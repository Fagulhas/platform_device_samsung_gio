From aab033d1ebbfa904dc6e55e679e4ffeef0cf028c Mon Sep 17 00:00:00 2001
From: streambinder <davidepucci@hiddenhost.org>
Date: Sat, 4 Oct 2014 16:11:57 +0200
Subject: [PATCH] frameworks/native: unified patch from Jellaxy original branch

---
 include/gui/SurfaceTexture.h                       |  79 +-----
 include/media/openmax/OMX_IVCommon.h               |   1 -
 include/ui/Overlay.h                               | 128 +++++++++
 include/ui/PixelFormat.h                           |   7 -
 include/ui/Region.h                                |  26 --
 libs/gui/Android.mk                                |   4 +
 libs/gui/SurfaceTexture.cpp                        | 268 ++----------------
 libs/ui/Android.mk                                 |   1 +
 libs/ui/GraphicBufferMapper.cpp                    |  13 +
 libs/ui/Overlay.cpp                                | 301 +++++++++++++++++++++
 libs/ui/PixelFormat.cpp                            |  16 --
 opengl/include/EGL/eglext.h                        |   2 -
 opengl/libs/EGL/eglApi.cpp                         |   4 -
 opengl/libs/EGL/egl_display.cpp                    |   2 -
 opengl/libs/EGL/egl_entries.in                     |   4 +-
 services/surfaceflinger/Android.mk                 |   4 +
 .../DisplayHardware/DisplayHardware.cpp            |  27 +-
 services/surfaceflinger/Layer.cpp                  |  54 ++--
 services/surfaceflinger/SurfaceFlinger.cpp         |  55 ----
 19 files changed, 542 insertions(+), 454 deletions(-)
 create mode 100644 include/ui/Overlay.h
 create mode 100644 libs/ui/Overlay.cpp

diff --git a/include/gui/SurfaceTexture.h b/include/gui/SurfaceTexture.h
index ec73f95..d116b21 100644
--- a/include/gui/SurfaceTexture.h
+++ b/include/gui/SurfaceTexture.h
@@ -31,11 +31,6 @@
 #include <utils/Vector.h>
 #include <utils/threads.h>
 
-#ifdef STE_HARDWARE
-#include <hardware/copybit.h>
-#include <gui/IGraphicBufferAlloc.h>
-#endif
-
 #define ANDROID_GRAPHICS_SURFACETEXTURE_JNI_ID "mSurfaceTexture"
 
 namespace android {
@@ -47,9 +42,6 @@ class String8;
 class SurfaceTexture : public virtual RefBase,
         protected BufferQueue::ConsumerListener {
 public:
-#ifdef STE_HARDWARE
-    enum { NUM_BLIT_BUFFER_SLOTS = 2 };
-#endif
     struct FrameAvailableListener : public virtual RefBase {
         // onFrameAvailable() is called each time an additional frame becomes
         // available for consumption. This means that frames that are queued
@@ -99,13 +91,6 @@ public:
     // target texture belongs is bound to the calling thread.
     status_t updateTexImage();
 
-#ifdef STE_HARDWARE
-    // convert() performs the deferred texture conversion as scheduled
-    // by updateTexImage(bool deferConversion).
-    // The method returns immediately if no conversion is necessary.
-    status_t convert();
-#endif
-
     // setBufferCountServer set the buffer count. If the client has requested
     // a buffer count using setBufferCount, the server-buffer count will
     // take effect once the client sets the count back to zero.
@@ -263,27 +248,16 @@ private:
         virtual ~BufferRejecter() { }
     };
     friend class Layer;
-#ifndef STE_HARDWARE
-    status_t updateTexImage(BufferRejecter* rejecter);
+#ifdef DECIDE_TEXTURE_TARGET
+    status_t updateTexImage(BufferRejecter* rejecter, bool isComposition=false);
 #else
-    // A surface that uses a non-native format requires conversion of
-    // its buffers. This conversion can be deferred until the layer
-    // based on this surface is drawn.
-    status_t updateTexImage(BufferRejecter* rejecter, bool deferConversion);
+    status_t updateTexImage(BufferRejecter* rejecter);
 #endif
 
     // createImage creates a new EGLImage from a GraphicBuffer.
     EGLImageKHR createImage(EGLDisplay dpy,
             const sp<GraphicBuffer>& graphicBuffer);
 
-#ifdef STE_HARDWARE
-    // returns TRUE if buffer needs color format conversion
-    bool conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer);
-
-    // converts buffer to a suitable color format
-    status_t convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf);
-#endif
-
     // freeBufferLocked frees up the given buffer slot.  If the slot has been
     // initialized this will release the reference to the GraphicBuffer in that
     // slot and destroy the EGLImage in that slot.  Otherwise it has no effect.
@@ -359,7 +333,11 @@ private:
     // glCopyTexSubImage to read from the texture.  This is a hack to work
     // around a GL driver limitation on the number of FBO attachments, which the
     // browser's tile cache exceeds.
+#ifdef DECIDE_TEXTURE_TARGET
+    GLenum mTexTarget;
+#else
     const GLenum mTexTarget;
+#endif
 
     // EGLSlot contains the information and object references that
     // SurfaceTexture maintains about a BufferQueue buffer slot.
@@ -379,15 +357,6 @@ private:
         // to EGL_NO_SYNC_KHR when the buffer is created and (optionally, based
         // on a compile-time option) set to a new sync object in updateTexImage.
         EGLSyncKHR mFence;
-
-#ifdef STE_HARDWARE
-    // mEglDisplay is the EGLDisplay with which this SurfaceTexture is currently
-    // associated.  It is intialized to EGL_NO_DISPLAY and gets set to the
-    // current display when updateTexImage is called for the first time and when
-    // attachToContext is called.
-    EGLDisplay mEglDisplay;
-#endif
-
     };
 
     // mEglDisplay is the EGLDisplay with which this SurfaceTexture is currently
@@ -396,40 +365,6 @@ private:
     // attachToContext is called.
     EGLDisplay mEglDisplay;
 
-#ifdef STE_HARDWARE
-    // mBlitEngine is the handle to the copybit device which will be used in
-    // case color transform is needed before the EGL image is created.
-    copybit_device_t* mBlitEngine;
-
-    // mBlitSlots contains several buffers which will
-    // be rendered alternately in case color transform is needed (instead
-    // of rendering the buffers in mSlots).
-    EGLSlot mBlitSlots[NUM_BLIT_BUFFER_SLOTS];
-
-    // mGraphicBufferAlloc is the connection to SurfaceFlinger that is used to
-    // allocate new GraphicBuffer objects.
-    sp<IGraphicBufferAlloc> mGraphicBufferAlloc;
-
-    // mNextBlitSlot is the index of the blitter buffer (in mBlitSlots) which
-    // will be used in the next color transform.
-    int mNextBlitSlot;
-
-    // mConversionSrcSlot designates the slot where source buffer
-    // for the last deferred updateTexImage is located.
-    int mConversionSrcSlot;
-
-    // mConversionBltSlot designates the slot where destination buffer
-    // for the last deferred updateTexImage is located.
-    int mConversionBltSlot;
-
-    // mNeedsConversion indicates that a format conversion is necessary
-    // before the layer based on this surface is drawn.
-    // This flag is set whenever updateTexImage() with deferred conversion
-    // is called. It is cleared once the layer is drawn,
-    // or when updateTexImage() w/o deferred conversion is called.
-    bool mNeedsConversion;
-#endif
-
     // mEglContext is the OpenGL ES context with which this SurfaceTexture is
     // currently associated.  It is initialized to EGL_NO_CONTEXT and gets set
     // to the current GL context when updateTexImage is called for the first
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index d73cf00..14ddaaa 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -162,7 +162,6 @@ typedef enum OMX_COLOR_FORMATTYPE {
      * */
     OMX_COLOR_FormatAndroidOpaque = 0x7F000789,
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
-    OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB = 0x7FA00000,
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
     OMX_QCOM_COLOR_FormatYVU420PackedSemiPlanar32m4ka = 0x7FA30C01,
diff --git a/include/ui/Overlay.h b/include/ui/Overlay.h
new file mode 100644
index 0000000..af2b849
--- /dev/null
+++ b/include/ui/Overlay.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_OVERLAY_H
+#define ANDROID_OVERLAY_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <utils/Errors.h>
+#include <binder/IInterface.h>
+#include <utils/RefBase.h>
+#include <utils/threads.h>
+#include <hardware/gralloc.h>
+
+#include <ui/PixelFormat.h>
+
+namespace android {
+
+typedef void* overlay_buffer_t;
+typedef uint32_t overlay_handle_t;
+
+class Overlay : public virtual RefBase
+{
+public:
+    typedef void (*QueueBufferHook)(void *data, void* buffer, size_t size);
+
+    enum Format {
+        FORMAT_YUV422SP,
+        FORMAT_YUV420SP,
+        FORMAT_YUV422I,
+        FORMAT_YUV420P,
+        FORMAT_RGB565,
+        FORMAT_RGBA8888,
+        FORMAT_UNKNOWN
+    };
+
+public:
+    Overlay(uint32_t width, uint32_t height, Format format, QueueBufferHook queueBuffer, void* data);
+
+    /* destroys this overlay */
+    void destroy();
+
+    /* get the HAL handle for this overlay */
+    overlay_handle_t getHandleRef() const;
+
+    /* blocks until an overlay buffer is available and return that buffer. */
+    status_t dequeueBuffer(overlay_buffer_t* buffer);
+
+    /* release the overlay buffer and post it */
+    status_t queueBuffer(overlay_buffer_t buffer);
+
+    /* change the width and height of the overlay */
+    status_t resizeInput(uint32_t width, uint32_t height);
+
+    status_t setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h) ;
+
+    status_t getCrop(uint32_t* x, uint32_t* y, uint32_t* w, uint32_t* h) ;
+
+    /* set the buffer attributes */
+    status_t setParameter(int param, int value);
+    status_t setFd(int fd);
+
+    /* returns the address of a given buffer if supported, NULL otherwise. */
+    void* getBufferAddress(overlay_buffer_t buffer);
+
+    /* get physical informations about the overlay */
+    uint32_t getWidth() const;
+    uint32_t getHeight() const;
+    int32_t getFormat() const;
+    int32_t getWidthStride() const;
+    int32_t getHeightStride() const;
+    int32_t getBufferCount() const;
+    status_t getStatus() const;
+
+public:
+    static int getBppFromFormat(Format format);
+    static Format getFormatFromString(const char* name);
+
+private:
+    virtual ~Overlay();
+
+    // C style hook
+    QueueBufferHook mQueueBufferHook;
+    void* mHookData;
+
+    // overlay data
+    static const uint32_t NUM_BUFFERS = 8;
+    static const uint32_t NUM_MIN_FREE_BUFFERS = 2;
+    uint32_t mNumFreeBuffers;
+
+    status_t mStatus;
+    uint32_t mWidth, mHeight;
+    Format mFormat;
+
+    // ashmem region
+    struct MappingData {
+        int fd;
+        size_t length;
+        uint32_t offset;
+        void *ptr;
+    };
+
+    MappingData mBuffers[NUM_BUFFERS];
+    bool mQueued[NUM_BUFFERS]; // true if buffer is currently queued
+
+    // queue/dequeue mutex
+    pthread_mutex_t mQueueMutex;
+};
+
+// ----------------------------------------------------------------------------
+
+}; // namespace android
+
+#endif // ANDROID_OVERLAY_H
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index 62eb9b4..9f3e267 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -64,13 +64,6 @@ enum {
     PIXEL_FORMAT_RGBA_5551   = HAL_PIXEL_FORMAT_RGBA_5551,  // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = HAL_PIXEL_FORMAT_RGBA_4444,  // 16-bit ARGB
     PIXEL_FORMAT_A_8         = 8,                           // 8-bit A
-#ifdef STE_HARDWARE
-    // Added Support for YUV42XMBN,
-    // Required for Copybit CC acceleration
-    PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
-    PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
-    PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
-#endif
 };
 
 typedef int32_t PixelFormat;
diff --git a/include/ui/Region.h b/include/ui/Region.h
index 9f4d329..f242f18 100644
--- a/include/ui/Region.h
+++ b/include/ui/Region.h
@@ -24,10 +24,6 @@
 
 #include <ui/Rect.h>
 
-#ifdef STE_HARDWARE
-#include <hardware/copybit.h>
-#endif
-
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -199,28 +195,6 @@ Region& Region::operator -= (const Region& rhs) {
 Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
-
-#ifdef STE_HARDWARE
-// ---------------------------------------------------------------------------
-
-struct region_iterator : public copybit_region_t {
-    region_iterator(const Region& region)
-        : b(region.begin()), e(region.end()) {
-        this->next = iterate;
-    }
-private:
-    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
-        region_iterator const* me = static_cast<region_iterator const*>(self);
-        if (me->b != me->e) {
-            *reinterpret_cast<Rect*>(rect) = *me->b++;
-            return 1;
-        }
-        return 0;
-    }
-    mutable Region::const_iterator b;
-    Region::const_iterator const e;
-};
-#endif
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index e71650f..e46b3fd 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -51,6 +51,10 @@ ifeq ($(TARGET_BOARD_PLATFORM), tegra)
 	LOCAL_CFLAGS += -DALLOW_DEQUEUE_CURRENT_BUFFER
 endif
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
 ifeq ($(BOARD_USES_QCOM_HARDWARE), true)
     LOCAL_C_INCLUDES += hardware/qcom/display/libgralloc
     LOCAL_C_INCLUDES += hardware/qcom/display/libqdutils
diff --git a/libs/gui/SurfaceTexture.cpp b/libs/gui/SurfaceTexture.cpp
index 21f3112..9012588 100644
--- a/libs/gui/SurfaceTexture.cpp
+++ b/libs/gui/SurfaceTexture.cpp
@@ -120,10 +120,6 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mUseFenceSync(false),
 #endif
     mTexTarget(texTarget),
-#ifdef STE_HARDWARE
-    mNextBlitSlot(0),
-    mNeedsConversion(false),
-#endif
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
     mAbandoned(false),
@@ -132,13 +128,6 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
 {
     // Choose a name using the PID and a process-unique ID.
     mName = String8::format("unnamed-%d-%d", getpid(), createProcessUniqueId());
-#ifdef STE_HARDWARE
-    sp<ISurfaceComposer> composer(ComposerService::getComposerService());
-    mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
-    if (mGraphicBufferAlloc == 0) {
-        ST_LOGE("createGraphicBufferAlloc() failed in SurfaceTexture()");
-    }
-#endif
     ST_LOGV("SurfaceTexture");
     if (bufferQueue == 0) {
         ST_LOGV("Creating a new BufferQueue");
@@ -151,21 +140,6 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
-#ifdef STE_HARDWARE
-
-    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
-        mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
-        mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
-    }
-
-    hw_module_t const* module;
-    mBlitEngine = 0;
-    if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
-        copybit_open(module, &mBlitEngine);
-    }
-    ALOGE_IF(!mBlitEngine, "\nCannot open copybit mBlitEngine=%p", mBlitEngine);
-#endif
-
     // Note that we can't create an sp<...>(this) in a ctor that will not keep a
     // reference once the ctor ends, as that would cause the refcount of 'this'
     // dropping to 0 at the end of the ctor.  Since all we need is a wp<...>
@@ -189,11 +163,6 @@ SurfaceTexture::~SurfaceTexture() {
     ST_LOGV("~SurfaceTexture");
 
     abandon();
-#ifdef STE_HARDWARE
-    if (mBlitEngine) {
-        copybit_close(mBlitEngine);
-    }
-#endif
 }
 
 status_t SurfaceTexture::setBufferCountServer(int bufferCount) {
@@ -211,18 +180,13 @@ status_t SurfaceTexture::setDefaultBufferSize(uint32_t w, uint32_t h)
 }
 
 status_t SurfaceTexture::updateTexImage() {
-#ifndef STE_HARDWARE
     return SurfaceTexture::updateTexImage(NULL);
-#else
-    return SurfaceTexture::updateTexImage(NULL, false);
-#define STE_DEFERDBG 0
-#endif
 }
 
-#ifndef STE_HARDWARE
-status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter) {
+#ifdef DECIDE_TEXTURE_TARGET
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool isComposition) {
 #else
-status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConversion) {
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter) {
 #endif
     ATRACE_CALL();
     ST_LOGV("updateTexImage");
@@ -286,7 +250,6 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
             return NO_ERROR;
         }
 
-#ifndef STE_HARDWARE
         // Update the GL texture object. We may have to do this even when
         // item.mGraphicBuffer == NULL, if we destroyed the EGLImage when
         // detaching from a context but the buffer has not been re-allocated.
@@ -304,6 +267,29 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
                 if(gpuSupportedFormat) {
                     image = createImage(dpy, mEGLSlots[buf].mGraphicBuffer);
                     mEGLSlots[buf].mEglImage = image;
+
+#ifdef DECIDE_TEXTURE_TARGET
+                // GPU is not efficient in handling GL_TEXTURE_EXTERNAL_OES
+                // texture target. Depending on the image format, decide,
+                // the texture target to be used
+
+                if(isComposition){
+                    switch (mEGLSlots[buf].mGraphicBuffer->format) {
+                        case HAL_PIXEL_FORMAT_RGBA_8888:
+                        case HAL_PIXEL_FORMAT_RGBX_8888:
+                        case HAL_PIXEL_FORMAT_RGB_888:
+                        case HAL_PIXEL_FORMAT_RGB_565:
+                        case HAL_PIXEL_FORMAT_BGRA_8888:
+                        case HAL_PIXEL_FORMAT_RGBA_5551:
+                        case HAL_PIXEL_FORMAT_RGBA_4444:
+                            mTexTarget = GL_TEXTURE_2D;
+                            break;
+                        default:
+                            mTexTarget = GL_TEXTURE_EXTERNAL_OES;
+                            break;
+                    }
+                }
+#endif
                     if (image == EGL_NO_IMAGE_KHR) {
                         // NOTE: if dpy was invalid, createImage() is guaranteed to
                         // fail. so we'd end up here.
@@ -312,102 +298,6 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
                 }
             }
         }
-#else
-        EGLImageKHR image;
-        EGLDisplay dpy = eglGetCurrentDisplay();
-        if (conversionIsNeeded(mEGLSlots[buf].mGraphicBuffer)) {
-            mNeedsConversion = deferConversion;
-            // If color conversion is needed we can't use the graphic buffers
-            // located in mSlots for the textures (wrong color format). Instead
-            // color convert it into a buffer in mBlitSlots and use that instead.
-            image = mBlitSlots[mNextBlitSlot].mEglImage;
-
-            // If there exists an image already, make sure that
-            // the dimensions match the current source buffer.
-            // Otherwise, destroy the buffer and let a new one be allocated.
-            if (image != EGL_NO_IMAGE_KHR &&
-                    mEGLSlots[buf].mGraphicBuffer != NULL &&
-                    mBlitSlots[mNextBlitSlot].mGraphicBuffer != NULL) {
-                sp<GraphicBuffer> &srcBuf = mEGLSlots[buf].mGraphicBuffer;
-                sp<GraphicBuffer> &bltBuf =
-                    mBlitSlots[mNextBlitSlot].mGraphicBuffer;
-                if (srcBuf->getWidth() != bltBuf->getWidth() ||
-                        srcBuf->getHeight() != bltBuf->getHeight()) {
-                    eglDestroyImageKHR(mBlitSlots[mNextBlitSlot].mEglDisplay,
-                        image);
-                    mBlitSlots[mNextBlitSlot].mEglImage = EGL_NO_IMAGE_KHR;
-                    mBlitSlots[mNextBlitSlot].mGraphicBuffer = NULL;
-                    image = EGL_NO_IMAGE_KHR;
-                }
-            }
-            if (image == EGL_NO_IMAGE_KHR) {
-                sp<GraphicBuffer> &srcBuf = mEGLSlots[buf].mGraphicBuffer;
-                status_t res = 0;
-
-                sp<GraphicBuffer> blitBuffer(
-                        mGraphicBufferAlloc->createGraphicBuffer(
-                                srcBuf->getWidth(), srcBuf->getHeight(),
-                                PIXEL_FORMAT_RGBA_8888, srcBuf->getUsage(),
-                                &res));
-                if (blitBuffer == 0) {
-                    ST_LOGE("updateTexImage: SurfaceComposer::createGraphicBuffer failed");
-                    return NO_MEMORY;
-                }
-                if (res != NO_ERROR) {
-                    ST_LOGW("updateTexImage: SurfaceComposer::createGraphicBuffer error=%#04x", res);
-                }
-                mBlitSlots[mNextBlitSlot].mGraphicBuffer = blitBuffer;
-
-                EGLDisplay dpy = eglGetCurrentDisplay();
-                image = createImage(dpy, blitBuffer);
-                mBlitSlots[mNextBlitSlot].mEglImage = image;
-                mBlitSlots[mNextBlitSlot].mEglDisplay = dpy;
-            }
-
-            if (deferConversion) {
-                item.mGraphicBuffer = mEGLSlots[buf].mGraphicBuffer;
-                mConversionSrcSlot = buf;
-                mConversionBltSlot = mNextBlitSlot;
-                // At this point item.mGraphicBuffer and image do not point
-                // at matching buffers. This is intentional as this
-                // surface might end up being taken care of by HWComposer,
-                // which needs access to the original buffer.
-                // GL however, is fed an EGLImage that is created from
-                // a conversion buffer. It will have its
-                // content updated once the surface is actually drawn
-                // in Layer::onDraw()
-            } else {
-                if (convert(mEGLSlots[buf].mGraphicBuffer,
-                        mBlitSlots[mNextBlitSlot].mGraphicBuffer) != OK) {
-                    ALOGE("updateTexImage: convert failed");
-                    return UNKNOWN_ERROR;
-                }
-                item.mGraphicBuffer = mBlitSlots[mNextBlitSlot].mGraphicBuffer;
-            }
-            // mBlitSlots contains several buffers (NUM_BLIT_BUFFER_SLOTS),
-            // advance (potentially wrap) the index
-            mNextBlitSlot = (mNextBlitSlot + 1) % NUM_BLIT_BUFFER_SLOTS;
-        } else {
-            mNeedsConversion = false;
-            image = mEGLSlots[buf].mEglImage ;
-            item.mGraphicBuffer = mEGLSlots[buf].mGraphicBuffer;
-            if (image == EGL_NO_IMAGE_KHR) {
-                EGLDisplay dpy = eglGetCurrentDisplay();
-                if (item.mGraphicBuffer == 0) {
-                    ST_LOGE("buffer at slot %d is null", buf);
-                    return BAD_VALUE;
-                }
-                image = createImage(dpy, item.mGraphicBuffer);
-                mEGLSlots[buf].mEglImage = image;
-                mEglDisplay = dpy;
-                if (image == EGL_NO_IMAGE_KHR) {
-                    // NOTE: if dpy was invalid, createImage() is guaranteed to
-                    // fail. so we'd end up here.
-                    return -EINVAL;
-                }
-            }
-        }
-#endif
 
         if (err == NO_ERROR) {
             GLint error;
@@ -415,14 +305,10 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
                 ST_LOGW("updateTexImage: clearing GL error: %#04x", error);
             }
 
-#ifndef STE_HARDWARE
             if(gpuSupportedFormat) {
-#endif
                 glBindTexture(mTexTarget, mTexName);
                 glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image);
-#ifndef STE_HARDWARE
             }
-#endif
             while ((error = glGetError()) != GL_NO_ERROR) {
                 ST_LOGE("updateTexImage: error binding external texture image %p "
                         "(slot %d): %#04x", image, buf, error);
@@ -463,11 +349,7 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
 
         // Update the SurfaceTexture state.
         mCurrentTexture = buf;
-#ifndef STE_HARDWARE
         mCurrentTextureBuf = mEGLSlots[buf].mGraphicBuffer;
-#else
-        mCurrentTextureBuf = item.mGraphicBuffer;
-#endif
         mCurrentCrop = item.mCrop;
         mCurrentTransform = item.mTransform;
         mCurrentScalingMode = item.mScalingMode;
@@ -660,18 +542,8 @@ bool SurfaceTexture::isExternalFormat(uint32_t format)
     case HAL_PIXEL_FORMAT_YV12:
     // Legacy/deprecated YUV formats
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-#ifdef STE_HARDWARE
-    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-#else
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
-#endif
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
-#ifdef STE_HARDWARE
-    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
-    case HAL_PIXEL_FORMAT_YCrCb_422_P:
-    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
-    case HAL_PIXEL_FORMAT_YCrCb_420_P:
-#endif
         return true;
     }
 
@@ -903,16 +775,6 @@ void SurfaceTexture::abandon() {
         for (int i =0; i < BufferQueue::NUM_BUFFER_SLOTS; i++) {
             freeBufferLocked(i);
         }
-#ifdef STE_HARDWARE
-    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
-        mBlitSlots[i].mGraphicBuffer = 0;
-        if (mBlitSlots[i].mEglImage != EGL_NO_IMAGE_KHR) {
-            eglDestroyImageKHR(mBlitSlots[i].mEglDisplay, mBlitSlots[i].mEglImage);
-            mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
-            mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
-        }
-    }
-#endif
 
         // disconnect from the BufferQueue
         mBufferQueue->consumerDisconnect();
@@ -1016,84 +878,6 @@ void SurfaceTexture::dump(String8& result, const char* prefix,
     }
 }
 
-#ifdef STE_HARDWARE
-bool SurfaceTexture::conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer) {
-    int fmt = graphicBuffer->getPixelFormat();
-    return (fmt == PIXEL_FORMAT_YCBCR42XMBN) || (fmt == PIXEL_FORMAT_YCbCr_420_P);
-}
-
-status_t SurfaceTexture::convert() {
-    if (!mNeedsConversion)
-        return NO_ERROR;
-
-    if (mConversionBltSlot < 0 ||
-            mConversionBltSlot >= NUM_BLIT_BUFFER_SLOTS ||
-            mConversionSrcSlot < 0 ||
-            mConversionSrcSlot >= BufferQueue::NUM_BUFFER_SLOTS) {
-        ALOGE_IF(STE_DEFERDBG, "%s: Incorrect setup for deferred "
-            "texture conversion:\n"
-            "mConversionSrcSlot=%d mConversionBltSlot=%d", __FUNCTION__,
-            mConversionSrcSlot, mConversionBltSlot);
-        return BAD_VALUE;
-    }
-
-    if (mEGLSlots[mConversionSrcSlot].mGraphicBuffer == NULL) {
-        ALOGI_IF(STE_DEFERDBG, "%s: NULL source for deferred texture conversion.",
-            __FUNCTION__);
-        return OK;
-    }
-
-    if (mBlitSlots[mConversionBltSlot].mGraphicBuffer == NULL) {
-        ALOGI_IF(STE_DEFERDBG, "%s: NULL destination for deferred "
-            "texture conversion.", __FUNCTION__);
-        return OK;
-    }
-
-    return convert(mEGLSlots[mConversionSrcSlot].mGraphicBuffer,
-        mBlitSlots[mConversionBltSlot].mGraphicBuffer);
-}
-
-status_t SurfaceTexture::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
-    copybit_image_t dstImg;
-    dstImg.w = dstBuf->getWidth();
-    dstImg.h = dstBuf->getHeight();
-    dstImg.format = dstBuf->getPixelFormat();
-    dstImg.handle = (native_handle_t*) dstBuf->getNativeBuffer()->handle;
-
-    copybit_image_t srcImg;
-    srcImg.w = srcBuf->getWidth();
-    srcImg.h = srcBuf->getHeight();
-    srcImg.format = srcBuf->getPixelFormat();
-    srcImg.base = NULL;
-    srcImg.handle = (native_handle_t*) srcBuf->getNativeBuffer()->handle;
-
-    copybit_rect_t dstCrop;
-    dstCrop.l = 0;
-    dstCrop.t = 0;
-    dstCrop.r = dstBuf->getWidth();
-    dstCrop.b = dstBuf->getHeight();
-
-    copybit_rect_t srcCrop;
-    srcCrop.l = 0;
-    srcCrop.t = 0;
-    srcCrop.r = srcBuf->getWidth();
-    srcCrop.b = srcBuf->getHeight();
-
-    region_iterator clip(Region(Rect(dstCrop.r, dstCrop.b)));
-    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_TRANSFORM, 0);
-    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_PLANE_ALPHA, 0xFF);
-    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_DITHER, COPYBIT_ENABLE);
-
-    int err = mBlitEngine->stretch(
-            mBlitEngine, &dstImg, &srcImg, &dstCrop, &srcCrop, &clip);
-    if (err != 0) {
-        ALOGE("\nError: Blit stretch operation failed (err:%d)\n", err);
-        return UNKNOWN_ERROR;
-    }
-    return OK;
-}
-#endif
-
 static void mtxMul(float out[16], const float a[16], const float b[16]) {
     out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
     out[1] = a[1]*b[0] + a[5]*b[1] + a[9]*b[2] + a[13]*b[3];
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index 719ddae..7fb522b 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -16,6 +16,7 @@ LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:= \
+        Overlay.cpp \
 	FramebufferNativeWindow.cpp \
 	GraphicBuffer.cpp \
 	GraphicBufferAllocator.cpp \
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index b7dd8ec..2aa28a3 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -75,10 +75,23 @@ status_t GraphicBufferMapper::lock(buffer_handle_t handle,
 {
     ATRACE_CALL();
     status_t err;
+#ifdef MISSING_GRALLOC_BUFFERS
+        int tries=5;
+#endif
 
     err = mAllocMod->lock(mAllocMod, handle, usage,
             bounds.left, bounds.top, bounds.width(), bounds.height(),
             vaddr);
+#ifdef MISSING_GRALLOC_BUFFERS
+    while (err && tries) {
+        sleep(1000);
+        err = mAllocMod->unlock(mAllocMod, handle);
+        err = mAllocMod->lock(mAllocMod, handle, usage,
+                                       bounds.left, bounds.top, bounds.width(), bounds.height(),
+                                       vaddr);
+        tries--;
+        }
+#endif
 
     ALOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
     return err;
diff --git a/libs/ui/Overlay.cpp b/libs/ui/Overlay.cpp
new file mode 100644
index 0000000..68c282b
--- /dev/null
+++ b/libs/ui/Overlay.cpp
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "Overlay"
+
+#include <binder/IMemory.h>
+#include <binder/Parcel.h>
+#include <utils/Errors.h>
+#include <binder/MemoryHeapBase.h>
+#include <cutils/ashmem.h>
+
+#include <ui/Overlay.h>
+
+namespace android {
+
+int Overlay::getBppFromFormat(const Format format)
+{
+    switch(format) {
+    case FORMAT_RGBA8888:
+        return 32;
+    case FORMAT_RGB565:
+    case FORMAT_YUV422I:
+    case FORMAT_YUV422SP:
+        return 16;
+    case FORMAT_YUV420SP:
+    case FORMAT_YUV420P:
+        return 12;
+    default:
+        ALOGW("%s: unhandled color format %d", __FUNCTION__, format);
+    }
+    return 32;
+}
+
+Overlay::Format Overlay::getFormatFromString(const char* name)
+{
+    if (strcmp(name, "yuv422sp") == 0) {
+        return FORMAT_YUV422SP;
+    } else if (strcmp(name, "yuv420sp") == 0) {
+        return FORMAT_YUV420SP;
+    } else if (strcmp(name, "yuv422i-yuyv") == 0) {
+        return FORMAT_YUV422I;
+    } else if (strcmp(name, "yuv420p") == 0) {
+        return FORMAT_YUV420P;
+    } else if (strcmp(name, "rgb565") == 0) {
+        return FORMAT_RGB565;
+    } else if (strcmp(name, "rgba8888") == 0) {
+        return FORMAT_RGBA8888;
+    }
+    ALOGW("%s: unhandled color format %s", __FUNCTION__, name);
+    return FORMAT_UNKNOWN;
+}
+
+Overlay::Overlay(uint32_t width, uint32_t height, Format format, QueueBufferHook queueBufferHook, void *data) :
+    mQueueBufferHook(queueBufferHook),
+    mHookData(data),
+    mNumFreeBuffers(0),
+    mStatus(NO_INIT),
+    mWidth(width),
+    mHeight(height),
+    mFormat(format)
+{
+    ALOGD("%s: Init overlay", __FUNCTION__);
+
+    int bpp = getBppFromFormat(format);
+    /* round up to next multiple of 8 */
+    if (bpp & 7) {
+        bpp = (bpp & ~7) + 8;
+    }
+
+    const int requiredMem = width * height * bpp;
+    const int bufferSize = (requiredMem + PAGE_SIZE - 1) & (~(PAGE_SIZE - 1));
+
+    int fd = ashmem_create_region("Overlay_buffer_region", NUM_BUFFERS * bufferSize);
+    if (fd < 0) {
+        ALOGE("%s: Cannot create ashmem region", __FUNCTION__);
+        return;
+    }
+
+    ALOGV("%s: allocated ashmem region for %d buffers of size %d", __FUNCTION__, NUM_BUFFERS, bufferSize);
+
+    for (uint32_t i = 0; i < NUM_BUFFERS; i++) {
+        mBuffers[i].fd = fd;
+        mBuffers[i].length = bufferSize;
+        mBuffers[i].offset = bufferSize * i;
+        ALOGV("%s: mBuffers[%d].offset = 0x%x", __FUNCTION__, i, mBuffers[i].offset);
+        mBuffers[i].ptr = mmap(NULL, bufferSize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, bufferSize * i);
+        if (mBuffers[i].ptr == MAP_FAILED) {
+            ALOGE("%s: Failed to mmap buffer %d", __FUNCTION__, i);
+            mBuffers[i].ptr = NULL;
+            continue;
+        }
+        mQueued[i] = false;
+    }
+
+    pthread_mutex_init(&mQueueMutex, NULL);
+
+    ALOGD("%s: Init overlay complete", __FUNCTION__);
+
+    mStatus = NO_ERROR;
+}
+
+Overlay::~Overlay() {
+}
+
+status_t Overlay::dequeueBuffer(overlay_buffer_t* buffer)
+{
+    ALOGV("%s", __FUNCTION__);
+    int rv = NO_ERROR;
+
+    pthread_mutex_lock(&mQueueMutex);
+
+    if (mNumFreeBuffers < NUM_MIN_FREE_BUFFERS) {
+        ALOGV("%s: No free buffers", __FUNCTION__);
+        rv = NO_MEMORY;
+    } else {
+        int index = -1;
+
+        for (uint32_t i = 0; i < NUM_BUFFERS; i++) {
+            if (mQueued[i]) {
+                mQueued[i] = false;
+                index = i;
+                break;
+            }
+        }
+
+        if (index >= 0) {
+            int *intBuffer = (int *) buffer;
+            *intBuffer = index;
+            mNumFreeBuffers--;
+            ALOGV("%s: dequeued buffer %d", __FUNCTION__, index);
+        } else {
+            ALOGE("%s: inconsistent queue state", __FUNCTION__);
+            rv = NO_MEMORY;
+        }
+    }
+
+    pthread_mutex_unlock(&mQueueMutex);
+    return rv;
+}
+
+status_t Overlay::queueBuffer(overlay_buffer_t buffer)
+{
+    uint32_t index = (uint32_t) buffer;
+    int rv;
+
+    ALOGV("%s: %d", __FUNCTION__, index);
+    if (index > NUM_BUFFERS) {
+        ALOGE("%s: invalid buffer index %d", __FUNCTION__, index);
+        return INVALID_OPERATION;
+    }
+
+    if (mQueueBufferHook) {
+        mQueueBufferHook(mHookData, mBuffers[index].ptr, mBuffers[index].length);
+    }
+
+    pthread_mutex_lock(&mQueueMutex);
+
+    if (mNumFreeBuffers < NUM_BUFFERS) {
+        mNumFreeBuffers++;
+        mQueued[index] = true;
+        rv = NO_ERROR;
+    } else {
+        ALOGW("%s: Attempt to queue more buffers than we have", __FUNCTION__);
+        rv = INVALID_OPERATION;
+    }
+
+    pthread_mutex_unlock(&mQueueMutex);
+
+    return mStatus;
+}
+
+status_t Overlay::resizeInput(uint32_t width, uint32_t height)
+{
+    ALOGW("%s: %d, %d", __FUNCTION__, width, height);
+    return mStatus;
+}
+
+status_t Overlay::setParameter(int param, int value)
+{
+    ALOGW("%s: %d, %d", __FUNCTION__, param, value);
+    return mStatus;
+}
+
+status_t Overlay::setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h)
+{
+    ALOGD("%s: x=%d, y=%d, w=%d, h=%d", __FUNCTION__, x, y, w, h);
+    return mStatus;
+}
+
+status_t Overlay::getCrop(uint32_t* x, uint32_t* y, uint32_t* w, uint32_t* h)
+{
+    ALOGW("%s", __FUNCTION__);
+    return mStatus;
+}
+
+status_t Overlay::setFd(int fd)
+{
+    ALOGW("%s: fd=%d", __FUNCTION__, fd);
+    return mStatus;
+}
+
+int32_t Overlay::getBufferCount() const
+{
+    ALOGV("%s: %d", __FUNCTION__, NUM_BUFFERS);
+    return NUM_BUFFERS;
+}
+
+void* Overlay::getBufferAddress(overlay_buffer_t buffer)
+{
+    uint32_t index = (uint32_t) buffer;
+
+    ALOGD("%s: %d", __FUNCTION__, index);
+    if (index >= NUM_BUFFERS) {
+        index = index % NUM_BUFFERS;
+    }
+
+    //ALOGD("%s: fd=%d, length=%d. offset=%d, ptr=%p", __FUNCTION__, mBuffers[index].fd,
+    //        mBuffers[index].length, mBuffers[index].offset, mBuffers[index].ptr);
+
+    return &mBuffers[index];
+}
+
+void Overlay::destroy()
+{
+    int fd = 0;
+
+    ALOGV("%s", __FUNCTION__);
+
+    for (uint32_t i = 0; i < NUM_BUFFERS; i++) {
+        if (mBuffers[i].ptr != NULL && munmap(mBuffers[i].ptr, mBuffers[i].length) < 0) {
+            ALOGW("%s: unmap of buffer %d failed", __FUNCTION__, i);
+        }
+        if (mBuffers[i].fd > 0) {
+            fd = mBuffers[i].fd;
+        }
+    }
+    if (fd > 0) {
+        close(fd);
+    }
+
+    pthread_mutex_destroy(&mQueueMutex);
+}
+
+status_t Overlay::getStatus() const
+{
+    ALOGV("%s", __FUNCTION__);
+    return mStatus;
+}
+
+overlay_handle_t Overlay::getHandleRef() const
+{
+    ALOGW("%s", __FUNCTION__);
+    return 0;
+}
+
+uint32_t Overlay::getWidth() const
+{
+    ALOGV("%s", __FUNCTION__);
+    return mWidth;
+}
+
+uint32_t Overlay::getHeight() const
+{
+    ALOGV("%s", __FUNCTION__);
+    return mHeight;
+}
+
+int32_t Overlay::getFormat() const
+{
+    ALOGV("%s", __FUNCTION__);
+    return mFormat;
+}
+
+int32_t Overlay::getWidthStride() const
+{
+    ALOGW("%s", __FUNCTION__);
+    return mWidth;
+}
+
+int32_t Overlay::getHeightStride() const
+{
+    ALOGW("%s", __FUNCTION__);
+    return mHeight;
+}
+
+}; // namespace android
diff --git a/libs/ui/PixelFormat.cpp b/libs/ui/PixelFormat.cpp
index 2135cb5..3ced41d 100644
--- a/libs/ui/PixelFormat.cpp
+++ b/libs/ui/PixelFormat.cpp
@@ -100,25 +100,9 @@ status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
     // YUV format from the HAL are handled here
     switch (format) {
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
-#ifdef STE_HARDWARE
-    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
-    case HAL_PIXEL_FORMAT_YCbCr_422_P:
-    case HAL_PIXEL_FORMAT_YCrCb_422_P:
-    case HAL_PIXEL_FORMAT_CbYCrY_422_I:
-#endif
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
         info->bitsPerPixel = 16;
         goto done;
-#ifdef STE_HARDWARE
-    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-    case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
-    case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
-    case HAL_PIXEL_FORMAT_YCbCr_420_P:
-    case HAL_PIXEL_FORMAT_YCrCb_420_P:
-    case HAL_PIXEL_FORMAT_YCbCr_420_I:
-    case HAL_PIXEL_FORMAT_CbYCrY_420_I:
-    case HAL_PIXEL_FORMAT_YCBCR42XMBN:
-#endif
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
     case HAL_PIXEL_FORMAT_YV12:
         info->bitsPerPixel = 12;
diff --git a/opengl/include/EGL/eglext.h b/opengl/include/EGL/eglext.h
index 3ccaf3a..540a547 100644
--- a/opengl/include/EGL/eglext.h
+++ b/opengl/include/EGL/eglext.h
@@ -237,7 +237,6 @@ struct ANativeWindowBuffer;
 
 /* EGL_NV_system_time
  */
-#ifndef STE_HARDWARE
 #ifndef EGL_NV_system_time
 #define EGL_NV_system_time 1
 typedef khronos_int64_t EGLint64NV;
@@ -249,7 +248,6 @@ EGLAPI EGLuint64NV EGLAPIENTRY eglGetSystemTimeNV(void);
 typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMEFREQUENCYNVPROC)(void);
 typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMENVPROC)(void);
 #endif
-#endif
 
 /* EGL_ANDROID_blob_cache
  */
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 3d1e834..3d44bbe 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -72,12 +72,10 @@ static const extention_map_t sExtentionMap[] = {
             (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR },
     { "eglGetRenderBufferANDROID",
         (__eglMustCastToProperFunctionPointerType)&eglGetRenderBufferANDROID },
-#ifndef STE_HARDWARE
     { "eglGetSystemTimeFrequencyNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
     { "eglGetSystemTimeNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-#endif
 };
 
 // accesses protected by sExtensionMapMutex
@@ -1214,7 +1212,6 @@ EGLClientBuffer eglGetRenderBufferANDROID(EGLDisplay dpy, EGLSurface draw)
 // ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
-#ifndef STE_HARDWARE
 EGLuint64NV eglGetSystemTimeFrequencyNV()
 {
     clearError();
@@ -1250,4 +1247,3 @@ EGLuint64NV eglGetSystemTimeNV()
 
     return setErrorQuiet(EGL_BAD_DISPLAY, 0);
 }
-#endif
diff --git a/opengl/libs/EGL/egl_display.cpp b/opengl/libs/EGL/egl_display.cpp
index bb4ac03..b6bdca4 100644
--- a/opengl/libs/EGL/egl_display.cpp
+++ b/opengl/libs/EGL/egl_display.cpp
@@ -52,9 +52,7 @@ static char const * const sExtensionString  =
         "EGL_KHR_gl_texture_cubemap_image "
         "EGL_KHR_gl_renderbuffer_image "
         "EGL_KHR_fence_sync "
-#ifndef STE_HARDWARE
         "EGL_NV_system_time "
-#endif
         "EGL_ANDROID_image_native_buffer "      // mandatory
         ;
 
diff --git a/opengl/libs/EGL/egl_entries.in b/opengl/libs/EGL/egl_entries.in
index 4968748..9feb716 100644
--- a/opengl/libs/EGL/egl_entries.in
+++ b/opengl/libs/EGL/egl_entries.in
@@ -64,10 +64,10 @@ EGL_ENTRY(EGLBoolean, eglSetSwapRectangleANDROID, EGLDisplay, EGLSurface, EGLint
 EGL_ENTRY(EGLClientBuffer, eglGetRenderBufferANDROID, EGLDisplay, EGLSurface)
 
 /* NVIDIA extensions */
-#ifndef STE_HARDWARE
+
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeFrequencyNV, void)
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeNV, void)
-#endif
+
 /* IMG extensions */
 
 EGL_ENTRY(EGLBoolean, eglHibernateProcessIMG, void)
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index a0b298b..e466bc5 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -32,6 +32,10 @@ ifeq ($(TARGET_DISABLE_TRIPLE_BUFFERING), true)
 	LOCAL_CFLAGS += -DTARGET_DISABLE_TRIPLE_BUFFERING
 endif
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
 LOCAL_SHARED_LIBRARIES := \
 	libcutils \
 	libhardware \
diff --git a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
index f306440..1f85afc 100644
--- a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
+++ b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
@@ -160,12 +160,7 @@ void DisplayHardware::init(uint32_t dpy)
     window->query(window, NATIVE_WINDOW_FORMAT, &format);
     mDpiX = mNativeWindow->xdpi;
     mDpiY = mNativeWindow->ydpi;
-#ifndef REFRESH_RATE
     mRefreshRate = fbDev->fps;
-#else
-    mRefreshRate = REFRESH_RATE;
-#endif
-    mRefreshPeriod = nsecs_t(1e9 / mRefreshRate);
 
     if (mDpiX == 0 || mDpiY == 0) {
         ALOGE("invalid screen resolution from fb HAL (xdpi=%f, ydpi=%f), "
@@ -206,6 +201,20 @@ void DisplayHardware::init(uint32_t dpy)
         mDensity /= 160.0f;
     }
 
+
+
+    /* FIXME: this is a temporary HACK until we are able to report the refresh rate
+     * properly from the HAL. The WindowManagerService now relies on this value.
+     */
+#ifndef REFRESH_RATE
+    mRefreshRate = fbDev->fps;
+#else
+    mRefreshRate = REFRESH_RATE;
+#warning "refresh rate set via makefile to REFRESH_RATE"
+#endif
+
+    mRefreshPeriod = nsecs_t(1e9 / mRefreshRate);
+
     EGLint w, h, dummy;
     EGLint numConfigs=0;
     EGLSurface surface;
@@ -238,8 +247,12 @@ void DisplayHardware::init(uint32_t dpy)
     eglGetConfigs(display, NULL, 0, &numConfigs);
 
     EGLConfig config = NULL;
+#ifdef FORCE_EGL_CONFIG
+    config = (EGLConfig)FORCE_EGL_CONFIG;
+#else
     err = selectConfigForPixelFormat(display, attribs, format, &config);
     ALOGE_IF(err, "couldn't find an EGLConfig matching the screen format");
+#endif
     
     EGLint r,g,b,a;
     eglGetConfigAttrib(display, config, EGL_RED_SIZE,   &r);
@@ -447,10 +460,6 @@ void DisplayHardware::flip(const Region& dirty) const
     if (mHwc->initCheck() == NO_ERROR) {
         mHwc->commit();
     } else {
-#ifdef STE_HARDWARE
-        // Make sure the swapbuffer call is done in sync
-        mNativeWindow->compositionComplete();
-#endif
         eglSwapBuffers(dpy, surface);
     }
     checkEGLErrors("eglSwapBuffers");
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 520a9fb..9bd5f5a 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -332,18 +332,6 @@ void Layer::setPerFrameData(hwc_layer_t* hwcl) {
 
 void Layer::onDraw(const Region& clip) const
 {
-#ifdef STE_HARDWARE
-    // Convert the texture to a native format if need be.
-    // convert() returns immediately if no conversion is necessary.
-    if (mSurfaceTexture != NULL) {
-        status_t res = mSurfaceTexture->convert();
-        if (res != NO_ERROR) {
-            ALOGE("Layer::onDraw: texture conversion failed. "
-                "Texture content for this layer will not be initialized.");
-        }
-    }
-#endif
-
     ATRACE_CALL();
 
     if (CC_UNLIKELY(mActiveBuffer == 0)) {
@@ -378,6 +366,9 @@ void Layer::onDraw(const Region& clip) const
         clearWithOpenGL(clip, 0, 0, 0, 1);
         return;
     }
+#ifdef DECIDE_TEXTURE_TARGET
+    GLuint currentTextureTarget = mSurfaceTexture->getCurrentTextureTarget();
+#endif
 #endif
     if (!isProtected()) {
         // TODO: we could be more subtle with isFixedSize()
@@ -389,25 +380,46 @@ void Layer::onDraw(const Region& clip) const
         mSurfaceTexture->getTransformMatrix(textureMatrix);
 
         // Set things up for texturing.
+#ifdef DECIDE_TEXTURE_TARGET
+        glBindTexture(currentTextureTarget, mTextureName);
+#else
         glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+#endif
         GLenum filter = GL_NEAREST;
         if (useFiltering) {
             filter = GL_LINEAR;
         }
+#ifdef DECIDE_TEXTURE_TARGET
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MAG_FILTER, filter);
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MIN_FILTER, filter);
+#else
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, filter);
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, filter);
+#endif
         glMatrixMode(GL_TEXTURE);
         glLoadMatrixf(textureMatrix);
         glMatrixMode(GL_MODELVIEW);
         glDisable(GL_TEXTURE_2D);
+#ifdef DECIDE_TEXTURE_TARGET
+        glEnable(currentTextureTarget);
+#else
         glEnable(GL_TEXTURE_EXTERNAL_OES);
+#endif
     } else {
+#ifdef DECIDE_TEXTURE_TARGET
+        glBindTexture(currentTextureTarget, mFlinger->getProtectedTexName());
+#else
         glBindTexture(GL_TEXTURE_2D, mFlinger->getProtectedTexName());
+#endif
         glMatrixMode(GL_TEXTURE);
         glLoadIdentity();
         glMatrixMode(GL_MODELVIEW);
+#ifdef DECIDE_TEXTURE_TARGET
+        glEnable(currentTextureTarget);
+#else
         glDisable(GL_TEXTURE_EXTERNAL_OES);
         glEnable(GL_TEXTURE_2D);
+#endif
     }
 
     drawWithOpenGL(clip);
@@ -658,12 +670,17 @@ void Layer::lockPageFlip(bool& recomputeVisibleRegions)
 
         Reject r(mDrawingState, currentState(), recomputeVisibleRegions);
 
-#ifndef STE_HARDWARE
-        if (mSurfaceTexture->updateTexImage(&r) < NO_ERROR) {
+#ifdef DECIDE_TEXTURE_TARGET
+        // While calling updateTexImage() from SurfaceFlinger, let it know
+        // by passing an extra parameter
+        // This will be true always.
+
+        bool isComposition = true;
+
+        if (mSurfaceTexture->updateTexImage(&r, isComposition) < NO_ERROR) {
 #else
-        if (mSurfaceTexture->updateTexImage(&r, true) < NO_ERROR) {
+        if (mSurfaceTexture->updateTexImage(&r) < NO_ERROR) {
 #endif
-
             // something happened!
             recomputeVisibleRegions = true;
             return;
@@ -804,7 +821,12 @@ uint32_t Layer::getEffectiveUsage(uint32_t usage) const
         // need a hardware-protected path to external video sink
         usage |= GraphicBuffer::USAGE_PROTECTED;
     }
+#ifdef MISSING_GRALLOC_BUFFERS
+    usage |= GraphicBuffer::USAGE_HW_TEXTURE;
+#else
     usage |= GraphicBuffer::USAGE_HW_COMPOSER;
+#endif
+
     return usage;
 }
 
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 17a810e..3ca2297 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -479,16 +479,12 @@ void SurfaceFlinger::onMessageReceived(int32_t what)
             if (CC_LIKELY(hw.canDraw())) {
                 // repaint the framebuffer (if needed)
                 handleRepaint();
-#ifndef STE_HARDWARE
                 // inform the h/w that we're done compositing
                 hw.compositionComplete();
-#endif
                 postFramebuffer();
             } else {
-#ifdef STE_HARDWARE
                 // pretend we did the post
                 hw.compositionComplete();
-#endif
             }
 
         } break;
@@ -895,10 +891,8 @@ void SurfaceFlinger::handleRepaint()
 
     // set the frame buffer
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
-#ifndef STE_HARDWARE
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
-#endif
 
     uint32_t flags = hw.getFlags();
     if (flags & DisplayHardware::SWAP_RECTANGLE) {
@@ -928,15 +922,8 @@ void SurfaceFlinger::handleRepaint()
     mDirtyRegion.clear();
 }
 
-#ifdef STE_HARDWARE
-static bool checkDrawingWithGL(hwc_layer_t* const layers, size_t layerCount);
-#endif
-
 void SurfaceFlinger::setupHardwareComposer()
 {
-#ifdef STE_HARDWARE
-    bool useGL = true;
-#endif
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
     HWComposer& hwc(hw.getHwComposer());
     hwc_layer_t* const cur(hwc.getLayers());
@@ -966,40 +953,8 @@ void SurfaceFlinger::setupHardwareComposer()
     }
     status_t err = hwc.prepare();
     ALOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err));
-#ifdef STE_HARDWARE
-    /*
-     * Check if GL will be used
-     */
-    useGL = checkDrawingWithGL(cur, count);
-
-    if (!useGL) {
-        return;
-    }
-    glMatrixMode(GL_MODELVIEW);
-    glLoadIdentity();
-    if (CC_UNLIKELY(!mWormholeRegion.isEmpty())) {
-        // should never happen unless the window manager has a bug
-        // draw something...
-        drawWormhole();
-    }
-#endif
 }
 
-#ifdef STE_HARDWARE
-static bool checkDrawingWithGL(hwc_layer_t* const layers, size_t layerCount)
-{
-    bool useGL = false;
-    if (layers) {
-        for (size_t i=0 ; i<layerCount ; i++) {
-            if (layers[i].compositionType == HWC_FRAMEBUFFER) {
-                useGL = true;
-            }
-        }
-    }
-    return useGL;
-}
-#endif
-
 void SurfaceFlinger::composeSurfaces(const Region& dirty)
 {
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
@@ -1026,7 +981,6 @@ void SurfaceFlinger::composeSurfaces(const Region& dirty)
                  glClear(GL_COLOR_BUFFER_BIT);
              }
         } else {
-#ifndef STE_HARDWARE
             // screen is already cleared here
             if (!mWormholeRegion.isEmpty()) {
                 // can happen with SurfaceView
@@ -1036,7 +990,6 @@ void SurfaceFlinger::composeSurfaces(const Region& dirty)
 #endif
                     drawWormhole();
             }
-#endif
         }
 
         /*
@@ -2588,9 +2541,7 @@ status_t SurfaceFlinger::captureScreenImplLocked(DisplayID dpy,
     glDeleteRenderbuffersOES(1, &tname);
     glDeleteFramebuffersOES(1, &name);
 
-#ifdef STE_HARDWARE
     hw.compositionComplete();
-#endif
 
     // ALOGD("screenshot: result = %s", result<0 ? strerror(result) : "OK");
 
@@ -2818,15 +2769,9 @@ sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h
         if (err == NO_MEMORY) {
             GraphicBuffer::dumpAllocationsToSystemLog();
         }
-#ifndef STE_HARDWARE
         ALOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) "
              "failed (%s), handle=%p",
                 w, h, strerror(-err), graphicBuffer->handle);
-#else
-        ALOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d, format=%#x) "
-             "failed (%s), handle=%p",
-                w, h, format, strerror(-err), graphicBuffer->handle);
-#endif
         return 0;
     }
     return graphicBuffer;
-- 
2.1.2
