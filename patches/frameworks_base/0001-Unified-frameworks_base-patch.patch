From c673252a14935dc3d35e12b930d7a37c64029299 Mon Sep 17 00:00:00 2001
From: streambinder <davidepucci@hiddenhost.org>
Date: Thu, 26 Jun 2014 23:00:20 +0200
Subject: [PATCH] Unified frameworks_base patch

---
 cmds/stagefright/Android.mk                        |   20 +-
 cmds/stagefright/recordvideo.cpp                   |    3 +
 cmds/surfaceflinger/Android.mk                     |    4 +
 cmds/system_server/library/Android.mk              |    4 +
 core/java/android/hardware/Camera.java             | 1338 +++++++++++++--
 core/java/android/os/Power.java                    |    8 +
 core/java/android/os/SystemProperties.java         |    4 +
 core/java/android/provider/Settings.java           |    6 +
 core/java/android/view/GLES20Canvas.java           |   16 +
 core/java/android/view/HardwareCanvas.java         |    2 +
 core/java/android/view/HardwareRenderer.java       |   59 +-
 core/java/android/view/Surface.java                |   12 +
 core/java/android/view/SurfaceHolder.java          |   21 +
 core/java/android/view/SurfaceView.java            |   12 +-
 core/java/org/codeaurora/Performance.java          |   63 +
 core/jni/Android.mk                                |   18 +-
 core/jni/AndroidRuntime.cpp                        |    8 +
 core/jni/android_hardware_Camera.cpp               |   42 +
 core/jni/android_net_TrafficStats.cpp              |    3 +
 core/jni/android_net_wifi_Wifi.cpp                 |   18 +
 core/jni/android_os_Power.cpp                      |   12 +
 core/jni/android_view_GLES20Canvas.cpp             |   22 +-
 core/jni/android_view_Surface.cpp                  |   14 +
 core/jni/org_codeaurora_Performance.cpp            |  162 ++
 core/res/res/values/config.xml                     |   38 +
 core/res/res/values/strings.xml                    |    1 +
 include/binder/IMemory.h                           |    2 +
 include/binder/MemoryHeapBase.h                    |    6 +-
 include/binder/Parcel.h                            |    4 +
 include/camera/Camera.h                            |    3 +
 include/camera/CameraParameters.h                  |  312 +++-
 include/gui/ISurfaceTexture.h                      |   14 +
 include/gui/SurfaceTexture.h                       |   22 +-
 include/gui/SurfaceTextureClient.h                 |   20 +
 include/media/AudioSystem.h                        |   13 +
 include/media/AudioTrack.h                         |   34 +-
 include/media/IAudioFlinger.h                      |   46 +-
 include/media/IAudioPolicyService.h                |   14 +
 include/media/MediaPlayerInterface.h               |   14 +
 include/media/MediaProfiles.h                      |   15 +-
 include/media/mediarecorder.h                      |   12 +
 include/media/stagefright/ACodec.h                 |   20 +
 include/media/stagefright/AudioPlayer.h            |   22 +-
 include/media/stagefright/ColorConverter.h         |   46 +
 include/media/stagefright/DataSource.h             |   11 +
 include/media/stagefright/ExtendedExtractorFuncs.h |   55 +
 include/media/stagefright/ExtendedWriter.h         |  126 ++
 include/media/stagefright/LPAPlayer.h              |  344 ++++
 include/media/stagefright/MediaDefs.h              |   16 +
 include/media/stagefright/MediaErrors.h            |    5 +
 include/media/stagefright/MetaData.h               |   44 +
 include/media/stagefright/OMXCodec.h               |   54 +-
 include/media/stagefright/SurfaceMediaSource.h     |   12 +
 include/media/stagefright/Utils.h                  |   15 +
 include/media/stagefright/openmax/OMX_IVCommon.h   |    2 +
 include/surfaceflinger/IGraphicBufferAlloc.h       |   14 +
 include/surfaceflinger/Surface.h                   |    3 +
 include/ui/FramebufferNativeWindow.h               |   10 +-
 include/ui/GraphicBuffer.h                         |    3 +
 include/ui/GraphicBufferAllocator.h                |    3 +
 include/ui/GraphicBufferMapper.h                   |    4 +
 include/ui/KeycodeLabels.h                         |   20 +
 include/ui/Overlay.h                               |  128 ++
 libs/binder/Android.mk                             |    5 +
 libs/binder/IMemory.cpp                            |   37 +-
 libs/binder/MemoryHeapBase.cpp                     |   24 +-
 libs/binder/Parcel.cpp                             |   17 +-
 libs/camera/CameraParameters.cpp                   |  405 ++++-
 libs/gui/Android.mk                                |   18 +-
 libs/gui/IGraphicBufferAlloc.cpp                   |   51 +
 libs/gui/ISurfaceTexture.cpp                       |   33 +
 libs/gui/Surface.cpp                               |    8 +
 libs/gui/SurfaceTexture.cpp                        |  147 +-
 libs/gui/SurfaceTextureClient.cpp                  |  108 ++
 libs/hwui/Android.mk                               |    1 +
 libs/hwui/Caches.cpp                               |   13 +
 libs/hwui/Caches.h                                 |    8 +
 libs/hwui/DisplayListRenderer.cpp                  |    7 +
 libs/hwui/DisplayListRenderer.h                    |    8 +-
 libs/hwui/FontRenderer.cpp                         |    4 +
 libs/hwui/GradientCache.h                          |    1 +
 libs/hwui/LayerRenderer.cpp                        |    2 +
 libs/hwui/OpenGLRenderer.cpp                       |   12 +
 libs/hwui/OpenGLRenderer.h                         |    4 +-
 libs/hwui/TextureCache.h                           |    1 +
 libs/rs/driver/rsdAllocation.cpp                   |    4 +-
 libs/rs/driver/rsdGL.cpp                           |    6 +
 libs/rs/rsAllocation.cpp                           |    8 +-
 libs/rs/rsContext.cpp                              |   16 +
 libs/rs/rsThreadIO.cpp                             |    9 +-
 libs/ui/Android.mk                                 |    3 +-
 libs/ui/FramebufferNativeWindow.cpp                |   66 +-
 libs/ui/GraphicBufferAllocator.cpp                 |    9 +
 libs/ui/GraphicBufferMapper.cpp                    |   27 +
 libs/ui/Overlay.cpp                                |  301 ++++
 libs/utils/Android.mk                              |    2 +-
 media/libmedia/Android.mk                          |   28 +-
 media/libmedia/AudioRecord.cpp                     |   32 +
 media/libmedia/AudioSystem.cpp                     |  130 ++
 media/libmedia/AudioTrack.cpp                      |  239 ++-
 media/libmedia/IAudioFlinger.cpp                   |  323 +++-
 media/libmedia/IAudioFlingerClient.cpp             |    5 +
 media/libmedia/IAudioPolicyService.cpp             |  108 ++
 media/libmedia/JetPlayer.cpp                       |    4 +
 media/libmedia/MediaProfiles.cpp                   |   46 +-
 media/libmediaplayerservice/Android.mk             |    2 +-
 media/libmediaplayerservice/MediaPlayerService.cpp |   80 +-
 media/libmediaplayerservice/MediaPlayerService.h   |   21 +-
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  235 +++
 media/libmediaplayerservice/StagefrightRecorder.h  |    8 +
 .../nuplayer/HTTPLiveSource.cpp                    |   11 +-
 .../nuplayer/HTTPLiveSource.h                      |    3 +-
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |   75 +-
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |    2 +
 .../nuplayer/NuPlayerSource.h                      |    2 +-
 media/libstagefright/ACodec.cpp                    |  533 +++++-
 media/libstagefright/AMRExtractor.cpp              |    4 +-
 media/libstagefright/Android.mk                    |   78 +-
 media/libstagefright/AudioPlayer.cpp               |   24 +-
 media/libstagefright/AwesomePlayer.cpp             |  296 +++-
 media/libstagefright/CameraSource.cpp              |   32 +-
 media/libstagefright/DataSource.cpp                |   65 +-
 media/libstagefright/ExtendedExtractor.cpp         |  152 ++
 media/libstagefright/ExtendedWriter.cpp            |  386 +++++
 media/libstagefright/FLACExtractor.cpp             |    8 +-
 media/libstagefright/LPAPlayer.cpp                 | 1692 +++++++++++++++++++
 media/libstagefright/LPAPlayerALSA.cpp             | 1739 ++++++++++++++++++++
 media/libstagefright/LPAPlayerION.cpp              |  168 ++
 media/libstagefright/LPAPlayerPMEM.cpp             |  129 ++
 media/libstagefright/MPEG4Extractor.cpp            |  144 +-
 media/libstagefright/MPEG4Writer.cpp               |   74 +-
 media/libstagefright/MediaDefs.cpp                 |   15 +
 media/libstagefright/MediaExtractor.cpp            |   11 +
 media/libstagefright/OMXCodec.cpp                  | 1491 ++++++++++++++++-
 media/libstagefright/OggExtractor.cpp              |    2 +-
 media/libstagefright/SampleIterator.cpp            |    2 +-
 media/libstagefright/SampleTable.cpp               |   11 +-
 media/libstagefright/StagefrightMediaScanner.cpp   |    8 +-
 .../StagefrightMetadataRetriever.cpp               |   45 +-
 media/libstagefright/SurfaceMediaSource.cpp        |   21 +
 media/libstagefright/Utils.cpp                     |  243 +++
 media/libstagefright/WAVExtractor.cpp              |    2 +-
 .../chromium_http/ChromiumHTTPDataSource.cpp       |    2 +
 media/libstagefright/codecs/aacdec/AACDecoder.cpp  |  504 ++++++
 media/libstagefright/codecs/aacdec/Android.mk      |  162 +-
 .../codecs/m4v_h263/dec/SoftMPEG4.cpp              |    7 +-
 media/libstagefright/codecs/mp3dec/Android.mk      |   64 +-
 media/libstagefright/codecs/mp3dec/MP3Decoder.cpp  |  586 +++++++
 media/libstagefright/colorconversion/Android.mk    |    4 +
 .../colorconversion/ColorConverter.cpp             |   62 +
 .../colorconversion/SoftwareRenderer.cpp           |   65 +-
 media/libstagefright/httplive/LiveSession.cpp      |  169 +-
 media/libstagefright/httplive/M3UParser.cpp        |    3 -
 media/libstagefright/include/AACDecoder.h          |    9 +-
 media/libstagefright/include/AwesomePlayer.h       |   26 +
 .../include/ChromiumHTTPDataSource.h               |    2 +
 media/libstagefright/include/ColorFormat.h         |   30 +
 media/libstagefright/include/ExtendedExtractor.h   |   48 +
 media/libstagefright/include/LiveSession.h         |    6 +-
 media/libstagefright/include/MP3Decoder.h          |    3 +
 media/libstagefright/include/OMXNodeInstance.h     |    3 +
 media/libstagefright/include/SampleTable.h         |    2 +-
 media/libstagefright/include/SoftwareRenderer.h    |    3 +
 .../libstagefright/matroska/MatroskaExtractor.cpp  |   24 +-
 media/libstagefright/mpeg2ts/ATSParser.cpp         |   41 +-
 .../libstagefright/mpeg2ts/AnotherPacketSource.cpp |    9 +
 media/libstagefright/omx/Android.mk                |    4 +
 media/libstagefright/omx/OMX.cpp                   |   12 +-
 media/libstagefright/omx/OMXMaster.cpp             |    5 +
 media/libstagefright/omx/OMXNodeInstance.cpp       |   17 +
 media/mediaserver/Android.mk                       |   10 +
 media/mediaserver/main_mediaserver.cpp             |   18 +
 obex/javax/obex/ClientOperation.java               |   13 +-
 obex/javax/obex/Operation.java                     |    4 +-
 obex/javax/obex/ServerOperation.java               |   36 +-
 opengl/include/EGL/eglext.h                        |   14 +
 opengl/include/GLES/glext.h                        |    4 +
 opengl/include/GLES2/gl2ext.h                      |    8 +
 opengl/java/android/opengl/GLSurfaceView.java      |    1 +
 opengl/libagl/Android.mk                           |    3 +
 opengl/libagl/egl.cpp                              |   42 +
 opengl/libagl/state.cpp                            |    2 +
 opengl/libs/Android.mk                             |   43 +-
 opengl/libs/EGL/eglApi.cpp                         |   24 +
 opengl/libs/EGL/egl_display.cpp                    |    3 +
 opengl/libs/GLES2/gl2.cpp                          |   11 +-
 opengl/libs/GLES_CM/gl.cpp                         |   11 +-
 .../android/systemui/usb/StorageNotification.java  |   20 +-
 services/audioflinger/Android.mk                   |   12 +
 services/camera/libcameraservice/Android.mk        |    4 +
 .../libcameraservice/CameraHardwareInterface.h     |   19 +-
 services/camera/libcameraservice/CameraService.cpp |  111 +-
 services/camera/libcameraservice/CameraService.h   |    5 +-
 services/input/Android.mk                          |    4 +
 services/input/InputReader.cpp                     |   32 +
 services/java/com/android/server/MountService.java |  175 +-
 .../android/server/NetworkManagementService.java   |   15 +-
 .../android/server/am/ActivityManagerService.java  |    2 +-
 .../android/server/usb/LegacyUsbDeviceManager.java |  655 ++++++++
 .../com/android/server/usb/UsbDeviceManager.java   |   16 +-
 .../java/com/android/server/usb/UsbService.java    |    3 +
 services/surfaceflinger/Android.mk                 |   27 +-
 .../DisplayHardware/DisplayHardware.cpp            |   17 +-
 .../DisplayHardware/DisplayHardware.h              |    7 +
 .../DisplayHardware/DisplayHardwareBase.cpp        |   18 +-
 .../surfaceflinger/DisplayHardware/HWComposer.cpp  |   34 +
 .../surfaceflinger/DisplayHardware/HWComposer.h    |    6 +
 services/surfaceflinger/Layer.cpp                  |  180 +-
 services/surfaceflinger/Layer.h                    |    8 +
 services/surfaceflinger/LayerBase.cpp              |  146 ++
 services/surfaceflinger/LayerBase.h                |   16 +-
 services/surfaceflinger/LayerScreenshot.cpp        |   10 +
 services/surfaceflinger/SurfaceFlinger.cpp         |  272 ++-
 services/surfaceflinger/SurfaceFlinger.h           |   33 +-
 services/surfaceflinger/SurfaceTextureLayer.cpp    |   21 +
 services/surfaceflinger/SurfaceTextureLayer.h      |    4 +
 .../android/telephony/NeighboringCellInfo.java     |   10 +-
 .../java/android/telephony/PhoneNumberUtils.java   |    7 +
 .../com/android/internal/telephony/AdnRecord.java  |    2 +-
 .../android/internal/telephony/BaseCommands.java   |    1 +
 .../android/internal/telephony/CallManager.java    |   25 +
 .../internal/telephony/CommandsInterface.java      |   12 +
 .../android/internal/telephony/DataCallState.java  |    2 +-
 .../android/internal/telephony/DataConnection.java |   17 +-
 .../internal/telephony/DataConnectionTracker.java  |    8 +
 .../android/internal/telephony/HTCQualcommRIL.java |  165 ++
 .../com/android/internal/telephony/HuaweiRIL.java  |  909 ++++++++++
 .../com/android/internal/telephony/IccCard.java    |    4 +-
 .../internal/telephony/IccCardApplication.java     |    5 +
 .../android/internal/telephony/IccCardStatus.java  |    6 +-
 .../internal/telephony/IccSmsInterfaceManager.java |   13 +
 .../com/android/internal/telephony/IccUtils.java   |   45 +
 .../com/android/internal/telephony/JellaxyRIL.java |  908 ++++++++++
 .../android/internal/telephony/LGEQualcommRIL.java |  379 +++++
 .../internal/telephony/LGEQualcommUiccRIL.java     |  188 +++
 .../com/android/internal/telephony/LGEStarRIL.java | 1179 +++++++++++++
 .../internal/telephony/MotoWrigley3GRIL.java       |  137 ++
 .../java/com/android/internal/telephony/Phone.java |    3 +
 .../com/android/internal/telephony/PhoneBase.java  |    5 +
 .../android/internal/telephony/PhoneFactory.java   |   18 +-
 .../internal/telephony/QualcommSharedRIL.java      |  844 ++++++++++
 .../java/com/android/internal/telephony/RIL.java   |  257 ++-
 .../android/internal/telephony/RILConstants.java   |    3 +-
 .../internal/telephony/SamsungCDMAQualcommRIL.java |  429 +++++
 .../internal/telephony/SamsungCDMAv6RIL.java       |  936 +++++++++++
 .../android/internal/telephony/SamsungHCRIL.java   |   87 +
 .../android/internal/telephony/SamsungMSMRIL.java  |  111 ++
 .../internal/telephony/SamsungQualcommD2RIL.java   |  110 ++
 .../internal/telephony/SamsungQualcommUiccRIL.java |  301 ++++
 .../com/android/internal/telephony/SamsungRIL.java |  960 +++++++++++
 .../com/android/internal/telephony/SemcRIL.java    |  454 +++++
 .../android/internal/telephony/SimRegionCache.java |   51 +
 .../android/internal/telephony/Smdk4210RIL.java    |  808 +++++++++
 .../internal/telephony/SonyQualcommRIL.java        |  151 ++
 .../internal/telephony/TelephonyProperties.java    |    5 +
 .../internal/telephony/cat/CallControlResult.java  |   44 +
 .../android/internal/telephony/cat/CatService.java |  127 +-
 .../internal/telephony/cat/CommandParams.java      |   11 +
 .../telephony/cat/CommandParamsFactory.java        |   86 +-
 .../internal/telephony/cat/ValueParser.java        |   67 +
 .../android/internal/telephony/cdma/CDMAPhone.java |    2 +-
 .../telephony/cdma/CdmaLteServiceStateTracker.java |    4 +
 .../internal/telephony/cdma/CdmaSMSDispatcher.java |   71 +-
 .../telephony/cdma/CdmaServiceStateTracker.java    |    4 +
 .../internal/telephony/cdma/sms/BearerData.java    |   19 +-
 .../android/internal/telephony/gsm/GSMPhone.java   |    7 +-
 .../internal/telephony/gsm/GsmConnection.java      |   31 +
 .../telephony/gsm/GsmDataConnectionTracker.java    |  106 +-
 .../telephony/gsm/GsmServiceStateTracker.java      |   12 +-
 .../internal/telephony/gsm/SIMFileHandler.java     |   41 +
 .../android/internal/telephony/gsm/SmsMessage.java |    9 +
 .../telephony/sip/SipCommandInterface.java         |   14 +
 .../internal/telephony/test/SimulatedCommands.java |   19 +
 .../android/internal/telephony/AdnRecordTest.java  |   12 +
 .../internal/telephony/SMSDispatcherTest.java      |   21 +
 .../android/internal/telephony/SimUtilsTest.java   |   24 +
 .../telephony/gsm/UsimDataDownloadCommands.java    |   12 +
 tools/aapt/Android.mk                              |    2 +-
 voip/jni/rtp/AudioGroup.cpp                        |    9 +-
 wifi/java/android/net/wifi/WifiConfigStore.java    |   35 +
 wifi/java/android/net/wifi/WifiConfiguration.java  |   23 +
 wifi/java/android/net/wifi/WifiNative.java         |    6 +
 wifi/java/android/net/wifi/WifiStateMachine.java   |   95 +-
 283 files changed, 27165 insertions(+), 786 deletions(-)
 create mode 100644 core/java/org/codeaurora/Performance.java
 create mode 100644 core/jni/org_codeaurora_Performance.cpp
 mode change 100644 => 100755 include/media/stagefright/ACodec.h
 create mode 100755 include/media/stagefright/ExtendedExtractorFuncs.h
 create mode 100644 include/media/stagefright/ExtendedWriter.h
 create mode 100644 include/media/stagefright/LPAPlayer.h
 mode change 100644 => 100755 include/media/stagefright/MediaDefs.h
 mode change 100644 => 100755 include/media/stagefright/MetaData.h
 mode change 100644 => 100755 include/media/stagefright/OMXCodec.h
 create mode 100644 include/ui/Overlay.h
 create mode 100644 libs/ui/Overlay.cpp
 mode change 100644 => 100755 media/libstagefright/ACodec.cpp
 mode change 100644 => 100755 media/libstagefright/DataSource.cpp
 create mode 100755 media/libstagefright/ExtendedExtractor.cpp
 create mode 100644 media/libstagefright/ExtendedWriter.cpp
 create mode 100644 media/libstagefright/LPAPlayer.cpp
 create mode 100755 media/libstagefright/LPAPlayerALSA.cpp
 create mode 100644 media/libstagefright/LPAPlayerION.cpp
 create mode 100644 media/libstagefright/LPAPlayerPMEM.cpp
 mode change 100644 => 100755 media/libstagefright/MediaDefs.cpp
 mode change 100644 => 100755 media/libstagefright/MediaExtractor.cpp
 mode change 100755 => 100644 media/libstagefright/OMXCodec.cpp
 mode change 100644 => 100755 media/libstagefright/StagefrightMediaScanner.cpp
 mode change 100644 => 100755 media/libstagefright/StagefrightMetadataRetriever.cpp
 create mode 100644 media/libstagefright/codecs/aacdec/AACDecoder.cpp
 create mode 100644 media/libstagefright/codecs/mp3dec/MP3Decoder.cpp
 create mode 100644 media/libstagefright/include/ColorFormat.h
 create mode 100755 media/libstagefright/include/ExtendedExtractor.h
 mode change 100644 => 100755 media/libstagefright/include/OMXNodeInstance.h
 mode change 100644 => 100755 services/camera/libcameraservice/CameraHardwareInterface.h
 create mode 100644 services/java/com/android/server/usb/LegacyUsbDeviceManager.java
 create mode 100644 telephony/java/com/android/internal/telephony/HTCQualcommRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/HuaweiRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/JellaxyRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/LGEQualcommRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/LGEQualcommUiccRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/LGEStarRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/QualcommSharedRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungCDMAQualcommRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungCDMAv6RIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungHCRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungMSMRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungQualcommD2RIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungQualcommUiccRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SemcRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SimRegionCache.java
 create mode 100644 telephony/java/com/android/internal/telephony/Smdk4210RIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SonyQualcommRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/cat/CallControlResult.java

diff --git a/cmds/stagefright/Android.mk b/cmds/stagefright/Android.mk
index e9642f7..ec86779 100644
--- a/cmds/stagefright/Android.mk
+++ b/cmds/stagefright/Android.mk
@@ -15,13 +15,17 @@ LOCAL_C_INCLUDES:= \
 	frameworks/base/media/libstagefright \
 	frameworks/base/media/libstagefright/include \
 	$(TOP)/frameworks/base/include/media/stagefright/openmax \
-        external/skia/include/core \
-        external/skia/include/images \
+    external/skia/include/core \
+    external/skia/include/images \
 
 LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= stagefright
 
 include $(BUILD_EXECUTABLE)
@@ -70,6 +74,10 @@ LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= recordvideo
 
 include $(BUILD_EXECUTABLE)
@@ -119,6 +127,10 @@ LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= stream
 
 include $(BUILD_EXECUTABLE)
@@ -143,6 +155,10 @@ LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+    LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= sf2
 
 include $(BUILD_EXECUTABLE)
diff --git a/cmds/stagefright/recordvideo.cpp b/cmds/stagefright/recordvideo.cpp
index c402286..8e07f1f 100644
--- a/cmds/stagefright/recordvideo.cpp
+++ b/cmds/stagefright/recordvideo.cpp
@@ -26,6 +26,9 @@
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
 #include <media/MediaPlayerInterface.h>
+#ifdef QCOM_HARDWARE
+#include <OMX_QCOMExtns.h>
+#endif
 
 using namespace android;
 
diff --git a/cmds/surfaceflinger/Android.mk b/cmds/surfaceflinger/Android.mk
index 1df32bb..56606fc 100644
--- a/cmds/surfaceflinger/Android.mk
+++ b/cmds/surfaceflinger/Android.mk
@@ -12,6 +12,10 @@ LOCAL_SHARED_LIBRARIES := \
 LOCAL_C_INCLUDES := \
 	$(LOCAL_PATH)/../../services/surfaceflinger
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+LOCAL_C_INCLUDES +=  hardware/qcom/display/libqcomui
+endif
+
 LOCAL_MODULE:= surfaceflinger
 
 include $(BUILD_EXECUTABLE)
diff --git a/cmds/system_server/library/Android.mk b/cmds/system_server/library/Android.mk
index e8afce3..0596e89 100644
--- a/cmds/system_server/library/Android.mk
+++ b/cmds/system_server/library/Android.mk
@@ -14,6 +14,10 @@ LOCAL_C_INCLUDES := \
 	$(base)/media/libmediaplayerservice \
 	$(JNI_H_INCLUDE)
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+LOCAL_C_INCLUDES +=  hardware/qcom/display/libqcomui
+endif
+
 LOCAL_SHARED_LIBRARIES := \
 	libandroid_runtime \
 	libsensorservice \
diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index 7ca6155..1e8ea4e 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -137,6 +137,8 @@ public class Camera {
     private static final int CAMERA_MSG_RAW_IMAGE        = 0x080;
     private static final int CAMERA_MSG_COMPRESSED_IMAGE = 0x100;
     private static final int CAMERA_MSG_RAW_IMAGE_NOTIFY = 0x200;
+    private static final int CAMERA_MSG_STATS_DATA       = 0x800;
+    private static final int CAMERA_MSG_META_DATA        = 0x8000;
     private static final int CAMERA_MSG_PREVIEW_METADATA = 0x400;
     private static final int CAMERA_MSG_ALL_MSGS         = 0x4FF;
 
@@ -148,6 +150,8 @@ public class Camera {
     private PreviewCallback mPreviewCallback;
     private PictureCallback mPostviewCallback;
     private AutoFocusCallback mAutoFocusCallback;
+    private CameraDataCallback mCameraDataCallback;
+    private CameraMetaDataCallback mCameraMetaDataCallback;
     private OnZoomChangeListener mZoomListener;
     private FaceDetectionListener mFaceListener;
     private ErrorCallback mErrorCallback;
@@ -207,6 +211,18 @@ public class Camera {
         public static final int CAMERA_FACING_FRONT = 1;
 
         /**
+         * The facing of the camera is the same as that of the screen.
+         * @hide
+         */
+        public static final int CAMERA_SUPPORT_MODE_ZSL = 2;
+
+        /**
+         * The facing of the camera is the same as that of the screen.
+         * @hide
+         */
+        public static final int CAMERA_SUPPORT_MODE_NONZSL = 3;
+
+        /**
          * The direction that the camera faces. It should be
          * CAMERA_FACING_BACK or CAMERA_FACING_FRONT.
          */
@@ -289,6 +305,8 @@ public class Camera {
         mPreviewCallback = null;
         mPostviewCallback = null;
         mZoomListener = null;
+        mCameraDataCallback = null;
+        mCameraMetaDataCallback = null;
 
         Looper looper;
         if ((looper = Looper.myLooper()) != null) {
@@ -706,6 +724,21 @@ public class Camera {
                 }
                 return;
 
+            case CAMERA_MSG_STATS_DATA:
+                int statsdata[] = new int[257];
+                for(int i =0; i<257; i++ ) {
+                   statsdata[i] = byteToInt( (byte[])msg.obj, i*4);
+                }
+                if (mCameraDataCallback != null) {
+                     mCameraDataCallback.onCameraData(statsdata, mCamera);
+                }
+                return;
+
+            case CAMERA_MSG_META_DATA:
+                if (mCameraMetaDataCallback != null) {
+                    mCameraMetaDataCallback.onCameraMetaData((int[])msg.obj, mCamera);
+                }
+                return;
             case CAMERA_MSG_POSTVIEW_FRAME:
                 if (mPostviewCallback != null) {
                     mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
@@ -744,6 +777,14 @@ public class Camera {
         }
     }
 
+    private static int byteToInt(byte[] b, int offset) {
+        int value = 0;
+        for (int i = 0; i < 4; i++) {
+            int shift = (4 - 1 - i) * 8;
+            value += (b[(3-i) + offset] & 0x000000FF) << shift;
+        }
+        return value;
+    }
     private static void postEventFromNative(Object camera_ref,
                                             int what, int arg1, int arg2, Object obj)
     {
@@ -849,6 +890,15 @@ public class Camera {
     private native final void native_cancelAutoFocus();
 
     /**
+     * @hide
+     */
+
+    public final void encodeData()
+    {
+        native_encodeData();
+    }
+    private native final void native_encodeData();
+    /**
      * Callback interface used to signal the moment of actual image capture.
      *
      * @see #takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)
@@ -864,6 +914,84 @@ public class Camera {
          */
         void onShutter();
     }
+    /**
+     * @hide
+     * Handles the callback for when Camera Data is available.
+     * data is read from the camera.
+     */
+    public interface CameraDataCallback {
+        /**
+         * Callback for when camera data is available.
+         *
+         * @param data   a int array of the camera data
+         * @param camera the Camera service object
+         */
+        void onCameraData(int[] data, Camera camera);
+    };
+
+    /**
+     * @hide
+     * Set camera histogram mode and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setHistogramMode(CameraDataCallback cb)
+    {
+        mCameraDataCallback = cb;
+        native_setHistogramMode(cb!=null);
+    }
+    private native final void native_setHistogramMode(boolean mode);
+
+    /**
+     * @hide
+     * Set camera histogram command to send data.
+     *
+     */
+    public final void sendHistogramData()
+    {
+        native_sendHistogramData();
+    }
+    private native final void native_sendHistogramData();
+
+    /**
+     * @hide
+     * Handles the callback for when Camera Meta Data is available.
+     * Meta data is read from the camera.
+     */
+    public interface CameraMetaDataCallback {
+        /**
+         * Callback for when camera meta data is available.
+         *
+         * @param data   a int array of the camera meta data
+         * @param camera the Camera service object
+         */
+        void onCameraMetaData(int[] data, Camera camera);
+    };
+
+    /**
+     * @hide
+     * Set camera face detection mode and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setFaceDetectionCb(CameraMetaDataCallback cb)
+    {
+        mCameraMetaDataCallback = cb;
+        native_setFaceDetectionCb(cb!=null);
+    }
+    private native final void native_setFaceDetectionCb(boolean mode);
+
+    /**
+     * @hide
+     * Set camera face detection command to send meta data.
+     */
+    public final void sendMetaData()
+    {
+        native_sendMetaData();
+    }
+    private native final void native_sendMetaData();
 
     /**
      * Callback interface used to supply image data from a photo capture.
@@ -1435,6 +1563,43 @@ public class Camera {
          */
         public int weight;
     }
+     /**
+     * @hide
+     * Handles the Touch Co-ordinate.
+     */
+	public class Coordinate {
+        /**
+         * Sets the x,y co-ordinates for a touch event
+         *
+         * @param x the x co-ordinate (pixels)
+         * @param y the y co-ordinate (pixels)
+         */
+        public Coordinate(int x, int y) {
+            xCoordinate = x;
+            yCoordinate = y;
+        }
+        /**
+         * Compares {@code obj} to this co-ordinate.
+         *
+         * @param obj the object to compare this co-ordinate with.
+         * @return {@code true} if the xCoordinate and yCoordinate of {@code obj} is the
+         *         same as those of this coordinate. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Coordinate)) {
+                return false;
+            }
+            Coordinate c = (Coordinate) obj;
+            return xCoordinate == c.xCoordinate && yCoordinate == c.yCoordinate;
+        }
+
+        /** x co-ordinate for the touch event*/
+        public int xCoordinate;
+
+        /** y co-ordinate for the touch event */
+        public int yCoordinate;
+    };
 
     /**
      * Camera service settings.
@@ -1456,9 +1621,13 @@ public class Camera {
     public class Parameters {
         // Parameter keys to communicate with the camera driver.
         private static final String KEY_PREVIEW_SIZE = "preview-size";
+	private static final String KEY_HFR_SIZE = "hfr-size";
         private static final String KEY_PREVIEW_FORMAT = "preview-format";
         private static final String KEY_PREVIEW_FRAME_RATE = "preview-frame-rate";
         private static final String KEY_PREVIEW_FPS_RANGE = "preview-fps-range";
+        private static final String KEY_PREVIEW_FRAME_RATE_MODE = "preview-frame-rate-mode";
+        private static final String KEY_PREVIEW_FRAME_RATE_AUTO_MODE = "frame-rate-auto";
+        private static final String KEY_PREVIEW_FRAME_RATE_FIXED_MODE = "frame-rate-fixed";
         private static final String KEY_PICTURE_SIZE = "picture-size";
         private static final String KEY_PICTURE_FORMAT = "picture-format";
         private static final String KEY_JPEG_THUMBNAIL_SIZE = "jpeg-thumbnail-size";
@@ -1470,14 +1639,27 @@ public class Camera {
         private static final String KEY_GPS_LATITUDE = "gps-latitude";
         private static final String KEY_GPS_LONGITUDE = "gps-longitude";
         private static final String KEY_GPS_ALTITUDE = "gps-altitude";
+        private static final String KEY_GPS_LATITUDE_REF = "gps-latitude-ref";
+        private static final String KEY_GPS_LONGITUDE_REF = "gps-longitude-ref";
+        private static final String KEY_GPS_ALTITUDE_REF = "gps-altitude-ref";
+        private static final String KEY_GPS_STATUS = "gps-status";
         private static final String KEY_GPS_TIMESTAMP = "gps-timestamp";
+        private static final String KEY_EXIF_DATETIME = "exif-datetime";
         private static final String KEY_GPS_PROCESSING_METHOD = "gps-processing-method";
         private static final String KEY_WHITE_BALANCE = "whitebalance";
         private static final String KEY_EFFECT = "effect";
+        private static final String KEY_TOUCH_AF_AEC = "touch-af-aec";
+        private static final String KEY_TOUCH_INDEX_AEC = "touch-index-aec";
+        private static final String KEY_TOUCH_INDEX_AF = "touch-index-af";
         private static final String KEY_ANTIBANDING = "antibanding";
         private static final String KEY_SCENE_MODE = "scene-mode";
+        private static final String KEY_SCENE_DETECT = "scene-detect";
         private static final String KEY_FLASH_MODE = "flash-mode";
         private static final String KEY_FOCUS_MODE = "focus-mode";
+        private static final String KEY_ISO_MODE = "iso";
+        private static final String KEY_LENSSHADE = "lensshade";
+        private static final String KEY_HISTOGRAM = "histogram";
+        private static final String KEY_SKIN_TONE_ENHANCEMENT = "skinToneEnhancement";
         private static final String KEY_FOCUS_AREAS = "focus-areas";
         private static final String KEY_MAX_NUM_FOCUS_AREAS = "max-num-focus-areas";
         private static final String KEY_FOCAL_LENGTH = "focal-length";
@@ -1493,6 +1675,7 @@ public class Camera {
         private static final String KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED = "auto-whitebalance-lock-supported";
         private static final String KEY_METERING_AREAS = "metering-areas";
         private static final String KEY_MAX_NUM_METERING_AREAS = "max-num-metering-areas";
+        private static final String KEY_AUTO_EXPOSURE = "auto-exposure";
         private static final String KEY_ZOOM = "zoom";
         private static final String KEY_MAX_ZOOM = "max-zoom";
         private static final String KEY_ZOOM_RATIOS = "zoom-ratios";
@@ -1506,8 +1689,24 @@ public class Camera {
         private static final String KEY_MAX_NUM_DETECTED_FACES_SW = "max-num-detected-faces-sw";
         private static final String KEY_RECORDING_HINT = "recording-hint";
         private static final String KEY_VIDEO_SNAPSHOT_SUPPORTED = "video-snapshot-supported";
+        private static final String KEY_FULL_VIDEO_SNAP_SUPPORTED = "full-video-snap-supported";
         private static final String KEY_VIDEO_STABILIZATION = "video-stabilization";
         private static final String KEY_VIDEO_STABILIZATION_SUPPORTED = "video-stabilization-supported";
+        private static final String KEY_SHARPNESS = "sharpness";
+        private static final String KEY_MAX_SHARPNESS = "max-sharpness";
+        private static final String KEY_CONTRAST = "contrast";
+        private static final String KEY_MAX_CONTRAST = "max-contrast";
+        private static final String KEY_SATURATION = "saturation";
+        private static final String KEY_MAX_SATURATION = "max-saturation";
+        private static final String KEY_DENOISE = "denoise";
+        private static final String KEY_CONTINUOUS_AF = "continuous-af";
+        private static final String KEY_SELECTABLE_ZONE_AF = "selectable-zone-af";
+        private static final String KEY_FACE_DETECTION = "face-detection";
+        private static final String KEY_MEMORY_COLOR_ENHANCEMENT = "mce";
+        private static final String KEY_REDEYE_REDUCTION = "redeye-reduction";
+        private static final String KEY_ZSL = "zsl";
+        private static final String KEY_CAMERA_MODE = "camera-mode";
+        private static final String KEY_VIDEO_HIGH_FRAME_RATE = "video-hfr";
 
         // Parameter key suffix for supported values.
         private static final String SUPPORTED_VALUES_SUFFIX = "-values";
@@ -1536,12 +1735,91 @@ public class Camera {
         public static final String EFFECT_BLACKBOARD = "blackboard";
         public static final String EFFECT_AQUA = "aqua";
 
+        // Values for touch af/aec settings.
+        /** @hide */
+        public static final String TOUCH_AF_AEC_OFF = "touch-off";
+        /** @hide */
+        public static final String TOUCH_AF_AEC_ON = "touch-on";
+
+        // Values for auto exposure settings.
+        /** @hide */
+        public static final String AUTO_EXPOSURE_FRAME_AVG = "frame-average";
+        /** @hide */
+        public static final String AUTO_EXPOSURE_CENTER_WEIGHTED = "center-weighted";
+        /** @hide */
+        public static final String AUTO_EXPOSURE_SPOT_METERING = "spot-metering";
         // Values for antibanding settings.
         public static final String ANTIBANDING_AUTO = "auto";
         public static final String ANTIBANDING_50HZ = "50hz";
         public static final String ANTIBANDING_60HZ = "60hz";
         public static final String ANTIBANDING_OFF = "off";
 
+        //Values for ISO settings
+        /** @hide */
+        public static final String ISO_AUTO = "auto";
+        /** @hide */
+        public static final String ISO_HJR = "ISO_HJR";
+        /** @hide */
+        public static final String ISO_100 = "ISO100";
+        /** @hide */
+        public static final String ISO_200 = "ISO200";
+        /** @hide */
+        public static final String ISO_400 = "ISO400";
+        /** @hide */
+        public static final String ISO_800 = "ISO800";
+        /** @hide */
+        public static final String ISO_1600 = "ISO1600";
+
+        //Values for Lens Shading
+
+        /** @hide */
+        public static final String LENSSHADE_ENABLE = "enable";
+        /** @hide */
+        public static final String LENSSHADE_DISABLE= "disable";
+
+        /** @hide */
+        public static final String HISTOGRAM_ENABLE = "enable";
+        /** @hide */
+        public static final String HISTOGRAM_DISABLE= "disable";
+
+        /** @hide */
+        public static final String SKIN_TONE_ENHANCEMENT_ENABLE = "enable";
+        /** @hide */
+        public static final String SKIN_TONE_ENHANCEMENT_DISABLE= "disable";
+
+        // Values for MCE settings.
+        /** @hide */
+        public static final String MCE_ENABLE = "enable";
+        /** @hide */
+        public static final String MCE_DISABLE = "disable";
+
+        // Values for ZSL settings.
+        /** @hide */
+        public static final String ZSL_ON = "on";
+        /** @hide */
+        public static final String ZSL_OFF = "off";
+
+        // Values for HDR Bracketing settings.
+        /** @hide */
+        public static final String AE_BRACKET_HDR_OFF = "Off";
+        /** @hide */
+        public static final String AE_BRACKET_HDR = "HDR";
+        /** @hide */
+        public static final String AE_BRACKET = "AE-Bracket";
+
+        // Values for HFR settings.
+        /** @hide */
+        public static final String VIDEO_HFR_OFF = "off";
+        /** @hide */
+        public static final String VIDEO_HFR_2X = "60";
+        /** @hide */
+        public static final String VIDEO_HFR_3X = "90";
+        /** @hide */
+        public static final String VIDEO_HFR_4X = "120";
+
+        /** @hide */
+        public static final String KEY_AE_BRACKET_HDR = "ae-bracket-hdr";
+
         // Values for flash mode settings.
         /**
          * Flash will not be fired.
@@ -1572,7 +1850,19 @@ public class Camera {
         public static final String FLASH_MODE_TORCH = "torch";
 
         /**
+         * Scene mode is off. (for some QCom)
+         * @hide
+         */
+        public static final String SCENE_MODE_OFF = "off";
+
+        /**
          * Scene mode is off.
+         * @hide
+         */
+        public static final String SCENE_MODE_ASD = "asd";
+
+        /**
+         * Scene mode is auto ASD.
          */
         public static final String SCENE_MODE_AUTO = "auto";
 
@@ -1647,6 +1937,16 @@ public class Camera {
          * Capture the naturally warm color of scenes lit by candles.
          */
         public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
+        /** @hide */
+        public static final String SCENE_MODE_BACKLIGHT = "backlight";
+        /** @hide */
+        public static final String SCENE_MODE_FLOWERS = "flowers";
+
+        // Values for auto scene detection settings.
+        /** @hide */
+        public static final String SCENE_DETECT_OFF = "off";
+        /** @hide */
+        public static final String SCENE_DETECT_ON = "on";
 
         /**
          * Applications are looking for a barcode. Camera driver will be
@@ -1682,6 +1982,14 @@ public class Camera {
         public static final String FOCUS_MODE_FIXED = "fixed";
 
         /**
+         * Normal focus mode. Applications should call
+         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
+         * mode.
+         * @hide
+         */
+        public static final String FOCUS_MODE_NORMAL = "normal";
+
+        /**
          * Extended depth of field (EDOF). Focusing is done digitally and
          * continuously. Applications should not call {@link
          * #autoFocus(AutoFocusCallback)} in this mode.
@@ -1769,11 +2077,47 @@ public class Camera {
         // Formats for setPreviewFormat and setPictureFormat.
         private static final String PIXEL_FORMAT_YUV422SP = "yuv422sp";
         private static final String PIXEL_FORMAT_YUV420SP = "yuv420sp";
+        private static final String PIXEL_FORMAT_YUV420SP_ADRENO = "yuv420sp-adreno";
         private static final String PIXEL_FORMAT_YUV422I = "yuv422i-yuyv";
         private static final String PIXEL_FORMAT_YUV420P = "yuv420p";
         private static final String PIXEL_FORMAT_RGB565 = "rgb565";
         private static final String PIXEL_FORMAT_JPEG = "jpeg";
         private static final String PIXEL_FORMAT_BAYER_RGGB = "bayer-rggb";
+        private static final String PIXEL_FORMAT_RAW = "raw";
+        private static final String PIXEL_FORMAT_YV12 = "yv12";
+        private static final String PIXEL_FORMAT_NV12 = "nv12";
+
+        //Values for Continuous AF
+
+        /** @hide */
+        public static final String CONTINUOUS_AF_OFF = "caf-off";
+        /** @hide */
+        public static final String CONTINUOUS_AF_ON = "caf-on";
+        /** @hide */
+        public static final String DENOISE_OFF = "denoise-off";
+        /** @hide */
+        public static final String DENOISE_ON = "denoise-on";
+	// Values for Redeye Reduction settings.
+        /** @hide */
+        public static final String REDEYE_REDUCTION_ENABLE = "enable";
+        /** @hide */
+        public static final String REDEYE_REDUCTION_DISABLE = "disable";
+
+        // Values for selectable zone af settings.
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_AUTO = "auto";
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_SPOTMETERING = "spot-metering";
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_CENTER_WEIGHTED = "center-weighted";
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_FRAME_AVERAGE = "frame-average";
+
+        // Values for Face Detection settings.
+        /** @hide */
+        public static final String FACE_DETECTION_OFF = "off";
+        /** @hide */
+        public static final String FACE_DETECTION_ON = "on";
 
         private HashMap<String, String> mMap;
 
@@ -1966,6 +2310,18 @@ public class Camera {
             return splitSize(str);
         }
 
+	/**
+         * @hide
+         * Gets the supported preview sizes in high frame rate recording mode.
+         *
+         * @return a list of Size object. This method will always return a list
+         *         with at least one element.
+         */
+        public List<Size> getSupportedHfrSizes() {
+            String str = get(KEY_HFR_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
+
         /**
          * <p>Gets the supported video frame sizes that can be used by
          * MediaRecorder.</p>
@@ -2418,6 +2774,16 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets GPS latitude reference coordinate. This will be stored in JPEG EXIF
+         * header.
+         * @param latRef GPS latitude reference coordinate.
+         */
+        public void setGpsLatitudeRef(String latRef) {
+            set(KEY_GPS_LATITUDE_REF, latRef);
+        }
+
+        /**
          * Sets GPS latitude coordinate. This will be stored in JPEG EXIF
          * header.
          *
@@ -2428,6 +2794,16 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets GPS longitude reference coordinate. This will be stored in JPEG EXIF
+         * header.
+         * @param lonRef GPS longitude reference coordinate.
+         */
+        public void setGpsLongitudeRef(String lonRef) {
+            set(KEY_GPS_LONGITUDE_REF, lonRef);
+        }
+
+        /**
          * Sets GPS longitude coordinate. This will be stored in JPEG EXIF
          * header.
          *
@@ -2438,6 +2814,15 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets GPS altitude reference. This will be stored in JPEG EXIF header.
+         * @param altRef reference GPS altitude in meters.
+         */
+        public void setGpsAltitudeRef(double altRef) {
+            set(KEY_GPS_ALTITUDE_REF, Double.toString(altRef));
+        }
+
+        /**
          * Sets GPS altitude. This will be stored in JPEG EXIF header.
          *
          * @param altitude GPS altitude in meters.
@@ -2467,12 +2852,37 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets system timestamp. This will be stored in JPEG EXIF header.
+         *
+         * @param dateTime current timestamp (UTC in seconds since January 1,
+         *                  1970).
+         */
+        public void setExifDateTime(String dateTime) {
+            set(KEY_EXIF_DATETIME, dateTime);
+        }
+
+        /**
+         * @hide
+         * Sets GPS Status. This will be stored in JPEG EXIF header.
+         *
+         * @param status GPS status (UTC in seconds since January 1,
+         *                  1970).
+         */
+        public void setGpsStatus(double status) {
+            set(KEY_GPS_STATUS, Double.toString(status));
+        }
+
+        /**
          * Removes GPS latitude, longitude, altitude, and timestamp from the
          * parameters.
          */
         public void removeGpsData() {
+            remove(KEY_GPS_LATITUDE_REF);
             remove(KEY_GPS_LATITUDE);
+            remove(KEY_GPS_LONGITUDE_REF);
             remove(KEY_GPS_LONGITUDE);
+            remove(KEY_GPS_ALTITUDE_REF);
             remove(KEY_GPS_ALTITUDE);
             remove(KEY_GPS_TIMESTAMP);
             remove(KEY_GPS_PROCESSING_METHOD);
@@ -2566,149 +2976,470 @@ public class Camera {
             return split(str);
         }
 
-
         /**
-         * Gets the current antibanding setting.
+         * @hide
+         * Gets the current Touch AF/AEC setting.
+         *
+         * @return one of TOUCH_AF_AEC_XXX string constant. null if Touch AF/AEC
+         *         setting is not supported.
          *
-         * @return current antibanding. null if antibanding setting is not
-         *         supported.
-         * @see #ANTIBANDING_AUTO
-         * @see #ANTIBANDING_50HZ
-         * @see #ANTIBANDING_60HZ
-         * @see #ANTIBANDING_OFF
          */
-        public String getAntibanding() {
-            return get(KEY_ANTIBANDING);
+        public String getTouchAfAec() {
+            return get(KEY_TOUCH_AF_AEC);
         }
 
         /**
-         * Sets the antibanding.
+         * @hide
+         * Sets the current TOUCH AF/AEC setting.
+         *
+         * @param value TOUCH_AF_AEC_XXX string constants.
          *
-         * @param antibanding new antibanding value.
-         * @see #getAntibanding()
          */
-        public void setAntibanding(String antibanding) {
-            set(KEY_ANTIBANDING, antibanding);
+        public void setTouchAfAec(String value) {
+            set(KEY_TOUCH_AF_AEC, value);
         }
 
-        /**
-         * Gets the supported antibanding values.
+       /**
+         * @hide
+         * Gets the supported Touch AF/AEC setting.
          *
-         * @return a list of supported antibanding values. null if antibanding
+         * @return a List of TOUCH_AF_AEC_XXX string constants. null if TOUCH AF/AEC
          *         setting is not supported.
-         * @see #getAntibanding()
+         *
          */
-        public List<String> getSupportedAntibanding() {
-            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+        public List<String> getSupportedTouchAfAec() {
+            String str = get(KEY_TOUCH_AF_AEC + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
 
         /**
-         * Gets the current scene mode setting.
+         * @hide
+         * Sets the touch co-ordinate for Touch AEC.
+         *
+         * @param x  the x co-ordinate of the touch event
+         * @param y the y co-ordinate of the touch event
          *
-         * @return one of SCENE_MODE_XXX string constant. null if scene mode
-         *         setting is not supported.
-         * @see #SCENE_MODE_AUTO
-         * @see #SCENE_MODE_ACTION
-         * @see #SCENE_MODE_PORTRAIT
-         * @see #SCENE_MODE_LANDSCAPE
-         * @see #SCENE_MODE_NIGHT
-         * @see #SCENE_MODE_NIGHT_PORTRAIT
-         * @see #SCENE_MODE_THEATRE
-         * @see #SCENE_MODE_BEACH
-         * @see #SCENE_MODE_SNOW
-         * @see #SCENE_MODE_SUNSET
-         * @see #SCENE_MODE_STEADYPHOTO
-         * @see #SCENE_MODE_FIREWORKS
-         * @see #SCENE_MODE_SPORTS
-         * @see #SCENE_MODE_PARTY
-         * @see #SCENE_MODE_CANDLELIGHT
          */
-        public String getSceneMode() {
-            return get(KEY_SCENE_MODE);
+        public void setTouchIndexAec(int x, int y) {
+            String v = Integer.toString(x) + "x" + Integer.toString(y);
+            set(KEY_TOUCH_INDEX_AEC, v);
         }
 
         /**
-         * Sets the scene mode. Changing scene mode may override other
-         * parameters (such as flash mode, focus mode, white balance). For
-         * example, suppose originally flash mode is on and supported flash
-         * modes are on/off. In night scene mode, both flash mode and supported
-         * flash mode may be changed to off. After setting scene mode,
-         * applications should call getParameters to know if some parameters are
-         * changed.
+         * @hide
+         * Returns the touch co-ordinates of the touch event.
+         *
+         * @return a Index object with the x and y co-ordinated
+         *          for the touch event
          *
-         * @param value scene mode.
-         * @see #getSceneMode()
          */
-        public void setSceneMode(String value) {
-            set(KEY_SCENE_MODE, value);
+        public Coordinate getTouchIndexAec() {
+            String pair = get(KEY_TOUCH_INDEX_AEC);
+            return strToCoordinate(pair);
         }
 
         /**
-         * Gets the supported scene modes.
+         * @hide
+         * Sets the touch co-ordinate for Touch AF.
+         *
+         * @param x  the x co-ordinate of the touch event
+         * @param y the y co-ordinate of the touch event
          *
-         * @return a list of supported scene modes. null if scene mode setting
-         *         is not supported.
-         * @see #getSceneMode()
          */
-        public List<String> getSupportedSceneModes() {
-            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public void setTouchIndexAf(int x, int y) {
+            String v = Integer.toString(x) + "x" + Integer.toString(y);
+            set(KEY_TOUCH_INDEX_AF, v);
         }
 
         /**
-         * Gets the current flash mode setting.
+         * @hide
+         * Returns the touch co-ordinates of the touch event.
+         *
+         * @return a Index object with the x and y co-ordinated
+         *          for the touch event
          *
-         * @return current flash mode. null if flash mode setting is not
-         *         supported.
-         * @see #FLASH_MODE_OFF
-         * @see #FLASH_MODE_AUTO
-         * @see #FLASH_MODE_ON
-         * @see #FLASH_MODE_RED_EYE
-         * @see #FLASH_MODE_TORCH
          */
-        public String getFlashMode() {
-            return get(KEY_FLASH_MODE);
+        public Coordinate getTouchIndexAf() {
+            String pair = get(KEY_TOUCH_INDEX_AF);
+            return strToCoordinate(pair);
         }
 
         /**
-         * Sets the flash mode.
+         * @hide
+         * Get Sharpness level
          *
-         * @param value flash mode.
-         * @see #getFlashMode()
+         * @return sharpness level
          */
-        public void setFlashMode(String value) {
-            set(KEY_FLASH_MODE, value);
+        public int getSharpness(){
+            return getInt(KEY_SHARPNESS);
         }
 
         /**
-         * Gets the supported flash modes.
+         * @hide
+         * Set Sharpness Level
          *
-         * @return a list of supported flash modes. null if flash mode setting
-         *         is not supported.
-         * @see #getFlashMode()
+         * @param sharpness level
          */
-        public List<String> getSupportedFlashModes() {
-            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public void setSharpness(int sharpness){
+            if((sharpness < 0) || (sharpness > getMaxSharpness()) )
+                throw new IllegalArgumentException(
+                        "Invalid Sharpness " + sharpness);
+
+            set(KEY_SHARPNESS, String.valueOf(sharpness));
         }
 
         /**
-         * Gets the current focus mode setting.
+         * @hide
+         * Get Max Sharpness Level
          *
-         * @return current focus mode. This method will always return a non-null
-         *         value. Applications should call {@link
-         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
-         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
-         * @see #FOCUS_MODE_AUTO
-         * @see #FOCUS_MODE_INFINITY
-         * @see #FOCUS_MODE_MACRO
-         * @see #FOCUS_MODE_FIXED
-         * @see #FOCUS_MODE_EDOF
-         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         * @return max sharpness level
          */
-        public String getFocusMode() {
-            return get(KEY_FOCUS_MODE);
+        public int getMaxSharpness(){
+            return getInt(KEY_MAX_SHARPNESS);
+        }
+
+        /**
+         * @hide
+         * Get Contrast level
+         *
+         * @return contrast level
+         */
+        public int getContrast(){
+            return getInt(KEY_CONTRAST);
+        }
+
+        /**
+         * @hide
+         * Set Contrast Level
+         *
+         * @param contrast level
+         */
+        public void setContrast(int contrast){
+            if((contrast < 0 ) || (contrast > getMaxContrast()))
+                throw new IllegalArgumentException(
+                        "Invalid Contrast " + contrast);
+
+            set(KEY_CONTRAST, String.valueOf(contrast));
+        }
+
+        /**
+         * @hide
+         * Get Max Contrast Level
+         *
+         * @return max contrast level
+         */
+        public int getMaxContrast(){
+            return getInt(KEY_MAX_CONTRAST);
+        }
+
+        /**
+         * @hide
+         * Get Saturation level
+         *
+         * @return saturation level
+         */
+        public int getSaturation(){
+            return getInt(KEY_SATURATION);
+        }
+
+        /**
+         * @hide
+         * Set Saturation Level
+         *
+         * @param saturation level
+         */
+        public void setSaturation(int saturation){
+            if((saturation < 0 ) || (saturation > getMaxSaturation()))
+                throw new IllegalArgumentException(
+                        "Invalid Saturation " + saturation);
+
+            set(KEY_SATURATION, String.valueOf(saturation));
+        }
+
+        /**
+         * @hide
+         * Get Max Saturation Level
+         *
+         * @return max contrast level
+         */
+        public int getMaxSaturation(){
+            return getInt(KEY_MAX_SATURATION);
+        }
+
+        /**
+         * @hide
+         * Gets the current redeye reduction setting.
+         *
+         * @return one of REDEYE_REDUCTION_XXX string constant. null if redeye reduction
+         *         setting is not supported.
+         *
+         */
+        public String getRedeyeReductionMode() {
+            return get(KEY_REDEYE_REDUCTION);
+        }
+
+	/**
+         * @hide
+         * Sets the redeye reduction. Other parameters may be changed after changing
+         * redeye reduction. After setting redeye reduction,
+         * applications should call getParameters to know if some parameters are
+         * changed.
+         *
+         * @param value REDEYE_REDUCTION_XXX string constants.
+         *
+         */
+        public void setRedeyeReductionMode(String value) {
+            set(KEY_REDEYE_REDUCTION, value);
+        }
+        /**
+         * @hide
+         * Gets the supported redeye reduction modes.
+         *
+         * @return a List of REDEYE_REDUCTION_XXX string constant. null if redeye reduction
+         *         setting is not supported.
+         *
+         */
+        public List<String> getSupportedRedeyeReductionModes() {
+            String str = get(KEY_REDEYE_REDUCTION + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        /**
+         * Gets the current antibanding setting.
+         *
+         * @return current antibanding. null if antibanding setting is not
+         *         supported.
+         * @see #ANTIBANDING_AUTO
+         * @see #ANTIBANDING_50HZ
+         * @see #ANTIBANDING_60HZ
+         * @see #ANTIBANDING_OFF
+         */
+        public String getAntibanding() {
+            return get(KEY_ANTIBANDING);
+        }
+
+        /**
+         * Sets the antibanding.
+         *
+         * @param antibanding new antibanding value.
+         * @see #getAntibanding()
+         */
+        public void setAntibanding(String antibanding) {
+            set(KEY_ANTIBANDING, antibanding);
+        }
+
+        /**
+         * Gets the supported antibanding values.
+         *
+         * @return a list of supported antibanding values. null if antibanding
+         *         setting is not supported.
+         * @see #getAntibanding()
+         */
+        public List<String> getSupportedAntibanding() {
+            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * @hide
+         * Gets the frame rate mode setting.
+         *
+         * @return one of FRAME_RATE_XXX_MODE string constant. null if this
+         *         setting is not supported.
+         */
+        public String getPreviewFrameRateMode() {
+            return get(KEY_PREVIEW_FRAME_RATE_MODE);
+        }
+
+        /**
+         * @hide
+         * Sets the frame rate mode.
+         *
+         * @param value FRAME_RATE_XXX_MODE string constants.
+         */
+        public void setPreviewFrameRateMode(String value) {
+            set(KEY_PREVIEW_FRAME_RATE_MODE, value);
+        }
+
+        /**
+         * @hide
+         * Gets the supported frame rate modes.
+         *
+         * @return a List of FRAME_RATE_XXX_MODE string constant. null if this
+         *         setting is not supported.
+         */
+        public List<String> getSupportedPreviewFrameRateModes() {
+            String str = get(KEY_PREVIEW_FRAME_RATE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the current scene mode setting.
+         *
+         * @return one of SCENE_MODE_XXX string constant. null if scene mode
+         *         setting is not supported.
+         * @see #SCENE_MODE_AUTO
+         * @see #SCENE_MODE_ACTION
+         * @see #SCENE_MODE_PORTRAIT
+         * @see #SCENE_MODE_LANDSCAPE
+         * @see #SCENE_MODE_NIGHT
+         * @see #SCENE_MODE_NIGHT_PORTRAIT
+         * @see #SCENE_MODE_THEATRE
+         * @see #SCENE_MODE_BEACH
+         * @see #SCENE_MODE_SNOW
+         * @see #SCENE_MODE_SUNSET
+         * @see #SCENE_MODE_STEADYPHOTO
+         * @see #SCENE_MODE_FIREWORKS
+         * @see #SCENE_MODE_SPORTS
+         * @see #SCENE_MODE_PARTY
+         * @see #SCENE_MODE_CANDLELIGHT
+         */
+        public String getSceneMode() {
+            return get(KEY_SCENE_MODE);
+        }
+
+        /**
+         * Sets the scene mode. Changing scene mode may override other
+         * parameters (such as flash mode, focus mode, white balance). For
+         * example, suppose originally flash mode is on and supported flash
+         * modes are on/off. In night scene mode, both flash mode and supported
+         * flash mode may be changed to off. After setting scene mode,
+         * applications should call getParameters to know if some parameters are
+         * changed.
+         *
+         * @param value scene mode.
+         * @see #getSceneMode()
+         */
+        public void setSceneMode(String value) {
+            set(KEY_SCENE_MODE, value);
+        }
+
+        /**
+         * Gets the supported scene modes.
+         *
+         * @return a list of supported scene modes. null if scene mode setting
+         *         is not supported.
+         * @see #getSceneMode()
+         */
+        public List<String> getSupportedSceneModes() {
+            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * @hide
+         * Gets the current auto scene detection setting.
+         *
+         * @return one of SCENE_DETECT_XXX string constant. null if auto scene detection
+         *         setting is not supported.
+         *
+         */
+        public String getSceneDetectMode() {
+            return get(KEY_SCENE_DETECT);
+        }
+
+        /**
+         * @hide
+         * Sets the auto scene detect. Other parameters may be changed after changing
+         * scene detect. After setting auto scene detection,
+         * applications should call getParameters to know if some parameters are
+         * changed.
+         *
+         * @param value SCENE_DETECT_XXX string constants.
+         *
+         */
+        public void setSceneDetectMode(String value) {
+            set(KEY_SCENE_DETECT, value);
+        }
+
+        /**
+         * @hide
+         * Gets the supported auto scene detection modes.
+         *
+         * @return a List of SCENE_DETECT_XXX string constant. null if scene detection
+         *         setting is not supported.
+         *
+         */
+        public List<String> getSupportedSceneDetectModes() {
+            String str = get(KEY_SCENE_DETECT + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the current flash mode setting.
+         *
+         * @return current flash mode. null if flash mode setting is not
+         *         supported.
+         * @see #FLASH_MODE_OFF
+         * @see #FLASH_MODE_AUTO
+         * @see #FLASH_MODE_ON
+         * @see #FLASH_MODE_RED_EYE
+         * @see #FLASH_MODE_TORCH
+         */
+        public String getFlashMode() {
+            return get(KEY_FLASH_MODE);
+        }
+
+        /**
+         * @hide
+         * Gets the current hdr bracketing mode setting.
+         *
+         * @return current hdr bracketing mode.
+         * @see #KEY_AE_BRACKET_OFF
+         * @see #KEY_AE_BRACKET_HDR
+         * @see #KEY_AE_BRACKET_BRACKATING
+         */
+        public String getAEBracket() {
+            return get(KEY_AE_BRACKET_HDR);
+        }
+
+        /**
+         * Sets the flash mode.
+         *
+         * @param value flash mode.
+         * @see #getFlashMode()
+         */
+        public void setFlashMode(String value) {
+            set(KEY_FLASH_MODE, value);
+        }
+
+        /**
+         * @hide
+         * Set HDR-Bracketing Level
+         *
+         * @param value HDR-Bracketing
+         */
+        public void setAEBracket(String value){
+            set(KEY_AE_BRACKET_HDR, value);
+        }
+
+        /**
+         * Gets the supported flash modes.
+         *
+         * @return a list of supported flash modes. null if flash mode setting
+         *         is not supported.
+         * @see #getFlashMode()
+         */
+        public List<String> getSupportedFlashModes() {
+            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the current focus mode setting.
+         *
+         * @return current focus mode. This method will always return a non-null
+         *         value. Applications should call {@link
+         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
+         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
+         * @see #FOCUS_MODE_AUTO
+         * @see #FOCUS_MODE_INFINITY
+         * @see #FOCUS_MODE_MACRO
+         * @see #FOCUS_MODE_FIXED
+         * @see #FOCUS_MODE_EDOF
+         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         */
+        public String getFocusMode() {
+            return get(KEY_FOCUS_MODE);
         }
 
         /**
@@ -3038,7 +3769,246 @@ public class Camera {
         }
 
         /**
-         * <p>Gets the distances from the camera to where an object appears to be
+         * @hide
+         * Gets the current ISO setting.
+         *
+         * @return one of ISO_XXX string constant. null if ISO
+         *         setting is not supported.
+         */
+        public String getISOValue() {
+            return get(KEY_ISO_MODE);
+        }
+
+        /**
+         * @hide
+         * Sets the ISO.
+         *
+         * @param iso ISO_XXX string constant.
+         */
+        public void setISOValue(String iso) {
+            set(KEY_ISO_MODE, iso);
+        }
+
+         /**
+         * @hide
+         * Gets the supported ISO values.
+         *
+         * @return a list of ISO_XXX string constants. null if ISO
+         *         setting is not supported.
+         */
+        public List<String> getSupportedIsoValues() {
+            String str = get(KEY_ISO_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current LensShade Mode.
+         *
+         * @return LensShade Mode
+         */
+        public String getLensShade() {
+            return get(KEY_LENSSHADE);
+        }
+        /**
+         * @hide
+         * Sets the current LensShade Mode.
+         *
+         * @return LensShade Mode
+         */
+        public void setLensShade(String lensshade) {
+            set(KEY_LENSSHADE, lensshade);
+        }
+
+         /**
+         * @hide
+         * Gets the supported Lensshade modes.
+         *
+         * @return a List of LENS_MODE_XXX string constants. null if lens mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedLensShadeModes() {
+            String str = get(KEY_LENSSHADE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the supported Histogram modes.
+         *
+         * @return a List of HISTOGRAM_XXX string constants. null if histogram mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedHistogramModes() {
+            String str = get(KEY_HISTOGRAM + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the supported Skin Tone Enhancement modes.
+         *
+         * @return a List of SKIN_TONE_ENHANCEMENT_XXX string constants. null if skin tone enhancement
+         *         setting is not supported.
+         */
+        public List<String> getSupportedSkinToneEnhancementModes() {
+            String str = get(KEY_SKIN_TONE_ENHANCEMENT + SUPPORTED_VALUES_SUFFIX);
+          return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current auto exposure setting.
+         *
+         * @return one of AUTO_EXPOSURE_XXX string constant. null if auto exposure
+         *         setting is not supported.
+         */
+        public String getAutoExposure() {
+            return get(KEY_AUTO_EXPOSURE);
+        }
+
+        /**
+         * @hide
+         * Sets the current auto exposure setting.
+         *
+         * @param value AUTO_EXPOSURE_XXX string constants.
+         */
+        public void setAutoExposure(String value) {
+            set(KEY_AUTO_EXPOSURE, value);
+        }
+
+       /**
+         * @hide
+         * Gets the supported auto exposure setting.
+         *
+         * @return a List of AUTO_EXPOSURE_XXX string constants. null if auto exposure
+         *         setting is not supported.
+         */
+        public List<String> getSupportedAutoexposure() {
+            String str = get(KEY_AUTO_EXPOSURE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current MCE Mode.
+         *
+         * @return MCE value
+         */
+        public String getMemColorEnhance() {
+            return get(KEY_MEMORY_COLOR_ENHANCEMENT);
+        }
+
+        /**
+         * @hide
+         * Sets the current MCE Mode.
+         *
+         * @return MCE Mode
+         */
+        public void setMemColorEnhance(String mce) {
+            set(KEY_MEMORY_COLOR_ENHANCEMENT, mce);
+        }
+
+         /**
+         * @hide
+         * Gets the supported MCE modes.
+         *
+         * @return a List of MCE_ENABLE/DISABLE string constants. null if MCE mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedMemColorEnhanceModes() {
+            String str = get(KEY_MEMORY_COLOR_ENHANCEMENT + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current ZSL Mode.
+         *
+         * @return ZSL mode value
+         */
+         public String getZSLMode() {
+            return get(KEY_ZSL);
+         }
+
+         /**
+         * @hide
+         * Sets the current ZSL Mode. ZSL mode is set as a 0th bit in KEY_CAMERA_MODE.
+         *
+         * @return null
+         */
+        public void setZSLMode(String zsl) {
+            set(KEY_ZSL, zsl);
+        }
+
+         /**
+         * @hide
+         * Gets the supported ZSL modes.
+         *
+         * @return a List of ZSL_OFF/OFF string constants. null if ZSL mode
+         * setting is not supported.
+         */
+        public List<String> getSupportedZSLModes() {
+            String str = get(KEY_ZSL + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+          /**
+          * @hide
+          * Gets the current Camera Mode Flag. Camera mode includes a
+          * flag(byte) which indicates different camera modes.
+          * For now support for ZSL added at bit0
+          *
+          * @return Camera Mode.
+          */
+         public String getCameraMode() {
+            return get(KEY_CAMERA_MODE);
+         }
+
+          /**
+          * @hide
+          * Sets the current Camera Mode.
+          *
+          * @return null
+          */
+         public void setCameraMode(int cameraMode) {
+            set(KEY_CAMERA_MODE, cameraMode);
+         }
+
+         /**
+         * @hide
+         * Gets the current HFR Mode.
+         *
+         * @return VIDEO_HFR_XXX string constants
+         */
+        public String getVideoHighFrameRate() {
+            return get(KEY_VIDEO_HIGH_FRAME_RATE);
+        }
+
+        /**
+         * @hide
+         * Sets the current HFR Mode.
+         *
+         * @param hfr VIDEO_HFR_XXX string constants
+         */
+        public void setVideoHighFrameRate(String hfr) {
+            set(KEY_VIDEO_HIGH_FRAME_RATE, hfr);
+        }
+
+         /**
+         * @hide
+         * Gets the supported HFR modes.
+         *
+         * @return a List of VIDEO_HFR_XXX string constants. null if hfr mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedVideoHighFrameRateModes() {
+            String str = get(KEY_VIDEO_HIGH_FRAME_RATE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the distances from the camera to where an object appears to be
          * in focus. The object is sharpest at the optimal focus distance. The
          * depth of field is the far focus distance minus near focus distance.</p>
          *
@@ -3131,6 +4101,28 @@ public class Camera {
         public List<Area> getFocusAreas() {
             return splitArea(get(KEY_FOCUS_AREAS));
         }
+        /**
+         * @hide
+         * Gets the current DENOISE  setting.
+         *
+         * @return one of DENOISE_XXX string constant. null if Denoise
+         *         setting is not supported.
+         *
+         */
+         public String getDenoise() {
+         return get(KEY_DENOISE);
+         }
+        /**
+         * @hide
+         * Gets the current Continuous AF setting.
+         *
+         * @return one of CONTINUOUS_AF_XXX string constant. null if continuous AF
+         *         setting is not supported.
+         *
+         */
+         public String getContinuousAf() {
+            return get(KEY_CONTINUOUS_AF);
+        }
 
         /**
          * Sets focus areas. See {@link #getFocusAreas()} for documentation.
@@ -3141,6 +4133,25 @@ public class Camera {
         public void setFocusAreas(List<Area> focusAreas) {
             set(KEY_FOCUS_AREAS, focusAreas);
         }
+        /**
+         * @hide
+         * Sets the current Denoise  mode.
+         * @param value DENOISE_XXX string constants.
+         *
+         */
+
+         public void setDenoise(String value) {
+             set(KEY_DENOISE, value);
+         }
+        /**
+         * @hide
+         * Sets the current Continuous AF mode.
+         * @param value CONTINUOUS_AF_XXX string constants.
+         *
+         */
+         public void setContinuousAf(String value) {
+            set(KEY_CONTINUOUS_AF, value);
+        }
 
         /**
          * Gets the maximum number of metering areas supported. This is the
@@ -3199,15 +4210,51 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Gets the supported Continuous AF modes.
+         *
+         * @return a List of CONTINUOUS_AF_XXX string constant. null if continuous AF
+         *         setting is not supported.
+         *
+         */
+         public List<String> getSupportedContinuousAfModes() {
+            String str = get(KEY_CONTINUOUS_AF + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        /**
+         * @hide
+         * Gets the supported DENOISE  modes.
+         *
+         * @return a List of DENOISE_XXX string constant. null if DENOISE
+         *         setting is not supported.
+         *
+         */
+         public List<String> getSupportedDenoiseModes() {
+             String str = get(KEY_DENOISE + SUPPORTED_VALUES_SUFFIX);
+             return split(str);
+         }
+
+
+        /**
          * Sets metering areas. See {@link #getMeteringAreas()} for
          * documentation.
          *
          * @param meteringAreas the metering areas
          * @see #getMeteringAreas()
          */
-        public void setMeteringAreas(List<Area> meteringAreas) {
+         public void setMeteringAreas(List<Area> meteringAreas) {
             set(KEY_METERING_AREAS, meteringAreas);
         }
+        /**
+         * @hide
+         * Gets the current selectable zone af setting.
+         *
+         * @return one of SELECTABLE_ZONE_AF_XXX string constant. null if selectable zone af
+         *         setting is not supported.
+         */
+         public String getSelectableZoneAf() {
+            return get(KEY_SELECTABLE_ZONE_AF);
+        }
 
         /**
          * Gets the maximum number of detected faces supported. This is the
@@ -3218,9 +4265,18 @@ public class Camera {
          * @return the maximum number of detected face supported by the camera.
          * @see #startFaceDetection()
          */
-        public int getMaxNumDetectedFaces() {
+         public int getMaxNumDetectedFaces() {
             return getInt(KEY_MAX_NUM_DETECTED_FACES_HW, 0);
         }
+        /**
+         * @hide
+         * Sets the current selectable zone af setting.
+         *
+         * @param value SELECTABLE_ZONE_AF_XXX string constants.
+         */
+         public void setSelectableZoneAf(String value) {
+            set(KEY_SELECTABLE_ZONE_AF, value);
+        }
 
         /**
          * Sets recording mode hint. This tells the camera that the intent of
@@ -3245,6 +4301,18 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Gets the supported selectable zone af setting.
+         *
+         * @return a List of SELECTABLE_ZONE_AF_XXX string constants. null if selectable zone af
+         *         setting is not supported.
+         */
+        public List<String> getSupportedSelectableZoneAf() {
+            String str = get(KEY_SELECTABLE_ZONE_AF + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
          * Returns true if video snapshot is supported. That is, applications
          * can call {@link #takePicture(Camera.ShutterCallback,
          * Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)}
@@ -3272,6 +4340,27 @@ public class Camera {
             return TRUE.equals(str);
         }
 
+        /** 
+         * @hide
+         * @return true if full size video snapshot is supported. 
+         */ 
+        public boolean isFullsizeVideoSnapSupported() {
+            String str = get(KEY_FULL_VIDEO_SNAP_SUPPORTED);
+            return TRUE.equals(str);
+        }
+
+        /**
+         * @hide
+         * Gets the current face detection setting.
+         *
+         * @return one of FACE_DETECTION_XXX string constant. null if face detection
+         *         setting is not supported.
+         *
+         */
+        public String getFaceDetectionMode() {
+            return get(KEY_FACE_DETECTION);
+        }
+
         /**
          * <p>Enables and disables video stabilization. Use
          * {@link #isVideoStabilizationSupported} to determine if calling this
@@ -3297,6 +4386,17 @@ public class Camera {
         }
 
         /**
+         * Sets the auto scene detect. Other settings like Touch AF/AEC might be
+         * changed after setting face detection.
+         *
+         * @param value FACE_DETECTION_XXX string constants.
+         * @hide
+         */
+        public void setFaceDetectionMode(String value) {
+            set(KEY_FACE_DETECTION, value);
+        }
+
+        /**
          * Get the current state of video stabilization. See
          * {@link #setVideoStabilization} for details of video stabilization.
          *
@@ -3322,6 +4422,19 @@ public class Camera {
             return TRUE.equals(str);
         }
 
+        /**
+         * @hide
+         * Gets the supported face detection modes.
+         *
+         * @return a List of FACE_DETECTION_XXX string constant. null if face detection
+         *         setting is not supported.
+         *
+         */
+        public List<String> getSupportedFaceDetectionModes() {
+            String str = get(KEY_FACE_DETECTION + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
         // Splits a comma delimited string to an ArrayList of String.
         // Return null if the passing string is null or the size is 0.
         private ArrayList<String> split(String str) {
@@ -3484,6 +4597,37 @@ public class Camera {
             return result;
         }
 
+	// Splits a comma delimited string to an ArrayList of Coordinate.
+        // Return null if the passing string is null or the Coordinate is 0.
+        private ArrayList<Coordinate> splitCoordinate(String str) {
+            if (str == null) return null;
+
+            StringTokenizer tokenizer = new StringTokenizer(str, ",");
+            ArrayList<Coordinate> coordinateList = new ArrayList<Coordinate>();
+            while (tokenizer.hasMoreElements()) {
+                Coordinate c = strToCoordinate(tokenizer.nextToken());
+                if (c != null) coordinateList.add(c);
+            }
+            if (coordinateList.size() == 0) return null;
+            return coordinateList;
+        }
+
+        // Parses a string (ex: "500x500") to Coordinate object.
+        // Return null if the passing string is null.
+        private Coordinate strToCoordinate(String str) {
+            if (str == null) return null;
+
+            int pos = str.indexOf('x');
+            if (pos != -1) {
+                String x = str.substring(0, pos);
+                String y = str.substring(pos + 1);
+                return new Coordinate(Integer.parseInt(x),
+                                Integer.parseInt(y));
+            }
+            Log.e(TAG, "Invalid Coordinate parameter string=" + str);
+            return null;
+        }
+
         private boolean same(String s1, String s2) {
             if (s1 == null && s2 == null) return true;
             if (s1 != null && s1.equals(s2)) return true;
diff --git a/core/java/android/os/Power.java b/core/java/android/os/Power.java
index 5a79215..492312d 100644
--- a/core/java/android/os/Power.java
+++ b/core/java/android/os/Power.java
@@ -104,4 +104,12 @@ public class Power
     }
 
     private static native void rebootNative(String reason) throws IOException ;
+
+    /**
+     * Activate/DeActivate Unstable Memory block
+     *
+     * @param on Whether you want Activate(true) or DeActive(False)
+     * @hide
+     */
+    public static native int SetUnstableMemoryState(boolean on);
 }
diff --git a/core/java/android/os/SystemProperties.java b/core/java/android/os/SystemProperties.java
index 619bf8d..3ab8c94 100644
--- a/core/java/android/os/SystemProperties.java
+++ b/core/java/android/os/SystemProperties.java
@@ -28,6 +28,10 @@ public class SystemProperties
     public static final int PROP_NAME_MAX = 31;
     public static final int PROP_VALUE_MAX = 91;
 
+    // QCOM Hardware
+    public static final boolean QCOM_HARDWARE = native_get_boolean("com.qc.hardware", false);
+    public static final boolean QCOM_HDMI_OUT = native_get_boolean("com.qc.hdmi_out", false);
+
     private static native String native_get(String key);
     private static native String native_get(String key, String def);
     private static native int native_get_int(String key, int def);
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index d7fab37..3ffa4dc 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -1884,6 +1884,12 @@ public final class Settings {
         public static final String POINTER_SPEED = "pointer_speed";
 
         /**
+         * Whether national data roaming should be used.
+         * @hide
+         */
+        public static final String MVNO_ROAMING = "mvno_roaming";
+
+        /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
          *
diff --git a/core/java/android/view/GLES20Canvas.java b/core/java/android/view/GLES20Canvas.java
index 4ca299f..3a6183a 100644
--- a/core/java/android/view/GLES20Canvas.java
+++ b/core/java/android/view/GLES20Canvas.java
@@ -254,9 +254,25 @@ class GLES20Canvas extends HardwareCanvas {
         }
     }
 
+    @Override
+    void startTileRendering(Rect dirty) {
+        if (dirty != null) {
+            nStartTileRendering(mRenderer, dirty.left, dirty.top, dirty.right, dirty.bottom);
+        } else {
+            nStartTileRendering(mRenderer, 0, 0, 0, 0);
+        }
+    }
+
+    @Override
+    void endTileRendering() {
+            nEndTileRendering(mRenderer);
+    }
+
     private static native void nPrepare(int renderer, boolean opaque);
     private static native void nPrepareDirty(int renderer, int left, int top, int right, int bottom,
             boolean opaque);
+    private static native void nStartTileRendering(int renderer, int left, int top, int right, int bottom);
+    private static native void nEndTileRendering(int renderer);
 
     @Override
     void onPostDraw() {
diff --git a/core/java/android/view/HardwareCanvas.java b/core/java/android/view/HardwareCanvas.java
index 23b3abc..1a6c7b6 100644
--- a/core/java/android/view/HardwareCanvas.java
+++ b/core/java/android/view/HardwareCanvas.java
@@ -43,6 +43,8 @@ public abstract class HardwareCanvas extends Canvas {
      * @param dirty The dirty rectangle to update, can be null.
      */
     abstract void onPreDraw(Rect dirty);
+    abstract void startTileRendering(Rect dirty);
+    abstract void endTileRendering();
 
     /**
      * Invoked after all drawing operation have been performed.
diff --git a/core/java/android/view/HardwareRenderer.java b/core/java/android/view/HardwareRenderer.java
index 71f3cf5..a95b22c 100644
--- a/core/java/android/view/HardwareRenderer.java
+++ b/core/java/android/view/HardwareRenderer.java
@@ -74,9 +74,18 @@ public abstract class HardwareRenderer {
     static final String RENDER_DIRTY_REGIONS_PROPERTY = "hwui.render_dirty_regions";
     
     /**
+     * System property used to enable or disable tile rendering
+     *
+     * Possible values:
+     * "true", to enable tile rendering
+     * "false", to disable tile rendering
+     */
+    static final String TILE_RENDERING_PROPERTY = "debug.enabletr";
+
+    /**
      * System property used to enable or disable vsync.
      * The default value of this property is assumed to be false.
-     * 
+     *
      * Possible values:
      * "true", to disable vsync
      * "false", to enable vsync
@@ -433,14 +442,22 @@ public abstract class HardwareRenderer {
 
         static boolean sDirtyRegions;
         static final boolean sDirtyRegionsRequested;
+        static boolean sTileRendering;
         static {
             String dirtyProperty = SystemProperties.get(RENDER_DIRTY_REGIONS_PROPERTY, "true");
+            String trProperty = SystemProperties.get(TILE_RENDERING_PROPERTY, "false");
             //noinspection PointlessBooleanExpression,ConstantConditions
-            sDirtyRegions = RENDER_DIRTY_REGIONS && "true".equalsIgnoreCase(dirtyProperty);
+            //enable dirty regions if tile-rendering enabled or dirty regions property enabled
+            sTileRendering = "true".equalsIgnoreCase(trProperty);
+            sDirtyRegions = RENDER_DIRTY_REGIONS &&
+                            ("true".equalsIgnoreCase(dirtyProperty) ||
+                             sTileRendering);
             sDirtyRegionsRequested = sDirtyRegions;
         }
 
         boolean mDirtyRegionsEnabled;
+        boolean mUpdateDirtyRegions;
+
         final boolean mVsyncDisabled;
 
         final int mGlVersion;
@@ -675,6 +692,12 @@ public abstract class HardwareRenderer {
             
             initCaches();
 
+            enableDirtyRegions();
+
+            return mEglContext.getGL();
+        }
+
+        private void enableDirtyRegions() {
             // If mDirtyRegions is set, this means we have an EGL configuration
             // with EGL_SWAP_BEHAVIOR_PRESERVED_BIT set
             if (sDirtyRegions) {
@@ -690,8 +713,6 @@ public abstract class HardwareRenderer {
                 // configuration (see RENDER_DIRTY_REGIONS)
                 mDirtyRegionsEnabled = GLES20Canvas.isBackBufferPreserved();
             }
-
-            return mEglContext.getGL();
         }
 
         abstract void initCaches();
@@ -745,6 +766,9 @@ public abstract class HardwareRenderer {
                 if (!createSurface(holder)) {
                     return;
                 }
+
+                mUpdateDirtyRegions = true;
+
                 if (mCanvas != null) {
                     setEnabled(true);
                 }
@@ -799,6 +823,12 @@ public abstract class HardwareRenderer {
             return mGl != null && mCanvas != null;
         }        
         
+        void startTileRendering(Rect dirty) {
+        }
+
+        void endTileRendering() {
+        }
+
         void onPreDraw(Rect dirty) {
         }
 
@@ -826,6 +856,9 @@ public abstract class HardwareRenderer {
                         dirty = null;
                     }
 
+                    if (sTileRendering)
+                        startTileRendering(dirty);
+
                     onPreDraw(dirty);
 
                     HardwareCanvas canvas = mCanvas;
@@ -871,6 +904,8 @@ public abstract class HardwareRenderer {
                     }
 
                     onPostDraw();
+                    if (sTileRendering)
+                        endTileRendering();
 
                     attachInfo.mIgnoreDirtyState = false;
 
@@ -906,6 +941,12 @@ public abstract class HardwareRenderer {
                     fallback(true);
                     return SURFACE_STATE_ERROR;
                 } else {
+                    if (SystemProperties.QCOM_HARDWARE ) {
+                        if (mUpdateDirtyRegions) {
+                            enableDirtyRegions();
+                            mUpdateDirtyRegions = false;
+                        }
+                     }
                     return SURFACE_STATE_UPDATED;
                 }
             }
@@ -1014,6 +1055,16 @@ public abstract class HardwareRenderer {
         }
 
         @Override
+        void startTileRendering(Rect dirty) {
+            mGlCanvas.startTileRendering(dirty);
+        }
+
+        @Override
+        void endTileRendering() {
+            mGlCanvas.endTileRendering();
+        }
+
+        @Override
         void destroy(boolean full) {
             try {
                 super.destroy(full);
diff --git a/core/java/android/view/Surface.java b/core/java/android/view/Surface.java
index edaa262..3471677 100644
--- a/core/java/android/view/Surface.java
+++ b/core/java/android/view/Surface.java
@@ -76,6 +76,18 @@ public class Surface implements Parcelable {
         return lockCanvasNative(dirty);
     }
 
+    /**
+     * @hide
+     */
+    public void setStereoscopic3DFormat(int format) {
+        setStereoscopic3DFormatNative(format);
+    }
+
+    /**
+     * @hide
+     */
+    private native void setStereoscopic3DFormatNative(int format);
+
     /** unlock the surface and asks a page flip */
     public native   void unlockCanvasAndPost(Canvas canvas);
 
diff --git a/core/java/android/view/SurfaceHolder.java b/core/java/android/view/SurfaceHolder.java
index 2a16725..0b05282 100644
--- a/core/java/android/view/SurfaceHolder.java
+++ b/core/java/android/view/SurfaceHolder.java
@@ -46,6 +46,27 @@ public interface SurfaceHolder {
     public static final int SURFACE_TYPE_PUSH_BUFFERS = 3;
 
     /**
+     * Stereoscopic Side-by-Side Half 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_HALF_L_R = 0x10000;
+    /**
+     * Stereoscopic Top Bottom 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_TOP_BOTTOM   = 0x20000;
+    /**
+     * Stereoscopic Interleaved 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_INTERLEAVED  = 0x40000;
+    /**
+     * Stereoscopic Side-by-Side Full 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_R_L = 0x80000;
+
+    /**
      * Exception that is thrown from {@link #lockCanvas} when called on a Surface
      * whose type is SURFACE_TYPE_PUSH_BUFFERS.
      */
diff --git a/core/java/android/view/SurfaceView.java b/core/java/android/view/SurfaceView.java
index 6726c56..adc4e8e 100644
--- a/core/java/android/view/SurfaceView.java
+++ b/core/java/android/view/SurfaceView.java
@@ -692,8 +692,16 @@ public class SurfaceView extends View {
         }
 
         public void setFormat(int format) {
-
-            // for backward compatibility reason, OPAQUE always
+            switch (format) {
+                case STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_HALF_L_R:
+                case STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_R_L:
+                case STEREOSCOPIC_3D_FORMAT_TOP_BOTTOM:
+                case STEREOSCOPIC_3D_FORMAT_INTERLEAVED:
+                    mSurface.setStereoscopic3DFormat(format);
+                    return;
+                default:
+                    break;
+            }            // for backward compatibility reason, OPAQUE always
             // means 565 for SurfaceView
             if (format == PixelFormat.OPAQUE)
                 format = PixelFormat.RGB_565;
diff --git a/core/java/org/codeaurora/Performance.java b/core/java/org/codeaurora/Performance.java
new file mode 100644
index 0000000..bbdbb80
--- /dev/null
+++ b/core/java/org/codeaurora/Performance.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.codeaurora;
+
+import android.util.Log;
+
+public class Performance
+{
+    private static final String TAG = "Perf";
+
+    /** &hide */
+    public Performance() {
+        //Log.d(TAG, "Perf module initialized");
+    }
+
+    /** &hide */
+    protected void finalize() {
+        native_deinit();
+    }
+
+    /** &hide */
+    public void cpuBoost(int ntasks) {
+        native_cpu_boost(ntasks);
+    }
+
+    /** @hide */ public static final int CPUOPT_CPU0_PWRCLSP = 1;
+    /** @hide */ public static final int CPUOPT_CPU0_FREQMIN = 2;
+
+    /** &hide */
+    public int cpuSetOptions(int reqType, int reqValue) {
+        return native_cpu_setoptions(reqType, reqValue);
+    }
+
+    private native void native_cpu_boost(int ntasks);
+    private native int  native_cpu_setoptions(int reqtype, int reqvalue);
+    private native void native_deinit();
+}
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index 71c5d26..a86f4f6 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -155,7 +155,11 @@ LOCAL_SRC_FILES:= \
 	android_app_backup_FullBackup.cpp \
 	android_content_res_ObbScanner.cpp \
 	android_content_res_Configuration.cpp \
-    android_animation_PropertyValuesHolder.cpp
+  	android_animation_PropertyValuesHolder.cpp
+
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_SRC_FILES += org_codeaurora_Performance.cpp
+endif
 
 LOCAL_C_INCLUDES += \
 	$(JNI_H_INCLUDE) \
@@ -222,6 +226,13 @@ ifeq ($(USE_OPENGL_RENDERER),true)
 	LOCAL_SHARED_LIBRARIES += libhwui
 endif
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+ifeq ($(USE_OPENGL_RENDERER),true)
+LOCAL_SHARED_LIBRARIES += libtilerenderer
+endif
+LOCAL_C_INCLUDES += hardware/qcom/display/libtilerenderer
+endif
+
 ifeq ($(BOARD_HAVE_BLUETOOTH),true)
 LOCAL_C_INCLUDES += \
 	external/dbus \
@@ -244,6 +255,11 @@ endif
 
 LOCAL_MODULE:= libandroid_runtime
 
+ifneq ($(BOARD_MOBILEDATA_INTERFACE_NAME),)
+	LOCAL_CFLAGS += -DMOBILE_IFACE_NAME='$(BOARD_MOBILEDATA_INTERFACE_NAME)'
+endif
+
+
 include $(BUILD_SHARED_LIBRARY)
 
 include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index c00e6c9..95c7fe9 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -177,6 +177,10 @@ extern int register_android_content_res_ObbScanner(JNIEnv* env);
 extern int register_android_content_res_Configuration(JNIEnv* env);
 extern int register_android_animation_PropertyValuesHolder(JNIEnv *env);
 extern int register_com_android_internal_content_NativeLibraryHelper(JNIEnv *env);
+#ifdef QCOM_HARDWARE
+extern int register_org_codeaurora_Performance(JNIEnv *env);
+#endif
+ 
 
 static AndroidRuntime* gCurRuntime = NULL;
 
@@ -1203,6 +1207,10 @@ static const RegJNIRec gRegJNI[] = {
 
     REG_JNI(register_android_animation_PropertyValuesHolder),
     REG_JNI(register_com_android_internal_content_NativeLibraryHelper),
+
+#ifdef QCOM_HARDWARE
+    REG_JNI(register_org_codeaurora_Performance),
+#endif
 };
 
 /*
diff --git a/core/jni/android_hardware_Camera.cpp b/core/jni/android_hardware_Camera.cpp
index fe60381..c8dd098 100644
--- a/core/jni/android_hardware_Camera.cpp
+++ b/core/jni/android_hardware_Camera.cpp
@@ -601,6 +601,42 @@ static void android_hardware_Camera_setHasPreviewCallback(JNIEnv *env, jobject t
     context->setCallbackMode(env, installed, manualBuffer);
 }
 
+ static void android_hardware_Camera_sendHistogramData(JNIEnv *env, jobject thiz)
+ {
+#ifdef QCOM_HARDWARE
+   LOGV("setHistogramMode: mode:" );
+   JNICameraContext* context;
+   status_t rc;
+   sp<Camera> camera = get_native_camera(env, thiz, &context);
+   if (camera == 0) return;
+
+   rc = camera->sendCommand(CAMERA_CMD_HISTOGRAM_SEND_DATA, 0, 0);
+
+   if (rc != NO_ERROR) {
+      jniThrowException(env, "java/lang/RuntimeException", "set histogram mode failed");
+     }
+#endif
+ }
+ static void android_hardware_Camera_setHistogramMode(JNIEnv *env, jobject thiz, jboolean mode)
+ {
+#ifdef QCOM_HARDWARE
+   LOGV("sendHistogramData: mode:%d", (int)mode);
+   JNICameraContext* context;
+   status_t rc;
+   sp<Camera> camera = get_native_camera(env, thiz, &context);
+   if (camera == 0) return;
+
+   if(mode == true)
+      rc = camera->sendCommand(CAMERA_CMD_HISTOGRAM_ON, 0, 0);
+   else
+      rc = camera->sendCommand(CAMERA_CMD_HISTOGRAM_OFF, 0, 0);
+
+   if (rc != NO_ERROR) {
+      jniThrowException(env, "java/lang/RuntimeException", "set histogram mode failed");
+     }
+#endif
+ }
+
 static void android_hardware_Camera_addCallbackBuffer(JNIEnv *env, jobject thiz, jbyteArray bytes, int msgType) {
     LOGV("addCallbackBuffer: 0x%x", msgType);
 
@@ -840,6 +876,12 @@ static JNINativeMethod camMethods[] = {
   { "native_takePicture",
     "(I)V",
     (void *)android_hardware_Camera_takePicture },
+  { "native_setHistogramMode",
+    "(Z)V",
+    (void *)android_hardware_Camera_setHistogramMode },
+  { "native_sendHistogramData",
+    "()V",
+    (void *)android_hardware_Camera_sendHistogramData },
   { "native_setParameters",
     "(Ljava/lang/String;)V",
     (void *)android_hardware_Camera_setParameters },
diff --git a/core/jni/android_net_TrafficStats.cpp b/core/jni/android_net_TrafficStats.cpp
index 7a61432..1e3cf6d 100644
--- a/core/jni/android_net_TrafficStats.cpp
+++ b/core/jni/android_net_TrafficStats.cpp
@@ -64,6 +64,9 @@ static jlong readNumber(char const* filename) {
 }
 
 static const char* mobile_iface_list[] = {
+#ifdef MOBILE_IFACE_NAME
+    MOBILE_IFACE_NAME,
+#endif
     "rmnet0",
     "rmnet1",
     "rmnet2",
diff --git a/core/jni/android_net_wifi_Wifi.cpp b/core/jni/android_net_wifi_Wifi.cpp
index 84c636b..62e574b 100644
--- a/core/jni/android_net_wifi_Wifi.cpp
+++ b/core/jni/android_net_wifi_Wifi.cpp
@@ -119,6 +119,21 @@ static jboolean android_net_wifi_unloadDriver(JNIEnv* env, jobject)
     return (jboolean)(::wifi_unload_driver() == 0);
 }
 
+static jboolean android_net_wifi_isHotspotDriverLoaded(JNIEnv* env, jobject)
+{
+    return (jboolean)(::is_wifi_hotspot_driver_loaded() == 1);
+}
+
+static jboolean android_net_wifi_loadHotspotDriver(JNIEnv* env, jobject)
+{
+    return (jboolean)(::wifi_load_hotspot_driver() == 0);
+}
+
+static jboolean android_net_wifi_unloadHotspotDriver(JNIEnv* env, jobject)
+{
+    return (jboolean)(::wifi_unload_hotspot_driver() == 0);
+}
+
 static jboolean android_net_wifi_startSupplicant(JNIEnv* env, jobject)
 {
     return (jboolean)(::wifi_start_supplicant() == 0);
@@ -561,6 +576,9 @@ static JNINativeMethod gWifiMethods[] = {
     { "loadDriver", "()Z",  (void *)android_net_wifi_loadDriver },
     { "isDriverLoaded", "()Z",  (void *)android_net_wifi_isDriverLoaded},
     { "unloadDriver", "()Z",  (void *)android_net_wifi_unloadDriver },
+    { "loadHotspotDriver", "()Z",  (void *)android_net_wifi_loadHotspotDriver },
+    { "isHotspotDriverLoaded", "()Z",  (void *)android_net_wifi_isHotspotDriverLoaded},
+    { "unloadHotspotDriver", "()Z",  (void *)android_net_wifi_unloadHotspotDriver },
     { "startSupplicant", "()Z",  (void *)android_net_wifi_startSupplicant },
     { "startP2pSupplicant", "()Z",  (void *)android_net_wifi_startP2pSupplicant },
     { "stopSupplicant", "()Z", (void*) android_net_wifi_stopSupplicant },
diff --git a/core/jni/android_os_Power.cpp b/core/jni/android_os_Power.cpp
index dc16990..e6bdad3 100644
--- a/core/jni/android_os_Power.cpp
+++ b/core/jni/android_os_Power.cpp
@@ -85,6 +85,15 @@ static void android_os_Power_reboot(JNIEnv *env, jobject clazz, jstring reason)
     jniThrowIOException(env, errno);
 }
 
+#ifdef QCOM_HARDWARE
+static int
+SetUnstableMemoryState(JNIEnv *env, jobject clazz, jboolean on)
+{
+    return set_unstable_memory_state(on);
+}
+#endif
+
+
 static JNINativeMethod method_table[] = {
     { "acquireWakeLock", "(ILjava/lang/String;)V", (void*)acquireWakeLock },
     { "releaseWakeLock", "(Ljava/lang/String;)V", (void*)releaseWakeLock },
@@ -92,6 +101,9 @@ static JNINativeMethod method_table[] = {
     { "setScreenState", "(Z)I", (void*)setScreenState },
     { "shutdown", "()V", (void*)android_os_Power_shutdown },
     { "rebootNative", "(Ljava/lang/String;)V", (void*)android_os_Power_reboot },
+#ifdef QCOM_HARDWARE
+    { "SetUnstableMemoryState",  "(Z)I", (void*)SetUnstableMemoryState},
+#endif
 };
 
 int register_android_os_Power(JNIEnv *env)
diff --git a/core/jni/android_view_GLES20Canvas.cpp b/core/jni/android_view_GLES20Canvas.cpp
index 426f4f7..eb3a87a 100644
--- a/core/jni/android_view_GLES20Canvas.cpp
+++ b/core/jni/android_view_GLES20Canvas.cpp
@@ -44,6 +44,10 @@
 #include <SkiaColorFilter.h>
 #include <Rect.h>
 
+#ifdef QCOM_HARDWARE
+#include <tilerenderer.h>
+#endif
+
 #include <TextLayout.h>
 
 namespace android {
@@ -176,6 +180,18 @@ static void android_view_GLES20Canvas_prepare(JNIEnv* env, jobject clazz,
     renderer->prepare(opaque);
 }
 
+#ifdef QCOM_HARDWARE
+static void android_view_GLES20Canvas_startTileRendering(JNIEnv* env, jobject clazz,
+        OpenGLRenderer* renderer, jint left, jint top, jint right, jint bottom) {
+    TileRenderer::getInstance().startTileRendering(renderer, left, top, right, bottom);
+}
+
+static void android_view_GLES20Canvas_endTileRendering(JNIEnv* env, jobject clazz,
+        OpenGLRenderer* renderer) {
+    TileRenderer::getInstance().endTileRendering(renderer);
+}
+#endif
+
 static void android_view_GLES20Canvas_prepareDirty(JNIEnv* env, jobject clazz,
         OpenGLRenderer* renderer, jint left, jint top, jint right, jint bottom,
         jboolean opaque) {
@@ -613,7 +629,7 @@ static void android_view_GLES20Canvas_resetDisplayListRenderer(JNIEnv* env,
 
 static void android_view_GLES20Canvas_destroyDisplayList(JNIEnv* env,
         jobject clazz, DisplayList* displayList) {
-    delete displayList;
+    DisplayList::destroyDisplayListDeferred(displayList);
 }
 
 static bool android_view_GLES20Canvas_drawDisplayList(JNIEnv* env,
@@ -785,6 +801,10 @@ static JNINativeMethod gMethods[] = {
     { "nSetViewport",       "(III)V",          (void*) android_view_GLES20Canvas_setViewport },
     { "nPrepare",           "(IZ)V",           (void*) android_view_GLES20Canvas_prepare },
     { "nPrepareDirty",      "(IIIIIZ)V",       (void*) android_view_GLES20Canvas_prepareDirty },
+#ifdef QCOM_HARDWARE
+    { "nStartTileRendering","(IIIII)V",        (void*) android_view_GLES20Canvas_startTileRendering},
+    { "nEndTileRendering",  "(I)V",            (void*) android_view_GLES20Canvas_endTileRendering},
+#endif
     { "nFinish",            "(I)V",            (void*) android_view_GLES20Canvas_finish },
 
     { "nCallDrawGLFunction", "(II)Z",
diff --git a/core/jni/android_view_Surface.cpp b/core/jni/android_view_Surface.cpp
index bba4b47..3a7b918 100644
--- a/core/jni/android_view_Surface.cpp
+++ b/core/jni/android_view_Surface.cpp
@@ -610,6 +610,20 @@ static void Surface_setSize(
     }
 }
 
+#ifdef QCOM_HARDWARE
+static void Surface_setStereoscopic3DFormat(JNIEnv* env, jobject clazz, jint f)
+{
+    const sp<Surface>& surface(getSurface(env, clazz));
+    if (!Surface::isValid(surface))
+        return;
+
+    status_t err = surface->setStereoscopic3DFormat(f);
+    if (err<0 && err!=NO_INIT) {
+        doThrowIAE(env);
+    }
+}
+#endif
+
 static void Surface_hide(
         JNIEnv* env, jobject clazz)
 {
diff --git a/core/jni/org_codeaurora_Performance.cpp b/core/jni/org_codeaurora_Performance.cpp
new file mode 100644
index 0000000..496972a
--- /dev/null
+++ b/core/jni/org_codeaurora_Performance.cpp
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_TAG "ANDR-PERF-JNI"
+
+#include "jni.h"
+#include "JNIHelp.h"
+#include <android_runtime/AndroidRuntime.h>
+
+#include <dlfcn.h>
+#include <limits.h>
+#include <string.h>
+
+#include <cutils/properties.h>
+#include <utils/Log.h>
+
+#define LIBRARY_PATH_PREFIX	"/system/lib/"
+
+namespace android
+{
+
+// ----------------------------------------------------------------------------
+
+static void (*cpu_boost)(int)           = NULL;
+static int  (*cpu_setoptions)(int, int) = NULL;
+static void *dlhandle                   = NULL;
+
+// ----------------------------------------------------------------------------
+
+static void
+org_codeaurora_performance_native_init()
+{
+    const char *rc;
+    void (*init)(void);
+    char buf[PROPERTY_VALUE_MAX];
+    int len;
+
+    /* Retrieve name of vendor extension library */
+    if (property_get("ro.vendor.extension_library", buf, NULL) <= 0) {
+        return;
+    }
+
+    /* Sanity check - ensure */
+    buf[PROPERTY_VALUE_MAX-1] = '\0';
+    if ((strncmp(buf, LIBRARY_PATH_PREFIX, sizeof(LIBRARY_PATH_PREFIX) - 1) != 0)
+        ||
+        (strstr(buf, "..") != NULL)) {
+        return;
+    }
+
+    dlhandle = dlopen(buf, RTLD_NOW | RTLD_LOCAL);
+    if (dlhandle == NULL) {
+        return;
+    }
+
+    dlerror();
+
+    cpu_boost = (void (*) (int))dlsym(dlhandle, "perf_cpu_boost");
+    if ((rc = dlerror()) != NULL) {
+        goto cleanup;
+    }
+    cpu_setoptions = (int (*) (int, int))dlsym(dlhandle, "perf_cpu_setoptions");
+    if ((rc = dlerror()) != NULL) {
+        goto cleanup;
+    }
+    init = (void (*) ())dlsym(dlhandle, "libqc_opt_init");
+    if ((rc = dlerror()) != NULL) {
+        goto cleanup;
+    }
+    (*init)();
+    return;
+
+cleanup:
+    cpu_boost      = NULL;
+    cpu_setoptions = NULL;
+    if (dlhandle) {
+        dlclose(dlhandle);
+        dlhandle = NULL;
+    }
+}
+
+static void
+org_codeaurora_performance_native_deinit(JNIEnv *env, jobject clazz)
+{
+    void (*deinit)(void);
+
+    if (dlhandle) {
+        cpu_boost      = NULL;
+        cpu_setoptions = NULL;
+
+        deinit = (void (*) ())dlsym(dlhandle, "libqc_opt_deinit");
+        if (deinit) {
+            (*deinit)();
+        }
+
+        dlclose(dlhandle);
+        dlhandle       = NULL;
+    }
+}
+
+static void
+org_codeaurora_performance_native_cpu_boost(JNIEnv *env, jobject clazz, jint ntasks)
+{
+    if (cpu_boost) {
+        (*cpu_boost)(ntasks);
+    }
+}
+
+static jint
+org_codeaurora_performance_native_cpu_setoptions(JNIEnv *env, jobject clazz,
+                                                 jint reqtype, jint reqvalue)
+{
+    if (cpu_setoptions) {
+        return (*cpu_setoptions)(reqtype, reqvalue);
+    }
+    return 0;
+}
+
+
+// ----------------------------------------------------------------------------
+
+static JNINativeMethod gMethods[] = {
+    {"native_cpu_boost",      "(I)V",                  (void *)org_codeaurora_performance_native_cpu_boost},
+    {"native_cpu_setoptions", "(II)I",                 (int *)org_codeaurora_performance_native_cpu_setoptions},
+    {"native_deinit",         "()V",                   (void *)org_codeaurora_performance_native_deinit},
+};
+
+
+int register_org_codeaurora_Performance(JNIEnv *env)
+{
+    org_codeaurora_performance_native_init();
+
+    return AndroidRuntime::registerNativeMethods(env,
+            "org/codeaurora/Performance", gMethods, NELEM(gMethods));
+}
+
+}   // namespace android
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 24afe15..95836ac 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -265,6 +265,12 @@
          point on the move. A value of 0 means no periodic scans will be used in the framework. -->
     <integer translatable="false" name="config_wifi_framework_scan_interval">300000</integer>
 
+    <!-- Boolean indicating whether Softap rely only on one interface -->
+    <bool name="config_wifi_ap_use_single_interface">false</bool>
+
+    <!-- Boolean indicating whether Softap require reloading AP firware -->
+    <bool name="config_wifi_ap_firmware_reload">true</bool>
+
     <!-- Flag indicating whether the keyguard should be bypassed when
          the slider is open.  This can be set or unset depending how easily
          the slider can be opened (for example, in a pocket or purse). -->
@@ -645,6 +651,12 @@
     <!-- The VoiceMail default value is displayed to my own number if it is true -->
     <bool name="config_telephony_use_own_number_for_voicemail">false</bool>
 
+    <!-- Set additional audio parameters for incall audio
+         Usage: parameter=onstring=offstring
+         Examples: <item>realcall=on=off</item> <item>dualmic_enabled=true=false</item> <item>mic_boost=yes=no</item> -->
+    <string-array name="config_telephony_set_audioparameters" translatable="false">
+    </string-array>
+
     <!-- If this value is true, Sms encoded as octet is decoded by utf8 decoder.
          If false, decoded by Latin decoder. -->
     <bool name="config_sms_utf8_support">false</bool>
@@ -653,6 +665,9 @@
          If false, Content-disposition fragments are ignored -->
     <bool name="config_mms_content_disposition_support">true</bool>
 
+    <!-- If this value is true, we handle Samsung CDMA's message ID method -->
+    <bool name="config_smsSamsungCdmaAlternateMessageIDEncoding">false</bool>
+
     <!-- National Language Identifier codes for the following two config items.
          (from 3GPP TS 23.038 V9.1.1 Table 6.2.1.2.4.1):
           0  - reserved
@@ -759,4 +774,27 @@
          [bootmode]:[original USB mode]:[USB mode used]-->
     <integer-array translatable="false" name="config_oemUsbModeOverride">
     </integer-array>
+
+    <!-- CM CHANGES START HERE -->
+
+    <!-- LUN file to be used by legacy USB manager.
+         The existence of this file will be used to determine in the
+         legacy USB manager should be started. -->
+    <string name="config_legacyUmsLunFile">/sys/devices/platform/usb_mass_storage/lun0/file</string>
+
+    <!-- Hardware 'face' keys present on the device, stored as a bit field.
+         This integer should equal the sum of the corresponding value for each
+         of the following keys present:
+             1 - Home
+             2 - Back
+             4 - Menu
+             8 - Search
+            16 - App switch
+         For example, a device with Home, Back and Menu keys would set this
+         config to 7. -->
+    <integer name="config_deviceHardwareKeys">15</integer>
+
+    <!-- Boolean to enable stk functionality on Samsung phones -->
+    <bool name="config_samsung_stk">true</bool>
+
 </resources>
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 7b785ec..27b9db1 100755
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -187,6 +187,7 @@
     <string name="roamingText11">Roaming Banner On</string>
     <string name="roamingText12">Roaming Banner Off</string>
     <string name="roamingTextSearching">Searching for Service</string>
+    <string name="roamingTextAirplaneMode">Airplane Mode</string>
 
 
     <!--
diff --git a/include/binder/IMemory.h b/include/binder/IMemory.h
index 2d0db00..059bee0 100644
--- a/include/binder/IMemory.h
+++ b/include/binder/IMemory.h
@@ -43,7 +43,9 @@ public:
     virtual void*       getBase() const = 0;
     virtual size_t      getSize() const = 0;
     virtual uint32_t    getFlags() const = 0;
+#ifndef BINDER_COMPAT
     virtual uint32_t    getOffset() const = 0;
+#endif
 
     // these are there just for backward source compatibility
     int32_t heapID() const { return getHeapID(); }
diff --git a/include/binder/MemoryHeapBase.h b/include/binder/MemoryHeapBase.h
index bbbda9c..97d4b18 100644
--- a/include/binder/MemoryHeapBase.h
+++ b/include/binder/MemoryHeapBase.h
@@ -61,7 +61,9 @@ public:
     virtual void*       getBase() const;
     virtual size_t      getSize() const;
     virtual uint32_t    getFlags() const;
-    virtual uint32_t      getOffset() const;
+#ifndef BINDER_COMPAT
+    virtual uint32_t    getOffset() const;
+#endif
 
     const char*         getDevice() const;
 
@@ -91,7 +93,9 @@ private:
     uint32_t    mFlags;
     const char* mDevice;
     bool        mNeedUnmap;
+#ifndef BINDER_COMPAT
     uint32_t    mOffset;
+#endif
 };
 
 // ---------------------------------------------------------------------------
diff --git a/include/binder/Parcel.h b/include/binder/Parcel.h
index 33b2f00..e6f64ed 100644
--- a/include/binder/Parcel.h
+++ b/include/binder/Parcel.h
@@ -76,6 +76,10 @@ public:
     // passed in.
     bool                enforceInterface(const String16& interface,
                                          IPCThreadState* threadState = NULL) const;
+#ifdef _INTERNAL_BINDER_PARCEL_
+    bool                enforceInterface(const String16& interface) const;
+#endif
+
     bool                checkInterface(IBinder*) const;
 
     void                freeData();
diff --git a/include/camera/Camera.h b/include/camera/Camera.h
index 234e165..ad4db3b 100644
--- a/include/camera/Camera.h
+++ b/include/camera/Camera.h
@@ -46,6 +46,9 @@ struct CameraInfo {
      * right of the screen, the value should be 270.
      */
     int orientation;
+#ifdef QCOM_HARDWARE
+    int mode;
+#endif
 };
 
 class ICameraService;
diff --git a/include/camera/CameraParameters.h b/include/camera/CameraParameters.h
index 7edf6b4..f54e240 100644
--- a/include/camera/CameraParameters.h
+++ b/include/camera/CameraParameters.h
@@ -36,7 +36,21 @@ struct Size {
         height = h;
     }
 };
-
+#ifdef QCOM_HARDWARE
+struct FPSRange{
+    int minFPS;
+    int maxFPS;
+
+    FPSRange(){
+        minFPS=0;
+        maxFPS=0;
+    };
+    FPSRange(int min,int max){
+        minFPS=min;
+        maxFPS=max;
+   };
+};
+#endif
 class CameraParameters
 {
 public:
@@ -91,6 +105,10 @@ public:
     void setPreviewFrameRate(int fps);
     int getPreviewFrameRate() const;
     void getPreviewFpsRange(int *min_fps, int *max_fps) const;
+#ifdef QCOM_HARDWARE
+    void setPreviewFrameRateMode(const char *mode);
+    const char *getPreviewFrameRateMode() const;
+#endif
     void setPreviewFormat(const char *format);
     const char *getPreviewFormat() const;
     void setPictureSize(int width, int height);
@@ -98,6 +116,14 @@ public:
     void getSupportedPictureSizes(Vector<Size> &sizes) const;
     void setPictureFormat(const char *format);
     const char *getPictureFormat() const;
+#ifdef QCOM_HARDWARE
+    void setTouchIndexAec(int x, int y);
+    void getTouchIndexAec(int *x, int *y) const;
+    void setTouchIndexAf(int x, int y);
+    void getTouchIndexAf(int *x, int *y) const;
+#endif
+
+    void getMeteringAreaCenter(int * x, int *y) const;
 
     void dump() const;
     status_t dump(int fd, const Vector<String16>& args) const;
@@ -112,6 +138,11 @@ public:
     // Supported preview frame sizes in pixels.
     // Example value: "800x600,480x320". Read only.
     static const char KEY_SUPPORTED_PREVIEW_SIZES[];
+#ifdef QCOM_HARDWARE
+    // Supported PREVIEW/RECORDING SIZES IN HIGH FRAME RATE recording, sizes in pixels.
+    // Example value: "800x480,432x320". Read only.
+    static const char KEY_SUPPORTED_HFR_SIZES[];
+#endif
     // The current minimum and maximum preview fps. This controls the rate of
     // preview frames received (CAMERA_MSG_PREVIEW_FRAME). The minimum and
     // maximum fps must be one of the elements from
@@ -127,7 +158,7 @@ public:
     // Example value: "(10500,26623),(15000,26623),(30000,30000)"
     static const char KEY_SUPPORTED_PREVIEW_FPS_RANGE[];
     // The image format for preview frames. See CAMERA_MSG_PREVIEW_FRAME in
-    // frameworks/base/include/camera/Camera.h.
+    // system/core/include/system/camera.h.
     // Example value: "yuv420sp" or PIXEL_FORMAT_XXX constants. Read/write.
     static const char KEY_PREVIEW_FORMAT[];
     // Supported image formats for preview frames.
@@ -140,6 +171,25 @@ public:
     // Supported number of preview frames per second.
     // Example value: "24,15,10". Read.
     static const char KEY_SUPPORTED_PREVIEW_FRAME_RATES[];
+#ifdef QCOM_HARDWARE
+    // The mode of preview frame rate.
+    // Example value: "frame-rate-auto, frame-rate-fixed".
+    static const char KEY_PREVIEW_FRAME_RATE_MODE[];
+    static const char KEY_SUPPORTED_PREVIEW_FRAME_RATE_MODES[];
+    static const char KEY_PREVIEW_FRAME_RATE_AUTO_MODE[];
+    static const char KEY_PREVIEW_FRAME_RATE_FIXED_MODE[];
+    static const char KEY_CAPTURE_MODE[];
+    static const char KEY_SUPPORTED_CAPTURE_MODES[];
+    static const char KEY_PICTURE_COUNT[];
+    static const char KEY_MAX_BURST_PICTURE_COUNT[];
+    static const char KEY_SUPPORTED_CONTINUOUS_AF[];
+    static const char CAPTURE_MODE_NORMAL[];
+    static const char CAPTURE_MODE_BURST[];
+    static const char CAPTURE_MODE_CONTI_BURST[];
+    static const char CAPTURE_MODE_HDR[];
+    static const char CAPTURE_MODE_HJR[];
+    static const char CAPTURE_MODE_PANORAMA[];
+#endif
     // The dimensions for captured pictures in pixels (width x height).
     // Example value: "1024x768". Read/write.
     static const char KEY_PICTURE_SIZE[];
@@ -147,7 +197,7 @@ public:
     // Example value: "2048x1536,1024x768". Read only.
     static const char KEY_SUPPORTED_PICTURE_SIZES[];
     // The image format for captured pictures. See CAMERA_MSG_COMPRESSED_IMAGE
-    // in frameworks/base/include/camera/Camera.h.
+    // in system/core/include/system/camera.h.
     // Example value: "jpeg" or PIXEL_FORMAT_XXX constants. Read/write.
     static const char KEY_PICTURE_FORMAT[];
     // Supported image formats for captured pictures.
@@ -202,6 +252,12 @@ public:
     // header.
     // Example value: "21.0" or "-5". Write only.
     static const char KEY_GPS_ALTITUDE[];
+
+#ifdef QCOM_HARDWARE
+    static const char KEY_SKIN_TONE_ENHANCEMENT[] ;
+    static const char KEY_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES[] ;
+#endif
+
     // GPS timestamp (UTC in seconds since January 1, 1970). This should be
     // stored in JPEG EXIF header.
     // Example value: "1251192757". Write only.
@@ -221,6 +277,15 @@ public:
     // Supported color effect settings.
     // Example value: "none,mono,sepia". Read only.
     static const char KEY_SUPPORTED_EFFECTS[];
+#ifdef QCOM_HARDWARE
+    //Touch Af/AEC settings.
+    static const char KEY_TOUCH_AF_AEC[];
+    static const char KEY_SUPPORTED_TOUCH_AF_AEC[];
+    //Touch Index for AEC.
+    static const char KEY_TOUCH_INDEX_AEC[];
+    //Touch Index for AF.
+    static const char KEY_TOUCH_INDEX_AF[];
+#endif
     // Current antibanding setting.
     // Example value: "auto" or ANTIBANDING_XXX constants. Read/write.
     static const char KEY_ANTIBANDING[];
@@ -233,6 +298,14 @@ public:
     // Supported scene mode settings.
     // Example value: "auto,night,fireworks". Read only.
     static const char KEY_SUPPORTED_SCENE_MODES[];
+#ifdef QCOM_HARDWARE
+    // Current auto scene detection mode.
+    // Example value: "off" or SCENE_DETECT_XXX constants. Read/write.
+    static const char KEY_SCENE_DETECT[];
+    // Supported auto scene detection settings.
+    // Example value: "off,backlight,snow/cloudy". Read only.
+    static const char KEY_SUPPORTED_SCENE_DETECT[];
+#endif
     // Current flash mode.
     // Example value: "auto" or FLASH_MODE_XXX constants. Read/write.
     static const char KEY_FLASH_MODE[];
@@ -408,7 +481,7 @@ public:
     // value is "true". It is not supported if the value is not "true" or the
     // key does not exist.
     // See CAMERA_CMD_START_SMOOTH_ZOOM, CAMERA_CMD_STOP_SMOOTH_ZOOM, and
-    // CAMERA_MSG_ZOOM in frameworks/base/include/camera/Camera.h.
+    // CAMERA_MSG_ZOOM in system/core/include/system/camera.h.
     // Example value: "true". Read only.
     static const char KEY_SMOOTH_ZOOM_SUPPORTED[];
 
@@ -442,7 +515,7 @@ public:
     static const char KEY_VIDEO_SIZE[];
     // A list of the supported dimensions in pixels (width x height)
     // for video frames. See CAMERA_MSG_VIDEO_FRAME for details in
-    // frameworks/base/include/camera/Camera.h.
+    // system/core/include/system/camera.h.
     // Example: "176x144,1280x720". Read only.
     static const char KEY_SUPPORTED_VIDEO_SIZES[];
 
@@ -471,7 +544,7 @@ public:
     static const char KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO[];
 
     // The image format for video frames. See CAMERA_MSG_VIDEO_FRAME in
-    // frameworks/base/include/camera/Camera.h.
+    // system/core/include/system/camera.h.
     // Example value: "yuv420sp" or PIXEL_FORMAT_XXX constants. Read only.
     static const char KEY_VIDEO_FRAME_FORMAT[];
 
@@ -504,6 +577,25 @@ public:
     // captured pictures.
     // Example value: "true" or "false". Read only.
     static const char KEY_VIDEO_SNAPSHOT_SUPPORTED[];
+    static const char KEY_FULL_VIDEO_SNAP_SUPPORTED[];
+
+#ifdef QCOM_HARDWARE
+    static const char KEY_LENSSHADE[] ;
+    static const char KEY_SUPPORTED_LENSSHADE_MODES[] ;
+
+    static const char KEY_AUTO_EXPOSURE[];
+    static const char KEY_SUPPORTED_AUTO_EXPOSURE[];
+
+    static const char KEY_GPS_LATITUDE_REF[];
+    static const char KEY_GPS_LONGITUDE_REF[];
+    static const char KEY_GPS_ALTITUDE_REF[];
+    static const char KEY_GPS_STATUS[];
+    static const char KEY_EXIF_DATETIME[];
+#ifndef SAMSUNG_CAMERA_HARDWARE
+    static const char KEY_ISO_MODE[];
+    static const char KEY_SUPPORTED_ISO_MODES[];
+#endif
+#endif
 
     // The state of the video stabilization. If set to true, both the
     // preview stream and the recorded video stream are stabilized by
@@ -519,11 +611,27 @@ public:
     // has no effect on still image capture.
     static const char KEY_VIDEO_STABILIZATION[];
 
+#ifdef QCOM_HARDWARE
+    static const char KEY_MEMORY_COLOR_ENHANCEMENT[];
+    static const char KEY_SUPPORTED_MEM_COLOR_ENHANCE_MODES[];
+
+    static const char KEY_ZSL[];
+    static const char KEY_SUPPORTED_ZSL_MODES[];
+
+    static const char KEY_CAMERA_MODE[];
+
+    static const char KEY_VIDEO_HIGH_FRAME_RATE[];
+    static const char KEY_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES[];
+    static const char KEY_HIGH_DYNAMIC_RANGE_IMAGING[];
+    static const char KEY_SUPPORTED_HDR_IMAGING_MODES[];
+#endif
     // Returns true if video stabilization is supported. That is, applications
     // can set KEY_VIDEO_STABILIZATION to true and have a stabilized preview
     // stream and record stabilized videos.
     static const char KEY_VIDEO_STABILIZATION_SUPPORTED[];
 
+    static const char KEY_AE_BRACKET_HDR[];
+
     // Value for KEY_ZOOM_SUPPORTED or KEY_SMOOTH_ZOOM_SUPPORTED.
     static const char TRUE[];
     static const char FALSE[];
@@ -531,6 +639,32 @@ public:
     // Value for KEY_FOCUS_DISTANCES.
     static const char FOCUS_DISTANCE_INFINITY[];
 
+#ifdef QCOM_HARDWARE
+    // DENOISE
+    static const char KEY_DENOISE[];
+    static const char KEY_SUPPORTED_DENOISE[];
+
+    //Selectable zone AF.
+    static const char KEY_SELECTABLE_ZONE_AF[];
+    static const char KEY_SUPPORTED_SELECTABLE_ZONE_AF[];
+
+    //Face Detection
+    static const char KEY_FACE_DETECTION[];
+    static const char KEY_SUPPORTED_FACE_DETECTION[];
+
+    //Redeye Reduction
+    static const char KEY_REDEYE_REDUCTION[];
+    static const char KEY_SUPPORTED_REDEYE_REDUCTION[];
+#endif
+
+#ifdef SAMSUNG_CAMERA_HARDWARE
+    static const char KEY_METERING[];
+    static const char KEY_WDR[];
+    static const char KEY_ANTI_SHAKE_MODE[];
+    static const char KEY_ISO_MODE[];
+    static const char KEY_SUPPORTED_ISO_MODES[];
+#endif
+
     // Values for white balance settings.
     static const char WHITE_BALANCE_AUTO[];
     static const char WHITE_BALANCE_INCANDESCENT[];
@@ -551,6 +685,15 @@ public:
     static const char EFFECT_WHITEBOARD[];
     static const char EFFECT_BLACKBOARD[];
     static const char EFFECT_AQUA[];
+#ifdef QCOM_HARDWARE
+    static const char EFFECT_EMBOSS[];
+    static const char EFFECT_SKETCH[];
+    static const char EFFECT_NEON[];
+
+    // Values for Touch AF/AEC
+    static const char TOUCH_AF_AEC_OFF[] ;
+    static const char TOUCH_AF_AEC_ON[] ;
+#endif
 
     // Values for antibanding settings.
     static const char ANTIBANDING_AUTO[];
@@ -575,6 +718,7 @@ public:
 
     // Values for scene mode settings.
     static const char SCENE_MODE_AUTO[];
+    static const char SCENE_MODE_ASD[];
     static const char SCENE_MODE_ACTION[];
     static const char SCENE_MODE_PORTRAIT[];
     static const char SCENE_MODE_LANDSCAPE[];
@@ -589,14 +733,27 @@ public:
     static const char SCENE_MODE_SPORTS[];
     static const char SCENE_MODE_PARTY[];
     static const char SCENE_MODE_CANDLELIGHT[];
+#ifdef QCOM_HARDWARE
+    static const char SCENE_MODE_BACKLIGHT[];
+    static const char SCENE_MODE_FLOWERS[];
+    static const char SCENE_MODE_AR[];
+    static const char SCENE_MODE_OFF[];
+#endif
     // Applications are looking for a barcode. Camera driver will be optimized
     // for barcode reading.
     static const char SCENE_MODE_BARCODE[];
 
     // Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
     // and KEY_VIDEO_FRAME_FORMAT
+#ifdef QCOM_HARDWARE
+    static const char SCENE_DETECT_OFF[];
+    static const char SCENE_DETECT_ON[];
+#endif
     static const char PIXEL_FORMAT_YUV422SP[];
     static const char PIXEL_FORMAT_YUV420SP[]; // NV21
+#ifdef QCOM_HARDWARE
+    static const char PIXEL_FORMAT_YUV420SP_ADRENO[]; // ADRENO
+#endif
     static const char PIXEL_FORMAT_YUV422I[]; // YUY2
     static const char PIXEL_FORMAT_YUV420P[]; // YV12
     static const char PIXEL_FORMAT_RGB565[];
@@ -605,6 +762,11 @@ public:
     // Raw bayer format used for images, which is 10 bit precision samples
     // stored in 16 bit words. The filter pattern is RGGB.
     static const char PIXEL_FORMAT_BAYER_RGGB[];
+#ifdef QCOM_HARDWARE
+    static const char PIXEL_FORMAT_RAW[];
+    static const char PIXEL_FORMAT_YV12[]; // NV21
+    static const char PIXEL_FORMAT_NV12[]; //NV12
+#endif
 
     // Values for focus mode settings.
     // Auto-focus mode. Applications should call
@@ -657,6 +819,143 @@ public:
     // other modes.
     static const char FOCUS_MODE_CONTINUOUS_PICTURE[];
 
+#ifdef QCOM_HARDWARE
+    static const char FOCUS_MODE_CONTINUOUS_CAMERA[];
+
+    // Values for Continuous AF
+    static const char CAF_OFF[] ;
+    static const char CAF_ON[] ;
+    // Proprietaries from CodeAurora use these...
+    static const char CONTINUOUS_AF_OFF[] ;
+    static const char CONTINUOUS_AF_ON[] ;
+    static const char KEY_CONTINUOUS_AF[] ;
+
+    // Normal focus mode. Applications should call
+    // CameraHardwareInterface.autoFocus to start the focus in this mode.
+    static const char FOCUS_MODE_NORMAL[];
+    static const char ISO_AUTO[];
+    static const char ISO_HJR[] ;
+    static const char ISO_100[];
+    static const char ISO_200[] ;
+    static const char ISO_400[];
+    static const char ISO_800[];
+    static const char ISO_1600[];
+    // Values for Lens Shading
+    static const char LENSSHADE_ENABLE[] ;
+    static const char LENSSHADE_DISABLE[] ;
+
+    // Values for auto exposure settings.
+    static const char AUTO_EXPOSURE_FRAME_AVG[];
+    static const char AUTO_EXPOSURE_CENTER_WEIGHTED[];
+    static const char AUTO_EXPOSURE_SPOT_METERING[];
+
+    static const char KEY_SHARPNESS[];
+    static const char KEY_MAX_SHARPNESS[];
+#if defined(QCOM_HARDWARE) && !defined(SAMSUNG_CAMERA_QCOM)
+    static const char KEY_MIN_SHARPNESS[];
+#endif
+    static const char KEY_CONTRAST[];
+    static const char KEY_MAX_CONTRAST[];
+#if defined(QCOM_HARDWARE) && !defined(SAMSUNG_CAMERA_QCOM)
+    static const char KEY_MIN_CONTRAST[];
+#endif
+    static const char KEY_SATURATION[];
+    static const char KEY_MAX_SATURATION[];
+#if defined(QCOM_HARDWARE) && !defined(SAMSUNG_CAMERA_QCOM)
+    static const char KEY_MIN_SATURATION[];
+#endif
+
+    static const char KEY_HISTOGRAM[] ;
+    static const char KEY_SUPPORTED_HISTOGRAM_MODES[] ;
+    // Values for HISTOGRAM
+    static const char HISTOGRAM_ENABLE[] ;
+    static const char HISTOGRAM_DISABLE[] ;
+
+    // Values for SKIN TONE ENHANCEMENT
+    static const char SKIN_TONE_ENHANCEMENT_ENABLE[] ;
+    static const char SKIN_TONE_ENHANCEMENT_DISABLE[] ;
+
+    // Values for Denoise
+    static const char DENOISE_OFF[] ;
+    static const char DENOISE_ON[] ;
+
+    // Values for auto exposure settings.
+    static const char SELECTABLE_ZONE_AF_AUTO[];
+    static const char SELECTABLE_ZONE_AF_SPOT_METERING[];
+    static const char SELECTABLE_ZONE_AF_CENTER_WEIGHTED[];
+    static const char SELECTABLE_ZONE_AF_FRAME_AVERAGE[];
+
+    // Values for Face Detection settings.
+    static const char FACE_DETECTION_OFF[];
+    static const char FACE_DETECTION_ON[];
+
+    // Values for MCE settings.
+    static const char MCE_ENABLE[];
+    static const char MCE_DISABLE[];
+
+    // Values for ZSL settings.
+    static const char ZSL_OFF[];
+    static const char ZSL_ON[];
+
+    // Values for HDR Bracketing settings.
+    static const char AE_BRACKET_HDR_OFF[];
+    static const char AE_BRACKET_HDR[];
+    static const char AE_BRACKET[];
+
+    // Values for HFR settings.
+    static const char VIDEO_HFR_OFF[];
+    static const char VIDEO_HFR_2X[];
+    static const char VIDEO_HFR_3X[];
+    static const char VIDEO_HFR_4X[];
+
+    // Values for Redeye Reduction settings.
+    static const char REDEYE_REDUCTION_ENABLE[];
+    static const char REDEYE_REDUCTION_DISABLE[];
+    // Values for HDR settings.
+    static const char HDR_ENABLE[];
+    static const char HDR_DISABLE[];
+
+   // Values for Redeye Reduction settings.
+   // static const char REDEYE_REDUCTION_ENABLE[];
+   // static const char REDEYE_REDUCTION_DISABLE[];
+   // Values for HDR settings.
+   //    static const char HDR_ENABLE[];
+   //    static const char HDR_DISABLE[];
+
+    enum {
+        CAMERA_ORIENTATION_UNKNOWN = 0,
+        CAMERA_ORIENTATION_PORTRAIT = 1,
+        CAMERA_ORIENTATION_LANDSCAPE = 2,
+    };
+    int getOrientation() const;
+    void setOrientation(int orientation);
+    void setPreviewFpsRange(int minFPS,int maxFPS);
+    void setPostviewSize(int x,int y);
+    void getSupportedHfrSizes(Vector<Size> &sizes) const;
+#endif
+
+#ifdef SAMSUNG_CAMERA_QCOM
+    static const char FOCUS_MODE_FACEDETECT[];
+    static const char FOCUS_MODE_TOUCHAF[];
+    static const char ISO_50[];
+//    static const char KEY_ANTI_SHAKE_MODE[];
+    static const char KEY_AUTO_CONTRAST[];
+    static const char KEY_BEAUTY_MODE[];
+    static const char KEY_BLUR_MODE[];
+    static const char KEY_VINTAGE_MODE[];
+    static const char KEY_WDR_MODE[];
+    static const char VINTAGE_MODE_BNW[];
+    static const char VINTAGE_MODE_COOL[];
+    static const char VINTAGE_MODE_NORMAL[];
+    static const char VINTAGE_MODE_OFF[];
+    static const char VINTAGE_MODE_WARM[];
+    static const char SCENE_MODE_DAWN[];
+    static const char SCENE_MODE_DUSKDAWN[];
+    static const char SCENE_MODE_FALL[];
+    static const char SCENE_MODE_FALL_COLOR[];
+    static const char SCENE_MODE_TEXT[];
+#endif
+
 private:
     DefaultKeyedVector<String8,String8>    mMap;
 };
@@ -664,3 +963,4 @@ private:
 }; // namespace android
 
 #endif
+
diff --git a/include/gui/ISurfaceTexture.h b/include/gui/ISurfaceTexture.h
index 50626a0..fbec6a1 100644
--- a/include/gui/ISurfaceTexture.h
+++ b/include/gui/ISurfaceTexture.h
@@ -127,6 +127,20 @@ protected:
     // This method will fail if the the SurfaceTexture is not currently
     // connected to the specified client API.
     virtual status_t disconnect(int api) = 0;
+
+#ifdef QCOM_HARDWARE
+    // performQcomOperation performs Qcom specific operations. The actual
+    // operation to be performed depends on the operation specified.
+    //
+    // The argument list is filled by the client based on the operation that
+    // the client wants to specify.
+    //
+    // This method will fail if the operation is invalid or the arguments
+    // specified in the operation are invalid.
+    virtual status_t performQcomOperation(int operation, int arg1, int  arg2,
+                                          int arg3) = 0;
+#endif
+
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/gui/SurfaceTexture.h b/include/gui/SurfaceTexture.h
index a8c7672..36c5b72 100644
--- a/include/gui/SurfaceTexture.h
+++ b/include/gui/SurfaceTexture.h
@@ -106,6 +106,10 @@ public:
 
     virtual int query(int what, int* value);
 
+#ifdef QCOM_HARDWARE
+    virtual int performQcomOperation(int operation, int arg1, int arg2, int arg3);
+#endif
+
     // setSynchronousMode set whether dequeueBuffer is synchronous or
     // asynchronous. In synchronous mode, dequeueBuffer blocks until
     // a buffer is available, the currently bound buffer can be dequeued and
@@ -137,7 +141,7 @@ public:
     //
     // This call may only be made while the OpenGL ES context to which the
     // target texture belongs is bound to the calling thread.
-    status_t updateTexImage();
+    status_t updateTexImage(bool isComposition = false);
 
     // setBufferCountServer set the buffer count. If the client has requested
     // a buffer count using setBufferCount, the server-buffer count will
@@ -502,12 +506,28 @@ private:
     // glCopyTexSubImage to read from the texture.  This is a hack to work
     // around a GL driver limitation on the number of FBO attachments, which the
     // browser's tile cache exceeds.
+#ifdef DECIDE_TEXTURE_TARGET
+    GLenum mTexTarget;
+#else
     const GLenum mTexTarget;
+#endif
 
     // mFrameCounter is the free running counter, incremented for every buffer queued
     // with the surface Texture.
     uint64_t mFrameCounter;
 
+#ifdef QCOM_HARDWARE
+    // s3dFormat is the S3D format specified by the client.
+    int mS3DFormat;
+
+    struct BufferInfo {
+         int width;
+         int height;
+         int format;
+     };
+ 
+     BufferInfo mNextBufferInfo;
+#endif
 
 };
 
diff --git a/include/gui/SurfaceTextureClient.h b/include/gui/SurfaceTextureClient.h
index 971a1b8..9e2e696 100644
--- a/include/gui/SurfaceTextureClient.h
+++ b/include/gui/SurfaceTextureClient.h
@@ -71,6 +71,9 @@ private:
     int dispatchSetUsage(va_list args);
     int dispatchLock(va_list args);
     int dispatchUnlockAndPost(va_list args);
+#ifdef QCOM_HARDWARE
+    int dispatchPerformQcomOperation(int operation, va_list args);
+#endif
 
 protected:
     virtual int cancelBuffer(ANativeWindowBuffer* buffer);
@@ -93,6 +96,9 @@ protected:
     virtual int setUsage(uint32_t reqUsage);
     virtual int lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds);
     virtual int unlockAndPost();
+#ifdef QCOM_HARDWARE
+    virtual int performQcomOperation(int operation, int arg1, int arg2, int arg3);
+#endif
 
     enum { MIN_UNDEQUEUED_BUFFERS = SurfaceTexture::MIN_UNDEQUEUED_BUFFERS };
     enum { NUM_BUFFER_SLOTS = SurfaceTexture::NUM_BUFFER_SLOTS };
@@ -156,8 +162,22 @@ private:
     // must be used from the lock/unlock thread
     sp<GraphicBuffer>           mLockedBuffer;
     sp<GraphicBuffer>           mPostedBuffer;
+#ifdef QCOM_HARDWARE
+    mutable Region              mOldDirtyRegion[NUM_BUFFER_SLOTS];
+#else
     mutable Region              mOldDirtyRegion;
+#endif
     bool                        mConnectedToCpu;
+
+#ifdef QCOM_HARDWARE
+    // mReqExtUsage is a flag set by app to mark a layer for display on
+    // external panels only. Depending on the value of this flag mReqUsage
+    // will be ORed with existing values.
+    // Possible values GRALLOC_USAGE_EXTERNAL_ONLY and
+    // GRALLOC_USAGE_EXTERNAL_BLOCK
+    // It is initialized to 0
+    uint32_t mReqExtUsage;
+#endif
 };
 
 }; // namespace android
diff --git a/include/media/AudioSystem.h b/include/media/AudioSystem.h
index 6a15f6e..f80a8d6 100644
--- a/include/media/AudioSystem.h
+++ b/include/media/AudioSystem.h
@@ -120,6 +120,10 @@ public:
         INPUT_CLOSED,
         INPUT_CONFIG_CHANGED,
         STREAM_CONFIG_CHANGED,
+#ifdef WITH_QCOM_LPA
+        A2DP_OUTPUT_STATE,
+        EFFECT_CONFIG_CHANGED,
+#endif
         NUM_CONFIG_EVENTS
     };
 
@@ -151,6 +155,15 @@ public:
                                         uint32_t format = AUDIO_FORMAT_DEFAULT,
                                         uint32_t channels = AUDIO_CHANNEL_OUT_STEREO,
                                         audio_policy_output_flags_t flags = AUDIO_POLICY_OUTPUT_FLAG_INDIRECT);
+#ifdef WITH_QCOM_LPA
+    static audio_io_handle_t getSession(audio_stream_type_t stream,
+                                        uint32_t format = AUDIO_FORMAT_DEFAULT,
+                                        audio_policy_output_flags_t flags = AUDIO_POLICY_OUTPUT_FLAG_DIRECT,
+                                        int32_t sessionId = -1);
+    static void closeSession(audio_io_handle_t output);
+    static status_t pauseSession(audio_io_handle_t output, audio_stream_type_t stream);
+    static status_t resumeSession(audio_io_handle_t output, audio_stream_type_t stream);
+#endif
     static status_t startOutput(audio_io_handle_t output,
                                 audio_stream_type_t stream,
                                 int session = 0);
diff --git a/include/media/AudioTrack.h b/include/media/AudioTrack.h
index 1c401e2..f518198 100644
--- a/include/media/AudioTrack.h
+++ b/include/media/AudioTrack.h
@@ -172,6 +172,20 @@ public:
                                     void* user          = 0,
                                     int notificationFrames = 0,
                                     int sessionId = 0);
+#ifdef WITH_QCOM_LPA
+    /* Creates an audio track and registers it with AudioFlinger. With this constructor,
+     * session ID of compressed stream can be registered AudioFlinger and AudioHardware,
+     * for routing purpose.
+     */
+
+                        AudioTrack( int streamType,
+                                    uint32_t sampleRate = 0,
+                                    int format          = 0,
+                                    int channels        = 0,
+                                    uint32_t flags      = 0,
+                                    int sessionId       = 0,
+                                    int lpaSessionId    =-1);
+#endif
 
     /* Terminates the AudioTrack and unregisters it from AudioFlinger.
      * Also destroys all resources assotiated with the AudioTrack.
@@ -198,7 +212,22 @@ public:
                             const sp<IMemory>& sharedBuffer = 0,
                             bool threadCanCallJava = false,
                             int sessionId = 0);
-
+#ifdef WITH_QCOM_LPA
+    /* Initialize an AudioTrack and registers session Id for Tunneled audio decoding.
+     * Returned status (from utils/Errors.h) can be:
+     *  - NO_ERROR: successful intialization
+     *  - INVALID_OPERATION: AudioTrack is already intitialized
+     *  - BAD_VALUE: invalid parameter (channels, format, sampleRate...)
+     *  - NO_INIT: audio server or audio hardware not initialized
+     * */
+            status_t    set(int streamType      =-1,
+                            uint32_t sampleRate = 0,
+                            int format          = 0,
+                            int channels        = 0,
+                            uint32_t flags      = 0,
+                            int sessionId       = 0,
+                            int lpaSessionId    =-1);
+#endif
 
     /* Result of constructing the AudioTrack. This must be checked
      * before using any AudioTrack API (except for set()), using
@@ -485,6 +514,9 @@ private:
     uint32_t                mUpdatePeriod;
     bool                    mFlushed; // FIXME will be made obsolete by making flush() synchronous
     uint32_t                mFlags;
+#ifdef WITH_QCOM_LPA
+    audio_io_handle_t       mAudioSession;
+#endif
     int                     mSessionId;
     int                     mAuxEffectId;
     Mutex                   mLock;
diff --git a/include/media/IAudioFlinger.h b/include/media/IAudioFlinger.h
index 9e3cb7f..743a0de 100644
--- a/include/media/IAudioFlinger.h
+++ b/include/media/IAudioFlinger.h
@@ -57,6 +57,22 @@ public:
                                 int *sessionId,
                                 status_t *status) = 0;
 
+#ifdef WITH_QCOM_LPA
+    virtual     void        createSession(
+                                pid_t pid,
+                                uint32_t sampleRate,
+                                int channelCount,
+                                int *sessionId,
+                                status_t *status) = 0;
+
+    virtual     void        deleteSession() = 0;
+
+    virtual     void        applyEffectsOn(
+                                int16_t *buffer1,
+                                int16_t *buffer2,
+                                int size) = 0;
+#endif
+
     virtual sp<IAudioRecord> openRecord(
                                 pid_t pid,
                                 int input,
@@ -86,6 +102,9 @@ public:
     virtual     float       masterVolume() const = 0;
     virtual     bool        masterMute() const = 0;
 
+#ifdef WITH_QCOM_LPA
+    virtual     status_t    setSessionVolume(int stream, float value, float right) = 0;
+#endif
     /* set/get stream type state. This will probably be used by
      * the preference panel, mostly.
      */
@@ -117,18 +136,37 @@ public:
                                     uint32_t *pChannels,
                                     uint32_t *pLatencyMs,
                                     uint32_t flags) = 0;
+#ifdef WITH_QCOM_LPA
+    virtual int openSession(uint32_t *pDevices,
+                                 uint32_t *pFormat,
+                                 uint32_t flags,
+                                 int32_t  stream,
+                                 int32_t  sessionId){return 0;};
+    virtual status_t pauseSession(int output, int32_t  stream) = 0;
+    virtual status_t resumeSession(int output, int32_t  stream) = 0;
+    virtual status_t closeSession(int output) = 0;
+#endif
     virtual int openDuplicateOutput(int output1, int output2) = 0;
     virtual status_t closeOutput(int output) = 0;
     virtual status_t suspendOutput(int output) = 0;
     virtual status_t restoreOutput(int output) = 0;
 
+#ifdef STE_AUDIO
+    virtual uint32_t *addInputClient(uint32_t clientId) = 0;
+    virtual status_t removeInputClient(uint32_t *pClientId) = 0;
+#endif
     virtual int openInput(uint32_t *pDevices,
                                     uint32_t *pSamplingRate,
                                     uint32_t *pFormat,
                                     uint32_t *pChannels,
+#ifdef STE_AUDIO
+                                    uint32_t acoustics,
+                                    uint32_t *pInputClientId = NULL) = 0;
+    virtual status_t closeInput(int input, uint32_t* inputClientId = NULL) = 0;
+#else
                                     uint32_t acoustics) = 0;
     virtual status_t closeInput(int input) = 0;
-
+#endif
     virtual status_t setStreamOutput(uint32_t stream, int output) = 0;
 
     virtual status_t setVoiceVolume(float volume) = 0;
@@ -159,6 +197,12 @@ public:
                                     int *enabled) = 0;
 
     virtual status_t moveEffects(int session, int srcOutput, int dstOutput) = 0;
+#ifdef WITH_QCOM_LPA
+    virtual status_t deregisterClient(const sp<IAudioFlingerClient>& client) { return false; };
+#endif
+#ifdef STE_AUDIO
+    virtual size_t readInput(uint32_t *input, uint32_t inputClientId, void *buffer, uint32_t bytes, uint32_t *pOverwrittenBytes) = 0;
+#endif
 };
 
 
diff --git a/include/media/IAudioPolicyService.h b/include/media/IAudioPolicyService.h
index 9807cbe..6134ad0 100644
--- a/include/media/IAudioPolicyService.h
+++ b/include/media/IAudioPolicyService.h
@@ -54,6 +54,15 @@ public:
                                         uint32_t format = AUDIO_FORMAT_DEFAULT,
                                         uint32_t channels = 0,
                                         audio_policy_output_flags_t flags = AUDIO_POLICY_OUTPUT_FLAG_INDIRECT) = 0;
+#ifdef WITH_QCOM_LPA
+    virtual audio_io_handle_t getSession(audio_stream_type_t stream,
+                                        uint32_t format = AUDIO_FORMAT_DEFAULT,
+                                        audio_policy_output_flags_t flags = AUDIO_POLICY_OUTPUT_FLAG_DIRECT,
+                                        int32_t  sessionId=-1) { return 0; }
+    virtual status_t pauseSession(audio_io_handle_t output, audio_stream_type_t stream) { return 0; }
+    virtual status_t resumeSession(audio_io_handle_t output, audio_stream_type_t stream) { return 0; }
+    virtual status_t closeSession(audio_io_handle_t output) = 0;
+#endif
     virtual status_t startOutput(audio_io_handle_t output,
                                  audio_stream_type_t stream,
                                  int session = 0) = 0;
@@ -66,7 +75,12 @@ public:
                                     uint32_t format = AUDIO_FORMAT_DEFAULT,
                                     uint32_t channels = 0,
                                     audio_in_acoustics_t acoustics = (audio_in_acoustics_t)0,
+#ifdef STE_AUDIO
+                                    int audioSession = 0,
+                                    audio_input_clients *inputClientId = NULL) = 0;
+#else
                                     int audioSession = 0) = 0;
+#endif
     virtual status_t startInput(audio_io_handle_t input) = 0;
     virtual status_t stopInput(audio_io_handle_t input) = 0;
     virtual void releaseInput(audio_io_handle_t input) = 0;
diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index 80f43a3..d23d2c4 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -90,12 +90,26 @@ public:
                 AudioCallback cb = NULL,
                 void *cookie = NULL) = 0;
 
+#ifdef WITH_QCOM_LPA
+        // API to open a routing session for tunneled audio playback
+        virtual status_t        openSession(
+                int format, int sessionId, uint32_t sampleRate = 44100, int channels = 2) {return 0;};
+#endif
+
         virtual void        start() = 0;
         virtual ssize_t     write(const void* buffer, size_t size) = 0;
         virtual void        stop() = 0;
         virtual void        flush() = 0;
         virtual void        pause() = 0;
+#ifdef WITH_QCOM_LPA
+        virtual void        pauseSession() {return;};
+        virtual void        resumeSession() {return;};
+#endif
         virtual void        close() = 0;
+#ifdef WITH_QCOM_LPA
+        virtual void        closeSession() {return;};
+        virtual int         getAudioStreamType() {return 0;};
+#endif
     };
 
                         MediaPlayerBase() : mCookie(0), mNotify(0) {}
diff --git a/include/media/MediaProfiles.h b/include/media/MediaProfiles.h
index 250f267..1a4875a 100644
--- a/include/media/MediaProfiles.h
+++ b/include/media/MediaProfiles.h
@@ -32,8 +32,13 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_480P = 4,
     CAMCORDER_QUALITY_720P = 5,
     CAMCORDER_QUALITY_1080P = 6,
-    CAMCORDER_QUALITY_QVGA = 7,
-    CAMCORDER_QUALITY_LIST_END = 7,
+    CAMCORDER_QUALITY_QVGA = 11,
+    CAMCORDER_QUALITY_FWVGA = 7,
+    CAMCORDER_QUALITY_WVGA = 8,
+    CAMCORDER_QUALITY_VGA = 9,
+    CAMCORDER_QUALITY_WQVGA = 10,
+
+    CAMCORDER_QUALITY_LIST_END = 11,
 
     CAMCORDER_QUALITY_TIME_LAPSE_LIST_START = 1000,
     CAMCORDER_QUALITY_TIME_LAPSE_LOW  = 1000,
@@ -455,7 +460,13 @@ private:
 
     static VideoEncoderCap* createDefaultH263VideoEncoderCap();
     static VideoEncoderCap* createDefaultM4vVideoEncoderCap();
+#ifdef QCOM_HARDWARE
+    static VideoEncoderCap* createDefaultH264VideoEncoderCap();
+#endif
     static AudioEncoderCap* createDefaultAmrNBEncoderCap();
+#ifdef QCOM_HARDWARE
+    static AudioEncoderCap* createDefaultAacEncoderCap();
+#endif
 
     static int findTagForName(const NameToTagMap *map, size_t nMappings, const char *name);
 
diff --git a/include/media/mediarecorder.h b/include/media/mediarecorder.h
index 30db642..794b928 100644
--- a/include/media/mediarecorder.h
+++ b/include/media/mediarecorder.h
@@ -67,6 +67,11 @@ enum output_format {
     /* H.264/AAC data encapsulated in MPEG2/TS */
     OUTPUT_FORMAT_MPEG2TS = 8,
 
+#ifdef QCOM_HARDWARE
+    OUTPUT_FORMAT_QCP = 9, // QCP file format
+    OUTPUT_FORMAT_THREE_GPP2 = 10, /*3GPP2*/
+#endif
+
     OUTPUT_FORMAT_LIST_END // must be last - used to validate format type
 };
 
@@ -77,6 +82,10 @@ enum audio_encoder {
     AUDIO_ENCODER_AAC = 3,
     AUDIO_ENCODER_AAC_PLUS = 4,
     AUDIO_ENCODER_EAAC_PLUS = 5,
+#ifdef QCOM_HARDWARE
+    AUDIO_ENCODER_EVRC = 6,
+    AUDIO_ENCODER_QCELP = 7,
+#endif
 
     AUDIO_ENCODER_LIST_END // must be the last - used to validate the audio encoder type
 };
@@ -118,6 +127,9 @@ enum media_recorder_event_type {
     MEDIA_RECORDER_EVENT_LIST_START               = 1,
     MEDIA_RECORDER_EVENT_ERROR                    = 1,
     MEDIA_RECORDER_EVENT_INFO                     = 2,
+#ifdef QCOM_HARDWARE
+    MEDIA_RECORDER_MSG_COMPRESSED_IMAGE           = 8, // mzhu: TODO, where to put this?
+#endif
     MEDIA_RECORDER_EVENT_LIST_END                 = 99,
 
     // Track related event types
diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
old mode 100644
new mode 100755
index 3963d9c..ea65652
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -22,6 +22,9 @@
 #include <android/native_window.h>
 #include <media/IOMX.h>
 #include <media/stagefright/foundation/AHierarchicalStateMachine.h>
+#ifdef QCOM_HARDWARE
+#include <OMX_Component.h>
+#endif
 
 namespace android {
 
@@ -60,6 +63,9 @@ private:
     struct ExecutingToIdleState;
     struct IdleToLoadedState;
     struct FlushingState;
+#ifdef QCOM_HARDWARE
+    struct FlushingOutputState;
+#endif
 
     enum {
         kWhatSetup                   = 'setu',
@@ -103,6 +109,9 @@ private:
     sp<ExecutingToIdleState> mExecutingToIdleState;
     sp<IdleToLoadedState> mIdleToLoadedState;
     sp<FlushingState> mFlushingState;
+#ifdef QCOM_HARDWARE
+    sp<FlushingOutputState> mFlushingOutputState;
+#endif
 
     AString mComponentName;
     sp<IOMX> mOMX;
@@ -128,6 +137,10 @@ private:
     status_t freeOutputBuffersNotOwnedByComponent();
     BufferInfo *dequeueBufferFromNativeWindow();
 
+#ifdef SAMSUNG_CODEC_SUPPORT
+    void setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat);
+#endif
+
     BufferInfo *findBufferByID(
             uint32_t portIndex, IOMX::buffer_id bufferID,
             ssize_t *index = NULL);
@@ -175,6 +188,13 @@ private:
 
     void signalError(OMX_ERRORTYPE error = OMX_ErrorUndefined);
 
+#ifdef QCOM_HARDWARE
+    //Smooth streaming related
+    status_t InitSmoothStreaming();
+    OMX_PARAM_PORTDEFINITIONTYPE mOutputPortDef;
+    bool mSmoothStreaming;
+#endif
+
     DISALLOW_EVIL_CONSTRUCTORS(ACodec);
 };
 
diff --git a/include/media/stagefright/AudioPlayer.h b/include/media/stagefright/AudioPlayer.h
index 0b79324..bb05ba3 100644
--- a/include/media/stagefright/AudioPlayer.h
+++ b/include/media/stagefright/AudioPlayer.h
@@ -42,27 +42,27 @@ public:
     virtual ~AudioPlayer();
 
     // Caller retains ownership of "source".
-    void setSource(const sp<MediaSource> &source);
+    virtual void setSource(const sp<MediaSource> &source);
 
     // Return time in us.
     virtual int64_t getRealTimeUs();
 
-    status_t start(bool sourceAlreadyStarted = false);
+    virtual status_t start(bool sourceAlreadyStarted = false);
 
-    void pause(bool playPendingSamples = false);
-    void resume();
+    virtual void pause(bool playPendingSamples = false);
+    virtual void resume();
 
     // Returns the timestamp of the last buffer played (in us).
-    int64_t getMediaTimeUs();
+    virtual int64_t getMediaTimeUs();
 
     // Returns true iff a mapping is established, i.e. the AudioPlayer
     // has played at least one frame of audio.
-    bool getMediaTimeMapping(int64_t *realtime_us, int64_t *mediatime_us);
+    virtual bool getMediaTimeMapping(int64_t *realtime_us, int64_t *mediatime_us);
 
-    status_t seekTo(int64_t time_us);
+    virtual status_t seekTo(int64_t time_us);
 
-    bool isSeeking();
-    bool reachedEOS(status_t *finalStatus);
+    virtual bool isSeeking();
+    virtual bool reachedEOS(status_t *finalStatus);
 
 private:
     friend class VideoEditorAudioPlayer;
@@ -87,7 +87,9 @@ private:
     int64_t mSeekTimeUs;
 
     bool mStarted;
-
+#ifdef QCOM_HARDWARE
+    bool mSourcePaused;
+#endif
     bool mIsFirstBuffer;
     status_t mFirstBufferResult;
     MediaBuffer *mFirstBuffer;
diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index 85ba920..df26f77 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -83,6 +84,51 @@ private:
     ColorConverter &operator=(const ColorConverter &);
 };
 
+#ifdef QCOM_HARDWARE
+//------------------------------------------
+enum ColorConvertFormat {
+    RGB565 = 1,
+    YCbCr420Tile,
+    YCbCr420SP,
+    YCbCr420P,
+    YCrCb420P,
+};
+
+/* 64 bit flag variable, reserving bits as needed */
+enum ColorConvertFlags {
+    COLOR_CONVERT_ALIGN_NONE = 1,
+    COLOR_CONVERT_CENTER_OUTPUT = 1<<1,
+    COLOR_CONVERT_ALIGN_16 =   1<<4,
+    COLOR_CONVERT_ALIGN_2048 = 1<<11,
+    COLOR_CONVERT_ALIGN_8192 = 1<<13,
+};
+
+struct ColorConvertParams {
+    size_t width;
+    size_t height;
+
+    size_t cropWidth;
+    size_t cropHeight;
+
+    size_t cropLeft;
+    size_t cropRight;
+    size_t cropTop;
+    size_t cropBottom;
+
+    ColorConvertFormat colorFormat;
+    const void * data;
+    int fd;
+
+    uint64_t flags;
+};
+
+typedef int (* ConvertFn)(ColorConvertParams src,
+                          ColorConvertParams dst, uint8_t *adjustedClip);
+
+int convert(ColorConvertParams src, ColorConvertParams dst,
+            uint8_t *adjustedClip);
+#endif
+
 }  // namespace android
 
 #endif  // COLOR_CONVERTER_H_
diff --git a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
index 713af92..effa686 100644
--- a/include/media/stagefright/DataSource.h
+++ b/include/media/stagefright/DataSource.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2010-2012 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -77,7 +78,12 @@ public:
             const sp<DataSource> &source, String8 *mimeType,
             float *confidence, sp<AMessage> *meta);
 
+#ifdef QCOM_HARDWARE
+    //isExtendedExtractor if true, will store the location of the sniffer to register
+    static void RegisterSniffer(SnifferFunc func, bool isExtendedExtractor = false);
+#else
     static void RegisterSniffer(SnifferFunc func);
+#endif
     static void RegisterDefaultSniffers();
 
     // for DRM
@@ -92,6 +98,7 @@ public:
 
     virtual String8 getMIMEType() const;
 
+
 protected:
     virtual ~DataSource() {}
 
@@ -99,6 +106,10 @@ private:
     static Mutex gSnifferMutex;
     static List<SnifferFunc> gSniffers;
 
+#ifdef QCOM_HARDWARE
+    static List<SnifferFunc>::iterator extendedSnifferPosition;
+#endif
+
     DataSource(const DataSource &);
     DataSource &operator=(const DataSource &);
 };
diff --git a/include/media/stagefright/ExtendedExtractorFuncs.h b/include/media/stagefright/ExtendedExtractorFuncs.h
new file mode 100755
index 0000000..c1d6cd9
--- /dev/null
+++ b/include/media/stagefright/ExtendedExtractorFuncs.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef EXTENDED_EXTRACTOR_FUNCS_
+#define EXTENDED_EXTRACTOR_FUNCS_
+
+#include <media/stagefright/DataSource.h>
+
+namespace android {
+
+class MediaExtractor;
+
+//Prototype for factory function - extended media extractor must export a function with this prototype to
+//instantiate MediaExtractor objects.
+typedef MediaExtractor* (*MediaExtractorFactory)(const sp<DataSource> &source, const char* mime);
+
+//Function name for extractor factory function. Extended extractor must export a function with this name.
+static const char* MEDIA_CREATE_EXTRACTOR = "createExtractor";
+
+//Prototype for function to return sniffers - extended media extractor must export a function with this prototype to
+//set a pointer to an array of sniffers and set the count value.
+typedef void (*SnifferArrayFunc)(const DataSource::SnifferFunc* snifferArray[], int *count);
+
+//Function name for function to return sniffer array. Extended extractor must export a function with this name.
+static const char* MEDIA_SNIFFER_ARRAY = "snifferArray";
+
+}   //namespace android
+
+#endif  //EXTENDED_EXTRACTOR_FUNCS_
diff --git a/include/media/stagefright/ExtendedWriter.h b/include/media/stagefright/ExtendedWriter.h
new file mode 100644
index 0000000..b5bda5c
--- /dev/null
+++ b/include/media/stagefright/ExtendedWriter.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2011 Code Aurora Forum. All rights reserved
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef EXTENDED_WRITER_H_
+
+#define EXTENDED_WRITER_H_
+
+#include <stdio.h>
+
+#include <media/stagefright/MediaWriter.h>
+#include <utils/threads.h>
+
+namespace android {
+
+struct MediaSource;
+struct MetaData;
+
+struct ExtendedWriter : public MediaWriter {
+    ExtendedWriter(const char *filename);
+    ExtendedWriter(int fd);
+
+    status_t initCheck() const;
+
+    virtual status_t addSource(const sp<MediaSource> &source);
+    virtual bool reachedEOS();
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual status_t pause();
+
+protected:
+    virtual ~ExtendedWriter();
+
+private:
+    FILE *mFile;
+    status_t mInitCheck;
+    sp<MediaSource> mSource;
+    bool mStarted;
+    volatile bool mPaused;
+    volatile bool mResumed;
+    volatile bool mDone;
+    volatile bool mReachedEOS;
+    pthread_t mThread;
+    int64_t mEstimatedSizeBytes;
+    int64_t mEstimatedDurationUs;
+
+    int32_t mFormat;
+
+    //QCP/EVRC header
+    struct QCPEVRCHeader
+    {
+        /* RIFF Section */
+        char riff[4];
+        unsigned int s_riff;
+        char qlcm[4];
+
+        /* Format chunk */
+        char fmt[4];
+        unsigned int s_fmt;
+        char mjr;
+        char mnr;
+        unsigned int data1;
+
+        /* UNIQUE ID of the codec */
+        unsigned short data2;
+        unsigned short data3;
+        char data4[8];
+        unsigned short ver;
+
+        /* Codec Info */
+        char name[80];
+        unsigned short abps;
+
+        /* average bits per sec of the codec */
+        unsigned short bytes_per_pkt;
+        unsigned short samp_per_block;
+        unsigned short samp_per_sec;
+        unsigned short bits_per_samp;
+        unsigned char vr_num_of_rates;
+
+        /* Rate Header fmt info */
+        unsigned char rvd1[3];
+        unsigned short vr_bytes_per_pkt[8];
+        unsigned int rvd2[5];
+
+        /* Vrat chunk */
+        unsigned char vrat[4];
+        unsigned int s_vrat;
+        unsigned int v_rate;
+        unsigned int size_in_pkts;
+
+        /* Data chunk */
+        unsigned char data[4];
+        unsigned int s_data;
+    } __attribute__ ((packed));
+
+    struct QCPEVRCHeader mHeader;
+    off_t mOffset; //note off_t
+
+    static void *ThreadWrapper(void *);
+    status_t threadFunc();
+    bool exceedsFileSizeLimit();
+    bool exceedsFileDurationLimit();
+
+    ExtendedWriter(const ExtendedWriter &);
+    ExtendedWriter &operator=(const ExtendedWriter &);
+
+    status_t writeQCPHeader( );
+    status_t writeEVRCHeader( );
+};
+
+}  // namespace android
+
+#endif  // AMR_WRITER_H_
diff --git a/include/media/stagefright/LPAPlayer.h b/include/media/stagefright/LPAPlayer.h
new file mode 100644
index 0000000..2db4b10
--- /dev/null
+++ b/include/media/stagefright/LPAPlayer.h
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef LPA_PLAYER_H_
+
+#define LPA_PLAYER_H_
+
+#include "AudioPlayer.h"
+#include <media/IAudioFlinger.h>
+#include <utils/threads.h>
+#include <utils/List.h>
+#include <utils/Vector.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <binder/IServiceManager.h>
+#include <linux/unistd.h>
+#include <linux/msm_audio.h>
+#include <linux/ion.h>
+#include <include/TimedEventQueue.h>
+#include <binder/BinderService.h>
+#include <binder/MemoryDealer.h>
+#include <powermanager/IPowerManager.h>
+
+// Pause timeout = 3sec
+#define LPA_PAUSE_TIMEOUT_USEC 3000000
+
+namespace android {
+
+class LPAPlayer : public AudioPlayer  {
+public:
+    enum {
+        REACHED_EOS,
+        SEEK_COMPLETE
+    };
+
+    LPAPlayer(const sp<MediaPlayerBase::AudioSink> &audioSink, bool &initCheck,
+                AwesomePlayer *audioObserver = NULL);
+
+    virtual ~LPAPlayer();
+
+    // Caller retains ownership of "source".
+    virtual void setSource(const sp<MediaSource> &source);
+
+    // Return time in us.
+    virtual int64_t getRealTimeUs();
+
+    virtual status_t start(bool sourceAlreadyStarted = false);
+
+    virtual void pause(bool playPendingSamples = false);
+    virtual void resume();
+
+    // Returns the timestamp of the last buffer played (in us).
+    virtual int64_t getMediaTimeUs();
+
+    // Returns true iff a mapping is established, i.e. the LPAPlayer
+    // has played at least one frame of audio.
+    virtual bool getMediaTimeMapping(int64_t *realtime_us, int64_t *mediatime_us);
+
+    virtual status_t seekTo(int64_t time_us);
+
+    virtual bool isSeeking();
+    virtual bool reachedEOS(status_t *finalStatus);
+
+
+    void* handle;
+    static int objectsAlive;
+private:
+
+    int afd;
+    int efd;
+    int ionfd;
+    int sessionId;
+    uint32_t bytesToWrite;
+    bool isPaused;
+    bool mSeeked;
+    bool a2dpDisconnectPause;
+    bool a2dpResumeAfterReConnect;
+    bool a2dpThreadStarted;
+    volatile bool asyncReset;
+    bool eventThreadCreated;
+    int mBuffSize;
+    int mBuffNumber;
+
+    void clearPowerManager();
+
+    class PMDeathRecipient : public IBinder::DeathRecipient {
+        public:
+                        PMDeathRecipient(void *obj){parentClass = (LPAPlayer *)obj;}
+            virtual     ~PMDeathRecipient() {}
+
+            // IBinder::DeathRecipient
+            virtual     void        binderDied(const wp<IBinder>& who);
+
+        private:
+                        LPAPlayer *parentClass;
+                        PMDeathRecipient(const PMDeathRecipient&);
+                        PMDeathRecipient& operator = (const PMDeathRecipient&);
+
+        friend class LPAPlayer;
+    };
+
+    friend class PMDeathRecipient;
+
+    void        acquireWakeLock();
+    void        releaseWakeLock();
+
+    sp<IPowerManager>       mPowerManager;
+    sp<IBinder>             mWakeLockToken;
+    sp<PMDeathRecipient>    mDeathRecipient;
+
+    //Structure to hold ion buffer information
+    class BuffersAllocated {
+    /* overload BuffersAllocated constructor to support both ion and pmem memory allocation */
+    public:
+        BuffersAllocated(void *buf1, void *buf2, int32_t nSize, int32_t fd) :
+        localBuf(buf1), memBuf(buf2), memBufsize(nSize), memFd(fd)
+        {}
+        BuffersAllocated(void *buf1, void *buf2, int32_t nSize, int32_t share_fd, struct ion_handle *handle) :
+        ion_handle(handle), localBuf(buf1), memBuf(buf2), memBufsize(nSize), memFd(share_fd)
+        {}
+        struct ion_handle *ion_handle;
+        void* localBuf;
+        void* memBuf;
+        int32_t memBufsize;
+        int32_t memFd;
+        uint32_t bytesToWrite;
+    };
+    void audio_register_memory();
+    void memBufferDeAlloc();
+    void *memBufferAlloc(int32_t nSize, int32_t *mem_fd);
+
+    List<BuffersAllocated> memBuffersRequestQueue;
+    List<BuffersAllocated> memBuffersResponseQueue;
+    List<BuffersAllocated> bufPool;
+    List<BuffersAllocated> effectsQueue;
+
+
+    //Declare all the threads
+    pthread_t eventThread;
+    pthread_t decoderThread;
+    pthread_t A2DPThread;
+    pthread_t EffectsThread;
+    pthread_t A2DPNotificationThread;
+
+    //Kill Thread boolean
+    bool killDecoderThread;
+    bool killEventThread;
+    bool killA2DPThread;
+    bool killEffectsThread;
+    bool killA2DPNotificationThread;
+
+    //Thread alive boolean
+    bool decoderThreadAlive;
+    bool eventThreadAlive;
+    bool a2dpThreadAlive;
+    bool effectsThreadAlive;
+    bool a2dpNotificationThreadAlive;
+
+    //Declare the condition Variables and Mutex
+    pthread_mutex_t mem_request_mutex;
+    pthread_mutex_t mem_response_mutex;
+    pthread_mutex_t decoder_mutex;
+    pthread_mutex_t event_mutex;
+    pthread_mutex_t a2dp_mutex;
+    pthread_mutex_t effect_mutex;
+    pthread_mutex_t apply_effect_mutex;
+    pthread_mutex_t a2dp_notification_mutex;
+    pthread_mutex_t pause_mutex;
+
+    pthread_cond_t event_cv;
+    pthread_cond_t decoder_cv;
+    pthread_cond_t a2dp_cv;
+    pthread_cond_t effect_cv;
+    pthread_cond_t event_thread_cv;
+    pthread_cond_t a2dp_notification_cv;
+    pthread_cond_t pause_cv;
+
+    // make sure Decoder thread has exited
+    void requestAndWaitForDecoderThreadExit();
+
+    // make sure the event thread also exited
+    void requestAndWaitForEventThreadExit();
+
+    // make sure the A2dp thread also exited
+    void requestAndWaitForA2DPThreadExit();
+
+    // make sure the Effects thread also exited
+    void requestAndWaitForEffectsThreadExit();
+
+    // make sure the Effects thread also exited
+    void requestAndWaitForA2DPNotificationThreadExit();
+
+    static void *eventThreadWrapper(void *me);
+    void eventThreadEntry();
+    static void *decoderThreadWrapper(void *me);
+    void decoderThreadEntry();
+    static void *A2DPThreadWrapper(void *me);
+    void A2DPThreadEntry();
+    static void *EffectsThreadWrapper(void *me);
+    void EffectsThreadEntry();
+    static void *A2DPNotificationThreadWrapper(void *me);
+    void A2DPNotificationThreadEntry();
+
+    void createThreads();
+
+    volatile bool bIsA2DPEnabled, bIsAudioRouted, bEffectConfigChanged;
+
+    //Structure to recieve the BT notification from the flinger.
+    class AudioFlingerLPAdecodeClient: public IBinder::DeathRecipient, public BnAudioFlingerClient {
+    public:
+        AudioFlingerLPAdecodeClient(void *obj);
+
+        LPAPlayer *pBaseClass;
+        // DeathRecipient
+        virtual void binderDied(const wp<IBinder>& who);
+
+        // IAudioFlingerClient
+
+        // indicate a change in the configuration of an output or input: keeps the cached
+        // values for output/input parameters upto date in client process
+        virtual void ioConfigChanged(int event, int ioHandle, void *param2);
+
+        friend class LPAPlayer;
+    };
+
+    sp<IAudioFlinger> mAudioFlinger;
+
+    // helper function to obtain AudioFlinger service handle
+    void getAudioFlinger();
+
+    void handleA2DPSwitch();
+
+    sp<AudioFlingerLPAdecodeClient> AudioFlingerClient;
+    friend class AudioFlingerLPAdecodeClient;
+    Mutex AudioFlingerLock;
+    bool mSourceEmpty;
+    bool mAudioSinkOpen;
+
+    sp<MediaSource> mSource;
+
+    MediaBuffer *mInputBuffer;
+    int32_t numChannels;
+    int mSampleRate;
+    int64_t mLatencyUs;
+    size_t mFrameSize;
+
+    Mutex pmLock;
+    Mutex mLock;
+    Mutex mSeekLock;
+    Mutex a2dpSwitchLock;
+    Mutex resumeLock;
+    int64_t mNumFramesPlayed;
+
+    int64_t mPositionTimeMediaUs;
+    int64_t mPositionTimeRealUs;
+
+    bool mSeeking;
+    bool mInternalSeeking;
+    bool mReachedEOS;
+    bool mReachedOutputEOS;
+    status_t mFinalStatus;
+    int64_t mSeekTimeUs;
+    int64_t mPauseTime;
+    int64_t mNumA2DPBytesPlayed;
+    int64_t timePlayed;
+    int64_t timeStarted;
+
+    bool mStarted;
+
+    bool mIsFirstBuffer;
+    status_t mFirstBufferResult;
+    MediaBuffer *mFirstBuffer;
+    TimedEventQueue mQueue;
+    bool            mQueueStarted;
+    sp<TimedEventQueue::Event>  mPauseEvent;
+    bool                        mPauseEventPending;
+    bool                        mPlaybackSuspended;
+    bool                        mIsDriverStarted;
+    bool                        mIsAudioRouted;
+
+    sp<MediaPlayerBase::AudioSink> mAudioSink;
+    AwesomePlayer *mObserver;
+
+    enum A2DPState {
+        A2DP_ENABLED,
+        A2DP_DISABLED,
+        A2DP_CONNECT,
+        A2DP_DISCONNECT
+    };
+
+    size_t fillBuffer(void *data, size_t size);
+
+    int64_t getRealTimeUsLocked();
+    int64_t getTimeStamp(A2DPState state);
+
+    void reset();
+
+    void onPauseTimeOut();
+
+
+    LPAPlayer(const LPAPlayer &);
+    LPAPlayer &operator=(const LPAPlayer &);
+};
+
+struct TimedEvent : public TimedEventQueue::Event {
+    TimedEvent(LPAPlayer *player,
+               void (LPAPlayer::*method)())
+        : mPlayer(player),
+          mMethod(method) {
+    }
+
+protected:
+    virtual ~TimedEvent() {}
+
+    virtual void fire(TimedEventQueue *queue, int64_t /* now_us */) {
+        (mPlayer->*mMethod)();
+    }
+
+private:
+    LPAPlayer *mPlayer;
+    void (LPAPlayer::*mMethod)();
+
+    TimedEvent(const TimedEvent &);
+    TimedEvent &operator=(const TimedEvent &);
+};
+
+}  // namespace android
+
+#endif  // LPA_PLAYER_H_
+
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
old mode 100644
new mode 100755
index 2eb259e..9559083
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2010-2012 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -55,6 +56,21 @@ extern const char *MEDIA_MIMETYPE_CONTAINER_WVM;
 
 extern const char *MEDIA_MIMETYPE_TEXT_3GPP;
 
+#ifdef QCOM_HARDWARE
+extern const char *MEDIA_MIMETYPE_AUDIO_EVRC;
+
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA;
+extern const char *MEDIA_MIMETYPE_CONTAINER_ASF;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX;
+extern const char *MEDIA_MIMETYPE_AUDIO_AC3;
+extern const char *MEDIA_MIMETYPE_CONTAINER_AAC;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCP;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX311;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX4;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2;
+extern const char *MEDIA_MIMETYPE_CONTAINER_3G2;
+#endif
 }  // namespace android
 
 #endif  // MEDIA_DEFS_H_
diff --git a/include/media/stagefright/MediaErrors.h b/include/media/stagefright/MediaErrors.h
index 21d00b8..4154739 100644
--- a/include/media/stagefright/MediaErrors.h
+++ b/include/media/stagefright/MediaErrors.h
@@ -41,6 +41,11 @@ enum {
     INFO_FORMAT_CHANGED    = MEDIA_ERROR_BASE - 12,
     INFO_DISCONTINUITY     = MEDIA_ERROR_BASE - 13,
 
+#ifdef QCOM_HARDWARE
+    //Custom Error for corrupt NAL
+    ERROR_CORRUPT_NAL      = MEDIA_ERROR_BASE - 99,
+#endif
+
     // The following constant values should be in sync with
     // drm/drm_framework_common.h
     DRM_ERROR_BASE = -2000,
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
old mode 100644
new mode 100755
index 4cdee17..45927be
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2010-2011 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -47,6 +48,9 @@ enum {
     kKeyFrameRate         = 'frmR',  // int32_t (video frame rate fps)
     kKeyBitRate           = 'brte',  // int32_t (bps)
     kKeyESDS              = 'esds',  // raw data
+#ifdef QCOM_HARDWARE
+    kKeyAacCodecSpecificData = 'nacc' , // for native aac files
+#endif
     kKeyAVCC              = 'avcc',  // raw data
     kKeyD263              = 'd263',  // raw data
     kKeyVorbisInfo        = 'vinf',  // raw data
@@ -113,6 +117,20 @@ enum {
     kKeyValidSamples      = 'valD',  // int32_t
 
     kKeyIsUnreadable      = 'unre',  // bool (int32_t)
+#ifdef QCOM_HARDWARE
+    kKeyRawCodecSpecificData = 'rcsd',  // raw data - added to support mmParser
+    kKeyDivXVersion       = 'DivX',  // int32_t
+    kKeyDivXDrm           = 'QDrm',  // void *
+    kKeyWMAEncodeOpt      = 'eopt',  // int32_t
+    kKeyWMABlockAlign     = 'blka',  // int32_t
+    kKeyWMAVersion        = 'wmav',  // int32_t
+    kKeyWMAAdvEncOpt1     = 'ade1',   // int16_t
+    kKeyWMAAdvEncOpt2     = 'ade2',  // int32_t
+    kKeyWMAFormatTag      = 'fmtt',  // int64_t
+    kKeyWMABitspersample  = 'bsps',  // int64_t
+    kKeyWMAVirPktSize     = 'vpks',  // int64_t
+    kKeyWMVProfile        = 'wmvp',   //int32_t
+#endif
 
     // An indication that a video buffer has been rendered.
     kKeyRendered          = 'rend',  // bool (int32_t)
@@ -122,8 +140,21 @@ enum {
 
     // To store the timed text format data
     kKeyTextFormatData    = 'text',  // raw data
+#ifdef QCOM_HARDWARE
+    kkeyAacFormatAdif     = 'adif', // bool (int32_t)
+    kkeyAacFormatLtp      = 'ltp',
+#endif
 
     kKeyRequiresSecureBuffers = 'secu',  // bool (int32_t)
+
+#ifdef QCOM_HARDWARE
+    // 3D Video Flag
+    kKey3D                = '3Dvf',  // bool (int32_t)
+    kKeyHFR               = 'hfr ',  // int32_t
+    //Extractor sets this
+    kKeyUseArbitraryMode  = 'ArbM'  //bool (int32_t)
+#endif
+
 };
 
 enum {
@@ -131,6 +162,19 @@ enum {
     kTypeAVCC        = 'avcc',
     kTypeD263        = 'd263',
 };
+#ifdef QCOM_HARDWARE
+enum {
+    kTypeDivXVer_3_11,
+    kTypeDivXVer_4,
+    kTypeDivXVer_5,
+    kTypeDivXVer_6,
+};
+enum {
+    kTypeWMA,
+    kTypeWMAPro,
+    kTypeWMALossLess,
+};
+#endif
 
 class MetaData : public RefBase {
 public:
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
old mode 100644
new mode 100755
index 84f8282..e338ba4
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
- *
+ * Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
@@ -13,6 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*--------------------------------------------------------------------------
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+--------------------------------------------------------------------------*/
 
 #ifndef OMX_CODEC_H_
 
@@ -56,6 +59,11 @@ struct OMXCodec : public MediaSource,
 
         // Secure decoding mode
         kUseSecureInputBuffers = 256,
+
+#ifdef QCOM_HARDWARE
+        kEnableThumbnailMode = 512,
+        kUseMinBufferCount = 32768,
+#endif
     };
     static sp<MediaSource> Create(
             const sp<IOMX> &omx,
@@ -109,10 +117,18 @@ private:
         EXECUTING_TO_IDLE,
         IDLE_TO_LOADED,
         RECONFIGURING,
+#ifdef QCOM_HARDWARE
+        PAUSING,
+        FLUSHING,
+        PAUSED,
+#endif
         ERROR
     };
 
     enum {
+#ifdef QCOM_HARDWARE
+        kPortIndexBoth   = -1,
+#endif
         kPortIndexInput  = 0,
         kPortIndexOutput = 1
     };
@@ -140,6 +156,11 @@ private:
         kAvoidMemcopyInputRecordingFrames     = 2048,
         kRequiresLargerEncoderOutputBuffer    = 4096,
         kOutputBuffersAreUnreadable           = 8192,
+#ifdef QCOM_HARDWARE
+        kStoreMetaDataInInputVideoBuffers     = 16384,
+        kRequiresGlobalFlush                  = 0x20000000, // 2^29
+        kRequiresWMAProComponent              = 0x40000000, //2^30
+#endif
     };
 
     enum BufferStatus {
@@ -156,6 +177,8 @@ private:
         size_t mSize;
         void *mData;
         MediaBuffer *mMediaBuffer;
+        OMX_U8 *mAllocatedBuffer;
+        OMX_U32 mAllocatedSize;
     };
 
     struct CodecSpecificData {
@@ -193,6 +216,9 @@ private:
     ReadOptions::SeekMode mSeekMode;
     int64_t mTargetTimeUs;
     bool mOutputPortSettingsChangedPending;
+#ifdef QCOM_HARDWARE
+    bool mThumbnailMode;
+#endif
 
     MediaBuffer *mLeftOverBuffer;
 
@@ -212,6 +238,14 @@ private:
     List<size_t> mFilledBuffers;
     Condition mBufferFilled;
 
+#ifdef QCOM_HARDWARE
+    bool mIsMetaDataStoredInVideoBuffers;
+    bool mOnlySubmitOneBufferAtOneTime;
+    bool mInterlaceFormatDetected;
+    bool mSPSParsed;
+    bool bInvalidState;
+#endif
+
     // Used to record the decoding time for an output picture from
     // a video encoder.
     List<int64_t> mDecodingTimeList;
@@ -229,7 +263,13 @@ private:
 
     void setAMRFormat(bool isWAMR, int32_t bitRate);
     status_t setAACFormat(int32_t numChannels, int32_t sampleRate, int32_t bitRate);
+#ifdef QCOM_HARDWARE
+    void setEVRCFormat( int32_t sampleRate, int32_t numChannels, int32_t bitRate);
+#endif
     void setG711Format(int32_t numChannels);
+#ifdef QCOM_HARDWARE
+    void setQCELPFormat( int32_t sampleRate, int32_t numChannels, int32_t bitRate);
+#endif
 
     status_t setVideoPortFormatType(
             OMX_U32 portIndex,
@@ -338,10 +378,20 @@ private:
 
     status_t parseAVCCodecSpecificData(
             const void *data, size_t size,
-            unsigned *profile, unsigned *level);
+            unsigned *profile, unsigned *level, const sp<MetaData> &meta);
+#ifdef QCOM_HARDWARE
+    void parseFlags( uint32_t flags );
+#endif
 
     OMXCodec(const OMXCodec &);
     OMXCodec &operator=(const OMXCodec &);
+#ifdef QCOM_HARDWARE
+    status_t setWMAFormat(const sp<MetaData> &inputFormat);
+    void setAC3Format(int32_t numChannels, int32_t sampleRate);
+
+    int32_t mNumBFrames;
+    bool mUseArbitraryMode;
+#endif
 };
 
 struct CodecCapabilities {
diff --git a/include/media/stagefright/SurfaceMediaSource.h b/include/media/stagefright/SurfaceMediaSource.h
index d0940bb..4fedf1c 100644
--- a/include/media/stagefright/SurfaceMediaSource.h
+++ b/include/media/stagefright/SurfaceMediaSource.h
@@ -127,6 +127,18 @@ public:
     // modes (S.Encoder vis-a-vis SurfaceTexture)
     virtual status_t setSynchronousMode(bool enabled);
 
+#ifdef QCOM_HARDWARE
+    // performQcomOperation performs Qcom specific operations. The actual
+    // operation to be performed depends on the operation specified.
+    //
+    // The argument list is filled by the client based on the operation that
+    // the client wants to specify.
+    //
+    // This method will fail if the operation is invalid or the arguments
+    // specified in the operation are invalid.
+    virtual status_t performQcomOperation(int operation, int arg1, int arg2, int arg3) {}
+#endif
+
     // connect attempts to connect a client API to the SurfaceMediaSource.  This
     // must be called before any other ISurfaceTexture methods are called except
     // for getAllocator.
diff --git a/include/media/stagefright/Utils.h b/include/media/stagefright/Utils.h
index 498b525..667b75d 100644
--- a/include/media/stagefright/Utils.h
+++ b/include/media/stagefright/Utils.h
@@ -19,6 +19,7 @@
 #define UTILS_H_
 
 #include <stdint.h>
+#include <utils/Errors.h>
 
 namespace android {
 
@@ -36,6 +37,20 @@ uint64_t U64LE_AT(const uint8_t *ptr);
 uint64_t ntoh64(uint64_t x);
 uint64_t hton64(uint64_t x);
 
+#ifdef QCOM_HARDWARE
+typedef struct {
+    uint8_t mProfile;
+    uint8_t mLevel;
+    int32_t mHeightInMBs;
+    int32_t mWidthInMBs;
+    int32_t mNumRefFrames;
+    int32_t mInterlaced;
+} SpsInfo;
+
+status_t
+parseSps(uint16_t naluSize,const uint8_t *encodedBytes, SpsInfo *info);
+#endif
+
 }  // namespace android
 
 #endif  // UTILS_H_
diff --git a/include/media/stagefright/openmax/OMX_IVCommon.h b/include/media/stagefright/openmax/OMX_IVCommon.h
index 8bb4ded..7391e56 100644
--- a/include/media/stagefright/openmax/OMX_IVCommon.h
+++ b/include/media/stagefright/openmax/OMX_IVCommon.h
@@ -158,7 +158,9 @@ typedef enum OMX_COLOR_FORMATTYPE {
      * */
     OMX_COLOR_FormatAndroidOpaque = 0x7F000789,
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
+#ifndef QCOM_HARDWARE
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
+#endif
     OMX_COLOR_FormatMax = 0x7FFFFFFF
 } OMX_COLOR_FORMATTYPE;
 
diff --git a/include/surfaceflinger/IGraphicBufferAlloc.h b/include/surfaceflinger/IGraphicBufferAlloc.h
index d3b2062..7856b7c 100644
--- a/include/surfaceflinger/IGraphicBufferAlloc.h
+++ b/include/surfaceflinger/IGraphicBufferAlloc.h
@@ -38,6 +38,20 @@ public:
      */
     virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t w, uint32_t h,
             PixelFormat format, uint32_t usage, status_t* error) = 0;
+
+#ifdef QCOM_HARDWARE
+    /* Free all but one of the GraphicBuffer objects that the server is
+     * currently referencing. If bufIndex is not a valid index of the buffers
+     * the server is referencing, then all buffers are freed.
+     */
+    virtual void freeAllGraphicBuffersExcept(int bufIndex) = 0;
+
+    /* Free the GraphicBuffer at the specified index */
+    virtual void freeGraphicBufferAtIndex(int bufIndex) = 0;
+
+    /* Sets the required size of the Graphic Buffers */
+    virtual void setGraphicBufferSize(int size) = 0;
+#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/surfaceflinger/Surface.h b/include/surfaceflinger/Surface.h
index 0460bbd..16125e9 100644
--- a/include/surfaceflinger/Surface.h
+++ b/include/surfaceflinger/Surface.h
@@ -140,6 +140,9 @@ public:
     status_t    unlockAndPost();
 
     sp<IBinder> asBinder() const;
+#ifdef QCOM_HARDWARE
+    status_t    setStereoscopic3DFormat(int format);
+#endif
 
 private:
     // this is just to be able to write some unit tests
diff --git a/include/ui/FramebufferNativeWindow.h b/include/ui/FramebufferNativeWindow.h
index 302d012..1afc66c 100644
--- a/include/ui/FramebufferNativeWindow.h
+++ b/include/ui/FramebufferNativeWindow.h
@@ -30,7 +30,11 @@
 
 #include <ui/egl/android_natives.h>
 
+#ifdef QCOM_HARDWARE
+#define NUM_FRAMEBUFFERS_MAX  3
+#else
 #define NUM_FRAME_BUFFERS  2
+#endif
 
 extern "C" EGLNativeWindowType android_createDisplaySurface(void);
 
@@ -76,7 +80,11 @@ private:
     framebuffer_device_t* fbDev;
     alloc_device_t* grDev;
 
-    sp<NativeBuffer> buffers[NUM_FRAME_BUFFERS];
+#ifdef QCOM_HARDWARE
+    sp<NativeBuffer> buffers[NUM_FRAMEBUFFERS_MAX];
+#else
+     sp<NativeBuffer> buffers[NUM_FRAME_BUFFERS];
+#endif
     sp<NativeBuffer> front;
     
     mutable Mutex mutex;
diff --git a/include/ui/GraphicBuffer.h b/include/ui/GraphicBuffer.h
index 6ab01f4..2a18731 100644
--- a/include/ui/GraphicBuffer.h
+++ b/include/ui/GraphicBuffer.h
@@ -64,6 +64,9 @@ public:
         USAGE_HW_2D             = GRALLOC_USAGE_HW_2D,
         USAGE_HW_COMPOSER       = GRALLOC_USAGE_HW_COMPOSER,
         USAGE_HW_VIDEO_ENCODER  = GRALLOC_USAGE_HW_VIDEO_ENCODER,
+#ifdef SAMSUNG_CODEC_SUPPORT
+        USAGE_HW_FIMC1          = GRALLOC_USAGE_HW_FIMC1,
+#endif
         USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK
     };
 
diff --git a/include/ui/GraphicBufferAllocator.h b/include/ui/GraphicBufferAllocator.h
index dffa788..3682ea3 100644
--- a/include/ui/GraphicBufferAllocator.h
+++ b/include/ui/GraphicBufferAllocator.h
@@ -56,6 +56,9 @@ public:
         USAGE_HW_TEXTURE        = GRALLOC_USAGE_HW_TEXTURE,
         USAGE_HW_RENDER         = GRALLOC_USAGE_HW_RENDER,
         USAGE_HW_2D             = GRALLOC_USAGE_HW_2D,
+#ifdef SAMSUNG_CODEC_SUPPORT
+        USAGE_HW_FIMC1          = GRALLOC_USAGE_HW_FIMC1,
+#endif
         USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK
     };
 
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index 697a02a..4db91ae 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -46,6 +46,10 @@ public:
             int usage, const Rect& bounds, void** vaddr);
 
     status_t unlock(buffer_handle_t handle);
+
+#ifdef EXYNOS4210_ENHANCEMENTS
+    status_t getphys(buffer_handle_t handle, void** paddr);
+#endif
     
     // dumps information about the mapping of this handle
     void dump(buffer_handle_t handle);
diff --git a/include/ui/KeycodeLabels.h b/include/ui/KeycodeLabels.h
index c5bd0c5..dde50f7 100755
--- a/include/ui/KeycodeLabels.h
+++ b/include/ui/KeycodeLabels.h
@@ -235,6 +235,26 @@ static const KeycodeLabel KEYCODES[] = {
     { "CALENDAR", 208 },
     { "MUSIC", 209 },
     { "CALCULATOR", 210 },
+    { "TOGGLE_WIFI", 211 },
+    { "TOGGLE_BT", 212 },
+    { "TOGGLE_TOUCHPAD", 213 },
+    { "BRIGHTNESS_DOWN", 214 },
+    { "BRIGHTNESS_UP", 215 },
+    { "BRIGHTNESS_AUTO", 216 },
+    { "SCREENSHOT", 217 },
+    { "FUNC_1", 218 },
+    { "FUNC_2", 219 },
+    { "FUNC_3", 220 },
+    { "FUNC_4", 221 },
+    { "FUNC_5", 222 },
+    { "FUNC_6", 223 },
+    { "FUNC_7", 224 },
+    { "FUNC_8", 225 },
+    { "USER1", 226 },
+    { "USER2", 227 },
+    { "USER3", 228 },
+    { "USER4", 229 },
+    { "USER5", 230 },
 
     // NOTE: If you add a new keycode here you must also add it to several other files.
     //       Refer to frameworks/base/core/java/android/view/KeyEvent.java for the full list.
diff --git a/include/ui/Overlay.h b/include/ui/Overlay.h
new file mode 100644
index 0000000..af2b849
--- /dev/null
+++ b/include/ui/Overlay.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_OVERLAY_H
+#define ANDROID_OVERLAY_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <utils/Errors.h>
+#include <binder/IInterface.h>
+#include <utils/RefBase.h>
+#include <utils/threads.h>
+#include <hardware/gralloc.h>
+
+#include <ui/PixelFormat.h>
+
+namespace android {
+
+typedef void* overlay_buffer_t;
+typedef uint32_t overlay_handle_t;
+
+class Overlay : public virtual RefBase
+{
+public:
+    typedef void (*QueueBufferHook)(void *data, void* buffer, size_t size);
+
+    enum Format {
+        FORMAT_YUV422SP,
+        FORMAT_YUV420SP,
+        FORMAT_YUV422I,
+        FORMAT_YUV420P,
+        FORMAT_RGB565,
+        FORMAT_RGBA8888,
+        FORMAT_UNKNOWN
+    };
+
+public:
+    Overlay(uint32_t width, uint32_t height, Format format, QueueBufferHook queueBuffer, void* data);
+
+    /* destroys this overlay */
+    void destroy();
+
+    /* get the HAL handle for this overlay */
+    overlay_handle_t getHandleRef() const;
+
+    /* blocks until an overlay buffer is available and return that buffer. */
+    status_t dequeueBuffer(overlay_buffer_t* buffer);
+
+    /* release the overlay buffer and post it */
+    status_t queueBuffer(overlay_buffer_t buffer);
+
+    /* change the width and height of the overlay */
+    status_t resizeInput(uint32_t width, uint32_t height);
+
+    status_t setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h) ;
+
+    status_t getCrop(uint32_t* x, uint32_t* y, uint32_t* w, uint32_t* h) ;
+
+    /* set the buffer attributes */
+    status_t setParameter(int param, int value);
+    status_t setFd(int fd);
+
+    /* returns the address of a given buffer if supported, NULL otherwise. */
+    void* getBufferAddress(overlay_buffer_t buffer);
+
+    /* get physical informations about the overlay */
+    uint32_t getWidth() const;
+    uint32_t getHeight() const;
+    int32_t getFormat() const;
+    int32_t getWidthStride() const;
+    int32_t getHeightStride() const;
+    int32_t getBufferCount() const;
+    status_t getStatus() const;
+
+public:
+    static int getBppFromFormat(Format format);
+    static Format getFormatFromString(const char* name);
+
+private:
+    virtual ~Overlay();
+
+    // C style hook
+    QueueBufferHook mQueueBufferHook;
+    void* mHookData;
+
+    // overlay data
+    static const uint32_t NUM_BUFFERS = 8;
+    static const uint32_t NUM_MIN_FREE_BUFFERS = 2;
+    uint32_t mNumFreeBuffers;
+
+    status_t mStatus;
+    uint32_t mWidth, mHeight;
+    Format mFormat;
+
+    // ashmem region
+    struct MappingData {
+        int fd;
+        size_t length;
+        uint32_t offset;
+        void *ptr;
+    };
+
+    MappingData mBuffers[NUM_BUFFERS];
+    bool mQueued[NUM_BUFFERS]; // true if buffer is currently queued
+
+    // queue/dequeue mutex
+    pthread_mutex_t mQueueMutex;
+};
+
+// ----------------------------------------------------------------------------
+
+}; // namespace android
+
+#endif // ANDROID_OVERLAY_H
diff --git a/libs/binder/Android.mk b/libs/binder/Android.mk
index 3a12e96..8bb32f0 100644
--- a/libs/binder/Android.mk
+++ b/libs/binder/Android.mk
@@ -33,6 +33,11 @@ sources := \
 
 LOCAL_PATH:= $(call my-dir)
 
+# Just an info!
+# Note about gingerbread compatibility : Require a global cflag,
+# several projects use binder's IMemory.h and MemoryHeapBase.h
+# COMMON_GLOBAL_CFLAGS += -DBINDER_COMPAT
+
 include $(CLEAR_VARS)
 LOCAL_LDLIBS += -lpthread
 LOCAL_MODULE := libbinder
diff --git a/libs/binder/IMemory.cpp b/libs/binder/IMemory.cpp
index 1ace8f8..a2d573d 100644
--- a/libs/binder/IMemory.cpp
+++ b/libs/binder/IMemory.cpp
@@ -81,7 +81,9 @@ public:
     virtual void* getBase() const;
     virtual size_t getSize() const;
     virtual uint32_t getFlags() const;
+#ifndef BINDER_COMPAT
     virtual uint32_t getOffset() const;
+#endif
 
 private:
     friend class IMemory;
@@ -108,9 +110,14 @@ private:
     mutable void*       mBase;
     mutable size_t      mSize;
     mutable uint32_t    mFlags;
+#ifndef BINDER_COMPAT
     mutable uint32_t    mOffset;
+#endif
     mutable bool        mRealHeap;
     mutable Mutex       mLock;
+#ifdef QCOM_HARDWARE
+    mutable int         mIonFd;
+#endif
 };
 
 // ----------------------------------------------------------------------------
@@ -231,8 +238,16 @@ status_t BnMemory::onTransact(
 
 BpMemoryHeap::BpMemoryHeap(const sp<IBinder>& impl)
     : BpInterface<IMemoryHeap>(impl),
-        mHeapId(-1), mBase(MAP_FAILED), mSize(0), mFlags(0), mOffset(0), mRealHeap(false)
+        mHeapId(-1), mBase(MAP_FAILED), mSize(0), mFlags(0),
+#ifndef BINDER_COMPAT
+        mOffset(0),
+#endif
+        mRealHeap(false)
 {
+#ifdef QCOM_HARDWARE
+    mIonFd = open("/dev/ion", O_RDONLY);
+#endif
+
 }
 
 BpMemoryHeap::~BpMemoryHeap() {
@@ -259,6 +274,10 @@ BpMemoryHeap::~BpMemoryHeap() {
             free_heap(binder);
         }
     }
+#ifdef QCOM_HARDWARE
+    if (mIonFd > 0)
+        close(mIonFd);
+#endif
 }
 
 void BpMemoryHeap::assertMapped() const
@@ -272,7 +291,9 @@ void BpMemoryHeap::assertMapped() const
             if (mHeapId == -1) {
                 mBase   = heap->mBase;
                 mSize   = heap->mSize;
-                mOffset = heap->mOffset;
+#ifndef BINDER_COMPAT
+                 mOffset = heap->mOffset;
+#endif
                 android_atomic_write( dup( heap->mHeapId ), &mHeapId );
             }
         } else {
@@ -296,7 +317,11 @@ void BpMemoryHeap::assertReallyMapped() const
         int parcel_fd = reply.readFileDescriptor();
         ssize_t size = reply.readInt32();
         uint32_t flags = reply.readInt32();
+#ifndef BINDER_COMPAT
         uint32_t offset = reply.readInt32();
+#else
+        uint32_t offset = 0;
+#endif
 
         LOGE_IF(err, "binder=%p transaction failed fd=%d, size=%ld, err=%d (%s)",
                 asBinder().get(), parcel_fd, size, err, strerror(-err));
@@ -321,7 +346,9 @@ void BpMemoryHeap::assertReallyMapped() const
             } else {
                 mSize = size;
                 mFlags = flags;
-                mOffset = offset;
+#ifndef BINDER_COMPAT
+                 mOffset = offset;
+#endif
                 android_atomic_write(fd, &mHeapId);
             }
         }
@@ -348,10 +375,12 @@ uint32_t BpMemoryHeap::getFlags() const {
     return mFlags;
 }
 
+#ifndef BINDER_COMPAT
 uint32_t BpMemoryHeap::getOffset() const {
     assertMapped();
     return mOffset;
 }
+#endif
 
 // ---------------------------------------------------------------------------
 
@@ -372,7 +401,9 @@ status_t BnMemoryHeap::onTransact(
             reply->writeFileDescriptor(getHeapID());
             reply->writeInt32(getSize());
             reply->writeInt32(getFlags());
+#ifndef BINDER_COMPAT
             reply->writeInt32(getOffset());
+#endif
             return NO_ERROR;
         } break;
         default:
diff --git a/libs/binder/MemoryHeapBase.cpp b/libs/binder/MemoryHeapBase.cpp
index bf4a73f..c9cee57 100644
--- a/libs/binder/MemoryHeapBase.cpp
+++ b/libs/binder/MemoryHeapBase.cpp
@@ -42,13 +42,19 @@ namespace android {
 
 MemoryHeapBase::MemoryHeapBase()
     : mFD(-1), mSize(0), mBase(MAP_FAILED),
-      mDevice(NULL), mNeedUnmap(false), mOffset(0)
+      mDevice(NULL), mNeedUnmap(false)
+#ifndef BINDER_COMPAT
+    , mOffset(0)
+#endif
 {
 }
 
 MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, char const * name)
     : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags),
-      mDevice(0), mNeedUnmap(false), mOffset(0)
+      mDevice(0), mNeedUnmap(false)
+#ifndef BINDER_COMPAT
+    , mOffset(0)
+#endif
 {
     const size_t pagesize = getpagesize();
     size = ((size + pagesize-1) & ~(pagesize-1));
@@ -65,7 +71,10 @@ MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, char const * name)
 
 MemoryHeapBase::MemoryHeapBase(const char* device, size_t size, uint32_t flags)
     : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags),
-      mDevice(0), mNeedUnmap(false), mOffset(0)
+      mDevice(0), mNeedUnmap(false)
+#ifndef BINDER_COMPAT
+    , mOffset(0)
+#endif
 {
     int open_flags = O_RDWR;
     if (flags & NO_CACHING)
@@ -84,7 +93,10 @@ MemoryHeapBase::MemoryHeapBase(const char* device, size_t size, uint32_t flags)
 
 MemoryHeapBase::MemoryHeapBase(int fd, size_t size, uint32_t flags, uint32_t offset)
     : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags),
-      mDevice(0), mNeedUnmap(false), mOffset(0)
+      mDevice(0), mNeedUnmap(false)
+#ifndef BINDER_COMPAT
+    , mOffset(0)
+#endif
 {
     const size_t pagesize = getpagesize();
     size = ((size + pagesize-1) & ~(pagesize-1));
@@ -141,7 +153,9 @@ status_t MemoryHeapBase::mapfd(int fd, size_t size, uint32_t offset)
     }
     mFD = fd;
     mSize = size;
+#ifndef BINDER_COMPAT
     mOffset = offset;
+#endif
     return NO_ERROR;
 }
 
@@ -184,9 +198,11 @@ const char* MemoryHeapBase::getDevice() const {
     return mDevice;
 }
 
+#ifndef BINDER_COMPAT
 uint32_t MemoryHeapBase::getOffset() const {
     return mOffset;
 }
+#endif
 
 // ---------------------------------------------------------------------------
 }; // namespace android
diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp
index 6b4c1a6..30fb1be 100644
--- a/libs/binder/Parcel.cpp
+++ b/libs/binder/Parcel.cpp
@@ -17,6 +17,7 @@
 #define LOG_TAG "Parcel"
 //#define LOG_NDEBUG 0
 
+#define _INTERNAL_BINDER_PARCEL_
 #include <binder/Parcel.h>
 
 #include <binder/IPCThreadState.h>
@@ -447,6 +448,12 @@ status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
     return err;
 }
 
+extern "C" Parcel *_ZN7android6Parcel10appendFromEPKS0_jj(Parcel *This, const Parcel *parcel, size_t offset, size_t len);
+extern "C" Parcel *_ZN7android6Parcel10appendFromEPS0_jj(Parcel *This, Parcel *parcel, size_t offset, size_t len)
+{
+    return _ZN7android6Parcel10appendFromEPKS0_jj(This, parcel, offset, len);
+}
+
 bool Parcel::pushAllowFds(bool allowFds)
 {
     const bool origValue = mAllowFds;
@@ -478,9 +485,14 @@ status_t Parcel::writeInterfaceToken(const String16& interface)
     return writeString16(interface);
 }
 
+bool Parcel::enforceInterface(const String16& interface) const
+{
+	return enforceInterface(interface,NULL);
+}
+
 bool Parcel::checkInterface(IBinder* binder) const
 {
-    return enforceInterface(binder->getInterfaceDescriptor());
+    return enforceInterface(binder->getInterfaceDescriptor(),NULL);
 }
 
 bool Parcel::enforceInterface(const String16& interface,
@@ -1047,10 +1059,11 @@ int32_t Parcel::readExceptionCode() const
 {
   int32_t exception_code = readAligned<int32_t>();
   if (exception_code == EX_HAS_REPLY_HEADER) {
+    int32_t header_start = dataPosition();
     int32_t header_size = readAligned<int32_t>();
     // Skip over fat responses headers.  Not used (or propagated) in
     // native code
-    setDataPosition(dataPosition() + header_size);
+    setDataPosition(header_start + header_size);
     // And fat response headers are currently only used when there are no
     // exceptions, so return no error:
     return 0;
diff --git a/libs/camera/CameraParameters.cpp b/libs/camera/CameraParameters.cpp
index c6087b4..9322a46 100644
--- a/libs/camera/CameraParameters.cpp
+++ b/libs/camera/CameraParameters.cpp
@@ -26,12 +26,39 @@ namespace android {
 // Parameter keys to communicate between camera application and driver.
 const char CameraParameters::KEY_PREVIEW_SIZE[] = "preview-size";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES[] = "preview-size-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_SUPPORTED_HFR_SIZES[] = "hfr-size-values";
+#endif
 const char CameraParameters::KEY_PREVIEW_FORMAT[] = "preview-format";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS[] = "preview-format-values";
 const char CameraParameters::KEY_PREVIEW_FRAME_RATE[] = "preview-frame-rate";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES[] = "preview-frame-rate-values";
 const char CameraParameters::KEY_PREVIEW_FPS_RANGE[] = "preview-fps-range";
 const char CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE[] = "preview-fps-range-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_PREVIEW_FRAME_RATE_MODE[] = "preview-frame-rate-mode";
+const char CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATE_MODES[] = "preview-frame-rate-modes";
+const char CameraParameters::KEY_PREVIEW_FRAME_RATE_AUTO_MODE[] = "frame-rate-auto";
+const char CameraParameters::KEY_PREVIEW_FRAME_RATE_FIXED_MODE[] = "frame-rate-fixed";
+//Values for Continuous AF
+const char CameraParameters::CAF_OFF[] = "caf-off";
+const char CameraParameters::CAF_ON[] = "caf-on";
+//Same, for CodeAurora-based blobs
+const char CameraParameters::CAPTURE_MODE_NORMAL[] = "normal";
+const char CameraParameters::CAPTURE_MODE_BURST[] = "burst";
+const char CameraParameters::CAPTURE_MODE_CONTI_BURST[] = "contiburst";
+const char CameraParameters::CAPTURE_MODE_HDR[] = "hdr";
+const char CameraParameters::CAPTURE_MODE_HJR[] = "hjr";
+const char CameraParameters::CAPTURE_MODE_PANORAMA[] = "panorama";    
+const char CameraParameters::CONTINUOUS_AF_OFF[] = "caf-off";
+const char CameraParameters::CONTINUOUS_AF_ON[] = "caf-on";
+const char CameraParameters::KEY_CONTINUOUS_AF[] = "continuous-af";
+const char CameraParameters::KEY_CAPTURE_MODE[] = "capture-mode";
+const char CameraParameters::KEY_PICTURE_COUNT[] = "picture-count";
+const char CameraParameters::KEY_MAX_BURST_PICTURE_COUNT[] = "max-burst-picture-count";
+const char CameraParameters::KEY_SUPPORTED_CONTINUOUS_AF[] = "continuous-af-mode";
+const char CameraParameters::KEY_SUPPORTED_CAPTURE_MODES[] = "capture-mode-values";
+#endif
 const char CameraParameters::KEY_PICTURE_SIZE[] = "picture-size";
 const char CameraParameters::KEY_SUPPORTED_PICTURE_SIZES[] = "picture-size-values";
 const char CameraParameters::KEY_PICTURE_FORMAT[] = "picture-format";
@@ -51,10 +78,20 @@ const char CameraParameters::KEY_WHITE_BALANCE[] = "whitebalance";
 const char CameraParameters::KEY_SUPPORTED_WHITE_BALANCE[] = "whitebalance-values";
 const char CameraParameters::KEY_EFFECT[] = "effect";
 const char CameraParameters::KEY_SUPPORTED_EFFECTS[] = "effect-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_TOUCH_AF_AEC[] = "touch-af-aec";
+const char CameraParameters::KEY_SUPPORTED_TOUCH_AF_AEC[] = "touch-af-aec-values";
+const char CameraParameters::KEY_TOUCH_INDEX_AEC[] = "touch-index-aec";
+const char CameraParameters::KEY_TOUCH_INDEX_AF[] = "touch-index-af";
+#endif
 const char CameraParameters::KEY_ANTIBANDING[] = "antibanding";
 const char CameraParameters::KEY_SUPPORTED_ANTIBANDING[] = "antibanding-values";
 const char CameraParameters::KEY_SCENE_MODE[] = "scene-mode";
 const char CameraParameters::KEY_SUPPORTED_SCENE_MODES[] = "scene-mode-values";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_SCENE_DETECT[] = "scene-detect";
+const char CameraParameters::KEY_SUPPORTED_SCENE_DETECT[] = "scene-detect-values";
+#endif
 const char CameraParameters::KEY_FLASH_MODE[] = "flash-mode";
 const char CameraParameters::KEY_SUPPORTED_FLASH_MODES[] = "flash-mode-values";
 const char CameraParameters::KEY_FOCUS_MODE[] = "focus-mode";
@@ -81,6 +118,41 @@ const char CameraParameters::KEY_ZOOM_SUPPORTED[] = "zoom-supported";
 const char CameraParameters::KEY_SMOOTH_ZOOM_SUPPORTED[] = "smooth-zoom-supported";
 const char CameraParameters::KEY_FOCUS_DISTANCES[] = "focus-distances";
 const char CameraParameters::KEY_VIDEO_FRAME_FORMAT[] = "video-frame-format";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_LENSSHADE[] = "lensshade";
+const char CameraParameters::KEY_SUPPORTED_LENSSHADE_MODES[] = "lensshade-values";
+#ifdef SAMSUNG_CAMERA_QCOM
+const char CameraParameters::KEY_AUTO_EXPOSURE[] = "metering";
+#else
+const char CameraParameters::KEY_AUTO_EXPOSURE[] = "auto-exposure";
+#endif
+const char CameraParameters::KEY_SUPPORTED_AUTO_EXPOSURE[] = "auto-exposure-values";
+const char CameraParameters::KEY_DENOISE[] = "denoise";
+const char CameraParameters::KEY_SUPPORTED_DENOISE[] = "denoise-values";
+const char CameraParameters::KEY_SELECTABLE_ZONE_AF[] = "selectable-zone-af";
+const char CameraParameters::KEY_SUPPORTED_SELECTABLE_ZONE_AF[] = "selectable-zone-af-values";
+const char CameraParameters::KEY_FACE_DETECTION[] = "face-detection";
+const char CameraParameters::KEY_SUPPORTED_FACE_DETECTION[] = "face-detection-values";
+const char CameraParameters::KEY_MEMORY_COLOR_ENHANCEMENT[] = "mce";
+const char CameraParameters::KEY_SUPPORTED_MEM_COLOR_ENHANCE_MODES[] = "mce-values";
+const char CameraParameters::KEY_VIDEO_HIGH_FRAME_RATE[] = "video-hfr";
+const char CameraParameters::KEY_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES[] = "video-hfr-values";
+const char CameraParameters::KEY_REDEYE_REDUCTION[] = "redeye-reduction";
+const char CameraParameters::KEY_SUPPORTED_REDEYE_REDUCTION[] = "redeye-reduction-values";
+const char CameraParameters::KEY_HIGH_DYNAMIC_RANGE_IMAGING[] = "hdr";
+const char CameraParameters::KEY_SUPPORTED_HDR_IMAGING_MODES[] = "hdr-values";
+#ifndef SAMSUNG_CAMERA_HARDWARE
+const char CameraParameters::KEY_ISO_MODE[] = "iso";
+const char CameraParameters::KEY_SUPPORTED_ISO_MODES[] = "iso-values";
+#endif
+#endif
+#ifdef SAMSUNG_CAMERA_HARDWARE
+const char CameraParameters::KEY_METERING[] = "metering";
+const char CameraParameters::KEY_WDR[] = "wdr";
+const char CameraParameters::KEY_ANTI_SHAKE_MODE[] = "anti-shake";
+const char CameraParameters::KEY_ISO_MODE[] = "iso";
+const char CameraParameters::KEY_SUPPORTED_ISO_MODES[] = "iso-values";
+#endif
 const char CameraParameters::KEY_VIDEO_SIZE[] = "video-size";
 const char CameraParameters::KEY_SUPPORTED_VIDEO_SIZES[] = "video-size-values";
 const char CameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO[] = "preferred-preview-size-for-video";
@@ -88,8 +160,17 @@ const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_HW[] = "max-num-detected
 const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_SW[] = "max-num-detected-faces-sw";
 const char CameraParameters::KEY_RECORDING_HINT[] = "recording-hint";
 const char CameraParameters::KEY_VIDEO_SNAPSHOT_SUPPORTED[] = "video-snapshot-supported";
+const char CameraParameters::KEY_FULL_VIDEO_SNAP_SUPPORTED[] = "full-video-snap-supported";
 const char CameraParameters::KEY_VIDEO_STABILIZATION[] = "video-stabilization";
 const char CameraParameters::KEY_VIDEO_STABILIZATION_SUPPORTED[] = "video-stabilization-supported";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::KEY_ZSL[] = "zsl";
+const char CameraParameters::KEY_SUPPORTED_ZSL_MODES[] = "zsl-values";
+const char CameraParameters::KEY_CAMERA_MODE[] = "camera-mode";
+#endif
+const char CameraParameters::KEY_AE_BRACKET_HDR[] = "ae-bracket-hdr";
+/*only effective when KEY_AE_BRACKET_HDR set to ae_bracketing*/
+//const char CameraParameters::KEY_AE_BRACKET_SETTING_KEY[] = "ae-bracket-setting";
 
 const char CameraParameters::TRUE[] = "true";
 const char CameraParameters::FALSE[] = "false";
@@ -115,6 +196,15 @@ const char CameraParameters::EFFECT_POSTERIZE[] = "posterize";
 const char CameraParameters::EFFECT_WHITEBOARD[] = "whiteboard";
 const char CameraParameters::EFFECT_BLACKBOARD[] = "blackboard";
 const char CameraParameters::EFFECT_AQUA[] = "aqua";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::EFFECT_EMBOSS[] = "emboss";
+const char CameraParameters::EFFECT_SKETCH[] = "sketch";
+const char CameraParameters::EFFECT_NEON[] = "neon";
+
+// Values for auto exposure settings.
+const char CameraParameters::TOUCH_AF_AEC_OFF[] = "touch-off";
+const char CameraParameters::TOUCH_AF_AEC_ON[] = "touch-on";
+#endif
 
 // Values for antibanding settings.
 const char CameraParameters::ANTIBANDING_AUTO[] = "auto";
@@ -130,7 +220,8 @@ const char CameraParameters::FLASH_MODE_RED_EYE[] = "red-eye";
 const char CameraParameters::FLASH_MODE_TORCH[] = "torch";
 
 // Values for scene mode settings.
-const char CameraParameters::SCENE_MODE_AUTO[] = "auto";
+const char CameraParameters::SCENE_MODE_AUTO[] = "auto"; // corresponds to CAMERA_BESTSHOT_OFF in HAL
+const char CameraParameters::SCENE_MODE_ASD[] = "asd";   // corresponds to CAMERA_BESTSHOT_AUTO in HAL
 const char CameraParameters::SCENE_MODE_ACTION[] = "action";
 const char CameraParameters::SCENE_MODE_PORTRAIT[] = "portrait";
 const char CameraParameters::SCENE_MODE_LANDSCAPE[] = "landscape";
@@ -145,16 +236,37 @@ const char CameraParameters::SCENE_MODE_FIREWORKS[] = "fireworks";
 const char CameraParameters::SCENE_MODE_SPORTS[] = "sports";
 const char CameraParameters::SCENE_MODE_PARTY[] = "party";
 const char CameraParameters::SCENE_MODE_CANDLELIGHT[] = "candlelight";
+#if defined(QCOM_HARDWARE) && !defined(SAMSUNG_CAMERA_QCOM)
+const char CameraParameters::SCENE_MODE_BACKLIGHT[] = "backlight";
+const char CameraParameters::SCENE_MODE_FLOWERS[] = "flowers";
+#endif
 const char CameraParameters::SCENE_MODE_BARCODE[] = "barcode";
-
+#ifdef QCOM_HARDWARE
+const char CameraParameters::SCENE_MODE_AR[] = "AR";
+const char CameraParameters::SCENE_MODE_OFF[] = "off";
+
+// Values for auto scene detection settings.
+const char CameraParameters::SCENE_DETECT_OFF[] = "off";
+const char CameraParameters::SCENE_DETECT_ON[] = "on";
+#endif
+ 
+// Formats for setPreviewFormat and setPictureFormat.
 const char CameraParameters::PIXEL_FORMAT_YUV422SP[] = "yuv422sp";
 const char CameraParameters::PIXEL_FORMAT_YUV420SP[] = "yuv420sp";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_YUV420SP_ADRENO[] = "yuv420sp-adreno";
+#endif
 const char CameraParameters::PIXEL_FORMAT_YUV422I[] = "yuv422i-yuyv";
 const char CameraParameters::PIXEL_FORMAT_YUV420P[]  = "yuv420p";
 const char CameraParameters::PIXEL_FORMAT_RGB565[] = "rgb565";
 const char CameraParameters::PIXEL_FORMAT_RGBA8888[] = "rgba8888";
 const char CameraParameters::PIXEL_FORMAT_JPEG[] = "jpeg";
 const char CameraParameters::PIXEL_FORMAT_BAYER_RGGB[] = "bayer-rggb";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_RAW[] = "raw";
+const char CameraParameters::PIXEL_FORMAT_YV12[] = "yuv420p";
+const char CameraParameters::PIXEL_FORMAT_NV12[] = "nv12";
+#endif
 
 // Values for focus mode settings.
 const char CameraParameters::FOCUS_MODE_AUTO[] = "auto";
@@ -164,6 +276,159 @@ const char CameraParameters::FOCUS_MODE_FIXED[] = "fixed";
 const char CameraParameters::FOCUS_MODE_EDOF[] = "edof";
 const char CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO[] = "continuous-video";
 const char CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE[] = "continuous-picture";
+#ifdef QCOM_HARDWARE
+const char CameraParameters::FOCUS_MODE_CONTINUOUS_CAMERA[] = "continuous-camera";
+const char CameraParameters::FOCUS_MODE_NORMAL[] = "normal";
+
+
+const char CameraParameters::KEY_SKIN_TONE_ENHANCEMENT[] = "skinToneEnhancement";
+const char CameraParameters::KEY_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES[] = "skinToneEnhancement-values";
+
+// Values for ISO Settings
+const char CameraParameters::ISO_AUTO[] = "auto";
+const char CameraParameters::ISO_HJR[] = "ISO_HJR";
+const char CameraParameters::ISO_100[] = "ISO100";
+const char CameraParameters::ISO_200[] = "ISO200";
+const char CameraParameters::ISO_400[] = "ISO400";
+const char CameraParameters::ISO_800[] = "ISO800";
+const char CameraParameters::ISO_1600[] = "ISO1600";
+
+ //Values for Lens Shading
+const char CameraParameters::LENSSHADE_ENABLE[] = "enable";
+const char CameraParameters::LENSSHADE_DISABLE[] = "disable";
+
+// Values for auto exposure settings.
+#ifdef SAMSUNG_CAMERA_QCOM
+const char CameraParameters::AUTO_EXPOSURE_FRAME_AVG[] = "matrix";
+const char CameraParameters::AUTO_EXPOSURE_CENTER_WEIGHTED[] = "center";
+const char CameraParameters::AUTO_EXPOSURE_SPOT_METERING[] = "spot";
+#else
+const char CameraParameters::AUTO_EXPOSURE_FRAME_AVG[] = "frame-average";
+const char CameraParameters::AUTO_EXPOSURE_CENTER_WEIGHTED[] = "center-weighted";
+const char CameraParameters::AUTO_EXPOSURE_SPOT_METERING[] = "spot-metering";
+#endif
+
+const char CameraParameters::KEY_GPS_LATITUDE_REF[] = "gps-latitude-ref";
+const char CameraParameters::KEY_GPS_LONGITUDE_REF[] = "gps-longitude-ref";
+const char CameraParameters::KEY_GPS_ALTITUDE_REF[] = "gps-altitude-ref";
+const char CameraParameters::KEY_GPS_STATUS[] = "gps-status";
+const char CameraParameters::KEY_EXIF_DATETIME[] = "exif-datetime";
+
+const char CameraParameters::KEY_HISTOGRAM[] = "histogram";
+const char CameraParameters::KEY_SUPPORTED_HISTOGRAM_MODES[] = "histogram-values";
+//Values for Histogram Shading
+const char CameraParameters::HISTOGRAM_ENABLE[] = "enable";
+const char CameraParameters::HISTOGRAM_DISABLE[] = "disable";
+
+//Values for Skin Tone Enhancement Modes
+const char CameraParameters::SKIN_TONE_ENHANCEMENT_ENABLE[] = "enable";
+const char CameraParameters::SKIN_TONE_ENHANCEMENT_DISABLE[] = "disable";
+
+const char CameraParameters::KEY_SHARPNESS[] = "sharpness";
+#if defined(QCOM_HARDWARE) && !defined(SAMSUNG_CAMERA_QCOM)
+const char CameraParameters::KEY_MAX_SHARPNESS[] = "sharpness-max";
+const char CameraParameters::KEY_MIN_SHARPNESS[] = "sharpness-min";
+#else
+const char CameraParameters::KEY_MAX_SHARPNESS[] = "max-sharpness";
+#endif
+const char CameraParameters::KEY_CONTRAST[] = "contrast";
+#if defined(QCOM_HARDWARE) && !defined(SAMSUNG_CAMERA_QCOM)
+const char CameraParameters::KEY_MAX_CONTRAST[] = "contrast-max";
+const char CameraParameters::KEY_MIN_CONTRAST[] = "contrast-min";
+#else
+const char CameraParameters::KEY_MAX_CONTRAST[] = "max-contrast";
+#endif
+const char CameraParameters::KEY_SATURATION[] = "saturation";
+#if defined(QCOM_HARDWARE) && !defined(SAMSUNG_CAMERA_QCOM)
+const char CameraParameters::KEY_MAX_SATURATION[] = "saturation-max";
+const char CameraParameters::KEY_MIN_SATURATION[] = "saturation-min";
+#else
+const char CameraParameters::KEY_MAX_SATURATION[] = "max-saturation";
+#endif
+
+//Values for DENOISE
+const char CameraParameters::DENOISE_OFF[] = "denoise-off";
+const char CameraParameters::DENOISE_ON[] = "denoise-on";
+// Values for selectable zone af Settings
+const char CameraParameters::SELECTABLE_ZONE_AF_AUTO[] = "auto";
+const char CameraParameters::SELECTABLE_ZONE_AF_SPOT_METERING[] = "spot-metering";
+const char CameraParameters::SELECTABLE_ZONE_AF_CENTER_WEIGHTED[] = "center-weighted";
+const char CameraParameters::SELECTABLE_ZONE_AF_FRAME_AVERAGE[] = "frame-average";
+
+// Values for Face Detection settings.
+const char CameraParameters::FACE_DETECTION_OFF[] = "off";
+const char CameraParameters::FACE_DETECTION_ON[] = "on";
+
+// Values for MCE settings.
+const char CameraParameters::MCE_ENABLE[] = "enable";
+const char CameraParameters::MCE_DISABLE[] = "disable";
+
+// Values for HFR settings.
+const char CameraParameters::VIDEO_HFR_OFF[] = "off";
+const char CameraParameters::VIDEO_HFR_2X[] = "60";
+const char CameraParameters::VIDEO_HFR_3X[] = "90";
+const char CameraParameters::VIDEO_HFR_4X[] = "120";
+
+// Values for Redeye Reduction settings.
+const char CameraParameters::REDEYE_REDUCTION_ENABLE[] = "enable";
+const char CameraParameters::REDEYE_REDUCTION_DISABLE[] = "disable";
+// Values for HDR settings.
+const char CameraParameters::HDR_ENABLE[] = "enable";
+const char CameraParameters::HDR_DISABLE[] = "disable";
+
+// Values for ZSL settings.
+const char CameraParameters::ZSL_OFF[] = "off";
+const char CameraParameters::ZSL_ON[] = "on";
+
+// Values for HDR Bracketing settings.
+const char CameraParameters::AE_BRACKET_HDR_OFF[] = "Off";
+const char CameraParameters::AE_BRACKET_HDR[] = "HDR";
+const char CameraParameters::AE_BRACKET[] = "AE-Bracket";
+
+#ifdef SAMSUNG_CAMERA_QCOM
+const char CameraParameters::FOCUS_MODE_FACEDETECT[] = "facedetect";
+const char CameraParameters::FOCUS_MODE_TOUCHAF[] = "touchaf";
+const char CameraParameters::ISO_50[] = "ISO50";
+// const char CameraParameters::KEY_ANTI_SHAKE_MODE[] = "antishake";
+const char CameraParameters::KEY_AUTO_CONTRAST[] = "auto-contrast";
+const char CameraParameters::KEY_BEAUTY_MODE[] = "beauty";
+const char CameraParameters::KEY_BLUR_MODE[] = "blur";
+const char CameraParameters::KEY_VINTAGE_MODE[] = "vintagemode";
+const char CameraParameters::KEY_WDR_MODE[] = "wdr";
+const char CameraParameters::VINTAGE_MODE_BNW[] = "bnw";
+const char CameraParameters::VINTAGE_MODE_COOL[] = "cool";
+const char CameraParameters::VINTAGE_MODE_NORMAL[] = "normal";
+const char CameraParameters::VINTAGE_MODE_OFF[] = "off";
+const char CameraParameters::VINTAGE_MODE_WARM[] = "warm";
+const char CameraParameters::SCENE_MODE_BACKLIGHT[] = "back-light";
+const char CameraParameters::SCENE_MODE_DAWN[] = "dusk-dawn";
+const char CameraParameters::SCENE_MODE_DUSKDAWN[] = "dusk-dawn";
+const char CameraParameters::SCENE_MODE_FALL[] = "fall-color";
+const char CameraParameters::SCENE_MODE_FALL_COLOR[] = "fall-color";
+const char CameraParameters::SCENE_MODE_FLOWERS[] = "flowers";
+const char CameraParameters::SCENE_MODE_TEXT[] = "text";
+#endif
+
+static const char* portrait = "portrait";
+static const char* landscape = "landscape";
+
+int CameraParameters::getOrientation() const
+{
+    const char* orientation = get("orientation");
+    if (orientation && !strcmp(orientation, portrait))
+        return CAMERA_ORIENTATION_PORTRAIT;
+    return CAMERA_ORIENTATION_LANDSCAPE;
+}
+void CameraParameters::setOrientation(int orientation)
+{
+    if (orientation == CAMERA_ORIENTATION_PORTRAIT) {
+        set("orientation", portrait);
+    } else {
+         set("orientation", landscape);
+    }
+}
+#endif
+
 
 CameraParameters::CameraParameters()
                 : mMap()
@@ -231,12 +496,12 @@ void CameraParameters::set(const char *key, const char *value)
 {
     // XXX i think i can do this with strspn()
     if (strchr(key, '=') || strchr(key, ';')) {
-        //XXX LOGE("Key \"%s\"contains invalid character (= or ;)", key);
+        //XXX LOGD("Key \"%s\"contains invalid character (= or ;)", key);
         return;
     }
 
     if (strchr(value, '=') || strchr(key, ';')) {
-        //XXX LOGE("Value \"%s\"contains invalid character (= or ;)", value);
+        //XXX LOGD("Value \"%s\"contains invalid character (= or ;)", value);
         return;
     }
 
@@ -246,7 +511,7 @@ void CameraParameters::set(const char *key, const char *value)
 void CameraParameters::set(const char *key, int value)
 {
     char str[16];
-    sprintf(str, "%d", value);
+    snprintf(str, sizeof(str), "%d", value);
     set(key, str);
 }
 
@@ -294,7 +559,7 @@ static int parse_pair(const char *str, int *first, int *second, char delim,
     int w = (int)strtol(str, &end, 10);
     // If a delimeter does not immediately follow, give up.
     if (*end != delim) {
-        LOGE("Cannot find delimeter (%c) in str=%s", delim, str);
+        LOGD("Cannot find delimeter (%c) in str=%s", delim, str);
         return -1;
     }
 
@@ -311,6 +576,33 @@ static int parse_pair(const char *str, int *first, int *second, char delim,
     return 0;
 }
 
+// Parse string like "(1, 2, 3, 4, ..., N)"
+// num is pointer to an allocated array of size N
+static int parseNDimVector(const char *str, int *num, int N, char delim = ',')
+{
+    char *start, *end;
+    if(num == NULL) {
+        LOGD("Invalid output array (num == NULL)");
+        return -1;
+    }
+    //check if string starts and ends with parantheses
+    if(str[0] != '(' || str[strlen(str)-1] != ')') {
+        LOGD("Invalid format of string %s, valid format is (n1, n2, n3, n4 ...)", str);
+        return -1;
+    }
+    start = (char*) str;
+    start++;
+    for(int i=0; i<N; i++) {
+        *(num+i) = (int) strtol(start, &end, 10);
+        if(*end != delim && i < N-1) {
+            LOGD("Cannot find delimeter '%c' in string \"%s\". end = %c", delim, str, *end);
+            return -1;
+        }
+        start = end+1;
+    }
+    return 0;
+}
+
 static void parseSizesList(const char *sizesStr, Vector<Size> &sizes)
 {
     if (sizesStr == 0) {
@@ -324,7 +616,7 @@ static void parseSizesList(const char *sizesStr, Vector<Size> &sizes)
         int success = parse_pair(sizeStartPtr, &width, &height, 'x',
                                  &sizeStartPtr);
         if (success == -1 || (*sizeStartPtr != ',' && *sizeStartPtr != '\0')) {
-            LOGE("Picture sizes string \"%s\" contains invalid character.", sizesStr);
+            LOGD("Picture sizes string \"%s\" contains invalid character.", sizesStr);
             return;
         }
         sizes.push(Size(width, height));
@@ -339,7 +631,7 @@ static void parseSizesList(const char *sizesStr, Vector<Size> &sizes)
 void CameraParameters::setPreviewSize(int width, int height)
 {
     char str[32];
-    sprintf(str, "%dx%d", width, height);
+    snprintf(str, sizeof(str), "%dx%d", width, height);
     set(KEY_PREVIEW_SIZE, str);
 }
 
@@ -366,6 +658,26 @@ void CameraParameters::getSupportedPreviewSizes(Vector<Size> &sizes) const
     parseSizesList(previewSizesStr, sizes);
 }
 
+#ifdef QCOM_HARDWARE
+void CameraParameters::getSupportedHfrSizes(Vector<Size> &sizes) const
+{
+    const char *hfrSizesStr = get(KEY_SUPPORTED_HFR_SIZES);
+    parseSizesList(hfrSizesStr, sizes);
+}
+
+void CameraParameters::setPreviewFpsRange(int minFPS, int maxFPS)
+{
+    char str[32];
+    snprintf(str, sizeof(str), "%d,%d",minFPS,maxFPS);
+    set(KEY_PREVIEW_FPS_RANGE,str);
+}
+
+void CameraParameters::setPostviewSize(int width, int height)
+{
+    // dummy
+}
+#endif
+
 void CameraParameters::setVideoSize(int width, int height)
 {
     char str[32];
@@ -405,6 +717,18 @@ void CameraParameters::getPreviewFpsRange(int *min_fps, int *max_fps) const
     parse_pair(p, min_fps, max_fps, ',');
 }
 
+#ifdef QCOM_HARDWARE
+void CameraParameters::setPreviewFrameRateMode(const char *mode)
+{
+    set(KEY_PREVIEW_FRAME_RATE_MODE, mode);
+}
+
+const char *CameraParameters::getPreviewFrameRateMode() const
+{
+    return get(KEY_PREVIEW_FRAME_RATE_MODE);
+}
+#endif
+
 void CameraParameters::setPreviewFormat(const char *format)
 {
     set(KEY_PREVIEW_FORMAT, format);
@@ -458,6 +782,71 @@ void CameraParameters::dump() const
     }
 }
 
+#ifdef QCOM_HARDWARE
+void CameraParameters::setTouchIndexAec(int x, int y)
+{
+    char str[32];
+    snprintf(str, sizeof(str), "%dx%d", x, y);
+    set(KEY_TOUCH_INDEX_AEC, str);
+}
+
+void CameraParameters::getTouchIndexAec(int *x, int *y) const
+{
+    *x = -1;
+    *y = -1;
+
+    // Get the current string, if it doesn't exist, leave the -1x-1
+    const char *p = get(KEY_TOUCH_INDEX_AEC);
+    if (p == 0)
+        return;
+
+    int tempX, tempY;
+    if (parse_pair(p, &tempX, &tempY, 'x') == 0) {
+        *x = tempX;
+        *y = tempY;
+    }
+}
+
+void CameraParameters::setTouchIndexAf(int x, int y)
+{
+    char str[32];
+    snprintf(str, sizeof(str), "%dx%d", x, y);
+    set(KEY_TOUCH_INDEX_AF, str);
+}
+
+void CameraParameters::getMeteringAreaCenter(int *x, int *y) const
+{
+    //Default invalid values
+    *x = -2000;
+    *y = -2000;
+
+    const char *p = get(KEY_METERING_AREAS);
+    if(p != NULL) {
+        int arr[5] = {-2000, -2000, -2000, -2000, 0};
+        parseNDimVector(p, arr, 5); //p = "(x1, y1, x2, y2, weight)"
+        *x = (arr[0] + arr[2])/2; //center_x = (x1+x2)/2
+        *y = (arr[1] + arr[3])/2; //center_y = (y1+y2)/2
+    }
+}
+
+void CameraParameters::getTouchIndexAf(int *x, int *y) const
+{
+    *x = -1;
+    *y = -1;
+
+    // Get the current string, if it doesn't exist, leave the -1x-1
+    const char *p = get(KEY_TOUCH_INDEX_AF);
+    if (p == 0)
+        return;
+
+    int tempX, tempY;
+    if (parse_pair(p, &tempX, &tempY, 'x') == 0) {
+        *x = tempX;
+        *y = tempY;
+    }
+}
+#endif
+
 status_t CameraParameters::dump(int fd, const Vector<String16>& args) const
 {
     const size_t SIZE = 256;
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 9767568..1d6e7cc 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -27,13 +27,27 @@ LOCAL_SHARED_LIBRARIES := \
 	libhardware_legacy \
 	libui \
 	libEGL \
-	libGLESv2 \
+	libGLESv2
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+LOCAL_SHARED_LIBRARIES += \
+        libQcomUI
+LOCAL_C_INCLUDES := hardware/qcom/display/libqcomui
+ifeq ($(TARGET_QCOM_HDMI_OUT),true)
+LOCAL_CFLAGS += -DQCOM_HDMI_OUT
+endif
+endif
 
 LOCAL_MODULE:= libgui
 
 ifeq ($(TARGET_BOARD_PLATFORM), tegra)
-	LOCAL_CFLAGS += -DALLOW_DEQUEUE_CURRENT_BUFFER
+ifneq ($(BOARD_NO_ALLOW_DEQUEUE_CURRENT_BUFFER), true)
+ 	LOCAL_CFLAGS += -DALLOW_DEQUEUE_CURRENT_BUFFER
+ endif
+endif
+
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
 endif
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/libs/gui/IGraphicBufferAlloc.cpp b/libs/gui/IGraphicBufferAlloc.cpp
index 30f8d00..8c0c58f 100644
--- a/libs/gui/IGraphicBufferAlloc.cpp
+++ b/libs/gui/IGraphicBufferAlloc.cpp
@@ -32,6 +32,11 @@ namespace android {
 
 enum {
     CREATE_GRAPHIC_BUFFER = IBinder::FIRST_CALL_TRANSACTION,
+#ifdef QCOM_HARDWARE
+    FREE_ALL_GRAPHIC_BUFFERS_EXCEPT,
+    FREE_GRAPHIC_BUFFER_AT_INDEX,
+    SET_GRAPHIC_BUFFER_SIZE,
+#endif
 };
 
 class BpGraphicBufferAlloc : public BpInterface<IGraphicBufferAlloc>
@@ -63,6 +68,32 @@ public:
         *error = result;
         return graphicBuffer;
     }
+
+#ifdef QCOM_HARDWARE
+    virtual void freeAllGraphicBuffersExcept(int bufIdx) {
+        Parcel data, reply;
+        data.writeInterfaceToken(
+                IGraphicBufferAlloc::getInterfaceDescriptor());
+        data.writeInt32(bufIdx);
+        remote()->transact(FREE_ALL_GRAPHIC_BUFFERS_EXCEPT, data, &reply);
+    }
+
+    virtual void freeGraphicBufferAtIndex(int bufIdx) {
+        Parcel data, reply;
+        data.writeInterfaceToken(
+                IGraphicBufferAlloc::getInterfaceDescriptor());
+        data.writeInt32(bufIdx);
+        remote()->transact(FREE_GRAPHIC_BUFFER_AT_INDEX, data, &reply);
+    }
+
+    virtual void setGraphicBufferSize(int size) {
+        Parcel data, reply;
+        data.writeInterfaceToken(
+                IGraphicBufferAlloc::getInterfaceDescriptor());
+        data.writeInt32(size);
+        remote()->transact(SET_GRAPHIC_BUFFER_SIZE, data, &reply);
+    }
+#endif
 };
 
 IMPLEMENT_META_INTERFACE(GraphicBufferAlloc, "android.ui.IGraphicBufferAlloc");
@@ -108,6 +139,26 @@ status_t BnGraphicBufferAlloc::onTransact(
             }
             return NO_ERROR;
         } break;
+#ifdef QCOM_HARDWARE
+        case FREE_ALL_GRAPHIC_BUFFERS_EXCEPT: {
+            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);
+            int bufIdx = data.readInt32();
+            freeAllGraphicBuffersExcept(bufIdx);
+            return NO_ERROR;
+        } break;
+        case FREE_GRAPHIC_BUFFER_AT_INDEX: {
+            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);
+            int bufIdx = data.readInt32();
+            freeGraphicBufferAtIndex(bufIdx);
+            return NO_ERROR;
+        } break;
+        case SET_GRAPHIC_BUFFER_SIZE: {
+            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);
+            int size = data.readInt32();
+            setGraphicBufferSize(size);
+            return NO_ERROR;
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/libs/gui/ISurfaceTexture.cpp b/libs/gui/ISurfaceTexture.cpp
index d2e5627..860e54c 100644
--- a/libs/gui/ISurfaceTexture.cpp
+++ b/libs/gui/ISurfaceTexture.cpp
@@ -43,6 +43,9 @@ enum {
     CONNECT,
     DISCONNECT,
     SET_SCALING_MODE,
+#ifdef QCOM_HARDWARE
+    PERFORM_QCOM_OPERATION,
+#endif
 };
 
 
@@ -216,6 +219,24 @@ public:
         result = reply.readInt32();
         return result;
     }
+
+#ifdef QCOM_HARDWARE
+    virtual status_t performQcomOperation(int operation, int arg1, int arg2, int arg3) {
+        Parcel data, reply;
+        data.writeInterfaceToken(ISurfaceTexture::getInterfaceDescriptor());
+
+        data.writeInt32(operation);
+        data.writeInt32(arg1);
+        data.writeInt32(arg2);
+        data.writeInt32(arg3);
+        status_t result =remote()->transact(PERFORM_QCOM_OPERATION, data, &reply);
+        if (result != NO_ERROR) {
+            return result;
+        }
+        result = reply.readInt32();
+        return result;
+    }
+#endif
 };
 
 IMPLEMENT_META_INTERFACE(SurfaceTexture, "android.gui.SurfaceTexture");
@@ -336,6 +357,18 @@ status_t BnSurfaceTexture::onTransact(
             reply->writeInt32(res);
             return NO_ERROR;
         } break;
+#ifdef QCOM_HARDWARE
+        case PERFORM_QCOM_OPERATION: {
+            CHECK_INTERFACE(ISurfaceTexture, data, reply);
+            int operation = data.readInt32();
+            int arg1 = data.readInt32();
+            int arg2 = data.readInt32();
+            int arg3 = data.readInt32();
+            status_t res = performQcomOperation(operation, arg1, arg2, arg3);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
+#endif
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/libs/gui/Surface.cpp b/libs/gui/Surface.cpp
index ff45fa3..ab743f8 100644
--- a/libs/gui/Surface.cpp
+++ b/libs/gui/Surface.cpp
@@ -38,6 +38,9 @@
 #include <surfaceflinger/ISurfaceComposer.h>
 #include <surfaceflinger/Surface.h>
 #include <surfaceflinger/SurfaceComposerClient.h>
+#ifdef QCOM_HARDWARE
+#include <qcom_ui.h>
+#endif
 
 namespace android {
 
@@ -382,6 +385,11 @@ status_t Surface::lock(SurfaceInfo* other, Region* inOutDirtyRegion) {
 status_t Surface::unlockAndPost() {
     return SurfaceTextureClient::unlockAndPost();
 }
+#ifdef QCOM_HARDWARE
+status_t Surface::setStereoscopic3DFormat(int format) {
+    return SurfaceTextureClient::performQcomOperation( NATIVE_WINDOW_SET_S3D_FORMAT, format, 0, 0);
+}
+#endif
 
 // ----------------------------------------------------------------------------
 }; // namespace android
diff --git a/libs/gui/SurfaceTexture.cpp b/libs/gui/SurfaceTexture.cpp
index 4772189..6a26e6a 100644
--- a/libs/gui/SurfaceTexture.cpp
+++ b/libs/gui/SurfaceTexture.cpp
@@ -36,6 +36,10 @@
 #include <utils/Log.h>
 #include <utils/String8.h>
 
+#ifdef QCOM_HARDWARE
+#include <qcom_ui.h>
+#endif
+
 // This compile option causes SurfaceTexture to return the buffer that is currently
 // attached to the GL texture from dequeueBuffer when no other buffers are
 // available.  It requires the drivers (Gralloc, GL, OMX IL, and Camera) to do
@@ -138,6 +142,9 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mUseFenceSync(false),
 #endif
     mTexTarget(texTarget),
+#ifdef QCOM_HARDWARE
+    mS3DFormat(0),
+#endif
     mFrameCounter(0) {
     // Choose a name using the PID and a process-unique ID.
     mName = String8::format("unnamed-%d-%d", getpid(), createProcessUniqueId());
@@ -148,6 +155,11 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mNextCrop.makeInvalid();
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
+#ifdef QCOM_HARDWARE
+    mNextBufferInfo.width = 0;
+    mNextBufferInfo.height = 0;
+    mNextBufferInfo.format = 0;
+#endif
 }
 
 SurfaceTexture::~SurfaceTexture() {
@@ -293,6 +305,9 @@ status_t SurfaceTexture::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
         int foundSync = -1;
         int dequeuedCount = 0;
         bool tryAgain = true;
+#ifdef MISSING_GRALLOC_BUFFERS
+        int dequeueRetries = 5;
+#endif
         while (tryAgain) {
             if (mAbandoned) {
                 ST_LOGE("dequeueBuffer: SurfaceTexture has been abandoned!");
@@ -382,8 +397,22 @@ status_t SurfaceTexture::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
             // clients are not allowed to dequeue more than one buffer
             // if they didn't set a buffer count.
             if (!mClientBufferCount && dequeuedCount) {
+#ifdef MISSING_GRALLOC_BUFFERS
+                if (--dequeueRetries) {
+                    LOGD("SurfaceTexture::dequeue: Not allowed to dequeue more "
+                            "than a buffer SLEEPING\n");
+                    usleep(10000);
+                } else {
+                    mClientBufferCount = mServerBufferCount;
+                    LOGD("SurfaceTexture::dequeue: Not allowed to dequeue more "
+                            "than a buffer RETRY mBufferCount:%d mServerBufferCount:%d\n",
+                            mBufferCount, mServerBufferCount);
+                }
+                continue;
+#else
                 ST_LOGE("dequeueBuffer: can't dequeue multiple buffers without "
                         "setting the buffer count");
+#endif
                 return -EINVAL;
             }
 
@@ -396,6 +425,15 @@ status_t SurfaceTexture::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
                 // than allowed.
                 const int avail = mBufferCount - (dequeuedCount+1);
                 if (avail < (MIN_UNDEQUEUED_BUFFERS-int(mSynchronousMode))) {
+#ifdef MISSING_GRALLOC_BUFFERS
+                    if (mClientBufferCount != 0) {
+                        mBufferCount++;
+                        mClientBufferCount = mServerBufferCount = mBufferCount;
+                        LOGD("SurfaceTexture::dequeuebuffer: MIN EXCEEDED "
+                                "mBuffer:%d bumped\n", mBufferCount);
+                        continue;
+                    }
+#endif
                     ST_LOGE("dequeueBuffer: MIN_UNDEQUEUED_BUFFERS=%d exceeded "
                             "(dequeued=%d)",
                             MIN_UNDEQUEUED_BUFFERS-int(mSynchronousMode),
@@ -444,12 +482,35 @@ status_t SurfaceTexture::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
         mSlots[buf].mBufferState = BufferSlot::DEQUEUED;
 
         const sp<GraphicBuffer>& buffer(mSlots[buf].mGraphicBuffer);
-        if ((buffer == NULL) ||
-            (uint32_t(buffer->width)  != w) ||
-            (uint32_t(buffer->height) != h) ||
-            (uint32_t(buffer->format) != format) ||
-            ((uint32_t(buffer->usage) & usage) != usage))
-        {
+#ifdef QCOM_HARDWARE
+	qBufGeometry currentGeometry;
+	if (buffer != NULL)
+	   currentGeometry.set(buffer->width, buffer->height, buffer->format);
+ 	else
+	   currentGeometry.set(0, 0, 0);
+ 
+	qBufGeometry requiredGeometry;
+	requiredGeometry.set(w, h, format);
+ 
+	qBufGeometry updatedGeometry;
+	updatedGeometry.set(mNextBufferInfo.width, mNextBufferInfo.height,
+				mNextBufferInfo.format);
+#endif
+	if ((buffer == NULL) ||
+#ifdef QCOM_HARDWARE
+	   needNewBuffer(currentGeometry, requiredGeometry, updatedGeometry) ||
+#else
+	   (uint32_t(buffer->width)  != w) ||
+	   (uint32_t(buffer->height) != h) ||
+	   (uint32_t(buffer->format) != format) ||
+#endif
+	   ((uint32_t(buffer->usage) & usage) != usage))
+	{
+#ifdef QCOM_HARDWARE
+            if (buffer != NULL) {
+                mGraphicBufferAlloc->freeGraphicBufferAtIndex(buf);
+            }
+#endif
             usage |= GraphicBuffer::USAGE_HW_TEXTURE;
             status_t error;
             sp<GraphicBuffer> graphicBuffer(
@@ -463,6 +524,7 @@ status_t SurfaceTexture::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
             if (updateFormat) {
                 mPixelFormat = format;
             }
+
             mSlots[buf].mGraphicBuffer = graphicBuffer;
             mSlots[buf].mRequestBufferCalled = false;
             mSlots[buf].mFence = EGL_NO_SYNC_KHR;
@@ -597,6 +659,16 @@ status_t SurfaceTexture::queueBuffer(int buf, int64_t timestamp,
         mFrameCounter++;
         mSlots[buf].mFrameNumber = mFrameCounter;
 
+#ifdef QCOM_HARDWARE
+        // Update the buffer Geometry if required
+        qBufGeometry updatedGeometry;
+        updatedGeometry.set(mNextBufferInfo.width,
+                            mNextBufferInfo.height, mNextBufferInfo.format);
+        updateBufferGeometry(mSlots[buf].mGraphicBuffer, updatedGeometry);
+        updateBufferS3DFormat(mSlots[buf].mGraphicBuffer, mS3DFormat);
+        sp<GraphicBuffer> buffer = mSlots[buf].mGraphicBuffer;
+#endif
+
         mDequeueCondition.signal();
 
         *outWidth = mDefaultWidth;
@@ -679,6 +751,13 @@ status_t SurfaceTexture::connect(int api,
                         mConnectedApi, api);
                 err = -EINVAL;
             } else {
+#ifdef QCOM_HARDWARE
+                memcpy(mCurrentTransformMatrix, mtxIdentity,
+                        sizeof(mCurrentTransformMatrix));
+                mNextBufferInfo.width = 0;
+                mNextBufferInfo.height = 0;
+                mNextBufferInfo.format = 0;
+#endif
                 mConnectedApi = api;
                 *outWidth = mDefaultWidth;
                 *outHeight = mDefaultHeight;
@@ -729,6 +808,30 @@ status_t SurfaceTexture::disconnect(int api) {
     return err;
 }
 
+#ifdef QCOM_HARDWARE
+status_t SurfaceTexture::performQcomOperation(int operation, int arg1, int arg2, int arg3)
+{
+    ST_LOGV("SurfaceTexture::performQcomOperation operation=%d", operation);
+
+    switch(operation) {
+        case NATIVE_WINDOW_SET_BUFFERS_SIZE: {
+            int size = arg1;
+            mGraphicBufferAlloc->setGraphicBufferSize(size);
+        } break;
+        case NATIVE_WINDOW_UPDATE_BUFFERS_GEOMETRY: {
+            mNextBufferInfo.width = arg1;
+            mNextBufferInfo.height = arg2;
+            mNextBufferInfo.format = arg3;
+        } break;
+        case NATIVE_WINDOW_SET_S3D_FORMAT:
+            mS3DFormat = arg1;
+            break;
+        default: return BAD_VALUE;
+     };
+     return OK;
+}
+#endif
+
 status_t SurfaceTexture::setScalingMode(int mode) {
     ST_LOGV("setScalingMode: mode=%d", mode);
 
@@ -746,7 +849,7 @@ status_t SurfaceTexture::setScalingMode(int mode) {
     return OK;
 }
 
-status_t SurfaceTexture::updateTexImage() {
+status_t SurfaceTexture::updateTexImage(bool isComposition) {
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
 
@@ -764,6 +867,9 @@ status_t SurfaceTexture::updateTexImage() {
         // Update the GL texture object.
         EGLImageKHR image = mSlots[buf].mEglImage;
         EGLDisplay dpy = eglGetCurrentDisplay();
+#ifdef QCOM_HARDWARE
+        if (isGPUSupportedFormat(mSlots[buf].mGraphicBuffer->format)) {
+#endif
         if (image == EGL_NO_IMAGE_KHR) {
             if (mSlots[buf].mGraphicBuffer == 0) {
                 ST_LOGE("buffer at slot %d is null", buf);
@@ -772,6 +878,18 @@ status_t SurfaceTexture::updateTexImage() {
             image = createImage(dpy, mSlots[buf].mGraphicBuffer);
             mSlots[buf].mEglImage = image;
             mSlots[buf].mEglDisplay = dpy;
+
+#ifdef DECIDE_TEXTURE_TARGET
+            // GPU is not efficient in handling GL_TEXTURE_EXTERNAL_OES
+            // texture target. Depending on the image format, decide,
+            // the texture target to be used
+
+            if (isComposition) {
+                mTexTarget =
+                   decideTextureTarget (mSlots[buf].mGraphicBuffer->format);
+            }
+#endif
+
             if (image == EGL_NO_IMAGE_KHR) {
                 // NOTE: if dpy was invalid, createImage() is guaranteed to
                 // fail. so we'd end up here.
@@ -796,7 +914,9 @@ status_t SurfaceTexture::updateTexImage() {
         if (failed) {
             return -EINVAL;
         }
-
+#ifdef QCOM_HARDWARE
+        }
+#endif
         if (mCurrentTexture != INVALID_BUFFER_SLOT) {
             if (mUseFenceSync) {
                 EGLSyncKHR fence = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR,
@@ -996,6 +1116,9 @@ void SurfaceTexture::freeAllBuffersLocked() {
     for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
         freeBufferLocked(i);
     }
+#ifdef QCOM_HARDWARE
+    mGraphicBufferAlloc->freeAllGraphicBuffersExcept(-1);
+#endif
 }
 
 void SurfaceTexture::freeAllBuffersExceptHeadLocked() {
@@ -1012,6 +1135,9 @@ void SurfaceTexture::freeAllBuffersExceptHeadLocked() {
             freeBufferLocked(i);
         }
     }
+#ifdef QCOM_HARDWARE
+    mGraphicBufferAlloc->freeAllGraphicBuffersExcept(head);
+#endif
 }
 
 status_t SurfaceTexture::drainQueueLocked() {
@@ -1106,6 +1232,11 @@ int SurfaceTexture::query(int what, int* outValue)
         value = mSynchronousMode ?
                 (MIN_UNDEQUEUED_BUFFERS-1) : MIN_UNDEQUEUED_BUFFERS;
         break;
+#ifdef QCOM_HARDWARE
+    case NATIVE_WINDOW_NUM_BUFFERS:
+        value = mBufferCount;
+        break;
+#endif
     default:
         return BAD_VALUE;
     }
diff --git a/libs/gui/SurfaceTextureClient.cpp b/libs/gui/SurfaceTextureClient.cpp
index 48070d6..06bd82d 100644
--- a/libs/gui/SurfaceTextureClient.cpp
+++ b/libs/gui/SurfaceTextureClient.cpp
@@ -23,6 +23,10 @@
 
 #include <utils/Log.h>
 
+#ifdef QCOM_HARDWARE
+#include <qcom_ui.h>
+#endif
+
 namespace android {
 
 SurfaceTextureClient::SurfaceTextureClient(
@@ -59,6 +63,9 @@ void SurfaceTextureClient::init() {
     mReqHeight = 0;
     mReqFormat = 0;
     mReqUsage = 0;
+#ifdef QCOM_HARDWARE
+    mReqExtUsage = 0;
+#endif
     mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;
     mDefaultWidth = 0;
     mDefaultHeight = 0;
@@ -129,6 +136,11 @@ int SurfaceTextureClient::setSwapInterval(int interval) {
 
     if (interval > maxSwapInterval)
         interval = maxSwapInterval;
+        
+#ifdef EGL_ALWAYS_ASYNC
+    if (mReqUsage != 0)
+        interval = 0;
+#endif
 
     status_t res = mSurfaceTexture->setSynchronousMode(interval ? true : false);
 
@@ -265,8 +277,12 @@ int SurfaceTextureClient::query(int what, int* value) const {
                 *value = mDefaultHeight;
                 return NO_ERROR;
             case NATIVE_WINDOW_TRANSFORM_HINT:
+#ifdef QCOM_HARDWARE
+                return mSurfaceTexture->query(what, value);
+#else
                 *value = mTransformHint;
                 return NO_ERROR;
+#endif
         }
     }
     return mSurfaceTexture->query(what, value);
@@ -322,12 +338,35 @@ int SurfaceTextureClient::perform(int operation, va_list args)
         res = dispatchDisconnect(args);
         break;
     default:
+#ifdef QCOM_HARDWARE
+        res = dispatchPerformQcomOperation(operation, args);
+#else
         res = NAME_NOT_FOUND;
+#endif
         break;
     }
     return res;
 }
 
+#ifdef QCOM_HARDWARE
+int SurfaceTextureClient::dispatchPerformQcomOperation(int operation,
+                                                       va_list args) {
+    int num_args = getNumberOfArgsForOperation(operation);
+    if (-EINVAL == num_args) {
+        LOGE("%s: invalid arguments for operation (operation = 0x%x)",
+             __FUNCTION__, operation);
+        return -1;
+    }
+
+    LOGV("%s: num_args = %d", __FUNCTION__, num_args);
+    int arg[3] = {0, 0, 0};
+    for (int i =0; i < num_args; i++) {
+        arg[i] = va_arg(args, int);
+    }
+    return performQcomOperation(operation, arg[0], arg[1], arg[2]);
+}
+#endif
+
 int SurfaceTextureClient::dispatchConnect(va_list args) {
     int api = va_arg(args, int);
     return connect(api);
@@ -361,13 +400,29 @@ int SurfaceTextureClient::dispatchSetBuffersGeometry(va_list args) {
     if (err != 0) {
         return err;
     }
+#ifdef QCOM_HARDWARE
+    LOGV("Resetting the Buffer size to 0 after SET GEOMETRY");
+    err = performQcomOperation(NATIVE_WINDOW_SET_BUFFERS_SIZE, 0, 0, 0);
+    if (err != 0) {
+        return err;
+    }
+#endif
     return setBuffersFormat(f);
 }
 
 int SurfaceTextureClient::dispatchSetBuffersDimensions(va_list args) {
     int w = va_arg(args, int);
     int h = va_arg(args, int);
+#ifndef QCOM_HARDWARE
     return setBuffersDimensions(w, h);
+#else
+    int err = setBuffersDimensions(w, h);
+    if (err != 0) {
+        return err;
+    }
+    LOGV("Resetting the Buffer size to 0 after SET DIMENSIONS");
+    return performQcomOperation(NATIVE_WINDOW_SET_BUFFERS_SIZE, 0, 0, 0);
+#endif
 }
 
 int SurfaceTextureClient::dispatchSetBuffersFormat(va_list args) {
@@ -400,6 +455,15 @@ int SurfaceTextureClient::dispatchUnlockAndPost(va_list args) {
     return unlockAndPost();
 }
 
+#ifdef QCOM_HARDWARE
+int SurfaceTextureClient::performQcomOperation(int operation, int arg1,
+                                               int arg2, int arg3) {
+    LOGV("SurfaceTextureClient::performQcomOperation");
+    Mutex::Autolock lock(mMutex);
+    int err = mSurfaceTexture->performQcomOperation(operation, arg1, arg2, arg3);
+    return err;
+}
+#endif
 
 int SurfaceTextureClient::connect(int api) {
     LOGV("SurfaceTextureClient::connect");
@@ -433,7 +497,25 @@ int SurfaceTextureClient::setUsage(uint32_t reqUsage)
 {
     LOGV("SurfaceTextureClient::setUsage");
     Mutex::Autolock lock(mMutex);
+#ifdef QCOM_HARDWARE
+    if (reqUsage & GRALLOC_USAGE_EXTERNAL_ONLY) {
+        //Set explicitly, since reqUsage may have other values.
+        mReqExtUsage = GRALLOC_USAGE_EXTERNAL_ONLY;
+        //This flag is never independent. Always an add-on to
+        //GRALLOC_USAGE_EXTERNAL_ONLY
+        if(reqUsage & GRALLOC_USAGE_EXTERNAL_BLOCK) {
+            mReqExtUsage |= GRALLOC_USAGE_EXTERNAL_BLOCK;
+        }
+    }
+    // For most cases mReqExtUsage will be 0.
+    // reqUsage could come from app or driver. When it comes from app
+    // and subsequently from driver, the latter ends up overwriting
+    // the existing values. We cache certain values in mReqExtUsage
+    // to avoid being overwritten.
+    mReqUsage = reqUsage | mReqExtUsage;
+#else
     mReqUsage = reqUsage;
+#endif
     return OK;
 }
 
@@ -637,20 +719,46 @@ status_t SurfaceTextureClient::lock(
                     backBuffer->height == frontBuffer->height &&
                     backBuffer->format == frontBuffer->format);
 
+#ifdef QCOM_HARDWARE
+            int bufferCount;
+
+            mSurfaceTexture->query(NATIVE_WINDOW_NUM_BUFFERS, &bufferCount);
+            const int backBufferidx = getSlotFromBufferLocked(out);
+#endif
+
             if (canCopyBack) {
                 // copy the area that is invalid and not repainted this round
+#ifdef QCOM_HARDWARE
+                Region oldDirtyRegion;
+                for(int i = 0 ; i < bufferCount; i++ ) {
+                    if(i != backBufferidx  && !mOldDirtyRegion[i].isEmpty())
+                        oldDirtyRegion.orSelf(mOldDirtyRegion[i]);
+                }
+
+                const Region copyback(oldDirtyRegion.subtract(newDirtyRegion));
+#else
                 const Region copyback(mOldDirtyRegion.subtract(newDirtyRegion));
+#endif
                 if (!copyback.isEmpty())
                     copyBlt(backBuffer, frontBuffer, copyback);
             } else {
                 // if we can't copy-back anything, modify the user's dirty
                 // region to make sure they redraw the whole buffer
                 newDirtyRegion.set(bounds);
+#ifdef QCOM_HARDWARE
+                for(int i = 0 ; i < bufferCount; i++ ) {
+                     mOldDirtyRegion[i].clear();
+                }
+#endif
             }
 
             // keep track of the are of the buffer that is "clean"
             // (ie: that will be redrawn)
+#ifdef QCOM_HARDWARE
+            mOldDirtyRegion[backBufferidx] = newDirtyRegion;
+#else
             mOldDirtyRegion = newDirtyRegion;
+#endif
 
             if (inOutDirtyBounds) {
                 *inOutDirtyBounds = newDirtyRegion.getBounds();
diff --git a/libs/hwui/Android.mk b/libs/hwui/Android.mk
index 9bfc94c..40708f9 100644
--- a/libs/hwui/Android.mk
+++ b/libs/hwui/Android.mk
@@ -42,6 +42,7 @@ ifeq ($(USE_OPENGL_RENDERER),true)
 	LOCAL_CFLAGS += -fvisibility=hidden
 	LOCAL_MODULE_CLASS := SHARED_LIBRARIES
 	LOCAL_SHARED_LIBRARIES := libcutils libutils libGLESv2 libskia libui
+
 	LOCAL_MODULE := libhwui
 	LOCAL_MODULE_TAGS := optional
 	
diff --git a/libs/hwui/Caches.cpp b/libs/hwui/Caches.cpp
index f293cba..d0c84bb 100644
--- a/libs/hwui/Caches.cpp
+++ b/libs/hwui/Caches.cpp
@@ -20,6 +20,7 @@
 #include <utils/String8.h>
 
 #include "Caches.h"
+#include "DisplayListRenderer.h"
 #include "Properties.h"
 #include "LayerRenderer.h"
 
@@ -178,6 +179,13 @@ void Caches::clearGarbage() {
         LayerRenderer::destroyLayer(layer);
     }
     mLayerGarbage.clear();
+
+    count = mDisplayListGarbage.size();
+    for (size_t i = 0; i < count; i++) {
+        DisplayList* displayList = mDisplayListGarbage.itemAt(i);
+        delete displayList;
+    }
+    mDisplayListGarbage.clear();
 }
 
 void Caches::deleteLayerDeferred(Layer* layer) {
@@ -185,6 +193,11 @@ void Caches::deleteLayerDeferred(Layer* layer) {
     mLayerGarbage.push(layer);
 }
 
+void Caches::deleteDisplayListDeferred(DisplayList* displayList) {
+    Mutex::Autolock _l(mGarbageLock);
+    mDisplayListGarbage.push(displayList);
+}
+
 void Caches::flush(FlushMode mode) {
     FLUSH_LOGD("Flushing caches (mode %d)", mode);
 
diff --git a/libs/hwui/Caches.h b/libs/hwui/Caches.h
index 5e58a9e..5a8b84f 100644
--- a/libs/hwui/Caches.h
+++ b/libs/hwui/Caches.h
@@ -84,6 +84,8 @@ struct CacheLogger {
 // Caches
 ///////////////////////////////////////////////////////////////////////////////
 
+class DisplayList;
+
 class ANDROID_API Caches: public Singleton<Caches> {
     Caches();
 
@@ -99,6 +101,7 @@ class ANDROID_API Caches: public Singleton<Caches> {
 
     mutable Mutex mGarbageLock;
     Vector<Layer*> mLayerGarbage;
+    Vector<DisplayList*> mDisplayListGarbage;
 
 public:
     enum FlushMode {
@@ -144,6 +147,11 @@ public:
      */
     void deleteLayerDeferred(Layer* layer);
 
+    /*
+     * Can be used to delete a display list from a non EGL thread.
+     */
+    void deleteDisplayListDeferred(DisplayList* layer);
+
     /**
      * Binds the VBO used to render simple textured quads.
      */
diff --git a/libs/hwui/DisplayListRenderer.cpp b/libs/hwui/DisplayListRenderer.cpp
index 3372d1c..163df5b 100644
--- a/libs/hwui/DisplayListRenderer.cpp
+++ b/libs/hwui/DisplayListRenderer.cpp
@@ -96,6 +96,13 @@ DisplayList::~DisplayList() {
     clearResources();
 }
 
+void DisplayList::destroyDisplayListDeferred(DisplayList* displayList) {
+    if (displayList) {
+        DISPLAY_LIST_LOGD("Deferring display list destruction");
+        Caches::getInstance().deleteDisplayListDeferred(displayList);
+    }
+}
+
 void DisplayList::clearResources() {
     sk_free((void*) mReader.base());
 
diff --git a/libs/hwui/DisplayListRenderer.h b/libs/hwui/DisplayListRenderer.h
index ab475bf..3053eaa 100644
--- a/libs/hwui/DisplayListRenderer.h
+++ b/libs/hwui/DisplayListRenderer.h
@@ -107,16 +107,16 @@ public:
 
     static const char* OP_NAMES[];
 
-    void initFromDisplayListRenderer(const DisplayListRenderer& recorder, bool reusing = false);
-
     ANDROID_API size_t getSize();
+    ANDROID_API static void destroyDisplayListDeferred(DisplayList* displayList);
+    ANDROID_API static void outputLogBuffer(int fd);
+
+    void initFromDisplayListRenderer(const DisplayListRenderer& recorder, bool reusing = false);
 
     bool replay(OpenGLRenderer& renderer, Rect& dirty, uint32_t level = 0);
 
     void output(OpenGLRenderer& renderer, uint32_t level = 0);
 
-    ANDROID_API static void outputLogBuffer(int fd);
-
     void setRenderable(bool renderable) {
         mIsRenderable = renderable;
     }
diff --git a/libs/hwui/FontRenderer.cpp b/libs/hwui/FontRenderer.cpp
index 158f785..84de916 100644
--- a/libs/hwui/FontRenderer.cpp
+++ b/libs/hwui/FontRenderer.cpp
@@ -368,6 +368,10 @@ FontRenderer::~FontRenderer() {
         delete[] mTextTexture;
     }
 
+    if (mIndexBufferID) {
+        glDeleteBuffers(1, &mIndexBufferID);
+    }
+
     if (mTextureId) {
         glDeleteTextures(1, &mTextureId);
     }
diff --git a/libs/hwui/GradientCache.h b/libs/hwui/GradientCache.h
index 7339853..7e2c69a 100644
--- a/libs/hwui/GradientCache.h
+++ b/libs/hwui/GradientCache.h
@@ -19,6 +19,7 @@
 
 #include <SkShader.h>
 
+#include <utils/threads.h>
 #include <utils/Vector.h>
 
 #include "Texture.h"
diff --git a/libs/hwui/LayerRenderer.cpp b/libs/hwui/LayerRenderer.cpp
index e38b479..94d3fab 100644
--- a/libs/hwui/LayerRenderer.cpp
+++ b/libs/hwui/LayerRenderer.cpp
@@ -221,6 +221,7 @@ Layer* LayerRenderer::createLayer(uint32_t width, uint32_t height, bool isOpaque
 
             glBindFramebuffer(GL_FRAMEBUFFER, previousFbo);
             Caches::getInstance().fboCache.put(fbo);
+            layer->setFbo(0);
 
             layer->deleteTexture();
             delete layer;
@@ -307,6 +308,7 @@ void LayerRenderer::destroyLayer(Layer* layer) {
 
         if (layer->getFbo()) {
             Caches::getInstance().fboCache.put(layer->getFbo());
+            layer->setFbo(0);
         }
 
         if (!Caches::getInstance().layerCache.put(layer)) {
diff --git a/libs/hwui/OpenGLRenderer.cpp b/libs/hwui/OpenGLRenderer.cpp
index 4d22646..35e5597 100644
--- a/libs/hwui/OpenGLRenderer.cpp
+++ b/libs/hwui/OpenGLRenderer.cpp
@@ -144,6 +144,13 @@ void OpenGLRenderer::setViewport(int width, int height) {
     mDirtyClip = false;
 }
 
+#ifdef QCOM_HARDWARE
+void OpenGLRenderer::getViewport(int &width, int &height) {
+    width = mWidth;
+    height = mHeight;
+}
+#endif
+
 void OpenGLRenderer::prepare(bool opaque) {
     prepareDirty(0.0f, 0.0f, mWidth, mHeight, opaque);
 }
@@ -163,10 +170,15 @@ void OpenGLRenderer::prepareDirty(float left, float top, float right, float bott
     glScissor(left, mSnapshot->height - bottom, right - left, bottom - top);
     mSnapshot->setClip(left, top, right, bottom);
 
+#ifdef QCOM_HARDWARE
+    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+    glClear(GL_COLOR_BUFFER_BIT);
+#else
     if (!opaque) {
         glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
         glClear(GL_COLOR_BUFFER_BIT);
     }
+#endif
 }
 
 void OpenGLRenderer::finish() {
diff --git a/libs/hwui/OpenGLRenderer.h b/libs/hwui/OpenGLRenderer.h
index 2fc88e1..40dd5b3 100644
--- a/libs/hwui/OpenGLRenderer.h
+++ b/libs/hwui/OpenGLRenderer.h
@@ -63,7 +63,9 @@ public:
     virtual ~OpenGLRenderer();
 
     virtual void setViewport(int width, int height);
-
+#ifdef QCOM_HARDWARE
+    ANDROID_API void getViewport(int &width, int &height);
+#endif
     ANDROID_API void prepare(bool opaque);
     virtual void prepareDirty(float left, float top, float right, float bottom, bool opaque);
     virtual void finish();
diff --git a/libs/hwui/TextureCache.h b/libs/hwui/TextureCache.h
index ce924b4..8ab9bdd 100644
--- a/libs/hwui/TextureCache.h
+++ b/libs/hwui/TextureCache.h
@@ -19,6 +19,7 @@
 
 #include <SkBitmap.h>
 
+#include <utils/threads.h>
 #include <utils/Vector.h>
 
 #include "Debug.h"
diff --git a/libs/rs/driver/rsdAllocation.cpp b/libs/rs/driver/rsdAllocation.cpp
index 2ebfe0a..d60a8b9 100644
--- a/libs/rs/driver/rsdAllocation.cpp
+++ b/libs/rs/driver/rsdAllocation.cpp
@@ -494,7 +494,7 @@ void rsdAllocationData3D_alloc(const android::renderscript::Context *rsc,
 
 void rsdAllocationElementData1D(const Context *rsc, const Allocation *alloc,
                                 uint32_t x,
-                                const void *data, uint32_t cIdx, uint32_t sizeBytes) {
+                                const void *data, uint32_t sizeBytes, uint32_t cIdx) {
     DrvAllocation *drv = (DrvAllocation *)alloc->mHal.drv;
 
     uint32_t eSize = alloc->mHal.state.elementSizeBytes;
@@ -515,7 +515,7 @@ void rsdAllocationElementData1D(const Context *rsc, const Allocation *alloc,
 
 void rsdAllocationElementData2D(const Context *rsc, const Allocation *alloc,
                                 uint32_t x, uint32_t y,
-                                const void *data, uint32_t cIdx, uint32_t sizeBytes) {
+                                const void *data, uint32_t sizeBytes, uint32_t cIdx) {
     DrvAllocation *drv = (DrvAllocation *)alloc->mHal.drv;
 
     uint32_t eSize = alloc->mHal.state.elementSizeBytes;
diff --git a/libs/rs/driver/rsdGL.cpp b/libs/rs/driver/rsdGL.cpp
index 98d9486..e52689e 100644
--- a/libs/rs/driver/rsdGL.cpp
+++ b/libs/rs/driver/rsdGL.cpp
@@ -138,6 +138,12 @@ void rsdGLShutdown(const Context *rsc) {
         if (dc->gl.egl.surface != EGL_NO_SURFACE) {
             RSD_CALL_GL(eglDestroySurface, dc->gl.egl.display, dc->gl.egl.surface);
         }
+#ifdef QCOM_HARDWARE
+        if (dc->gl.wndSurface != NULL) {
+            dc->gl.wndSurface->decStrong(NULL);
+            dc->gl.wndSurface = NULL;
+        }
+#endif        
         RSD_CALL_GL(eglDestroyContext, dc->gl.egl.display, dc->gl.egl.context);
         checkEglError("eglDestroyContext");
     }
diff --git a/libs/rs/rsAllocation.cpp b/libs/rs/rsAllocation.cpp
index e732630..bbf2dbd 100644
--- a/libs/rs/rsAllocation.cpp
+++ b/libs/rs/rsAllocation.cpp
@@ -130,7 +130,7 @@ void Allocation::elementData(Context *rsc, uint32_t x, const void *data,
         return;
     }
 
-    rsc->mHal.funcs.allocation.elementData1D(rsc, this, x, data, cIdx, sizeBytes);
+    rsc->mHal.funcs.allocation.elementData1D(rsc, this, x, data, sizeBytes, cIdx);
     sendDirty(rsc);
 }
 
@@ -164,7 +164,7 @@ void Allocation::elementData(Context *rsc, uint32_t x, uint32_t y,
         return;
     }
 
-    rsc->mHal.funcs.allocation.elementData2D(rsc, this, x, y, data, cIdx, sizeBytes);
+    rsc->mHal.funcs.allocation.elementData2D(rsc, this, x, y, data, sizeBytes, cIdx);
     sendDirty(rsc);
 }
 
@@ -429,13 +429,13 @@ void rsi_Allocation1DData(Context *rsc, RsAllocation va, uint32_t xoff, uint32_t
 }
 
 void rsi_Allocation2DElementData(Context *rsc, RsAllocation va, uint32_t x, uint32_t y, uint32_t lod, RsAllocationCubemapFace face,
-                                 const void *data, size_t eoff, uint32_t sizeBytes) { // TODO: this seems wrong, eoff and sizeBytes may be swapped
+                                 const void *data, uint32_t sizeBytes, size_t eoff) {
     Allocation *a = static_cast<Allocation *>(va);
     a->elementData(rsc, x, y, data, eoff, sizeBytes);
 }
 
 void rsi_Allocation1DElementData(Context *rsc, RsAllocation va, uint32_t x, uint32_t lod,
-                                 const void *data, size_t eoff, uint32_t sizeBytes) { // TODO: this seems wrong, eoff and sizeBytes may be swapped
+                                 const void *data, uint32_t sizeBytes, size_t eoff) {
     Allocation *a = static_cast<Allocation *>(va);
     a->elementData(rsc, x, data, eoff, sizeBytes);
 }
diff --git a/libs/rs/rsContext.cpp b/libs/rs/rsContext.cpp
index 5291a1f..52a361d 100644
--- a/libs/rs/rsContext.cpp
+++ b/libs/rs/rsContext.cpp
@@ -263,8 +263,16 @@ void * Context::threadProc(void *vrsc) {
         mDraw &= (rsc->mRootScript.get() != NULL);
         mDraw &= rsc->mHasSurface;
 
+#ifdef QCOM_HARDWARE
+        int32_t scripttime = 0;
+#endif
         if (mDraw && rsc->mIsGraphicsContext) {
+#ifdef QCOM_HARDWARE
+            scripttime = rsc->runRootScript();
+            uint64_t delay = scripttime * 1000000;
+#else
             uint64_t delay = rsc->runRootScript() * 1000000;
+#endif
             targetTime = rsc->getTime() + delay;
             doWait = (delay == 0);
 
@@ -282,6 +290,14 @@ void * Context::threadProc(void *vrsc) {
         } else {
             doWait = true;
         }
+#ifdef QCOM_HARDWARE
+        if (scripttime > 1) {
+            int32_t t = (scripttime - (int32_t)(rsc->mTimeMSLastScript + rsc->mTimeMSLastSwap)) * 1000;
+            if (t > 0) {
+                usleep(t);
+            }
+        }
+#endif
     }
 
     LOGV("%p RS Thread exiting", rsc);
diff --git a/libs/rs/rsThreadIO.cpp b/libs/rs/rsThreadIO.cpp
index b1a579a..031dd3d 100644
--- a/libs/rs/rsThreadIO.cpp
+++ b/libs/rs/rsThreadIO.cpp
@@ -124,7 +124,6 @@ bool ThreadIO::playCoreCommands(Context *con, bool waitForCommand, uint64_t time
     while (!mToCore.isEmpty() || waitForCommand) {
         uint32_t cmdID = 0;
         uint32_t cmdSize = 0;
-        ret = true;
         if (con->props.mLogTimes) {
             con->timerSet(Context::RS_TIMER_IDLE);
         }
@@ -135,12 +134,18 @@ bool ThreadIO::playCoreCommands(Context *con, bool waitForCommand, uint64_t time
             if (delay > timeToWait) {
                 delay = 0;
             }
+
+        if (delay == 0 && timeToWait != 0 && mToCore.isEmpty()) {
+            break;
+        }
+
         }
         const void * data = mToCore.get(&cmdID, &cmdSize, delay);
         if (!cmdSize) {
             // exception or timeout occurred.
-            return false;
+            break;
         }
+        ret=true;
         if (con->props.mLogTimes) {
             con->timerSet(Context::RS_TIMER_INTERNAL);
         }
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index fbabfc4..5f5e325 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -21,7 +21,8 @@ commonSources:= \
 	Keyboard.cpp \
 	KeyLayoutMap.cpp \
 	KeyCharacterMap.cpp \
-	VirtualKeyMap.cpp
+	VirtualKeyMap.cpp \
+    Overlay.cpp
 
 # For the host
 # =====================================================
diff --git a/libs/ui/FramebufferNativeWindow.cpp b/libs/ui/FramebufferNativeWindow.cpp
index 8949730..cd6849a 100644
--- a/libs/ui/FramebufferNativeWindow.cpp
+++ b/libs/ui/FramebufferNativeWindow.cpp
@@ -97,9 +97,17 @@ FramebufferNativeWindow::FramebufferNativeWindow()
         mUpdateOnDemand = (fbDev->setUpdateRect != 0);
         
         // initialize the buffer FIFO
+#ifdef QCOM_HARDWARE
+	mNumBuffers = fbDev->numFramebuffers;
+	mNumFreeBuffers = mNumBuffers;
+	mBufferHead = 0;
+
+	LOGD("mNumBuffers = %d", mNumBuffers);
+#else
         mNumBuffers = NUM_FRAME_BUFFERS;
         mNumFreeBuffers = NUM_FRAME_BUFFERS;
         mBufferHead = mNumBuffers-1;
+#endif
 
         for (i = 0; i < mNumBuffers; i++)
         {
@@ -142,15 +150,26 @@ FramebufferNativeWindow::FramebufferNativeWindow()
     ANativeWindow::queueBuffer = queueBuffer;
     ANativeWindow::query = query;
     ANativeWindow::perform = perform;
+#ifdef QCOM_HARDWARE
+    ANativeWindow::cancelBuffer = NULL;
+#endif
 }
 
 FramebufferNativeWindow::~FramebufferNativeWindow() 
 {
     if (grDev) {
+#ifdef QCOM_HARDWARE
+       for(int i = 0; i < mNumBuffers; i++) {
+            if (buffers[i] != NULL) {
+                grDev->free(grDev, buffers[i]->handle);
+            }
+        }
+#else
         if (buffers[0] != NULL)
             grDev->free(grDev, buffers[0]->handle);
         if (buffers[1] != NULL)
             grDev->free(grDev, buffers[1]->handle);
+#endif
         gralloc_close(grDev);
     }
 
@@ -201,23 +220,46 @@ int FramebufferNativeWindow::getCurrentBufferIndex() const
 }
 
 int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window, 
+#ifdef QCOM_HARDWARE
+        android_native_buffer_t** buffer)
+#else
         ANativeWindowBuffer** buffer)
+#endif
 {
     FramebufferNativeWindow* self = getSelf(window);
+#ifndef QCOM_HARDWARE
     Mutex::Autolock _l(self->mutex);
+#endif
     framebuffer_device_t* fb = self->fbDev;
 
+#ifdef QCOM_HARDWARE
+    int index = self->mBufferHead;
+#else
     int index = self->mBufferHead++;
     if (self->mBufferHead >= self->mNumBuffers)
         self->mBufferHead = 0;
+#endif
 
     GraphicLog& logger(GraphicLog::getInstance());
     logger.log(GraphicLog::SF_FB_DEQUEUE_BEFORE, index);
 
+#ifdef QCOM_HARDWARE
+    /* The buffer is available, return it */
+    Mutex::Autolock _l(self->mutex);
+
+    // wait if the number of free buffers <= 0
+    while (self->mNumFreeBuffers <= 0) {
+#else
     // wait for a free buffer
     while (!self->mNumFreeBuffers) {
+#endif
         self->mCondition.wait(self->mutex);
     }
+#ifdef QCOM_HARDWARE
+    self->mBufferHead++;
+    if (self->mBufferHead >= self->mNumBuffers)
+        self->mBufferHead = 0;
+#endif
     // get this buffer
     self->mNumFreeBuffers--;
     self->mCurrentBufferIndex = index;
@@ -229,20 +271,37 @@ int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,
 }
 
 int FramebufferNativeWindow::lockBuffer(ANativeWindow* window, 
+#ifdef QCOM_HARDWARE
+        android_native_buffer_t* buffer)
+#else
         ANativeWindowBuffer* buffer)
+#endif
 {
     FramebufferNativeWindow* self = getSelf(window);
+#ifdef QCOM_HARDWARE
+    framebuffer_device_t* fb = self->fbDev;
+    int index = -1;
+
+    {
+        Mutex::Autolock _l(self->mutex);
+        index = self->mCurrentBufferIndex;
+    }
+#else
     Mutex::Autolock _l(self->mutex);
 
     const int index = self->mCurrentBufferIndex;
+#endif
     GraphicLog& logger(GraphicLog::getInstance());
     logger.log(GraphicLog::SF_FB_LOCK_BEFORE, index);
 
+#ifdef QCOM_HARDWARE
+    fb->lockBuffer(fb, index);
+#else
     // wait that the buffer we're locking is not front anymore
     while (self->front == buffer) {
         self->mCondition.wait(self->mutex);
     }
-
+#endif
     logger.log(GraphicLog::SF_FB_LOCK_AFTER, index);
 
     return NO_ERROR;
@@ -289,6 +348,11 @@ int FramebufferNativeWindow::query(const ANativeWindow* window,
         case NATIVE_WINDOW_CONCRETE_TYPE:
             *value = NATIVE_WINDOW_FRAMEBUFFER;
             return NO_ERROR;
+#ifdef QCOM_HARDWARE
+        case NATIVE_WINDOW_NUM_BUFFERS:
+            *value = fb->numFramebuffers;
+            return NO_ERROR;
+#endif
         case NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER:
             *value = 0;
             return NO_ERROR;
diff --git a/libs/ui/GraphicBufferAllocator.cpp b/libs/ui/GraphicBufferAllocator.cpp
index e75415b..d86ac5e 100644
--- a/libs/ui/GraphicBufferAllocator.cpp
+++ b/libs/ui/GraphicBufferAllocator.cpp
@@ -98,6 +98,15 @@ status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h, PixelFormat forma
 
     // we have a h/w allocator and h/w buffer is requested
     status_t err; 
+
+#ifdef MISSING_EGL_PIXEL_FORMAT_YV12
+    if (format == HAL_PIXEL_FORMAT_YV12) {
+	format = HAL_PIXEL_FORMAT_RGBX_8888;
+    }
+    if (usage & GRALLOC_USAGE_EXTERNAL_DISP) {
+	usage ^= GRALLOC_USAGE_EXTERNAL_DISP;
+    }
+#endif
     
     err = mAllocDev->alloc(mAllocDev, w, h, format, usage, handle, stride);
 
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index 07c0674..b595713 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -70,11 +70,25 @@ status_t GraphicBufferMapper::lock(buffer_handle_t handle,
         int usage, const Rect& bounds, void** vaddr)
 {
     status_t err;
+#ifdef MISSING_GRALLOC_BUFFERS
+    int tries=5;
+#endif
 
     err = mAllocMod->lock(mAllocMod, handle, usage,
             bounds.left, bounds.top, bounds.width(), bounds.height(),
             vaddr);
 
+#ifdef MISSING_GRALLOC_BUFFERS
+    while (err && tries) {
+	usleep(1000);
+        err = mAllocMod->unlock(mAllocMod, handle);
+        err = mAllocMod->lock(mAllocMod, handle, usage,
+            bounds.left, bounds.top, bounds.width(), bounds.height(),
+            vaddr);
+	tries--;
+    }
+#endif
+
     LOGW_IF(err, "lock(...) failed %d (%s)", err, strerror(-err));
     return err;
 }
@@ -87,6 +101,19 @@ status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
 
     LOGW_IF(err, "unlock(...) failed %d (%s)", err, strerror(-err));
     return err;
+
+#ifdef EXYNOS4210_ENHANCEMENTS
+status_t GraphicBufferMapper::getphys(buffer_handle_t handle, void** paddr)
+{
+    status_t err;
+
+    err = mAllocMod->getphys(mAllocMod, handle, paddr);
+
+    LOGW_IF(err, "getphys(%p) fail %d(%s)",
+            handle, err, strerror(-err));
+    return err;
+}
+#endif
 }
 
 // ---------------------------------------------------------------------------
diff --git a/libs/ui/Overlay.cpp b/libs/ui/Overlay.cpp
new file mode 100644
index 0000000..6733a85
--- /dev/null
+++ b/libs/ui/Overlay.cpp
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "Overlay"
+
+#include <binder/IMemory.h>
+#include <binder/Parcel.h>
+#include <utils/Errors.h>
+#include <binder/MemoryHeapBase.h>
+#include <cutils/ashmem.h>
+
+#include <ui/Overlay.h>
+
+namespace android {
+
+int Overlay::getBppFromFormat(const Format format)
+{
+    switch(format) {
+    case FORMAT_RGBA8888:
+        return 32;
+    case FORMAT_RGB565:
+    case FORMAT_YUV422I:
+    case FORMAT_YUV422SP:
+        return 16;
+    case FORMAT_YUV420SP:
+    case FORMAT_YUV420P:
+        return 12;
+    default:
+        LOGW("%s: unhandled color format %d", __FUNCTION__, format);
+    }
+    return 32;
+}
+
+Overlay::Format Overlay::getFormatFromString(const char* name)
+{
+    if (strcmp(name, "yuv422sp") == 0) {
+        return FORMAT_YUV422SP;
+    } else if (strcmp(name, "yuv420sp") == 0) {
+        return FORMAT_YUV420SP;
+    } else if (strcmp(name, "yuv422i-yuyv") == 0) {
+        return FORMAT_YUV422I;
+    } else if (strcmp(name, "yuv420p") == 0) {
+        return FORMAT_YUV420P;
+    } else if (strcmp(name, "rgb565") == 0) {
+        return FORMAT_RGB565;
+    } else if (strcmp(name, "rgba8888") == 0) {
+        return FORMAT_RGBA8888;
+    }
+    LOGW("%s: unhandled color format %s", __FUNCTION__, name);
+    return FORMAT_UNKNOWN;
+}
+
+Overlay::Overlay(uint32_t width, uint32_t height, Format format, QueueBufferHook queueBufferHook, void *data) :
+    mQueueBufferHook(queueBufferHook),
+    mHookData(data),
+    mNumFreeBuffers(0),
+    mStatus(NO_INIT),
+    mWidth(width),
+    mHeight(height),
+    mFormat(format)
+{
+    LOGD("%s: Init overlay", __FUNCTION__);
+
+    int bpp = getBppFromFormat(format);
+    /* round up to next multiple of 8 */
+    if (bpp & 7) {
+        bpp = (bpp & ~7) + 8;
+    }
+
+    const int requiredMem = width * height * bpp;
+    const int bufferSize = (requiredMem + PAGE_SIZE - 1) & (~(PAGE_SIZE - 1));
+
+    int fd = ashmem_create_region("Overlay_buffer_region", NUM_BUFFERS * bufferSize);
+    if (fd < 0) {
+        LOGE("%s: Cannot create ashmem region", __FUNCTION__);
+        return;
+    }
+
+    LOGV("%s: allocated ashmem region for %d buffers of size %d", __FUNCTION__, NUM_BUFFERS, bufferSize);
+
+    for (uint32_t i = 0; i < NUM_BUFFERS; i++) {
+        mBuffers[i].fd = fd;
+        mBuffers[i].length = bufferSize;
+        mBuffers[i].offset = bufferSize * i;
+        LOGV("%s: mBuffers[%d].offset = 0x%x", __FUNCTION__, i, mBuffers[i].offset);
+        mBuffers[i].ptr = mmap(NULL, bufferSize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, bufferSize * i);
+        if (mBuffers[i].ptr == MAP_FAILED) {
+            LOGE("%s: Failed to mmap buffer %d", __FUNCTION__, i);
+            mBuffers[i].ptr = NULL;
+            continue;
+        }
+        mQueued[i] = false;
+    }
+
+    pthread_mutex_init(&mQueueMutex, NULL);
+
+    LOGD("%s: Init overlay complete", __FUNCTION__);
+
+    mStatus = NO_ERROR;
+}
+
+Overlay::~Overlay() {
+}
+
+status_t Overlay::dequeueBuffer(overlay_buffer_t* buffer)
+{
+    LOGV("%s", __FUNCTION__);
+    int rv = NO_ERROR;
+
+    pthread_mutex_lock(&mQueueMutex);
+
+    if (mNumFreeBuffers < NUM_MIN_FREE_BUFFERS) {
+        LOGV("%s: No free buffers", __FUNCTION__);
+        rv = NO_MEMORY;
+    } else {
+        int index = -1;
+
+        for (uint32_t i = 0; i < NUM_BUFFERS; i++) {
+            if (mQueued[i]) {
+                mQueued[i] = false;
+                index = i;
+                break;
+            }
+        }
+
+        if (index >= 0) {
+            int *intBuffer = (int *) buffer;
+            *intBuffer = index;
+            mNumFreeBuffers--;
+            LOGV("%s: dequeued buffer %d", __FUNCTION__, index);
+        } else {
+            LOGE("%s: inconsistent queue state", __FUNCTION__);
+            rv = NO_MEMORY;
+        }
+    }
+
+    pthread_mutex_unlock(&mQueueMutex);
+    return rv;
+}
+
+status_t Overlay::queueBuffer(overlay_buffer_t buffer)
+{
+    uint32_t index = (uint32_t) buffer;
+    int rv;
+
+    LOGV("%s: %d", __FUNCTION__, index);
+    if (index > NUM_BUFFERS) {
+        LOGE("%s: invalid buffer index %d", __FUNCTION__, index);
+        return INVALID_OPERATION;
+    }
+
+    if (mQueueBufferHook) {
+        mQueueBufferHook(mHookData, mBuffers[index].ptr, mBuffers[index].length);
+    }
+
+    pthread_mutex_lock(&mQueueMutex);
+
+    if (mNumFreeBuffers < NUM_BUFFERS) {
+        mNumFreeBuffers++;
+        mQueued[index] = true;
+        rv = NO_ERROR;
+    } else {
+        LOGW("%s: Attempt to queue more buffers than we have", __FUNCTION__);
+        rv = INVALID_OPERATION;
+    }
+
+    pthread_mutex_unlock(&mQueueMutex);
+
+    return mStatus;
+}
+
+status_t Overlay::resizeInput(uint32_t width, uint32_t height)
+{
+    LOGW("%s: %d, %d", __FUNCTION__, width, height);
+    return mStatus;
+}
+
+status_t Overlay::setParameter(int param, int value)
+{
+    LOGW("%s: %d, %d", __FUNCTION__, param, value);
+    return mStatus;
+}
+
+status_t Overlay::setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h)
+{
+    LOGD("%s: x=%d, y=%d, w=%d, h=%d", __FUNCTION__, x, y, w, h);
+    return mStatus;
+}
+
+status_t Overlay::getCrop(uint32_t* x, uint32_t* y, uint32_t* w, uint32_t* h)
+{
+    LOGW("%s", __FUNCTION__);
+    return mStatus;
+}
+
+status_t Overlay::setFd(int fd)
+{
+    LOGW("%s: fd=%d", __FUNCTION__, fd);
+    return mStatus;
+}
+
+int32_t Overlay::getBufferCount() const
+{
+    LOGV("%s: %d", __FUNCTION__, NUM_BUFFERS);
+    return NUM_BUFFERS;
+}
+
+void* Overlay::getBufferAddress(overlay_buffer_t buffer)
+{
+    uint32_t index = (uint32_t) buffer;
+
+    LOGD("%s: %d", __FUNCTION__, index);
+    if (index >= NUM_BUFFERS) {
+        index = index % NUM_BUFFERS;
+    }
+
+    //LOGD("%s: fd=%d, length=%d. offset=%d, ptr=%p", __FUNCTION__, mBuffers[index].fd,
+    //        mBuffers[index].length, mBuffers[index].offset, mBuffers[index].ptr);
+
+    return &mBuffers[index];
+}
+
+void Overlay::destroy()
+{
+    int fd = 0;
+
+    LOGV("%s", __FUNCTION__);
+
+    for (uint32_t i = 0; i < NUM_BUFFERS; i++) {
+        if (mBuffers[i].ptr != NULL && munmap(mBuffers[i].ptr, mBuffers[i].length) < 0) {
+            LOGW("%s: unmap of buffer %d failed", __FUNCTION__, i);
+        }
+        if (mBuffers[i].fd > 0) {
+            fd = mBuffers[i].fd;
+        }
+    }
+    if (fd > 0) {
+        close(fd);
+    }
+
+    pthread_mutex_destroy(&mQueueMutex);
+}
+
+status_t Overlay::getStatus() const
+{
+    LOGV("%s", __FUNCTION__);
+    return mStatus;
+}
+
+overlay_handle_t Overlay::getHandleRef() const
+{
+    LOGW("%s", __FUNCTION__);
+    return 0;
+}
+
+uint32_t Overlay::getWidth() const
+{
+    LOGV("%s", __FUNCTION__);
+    return mWidth;
+}
+
+uint32_t Overlay::getHeight() const
+{
+    LOGV("%s", __FUNCTION__);
+    return mHeight;
+}
+
+int32_t Overlay::getFormat() const
+{
+    LOGV("%s", __FUNCTION__);
+    return mFormat;
+}
+
+int32_t Overlay::getWidthStride() const
+{
+    LOGW("%s", __FUNCTION__);
+    return mWidth;
+}
+
+int32_t Overlay::getHeightStride() const
+{
+    LOGW("%s", __FUNCTION__);
+    return mHeight;
+}
+
+}; // namespace android
diff --git a/libs/utils/Android.mk b/libs/utils/Android.mk
index 831d9e3..c7bcb46 100644
--- a/libs/utils/Android.mk
+++ b/libs/utils/Android.mk
@@ -61,7 +61,7 @@ LOCAL_SRC_FILES:= $(commonSources)
 
 LOCAL_MODULE:= libutils
 
-LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1 $(TOOL_CFLAGS)
+LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1 $(TOOL_CFLAGS) -fpermissive
 LOCAL_C_INCLUDES += external/zlib
 
 ifeq ($(HOST_OS),windows)
diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index 7af4a87..02138e4 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -4,6 +4,7 @@ include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:= \
     AudioParameter.cpp
+
 LOCAL_MODULE:= libmedia_helper
 LOCAL_MODULE_TAGS := optional
 
@@ -46,10 +47,31 @@ LOCAL_SRC_FILES:= \
     MemoryLeakTrackUtil.cpp \
     fixedfft.cpp.arm
 
+ifeq ($(BOARD_USES_LIBMEDIA_WITH_AUDIOPARAMETER),true)
+    LOCAL_SRC_FILES+= \
+        AudioParameter.cpp
+endif
+
+ifeq ($(BOARD_USES_AUDIO_LEGACY),true)
+    LOCAL_SRC_FILES+= \
+        AudioParameter.cpp
+
+    LOCAL_CFLAGS += -DUSES_AUDIO_LEGACY
+endif
+
+ifeq ($(BOARD_USE_KINETO_COMPATIBILITY),true)
+    LOCAL_CFLAGS += -DUSE_KINETO_COMPATIBILITY
+endif
+
+ifeq ($(BOARD_USE_SAMSUNG_SEPARATEDSTREAM),true)
+    LOCAL_CFLAGS += -DUSE_SAMSUNG_SEPARATEDSTREAM
+endif
+
 LOCAL_SHARED_LIBRARIES := \
-	libui libcutils libutils libbinder libsonivox libicuuc libexpat \
-        libcamera_client libstagefright_foundation \
-        libgui libdl
+    libui libcutils libutils libbinder libsonivox libicuuc libexpat \
+    libcamera_client libstagefright_foundation \
+    libgui libdl
+
 
 LOCAL_WHOLE_STATIC_LIBRARY := libmedia_helper
 
diff --git a/media/libmedia/AudioRecord.cpp b/media/libmedia/AudioRecord.cpp
index e5062ab..de3e6af 100644
--- a/media/libmedia/AudioRecord.cpp
+++ b/media/libmedia/AudioRecord.cpp
@@ -101,6 +101,38 @@ AudioRecord::AudioRecord(
             frameCount, flags, cbf, user, notificationFrames, sessionId);
 }
 
+#ifdef USE_KINETO_COMPATIBILITY
+// Really dirty hack to give a Froyo-compatible constructor
+extern "C" AudioRecord *_ZN7android11AudioRecordC1EijijijPFviPvS1_ES1_ii(
+        AudioRecord *This,
+        int inputSource,
+        uint32_t sampleRate,
+        int format,
+        uint32_t channels,
+        int frameCount,
+        uint32_t flags,
+        AudioRecord::callback_t cbf,
+        void* user,
+        int notificationFrames,
+        int sessionId);
+extern "C" AudioRecord *_ZN7android11AudioRecordC1EijijijPFviPvS1_ES1_i(
+        AudioRecord *This,
+        int inputSource,
+        uint32_t sampleRate,
+        int format,
+        uint32_t channels,
+        int frameCount,
+        uint32_t flags,
+        AudioRecord::callback_t cbf,
+        void* user,
+        int notificationFrames)
+{
+    return _ZN7android11AudioRecordC1EijijijPFviPvS1_ES1_ii(This,
+        inputSource, sampleRate, format, channels,
+        frameCount, flags, cbf, user, notificationFrames, 0);
+}
+#endif
+
 AudioRecord::~AudioRecord()
 {
     if (mStatus == NO_ERROR) {
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index 7b14c18..a7ea595 100644
--- a/media/libmedia/AudioSystem.cpp
+++ b/media/libmedia/AudioSystem.cpp
@@ -596,6 +596,27 @@ audio_io_handle_t AudioSystem::getOutput(audio_stream_type_t stream,
     return output;
 }
 
+#ifdef WITH_QCOM_LPA
+audio_io_handle_t AudioSystem::getSession(audio_stream_type_t stream,
+                                          uint32_t      format,
+                                          audio_policy_output_flags_t flags,
+                                          int           sessionId)
+{
+    audio_io_handle_t output = 0;
+
+    if ((flags & AUDIO_POLICY_OUTPUT_FLAG_DIRECT) == 0) {
+        return 0;
+    }
+
+    const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+    if (aps == 0) return 0;
+
+    output = aps->getSession(stream, format, flags, sessionId);
+
+    return output;
+}
+#endif
+
 status_t AudioSystem::startOutput(audio_io_handle_t output,
                                   audio_stream_type_t stream,
                                   int session)
@@ -621,6 +642,29 @@ void AudioSystem::releaseOutput(audio_io_handle_t output)
     aps->releaseOutput(output);
 }
 
+#ifdef WITH_QCOM_LPA
+status_t AudioSystem::pauseSession(audio_io_handle_t output, audio_stream_type_t stream)
+{
+    const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+    if (aps == 0) return PERMISSION_DENIED;
+    return aps->pauseSession(output, stream);
+}
+
+status_t AudioSystem::resumeSession(audio_io_handle_t output, audio_stream_type_t stream)
+{
+    const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+    if (aps == 0) return PERMISSION_DENIED;
+    return aps->resumeSession(output, stream);
+}
+
+void AudioSystem::closeSession(audio_io_handle_t output)
+{
+    const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+    if (aps == 0) return;
+    aps->closeSession(output);
+}
+#endif
+
 audio_io_handle_t AudioSystem::getInput(int inputSource,
                                     uint32_t samplingRate,
                                     uint32_t format,
@@ -750,5 +794,91 @@ void AudioSystem::AudioPolicyServiceClient::binderDied(const wp<IBinder>& who) {
     LOGW("AudioPolicyService server died!");
 }
 
+#ifdef USES_AUDIO_LEGACY
+extern "C" uint32_t _ZN7android11AudioSystem8popCountEj(uint32_t u)
+{
+    return popcount(u);
+}
+
+extern "C" bool _ZN7android11AudioSystem12isA2dpDeviceENS0_13audio_devicesE(uint32_t device)
+{
+    return audio_is_a2dp_device((audio_devices_t)device);
+}
+
+extern "C" bool _ZN7android11AudioSystem13isInputDeviceENS0_13audio_devicesE(uint32_t device)
+{
+    return audio_is_input_device((audio_devices_t)device);
+}
+
+extern "C" bool _ZN7android11AudioSystem14isOutputDeviceENS0_13audio_devicesE(uint32_t device)
+{
+    return audio_is_output_device((audio_devices_t)device);
+}
+
+extern "C" bool _ZN7android11AudioSystem20isBluetoothScoDeviceENS0_13audio_devicesE(uint32_t device)
+{
+    return audio_is_bluetooth_sco_device((audio_devices_t)device);
+}
+
+extern "C" status_t _ZN7android11AudioSystem24setDeviceConnectionStateENS0_13audio_devicesENS0_23device_connection_stateEPKc(audio_devices_t device,
+                                               audio_policy_dev_state_t state,
+                                               const char *device_address) 
+{
+    return AudioSystem::setDeviceConnectionState(device, state, device_address);
+}
+
+extern "C" audio_io_handle_t _ZN7android11AudioSystem9getOutputENS0_11stream_typeEjjjNS0_12output_flagsE(audio_stream_type_t stream,
+                                    uint32_t samplingRate,
+                                    uint32_t format,
+                                    uint32_t channels,
+                                    audio_policy_output_flags_t flags) 
+{
+   return AudioSystem::getOutput(stream,samplingRate,format,channels>>2,flags);
+}
+
+extern "C" bool _ZN7android11AudioSystem11isLinearPCMEj(uint32_t format)
+{
+    return audio_is_linear_pcm(format);
+}
+
+extern "C" bool _ZN7android11AudioSystem15isLowVisibilityENS0_11stream_typeE(audio_stream_type_t stream)
+{
+    if (stream == AUDIO_STREAM_SYSTEM ||
+        stream == AUDIO_STREAM_NOTIFICATION ||
+        stream == AUDIO_STREAM_RING) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+#endif // AUDIO_LEGACY
+
+#ifdef USE_SAMSUNG_SEPARATEDSTREAM
+extern "C" bool _ZN7android11AudioSystem17isSeparatedStreamE19audio_stream_type_t(audio_stream_type_t stream)
+{
+    LOGD("android::AudioSystem::isSeparatedStream(audio_stream_type_t) called!");
+    LOGD("audio_stream_type_t: %d", stream);
+
+/* this is the correct implementation, but breaks headset volume rocker.
+    if (stream == 3  || stream == 9  || stream == 10
+     || stream == 12 || stream == 13 || stream == 14)
+    {
+        LOGD("isSeparatedStream: true");
+        return true;
+    }
+*/
+
+    LOGD("isSeparatedStream: false");
+    return false;
+}
+
+extern "C" bool _ZN7android11AudioSystem10stopOutputEiNS0_11stream_typeEi(audio_io_handle_t output, audio_stream_type_t stream, int session)
+{
+    return AudioSystem::stopOutput(output, stream, session);
+}
+
+#endif // USE_SAMSUNG_SEPARATEDSTREAM
+
 }; // namespace android
 
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 498ad45..a9ab982 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -54,6 +54,18 @@ status_t AudioTrack::getMinFrameCount(
         int streamType,
         uint32_t sampleRate)
 {
+#ifdef QCOM_HARDWARE
+    if(streamType == AUDIO_STREAM_VOICE_CALL) {
+        LOGV("AudioTrack :: getMinFramecount voice call \n");
+        if(sampleRate == 8000) {
+            *frameCount = 160;
+        } else if (sampleRate == 16000) {
+            *frameCount = 320;
+        }
+        return NO_ERROR;
+    }
+#endif
+
     int afSampleRate;
     if (AudioSystem::getOutputSamplingRate(&afSampleRate, streamType) != NO_ERROR) {
         return NO_INIT;
@@ -78,6 +90,38 @@ status_t AudioTrack::getMinFrameCount(
 
 // ---------------------------------------------------------------------------
 
+#ifdef USE_KINETO_COMPATIBILITY
+// Really dirty hack to give a Froyo-compatible constructor
+extern "C" AudioTrack *_ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_ii(
+        AudioTrack *This,
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        int frameCount,
+        uint32_t flags,
+        AudioTrack::callback_t cbf,
+        void* user,
+        int notificationFrames,
+        int sessionId);
+extern "C" AudioTrack *_ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_i(
+        AudioTrack *This,
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        int frameCount,
+        uint32_t flags,
+        AudioTrack::callback_t cbf,
+        void* user,
+        int notificationFrames)
+{
+    return _ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_ii(This,
+        streamType, sampleRate, format, channels,
+        frameCount, flags, cbf, user, notificationFrames, 0);
+}
+#endif
+
 AudioTrack::AudioTrack()
     : mStatus(NO_INIT)
 {
@@ -118,7 +162,20 @@ AudioTrack::AudioTrack(
             0, flags, cbf, user, notificationFrames,
             sharedBuffer, false, sessionId);
 }
-
+#ifdef WITH_QCOM_LPA
+AudioTrack::AudioTrack(
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        uint32_t flags,
+        int sessionId,
+        int lpaSessionId)
+    : mStatus(NO_INIT), mAudioSession(-1)
+{
+    mStatus = set(streamType, sampleRate, format, channels, flags, sessionId, lpaSessionId);
+}
+#endif
 AudioTrack::~AudioTrack()
 {
     LOGV_IF(mSharedBuffer != 0, "Destructor sharedBuffer: %p", mSharedBuffer->pointer());
@@ -132,9 +189,31 @@ AudioTrack::~AudioTrack()
             mAudioTrackThread->requestExitAndWait();
             mAudioTrackThread.clear();
         }
+#ifndef WITH_QCOM_LPA
         mAudioTrack.clear();
+#else
+        if(mAudioTrack != NULL) {
+            mAudioTrack.clear();
+            AudioSystem::releaseAudioSessionId(mSessionId);
+        }
+        if(mAudioSession >= 0) {
+            const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+            if (audioFlinger != 0) {
+                status_t status;
+                LOGV("Calling AudioFlinger::deleteSession");
+                audioFlinger->deleteSession();
+            } else {
+                LOGE("Could not get audioflinger");
+            }
+
+            AudioSystem::closeSession(mAudioSession);
+            mAudioSession = -1;
+        }
+#endif
         IPCThreadState::self()->flushCommands();
+#ifndef WITH_QCOM_LPA
         AudioSystem::releaseAudioSessionId(mSessionId);
+#endif
     }
 }
 
@@ -261,11 +340,97 @@ status_t AudioTrack::set(
     mUpdatePeriod = 0;
     mFlushed = false;
     mFlags = flags;
+#ifdef WITH_QCOM_LPA
+    mAudioSession = -1;
+#endif
     AudioSystem::acquireAudioSessionId(mSessionId);
     mRestoreStatus = NO_ERROR;
     return NO_ERROR;
 }
 
+#ifdef WITH_QCOM_LPA
+status_t AudioTrack::set(
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        uint32_t flags,
+        int sessionId,
+        int lpaSessionId)
+{
+
+    // handle default values first.
+    if (streamType == AUDIO_STREAM_DEFAULT) {
+        streamType = AUDIO_STREAM_MUSIC;
+    }
+    // these below should probably come from the audioFlinger too...
+    if (format == 0) {
+        format = AUDIO_FORMAT_PCM_16_BIT;
+    }
+    // validate parameters
+    if (!audio_is_valid_format(format)) {
+        LOGE("Invalid format");
+        return BAD_VALUE;
+    }
+    // force direct flag if format is not linear PCM
+    if (!audio_is_linear_pcm(format)) {
+        flags |= AUDIO_POLICY_OUTPUT_FLAG_DIRECT;
+    }
+
+    audio_io_handle_t output = AudioSystem::getSession((audio_stream_type_t)streamType,
+            format, (audio_policy_output_flags_t)flags, lpaSessionId);
+
+    if (output == 0) {
+        LOGE("Could not get audio output for stream type %d", streamType);
+        return BAD_VALUE;
+    }
+    mVolume[LEFT] = 1.0f;
+    mVolume[RIGHT] = 1.0f;
+    mStatus = NO_ERROR;
+    mStreamType = streamType;
+    mFormat = format;
+    mChannelCount = 2;
+    mSharedBuffer = NULL;
+    mMuted = false;
+    mActive = 0;
+    mCbf = NULL;
+    mNotificationFramesReq = 0;
+    mRemainingFrames = 0;
+    mUserData = NULL;
+    mLatency = 0;
+    mLoopCount = 0;
+    mMarkerPosition = 0;
+    mMarkerReached = false;
+    mNewPosition = 0;
+    mUpdatePeriod = 0;
+    mFlags = flags;
+    mAudioTrack = NULL;
+    mAudioSession = output;
+
+    mSessionId = sessionId;
+    mAuxEffectId = 0;
+
+    const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+    if (audioFlinger == 0) {
+       LOGE("Could not get audioflinger");
+       return NO_INIT;
+    }
+    status_t status;
+    audioFlinger->createSession(getpid(),
+                                sampleRate,
+                                channels,
+                                &mSessionId,
+                                &status);
+    if(status != NO_ERROR) {
+        LOGE("createSession returned with status %d", status);
+    }
+    /* Make the track active and start output */
+    android_atomic_or(1, &mActive);
+    AudioSystem::startOutput(output, (audio_stream_type_t)mStreamType);
+    LOGV("AudioTrack::set() - Started output(%d)",output);
+    return NO_ERROR;
+}
+#endif
 status_t AudioTrack::initCheck() const
 {
     return mStatus;
@@ -316,6 +481,16 @@ sp<IMemory>& AudioTrack::sharedBuffer()
 
 void AudioTrack::start()
 {
+#ifdef WITH_QCOM_LPA
+    if ( mAudioSession != -1  ) {
+        if ( NO_ERROR != AudioSystem::resumeSession(mAudioSession,
+                                   (audio_stream_type_t)mStreamType) )
+        {
+            LOGE("ResumeSession failed");
+        }
+        return;
+    }
+#endif
     sp<AudioTrackThread> t = mAudioTrackThread;
     status_t status = NO_ERROR;
 
@@ -391,25 +566,31 @@ void AudioTrack::stop()
 
     AutoMutex lock(mLock);
     if (mActive == 1) {
-        mActive = 0;
-        mCblk->cv.signal();
-        mAudioTrack->stop();
-        // Cancel loops (If we are in the middle of a loop, playback
-        // would not stop until loopCount reaches 0).
-        setLoop_l(0, 0, 0);
-        // the playback head position will reset to 0, so if a marker is set, we need
-        // to activate it again
-        mMarkerReached = false;
-        // Force flush if a shared buffer is used otherwise audioflinger
-        // will not stop before end of buffer is reached.
-        if (mSharedBuffer != 0) {
-            flush_l();
-        }
-        if (t != 0) {
-            t->requestExit();
-        } else {
-            setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_NORMAL);
+#ifdef WITH_QCOM_LPA
+        if (mAudioTrack != NULL) {
+#endif
+            mActive = 0;
+            mCblk->cv.signal();
+            mAudioTrack->stop();
+            // Cancel loops (If we are in the middle of a loop, playback
+            // would not stop until loopCount reaches 0).
+            setLoop_l(0, 0, 0);
+            // the playback head position will reset to 0, so if a marker is set, we need
+            // to activate it again
+            mMarkerReached = false;
+            // Force flush if a shared buffer is used otherwise audioflinger
+            // will not stop before end of buffer is reached.
+            if (mSharedBuffer != 0) {
+                flush_l();
+            }
+            if (t != 0) {
+                t->requestExit();
+            } else {
+                setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_NORMAL);
+            }
+#ifdef WITH_QCOM_LPA
         }
+#endif
     }
 
     if (t != 0) {
@@ -450,6 +631,16 @@ void AudioTrack::flush_l()
 void AudioTrack::pause()
 {
     LOGV("pause");
+#ifdef WITH_QCOM_LPA
+    if ( mAudioSession != -1 ) {
+        if ( NO_ERROR != AudioSystem::pauseSession(mAudioSession,
+                                  (audio_stream_type_t)mStreamType) )
+        {
+            LOGE("PauseSession failed");
+        }
+        return;
+    }
+#endif
     AutoMutex lock(mLock);
     if (mActive == 1) {
         mActive = 0;
@@ -475,6 +666,16 @@ status_t AudioTrack::setVolume(float left, float right)
     }
 
     AutoMutex lock(mLock);
+
+#ifdef WITH_QCOM_LPA
+    if(mAudioSession != -1) {
+        // LPA output
+        const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+        status_t status = audioFlinger->setSessionVolume(mStreamType, left, right);
+        return NO_ERROR;
+    }
+#endif
+
     mVolume[LEFT] = left;
     mVolume[RIGHT] = right;
 
diff --git a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
index d58834b..fd4c66c 100644
--- a/media/libmedia/IAudioFlinger.cpp
+++ b/media/libmedia/IAudioFlinger.cpp
@@ -40,6 +40,9 @@ enum {
     SET_MASTER_MUTE,
     MASTER_VOLUME,
     MASTER_MUTE,
+#ifdef WITH_QCOM_LPA
+    SET_SESSION_VOLUME,
+#endif
     SET_STREAM_VOLUME,
     SET_STREAM_MUTE,
     STREAM_VOLUME,
@@ -52,10 +55,22 @@ enum {
     REGISTER_CLIENT,
     GET_INPUTBUFFERSIZE,
     OPEN_OUTPUT,
+#ifdef WITH_QCOM_LPA
+    OPEN_SESSION,
+#endif
     OPEN_DUPLICATE_OUTPUT,
     CLOSE_OUTPUT,
+#ifdef WITH_QCOM_LPA
+    PAUSE_SESSION,
+    RESUME_SESSION,
+    CLOSE_SESSION,
+#endif
     SUSPEND_OUTPUT,
     RESTORE_OUTPUT,
+#ifdef STE_AUDIO
+    ADD_INPUT_CLIENT,
+    REMOVE_INPUT_CLIENT,
+#endif
     OPEN_INPUT,
     CLOSE_INPUT,
     SET_STREAM_OUTPUT,
@@ -69,7 +84,16 @@ enum {
     QUERY_EFFECT,
     GET_EFFECT_DESCRIPTOR,
     CREATE_EFFECT,
-    MOVE_EFFECTS
+    MOVE_EFFECTS,
+#ifdef STE_AUDIO
+    READ_INPUT,
+#endif
+#ifdef WITH_QCOM_LPA
+    SET_FM_VOLUME,
+    CREATE_SESSION,
+    DELETE_SESSION,
+    APPLY_EFFECTS
+#endif
 };
 
 class BpAudioFlinger : public BpInterface<IAudioFlinger>
@@ -126,7 +150,62 @@ public:
         }
         return track;
     }
+#ifdef WITH_QCOM_LPA
+    virtual void createSession(
+                        pid_t pid,
+                        uint32_t sampleRate,
+                        int channelCount,
+                        int *sessionId,
+                        status_t *status)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(pid);
+        data.writeInt32(sampleRate);
+        data.writeInt32(channelCount);
+        int lSessionId = 0;
+        if (sessionId != NULL) {
+            lSessionId = *sessionId;
+        }
+        data.writeInt32(lSessionId);
+        status_t lStatus = remote()->transact(CREATE_SESSION, data, &reply);
+        if (lStatus != NO_ERROR) {
+            LOGE("openRecord error: %s", strerror(-lStatus));
+        } else {
+            lSessionId = reply.readInt32();
+            if (sessionId != NULL) {
+                *sessionId = lSessionId;
+            }
+            lStatus = reply.readInt32();
+        }
+        if (status) {
+            *status = lStatus;
+        }
+    }
+
+    virtual void deleteSession()
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        status_t lStatus = remote()->transact(DELETE_SESSION, data, &reply);
+        if (lStatus != NO_ERROR) {
+            LOGE("deleteSession error: %s", strerror(-lStatus));
+        }
+    }
 
+    virtual void applyEffectsOn(int16_t *inBuffer, int16_t *outBuffer, int size)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32((int32_t)inBuffer);
+        data.writeInt32((int32_t)outBuffer);
+        data.writeInt32(size);
+        status_t lStatus = remote()->transact(APPLY_EFFECTS, data, &reply);
+        if (lStatus != NO_ERROR) {
+            LOGE("applyEffectsOn error: %s", strerror(-lStatus));
+        }
+    }
+#endif
     virtual sp<IAudioRecord> openRecord(
                                 pid_t pid,
                                 int input,
@@ -248,7 +327,18 @@ public:
         remote()->transact(MASTER_MUTE, data, &reply);
         return reply.readInt32();
     }
-
+#ifdef WITH_QCOM_LPA
+    virtual status_t setSessionVolume(int stream, float left, float right)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(stream);
+        data.writeFloat(left);
+        data.writeInt32(right);
+        remote()->transact(SET_SESSION_VOLUME, data, &reply);
+        return reply.readInt32();
+    }
+#endif
     virtual status_t setStreamVolume(int stream, float value, int output)
     {
         Parcel data, reply;
@@ -390,6 +480,62 @@ public:
         if (pLatencyMs) *pLatencyMs = latency;
         return output;
     }
+#ifdef WITH_QCOM_LPA
+    virtual int openSession(uint32_t *pDevices,
+                            uint32_t *pFormat,
+                            uint32_t flags,
+                            int32_t  stream,
+                            int32_t  sessionId)
+    {
+        Parcel data, reply;
+        uint32_t devices = pDevices ? *pDevices : 0;
+        uint32_t format = pFormat ? *pFormat : 0;
+
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(devices);
+        data.writeInt32(format);
+        data.writeInt32(flags);
+        data.writeInt32(stream);
+        data.writeInt32(sessionId);
+        remote()->transact(OPEN_SESSION, data, &reply);
+        int  output = reply.readInt32();
+        LOGV("openOutput() returned output, %p", output);
+        devices = reply.readInt32();
+        if (pDevices) *pDevices = devices;
+        format = reply.readInt32();
+        if (pFormat) *pFormat = format;
+        return output;
+    }
+
+    virtual status_t pauseSession(int output, int32_t  stream)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(output);
+        data.writeInt32(stream);
+        remote()->transact(PAUSE_SESSION, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual status_t resumeSession(int output, int32_t  stream)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(output);
+        data.writeInt32(stream);
+        remote()->transact(RESUME_SESSION, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual status_t closeSession(int output)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(output);
+        remote()->transact(CLOSE_SESSION, data, &reply);
+        return reply.readInt32();
+    }
+#endif
 
     virtual int openDuplicateOutput(int output1, int output2)
     {
@@ -428,11 +574,35 @@ public:
         return reply.readInt32();
     }
 
+#ifdef STE_AUDIO
+    virtual uint32_t *addInputClient(uint32_t clientId)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(clientId);
+        remote()->transact(ADD_INPUT_CLIENT, data, &reply);
+        return (uint32_t*) reply.readIntPtr();
+    }
+
+    virtual status_t removeInputClient(uint32_t *pClientId)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeIntPtr((intptr_t)pClientId);
+        remote()->transact(REMOVE_INPUT_CLIENT, data, &reply);
+        return reply.readInt32();
+    }
+#endif
     virtual int openInput(uint32_t *pDevices,
                             uint32_t *pSamplingRate,
                             uint32_t *pFormat,
                             uint32_t *pChannels,
+#ifdef STE_AUDIO
+                            uint32_t acoustics,
+                            uint32_t *pInputClientId)
+#else
                             uint32_t acoustics)
+#endif
     {
         Parcel data, reply;
         uint32_t devices = pDevices ? *pDevices : 0;
@@ -446,6 +616,9 @@ public:
         data.writeInt32(format);
         data.writeInt32(channels);
         data.writeInt32(acoustics);
+#ifdef STE_AUDIO
+        data.writeIntPtr((intptr_t)pInputClientId);
+#endif
         remote()->transact(OPEN_INPUT, data, &reply);
         int input = reply.readInt32();
         devices = reply.readInt32();
@@ -459,6 +632,17 @@ public:
         return input;
     }
 
+#ifdef STE_AUDIO
+    virtual status_t closeInput(int input, uint32_t *inputClientId)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(input);
+        data.writeIntPtr((intptr_t) inputClientId);
+        remote()->transact(CLOSE_INPUT, data, &reply);
+        return reply.readInt32();
+    }
+#else
     virtual status_t closeInput(int input)
     {
         Parcel data, reply;
@@ -467,7 +651,7 @@ public:
         remote()->transact(CLOSE_INPUT, data, &reply);
         return reply.readInt32();
     }
-
+#endif
     virtual status_t setStreamOutput(uint32_t stream, int output)
     {
         Parcel data, reply;
@@ -516,6 +700,20 @@ public:
         return reply.readInt32();
     }
 
+#ifdef STE_AUDIO
+    virtual size_t readInput(uint32_t *input, uint32_t inputClientId, void *buffer, uint32_t bytes, uint32_t *pOverwrittenBytes)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeIntPtr((intptr_t) input);
+        data.writeInt32(inputClientId);
+        data.writeIntPtr((intptr_t) buffer);
+        data.writeInt32(bytes);
+        data.writeIntPtr((intptr_t) pOverwrittenBytes);
+        remote()->transact(READ_INPUT, data, &reply);
+        return reply.readInt32();
+    }
+#endif
     virtual int newAudioSessionId()
     {
         Parcel data, reply;
@@ -694,6 +892,33 @@ status_t BnAudioFlinger::onTransact(
             reply->writeStrongBinder(track->asBinder());
             return NO_ERROR;
         } break;
+#ifdef WITH_QCOM_LPA
+        case CREATE_SESSION: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            pid_t pid = data.readInt32();
+            uint32_t sampleRate = data.readInt32();
+            int channelCount = data.readInt32();
+            int sessionId = data.readInt32();
+            status_t status;
+            createSession(pid, sampleRate, channelCount, &sessionId, &status);
+            reply->writeInt32(sessionId);
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+        case DELETE_SESSION: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            deleteSession();
+            return NO_ERROR;
+        } break;
+        case APPLY_EFFECTS: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int16_t *inBuffer = (int16_t*)data.readInt32();
+            int16_t *outBuffer = (int16_t*)data.readInt32();
+            int size = data.readInt32();
+            applyEffectsOn(inBuffer, outBuffer, size);
+            return NO_ERROR;
+        } break;
+#endif
         case OPEN_RECORD: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             pid_t pid = data.readInt32();
@@ -757,6 +982,16 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32( masterMute() );
             return NO_ERROR;
         } break;
+#ifdef WITH_QCOM_LPA
+        case SET_SESSION_VOLUME: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int stream = data.readInt32();
+            float left = data.readFloat();
+            float right = data.readFloat();
+            reply->writeInt32( setSessionVolume(stream, left, right) );
+            return NO_ERROR;
+        } break;
+#endif
         case SET_STREAM_VOLUME: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             int stream = data.readInt32();
@@ -853,6 +1088,47 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(latency);
             return NO_ERROR;
         } break;
+#ifdef WITH_QCOM_LPA
+        case OPEN_SESSION: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            uint32_t devices = data.readInt32();
+            uint32_t format = data.readInt32();
+            uint32_t flags = data.readInt32();
+            int32_t  stream = data.readInt32();
+            int32_t  sessionId = data.readInt32();
+            int output = openSession(&devices,
+                                     &format,
+                                     flags,
+                                     stream,
+                                     sessionId);
+            LOGV("OPEN_SESSION output, %p", output);
+            reply->writeInt32(output);
+            reply->writeInt32(devices);
+            reply->writeInt32(format);
+            return NO_ERROR;
+        } break;
+        case PAUSE_SESSION: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int output = data.readInt32();
+            int32_t  stream = data.readInt32();
+            reply->writeInt32(pauseSession(output,
+                                           stream));
+            return NO_ERROR;
+        } break;
+        case RESUME_SESSION: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int output = data.readInt32();
+            int32_t  stream = data.readInt32();
+            reply->writeInt32(resumeSession(output,
+                                           stream));
+            return NO_ERROR;
+        } break;
+        case CLOSE_SESSION: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            reply->writeInt32(closeSession(data.readInt32()));
+            return NO_ERROR;
+        } break;
+#endif
         case OPEN_DUPLICATE_OUTPUT: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             int output1 = data.readInt32();
@@ -875,6 +1151,20 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(restoreOutput(data.readInt32()));
             return NO_ERROR;
         } break;
+#ifdef STE_AUDIO
+        case ADD_INPUT_CLIENT: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            uint32_t clientId = data.readInt32();
+            reply->writeIntPtr((intptr_t)addInputClient(clientId));
+            return NO_ERROR;
+        } break;
+        case REMOVE_INPUT_CLIENT: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            uint32_t *pClientId = (uint32_t*) data.readIntPtr();
+            reply->writeInt32(removeInputClient(pClientId));
+            return NO_ERROR;
+        } break;
+#endif
         case OPEN_INPUT: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             uint32_t devices = data.readInt32();
@@ -882,12 +1172,19 @@ status_t BnAudioFlinger::onTransact(
             uint32_t format = data.readInt32();
             uint32_t channels = data.readInt32();
             uint32_t acoutics = data.readInt32();
-
+#ifdef STE_AUDIO
+            uint32_t *inputClientId = (uint32_t*) data.readIntPtr();
+#endif
             int input = openInput(&devices,
                                      &samplingRate,
                                      &format,
                                      &channels,
+#ifdef STE_AUDIO
+                                     acoutics,
+                                     inputClientId);
+#else
                                      acoutics);
+#endif
             reply->writeInt32(input);
             reply->writeInt32(devices);
             reply->writeInt32(samplingRate);
@@ -897,7 +1194,13 @@ status_t BnAudioFlinger::onTransact(
         } break;
         case CLOSE_INPUT: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
+#ifdef STE_AUDIO
+            uint32_t input = data.readInt32();
+            uint32_t *inputClientId = (uint32_t*) data.readIntPtr();
+            reply->writeInt32(closeInput(input, inputClientId));
+#else
             reply->writeInt32(closeInput(data.readInt32()));
+#endif
             return NO_ERROR;
         } break;
         case SET_STREAM_OUTPUT: {
@@ -1010,6 +1313,18 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(moveEffects(session, srcOutput, dstOutput));
             return NO_ERROR;
         } break;
+#ifdef STE_AUDIO
+        case READ_INPUT: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            uint32_t* input = (uint32_t*) data.readIntPtr();
+            uint32_t inputClientId = data.readInt32();
+            void* buffer = (void*) data.readIntPtr();
+            uint32_t bytes = data.readInt32();
+            uint32_t *pOverwrittenBytes = (uint32_t*) data.readIntPtr();
+            reply->writeInt32(readInput(input, inputClientId, buffer, bytes, pOverwrittenBytes));
+            return NO_ERROR;
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IAudioFlingerClient.cpp b/media/libmedia/IAudioFlingerClient.cpp
index 3900de4..5c967ed 100644
--- a/media/libmedia/IAudioFlingerClient.cpp
+++ b/media/libmedia/IAudioFlingerClient.cpp
@@ -49,7 +49,12 @@ public:
             uint32_t stream = *(uint32_t *)param2;
             LOGV("ioConfigChanged stream %d", stream);
             data.writeInt32(stream);
+#ifdef WITH_QCOM_LPA
+        } else if (event != AudioSystem::OUTPUT_CLOSED && event != AudioSystem::INPUT_CLOSED &&
+                   event != AudioSystem::A2DP_OUTPUT_STATE && event != AudioSystem::EFFECT_CONFIG_CHANGED) {
+#else
         } else if (event != AudioSystem::OUTPUT_CLOSED && event != AudioSystem::INPUT_CLOSED) {
+#endif
             AudioSystem::OutputDescriptor *desc = (AudioSystem::OutputDescriptor *)param2;
             data.writeInt32(desc->samplingRate);
             data.writeInt32(desc->format);
diff --git a/media/libmedia/IAudioPolicyService.cpp b/media/libmedia/IAudioPolicyService.cpp
index 50b4855..bbb041a 100644
--- a/media/libmedia/IAudioPolicyService.cpp
+++ b/media/libmedia/IAudioPolicyService.cpp
@@ -37,6 +37,12 @@ enum {
     SET_FORCE_USE,
     GET_FORCE_USE,
     GET_OUTPUT,
+#ifdef WITH_QCOM_LPA
+    GET_SESSION,
+    PAUSE_SESSION,
+    RESUME_SESSION,
+    CLOSE_SESSION,
+#endif
     START_OUTPUT,
     STOP_OUTPUT,
     RELEASE_OUTPUT,
@@ -146,7 +152,52 @@ public:
         remote()->transact(GET_OUTPUT, data, &reply);
         return static_cast <audio_io_handle_t> (reply.readInt32());
     }
+#ifdef WITH_QCOM_LPA
+    virtual audio_io_handle_t getSession(
+                                        audio_stream_type_t stream,
+                                        uint32_t format,
+                                        audio_policy_output_flags_t flags,
+                                        int32_t sessionId)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
+        data.writeInt32(static_cast <uint32_t>(stream));
+        data.writeInt32(static_cast <uint32_t>(format));
+        data.writeInt32(static_cast <uint32_t>(flags));
+        data.writeInt32(static_cast <int32_t>(sessionId));
+        remote()->transact(GET_SESSION, data, &reply);
+        return static_cast <audio_io_handle_t> (reply.readInt32());
+    }
+
+    virtual status_t pauseSession(audio_io_handle_t output, audio_stream_type_t stream)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
+        data.writeInt32(output);
+        data.writeInt32(static_cast <uint32_t>(stream));
+        remote()->transact(PAUSE_SESSION, data, &reply);
+        return static_cast <status_t> (reply.readInt32());
+    }
+
+    virtual status_t resumeSession(audio_io_handle_t output, audio_stream_type_t stream)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
+        data.writeInt32(output);
+        data.writeInt32(static_cast <uint32_t>(stream));
+        remote()->transact(RESUME_SESSION, data, &reply);
+        return static_cast <status_t> (reply.readInt32());
+    }
 
+    virtual status_t closeSession(audio_io_handle_t output)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
+        data.writeInt32(output);
+        remote()->transact(CLOSE_SESSION, data, &reply);
+        return static_cast <audio_io_handle_t> (reply.readInt32());
+    }
+#endif
     virtual status_t startOutput(audio_io_handle_t output,
                                  audio_stream_type_t stream,
                                  int session)
@@ -187,7 +238,12 @@ public:
                                     uint32_t format,
                                     uint32_t channels,
                                     audio_in_acoustics_t acoustics,
+#ifdef STE_AUDIO
+                                    int audioSession,
+                                    audio_input_clients *inputClientId)
+#else
                                     int audioSession)
+#endif
     {
         Parcel data, reply;
         data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
@@ -196,6 +252,9 @@ public:
         data.writeInt32(static_cast <uint32_t>(format));
         data.writeInt32(channels);
         data.writeInt32(static_cast <uint32_t>(acoustics));
+#ifdef STE_AUDIO
+        data.writeIntPtr((intptr_t)inputClientId);
+#endif
         data.writeInt32(audioSession);
         remote()->transact(GET_INPUT, data, &reply);
         return static_cast <audio_io_handle_t> (reply.readInt32());
@@ -440,7 +499,47 @@ status_t BnAudioPolicyService::onTransact(
             reply->writeInt32(static_cast <int>(output));
             return NO_ERROR;
         } break;
+#ifdef WITH_QCOM_LPA
+        case GET_SESSION: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_stream_type_t stream = static_cast <audio_stream_type_t>(data.readInt32());
+            uint32_t format = data.readInt32();
+            audio_policy_output_flags_t flags = static_cast <audio_policy_output_flags_t>(data.readInt32());
+            int32_t sessionId = data.readInt32();
+            audio_io_handle_t output = getSession(stream,
+                                                 format,
+                                                 flags,
+                                                 sessionId);
+            reply->writeInt32(static_cast <int>(output));
+            return NO_ERROR;
+        } break;
+
+        case PAUSE_SESSION: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_io_handle_t output = static_cast <audio_io_handle_t>(data.readInt32());
+            audio_stream_type_t stream = static_cast <audio_stream_type_t>(data.readInt32());
+            status_t status = pauseSession(output, stream);
+            reply->writeInt32(static_cast <int>(status));
+            return NO_ERROR;
+        } break;
 
+        case RESUME_SESSION: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_io_handle_t output = static_cast <audio_io_handle_t>(data.readInt32());
+            audio_stream_type_t stream = static_cast <audio_stream_type_t>(data.readInt32());
+            status_t status = resumeSession(output, stream);
+            reply->writeInt32(static_cast <int>(status));
+            return NO_ERROR;
+        } break;
+
+        case CLOSE_SESSION: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            audio_io_handle_t output = static_cast <audio_io_handle_t>(data.readInt32());
+            status_t status = closeSession(output);
+            reply->writeInt32(static_cast <int>(status));
+            return NO_ERROR;
+        } break;
+#endif
         case START_OUTPUT: {
             CHECK_INTERFACE(IAudioPolicyService, data, reply);
             audio_io_handle_t output = static_cast <audio_io_handle_t>(data.readInt32());
@@ -478,13 +577,22 @@ status_t BnAudioPolicyService::onTransact(
             uint32_t channels = data.readInt32();
             audio_in_acoustics_t acoustics =
                     static_cast <audio_in_acoustics_t>(data.readInt32());
+#ifdef STE_AUDIO
+            audio_input_clients *inputClientId =
+                    (audio_input_clients*) data.readIntPtr();
+#endif
             int audioSession = data.readInt32();
             audio_io_handle_t input = getInput(inputSource,
                                                samplingRate,
                                                format,
                                                channels,
                                                acoustics,
+#ifdef STE_AUDIO
+                                               audioSession,
+                                               inputClientId);
+#else
                                                audioSession);
+#endif
             reply->writeInt32(static_cast <int>(input));
             return NO_ERROR;
         } break;
diff --git a/media/libmedia/JetPlayer.cpp b/media/libmedia/JetPlayer.cpp
index 8b953e0..e0e8754 100644
--- a/media/libmedia/JetPlayer.cpp
+++ b/media/libmedia/JetPlayer.cpp
@@ -94,6 +94,10 @@ int JetPlayer::init()
             1, // format = PCM 16bits per sample,
             (pLibConfig->numChannels == 2) ? AUDIO_CHANNEL_OUT_STEREO : AUDIO_CHANNEL_OUT_MONO,
             mTrackBufferSize,
+#ifdef WITH_QCOM_LPA
+            0,
+            0,
+#endif
             0);
 
     // create render and playback thread
diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cpp
index 6096b72..fb3bf80 100644
--- a/media/libmedia/MediaProfiles.cpp
+++ b/media/libmedia/MediaProfiles.cpp
@@ -68,6 +68,10 @@ const MediaProfiles::NameToTagMap MediaProfiles::sCamcorderQualityNameMap[] = {
     {"720p", CAMCORDER_QUALITY_720P},
     {"1080p", CAMCORDER_QUALITY_1080P},
     {"qvga", CAMCORDER_QUALITY_QVGA},
+    {"fwvga", CAMCORDER_QUALITY_FWVGA},
+    {"wvga", CAMCORDER_QUALITY_WVGA},
+    {"vga", CAMCORDER_QUALITY_VGA},
+    {"wqvga", CAMCORDER_QUALITY_WQVGA},
 
     {"timelapselow",  CAMCORDER_QUALITY_TIME_LAPSE_LOW},
     {"timelapsehigh", CAMCORDER_QUALITY_TIME_LAPSE_HIGH},
@@ -612,7 +616,7 @@ void MediaProfiles::checkAndAddRequiredProfilesIfNecessary() {
 /*static*/ MediaProfiles*
 MediaProfiles::getInstance()
 {
-    LOGV("getInstance");
+    LOGE("getInstance");
     Mutex::Autolock lock(sLock);
     if (!sIsInitialized) {
         char value[PROPERTY_VALUE_MAX];
@@ -620,20 +624,22 @@ MediaProfiles::getInstance()
             const char *defaultXmlFile = "/etc/media_profiles.xml";
             FILE *fp = fopen(defaultXmlFile, "r");
             if (fp == NULL) {
-                LOGW("could not find media config xml file");
+                LOGE("could not find media config xml file");
                 sInstance = createDefaultInstance();
             } else {
+                LOGE("Guru :Else 1");
                 fclose(fp);  // close the file first.
                 sInstance = createInstanceFromXmlFile(defaultXmlFile);
             }
         } else {
+            LOGE("Guru : Else 2");
             sInstance = createInstanceFromXmlFile(value);
         }
         CHECK(sInstance != NULL);
         sInstance->checkAndAddRequiredProfilesIfNecessary();
         sIsInitialized = true;
     }
-
+    LOGE("getInstance %x",sInstance);
     return sInstance;
 }
 
@@ -641,22 +647,41 @@ MediaProfiles::getInstance()
 MediaProfiles::createDefaultH263VideoEncoderCap()
 {
     return new MediaProfiles::VideoEncoderCap(
+#ifdef QCOM_HARDWARE
+        VIDEO_ENCODER_H263, 192000, 6000000, 176, 800, 144, 480, 1, 30);
+#else
         VIDEO_ENCODER_H263, 192000, 420000, 176, 352, 144, 288, 1, 20);
+#endif
 }
 
 /*static*/ MediaProfiles::VideoEncoderCap*
 MediaProfiles::createDefaultM4vVideoEncoderCap()
 {
     return new MediaProfiles::VideoEncoderCap(
+#ifdef QCOM_HARDWARE
+        VIDEO_ENCODER_MPEG_4_SP, 192000, 20 * 1000 * 1000, 176, 1920, 144, 1088, 1, 30);
+#else
         VIDEO_ENCODER_MPEG_4_SP, 192000, 420000, 176, 352, 144, 288, 1, 20);
+#endif
 }
 
+#ifdef QCOM_HARDWARE
+/*static*/ MediaProfiles::VideoEncoderCap*
+MediaProfiles::createDefaultH264VideoEncoderCap()
+{
+    return new MediaProfiles::VideoEncoderCap(
+        VIDEO_ENCODER_H264, 192000, 20 * 1000 * 1000, 176, 1920, 144, 1088, 1, 30);
+}
+#endif
 
 /*static*/ void
 MediaProfiles::createDefaultVideoEncoders(MediaProfiles *profiles)
 {
     profiles->mVideoEncoders.add(createDefaultH263VideoEncoderCap());
     profiles->mVideoEncoders.add(createDefaultM4vVideoEncoderCap());
+#ifdef QCOM_HARDWARE
+    profiles->mVideoEncoders.add(createDefaultH264VideoEncoderCap());
+#endif
 }
 
 /*static*/ MediaProfiles::CamcorderProfile*
@@ -798,6 +823,9 @@ MediaProfiles::createDefaultCamcorderProfiles(MediaProfiles *profiles)
 MediaProfiles::createDefaultAudioEncoders(MediaProfiles *profiles)
 {
     profiles->mAudioEncoders.add(createDefaultAmrNBEncoderCap());
+#ifdef QCOM_HARDWARE
+    profiles->mAudioEncoders.add(createDefaultAacEncoderCap());
+#endif
 }
 
 /*static*/ void
@@ -832,6 +860,15 @@ MediaProfiles::createDefaultAmrNBEncoderCap()
         AUDIO_ENCODER_AMR_NB, 5525, 12200, 8000, 8000, 1, 1);
 }
 
+#ifdef QCOM_HARDWARE
+/*static*/ MediaProfiles::AudioEncoderCap*
+MediaProfiles::createDefaultAacEncoderCap()
+{
+    return new MediaProfiles::AudioEncoderCap(
+        AUDIO_ENCODER_AAC, 64000, 156000, 8000, 48000, 1, 2);
+}
+#endif
+
 /*static*/ void
 MediaProfiles::createDefaultImageEncodingQualityLevels(MediaProfiles *profiles)
 {
@@ -1091,6 +1128,7 @@ int MediaProfiles::getCamcorderProfileIndex(int cameraId, camcorder_quality qual
             break;
         }
     }
+    LOGE("Guru : quality = %d, index = %d",quality,index);
     return index;
 }
 
@@ -1098,7 +1136,7 @@ int MediaProfiles::getCamcorderProfileParamByName(const char *name,
                                                   int cameraId,
                                                   camcorder_quality quality) const
 {
-    LOGV("getCamcorderProfileParamByName: %s for camera %d, quality %d",
+    LOGE("getCamcorderProfileParamByName: %s for camera %d, quality %d",
          name, cameraId, quality);
 
     int index = getCamcorderProfileIndex(cameraId, quality);
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index a3e2517..a975613 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -41,7 +41,7 @@ LOCAL_C_INCLUDES :=                                                 \
 	$(TOP)/frameworks/base/include/media/stagefright/openmax \
 	$(TOP)/frameworks/base/media/libstagefright/include             \
 	$(TOP)/frameworks/base/media/libstagefright/rtsp                \
-        $(TOP)/external/tremolo/Tremolo \
+	$(TOP)/external/tremolo/Tremolo \
 
 LOCAL_MODULE:= libmediaplayerservice
 
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index f27d3d6..2888888 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -56,6 +56,7 @@
 #include <media/stagefright/MediaErrors.h>
 
 #include <system/audio.h>
+#include <system/audio_policy.h>
 
 #include <private/android_filesystem_config.h>
 
@@ -1262,6 +1263,9 @@ MediaPlayerService::AudioOutput::AudioOutput(int sessionId)
       mSessionId(sessionId) {
     LOGV("AudioOutput(%d)", sessionId);
     mTrack = 0;
+#ifdef WITH_QCOM_LPA
+    mSession = 0;
+#endif
     mStreamType = AUDIO_STREAM_MUSIC;
     mLeftVolume = 1.0;
     mRightVolume = 1.0;
@@ -1274,6 +1278,9 @@ MediaPlayerService::AudioOutput::AudioOutput(int sessionId)
 MediaPlayerService::AudioOutput::~AudioOutput()
 {
     close();
+#ifdef WITH_QCOM_LPA
+    closeSession();
+#endif
 }
 
 void MediaPlayerService::AudioOutput::setMinBufferCount()
@@ -1337,6 +1344,39 @@ status_t MediaPlayerService::AudioOutput::getPosition(uint32_t *position)
     if (mTrack == 0) return NO_INIT;
     return mTrack->getPosition(position);
 }
+#ifdef WITH_QCOM_LPA
+status_t MediaPlayerService::AudioOutput::openSession(
+        int format, int lpaSessionId, uint32_t sampleRate, int channels)
+{
+    uint32_t flags = 0;
+    mCallback = NULL;
+    mCallbackCookie = NULL;
+    if (mSession) closeSession();
+    mSession = NULL;
+
+    flags |= AUDIO_POLICY_OUTPUT_FLAG_DIRECT;
+
+    AudioTrack *t = new AudioTrack(
+                mStreamType,
+                sampleRate,
+                format,
+                channels,
+                flags,
+                mSessionId,
+                lpaSessionId);
+    LOGV("openSession: AudioTrack created successfully track(%p)",t);
+    if ((t == 0) || (t->initCheck() != NO_ERROR)) {
+        LOGE("Unable to create audio track");
+        delete t;
+        return NO_INIT;
+    }
+    LOGV("openSession: Out");
+    mSession = t;
+    LOGV("setVolume");
+    t->setVolume(mLeftVolume, mRightVolume);
+    return NO_ERROR;
+}
+#endif
 
 status_t MediaPlayerService::AudioOutput::open(
         uint32_t sampleRate, int channelCount, int format, int bufferCount,
@@ -1454,17 +1494,53 @@ void MediaPlayerService::AudioOutput::pause()
 void MediaPlayerService::AudioOutput::close()
 {
     LOGV("close");
-    delete mTrack;
-    mTrack = 0;
+    if(mTrack != NULL) {
+        delete mTrack;
+        mTrack = 0;
+    }
+}
+#ifdef WITH_QCOM_LPA
+void MediaPlayerService::AudioOutput::closeSession()
+{
+    LOGV("closeSession");
+    if(mSession != NULL) {
+        delete mSession;
+        mSession = 0;
+    }
 }
 
+void MediaPlayerService::AudioOutput::pauseSession()
+{
+    LOGV("pauseSession");
+    if(mSession != NULL) {
+        mSession->pause();
+    }
+}
+
+void MediaPlayerService::AudioOutput::resumeSession()
+{
+    LOGV("resumeSession");
+    if(mSession != NULL) {
+        mSession->start();
+    }
+}
+#endif
 void MediaPlayerService::AudioOutput::setVolume(float left, float right)
 {
+#ifdef WITH_QCOM_LPA
+    LOGV("setVolume(%f, %f): %p", left, right, mSession);
+#else
     LOGV("setVolume(%f, %f)", left, right);
+#endif
+
     mLeftVolume = left;
     mRightVolume = right;
     if (mTrack) {
         mTrack->setVolume(left, right);
+#ifdef WITH_QCOM_LPA
+    } else if(mSession) {
+        mSession->setVolume(left, right);
+#endif
     }
 }
 
diff --git a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
index b04fddb..24a8d09 100644
--- a/media/libmediaplayerservice/MediaPlayerService.h
+++ b/media/libmediaplayerservice/MediaPlayerService.h
@@ -85,14 +85,27 @@ class MediaPlayerService : public BnMediaPlayerService
                 uint32_t sampleRate, int channelCount,
                 int format, int bufferCount,
                 AudioCallback cb, void *cookie);
-
+#ifdef WITH_QCOM_LPA
+        virtual status_t        openSession(
+                int format, int sessionId, uint32_t sampleRate, int channels);
+#endif
         virtual void            start();
         virtual ssize_t         write(const void* buffer, size_t size);
         virtual void            stop();
         virtual void            flush();
         virtual void            pause();
+#ifdef WITH_QCOM_LPA
+        virtual void            pauseSession();
+        virtual void            resumeSession();
+#endif
         virtual void            close();
+#ifdef WITH_QCOM_LPA
+        virtual void            closeSession();
+#endif
                 void            setAudioStreamType(int streamType) { mStreamType = streamType; }
+#ifdef WITH_QCOM_LPA
+        virtual int             getAudioStreamType() { return mStreamType; }
+#endif
                 void            setVolume(float left, float right);
                 status_t        setAuxEffectSendLevel(float level);
                 status_t        attachAuxEffect(int effectId);
@@ -106,6 +119,9 @@ class MediaPlayerService : public BnMediaPlayerService
                 int event, void *me, void *info);
 
         AudioTrack*             mTrack;
+#ifdef WITH_QCOM_LPA
+        AudioTrack*             mSession;
+#endif
         AudioCallback           mCallback;
         void *                  mCallbackCookie;
         int                     mStreamType;
@@ -149,6 +165,9 @@ class MediaPlayerService : public BnMediaPlayerService
         virtual void            pause() {}
         virtual void            close() {}
                 void            setAudioStreamType(int streamType) {}
+#ifdef WITH_QCOM_LPA
+        virtual int             getAudioStreamType() { return 0; }
+#endif
                 void            setVolume(float left, float right) {}
                 uint32_t        sampleRate() const { return mSampleRate; }
                 uint32_t        format() const { return (uint32_t)mFormat; }
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 6981668..8c89dd9 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1,4 +1,5 @@
 /*
+ * Portions Copyright (C) 2012 VMware, Inc. All Rights Reserved.
  * Copyright (C) 2009 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -27,6 +28,9 @@
 #include <media/stagefright/AudioSource.h>
 #include <media/stagefright/AMRWriter.h>
 #include <media/stagefright/AACWriter.h>
+#ifdef QCOM_HARDWARE
+#include <media/stagefright/ExtendedWriter.h>
+#endif
 #include <media/stagefright/CameraSource.h>
 #include <media/stagefright/CameraSourceTimeLapse.h>
 #include <media/stagefright/MPEG2TSWriter.h>
@@ -51,6 +55,10 @@
 
 #include "ARTPWriter.h"
 
+#ifdef QCOM_HARDWARE
+#include <cutils/properties.h>
+#endif
+
 namespace android {
 
 // To collect the encoder usage for the battery app
@@ -69,7 +77,13 @@ StagefrightRecorder::StagefrightRecorder()
       mOutputFd(-1),
       mAudioSource(AUDIO_SOURCE_CNT),
       mVideoSource(VIDEO_SOURCE_LIST_END),
+#ifdef QCOM_HARDWARE
+      mStarted(false), mSurfaceMediaSource(NULL),
+      mDisableAudio(false) {
+#else
       mStarted(false), mSurfaceMediaSource(NULL) {
+#endif
+
 
     LOGV("Constructor");
     reset();
@@ -101,6 +115,12 @@ status_t StagefrightRecorder::setAudioSource(audio_source_t as) {
         return BAD_VALUE;
     }
 
+#ifdef QCOM_HARDWARE
+    if (mDisableAudio) {
+        return OK;
+    }
+#endif
+
     if (as == AUDIO_SOURCE_DEFAULT) {
         mAudioSource = AUDIO_SOURCE_MIC;
     } else {
@@ -152,12 +172,31 @@ status_t StagefrightRecorder::setAudioEncoder(audio_encoder ae) {
         return BAD_VALUE;
     }
 
+#ifdef QCOM_HARDWARE
+    if (mDisableAudio) {
+        return OK;
+    }
+#endif
+
     if (ae == AUDIO_ENCODER_DEFAULT) {
         mAudioEncoder = AUDIO_ENCODER_AMR_NB;
     } else {
         mAudioEncoder = ae;
     }
 
+#ifdef QCOM_HARDWARE
+    // Use default values if appropriate setparam's weren't called.
+    if(mAudioEncoder == AUDIO_ENCODER_AAC) {
+        mSampleRate = mSampleRate ? mSampleRate : 48000;
+        mAudioChannels = mAudioChannels ? mAudioChannels : 2;
+        mAudioBitRate = mAudioBitRate ? mAudioBitRate : 156000;
+    }
+    else{
+        mSampleRate = mSampleRate ? mSampleRate : 8000;
+        mAudioChannels = mAudioChannels ? mAudioChannels : 1;
+        mAudioBitRate = mAudioBitRate ? mAudioBitRate : 12200;
+    }
+#endif
     return OK;
 }
 
@@ -768,6 +807,11 @@ status_t StagefrightRecorder::start() {
             status = startMPEG2TSRecording();
             break;
 
+#ifdef QCOM_HARDWARE
+        case OUTPUT_FORMAT_QCP:
+            status = startExtendedRecording( );
+            break;
+#endif
         default:
             LOGE("Unsupported output file format: %d", mOutputFormat);
             status = UNKNOWN_ERROR;
@@ -818,6 +862,14 @@ sp<MediaSource> StagefrightRecorder::createAudioSource() {
         case AUDIO_ENCODER_AAC:
             mime = MEDIA_MIMETYPE_AUDIO_AAC;
             break;
+#ifdef QCOM_HARDWARE
+        case AUDIO_ENCODER_EVRC:
+            mime = MEDIA_MIMETYPE_AUDIO_EVRC;
+            break;
+        case AUDIO_ENCODER_QCELP:
+            mime = MEDIA_MIMETYPE_AUDIO_QCELP;
+            break;
+#endif
         default:
             LOGE("Unknown audio encoder: %d", mAudioEncoder);
             return NULL;
@@ -876,12 +928,32 @@ status_t StagefrightRecorder::startAMRRecording() {
                     mAudioEncoder);
             return BAD_VALUE;
         }
+#ifdef QCOM_HARDWARE
+        if (mSampleRate != 8000) {
+            LOGE("Invalid sampling rate %d used for AMRNB recording",
+                    mSampleRate);
+            return BAD_VALUE;
+        }
+#endif
     } else {  // mOutputFormat must be OUTPUT_FORMAT_AMR_WB
         if (mAudioEncoder != AUDIO_ENCODER_AMR_WB) {
             LOGE("Invlaid encoder %d used for AMRWB recording",
                     mAudioEncoder);
             return BAD_VALUE;
         }
+#ifdef QCOM_HARDWARE
+        if (mSampleRate != 16000) {
+            LOGE("Invalid sample rate %d used for AMRWB recording",
+                    mSampleRate);
+            return BAD_VALUE;
+        }
+    }
+
+    if (mAudioChannels != 1) {
+        LOGE("Invalid number of audio channels %d used for amr recording",
+                mAudioChannels);
+        return BAD_VALUE;
+#endif
     }
 
     mWriter = new AMRWriter(mOutputFd);
@@ -1297,9 +1369,22 @@ status_t StagefrightRecorder::setupCameraSource(
                 mTimeBetweenTimeLapseFrameCaptureUs);
         *cameraSource = mCameraSourceTimeLapse;
     } else {
+
+#ifdef QCOM_HARDWARE
+        bool useMeta = true;
+        char value[PROPERTY_VALUE_MAX];
+        if (property_get("debug.camcorder.disablemeta", value, NULL) &&
+            atoi(value)) {
+            useMeta = false;
+        }
+#endif
         *cameraSource = CameraSource::CreateFromCamera(
                 mCamera, mCameraProxy, mCameraId, videoSize, mFrameRate,
+#ifdef QCOM_HARDWARE
+                mPreviewSurface, useMeta);
+#else
                 mPreviewSurface, true /*storeMetaDataInVideoBuffers*/);
+#endif
     }
     mCamera.clear();
     mCameraProxy.clear();
@@ -1363,11 +1448,24 @@ status_t StagefrightRecorder::setupVideoEncoder(
     sp<MetaData> meta = cameraSource->getFormat();
 
     int32_t width, height, stride, sliceHeight, colorFormat;
+#ifdef QCOM_HARDWARE
+    int32_t hfr;
+#endif
     CHECK(meta->findInt32(kKeyWidth, &width));
     CHECK(meta->findInt32(kKeyHeight, &height));
     CHECK(meta->findInt32(kKeyStride, &stride));
     CHECK(meta->findInt32(kKeySliceHeight, &sliceHeight));
     CHECK(meta->findInt32(kKeyColorFormat, &colorFormat));
+#ifdef QCOM_HARDWARE
+    hfr = 0;
+    if (!meta->findInt32(kKeyHFR, &hfr)) {
+        LOGW("hfr not found, default to 0");
+    }
+
+    if(hfr) {
+      mMaxFileDurationUs = mMaxFileDurationUs * (hfr/mFrameRate);
+    }
+#endif
 
     enc_meta->setInt32(kKeyWidth, width);
     enc_meta->setInt32(kKeyHeight, height);
@@ -1375,9 +1473,80 @@ status_t StagefrightRecorder::setupVideoEncoder(
     enc_meta->setInt32(kKeyStride, stride);
     enc_meta->setInt32(kKeySliceHeight, sliceHeight);
     enc_meta->setInt32(kKeyColorFormat, colorFormat);
+#ifdef QCOM_HARDWARE
+    enc_meta->setInt32(kKeyHFR, hfr);
+#endif
     if (mVideoTimeScale > 0) {
         enc_meta->setInt32(kKeyTimeScale, mVideoTimeScale);
     }
+
+#ifdef QCOM_HARDWARE
+    char mDeviceName[100];
+    property_get("ro.board.platform",mDeviceName,"0");
+    if(!strncmp(mDeviceName, "msm7627a", 8)) {
+      if(hfr && (width * height > 432*240)) {
+        LOGE("HFR mode is supported only upto WQVGA resolution");
+        return INVALID_OPERATION;
+      }
+    }
+    else {
+      if(hfr && ((mVideoEncoder != VIDEO_ENCODER_H264) || (width * height > 800*480))) {
+        LOGE("HFR mode is supported only upto WVGA and H264 codec.");
+        return INVALID_OPERATION;
+      }
+    }
+
+    /*
+     * can set profile from the app as a parameter.
+     * For the mean time, set from shell
+     */
+
+    char value[PROPERTY_VALUE_MAX];
+    bool customProfile = false;
+
+    if (property_get("encoder.video.profile", value, NULL) > 0) {
+        customProfile = true;
+    }
+
+    if (customProfile) {
+        switch ( mVideoEncoder ) {
+        case VIDEO_ENCODER_H264:
+            if (strncmp("base", value, 4) == 0) {
+                mVideoEncoderProfile = OMX_VIDEO_AVCProfileBaseline;
+                LOGI("H264 Baseline Profile");
+            }
+            else if (strncmp("main", value, 4) == 0) {
+                mVideoEncoderProfile = OMX_VIDEO_AVCProfileMain;
+                LOGI("H264 Main Profile");
+            }
+            else if (strncmp("high", value, 4) == 0) {
+                mVideoEncoderProfile = OMX_VIDEO_AVCProfileHigh;
+                LOGI("H264 High Profile");
+            }
+            else {
+               LOGW("Unsupported H264 Profile");
+            }
+            break;
+        case VIDEO_ENCODER_MPEG_4_SP:
+            if (strncmp("simple", value, 5) == 0 ) {
+                mVideoEncoderProfile = OMX_VIDEO_MPEG4ProfileSimple;
+                LOGI("MPEG4 Simple profile");
+            }
+            else if (strncmp("asp", value, 3) == 0 ) {
+                mVideoEncoderProfile = OMX_VIDEO_MPEG4ProfileAdvancedSimple;
+                LOGI("MPEG4 Advanced Simple Profile");
+            }
+            else {
+                LOGW("Unsupported MPEG4 Profile");
+            }
+            break;
+        default:
+            LOGW("No custom profile support for other codecs");
+            break;
+        }
+    }
+#endif
+
     if (mVideoEncoderProfile != -1) {
         enc_meta->setInt32(kKeyVideoProfile, mVideoEncoderProfile);
     }
@@ -1390,8 +1559,17 @@ status_t StagefrightRecorder::setupVideoEncoder(
 
     uint32_t encoder_flags = 0;
     if (mIsMetaDataStoredInVideoBuffers) {
+        LOGW("Camera source supports metadata mode, create OMXCodec for metadata");
         encoder_flags |= OMXCodec::kHardwareCodecsOnly;
         encoder_flags |= OMXCodec::kStoreMetaDataInVideoBuffers;
+#ifdef QCOM_HARDWARE
+        if (property_get("ro.board.platform", value, "0")
+            && (!strncmp(value, "msm7627a", sizeof("msm7627a") - 1) ||
+                !strncmp(value, "msm7x27a", sizeof("msm7x27a") - 1))) {
+            LOGW("msm7627 family of chipsets supports, only one buffer at a time");
+            encoder_flags |= OMXCodec::kOnlySubmitOneInputBufferAtOneTime;
+        }
+#endif
     }
 
     // Do not wait for all the input buffers to become available.
@@ -1632,9 +1810,15 @@ status_t StagefrightRecorder::reset() {
     mVideoHeight   = 144;
     mFrameRate     = -1;
     mVideoBitRate  = 192000;
+#ifdef QCOM_HARDWARE
+    mSampleRate    = 0;
+    mAudioChannels = 0;
+    mAudioBitRate  = 0;
+#else
     mSampleRate    = 8000;
     mAudioChannels = 1;
     mAudioBitRate  = 12200;
+#endif
     mInterleaveDurationUs = 0;
     mIFramesIntervalSec = 1;
     mAudioSourceNode = 0;
@@ -1660,6 +1844,13 @@ status_t StagefrightRecorder::reset() {
 
     mOutputFd = -1;
 
+#ifdef QCOM_HARDWARE
+    // Disable Audio Encoding
+    char value[PROPERTY_VALUE_MAX];
+    property_get("camcorder.debug.disableaudio", value, "0");
+    if(atoi(value)) mDisableAudio = true;
+#endif
+
     return OK;
 }
 
@@ -1746,4 +1937,48 @@ status_t StagefrightRecorder::dump(
     ::write(fd, result.string(), result.size());
     return OK;
 }
+
+#ifdef QCOM_HARDWARE
+status_t StagefrightRecorder::startExtendedRecording() {
+    CHECK(mOutputFormat == OUTPUT_FORMAT_QCP);
+
+    if (mSampleRate != 8000) {
+        LOGE("Invalid sampling rate %d used for recording",
+             mSampleRate);
+        return BAD_VALUE;
+    }
+    if (mAudioChannels != 1) {
+        LOGE("Invalid number of audio channels %d used for recording",
+                mAudioChannels);
+        return BAD_VALUE;
+    }
+
+    if (mAudioSource >= AUDIO_SOURCE_CNT) {
+        LOGE("Invalid audio source: %d", mAudioSource);
+        return BAD_VALUE;
+    }
+
+    sp<MediaSource> audioEncoder = createAudioSource();
+
+    if (audioEncoder == NULL) {
+        LOGE("AudioEncoder NULL");
+        return UNKNOWN_ERROR;
+    }
+
+    mWriter = new ExtendedWriter(dup(mOutputFd));
+    mWriter->addSource(audioEncoder);
+
+    if (mMaxFileDurationUs != 0) {
+        mWriter->setMaxFileDuration(mMaxFileDurationUs);
+    }
+    if (mMaxFileSizeBytes != 0) {
+        mWriter->setMaxFileSize(mMaxFileSizeBytes);
+    }
+    mWriter->setListener(mListener);
+    mWriter->start();
+
+    return OK;
+}
+#endif
+
 }  // namespace android
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index ec5ce7e..ef33ede 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -120,6 +120,9 @@ private:
     // will be sent to the client side using which the
     // frame buffers will be queued and dequeued
     sp<SurfaceMediaSource> mSurfaceMediaSource;
+#ifdef QCOM_HARDWARE
+    bool mDisableAudio;
+#endif
 
     status_t setupMPEG4Recording(
         int outputFd,
@@ -187,6 +190,11 @@ private:
 
     StagefrightRecorder(const StagefrightRecorder &);
     StagefrightRecorder &operator=(const StagefrightRecorder &);
+
+#ifdef QCOM_HARDWARE
+    /* extension */
+    status_t startExtendedRecording();
+#endif
 };
 
 }  // namespace android
diff --git a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp
index 079f6fa..44e6bb1 100644
--- a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.cpp
@@ -169,14 +169,21 @@ status_t NuPlayer::HTTPLiveSource::getDuration(int64_t *durationUs) {
     return mLiveSession->getDuration(durationUs);
 }
 
-status_t NuPlayer::HTTPLiveSource::seekTo(int64_t seekTimeUs) {
+status_t NuPlayer::HTTPLiveSource::seekTo(int64_t seekTimeUs, int64_t* newSeekTime) {
     // We need to make sure we're not seeking until we have seen the very first
     // PTS timestamp in the whole stream (from the beginning of the stream).
     while (!mTSParser->PTSTimeDeltaEstablished() && feedMoreTSData() == OK) {
         usleep(100000);
     }
+    if( mFinalResult != OK  ) {
+       LOGW("Error state %d, Ignore this seek", mFinalResult);
+       return mFinalResult;
+    }
 
-    mLiveSession->seekTo(seekTimeUs);
+    mLiveSession->seekTo(seekTimeUs, newSeekTime);
+    if( *newSeekTime >= 0 ) {
+       mTSParser->signalDiscontinuity( ATSParser::DISCONTINUITY_SEEK, NULL);
+    }
 
     return OK;
 }
diff --git a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
index f22af5b..7d028f7 100644
--- a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
+++ b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
@@ -41,7 +41,8 @@ struct NuPlayer::HTTPLiveSource : public NuPlayer::Source {
     virtual status_t dequeueAccessUnit(bool audio, sp<ABuffer> *accessUnit);
 
     virtual status_t getDuration(int64_t *durationUs);
-    virtual status_t seekTo(int64_t seekTimeUs);
+    virtual status_t seekTo(int64_t seekTimeUs, int64_t* newSeek = NULL);
+
     virtual bool isSeekable();
 
 protected:
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 93ab704..aef118b 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -146,6 +146,7 @@ bool NuPlayer::IsFlushingState(FlushStatus state, bool *needShutdown) {
             return true;
 
         case FLUSHING_DECODER_SHUTDOWN:
+        case SHUTTING_DOWN_DECODER:
             if (needShutdown != NULL) {
                 *needShutdown = true;
             }
@@ -294,6 +295,8 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 
                 mRenderer->queueEOS(audio, err);
             } else if (what == ACodec::kWhatFlushCompleted) {
+
+                Mutex::Autolock autoLock(mLock);
                 bool needShutdown;
 
                 if (audio) {
@@ -369,6 +372,7 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                 }
             } else if (what == ACodec::kWhatShutdownCompleted) {
                 LOGV("%s shutdown completed", audio ? "audio" : "video");
+                Mutex::Autolock autoLock(mLock);
                 if (audio) {
                     mAudioDecoder.clear();
 
@@ -462,6 +466,7 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
         case kWhatReset:
         {
             LOGV("kWhatReset");
+            Mutex::Autolock autoLock(mLock);
 
             if (mRenderer != NULL) {
                 // There's an edge case where the renderer owns all output
@@ -475,7 +480,8 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                 }
             }
 
-            if (mFlushingAudio != NONE || mFlushingVideo != NONE) {
+            if ( (mAudioDecoder != NULL && IsFlushingState(mFlushingAudio)) ||
+                 (mVideoDecoder != NULL && IsFlushingState(mFlushingVideo)) ) {
                 // We're currently flushing, postpone the reset until that's
                 // completed.
 
@@ -507,18 +513,43 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 
         case kWhatSeek:
         {
-            int64_t seekTimeUs;
+            Mutex::Autolock autoLock(mLock);
+            int64_t seekTimeUs = -1, newSeekTime = -1;
             CHECK(msg->findInt64("seekTimeUs", &seekTimeUs));
 
             LOGV("kWhatSeek seekTimeUs=%lld us (%.2f secs)",
                  seekTimeUs, seekTimeUs / 1E6);
 
-            mSource->seekTo(seekTimeUs);
+            mSource->seekTo(seekTimeUs, &newSeekTime);
+            LOGV("newSeekTime %lld", newSeekTime);
+
+            if( newSeekTime >= 0 ) {
+               if( (mAudioDecoder != NULL) &&
+                   (mFlushingAudio == NONE || mFlushingAudio == AWAITING_DISCONTINUITY) ) {
+                  flushDecoder( true, true );
+               }
+               if( (mVideoDecoder != NULL) &&
+                   (mFlushingVideo == NONE || mFlushingVideo == AWAITING_DISCONTINUITY) ) {
+                  flushDecoder( false, true );
+               }
+               if( mAudioDecoder == NULL ) {
+                   LOGV("Audio is not there, set it to shutdown");
+                   mFlushingAudio = SHUT_DOWN;
+
+               }
+               if( mVideoDecoder == NULL ) {
+                   LOGV("Video is not there, set it to shutdown");
+                   mFlushingVideo = SHUT_DOWN;
+               }
+            }
 
             if (mDriver != NULL) {
                 sp<NuPlayerDriver> driver = mDriver.promote();
                 if (driver != NULL) {
                     driver->notifySeekComplete();
+                    if( newSeekTime >= 0 ) {
+                        driver->notifyPosition( newSeekTime );
+                     }
                 }
             }
 
@@ -546,11 +577,27 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 }
 
 void NuPlayer::finishFlushIfPossible() {
+    //If reset was postponed after one of the streams is flushed, complete it now
+    if (mResetPostponed) {
+        LOGV("finishFlushIfPossible Handle reset postpone ");
+        if ((mAudioDecoder != NULL) &&
+            (mFlushingAudio == NONE || mFlushingAudio == AWAITING_DISCONTINUITY )) {
+           flushDecoder( true, true );
+        }
+        if ((mVideoDecoder != NULL) &&
+            (mFlushingVideo == NONE || mFlushingVideo == AWAITING_DISCONTINUITY )) {
+           flushDecoder( false, true );
+        }
+    }
+
+    //Check if both audio & video are flushed
     if (mFlushingAudio != FLUSHED && mFlushingAudio != SHUT_DOWN) {
+        LOGV("Dont finish flush, audio is in state %d ", mFlushingAudio);
         return;
     }
 
     if (mFlushingVideo != FLUSHED && mFlushingVideo != SHUT_DOWN) {
+        LOGV("Dont finish flush, video is in state %d ", mFlushingVideo);
         return;
     }
 
@@ -562,10 +609,12 @@ void NuPlayer::finishFlushIfPossible() {
     }
 
     if (mAudioDecoder != NULL) {
+        LOGV("Resume Audio after flush");
         mAudioDecoder->signalResume();
     }
 
     if (mVideoDecoder != NULL) {
+        LOGV("Resume Video after flush");
         mVideoDecoder->signalResume();
     }
 
@@ -580,7 +629,9 @@ void NuPlayer::finishFlushIfPossible() {
     } else if (mResetPostponed) {
         (new AMessage(kWhatReset, id()))->post();
         mResetPostponed = false;
+        LOGE("Handle reset postpone");
     } else if (mAudioDecoder == NULL || mVideoDecoder == NULL) {
+        LOGV("Start scanning for sources after shutdown");
         postScanSources();
     }
 }
@@ -588,6 +639,9 @@ void NuPlayer::finishFlushIfPossible() {
 void NuPlayer::finishReset() {
     CHECK(mAudioDecoder == NULL);
     CHECK(mVideoDecoder == NULL);
+    // Make sure we don't continue to scan sources until we finish reset
+    ++mScanSourcesGeneration;
+    mScanSourcesPending = false;
 
     ++mScanSourcesGeneration;
     mScanSourcesPending = false;
@@ -644,6 +698,17 @@ status_t NuPlayer::instantiateDecoder(bool audio, sp<Decoder> *decoder) {
                        new Decoder(notify, mNativeWindow);
     looper()->registerHandler(*decoder);
 
+    {
+        //Set flushing state to none
+        Mutex::Autolock autoLock(mLock);
+        if( audio ) {
+            mFlushingAudio = NONE;
+        } else {
+            mFlushingVideo = NONE;
+
+        }
+    }
+
     (*decoder)->configure(meta);
 
     int64_t durationUs;
@@ -661,6 +726,8 @@ status_t NuPlayer::feedDecoderInputData(bool audio, const sp<AMessage> &msg) {
     sp<AMessage> reply;
     CHECK(msg->findMessage("reply", &reply));
 
+    Mutex::Autolock autoLock(mLock);
+
     if ((audio && IsFlushingState(mFlushingAudio))
             || (!audio && IsFlushingState(mFlushingVideo))) {
         reply->setInt32("err", INFO_DISCONTINUITY);
@@ -780,6 +847,7 @@ void NuPlayer::renderBuffer(bool audio, const sp<AMessage> &msg) {
     sp<AMessage> reply;
     CHECK(msg->findMessage("reply", &reply));
 
+    Mutex::Autolock autoLock(mLock);
     if (IsFlushingState(audio ? mFlushingAudio : mFlushingVideo)) {
         // We're currently attempting to flush the decoder, in order
         // to complete this, the decoder wants all its buffers back,
@@ -875,6 +943,7 @@ void NuPlayer::flushDecoder(bool audio, bool needShutdown) {
                 : FLUSHED;
         }
     }
+    LOGV("flushDecoder end states Audio %d, Video %d", mFlushingAudio, mFlushingVideo);
 }
 
 }  // namespace android
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index ffc710e..f5d31e6 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -127,6 +127,8 @@ private:
     int64_t mVideoLateByUs;
     int64_t mNumFramesTotal, mNumFramesDropped;
 
+    Mutex mLock;
+
     status_t instantiateDecoder(bool audio, sp<Decoder> *decoder);
 
     status_t feedDecoderInputData(bool audio, const sp<AMessage> &msg);
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerSource.h b/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
index 531b29f..5b8b80e 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
@@ -43,7 +43,7 @@ struct NuPlayer::Source : public RefBase {
         return INVALID_OPERATION;
     }
 
-    virtual status_t seekTo(int64_t seekTimeUs) {
+    virtual status_t seekTo(int64_t seekTimeUs, int64_t* newSeekTime = NULL ) {
         return INVALID_OPERATION;
     }
 
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
old mode 100644
new mode 100755
index dbc9b7e..f201682
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -13,6 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*--------------------------------------------------------------------------
+Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+--------------------------------------------------------------------------*/
 
 //#define LOG_NDEBUG 0
 #define LOG_TAG "ACodec"
@@ -35,6 +38,25 @@
 #include <gui/SurfaceTextureClient.h>
 
 #include <OMX_Component.h>
+#ifdef QCOM_HARDWARE
+#include <OMX_QCOMExtns.h>
+#include <gralloc_priv.h>
+#include <cutils/properties.h>
+#include <qcom_ui.h>
+
+//Smmoth streaming settings
+//Max resolution 1080p
+#define MAX_WIDTH 1920;
+#define MAX_HEIGHT 1080;
+
+//Min resolution QVGA
+#define MIN_WIDTH 480;
+#define MIN_HEIGHT 320;
+#endif
+
+#ifdef SAMSUNG_CODEC_SUPPORT
+#include "include/ColorFormat.h"
+#endif
 
 namespace android {
 
@@ -118,6 +140,37 @@ private:
     DISALLOW_EVIL_CONSTRUCTORS(CodecObserver);
 };
 
+#ifdef QCOM_HARDWARE
+static const int QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03;
+static const int OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00;
+
+class ColorFormatInfo {
+    private:
+          static const int32_t preferredFormat;
+    public:
+          static int32_t getPreferredFormat() {
+          return preferredFormat;
+          }
+};
+
+const int32_t ColorFormatInfo::preferredFormat =
+#ifdef TARGET7x30
+    QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka;
+#endif
+#ifdef TARGET8x60
+    QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka;
+#endif
+#ifdef TARGET7x27
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar;
+#endif
+#ifdef TARGET7x27A
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar;
+#endif
+#ifdef TARGET8x50
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar;
+#endif
+#endif //QCOM_HARDWARE
+
 ////////////////////////////////////////////////////////////////////////////////
 
 struct ACodec::BaseState : public AState {
@@ -158,6 +211,10 @@ private:
 
     void getMoreInputDataIfPossible();
 
+#ifdef QCOM_HARDWARE
+    void HandleExtraData(IOMX::buffer_id omxBuffer);
+#endif
+
     DISALLOW_EVIL_CONSTRUCTORS(BaseState);
 };
 
@@ -307,9 +364,38 @@ private:
 
 ////////////////////////////////////////////////////////////////////////////////
 
+#ifdef QCOM_HARDWARE
+struct ACodec::FlushingOutputState : public ACodec::BaseState {
+    FlushingOutputState(ACodec *codec);
+
+protected:
+    virtual bool onMessageReceived(const sp<AMessage> &msg);
+    virtual void stateEntered();
+
+    virtual bool onOMXEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2);
+
+    virtual void onOutputBufferDrained(const sp<AMessage> &msg);
+    virtual void onInputBufferFilled(const sp<AMessage> &msg);
+
+private:
+    bool mFlushComplete;
+
+    void changeStateIfWeOwnAllBuffers();
+
+    DISALLOW_EVIL_CONSTRUCTORS(FlushingOutputState);
+};
+
+////////////////////////////////////////////////////////////////////////////////
+#endif
+
 ACodec::ACodec()
     : mNode(NULL),
+#ifdef QCOM_HARDWARE
+      mSentFormat(false),
+      mSmoothStreaming(false) {
+#else
       mSentFormat(false) {
+#endif
     mUninitializedState = new UninitializedState(this);
     mLoadedToIdleState = new LoadedToIdleState(this);
     mIdleToExecutingState = new IdleToExecutingState(this);
@@ -321,6 +407,9 @@ ACodec::ACodec()
     mExecutingToIdleState = new ExecutingToIdleState(this);
     mIdleToLoadedState = new IdleToLoadedState(this);
     mFlushingState = new FlushingState(this);
+#ifdef QCOM_HARDWARE
+    mFlushingOutputState = new FlushingOutputState(this);
+#endif
 
     mPortEOS[kPortIndexInput] = mPortEOS[kPortIndexOutput] = false;
     mInputEOSResult = OK;
@@ -372,6 +461,7 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
     if (err != OK) {
+        LOGE("allocateBuffersOnInputPort Error in getParameter %d", err);
         return err;
     }
 
@@ -426,6 +516,8 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
 
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+    LOGV("allocateOutputBufs getParam buf cnt actual %d, min %d, buf size %d", 
+          def.nBufferCountActual, def.nBufferCountMin, def.nBufferSize);
 
     if (err != OK) {
         return err;
@@ -438,11 +530,35 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+#ifdef QCOM_HARDWARE
+    int format = (def.format.video.eColorFormat == (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka)?
+                 HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED : def.format.video.eColorFormat;
+    if(def.format.video.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar)
+        format = HAL_PIXEL_FORMAT_YCrCb_420_SP;
+#endif
+
+#ifdef SAMSUNG_CODEC_SUPPORT
+    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
+    setNativeWindowColorFormat(eNativeColorFormat);
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+           eNativeColorFormat);
+#else
+    err = native_window_set_buffers_geometry(
+            mNativeWindow.get(),
+#ifdef QCOM_HARDWARE
+            def.format.video.nStride,
+            def.format.video.nSliceHeight,
+            format);
+#else
+            def.format.video.nFrameWidth,
+            def.format.video.nFrameHeight,
             def.format.video.eColorFormat);
+#endif
+#endif
+
 
     if (err != 0) {
         LOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -485,6 +601,14 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
     if (def.nBufferCountActual < def.nBufferCountMin + minUndequeuedBufs) {
         OMX_U32 newBufferCount = def.nBufferCountMin + minUndequeuedBufs;
         def.nBufferCountActual = newBufferCount;
+
+#ifdef QCOM_HARDWARE
+        //Keep an extra buffer for smooth streaming
+        if (mSmoothStreaming) {
+            def.nBufferCountActual += 1;
+        }
+#endif
+
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -493,6 +617,13 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
                     mComponentName.c_str(), newBufferCount, err);
             return err;
         }
+
+#ifdef QCOM_HARDWARE
+        if (mSmoothStreaming) {
+            //Copy the final port definitio
+             memcpy(&mOutputPortDef, &def, sizeof(def));
+        }
+#endif
     }
 
     err = native_window_set_buffer_count(
@@ -504,6 +635,19 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+#ifdef QCOM_HARDWARE
+    err = mNativeWindow.get()->perform(mNativeWindow.get(),
+                              NATIVE_WINDOW_SET_BUFFERS_SIZE,
+                              def.nBufferSize);
+
+    if (err != 0) {
+        LOGE("native_window_set_buffer_size failed: %s (%d)", strerror(-err),
+                -err);
+        return err;
+    }
+#endif
+
+
     LOGV("[%s] Allocating %lu buffers from a native window of size %lu on "
          "output port",
          mComponentName.c_str(), def.nBufferCountActual, def.nBufferSize);
@@ -562,6 +706,25 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
     return err;
 }
 
+#ifdef SAMSUNG_CODEC_SUPPORT
+void ACodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat)
+{
+    // In case of Samsung decoders, we set proper native color format for the Native Window
+    if (!strcasecmp(mComponentName.c_str(), "OMX.SEC.AVC.Decoder")
+        || !strcasecmp(mComponentName.c_str(), "OMX.SEC.FP.AVC.Decoder")) {
+        switch (eNativeColorFormat) {
+            case OMX_COLOR_FormatYUV420SemiPlanar:
+                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
+                break;
+            case OMX_COLOR_FormatYUV420Planar:
+            default:
+                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
+                break;
+        }
+    }
+}
+#endif
+
 status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_US);
 
@@ -984,6 +1147,21 @@ status_t ACodec::setSupportedOutputFormat() {
     format.nPortIndex = kPortIndexOutput;
     format.nIndex = 0;
 
+#ifdef QCOM_HARDWARE
+    if (!strncmp(mComponentName.c_str(), "OMX.qcom",8)) {
+        int32_t reqdColorFormat = ColorFormatInfo::getPreferredFormat();
+        for(format.nIndex = 0;
+                (OK == mOMX->getParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format)));
+                format.nIndex++) {
+            if(format.eColorFormat == reqdColorFormat)
+                break;
+        }
+    }
+
+    LOGV("Video O/P format.nIndex 0x%x",format.nIndex);
+    LOGW("Video O/P format.eColorFormat 0x%x",format.eColorFormat);
+#endif
+
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamVideoPortFormat,
             &format, sizeof(format));
@@ -994,6 +1172,10 @@ status_t ACodec::setSupportedOutputFormat() {
            || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
            || format.eColorFormat == OMX_COLOR_FormatCbYCrY
            || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+#ifdef QCOM_HARDWARE
+           || format.eColorFormat == (OMX_COLOR_FORMATTYPE)OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+           || format.eColorFormat ==  (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
+#endif
            || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar);
 
     return mOMX->setParameter(
@@ -1060,7 +1242,11 @@ status_t ACodec::setVideoFormatOnPort(
 
     CHECK_EQ(err, (status_t)OK);
 
-    if (portIndex == kPortIndexInput) {
+    if (portIndex == kPortIndexInput
+#ifdef QCOM_HARDWARE
+            && !mSmoothStreaming
+#endif
+            ) {
         // XXX Need a (much) better heuristic to compute input buffer sizes.
         const size_t X = 64 * 1024;
         if (def.nBufferSize < X) {
@@ -1070,8 +1256,14 @@ status_t ACodec::setVideoFormatOnPort(
 
     CHECK_EQ((int)def.eDomain, (int)OMX_PortDomainVideo);
 
-    video_def->nFrameWidth = width;
-    video_def->nFrameHeight = height;
+#ifdef QCOM_HARDWARE
+    if (!mSmoothStreaming) {
+#endif
+        video_def->nFrameWidth = width;
+        video_def->nFrameHeight = height;
+#ifdef QCOM_HARDWARE
+    }
+#endif
 
     if (portIndex == kPortIndexInput) {
         video_def->eCompressionFormat = compressionFormat;
@@ -1114,7 +1306,7 @@ bool ACodec::allYourBuffersAreBelongToUs(
 
         if (info->mStatus != BufferInfo::OWNED_BY_US
                 && info->mStatus != BufferInfo::OWNED_BY_NATIVE_WINDOW) {
-            LOGV("[%s] Buffer %p on port %ld still has status %d",
+            LOGE("[%s] Buffer %p on port %ld still has status %d",
                     mComponentName.c_str(),
                     info->mBufferID, portIndex, info->mStatus);
             return false;
@@ -1187,6 +1379,22 @@ void ACodec::sendFormatChange() {
             CHECK_LE(rect.nLeft + rect.nWidth - 1, videoDef->nFrameWidth);
             CHECK_LE(rect.nTop + rect.nHeight - 1, videoDef->nFrameHeight);
 
+#ifdef QCOM_HARDWARE
+            int format = (def.format.video.eColorFormat == (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka)?
+                 HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED : def.format.video.eColorFormat;
+
+
+            if( mSmoothStreaming ) {
+               //call Update buffer geometry here
+                status_t err = mNativeWindow.get()->perform(mNativeWindow.get(),
+                                         NATIVE_WINDOW_UPDATE_BUFFERS_GEOMETRY,
+                                         videoDef->nFrameWidth, videoDef->nFrameHeight, format);
+               if( err != OK ) {
+                   LOGE("native_window_update_buffers_geometry failed in SS mode %d", err);
+               }
+            }
+#endif
+
             notify->setRect(
                     "crop",
                     rect.nLeft,
@@ -1241,6 +1449,120 @@ void ACodec::sendFormatChange() {
     mSentFormat = true;
 }
 
+#ifdef QCOM_HARDWARE
+status_t ACodec::InitSmoothStreaming() {
+
+    // get Extension index for smooth streaming
+    QOMX_INDEXEXTRADATATYPE extraDataType;
+    OMX_INDEXTYPE indexType;
+    status_t err = mOMX->getExtensionIndex(mNode, const_cast<char *>(OMX_QCOM_INDEX_PARAM_INDEXEXTRADATA), &indexType);
+    if (err != OK) {
+        LOGE("InitSmoothStreaming Error in getExtensionIndex %d", err);
+        return err;
+    }
+
+    //Enable smooth streaming
+    extraDataType.nPortIndex = kPortIndexOutput;
+    extraDataType.nIndex = OMX_IndexParamPortDefinition;
+    extraDataType.bEnabled = OMX_TRUE;
+
+    // call set_parameter
+    err = mOMX->setParameter(mNode, indexType, &extraDataType, sizeof(extraDataType));
+    if (err != OMX_ErrorNone) {
+        LOGE("InitSmoothStreaming setParam failed for extradata");
+        return err;
+    }
+
+    LOGI("InitSmoothStreaming - Smooth streaming mode enabled");
+
+    //Get buffer count for min resolution for input port
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexInput;
+
+    OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
+    err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,&def, sizeof(def));
+    if (err != OK) {
+        LOGE("InitSmoothStreaming getParam failed for input");
+        return err;
+    }
+    LOGV("ISS getParam Input buffer count actual = %lu, min %lu, size= %lu, ",
+            def.nBufferCountActual, def.nBufferCountMin, def.nBufferSize);
+
+    //set parameter for input port for min resolution for buffer count
+    video_def->nFrameWidth = MIN_WIDTH;
+    video_def->nFrameHeight = MIN_HEIGHT;
+    err = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+    if (err != OMX_ErrorNone) {
+        LOGE("InitSmoothStreaming SetParam failed for input port");
+        return err;
+    }
+    LOGV("ISS setParam Input buffer count actual = %lu, min %lu, size= %lu, ",
+            def.nBufferCountActual, def.nBufferCountMin, def.nBufferSize);
+
+    uint32_t maxBufferCnt = 0;
+    uint32_t maxBufferSize = 0;
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexOutput;
+    err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,&def, sizeof(def));
+    if (err != OK) {
+        LOGE("InitSmoothStreaming getParam failed for output");
+        return err;
+    }
+    LOGV("ISS getParam Output buffer count actual = %lu, min %lu, size= %lu, ",
+            def.nBufferCountActual, def.nBufferCountMin, def.nBufferSize);
+    maxBufferCnt = def.nBufferCountActual;
+
+    // Query buffer count for max resolution
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexInput;
+    video_def = &def.format.video;
+    err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,&def, sizeof(def));
+    if (err != OK) {
+        LOGE("InitSmoothStreaming getParam failed for input");
+        return err;
+    }
+    LOGV("ISS getParam Input buffer count actual = %lu, min %lu, size= %lu, ",
+            def.nBufferCountActual, def.nBufferCountMin, def.nBufferSize);
+
+    //set parameter for input port for max resolution for buffer count
+    video_def->nFrameWidth = MAX_WIDTH;
+    video_def->nFrameHeight = MAX_HEIGHT;
+    err = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+    if (err != OMX_ErrorNone) {
+        LOGE("InitSmoothStreaming SetParam failed for input port");
+        return err;
+    }
+
+    // query buffer size for max resolution
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexOutput;
+    err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+    if (err != OMX_ErrorNone) {
+        LOGE("InitSmoothStreaming OMX_GetParameter OMX_IndexParamPortDefinition failed");
+        return err;
+    }
+    LOGV("ISS getParam Output buffer count actual = %lu, min %lu, size= %lu, ",
+            def.nBufferCountActual, def.nBufferCountMin, def.nBufferSize);
+    maxBufferSize = def.nBufferSize;
+
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexOutput;
+    def.nBufferSize = maxBufferSize;
+    def.nBufferCountActual = maxBufferCnt;
+    video_def->nFrameWidth = MAX_WIDTH;
+    video_def->nFrameHeight = MAX_HEIGHT;
+    err = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+    if (err != OMX_ErrorNone) {
+        LOGE("InitSmoothStreaming SetParam failed for input port");
+        return err;
+    }
+    LOGV("ISS final Output buffer count actual = %lu, min %lu, size= %lu, ",
+            def.nBufferCountActual, def.nBufferCountMin, def.nBufferSize);
+    return OK;
+}
+#endif
+
 void ACodec::signalError(OMX_ERRORTYPE error) {
     sp<AMessage> notify = mNotify->dup();
     notify->setInt32("what", ACodec::kWhatError);
@@ -1575,6 +1897,47 @@ void ACodec::BaseState::getMoreInputDataIfPossible() {
     postFillThisBuffer(eligible);
 }
 
+#ifdef QCOM_HARDWARE
+void ACodec::BaseState::HandleExtraData(IOMX::buffer_id bufferID) {
+    OMX_OTHER_EXTRADATATYPE *pExtra;
+    OMX_BUFFERHEADERTYPE* pBufHdr = (OMX_BUFFERHEADERTYPE*)bufferID;
+    OMX_U32 uExtraData = (OMX_U32)pBufHdr->pBuffer + pBufHdr->nOffset + pBufHdr->nFilledLen;
+
+    uExtraData = (uExtraData + 3) & (~3); // 4 bytes aligned
+    pExtra = (OMX_OTHER_EXTRADATATYPE *)uExtraData;
+    while((uExtraData <= pBufHdr->nAllocLen) && (pExtra->eType != OMX_ExtraDataNone) &&
+          ((OMX_QCOM_EXTRADATATYPE)pExtra->eType != OMX_ExtraDataPortDef)) {
+
+        uExtraData += pExtra->nSize;
+        uExtraData = (uExtraData + 3) & (~3); // 4 bytes aligned
+        pExtra = (OMX_OTHER_EXTRADATATYPE *)uExtraData;
+    }
+
+    if((OMX_QCOM_EXTRADATATYPE)pExtra->eType == OMX_ExtraDataPortDef)
+    {
+        OMX_PARAM_PORTDEFINITIONTYPE* pPortDef;
+        pPortDef = (OMX_PARAM_PORTDEFINITIONTYPE *)pExtra->data;
+
+         //compare portDefi from extra data & output port def that we stored earlier
+        if ((pPortDef->format.video.nFrameWidth != mCodec->mOutputPortDef.format.video.nFrameWidth) ||
+                    (pPortDef->format.video.nFrameHeight != mCodec->mOutputPortDef.format.video.nFrameHeight) ||
+                    (pPortDef->format.video.nStride!= mCodec->mOutputPortDef.format.video.nStride) ||
+                    (pPortDef->format.video.nSliceHeight != mCodec->mOutputPortDef.format.video.nSliceHeight)) {
+             // set display parameteres if video size changed
+             LOGI("Resolution change detected, new size "
+               "w = %lu, h = %lu, stride = %lu, sliceht = %lu \n",
+                 pPortDef->format.video.nFrameWidth,
+                 pPortDef->format.video.nFrameHeight,
+                 pPortDef->format.video.nStride,
+                 pPortDef->format.video.nSliceHeight);
+
+             mCodec->mOutputPortDef = *pPortDef;
+             mCodec->mSentFormat = false;
+        }
+    }
+}
+#endif
+
 bool ACodec::BaseState::onOMXFillBufferDone(
         IOMX::buffer_id bufferID,
         size_t rangeOffset, size_t rangeLength,
@@ -1632,6 +1995,9 @@ bool ACodec::BaseState::onOMXFillBufferDone(
                     new AMessage(kWhatOutputBufferDrained, mCodec->id());
 
                 reply->setPointer("buffer-id", info->mBufferID);
+#ifdef QCOM_HARDWARE
+                reply->setInt32("flags", flags);
+#endif
 
                 notify->setMessage("reply", reply);
 
@@ -1673,6 +2039,13 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
         mCodec->findBufferByID(kPortIndexOutput, bufferID, &index);
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_DOWNSTREAM);
 
+#ifdef QCOM_HARDWARE
+    int32_t flags;
+    CHECK(msg->findInt32("flags", &flags));
+    if (mCodec->mSmoothStreaming && (flags & OMX_BUFFERFLAG_EXTRADATA)) {
+        HandleExtraData( bufferID );
+    }
+#endif
     int32_t render;
     if (mCodec->mNativeWindow != NULL
             && msg->findInt32("render", &render) && render != 0) {
@@ -1844,6 +2217,23 @@ void ACodec::UninitializedState::onSetup(
 
     mCodec->mInputEOSResult = OK;
 
+#ifdef QCOM_HARDWARE
+    char value[PROPERTY_VALUE_MAX];
+    if(property_get("hls.enable.smooth.streaming", value, NULL) &&
+      (!strcasecmp(value, "true") || !strcmp(value, "1")) &&
+      (!strcmp("OMX.qcom.video.decoder.avc", mCodec->mComponentName.c_str())) ) {
+
+        LOGI("Enable Smooth streaming");
+        mCodec->mSmoothStreaming = true;
+        status_t err = mCodec->InitSmoothStreaming();
+        if (err != OK) {
+           LOGE("Error in enabling smooth streaming, ignore & disable ");
+           mCodec->mSmoothStreaming = false;
+        } else {
+            LOGI("Smooth streaming is enabled ");
+        }
+    }
+#endif
     mCodec->configureCodec(mime.c_str(), msg);
 
     sp<RefBase> obj;
@@ -1895,6 +2285,7 @@ status_t ACodec::LoadedToIdleState::allocateBuffers() {
 bool ACodec::LoadedToIdleState::onMessageReceived(const sp<AMessage> &msg) {
     switch (msg->what()) {
         case kWhatShutdown:
+        case kWhatFlush:
         {
             mCodec->deferMessage(msg);
             return true;
@@ -1939,6 +2330,7 @@ void ACodec::IdleToExecutingState::stateEntered() {
 
 bool ACodec::IdleToExecutingState::onMessageReceived(const sp<AMessage> &msg) {
     switch (msg->what()) {
+        case kWhatFlush:
         case kWhatShutdown:
         {
             mCodec->deferMessage(msg);
@@ -2100,14 +2492,22 @@ bool ACodec::ExecutingState::onOMXEvent(
             CHECK_EQ(data1, (OMX_U32)kPortIndexOutput);
 
             if (data2 == 0 || data2 == OMX_IndexParamPortDefinition) {
+                LOGV("Flush output port before disable");
                 CHECK_EQ(mCodec->mOMX->sendCommand(
+#ifdef QCOM_HARDWARE
+                        mCodec->mNode, OMX_CommandFlush, kPortIndexOutput),
+#else
                             mCodec->mNode,
                             OMX_CommandPortDisable, kPortIndexOutput),
-                         (status_t)OK);
+#endif
+                     (status_t)OK);
 
+#ifdef QCOM_HARDWARE
+                mCodec->changeState(mCodec->mFlushingOutputState);
+#else
                 mCodec->freeOutputBuffersNotOwnedByComponent();
-
                 mCodec->changeState(mCodec->mOutputPortSettingsChangedState);
+#endif
             } else if (data2 == OMX_IndexConfigCommonOutputCrop) {
                 mCodec->mSentFormat = false;
             } else {
@@ -2117,6 +2517,13 @@ bool ACodec::ExecutingState::onOMXEvent(
 
             return true;
         }
+#ifdef QCOM_HARDWARE
+        case OMX_EventIndexsettingChanged:
+        {
+            LOGV("[%s] Received OMX_EventIndexsettingChanged event ", mCodec->mComponentName.c_str());
+            return true;
+        }
+#endif
 
         case OMX_EventBufferFlag:
         {
@@ -2517,4 +2924,118 @@ void ACodec::FlushingState::changeStateIfWeOwnAllBuffers() {
     }
 }
 
+#ifdef QCOM_HARDWARE
+////////////////////////////////////////////////////////////////////////////////
+
+ACodec::FlushingOutputState::FlushingOutputState(ACodec *codec)
+    : BaseState(codec) {
+}
+
+void ACodec::FlushingOutputState::stateEntered() {
+    LOGV("[%s] Now Flushing Output Port", mCodec->mComponentName.c_str());
+
+    mFlushComplete = false;
+}
+
+bool ACodec::FlushingOutputState::onMessageReceived(const sp<AMessage> &msg) {
+    bool handled = false;
+
+    switch (msg->what()) {
+        case kWhatShutdown:
+        {
+            mCodec->deferMessage(msg);
+            break;
+        }
+
+        case kWhatFlush:
+        {
+            LOGV("Flush received during port reconfig, deferring it");
+            mCodec->deferMessage(msg);
+            break;
+        }
+        default:
+            handled = BaseState::onMessageReceived(msg);
+            break;
+    }
+
+    return handled;
+}
+
+bool ACodec::FlushingOutputState::onOMXEvent(
+        OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
+    switch (event) {
+        case OMX_EventCmdComplete:
+        {
+            CHECK_EQ(data1, (OMX_U32)OMX_CommandFlush);
+            CHECK_EQ(data2,(OMX_U32)kPortIndexOutput);
+            LOGV("FlushingOutputState::onOMXEvent Output port flush complete");
+            mFlushComplete = true;
+            changeStateIfWeOwnAllBuffers();
+            return true;
+        }
+
+        case OMX_EventPortSettingsChanged:
+        {
+            sp<AMessage> msg = new AMessage(kWhatOMXMessage, mCodec->id());
+            msg->setInt32("type", omx_message::EVENT);
+            msg->setPointer("node", mCodec->mNode);
+            msg->setInt32("event", event);
+            msg->setInt32("data1", data1);
+            msg->setInt32("data2", data2);
+
+            LOGV("[%s] Deferring OMX_EventPortSettingsChanged",
+                 mCodec->mComponentName.c_str());
+
+            mCodec->deferMessage(msg);
+
+            return true;
+        }
+
+        default:
+            return BaseState::onOMXEvent(event, data1, data2);
+    }
+
+    return true;
+}
+
+void ACodec::FlushingOutputState::onOutputBufferDrained(const sp<AMessage> &msg) {
+    BaseState::onOutputBufferDrained(msg);
+
+    changeStateIfWeOwnAllBuffers();
+}
+
+void ACodec::FlushingOutputState::onInputBufferFilled(const sp<AMessage> &msg) {
+    BaseState::onInputBufferFilled(msg);
+
+    changeStateIfWeOwnAllBuffers();
+}
+
+void ACodec::FlushingOutputState::changeStateIfWeOwnAllBuffers() {
+   LOGV("FlushingOutputState::ChangeState %d",mFlushComplete);
+   if (mFlushComplete && mCodec->allYourBuffersAreBelongToUs( kPortIndexOutput )) {
+        /*** TO DO - Enable this when display API is available ***/
+        /*
+        LOGV("sending native window reconfigure for after port reconfig");
+        status_t err = native_window_reconfigure_buffers(mCodec->mNativeWindow.get());
+        if(err != 0){
+           LOGV("native_window_reconfigure_buffers call failed\n");
+        }
+        */
+        LOGV("FlushingOutputState Sending port disable ");
+        CHECK_EQ(mCodec->mOMX->sendCommand(
+                            mCodec->mNode,
+                            OMX_CommandPortDisable, kPortIndexOutput),
+                         (status_t)OK);
+
+        mCodec->mPortEOS[kPortIndexInput] = false;
+        mCodec->mPortEOS[kPortIndexOutput] = false;
+
+        LOGV("FlushingOutputState Calling freeOutputBuffersNotOwnedByComponent");
+        mCodec->freeOutputBuffersNotOwnedByComponent();
+
+        LOGV("FlushingOutputState Change state to port settings changed");
+        mCodec->changeState(mCodec->mOutputPortSettingsChangedState);
+    }
+}
+#endif
 }  // namespace android
diff --git a/media/libstagefright/AMRExtractor.cpp b/media/libstagefright/AMRExtractor.cpp
index 7eca5e4..bceffb5 100644
--- a/media/libstagefright/AMRExtractor.cpp
+++ b/media/libstagefright/AMRExtractor.cpp
@@ -337,12 +337,12 @@ bool SniffAMR(
 
     if (!memcmp(header, "#!AMR\n", 6)) {
         *mimeType = MEDIA_MIMETYPE_AUDIO_AMR_NB;
-        *confidence = 0.5;
+        *confidence = 0.6;
 
         return true;
     } else if (!memcmp(header, "#!AMR-WB\n", 9)) {
         *mimeType = MEDIA_MIMETYPE_AUDIO_AMR_WB;
-        *confidence = 0.5;
+        *confidence = 0.6;
 
         return true;
     }
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 690deac..4cb0895 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -1,6 +1,33 @@
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+ifeq ($(TARGET_BOARD_PLATFORM),msm7x27a)
+    LOCAL_CFLAGS += -DUSE_AAC_HW_DEC
+endif
+
+ifeq ($(TARGET_BOARD_PLATFORM),msm7x27)
+    LOCAL_CFLAGS += -DTARGET7x27
+endif
+ifeq ($(TARGET_BOARD_PLATFORM),msm7x27a)
+    LOCAL_CFLAGS += -DTARGET7x27A
+endif
+ifeq ($(TARGET_BOARD_PLATFORM),msm7x30)
+    LOCAL_CFLAGS += -DTARGET7x30
+endif
+ifeq ($(TARGET_BOARD_PLATFORM),qsd8k)
+    LOCAL_CFLAGS += -DTARGET8x50
+endif
+ifeq ($(TARGET_BOARD_PLATFORM),msm8660)
+    LOCAL_CFLAGS += -DTARGET8x60
+endif
+ifeq ($(TARGET_BOARD_PLATFORM),msm8960)
+    LOCAL_CFLAGS += -DTARGET8x60
+endif
+ifeq ($(BOARD_CAMERA_USE_MM_HEAP),true)
+    LOCAL_CFLAGS += -DCAMERA_MM_HEAP
+endif
+endif
 include frameworks/base/media/libstagefright/codecs/common/Config.mk
 
 LOCAL_SRC_FILES:=                         \
@@ -52,14 +79,38 @@ LOCAL_SRC_FILES:=                         \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
 
-LOCAL_C_INCLUDES:= \
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+        LOCAL_SRC_FILES += ExtendedExtractor.cpp
+        LOCAL_SRC_FILES += ExtendedWriter.cpp
+	LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/display/libqcomui
+endif
+
+ifeq ($(TARGET_USES_QCOM_LPA),true)
+ifeq ($(BOARD_USES_ALSA_AUDIO),true)
+	LOCAL_SRC_FILES += LPAPlayerALSA.cpp
+	LOCAL_C_INCLUDES += $(TARGET_OUT_HEADERS)/mm-audio/libalsa-intf
+	LOCAL_C_INCLUDES += $(TOP)/hardware/libhardware_legacy/include
+	LOCAL_SHARED_LIBRARIES += libalsa-intf
+	LOCAL_SHARED_LIBRARIES += libhardware_legacy
+	LOCAL_SHARED_LIBRARIES += libpowermanager
+else
+	LOCAL_SRC_FILES += LPAPlayer.cpp
+ifeq ($(TARGET_USES_ION_AUDIO),true)
+	LOCAL_SRC_FILES += LPAPlayerION.cpp
+else
+	LOCAL_SRC_FILES += LPAPlayerPMEM.cpp
+endif
+endif
+endif
+
+LOCAL_C_INCLUDES+= \
 	$(JNI_H_INCLUDE) \
         $(TOP)/frameworks/base/include/media/stagefright/openmax \
         $(TOP)/external/flac/include \
         $(TOP)/external/tremolo \
-        $(TOP)/external/openssl/include \
+        $(TOP)/external/openssl/include
 
-LOCAL_SHARED_LIBRARIES := \
+LOCAL_SHARED_LIBRARIES += \
         libbinder         \
         libmedia          \
         libutils          \
@@ -89,6 +140,20 @@ LOCAL_STATIC_LIBRARIES := \
         libstagefright_id3 \
         libFLAC \
 
+ifeq ($(TARGET_USES_QCOM_LPA),true)
+LOCAL_STATIC_LIBRARIES += \
+		libstagefright_aacdec \
+	    libstagefright_mp3dec
+endif
+
+ifeq ($(BOARD_HAVE_CODEC_SUPPORT),SAMSUNG_CODEC_SUPPORT)
+LOCAL_CFLAGS     += -DSAMSUNG_CODEC_SUPPORT
+endif
+
+ifeq ($(BOARD_USES_PROPRIETARY_OMX),SAMSUNG)
+LOCAL_CFLAGS     += -DSAMSUNG_OMX
+endif
+
 ################################################################################
 
 # The following was shamelessly copied from external/webkit/Android.mk and
@@ -148,6 +213,13 @@ LOCAL_SHARED_LIBRARIES += \
 
 LOCAL_CFLAGS += -Wno-multichar
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+        LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/display/libgralloc
+        LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+        LOCAL_C_INCLUDES += $(TOP)/system/core/include
+        LOCAL_C_INCLUDES += $(TOP)/hardware/libhardware_legacy/include
+endif
+
 LOCAL_MODULE:= libstagefright
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index f4fb556..ea04288 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -50,6 +50,9 @@ AudioPlayer::AudioPlayer(
       mFirstBufferResult(OK),
       mFirstBuffer(NULL),
       mAudioSink(audioSink),
+#ifdef QCOM_HARDWARE
+      mSourcePaused(false),
+#endif
       mObserver(observer) {
 }
 
@@ -70,6 +73,9 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
 
     status_t err;
     if (!sourceAlreadyStarted) {
+#ifdef QCOM_HARDWARE
+        mSourcePaused = false;
+#endif
         err = mSource->start();
 
         if (err != OK) {
@@ -189,11 +195,23 @@ void AudioPlayer::pause(bool playPendingSamples) {
             mAudioTrack->pause();
         }
     }
+#ifdef QCOM_HARDWARE
+    CHECK(mSource != NULL);
+    if (mSource->pause() == OK) {
+        mSourcePaused = true;
+    }
+#endif
 }
 
 void AudioPlayer::resume() {
     CHECK(mStarted);
-
+#ifdef QCOM_HARDWARE
+    CHECK(mSource != NULL);
+    if (mSourcePaused == true) {
+        mSourcePaused = false;
+        mSource->start();
+    }
+#endif
     if (mAudioSink.get() != NULL) {
         mAudioSink->start();
     } else {
@@ -228,7 +246,9 @@ void AudioPlayer::reset() {
         mInputBuffer->release();
         mInputBuffer = NULL;
     }
-
+#ifdef QCOM_HARDWARE
+    mSourcePaused = false;
+#endif
     mSource->stop();
 
     // The following hack is necessary to ensure that the OMX
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index bc45f83..bf37b10 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -38,6 +38,9 @@
 #include <media/stagefright/foundation/hexdump.h>
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/AudioPlayer.h>
+#ifdef WITH_QCOM_LPA
+#include <media/stagefright/LPAPlayer.h>
+#endif
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/FileSource.h>
 #include <media/stagefright/MediaBuffer.h>
@@ -52,11 +55,19 @@
 #include <gui/SurfaceTextureClient.h>
 #include <surfaceflinger/ISurfaceComposer.h>
 
+#include <cutils/properties.h>
+
+#include <media/stagefright/foundation/ALooper.h>
 #include <media/stagefright/foundation/AMessage.h>
 
 #include <cutils/properties.h>
 
+#ifdef QCOM_LEGACY_OMX
+// Disable rendering directly to NativeWindow
+#define USE_SURFACE_ALLOC 0
+#else
 #define USE_SURFACE_ALLOC 1
+#endif
 #define FRAME_DROP_FREQ 0
 
 namespace android {
@@ -211,6 +222,28 @@ AwesomePlayer::AwesomePlayer()
 
     mAudioStatusEventPending = false;
 
+    // for qualcomm statistics profiling
+    char value[PROPERTY_VALUE_MAX];
+    mStatistics = false;
+    property_get("persist.debug.sf.statistics", value, "0");
+    if(atoi(value)) mStatistics = true;
+    {
+        Mutex::Autolock autoLock(mStatsLock);
+        mStats.mNumVideoFramesDecoded = 0;
+        mStats.mNumVideoFramesDropped = 0;
+
+        mStats.mConsecutiveFramesDropped = 0;
+        mStats.mCatchupTimeStart = 0;
+        mStats.mNumTimesSyncLoss = 0;
+        mStats.mMaxEarlyDelta = 0;
+        mStats.mMaxLateDelta = 0;
+        mStats.mMaxTimeSyncLoss = 0;
+        mStats.mTotalFrames = 0;
+        mStats.mLastFrame = 0;
+        mStats.mLastFrameUs = 0;
+        mStats.mStatisticsFrames = 0;
+        mStats.mFPSSumUs = 0;
+    }
     reset();
 }
 
@@ -219,6 +252,13 @@ AwesomePlayer::~AwesomePlayer() {
         mQueue.stop();
     }
 
+    if (mStatistics) {
+        Mutex::Autolock autoLock(mStatsLock);
+        LOGW("=========================================================");
+        LOGW("Average Frames Per Second: %.4f", mStats.mFPSSumUs/((double)mStats.mStatisticsFrames));
+        LOGW("========================================================");
+    }
+
     reset();
 
     mClient.disconnect();
@@ -499,6 +539,11 @@ void AwesomePlayer::reset_l() {
     }
 
     cancelPlayerEvents();
+    if(mStatistics && mVideoSource != NULL){
+        Mutex::Autolock autolock(mStatsLock);
+        logStatistics();
+        logSyncLoss();
+    }
 
     mWVMExtractor.clear();
     mCachedSource.clear();
@@ -520,8 +565,8 @@ void AwesomePlayer::reset_l() {
     mAudioSource.clear();
 
     mTimeSource = NULL;
-
     delete mAudioPlayer;
+
     mAudioPlayer = NULL;
 
     if (mTextPlayer != NULL) {
@@ -560,8 +605,6 @@ void AwesomePlayer::reset_l() {
         mStats.mBitrate = -1;
         mStats.mAudioTrackIndex = -1;
         mStats.mVideoTrackIndex = -1;
-        mStats.mNumVideoFramesDecoded = 0;
-        mStats.mNumVideoFramesDropped = 0;
         mStats.mVideoWidth = -1;
         mStats.mVideoHeight = -1;
         mStats.mFlags = 0;
@@ -818,6 +861,13 @@ void AwesomePlayer::onStreamDone() {
 
         if (mVideoSource != NULL) {
             postVideoEvent_l();
+
+            if(mStatistics)
+            {
+                Mutex::Autolock autolock(mStatsLock);
+                logStatistics();
+                logSyncLoss();
+            }
         }
     } else {
         LOGV("MEDIA_PLAYBACK_COMPLETE");
@@ -865,7 +915,52 @@ status_t AwesomePlayer::play_l() {
     if (mAudioSource != NULL) {
         if (mAudioPlayer == NULL) {
             if (mAudioSink != NULL) {
+#ifndef WITH_QCOM_LPA
                 mAudioPlayer = new AudioPlayer(mAudioSink, this);
+#else
+                sp<MetaData> format = mAudioTrack->getFormat();
+                const char *mime;
+                bool success = format->findCString(kKeyMIMEType, &mime);
+                CHECK(success);
+
+                int64_t durationUs;
+                success = format->findInt64(kKeyDuration, &durationUs);
+                /*
+                 * Some clips may not have kKeyDuration set, especially so for clips in a MP3
+                 * container with the Frames field absent in the Xing header.
+                 */
+                if (!success)
+                    durationUs = 0;
+
+                LOGV("LPAPlayer::getObjectsAlive() %d",LPAPlayer::objectsAlive);
+                int32_t isFormatAdif = 0;
+                format->findInt32(kkeyAacFormatAdif, &isFormatAdif);
+
+                char lpaDecode[128];
+                property_get("lpa.decode",lpaDecode,"0");
+                if(strcmp("true",lpaDecode) == 0)
+                {
+                    LOGV("LPAPlayer::getObjectsAlive() %d",LPAPlayer::objectsAlive);
+                    int streamType = mAudioSink->getAudioStreamType();
+                    if ( durationUs > 60000000 && !isFormatAdif
+                         && (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG) || !strcasecmp(mime,MEDIA_MIMETYPE_AUDIO_AAC))
+                         && LPAPlayer::objectsAlive == 0 && mVideoSource == NULL && streamType == AUDIO_STREAM_MUSIC) {
+                        LOGE("LPAPlayer created, LPA MODE detected mime %s duration %lld AudioStream %d", mime, durationUs,streamType);
+                        bool initCheck =  false;
+                        mAudioPlayer = new LPAPlayer(mAudioSink, initCheck, this);
+                        if(!initCheck) {
+                            delete mAudioPlayer;
+                            mAudioPlayer = NULL;
+                        }
+                    }
+                }
+                if(mAudioPlayer == NULL) {
+                    LOGE("AudioPlayer created, Non-LPA mode mime %s duration %d\n", mime, durationUs);
+                    mAudioPlayer = new AudioPlayer(mAudioSink, this);
+                }
+
+                LOGV("Setting Audio source");
+#endif
                 mAudioPlayer->setSource(mAudioSource);
 
                 mTimeSource = mAudioPlayer;
@@ -907,6 +1002,12 @@ status_t AwesomePlayer::play_l() {
         mTimeSource = &mSystemTimeSource;
     }
 
+    if(mStatistics) {
+        Mutex::Autolock autoLock(mStatsLock);
+        mStats.mFirstFrameLatencyStartUs = getTimeOfDayUs();
+        mStats.mVeryFirstFrame = true;
+    }
+
     if (mVideoSource != NULL) {
         // Kick off video playback
         postVideoEvent_l();
@@ -1123,6 +1224,11 @@ status_t AwesomePlayer::pause_l(bool at_eos) {
                 Playback::PAUSE, 0);
     }
 
+    if(mStatistics && !(mFlags & AT_EOS)){
+        Mutex::Autolock autoLock(mStatsLock);
+        logPause();
+    }
+
     uint32_t params = IMediaPlayerService::kBatteryDataTrackDecoder;
     if ((mAudioSource != NULL) && (mAudioSource != mAudioTrack)) {
         params |= IMediaPlayerService::kBatteryDataTrackAudio;
@@ -1306,6 +1412,12 @@ status_t AwesomePlayer::seekTo_l(int64_t timeUs) {
     }
 
     mSeeking = SEEK;
+
+    if(mStatistics)
+    {
+        Mutex::Autolock autoLock(mStatsLock);
+        mStats.mFirstFrameLatencyStartUs = getTimeOfDayUs();
+    }
     mSeekNotificationSent = false;
     mSeekTimeUs = timeUs;
     modifyFlags((AT_EOS | AUDIO_AT_EOS | VIDEO_AT_EOS), CLEAR);
@@ -1374,10 +1486,42 @@ status_t AwesomePlayer::initAudioDecoder() {
     if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
         mAudioSource = mAudioTrack;
     } else {
+#ifdef WITH_QCOM_LPA
+        // For LPA Playback use the decoder without OMX layer
+        char lpaDecode[128];
+        char *matchComponentName = NULL;
+        property_get("lpa.decode",lpaDecode,"0");
+        if(strcmp("true",lpaDecode) == 0 && mVideoSource == NULL) {
+            const char *mime;
+            bool success = meta->findCString(kKeyMIMEType, &mime);
+            CHECK(success);
+            int64_t durationUs;
+            success = meta->findInt64(kKeyDuration, &durationUs);
+            if (!success) durationUs = 0;
+            int32_t isFormatAdif = 0;
+            meta->findInt32(kkeyAacFormatAdif, &isFormatAdif);
+
+            if ( (durationUs > 60000000) && !isFormatAdif && LPAPlayer::objectsAlive == 0) {
+                if(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
+                    LOGV("matchComponentName is set to MP3Decoder");
+                    matchComponentName= "MP3Decoder";
+                }
+                if(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
+                    LOGV("matchComponentName is set to AACDecoder");
+                    matchComponentName= "AACDecoder";
+                }
+            }
+        }
+#endif
         mAudioSource = OMXCodec::Create(
                 mClient.interface(), mAudioTrack->getFormat(),
                 false, // createEncoder
+#ifndef WITH_QCOM_LPA
                 mAudioTrack);
+#else
+                mAudioTrack,
+                matchComponentName);
+#endif
     }
 
     if (mAudioSource != NULL) {
@@ -1435,11 +1579,12 @@ status_t AwesomePlayer::initVideoDecoder(uint32_t flags) {
     //   (mSurface->getFlags() & ISurfaceComposer::eProtectedByApp))
     // will be true, but that part is already handled by SurfaceFlinger.
 
+    char value[PROPERTY_VALUE_MAX];
+
 #ifdef DEBUG_HDCP
     // For debugging, we allow a system property to control the protected usage.
     // In case of uninitialized or unexpected property, we default to "DRM only".
     bool setProtectionBit = false;
-    char value[PROPERTY_VALUE_MAX];
     if (property_get("persist.sys.hdcp_checking", value, NULL)) {
         if (!strcmp(value, "never")) {
             // nop
@@ -1470,6 +1615,13 @@ status_t AwesomePlayer::initVideoDecoder(uint32_t flags) {
         flags |= OMXCodec::kEnableGrallocUsageProtected;
     }
 #endif
+
+    property_get("sys.media.vdec.sw", value, "0");
+    if (atoi(value)) {
+        LOGW("Software Codec is preferred for Video");
+        flags |= OMXCodec::kPreferSoftwareCodecs;
+    }
+
     LOGV("initVideoDecoder flags=0x%x", flags);
     mVideoSource = OMXCodec::Create(
             mClient.interface(), mVideoTrack->getFormat(),
@@ -1558,6 +1710,11 @@ void AwesomePlayer::finishSeekIfNecessary(int64_t videoTimeUs) {
         mDrmManagerClient->setPlaybackStatus(mDecryptHandle,
                 Playback::START, videoTimeUs / 1000);
     }
+
+    if (mStatistics){
+        Mutex::Autolock autoLock(mStatsLock);
+        logSeek();
+    }
 }
 
 void AwesomePlayer::onVideoEvent() {
@@ -1701,18 +1858,25 @@ void AwesomePlayer::onVideoEvent() {
         modifyFlags(FIRST_FRAME, CLEAR);
         mSinceLastDropped = 0;
         mTimeSourceDeltaUs = ts->getRealTimeUs() - timeUs;
+
+        if(mStatistics)
+        {
+            Mutex::Autolock autoLock(mStatsLock);
+            if(mStats.mVeryFirstFrame)
+                logFirstFrame();
+        }
     }
 
-    int64_t realTimeUs, mediaTimeUs;
+    int64_t realTimeUs, mediaTimeUs, nowUs = 0, latenessUs = 0;
     if (!(mFlags & AUDIO_AT_EOS) && mAudioPlayer != NULL
         && mAudioPlayer->getMediaTimeMapping(&realTimeUs, &mediaTimeUs)) {
         mTimeSourceDeltaUs = realTimeUs - mediaTimeUs;
     }
 
     if (wasSeeking == SEEK_VIDEO_ONLY) {
-        int64_t nowUs = ts->getRealTimeUs() - mTimeSourceDeltaUs;
+        nowUs = ts->getRealTimeUs() - mTimeSourceDeltaUs;
 
-        int64_t latenessUs = nowUs - timeUs;
+        latenessUs = nowUs - timeUs;
 
         if (latenessUs > 0) {
             LOGI("after SEEK_VIDEO_ONLY we're late by %.2f secs", latenessUs / 1E6);
@@ -1722,9 +1886,9 @@ void AwesomePlayer::onVideoEvent() {
     if (wasSeeking == NO_SEEK) {
         // Let's display the first frame after seeking right away.
 
-        int64_t nowUs = ts->getRealTimeUs() - mTimeSourceDeltaUs;
+        nowUs = ts->getRealTimeUs() - mTimeSourceDeltaUs;
 
-        int64_t latenessUs = nowUs - timeUs;
+        latenessUs = nowUs - timeUs;
 
         if (latenessUs > 500000ll
                 && mAudioPlayer != NULL
@@ -1762,6 +1926,14 @@ void AwesomePlayer::onVideoEvent() {
                 {
                     Mutex::Autolock autoLock(mStatsLock);
                     ++mStats.mNumVideoFramesDropped;
+                    if(mStatistics) {
+                        mStats.mConsecutiveFramesDropped++;
+                        if (mStats.mConsecutiveFramesDropped == 1){
+                            mStats.mCatchupTimeStart = mTimeSource->getRealTimeUs();
+                        }
+
+                        if(!(mFlags & AT_EOS)) logLate(timeUs,nowUs,latenessUs);
+                    }
                 }
 
                 postVideoEvent_l();
@@ -1771,7 +1943,11 @@ void AwesomePlayer::onVideoEvent() {
 
         if (latenessUs < -10000) {
             // We're more than 10ms early.
-
+            logOnTime(timeUs,nowUs,latenessUs);
+            {
+                Mutex::Autolock autoLock(mStatsLock);
+                mStats.mConsecutiveFramesDropped = 0;
+            }
             postVideoEvent_l(10000);
             return;
         }
@@ -1787,6 +1963,25 @@ void AwesomePlayer::onVideoEvent() {
     if (mVideoRenderer != NULL) {
         mSinceLastDropped++;
         mVideoRenderer->render(mVideoBuffer);
+
+        if(mStatistics) {
+            Mutex::Autolock autoLock(mStatsLock);
+            logOnTime(timeUs,nowUs,latenessUs);
+            mStats.mTotalFrames++;
+            mStats.mConsecutiveFramesDropped = 0;
+
+            int64_t now = getTimeOfDayUs(),
+            diff = now - mStats.mLastFrameUs;
+            if (diff > 250000) {
+                float fps =((mStats.mTotalFrames - mStats.mLastFrame) * 1E6)/diff;
+                LOGW("Frames per second: %.4f", fps);
+
+                mStats.mFPSSumUs += fps;
+                mStats.mLastFrameUs = now;
+                mStats.mLastFrame = mStats.mTotalFrames;
+                ++mStats.mStatisticsFrames;
+            }
+        }
     }
 
     mVideoBuffer->release();
@@ -2361,4 +2556,85 @@ void AwesomePlayer::modifyFlags(unsigned value, FlagMode mode) {
     }
 }
 
+//Statistics profiling
+void AwesomePlayer::logStatistics() {
+    const char *mime;
+    mVideoTrack->getFormat()->findCString(kKeyMIMEType, &mime);
+    LOGW("=====================================================");
+    if (mFlags & LOOPING) {LOGW("Looping Update");}
+    LOGW("Mime Type: %s",mime);
+    LOGW("Number of frames dropped: %lld",mStats.mNumVideoFramesDropped);
+    LOGW("Number of frames rendered: %u",mStats.mTotalFrames);
+    LOGW("=====================================================");
+}
+
+inline void AwesomePlayer::logFirstFrame() {
+    LOGW("=====================================================");
+    LOGW("First frame latency: %lld ms",(getTimeOfDayUs()-mStats.mFirstFrameLatencyStartUs)/1000);
+    LOGW("=====================================================");
+    mStats.mVeryFirstFrame = false;
+}
+
+inline void AwesomePlayer::logSeek() {
+    LOGW("=====================================================");
+    LOGW("Seek position: %lld ms",mSeekTimeUs/1000);
+    LOGW("Seek latency: %lld ms",(getTimeOfDayUs()-mStats.mFirstFrameLatencyStartUs)/1000);
+    LOGW("=====================================================");
+}
+
+inline void AwesomePlayer::logPause() {
+    LOGW("=====================================================");
+    LOGW("Pause position: %lld ms",mVideoTimeUs/1000);
+    LOGW("=====================================================");
+}
+
+inline void AwesomePlayer::logCatchUp(int64_t ts, int64_t clock, int64_t delta)
+{
+    if (mStats.mConsecutiveFramesDropped > 0) {
+        mStats.mNumTimesSyncLoss++;
+        if (mStats.mMaxTimeSyncLoss < (clock - mStats.mCatchupTimeStart) && clock > 0 && ts > 0) {
+            mStats.mMaxTimeSyncLoss = clock - mStats.mCatchupTimeStart;
+        }
+    }
+}
+
+inline void AwesomePlayer::logLate(int64_t ts, int64_t clock, int64_t delta)
+{
+    if (mStats.mMaxLateDelta < delta && clock > 0 && ts > 0) {
+        mStats.mMaxLateDelta = delta;
+    }
+}
+
+inline void AwesomePlayer::logOnTime(int64_t ts, int64_t clock, int64_t delta)
+{
+    bool needLogLate = false;
+    logCatchUp(ts, clock, delta);
+    if (delta <= 0) {
+        if ((-delta) > (-mStats.mMaxEarlyDelta) && clock > 0 && ts > 0) {
+            mStats.mMaxEarlyDelta = delta;
+        }
+    }
+    else {
+        needLogLate = true;
+    }
+
+    if(needLogLate) logLate(ts, clock, delta);
+}
+
+void AwesomePlayer::logSyncLoss()
+{
+    LOGW("=====================================================");
+    LOGW("Number of times AV Sync Losses = %u", mStats.mNumTimesSyncLoss);
+    LOGW("Max Video Ahead time delta = %u", -mStats.mMaxEarlyDelta/1000);
+    LOGW("Max Video Behind time delta = %u", mStats.mMaxLateDelta/1000);
+    LOGW("Max Time sync loss = %u",mStats.mMaxTimeSyncLoss/1000);
+    LOGW("=====================================================");
+}
+
+inline int64_t AwesomePlayer::getTimeOfDayUs() {
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+
+    return (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;
+}
 }  // namespace android
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 57989c5..d79df77 100755
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -87,6 +87,10 @@ void CameraSourceListener::postDataTimestamp(
 }
 
 static int32_t getColorFormat(const char* colorFormat) {
+#ifdef QCOM_HARDWARE
+    return OMX_COLOR_FormatYUV420SemiPlanar;
+#endif
+
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
        return OMX_COLOR_FormatYUV420Planar;
     }
@@ -96,7 +100,12 @@ static int32_t getColorFormat(const char* colorFormat) {
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
+#ifdef EXYNOS4210_ENHANCEMENTS
+        static const int OMX_SEC_COLOR_FormatNV12LPhysicalAddress = 0x7F000002;
+        return OMX_SEC_COLOR_FormatNV12LPhysicalAddress;
+#else
         return OMX_COLOR_FormatYUV420SemiPlanar;
+#endif
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV422I)) {
@@ -267,8 +276,12 @@ static void getSupportedVideoSizes(
  */
 status_t CameraSource::isCameraColorFormatSupported(
         const CameraParameters& params) {
-    mColorFormat = getColorFormat(params.get(
-            CameraParameters::KEY_VIDEO_FRAME_FORMAT));
+    const char* fmt = params.get(CameraParameters::KEY_VIDEO_FRAME_FORMAT);
+    if (!fmt) {
+        LOGE("Missing parameter %s!", CameraParameters::KEY_VIDEO_FRAME_FORMAT);
+        return BAD_VALUE;
+    }
+    mColorFormat = getColorFormat(fmt);
     if (mColorFormat == -1) {
         return BAD_VALUE;
     }
@@ -528,6 +541,18 @@ status_t CameraSource::initWithCameraAccess(
         }
     }
 
+#ifdef QCOM_HARDWARE
+    const char *hfr_str = params.get("video-hfr");
+    int32_t hfr = -1;
+    if ( hfr_str != NULL ) {
+      hfr = atoi(hfr_str);
+    }
+    if(hfr < 0) {
+      LOGW("Invalid hfr value(%d) set from app. Disabling HFR.", hfr);
+      hfr = 0;
+    }
+#endif
+
     int64_t glitchDurationUs = (1000000LL / mVideoFrameRate);
     if (glitchDurationUs > mGlitchDurationThresholdUs) {
         mGlitchDurationThresholdUs = glitchDurationUs;
@@ -543,6 +568,9 @@ status_t CameraSource::initWithCameraAccess(
     mMeta->setInt32(kKeyStride,      mVideoSize.width);
     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
+#ifdef QCOM_HARDWARE
+    mMeta->setInt32(kKeyHFR, hfr);
+#endif
     return OK;
 }
 
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
old mode 100644
new mode 100755
index 43539bb..66a16c1
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2010-2012 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,6 +27,13 @@
 #include "include/DRMExtractor.h"
 #include "include/FLACExtractor.h"
 #include "include/AACExtractor.h"
+#ifdef QCOM_HARDWARE
+#include "include/ExtendedExtractor.h"
+#else
+#include "include/AVIExtractor.h"
+#endif
+
+#include <media/stagefright/MediaDefs.h>
 
 #include "matroska/MatroskaExtractor.h"
 
@@ -62,16 +70,26 @@ status_t DataSource::getSize(off64_t *size) {
 
 Mutex DataSource::gSnifferMutex;
 List<DataSource::SnifferFunc> DataSource::gSniffers;
+#ifdef QCOM_HARDWARE
+List<DataSource::SnifferFunc>::iterator DataSource::extendedSnifferPosition;
+#endif
 
 bool DataSource::sniff(
         String8 *mimeType, float *confidence, sp<AMessage> *meta) {
+
     *mimeType = "";
     *confidence = 0.0f;
     meta->clear();
-
     Mutex::Autolock autoLock(gSnifferMutex);
     for (List<SnifferFunc>::iterator it = gSniffers.begin();
          it != gSniffers.end(); ++it) {
+
+#ifdef QCOM_HARDWARE
+        //Dont call the first sniffer from extended extarctor
+        if(it == extendedSnifferPosition)
+            continue;
+#endif
+
         String8 newMimeType;
         float newConfidence;
         sp<AMessage> newMeta;
@@ -80,6 +98,34 @@ bool DataSource::sniff(
                 *mimeType = newMimeType;
                 *confidence = newConfidence;
                 *meta = newMeta;
+#ifdef QCOM_HARDWARE
+                if(*confidence >= 0.6f) {
+
+                    LOGV("Ignore other Sniffers - confidence = %f , mimeType = %s",*confidence,mimeType->string());
+
+                    char value[PROPERTY_VALUE_MAX];
+                    if( (!strcasecmp((*mimeType).string(), MEDIA_MIMETYPE_CONTAINER_MPEG4)) &&
+                        (property_get("mmp.enable.3g2", value, NULL)) &&
+                        (!strcasecmp(value, "true") || !strcmp(value, "1"))) {
+
+                        //Incase of mimeType MPEG4 call the extended parser sniffer to check
+                        //if this is fragmented or not.
+                        LOGV("calling Extended Sniff if mimeType = %s ",(*mimeType).string());
+                        String8 tmpMimeType;
+                        float tmpConfidence;
+                        sp<AMessage> tmpMeta;
+                        (*extendedSnifferPosition)(this, &tmpMimeType, &tmpConfidence, &tmpMeta);
+                        if (tmpConfidence > *confidence) {
+                            *mimeType = tmpMimeType;
+                            *confidence = tmpConfidence;
+                            *meta = tmpMeta;
+                            LOGV("Confidence of Extended sniffer greater than previous sniffer ");
+                        }
+                    }
+
+                    break;
+                }
+#endif
             }
         }
     }
@@ -88,7 +134,11 @@ bool DataSource::sniff(
 }
 
 // static
+#ifdef QCOM_HARDWARE
+void DataSource::RegisterSniffer(SnifferFunc func, bool isExtendedExtractor) {
+#else
 void DataSource::RegisterSniffer(SnifferFunc func) {
+#endif
     Mutex::Autolock autoLock(gSnifferMutex);
 
     for (List<SnifferFunc>::iterator it = gSniffers.begin();
@@ -99,6 +149,16 @@ void DataSource::RegisterSniffer(SnifferFunc func) {
     }
 
     gSniffers.push_back(func);
+
+#ifdef QCOM_HARDWARE
+    if(isExtendedExtractor)
+    {
+        extendedSnifferPosition = gSniffers.end();
+        extendedSnifferPosition--;
+    }
+
+    return;
+#endif
 }
 
 // static
@@ -113,6 +173,9 @@ void DataSource::RegisterDefaultSniffers() {
     RegisterSniffer(SniffMP3);
     RegisterSniffer(SniffAAC);
     RegisterSniffer(SniffMPEG2PS);
+#ifdef QCOM_HARDWARE
+    ExtendedExtractor::RegisterSniffers();
+#endif
 
     char value[PROPERTY_VALUE_MAX];
     if (property_get("drm.service.enabled", value, NULL)
diff --git a/media/libstagefright/ExtendedExtractor.cpp b/media/libstagefright/ExtendedExtractor.cpp
new file mode 100755
index 0000000..c6e1506
--- /dev/null
+++ b/media/libstagefright/ExtendedExtractor.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "ExtendedExtractor"
+#include <utils/Log.h>
+//#define DUMP_TO_FILE
+
+
+#include <media/stagefright/ExtendedExtractorFuncs.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaDefs.h>
+#include <utils/String8.h>
+#include <dlfcn.h>  // for dlopen/dlclose
+
+#include "include/ExtendedExtractor.h"
+#define LOGV LOGE
+
+static const char* MM_PARSER_LIB = "libmmparser.so";
+static const char* MM_PARSER_LITE_LIB = "libmmparser_lite.so";
+
+namespace android {
+
+void* MmParserLib() {
+    static void* mmParserLib = NULL;
+    static bool alreadyTriedToOpenMmParsers = false;
+
+    if(alreadyTriedToOpenMmParsers) {
+        return mmParserLib;
+    }
+
+    alreadyTriedToOpenMmParsers = true;
+
+    mmParserLib = ::dlopen(MM_PARSER_LIB, RTLD_LAZY);
+
+    if(mmParserLib != NULL) {
+        return mmParserLib;
+    }
+
+    LOGV("Failed to open MM_PARSER_LIB, dlerror = %s \n", dlerror());
+
+    mmParserLib = ::dlopen(MM_PARSER_LITE_LIB, RTLD_LAZY);
+
+    if(mmParserLib == NULL) {
+        LOGV("Failed to open MM_PARSER_LITE_LIB, dlerror = %s \n", dlerror());
+    }
+
+    return mmParserLib;
+}
+
+MediaExtractorFactory MediaExtractorFactoryFunction() {
+    static MediaExtractorFactory mediaFactoryFunction = NULL;
+    static bool alreadyTriedToFindFactoryFunction = false;
+
+    if(alreadyTriedToFindFactoryFunction) {
+        return mediaFactoryFunction;
+    }
+
+    void *mmParserLib = MmParserLib();
+    if (mmParserLib == NULL) {
+        return NULL;
+    }
+
+    mediaFactoryFunction = (MediaExtractorFactory) dlsym(mmParserLib, MEDIA_CREATE_EXTRACTOR);
+    alreadyTriedToFindFactoryFunction = true;
+
+    if(mediaFactoryFunction==NULL) {
+        LOGE(" dlsym for ExtendedExtractor factory function failed, dlerror = %s \n", dlerror());
+    }
+
+    return mediaFactoryFunction;
+}
+
+sp<MediaExtractor> ExtendedExtractor::CreateExtractor(const sp<DataSource> &source, const char *mime) {
+    MediaExtractorFactory f = MediaExtractorFactoryFunction();
+    if(f==NULL) {
+        return NULL;
+    }
+
+    sp<MediaExtractor> extractor = f(source, mime);
+    if(extractor==NULL) {
+        LOGE(" ExtendedExtractor failed to instantiate extractor \n");
+    }
+
+    return extractor;
+}
+
+void ExtendedExtractor::RegisterSniffers() {
+    void *mmParserLib = MmParserLib();
+    if (mmParserLib == NULL) {
+        return;
+    }
+
+    SnifferArrayFunc snifferArrayFunc = (SnifferArrayFunc) dlsym(mmParserLib, MEDIA_SNIFFER_ARRAY);
+    if(snifferArrayFunc==NULL) {
+        LOGE(" Unable to init Extended Sniffers, dlerror = %s \n", dlerror());
+        return;
+    }
+
+    const DataSource::SnifferFunc *snifferArray = NULL;
+    int snifferCount = 0;
+
+    //Invoke function in libmmparser to return its array of sniffers.
+    snifferArrayFunc(&snifferArray, &snifferCount);
+
+    if(snifferArray==NULL) {
+        LOGE(" snifferArray is NULL \n");
+        return;
+    }
+
+    bool flag= true;
+    //Register the remote sniffers with the DataSource.
+    for(int i=0; i<snifferCount; i++) {
+#ifdef QCOM_HARDWARE
+        DataSource::RegisterSniffer(snifferArray[i],flag);
+        flag = false;
+#else
+        DataSource::RegisterSniffer(snifferArray[i]);
+#endif
+    }
+}
+
+}  // namespace android
+
+
diff --git a/media/libstagefright/ExtendedWriter.cpp b/media/libstagefright/ExtendedWriter.cpp
new file mode 100644
index 0000000..18e6e95
--- /dev/null
+++ b/media/libstagefright/ExtendedWriter.cpp
@@ -0,0 +1,386 @@
+/*
+ * Copyright (C) 2011 Code Aurora Forum. All rights reserved
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <media/stagefright/ExtendedWriter.h>
+#include <media/stagefright/MediaBuffer.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/mediarecorder.h>
+#include <system/audio.h>
+
+#include <sys/prctl.h>
+#include <sys/resource.h>
+
+#include <arpa/inet.h>
+
+#undef LOG_TAG
+#define LOG_TAG "ExtendedWriter"
+
+namespace android {
+
+ExtendedWriter::ExtendedWriter(const char *filename)
+    : mFile(fopen(filename, "wb")),
+      mInitCheck(mFile != NULL ? OK : NO_INIT),
+      mStarted(false),
+      mPaused(false),
+      mResumed(false),
+      mOffset(0) {
+}
+
+ExtendedWriter::ExtendedWriter(int fd)
+    : mFile(fdopen(fd, "wb")),
+      mInitCheck(mFile != NULL ? OK : NO_INIT),
+      mStarted(false),
+      mPaused(false),
+      mResumed(false),
+      mOffset(0) {
+}
+
+ExtendedWriter::~ExtendedWriter() {
+    if (mStarted) {
+        stop();
+    }
+
+    if (mFile != NULL) {
+        fclose(mFile);
+        mFile = NULL;
+    }
+}
+
+status_t ExtendedWriter::initCheck() const {
+    return mInitCheck;
+}
+
+status_t ExtendedWriter::addSource(const sp<MediaSource> &source) {
+    if (mInitCheck != OK) {
+        LOGE("Init Check not OK, return");
+        return mInitCheck;
+    }
+
+    if (mSource != NULL) {
+        LOGE("A source already exists, return");
+        return UNKNOWN_ERROR;
+    }
+
+    sp<MetaData> meta = source->getFormat();
+
+    const char *mime;
+    CHECK(meta->findCString(kKeyMIMEType, &mime));
+
+    if ( !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_QCELP)) {
+        mFormat = AUDIO_FORMAT_QCELP;
+    } else if ( !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EVRC)) {
+        mFormat = AUDIO_FORMAT_EVRC;
+    }
+    else {
+        return UNKNOWN_ERROR;
+    }
+
+    int32_t channelCount;
+    int32_t sampleRate;
+    CHECK(meta->findInt32(kKeyChannelCount, &channelCount));
+    CHECK_EQ(channelCount, 1);
+    CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+    CHECK_EQ(sampleRate, 8000);
+
+    mSource = source;
+
+    return OK;
+}
+
+status_t ExtendedWriter::start(MetaData *params) {
+    if (mInitCheck != OK) {
+        LOGE("Init Check not OK, return");
+        return mInitCheck;
+    }
+
+    if (mSource == NULL) {
+        LOGE("NULL Source");
+        return UNKNOWN_ERROR;
+    }
+
+    if (mStarted && mPaused) {
+        mPaused = false;
+        mResumed = true;
+        return OK;
+    } else if (mStarted) {
+        LOGE("Already startd, return");
+        return OK;
+    }
+
+    //space for header;
+    size_t headerSize = sizeof( struct QCPEVRCHeader );
+    uint8_t * header = (uint8_t *)malloc(headerSize);
+    memset( header, '?', headerSize);
+    fwrite( header, 1, headerSize, mFile );
+    mOffset += headerSize;
+    delete header;
+
+    status_t err = mSource->start();
+
+    if (err != OK) {
+        return err;
+    }
+
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    mReachedEOS = false;
+    mDone = false;
+
+    pthread_create(&mThread, &attr, ThreadWrapper, this);
+    pthread_attr_destroy(&attr);
+
+    mStarted = true;
+
+    return OK;
+}
+
+status_t ExtendedWriter::pause() {
+    if (!mStarted) {
+        return OK;
+    }
+    mPaused = true;
+    return OK;
+}
+
+status_t ExtendedWriter::stop() {
+    if (!mStarted) {
+        return OK;
+    }
+
+    mDone = true;
+
+    void *dummy;
+    pthread_join(mThread, &dummy);
+
+    status_t err = (status_t) dummy;
+    {
+        status_t status = mSource->stop();
+        if (err == OK &&
+            (status != OK && status != ERROR_END_OF_STREAM)) {
+            err = status;
+        }
+    }
+
+    mStarted = false;
+    return err;
+}
+
+bool ExtendedWriter::exceedsFileSizeLimit() {
+    if (mMaxFileSizeLimitBytes == 0) {
+        return false;
+    }
+    return mEstimatedSizeBytes >= mMaxFileSizeLimitBytes;
+}
+
+bool ExtendedWriter::exceedsFileDurationLimit() {
+    if (mMaxFileDurationLimitUs == 0) {
+        return false;
+    }
+    return mEstimatedDurationUs >= mMaxFileDurationLimitUs;
+}
+
+// static
+void *ExtendedWriter::ThreadWrapper(void *me) {
+    return (void *) static_cast<ExtendedWriter *>(me)->threadFunc();
+}
+
+status_t ExtendedWriter::threadFunc() {
+    mEstimatedDurationUs = 0;
+    mEstimatedSizeBytes = 0;
+    bool stoppedPrematurely = true;
+    int64_t previousPausedDurationUs = 0;
+    int64_t maxTimestampUs = 0;
+    status_t err = OK;
+
+    prctl(PR_SET_NAME, (unsigned long)"ExtendedWriter", 0, 0, 0);
+    while (!mDone) {
+        MediaBuffer *buffer;
+        err = mSource->read(&buffer);
+
+        if (err != OK) {
+            break;
+        }
+
+        if (mPaused) {
+            buffer->release();
+            buffer = NULL;
+            continue;
+        }
+
+        mEstimatedSizeBytes += buffer->range_length();
+        if (exceedsFileSizeLimit()) {
+            buffer->release();
+            buffer = NULL;
+            notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, 0);
+            break;
+        }
+
+        int64_t timestampUs;
+        CHECK(buffer->meta_data()->findInt64(kKeyTime, &timestampUs));
+        if (timestampUs > mEstimatedDurationUs) {
+            mEstimatedDurationUs = timestampUs;
+        }
+        if (mResumed) {
+            previousPausedDurationUs += (timestampUs - maxTimestampUs - 20000);
+            mResumed = false;
+        }
+        timestampUs -= previousPausedDurationUs;
+        LOGV("time stamp: %lld, previous paused duration: %lld",
+                timestampUs, previousPausedDurationUs);
+        if (timestampUs > maxTimestampUs) {
+            maxTimestampUs = timestampUs;
+        }
+
+        if (exceedsFileDurationLimit()) {
+            buffer->release();
+            buffer = NULL;
+            notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, 0);
+            break;
+        }
+        ssize_t n = fwrite(
+                (const uint8_t *)buffer->data() + buffer->range_offset(),
+                1,
+                buffer->range_length(),
+                mFile);
+        mOffset += n;
+
+        if (n < (ssize_t)buffer->range_length()) {
+            buffer->release();
+            buffer = NULL;
+
+            break;
+        }
+
+        // XXX: How to tell it is stopped prematurely?
+        if (stoppedPrematurely) {
+            stoppedPrematurely = false;
+        }
+
+        buffer->release();
+        buffer = NULL;
+    }
+
+    if (stoppedPrematurely) {
+        notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_TRACK_INFO_COMPLETION_STATUS, UNKNOWN_ERROR);
+    }
+
+    if ( mFormat == AUDIO_FORMAT_QCELP ) {
+        writeQCPHeader( );
+    }
+    else if ( mFormat == AUDIO_FORMAT_EVRC ) {
+        writeEVRCHeader( );
+    }
+
+    fflush(mFile);
+    fclose(mFile);
+    mFile = NULL;
+    mReachedEOS = true;
+    if (err == ERROR_END_OF_STREAM || (err == -ETIMEDOUT)) {
+        return OK;
+    }
+    return err;
+}
+
+bool ExtendedWriter::reachedEOS() {
+    return mReachedEOS;
+}
+
+status_t ExtendedWriter::writeQCPHeader() {
+    /* Common part */
+    struct QCPEVRCHeader header = {
+        {'R', 'I', 'F', 'F'}, 0, {'Q', 'L', 'C', 'M'}, /* Riff */
+        {'f', 'm', 't', ' '}, 150, 1, 0, 0, 0, 0,{0}, 0, {0},0,0,160,8000,16,0,{0},{0},{0}, /* Fmt */
+        {'v','r','a','t'}, 0, 0, 0, /* Vrat */
+        {'d','a','t','a'},0 /* Data */
+    };
+
+    fseeko(mFile, 0, SEEK_SET);
+    header.s_riff = (mOffset - 8);
+    header.data1 = (0x5E7F6D41);
+    header.data2 = (0xB115);
+    header.data3 = (0x11D0);
+    header.data4[0] = 0xBA;
+    header.data4[1] = 0x91;
+    header.data4[2] = 0x00;
+    header.data4[3] = 0x80;
+    header.data4[4] = 0x5F;
+    header.data4[5] = 0xB4;
+    header.data4[6] = 0xB9;
+    header.data4[7] = 0x7E;
+    header.ver = (0x0002);
+    memcpy(header.name, "Qcelp 13K", 9);
+    header.abps = (13000);
+    header.bytes_per_pkt = (35);
+    header.vr_num_of_rates = 5;
+    header.vr_bytes_per_pkt[0] = (0x0422);
+    header.vr_bytes_per_pkt[1] = (0x0310);
+    header.vr_bytes_per_pkt[2] = (0x0207);
+    header.vr_bytes_per_pkt[3] = (0x0103);
+    header.s_vrat = (0x00000008);
+    header.v_rate = (0x00000001);
+    header.size_in_pkts = (mOffset - sizeof( struct QCPEVRCHeader ))/ header.bytes_per_pkt;
+    header.s_data = mOffset - sizeof( struct QCPEVRCHeader );
+    fwrite( &header, 1, sizeof( struct QCPEVRCHeader ), mFile );
+    return OK;
+}
+
+status_t ExtendedWriter::writeEVRCHeader() {
+    /* Common part */
+    struct QCPEVRCHeader header = {
+        {'R', 'I', 'F', 'F'}, 0, {'Q', 'L', 'C', 'M'}, /* Riff */
+        {'f', 'm', 't', ' '}, 150, 1, 0, 0, 0, 0,{0}, 0, {0},0,0,160,8000,16,0,{0},{0},{0}, /* Fmt */
+        {'v','r','a','t'}, 0, 0, 0, /* Vrat */
+        {'d','a','t','a'},0 /* Data */
+    };
+
+    fseeko(mFile, 0, SEEK_SET);
+    header.s_riff = (mOffset - 8);
+    header.data1 = (0xe689d48d);
+    header.data2 = (0x9076);
+    header.data3 = (0x46b5);
+    header.data4[0] = 0x91;
+    header.data4[1] = 0xef;
+    header.data4[2] = 0x73;
+    header.data4[3] = 0x6a;
+    header.data4[4] = 0x51;
+    header.data4[5] = 0x00;
+    header.data4[6] = 0xce;
+    header.data4[7] = 0xb4;
+    header.ver = (0x0001);
+    memcpy(header.name, "TIA IS-127 Enhanced Variable Rate Codec, Speech Service Option 3", 64);
+    header.abps = (9600);
+    header.bytes_per_pkt = (23);
+    header.vr_num_of_rates = 4;
+    header.vr_bytes_per_pkt[0] = (0x0416);
+    header.vr_bytes_per_pkt[1] = (0x030a);
+    header.vr_bytes_per_pkt[2] = (0x0200);
+    header.vr_bytes_per_pkt[3] = (0x0102);
+    header.s_vrat = (0x00000008);
+    header.v_rate = (0x00000001);
+    header.size_in_pkts = (mOffset - sizeof( struct QCPEVRCHeader )) / header.bytes_per_pkt;
+    header.s_data = mOffset - sizeof( struct QCPEVRCHeader );
+    fwrite( &header, 1, sizeof( struct QCPEVRCHeader ), mFile );
+    return OK;
+}
+
+
+}  // namespace android
diff --git a/media/libstagefright/FLACExtractor.cpp b/media/libstagefright/FLACExtractor.cpp
index 8ba5a2d..5b05582 100644
--- a/media/libstagefright/FLACExtractor.cpp
+++ b/media/libstagefright/FLACExtractor.cpp
@@ -793,13 +793,9 @@ bool SniffFLAC(
         const sp<DataSource> &source, String8 *mimeType, float *confidence,
         sp<AMessage> *)
 {
-    // first 4 is the signature word
-    // second 4 is the sizeof STREAMINFO
-    // 042 is the mandatory STREAMINFO
-    // no need to read rest of the header, as a premature EOF will be caught later
-    uint8_t header[4+4];
+    uint8_t header[4];
     if (source->readAt(0, header, sizeof(header)) != sizeof(header)
-            || memcmp("fLaC\0\0\0\042", header, 4+4))
+            || memcmp("fLaC", header, 4))
     {
         return false;
     }
diff --git a/media/libstagefright/LPAPlayer.cpp b/media/libstagefright/LPAPlayer.cpp
new file mode 100644
index 0000000..a5d464e
--- /dev/null
+++ b/media/libstagefright/LPAPlayer.cpp
@@ -0,0 +1,1692 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "LPAPlayer"
+#include <utils/Log.h>
+#include <utils/threads.h>
+
+#include <sys/prctl.h>
+#include <sys/resource.h>
+
+#include <binder/IPCThreadState.h>
+#include <media/AudioTrack.h>
+
+#include <media/stagefright/LPAPlayer.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/MediaErrors.h>
+
+#include <linux/unistd.h>
+
+#include "include/AwesomePlayer.h"
+
+#define MEM_BUFFER_SIZE 524288
+//#define PMEM_BUFFER_SIZE (4800 * 4)
+#define MEM_BUFFER_COUNT 4
+
+namespace android {
+int LPAPlayer::objectsAlive = 0;
+
+#define BT_A2DP_BUFFER_SIZE 65536
+
+LPAPlayer::LPAPlayer(
+                    const sp<MediaPlayerBase::AudioSink> &audioSink, bool &initCheck,
+                    AwesomePlayer *observer)
+:mInputBuffer(NULL),
+mSampleRate(0),
+mLatencyUs(0),
+mFrameSize(0),
+mNumFramesPlayed(0),
+mPositionTimeMediaUs(-1),
+mPositionTimeRealUs(-1),
+mSeeking(false),
+mInternalSeeking(false),
+mReachedEOS(false),
+mFinalStatus(OK),
+mStarted(false),
+mIsFirstBuffer(false),
+mFirstBufferResult(OK),
+mFirstBuffer(NULL),
+mAudioSink(audioSink),
+mObserver(observer),
+AudioPlayer(audioSink,observer) {
+    LOGV("LPAPlayer::LPAPlayer() ctor");
+    a2dpDisconnectPause = false;
+    a2dpResumeAfterReConnect = false;
+    mSeeked = false;
+    objectsAlive++;
+    timeStarted = 0;
+    numChannels =0;
+    afd = -1;
+    ionfd = -1;
+    timePlayed = 0;
+    isPaused = false;
+    bIsA2DPEnabled = false;
+    mAudioFlinger = NULL;
+    AudioFlingerClient = NULL;
+    eventThreadCreated = false;
+    /* Initialize Suspend/Resume related variables */
+    mQueue.start();
+    mQueueStarted      = true;
+    mPauseEvent        = new TimedEvent(this, &LPAPlayer::onPauseTimeOut);
+    mPauseEventPending = false;
+    mPlaybackSuspended = false;
+    bIsAudioRouted     = false;
+    mIsDriverStarted   = false;
+
+    LOGV("Opening pcm_dec driver");
+    afd = open("/dev/msm_pcm_lp_dec", O_WRONLY | O_NONBLOCK);
+    mSourceEmpty = true;
+    if ( afd < 0 ) {
+        LOGE("pcm_lp_dec: cannot open pcm_dec device and the error is %d", errno);
+        initCheck = false;
+        return;
+    } else {
+        initCheck = true;
+        LOGV("pcm_lp_dec: pcm_lp_dec Driver opened");
+    }
+    getAudioFlinger();
+    LOGV("Registering client with AudioFlinger");
+    mAudioFlinger->registerClient(AudioFlingerClient);
+    mAudioSinkOpen = false;
+    a2dpThreadStarted = true;
+    asyncReset = false;
+
+    bEffectConfigChanged = false;
+}
+
+LPAPlayer::~LPAPlayer() {
+    LOGV("LPAPlayer::~LPAPlayer()");
+    if (mQueueStarted) {
+        mQueue.stop();
+    }
+    if (mStarted) {
+        reset();
+    }
+    if (mAudioFlinger != NULL)
+        mAudioFlinger->deregisterClient(AudioFlingerClient);
+    objectsAlive--;
+}
+
+void LPAPlayer::getAudioFlinger() {
+    Mutex::Autolock _l(AudioFlingerLock);
+
+    if ( mAudioFlinger.get() == 0 ) {
+        sp<IServiceManager> sm = defaultServiceManager();
+        sp<IBinder> binder;
+        do {
+            binder = sm->getService(String16("media.audio_flinger"));
+            if ( binder != 0 )
+                break;
+            LOGW("AudioFlinger not published, waiting...");
+            usleep(500000); // 0.5 s
+        } while ( true );
+        if ( AudioFlingerClient == NULL ) {
+            AudioFlingerClient = new AudioFlingerLPAdecodeClient(this);
+        }
+
+        binder->linkToDeath(AudioFlingerClient);
+        mAudioFlinger = interface_cast<IAudioFlinger>(binder);
+    }
+    LOGE_IF(mAudioFlinger==0, "no AudioFlinger!?");
+}
+
+LPAPlayer::AudioFlingerLPAdecodeClient::AudioFlingerLPAdecodeClient(void *obj)
+{
+    LOGV("LPAPlayer::AudioFlingerLPAdecodeClient::AudioFlingerLPAdecodeClient");
+    pBaseClass = (LPAPlayer*)obj;
+}
+
+void LPAPlayer::AudioFlingerLPAdecodeClient::binderDied(const wp<IBinder>& who) {
+    Mutex::Autolock _l(pBaseClass->AudioFlingerLock);
+
+    pBaseClass->mAudioFlinger.clear();
+    LOGW("AudioFlinger server died!");
+}
+
+void LPAPlayer::AudioFlingerLPAdecodeClient::ioConfigChanged(int event, int ioHandle, void *param2) {
+    LOGV("ioConfigChanged() event %d", event);
+
+    if ( event != AudioSystem::A2DP_OUTPUT_STATE &&
+         event != AudioSystem::EFFECT_CONFIG_CHANGED) {
+        return;
+    }
+
+    switch ( event ) {
+    case AudioSystem::A2DP_OUTPUT_STATE:
+        {
+            LOGV("ioConfigChanged() A2DP_OUTPUT_STATE iohandle is %d with A2DPEnabled in %d", ioHandle, pBaseClass->bIsA2DPEnabled);
+            if ( -1 == ioHandle ) {
+                if ( pBaseClass->bIsA2DPEnabled ) {
+                    pBaseClass->bIsA2DPEnabled = false;
+                    if (pBaseClass->mStarted) {
+                        pBaseClass->handleA2DPSwitch();
+                    }
+                    LOGV("ioConfigChanged:: A2DP Disabled");
+                }
+            } else {
+                if ( !pBaseClass->bIsA2DPEnabled ) {
+
+                    pBaseClass->bIsA2DPEnabled = true;
+                    if (pBaseClass->mStarted) {
+                        pBaseClass->handleA2DPSwitch();
+                    }
+
+                    LOGV("ioConfigChanged:: A2DP Enabled");
+                }
+            }
+        }
+        break;
+    case AudioSystem::EFFECT_CONFIG_CHANGED:
+        {
+            LOGV("Received notification for change in effect module");
+            // Seek to current media time - flush the decoded buffers with the driver
+            if(!pBaseClass->bIsA2DPEnabled) {
+                pthread_mutex_lock(&pBaseClass->effect_mutex);
+                pBaseClass->bEffectConfigChanged = true;
+                pthread_mutex_unlock(&pBaseClass->effect_mutex);
+                // Signal effects thread to re-apply effects
+                LOGV("Signalling Effects Thread");
+                pthread_cond_signal(&pBaseClass->effect_cv);
+            }
+        }
+    }
+
+    LOGV("ioConfigChanged Out");
+}
+
+void LPAPlayer::handleA2DPSwitch() {
+    Mutex::Autolock autoLock(mLock);
+
+    LOGV("handleA2dpSwitch()");
+    if (bIsA2DPEnabled) {
+        if (!isPaused) {
+            if(mIsDriverStarted) {
+                if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+                    LOGE("AUDIO PAUSE failed");
+                }
+            }
+            /* Set timePlayed to time where we are pausing */
+            timePlayed += (nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted);
+            timeStarted = 0;
+            LOGV("paused for bt switch");
+        }
+
+        mInternalSeeking = true;
+        mReachedEOS = false;
+        mSeekTimeUs = timePlayed;
+
+        if(mIsDriverStarted) {
+            mIsDriverStarted = false;
+            if (ioctl(afd, AUDIO_STOP, 0) < 0) {
+                LOGE("%s: Audio stop event failed", __func__);
+            }
+        }
+    } else {
+        if (!isPaused) {
+            timePlayed += (nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted);
+            timeStarted = 0;
+        }
+
+        a2dpDisconnectPause = true;
+    }
+}
+
+void LPAPlayer::setSource(const sp<MediaSource> &source) {
+    CHECK_EQ(mSource, NULL);
+    LOGV("Setting source from LPA Player");
+    mSource = source;
+}
+
+status_t LPAPlayer::start(bool sourceAlreadyStarted) {
+    CHECK(!mStarted);
+    CHECK(mSource != NULL);
+
+    LOGV("start: sourceAlreadyStarted %d", sourceAlreadyStarted);
+    //Check if the source is started, start it
+    status_t err;
+    if (!sourceAlreadyStarted) {
+        err = mSource->start();
+
+        if (err != OK) {
+            return err;
+        }
+    }
+
+    //Create event, decoder and a2dp thread and initialize all the
+    //mutexes and coditional variables
+    createThreads();
+    LOGV("All Threads Created.");
+
+    // We allow an optional INFO_FORMAT_CHANGED at the very beginning
+    // of playback, if there is one, getFormat below will retrieve the
+    // updated format, if there isn't, we'll stash away the valid buffer
+    // of data to be used on the first audio callback.
+
+    CHECK(mFirstBuffer == NULL);
+
+    MediaSource::ReadOptions options;
+    if (mSeeking) {
+        options.setSeekTo(mSeekTimeUs);
+        mSeeking = false;
+    }
+
+    mFirstBufferResult = mSource->read(&mFirstBuffer, &options);
+    if (mFirstBufferResult == INFO_FORMAT_CHANGED) {
+        LOGV("INFO_FORMAT_CHANGED!!!");
+        CHECK(mFirstBuffer == NULL);
+        mFirstBufferResult = OK;
+        mIsFirstBuffer = false;
+    } else {
+        mIsFirstBuffer = true;
+    }
+
+    /*TODO: Check for bA2dpEnabled */
+
+    sp<MetaData> format = mSource->getFormat();
+    const char *mime;
+    bool success = format->findCString(kKeyMIMEType, &mime);
+    CHECK(success);
+    CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
+
+    success = format->findInt32(kKeySampleRate, &mSampleRate);
+    CHECK(success);
+
+    success = format->findInt32(kKeyChannelCount, &numChannels);
+    CHECK(success);
+
+    if ( afd >= 0 ) {
+        struct msm_audio_config config;
+        if ( ioctl(afd, AUDIO_GET_CONFIG, &config) < 0 ) {
+            LOGE("could not get config");
+            close(afd);
+            afd = -1;
+            return BAD_VALUE;
+        }
+
+        config.sample_rate = mSampleRate;
+        config.channel_count =  numChannels;
+        LOGV(" in initate_play, sample_rate=%d and channel count=%d \n", mSampleRate, numChannels);
+        if ( ioctl(afd, AUDIO_SET_CONFIG, &config) < 0 ) {
+            LOGE("could not set config");
+            close(afd);
+            afd = -1;
+            return BAD_VALUE;
+        }
+    }
+
+    // Get the session id from the LPA Driver
+    // Register the session id with HAL for routing
+    if (mAudioSink.get() != NULL) {
+        unsigned short decId;
+        if ( ioctl(afd, AUDIO_GET_SESSION_ID, &decId) == -1 ) {
+            LOGE("AUDIO_GET_SESSION_ID FAILED\n");
+            return BAD_VALUE;
+        } else {
+            sessionId = (int)decId;
+            LOGV("AUDIO_GET_SESSION_ID success : decId = %d", decId);
+        }
+
+        if (!bIsA2DPEnabled) {
+            LOGV("Opening a routing session for audio playback: sessionId = %d mSampleRate %d numChannels %d",
+                 sessionId, mSampleRate, numChannels);
+            status_t err = mAudioSink->openSession(AUDIO_FORMAT_PCM_16_BIT, sessionId, mSampleRate, numChannels);
+            if (err != OK) {
+                if (mFirstBuffer != NULL) {
+                    mFirstBuffer->release();
+                    mFirstBuffer = NULL;
+                }
+
+                if (!sourceAlreadyStarted) {
+                    mSource->stop();
+                }
+
+                LOGE("Opening a routing session failed");
+                close(afd);
+                afd = -1;
+
+                return err;
+            }
+            LOGV("AudioSink Opened a session(%d)",sessionId);
+
+            //Start the Driver
+            if (ioctl(afd, AUDIO_START,0) < 0) {
+                LOGE("Driver start failed!");
+                return BAD_VALUE;
+            }
+            mIsDriverStarted = true;
+            bIsAudioRouted = true;
+            LOGV("LPA Driver Started");
+        } else {
+            LOGV("Before Audio Sink Open");
+            status_t ret = mAudioSink->open(mSampleRate, numChannels,AUDIO_FORMAT_PCM_16_BIT, DEFAULT_AUDIOSINK_BUFFERCOUNT);
+            mAudioSink->start();
+            LOGV("After Audio Sink Open");
+            mAudioSinkOpen = true;
+            //pthread_cond_signal(&a2dp_cv);
+        }
+    } else {
+        close(afd);
+        afd = -1;
+        LOGE("Audiosink is NULL");
+        return BAD_VALUE;
+    }
+
+    mStarted = true;
+
+    if (timeStarted == 0) {
+        timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));
+    }
+
+    LOGV("Waking up decoder thread");
+    pthread_cond_signal(&decoder_cv);
+    return OK;
+}
+
+status_t LPAPlayer::seekTo(int64_t time_us) {
+    Mutex::Autolock autoLock1(mSeekLock);
+    Mutex::Autolock autoLock(mLock);
+    LOGV("seekTo: time_us %ld", time_us);
+    if ( mReachedEOS ) {
+        mReachedEOS = false;
+        LOGV("Signalling to Decoder Thread");
+        pthread_cond_signal(&decoder_cv);
+    }
+    mSeeking = true;
+
+    mSeekTimeUs = time_us;
+    timePlayed  = time_us;
+    timeStarted = 0;
+
+    LOGV("In seekTo(), mSeekTimeUs %lld",mSeekTimeUs);
+    if (!bIsA2DPEnabled) {
+        if(mIsDriverStarted) {
+#ifndef QCOM_KERNEL_SUPPORT_LPA_PAUSE
+            if (!isPaused) {
+                if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+                    LOGE("Audio Pause failed");
+                }
+            }
+#endif
+            pthread_mutex_lock(&mem_response_mutex);
+            pthread_mutex_lock(&mem_request_mutex);
+            LOGV("Response queue size %d:", memBuffersResponseQueue.size());
+            LOGV("Request queue size %d:", memBuffersRequestQueue.size());
+            while (!memBuffersResponseQueue.empty()) {
+                List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+                BuffersAllocated buf = *it;
+                buf.bytesToWrite = 0;
+                memBuffersRequestQueue.push_back(buf);
+                memBuffersResponseQueue.erase(it);
+            }
+            LOGV("Response queue size %d:", memBuffersResponseQueue.size());
+            LOGV("Request queue size %d:", memBuffersRequestQueue.size());
+            pthread_mutex_unlock(&mem_request_mutex);
+            pthread_mutex_unlock(&mem_response_mutex);
+            if (ioctl(afd, AUDIO_FLUSH, 0) < 0) {
+                LOGE("Audio Flush failed");
+            }
+            LOGV("Paused case, %d",isPaused);
+            if (isPaused) {
+                LOGV("AUDIO pause in seek()");
+                if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+                    LOGE("Audio Pause failed");
+                    return BAD_VALUE;
+                }
+            }
+        }
+    } else {
+        mSeeked = true;
+        if (!isPaused) {
+            mAudioSink->pause();
+            mAudioSink->flush();
+            mAudioSink->start();
+        }
+    }
+
+    return OK;
+}
+
+void LPAPlayer::pause(bool playPendingSamples) {
+    CHECK(mStarted);
+
+    LOGV("pause: playPendingSamples %d", playPendingSamples);
+    isPaused = true;
+    if (playPendingSamples) {
+        if (!bIsA2DPEnabled) {
+            if (fsync(afd) != 0)
+                LOGE("fsync failed.");
+            if(!mPauseEventPending) {
+                LOGV("Posting an event for Pause timeout");
+                mQueue.postEventWithDelay(mPauseEvent, LPA_PAUSE_TIMEOUT_USEC);
+                mPauseEventPending = true;
+            }
+            if (mAudioSink.get() != NULL) {
+                mAudioSink->pauseSession();
+            }
+            timePlayed += (nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted);
+        }
+        else {
+            if (mAudioSink.get() != NULL)
+                mAudioSink->stop();
+        }
+    } else {
+        if (a2dpDisconnectPause) {
+            mAudioSink->pause();
+        } else {
+            if (!bIsA2DPEnabled) {
+                LOGV("LPAPlayer::Pause - Pause driver");
+                if (ioctl(afd, AUDIO_PAUSE, 1) < 0) {
+                    LOGE("Audio Pause failed");
+                }
+                if(!mPauseEventPending) {
+                    LOGV("Posting an event for Pause timeout");
+                    mQueue.postEventWithDelay(mPauseEvent, LPA_PAUSE_TIMEOUT_USEC);
+                    mPauseEventPending = true;
+                }
+
+                if (mAudioSink.get() != NULL) {
+                    mAudioSink->pauseSession();
+                }
+            } else {
+                mAudioSink->pause();
+                mAudioSink->flush();
+            }
+            timePlayed += (nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted);
+        }
+    }
+}
+
+void LPAPlayer::resume() {
+    LOGV("resume: isPaused %d",isPaused);
+    Mutex::Autolock autoLock(resumeLock);
+    if ( isPaused) {
+        CHECK(mStarted);
+        if (bIsA2DPEnabled && a2dpDisconnectPause) {
+            isPaused = false;
+            mInternalSeeking = true;
+            mReachedEOS = false;
+            mSeekTimeUs = timePlayed;
+            a2dpDisconnectPause = false;
+            a2dpResumeAfterReConnect = true;
+            mAudioSink->start();
+            pthread_cond_signal(&decoder_cv);
+            pthread_cond_signal(&a2dp_cv);
+        }
+        else if (a2dpDisconnectPause) {
+            LOGV("A2DP disconnect resume");
+            mAudioSink->pause();
+            mAudioSink->stop();
+            mAudioSink->close();
+            mAudioSinkOpen = false;
+            LOGV("resume:: opening audio session with mSampleRate %d numChannels %d sessionId %d",
+                 mSampleRate, numChannels, sessionId);
+            status_t err = mAudioSink->openSession(AUDIO_FORMAT_PCM_16_BIT, sessionId,  mSampleRate, numChannels);
+            a2dpDisconnectPause = false;
+            mInternalSeeking = true;
+            mReachedEOS = false;
+            mSeekTimeUs = timePlayed;
+
+            if (ioctl(afd, AUDIO_START,0) < 0) {
+                LOGE("Driver start failed!");// TODO: How to report this error and stop playback ??
+            }
+            mIsDriverStarted = true;
+            LOGV("LPA Driver Started");
+
+            pthread_cond_signal(&event_cv);
+            pthread_cond_signal(&a2dp_cv);
+            pthread_cond_signal(&decoder_cv);
+
+        } else {
+            if (!bIsA2DPEnabled) {
+                LOGV("LPAPlayer::resume - Resuming Driver");
+
+                if(mPauseEventPending) {
+                    LOGV("Resume(): Cancelling the puaseTimeout event");
+                    mPauseEventPending = false;
+                    mQueue.cancelEvent(mPauseEvent->eventID());
+                }
+
+                if(!bIsAudioRouted) {
+                    unsigned short decId;
+                    int sessionId;
+
+                    mPlaybackSuspended = false;
+
+                    CHECK(afd != -1);
+                    if ( ioctl(afd, AUDIO_GET_SESSION_ID, &decId) == -1 ) {
+                        LOGE("AUDIO_GET_SESSION_ID FAILED\n");
+                    } else {
+                        sessionId = (int)decId;
+                        LOGV("AUDIO_GET_SESSION_ID success : decId = %d", decId);
+                    }
+
+                    LOGV("Resume:: Opening a session for playback: sessionId = %d", sessionId);
+                    status_t err = mAudioSink->openSession(AUDIO_FORMAT_PCM_16_BIT, sessionId);
+                    if (err != OK) {
+                        LOGE("Opening a routing session failed");
+                        if (mFirstBuffer != NULL) {
+                            mFirstBuffer->release();
+                            mFirstBuffer = NULL;
+                        }
+
+                        close(afd);
+                        afd = -1;
+                        return;
+                    }
+                    LOGV("Resume:: AudioSink Opened a session(%d)",sessionId);
+                    //Start the Driver
+                    LOGV("Resume:: Starting LPA Driver");
+                    if (ioctl(afd, AUDIO_START,0) < 0) {
+                        LOGE("Driver start failed!");
+                        return; // TODO: How to report this error and stop playback ??
+                    }
+                    mIsDriverStarted = true;
+                    bIsAudioRouted = true;
+
+                    LOGV("Resume: Waking up decoder thread");
+                    pthread_cond_signal(&decoder_cv);
+                } else {
+                    if (ioctl(afd, AUDIO_PAUSE, 0) < 0) {
+                        LOGE("Resume:: LPA driver resume failed");
+                        // TODO: How to report this error and stop playback ??
+                    }
+                    if (mAudioSink.get() != NULL) {
+                        mAudioSink->resumeSession();
+                    }
+                }
+            } else {
+                isPaused = false;
+
+                if (!mAudioSinkOpen) {
+                    if (mAudioSink.get() != NULL) {
+                        LOGV("%s mAudioSink close session", __func__);
+                        mAudioSink->closeSession();
+                    } else {
+                        LOGE("close session NULL");
+                    }
+
+                    LOGV("Resume: Before Audio Sink Open");
+                    status_t ret = mAudioSink->open(mSampleRate, numChannels,AUDIO_FORMAT_PCM_16_BIT,
+                                                    DEFAULT_AUDIOSINK_BUFFERCOUNT);
+                    mAudioSink->start();
+                    LOGV("Resume: After Audio Sink Open");
+                    mAudioSinkOpen = true;
+
+                    LOGV("Resume: Waking up the decoder thread");
+                    pthread_cond_signal(&decoder_cv);
+                } else {
+                    /* If AudioSink is already open just start it */
+                    mAudioSink->start();
+                }
+                LOGV("Waking up A2dp thread");
+                pthread_cond_signal(&a2dp_cv);
+            }
+        }
+        isPaused = false;
+        /* Set timeStarted to current systemTime */
+        timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));
+    }
+}
+
+void LPAPlayer::reset() {
+    CHECK(mStarted);
+    LOGV("Reset called!!!!!");
+    asyncReset = true;
+
+    if(!bIsA2DPEnabled) {
+        mIsDriverStarted = false;
+        ioctl(afd,AUDIO_STOP,0);
+    }
+
+    LOGV("reset() requestQueue.size() = %d, responseQueue.size() = %d effectsQueue.size() = %d",
+         memBuffersRequestQueue.size(), memBuffersResponseQueue.size(), effectsQueue.size());
+
+    // make sure the Effects thread has exited
+    requestAndWaitForEffectsThreadExit();
+
+    // make sure Decoder thread has exited
+    requestAndWaitForDecoderThreadExit();
+
+    // make sure the event thread also has exited
+    requestAndWaitForEventThreadExit();
+
+    requestAndWaitForA2DPThreadExit();
+
+    // Close the audiosink after all the threads exited to make sure
+    // there is no thread writing data to audio sink or applying effect
+    if (bIsA2DPEnabled) {
+        mAudioSink->close();
+    } else {
+        mAudioSink->closeSession();
+    }
+    mAudioSink.clear();
+
+    // Make sure to release any buffer we hold onto so that the
+    // source is able to stop().
+    if (mFirstBuffer != NULL) {
+        mFirstBuffer->release();
+        mFirstBuffer = NULL;
+    }
+
+    if (mInputBuffer != NULL) {
+        LOGV("AudioPlayer releasing input buffer.");
+        mInputBuffer->release();
+        mInputBuffer = NULL;
+    }
+
+    mSource->stop();
+
+    // The following hack is necessary to ensure that the OMX
+    // component is completely released by the time we may try
+    // to instantiate it again.
+    wp<MediaSource> tmp = mSource;
+    mSource.clear();
+    while (tmp.promote() != NULL) {
+        usleep(1000);
+    }
+
+    if ( afd >= 0 ) {
+        memBufferDeAlloc();
+        close(afd);
+        afd = -1;
+    }
+
+    LOGV("reset() after memBuffersRequestQueue.size() = %d, memBuffersResponseQueue.size() = %d ",memBuffersRequestQueue.size(),memBuffersResponseQueue.size());
+
+    mNumFramesPlayed = 0;
+    mPositionTimeMediaUs = -1;
+    mPositionTimeRealUs = -1;
+    mSeeking = false;
+    mInternalSeeking = false;
+    mReachedEOS = false;
+    mFinalStatus = OK;
+    mStarted = false;
+}
+
+
+bool LPAPlayer::isSeeking() {
+    Mutex::Autolock autoLock(mLock);
+    return mSeeking;
+}
+
+bool LPAPlayer::reachedEOS(status_t *finalStatus) {
+    *finalStatus = OK;
+
+    Mutex::Autolock autoLock(mLock);
+    *finalStatus = mFinalStatus;
+    return mReachedEOS;
+}
+
+
+void *LPAPlayer::decoderThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->decoderThreadEntry();
+    return NULL;
+}
+
+void LPAPlayer::decoderThreadEntry() {
+
+    pthread_mutex_lock(&decoder_mutex);
+
+    setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"LPA DecodeThread", 0, 0, 0);
+
+    LOGV("decoderThreadEntry wait for signal \n");
+    if (!mStarted) {
+        pthread_cond_wait(&decoder_cv, &decoder_mutex);
+    }
+    LOGV("decoderThreadEntry ready to work \n");
+    pthread_mutex_unlock(&decoder_mutex);
+
+
+    audio_register_memory();
+    while (1) {
+        LOGV("mem_request_mutex locking: %d", __LINE__);
+        pthread_mutex_lock(&mem_request_mutex);
+        LOGV("mem_request_mutex locked: %d", __LINE__);
+        if (killDecoderThread) {
+            LOGV("mem_request_mutex unlocking: %d", __LINE__);
+            pthread_mutex_unlock(&mem_request_mutex);
+            LOGV("mem_request_mutex unlocked: %d", __LINE__);
+            break;
+        }
+
+        LOGV("decoder memBuffersRequestQueue.size() = %d, memBuffersResponseQueue.size() = %d ",
+             memBuffersRequestQueue.size(),memBuffersResponseQueue.size());
+
+        if (memBuffersRequestQueue.empty() || a2dpDisconnectPause || mReachedEOS ||
+            (bIsA2DPEnabled && !mAudioSinkOpen) || asyncReset || (!bIsA2DPEnabled && !mIsDriverStarted)) {
+            LOGV("decoderThreadEntry: a2dpDisconnectPause %d  mReachedEOS %d bIsA2DPEnabled %d "
+                 "mAudioSinkOpen %d asyncReset %d mIsDriverStarted %d", a2dpDisconnectPause,
+                 mReachedEOS, bIsA2DPEnabled, mAudioSinkOpen, asyncReset, mIsDriverStarted);
+            LOGV("decoderThreadEntry: waiting on decoder_cv");
+            pthread_cond_wait(&decoder_cv, &mem_request_mutex);
+            LOGV("mem_request_mutex unlocking: %d", __LINE__);
+            pthread_mutex_unlock(&mem_request_mutex);
+            LOGV("decoderThreadEntry: received a signal to wake up");
+            LOGV("mem_request_mutex unlocked: %d", __LINE__);
+            continue;
+        }
+
+        List<BuffersAllocated>::iterator it = memBuffersRequestQueue.begin();
+        BuffersAllocated buf = *it;
+        memBuffersRequestQueue.erase(it);
+        LOGV("mem_request_mutex unlocking: %d", __LINE__);
+        pthread_mutex_unlock(&mem_request_mutex);
+        LOGV("mem_request_mutex unlocked: %d", __LINE__);
+
+        //Queue the buffers back to Request queue
+        if (mReachedEOS || (bIsA2DPEnabled && !mAudioSinkOpen) || asyncReset || a2dpDisconnectPause) {
+            LOGV("%s: mReachedEOS %d bIsA2DPEnabled %d ", __func__, mReachedEOS, bIsA2DPEnabled);
+            LOGV("mem_request_mutex locking: %d", __LINE__);
+            pthread_mutex_lock(&mem_request_mutex);
+            LOGV("mem_request_mutex locked: %d", __LINE__);
+            memBuffersRequestQueue.push_back(buf);
+            LOGV("mem_request_mutex unlocking: %d", __LINE__);
+            pthread_mutex_unlock(&mem_request_mutex);
+            LOGV("mem_request_mutex unlocked: %d", __LINE__);
+        }
+        //Queue up the buffers for writing either for A2DP or LPA Driver
+        else {
+            struct msm_audio_aio_buf aio_buf_local;
+            Mutex::Autolock autoLock(mSeekLock);
+            if(bIsA2DPEnabled && isPaused){
+                pthread_mutex_lock(&mem_response_mutex);
+                buf.bytesToWrite = 0;
+                memBuffersResponseQueue.push_back(buf);
+                pthread_mutex_unlock(&mem_response_mutex);
+                continue;
+            }
+            int numOfBytes = 0;
+
+            if (bIsA2DPEnabled)
+                numOfBytes = BT_A2DP_BUFFER_SIZE;
+            else
+                numOfBytes = MEM_BUFFER_SIZE;
+
+            LOGV("Calling fillBuffer for size %d",numOfBytes);
+            buf.bytesToWrite = fillBuffer(buf.localBuf, numOfBytes);
+            LOGV("fillBuffer returned size %d",buf.bytesToWrite);
+
+            /* TODO: Check if we have to notify the app if an error occurs */
+            if (!bIsA2DPEnabled) {
+                if ( buf.bytesToWrite > 0) {
+                    memset(&aio_buf_local, 0, sizeof(msm_audio_aio_buf));
+                    aio_buf_local.buf_addr = buf.memBuf;
+                    aio_buf_local.buf_len = buf.bytesToWrite;
+                    aio_buf_local.data_len = buf.bytesToWrite;
+                    aio_buf_local.private_data = (void*) buf.memFd;
+
+                    if ( (buf.bytesToWrite % 2) != 0 ) {
+                        LOGV("Increment for even bytes");
+                        aio_buf_local.data_len += 1;
+                    }
+
+                    if (timeStarted == 0) {
+                        timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));
+                    }
+                } else {
+                    /* Put the buffer back into requestQ */
+                    LOGV("mem_request_mutex locking: %d", __LINE__);
+                    pthread_mutex_lock(&mem_request_mutex);
+                    LOGV("mem_request_mutex locked: %d", __LINE__);
+                    memBuffersRequestQueue.push_back(buf);
+                    LOGV("mem_request_mutex unlocking: %d", __LINE__);
+                    pthread_mutex_unlock(&mem_request_mutex);
+                    LOGV("mem_request_mutex unlocked: %d", __LINE__);
+                    /* This is zero byte buffer - no need to put in response Q*/
+                    if (mObserver && mReachedEOS && memBuffersResponseQueue.empty()) {
+                        LOGV("Posting EOS event to AwesomePlayer");
+                        mObserver->postAudioEOS();
+                    }
+                    continue;
+                }
+            }
+            pthread_mutex_lock(&mem_response_mutex);
+            memBuffersResponseQueue.push_back(buf);
+            pthread_mutex_unlock(&mem_response_mutex);
+
+            if (bIsA2DPEnabled && !mAudioSinkOpen) {
+                LOGV("Close Session");
+                if (mAudioSink.get() != NULL) {
+                    mAudioSink->closeSession();
+                    LOGV("mAudioSink close session");
+                } else {
+                    LOGE("close session NULL");
+                }
+
+                sp<MetaData> format = mSource->getFormat();
+                const char *mime;
+                bool success = format->findCString(kKeyMIMEType, &mime);
+                CHECK(success);
+                CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
+                success = format->findInt32(kKeySampleRate, &mSampleRate);
+                CHECK(success);
+                success = format->findInt32(kKeyChannelCount, &numChannels);
+                CHECK(success);
+                LOGV("Before Audio Sink Open");
+                status_t ret = mAudioSink->open(mSampleRate, numChannels,AUDIO_FORMAT_PCM_16_BIT, DEFAULT_AUDIOSINK_BUFFERCOUNT);
+                mAudioSink->start();
+                LOGV("After Audio Sink Open");
+            }
+
+            if (!bIsA2DPEnabled){
+                pthread_cond_signal(&event_cv);
+                // Make sure the buffer is added to response Q before applying effects
+                // If there is a change in effects while applying on current buffer
+                // it will be re applied as the buffer already present in responseQ
+                if (!asyncReset) {
+                    pthread_mutex_lock(&apply_effect_mutex);
+                    LOGV("decoderThread: applying effects on mem buf with fd %d", buf.memFd);
+                    mAudioFlinger->applyEffectsOn((int16_t*)buf.localBuf,
+                                                  (int16_t*)buf.memBuf,
+                                                  (int)buf.bytesToWrite);
+
+                    pthread_mutex_unlock(&apply_effect_mutex);
+
+                    LOGV("decoderThread: Writing buffer to driver with mem fd %d", buf.memFd);
+                    if ( ioctl(afd, AUDIO_ASYNC_WRITE, &aio_buf_local) < 0 ) {
+                        LOGE("error on async write\n");
+                    }
+                }
+            }
+            else
+                pthread_cond_signal(&a2dp_cv);
+        }
+    }
+    decoderThreadAlive = false;
+    LOGV("decoder Thread is dying");
+}
+
+void *LPAPlayer::eventThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->eventThreadEntry();
+    return NULL;
+}
+
+void LPAPlayer::eventThreadEntry() {
+    struct msm_audio_event cur_pcmdec_event;
+
+    pthread_mutex_lock(&event_mutex);
+    eventThreadCreated = true;
+    pthread_cond_signal(&event_thread_cv);
+    int rc = 0;
+    setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"LPA EventThread", 0, 0, 0);
+
+    LOGV("eventThreadEntry wait for signal \n");
+    pthread_cond_wait(&event_cv, &event_mutex);
+    LOGV("eventThreadEntry ready to work \n");
+    pthread_mutex_unlock(&event_mutex);
+
+    if (killEventThread) {
+        eventThreadAlive = false;
+        LOGV("Event Thread is dying.");
+        return;
+    }
+
+    while (1) {
+        //Wait for an event to occur
+        rc = ioctl(afd, AUDIO_GET_EVENT, &cur_pcmdec_event);
+        LOGV("pcm dec Event Thread rc = %d and errno is %d",rc, errno);
+
+        if ( (rc < 0) && (errno == ENODEV ) ) {
+            LOGV("AUDIO_ABORT_GET_EVENT called. Exit the thread");
+            break;
+        }
+
+        switch ( cur_pcmdec_event.event_type ) {
+        case AUDIO_EVENT_WRITE_DONE:
+            {
+                LOGV("WRITE_DONE: addr %p len %d and fd is %d\n",
+                     cur_pcmdec_event.event_payload.aio_buf.buf_addr,
+                     cur_pcmdec_event.event_payload.aio_buf.data_len,
+                     (int32_t) cur_pcmdec_event.event_payload.aio_buf.private_data);
+                Mutex::Autolock autoLock(mLock);
+                mNumFramesPlayed += cur_pcmdec_event.event_payload.aio_buf.buf_len/ mFrameSize;
+                pthread_mutex_lock(&mem_response_mutex);
+                BuffersAllocated buf = *(memBuffersResponseQueue.begin());
+                for (List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+                    it != memBuffersResponseQueue.end(); ++it) {
+                    if (it->memBuf == cur_pcmdec_event.event_payload.aio_buf.buf_addr) {
+                        buf = *it;
+                        memBuffersResponseQueue.erase(it);
+                        // Post buffer to request Q
+                        LOGV("mem_request_mutex locking: %d", __LINE__);
+                        pthread_mutex_lock(&mem_request_mutex);
+                        LOGV("mem_request_mutex locked: %d", __LINE__);
+                        memBuffersRequestQueue.push_back(buf);
+                        LOGV("mem_request_mutex unlocking: %d", __LINE__);
+                        pthread_mutex_unlock(&mem_request_mutex);
+                        LOGV("mem_request_mutex unlocked: %d", __LINE__);
+                        break;
+                    }
+                }
+
+                /* If the rendering is complete report EOS to the AwesomePlayer */
+                if (mObserver && !asyncReset && mReachedEOS && memBuffersResponseQueue.empty()) {
+                    LOGV("Posting EOS event to AwesomePlayer");
+                    mObserver->postAudioEOS();
+                }
+                if (memBuffersResponseQueue.empty() && bIsA2DPEnabled && !mAudioSinkOpen) {
+                    LOGV("Close Session");
+                    if (mAudioSink.get() != NULL) {
+                        mAudioSink->closeSession();
+                        LOGV("mAudioSink close session");
+                    } else {
+                        LOGE("close session NULL");
+                    }
+
+                    sp<MetaData> format = mSource->getFormat();
+                    const char *mime;
+                    bool success = format->findCString(kKeyMIMEType, &mime);
+                    CHECK(success);
+                    CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
+
+                    success = format->findInt32(kKeySampleRate, &mSampleRate);
+                    CHECK(success);
+
+                    success = format->findInt32(kKeyChannelCount, &numChannels);
+                    CHECK(success);
+                    LOGV("Before Audio Sink Open");
+                    status_t ret = mAudioSink->open(mSampleRate, numChannels,AUDIO_FORMAT_PCM_16_BIT, DEFAULT_AUDIOSINK_BUFFERCOUNT);
+                    mAudioSink->start();
+                    LOGV("After Audio Sink Open");
+                    mAudioSinkOpen = true;
+                }
+
+                pthread_mutex_unlock(&mem_response_mutex);
+
+                pthread_cond_signal(&decoder_cv);
+            }
+            break;
+        case AUDIO_EVENT_SUSPEND:
+            {
+                struct msm_audio_stats stats;
+                int nBytesConsumed = 0;
+
+                LOGV("AUDIO_EVENT_SUSPEND received\n");
+                if(mPauseEventPending) {
+                    mPauseEventPending = false;
+                    mQueue.cancelEvent(mPauseEvent->eventID());
+                } else {
+                    LOGV("Not in paused, no need to honor SUSPEND event");
+                    break;
+                }
+                if(!bIsA2DPEnabled) {
+                    if(!mPlaybackSuspended) {
+                        mPlaybackSuspended = true;
+                        // 1. Get the Byte count that is consumed
+                        if ( ioctl(afd, AUDIO_GET_STATS, &stats)  < 0 ) {
+                            LOGE("AUDIO_GET_STATUS failed");
+                        } else {
+                            LOGV("Number of bytes consumed by DSP is %u", stats.byte_count);
+                            nBytesConsumed = stats.byte_count;
+                        }
+                        // Reset eosflag to resume playback where we actually paused
+                        mInternalSeeking = true;
+                        mReachedEOS = false;
+                        mSeekTimeUs = timePlayed;
+
+                        // 2. Close the session
+                        if(bIsAudioRouted) {
+                            mAudioSink->closeSession();
+                            bIsAudioRouted = false;
+                        }
+
+                        // 3. Call AUDIO_STOP on the Driver.
+                        LOGV("Received AUDIO_EVENT_SUSPEND and calling AUDIO_STOP");
+                        mIsDriverStarted = false;
+                        if ( ioctl(afd, AUDIO_STOP, 0) < 0 ) {
+                            LOGE("AUDIO_STOP failed");
+                        }
+                        break;
+                    }
+
+                    // 4. Close the session if existing
+                    if(bIsAudioRouted) {
+                        mAudioSink->closeSession();
+                        bIsAudioRouted = false;
+                    }
+                }
+            }
+            break;
+        case AUDIO_EVENT_RESUME:
+            {
+                LOGV("AUDIO_EVENT_RESUME received\n");
+            }
+            break;
+        default:
+            LOGV("Received Invalid Event from driver\n");
+            break;
+        }
+    }
+    eventThreadAlive = false;
+    LOGV("Event Thread is dying.");
+
+}
+
+void *LPAPlayer::A2DPThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->A2DPThreadEntry();
+    return NULL;
+}
+
+void LPAPlayer::A2DPThreadEntry() {
+    setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"LPA A2DPThread", 0, 0, 0);
+
+    //TODO: Remove this
+/*
+    LOGV("a2dpThreadEntry wait for signal \n");
+    pthread_cond_wait(&a2dp_cv, &a2dp_mutex);
+    LOGV("a2dpThreadEntry ready to work \n");
+    pthread_mutex_unlock(&a2dp_mutex);
+
+    a2dpThreadStarted = true;
+
+    if (killA2DPThread) {
+        a2dpThreadAlive = false;
+        return;
+    }
+*/
+    while (1) {
+        /* If exitPending break here */
+        if (killA2DPThread) {
+            break;
+        }
+
+        pthread_mutex_lock(&mem_response_mutex);
+        if (memBuffersResponseQueue.empty() || !mAudioSinkOpen || isPaused || !bIsA2DPEnabled) {
+            LOGV("A2DPThreadEntry:: responseQ empty %d mAudioSinkOpen %d isPaused %d bIsA2DPEnabled %d",
+                 memBuffersResponseQueue.empty(), mAudioSinkOpen, isPaused, bIsA2DPEnabled);
+            LOGV("A2DPThreadEntry:: Waiting on a2dp_cv");
+            pthread_cond_wait(&a2dp_cv, &mem_response_mutex);
+            LOGV("A2DPThreadEntry:: received signal to wake up");
+            // A2DP got disabled -- Queue up everything back to Request Queue
+            if (!bIsA2DPEnabled) {
+                LOGV("mem_request_mutex locking: %d", __LINE__);
+                pthread_mutex_lock(&mem_request_mutex);
+                LOGV("mem_request_mutex locked: %d", __LINE__);
+                while (!memBuffersResponseQueue.empty()) {
+                    LOGV("BUF transfer");
+                    List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+                    BuffersAllocated buf = *it;
+                    memBuffersRequestQueue.push_back(buf);
+                    memBuffersResponseQueue.erase(it);
+                }
+                LOGV("mem_request_mutex unlocking: %d", __LINE__);
+                pthread_mutex_unlock(&mem_request_mutex);
+                LOGV("mem_request_mutex unlocked: %d", __LINE__);
+            }
+            pthread_mutex_unlock(&mem_response_mutex);
+        }
+        //A2DP is enabled -- Continue normal Playback
+        else {
+            List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+            BuffersAllocated buf = *it;
+            memBuffersResponseQueue.erase(it);
+            pthread_mutex_unlock(&mem_response_mutex);
+            bytesToWrite = buf.bytesToWrite;
+            LOGV("bytes To write:%d",bytesToWrite);
+            if (timeStarted == 0) {
+                LOGV("Time started in A2DP thread");
+                timeStarted = nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC));
+            }
+            //LOGV("16 bit :: cmdid = %d, len = %u, bytesAvailInBuffer = %u, bytesToWrite = %u", cmdid, len, bytesAvailInBuffer, bytesToWrite);
+
+            uint32_t bytesWritten = 0;
+            uint32_t numBytesRemaining = 0;
+            uint32_t bytesAvailInBuffer = 0;
+            void* data = buf.localBuf;
+
+            while (bytesToWrite) {
+                /* If exitPending break here */
+                if (killA2DPThread || !bIsA2DPEnabled) {
+                    LOGV("A2DPThreadEntry: A2DPThread set to be killed");
+                    break;
+                }
+
+                bytesAvailInBuffer = mAudioSink->bufferSize();
+
+                uint32_t writeLen = bytesAvailInBuffer > bytesToWrite ? bytesToWrite : bytesAvailInBuffer;
+                //LOGV("16 bit :: cmdid = %d, len = %u, bytesAvailInBuffer = %u, bytesToWrite = %u", cmdid, len, bytesAvailInBuffer, bytesToWrite);
+                bytesWritten = mAudioSink->write(data, writeLen);
+                /*if ( bytesWritten != writeLen ) {
+                    if (mSeeked) {
+                        break;
+                    }
+                    LOGE("Error writing audio data");
+                    pthread_mutex_lock(&a2dp_mutex);
+                    pthread_cond_wait(&a2dp_cv, &a2dp_mutex);
+                    pthread_mutex_unlock(&a2dp_mutex);
+                    if (mSeeked) {
+                        break;
+                    }
+                }*/
+                if ( bytesWritten != writeLen ) {
+                    //Paused - Wait till resume
+                    if (isPaused) {
+                        LOGV("Pausing A2DP playback");
+                        pthread_mutex_lock(&a2dp_mutex);
+                        pthread_cond_wait(&a2dp_cv, &a2dp_mutex);
+                        pthread_mutex_unlock(&a2dp_mutex);
+                    }
+
+                    //Seeked: break out of loop, flush old buffers and write new buffers
+                    LOGV("@_@bytes To write1:%d",bytesToWrite);
+                }
+                /* Incase of A2DP disconnect and connects back flushing all the buffers
+                   which are decoded by fillbuffer and not sent to A2DP */
+                if( a2dpResumeAfterReConnect == true )
+                {
+                    a2dpResumeAfterReConnect = false;
+                    while (!memBuffersResponseQueue.empty()) {
+                        List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+                        BuffersAllocated buf = *it;
+                        memBuffersRequestQueue.push_back(buf);
+                        memBuffersResponseQueue.erase(it);
+                    }
+                    break;
+                }
+                if (mSeeked) {
+                    LOGV("Seeking A2DP Playback");
+                    break;
+                }
+                data += bytesWritten;
+                bytesToWrite -= bytesWritten;
+                LOGV("@_@bytes To write2:%d",bytesToWrite);
+            }
+            if (mObserver && !asyncReset && mReachedEOS && memBuffersResponseQueue.empty()) {
+                LOGV("Posting EOS event to AwesomePlayer");
+                mObserver->postAudioEOS();
+            }
+            LOGV("mem_request_mutex locking: %d", __LINE__);
+            pthread_mutex_lock(&mem_request_mutex);
+            LOGV("mem_request_mutex locked: %d", __LINE__);
+            memBuffersRequestQueue.push_back(buf);
+            if (killA2DPThread) {
+                LOGV("mem_request_mutex unlocking: %d", __LINE__);
+                pthread_mutex_unlock(&mem_request_mutex);
+                LOGV("mem_request_mutex unlocked: %d", __LINE__);
+                break;
+            }
+            //flush out old buffer
+            if (mSeeked || !bIsA2DPEnabled) {
+                mSeeked = false;
+                LOGV("A2DPThread: Putting buffers back to requestQ from responseQ");
+                pthread_mutex_lock(&mem_response_mutex);
+                while (!memBuffersResponseQueue.empty()) {
+                    List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+                    BuffersAllocated buf = *it;
+                    memBuffersRequestQueue.push_back(buf);
+                    memBuffersResponseQueue.erase(it);
+                }
+                pthread_mutex_unlock(&mem_response_mutex);
+            }
+            LOGV("mem_request_mutex unlocking: %d", __LINE__);
+            pthread_mutex_unlock(&mem_request_mutex);
+            LOGV("mem_request_mutex unlocked: %d", __LINE__);
+            // Signal decoder thread when a buffer is put back to request Q
+            pthread_cond_signal(&decoder_cv);
+        }
+    }
+    a2dpThreadAlive = false;
+
+    LOGV("AudioSink stop");
+    if(mAudioSinkOpen) {
+        mAudioSinkOpen = false;
+        mAudioSink->stop();
+    }
+
+    LOGV("A2DP Thread is dying.");
+}
+
+void *LPAPlayer::EffectsThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->EffectsThreadEntry();
+    return NULL;
+}
+
+void LPAPlayer::EffectsThreadEntry() {
+    while(1) {
+        if(killEffectsThread) {
+            break;
+        }
+        pthread_mutex_lock(&effect_mutex);
+
+        if(bEffectConfigChanged) {
+            bEffectConfigChanged = false;
+
+            // 1. Clear current effectQ
+            LOGV("Clearing EffectQ: size %d", effectsQueue.size());
+            while (!effectsQueue.empty())  {
+                List<BuffersAllocated>::iterator it = effectsQueue.begin();
+                effectsQueue.erase(it);
+            }
+
+            // 2. Lock the responseQ mutex
+            pthread_mutex_lock(&mem_response_mutex);
+
+            // 3. Copy responseQ to effectQ
+            LOGV("Copying responseQ to effectQ: responseQ size %d", memBuffersResponseQueue.size());
+            for (List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+                it != memBuffersResponseQueue.end(); ++it) {
+                BuffersAllocated buf = *it;
+                effectsQueue.push_back(buf);
+            }
+
+            // 4. Unlock the responseQ mutex
+            pthread_mutex_unlock(&mem_response_mutex);
+        }
+        // If effectQ is empty just wait for a signal
+        // Else dequeue a buffer, apply effects and delete it from effectQ
+        if(effectsQueue.empty() || asyncReset || bIsA2DPEnabled) {
+            LOGV("EffectQ is empty or Reset called or A2DP enabled, waiting for signal");
+            pthread_cond_wait(&effect_cv, &effect_mutex);
+            LOGV("effectsThread: received signal to wake up");
+            pthread_mutex_unlock(&effect_mutex);
+        } else {
+            pthread_mutex_unlock(&effect_mutex);
+
+            List<BuffersAllocated>::iterator it = effectsQueue.begin();
+            BuffersAllocated buf = *it;
+
+            pthread_mutex_lock(&apply_effect_mutex);
+            LOGV("effectsThread: applying effects on %p fd %d", buf.memBuf, (int)buf.memFd);
+            mAudioFlinger->applyEffectsOn((int16_t*)buf.localBuf,
+                                          (int16_t*)buf.memBuf,
+                                          (int)buf.bytesToWrite);
+            pthread_mutex_unlock(&apply_effect_mutex);
+            effectsQueue.erase(it);
+        }
+    }
+    LOGV("Effects thread is dead");
+    effectsThreadAlive = false;
+}
+
+void LPAPlayer::createThreads() {
+
+    //Initialize all the Mutexes and Condition Variables
+    pthread_mutex_init(&mem_request_mutex, NULL);
+    pthread_mutex_init(&mem_response_mutex, NULL);
+    pthread_mutex_init(&decoder_mutex, NULL);
+    pthread_mutex_init(&event_mutex, NULL);
+    pthread_mutex_init(&a2dp_mutex, NULL);
+    pthread_mutex_init(&effect_mutex, NULL);
+    pthread_mutex_init(&apply_effect_mutex, NULL);
+
+    pthread_cond_init (&event_cv, NULL);
+    pthread_cond_init (&decoder_cv, NULL);
+    pthread_cond_init (&a2dp_cv, NULL);
+    pthread_cond_init (&effect_cv, NULL);
+    pthread_cond_init (&event_thread_cv, NULL);
+    // Create 4 threads Effect, decoder, event and A2dp
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    killDecoderThread = false;
+    killEventThread = false;
+    killA2DPThread = false;
+    killEffectsThread = false;
+
+    decoderThreadAlive = true;
+    eventThreadAlive = true;
+    a2dpThreadAlive = true;
+    effectsThreadAlive = true;
+
+    LOGV("Creating Event Thread");
+    pthread_create(&eventThread, &attr, eventThreadWrapper, this);
+
+    LOGV("Creating decoder Thread");
+    pthread_create(&decoderThread, &attr, decoderThreadWrapper, this);
+
+    LOGV("Creating A2dp Thread");
+    pthread_create(&A2DPThread, &attr, A2DPThreadWrapper, this);
+
+    LOGV("Creating Effects Thread");
+    pthread_create(&EffectsThread, &attr, EffectsThreadWrapper, this);
+
+    pthread_attr_destroy(&attr);
+}
+
+
+size_t LPAPlayer::fillBuffer(void *data, size_t size) {
+    LOGE("fillBuffer");
+    if (mNumFramesPlayed == 0) {
+        LOGV("AudioCallback");
+    }
+
+    LOGV("Number of Frames Played: %u", mNumFramesPlayed);
+    if (mReachedEOS) {
+        return 0;
+    }
+
+    size_t size_done = 0;
+    size_t size_remaining = size;
+    while (size_remaining > 0) {
+        MediaSource::ReadOptions options;
+        {
+            Mutex::Autolock autoLock(mLock);
+
+            if (mSeeking || mInternalSeeking) {
+                if (mIsFirstBuffer) {
+                    if (mFirstBuffer != NULL) {
+                        mFirstBuffer->release();
+                        mFirstBuffer = NULL;
+                    }
+                    mIsFirstBuffer = false;
+                }
+
+                options.setSeekTo(mSeekTimeUs);
+
+                if (mInputBuffer != NULL) {
+                    mInputBuffer->release();
+                    mInputBuffer = NULL;
+                }
+
+                // This is to ignore the data already filled in the output buffer
+                size_done = 0;
+                size_remaining = size;
+
+                if (mSeeking){
+                   mInternalSeeking = false;
+                }
+
+                mSeeking = false;
+                if (mObserver && !asyncReset && !mInternalSeeking) {
+                    LOGV("fillBuffer: Posting audio seek complete event");
+                    mObserver->postAudioSeekComplete();
+                }
+                mInternalSeeking = false;
+            }
+        }
+        if (mInputBuffer == NULL) {
+            status_t err;
+
+            if (mIsFirstBuffer) {
+                mInputBuffer = mFirstBuffer;
+                mFirstBuffer = NULL;
+                err = mFirstBufferResult;
+
+                mIsFirstBuffer = false;
+            } else {
+                err = mSource->read(&mInputBuffer, &options);
+            }
+
+            CHECK((err == OK && mInputBuffer != NULL)
+                  || (err != OK && mInputBuffer == NULL));
+
+            Mutex::Autolock autoLock(mLock);
+
+            if (err != OK) {
+				LOGV("err != ok");
+                if (err == INFO_FORMAT_CHANGED) {
+					LOGV("INFO_FORMAT_CHANGED");
+                    sp<MetaData> format = mSource->getFormat();
+                    const char *mime;
+                    bool success = format->findCString(kKeyMIMEType, &mime);
+                    CHECK(success);
+                    CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
+
+                    success = format->findInt32(kKeySampleRate, &mSampleRate);
+                    CHECK(success);
+
+                    int32_t numChannels;
+                    success = format->findInt32(kKeyChannelCount, &numChannels);
+                    CHECK(success);
+
+                    if(bIsA2DPEnabled) {
+                        mAudioSink->stop();
+                        mAudioSink->close();
+                        mAudioSinkOpen = false;
+                        status_t err = mAudioSink->open(
+                                mSampleRate, numChannels, AUDIO_FORMAT_PCM_16_BIT,
+                                DEFAULT_AUDIOSINK_BUFFERCOUNT);
+                        if (err != OK) {
+                            mSource->stop();
+                            return err;
+                        }
+                        mAudioSinkOpen = true;
+                        mLatencyUs = (int64_t)mAudioSink->latency() * 1000;
+                        mFrameSize = mAudioSink->frameSize();
+                        mAudioSink->start();
+                    } else {
+                        /* TODO: LPA driver needs to be reconfigured
+                           For MP3 we might not come here but for AAC we need this */
+                        mAudioSink->stop();
+                        mAudioSink->closeSession();
+                        LOGV("Opening a routing session in fillBuffer: sessionId = %d mSampleRate %d numChannels %d",
+                             sessionId, mSampleRate, numChannels);
+                        status_t err = mAudioSink->openSession(AUDIO_FORMAT_PCM_16_BIT, sessionId, mSampleRate, numChannels);
+                        if (err != OK) {
+                            mSource->stop();
+                            return err;
+                        }
+                    }
+                    break;
+                } else {
+                    mReachedEOS = true;
+                    mFinalStatus = err;
+                    break;
+                }
+            }
+
+            CHECK(mInputBuffer->meta_data()->findInt64(
+                                                      kKeyTime, &mPositionTimeMediaUs));
+
+            mFrameSize = mAudioSink->frameSize();
+            mPositionTimeRealUs =
+            ((mNumFramesPlayed + size_done / mFrameSize) * 1000000)
+            / mSampleRate;
+
+            //   LOGV("buffer->size() = %d, "
+            //       "mPositionTimeMediaUs=%.2f mPositionTimeRealUs=%.2f",
+            //       mInputBuffer->range_length(),
+            //      mPositionTimeMediaUs / 1E6, mPositionTimeRealUs / 1E6);
+        }
+        if (mInputBuffer->range_length() == 0) {
+            mInputBuffer->release();
+            mInputBuffer = NULL;
+            continue;
+        }
+
+        size_t copy = size_remaining;
+        if (copy > mInputBuffer->range_length()) {
+            copy = mInputBuffer->range_length();
+        }
+
+        memcpy((char *)data + size_done,
+               (const char *)mInputBuffer->data() + mInputBuffer->range_offset(),
+               copy);
+
+        mInputBuffer->set_range(mInputBuffer->range_offset() + copy,
+                                mInputBuffer->range_length() - copy);
+
+        size_done += copy;
+        size_remaining -= copy;
+    }
+    return size_done;
+}
+
+int64_t LPAPlayer::getRealTimeUs() {
+    Mutex::Autolock autoLock(mLock);
+    return getRealTimeUsLocked();
+}
+
+
+int64_t LPAPlayer::getRealTimeUsLocked(){
+    /* struct msm_audio_stats stats;
+
+     // 1. Get the Byte count that is consumed
+     if ( ioctl(afd, AUDIO_GET_STATS, &stats)  < 0 ) {
+         LOGE("AUDIO_GET_STATUS failed");
+     }
+
+     //mNumFramesDspPlayed = mNumFramesPlayed - ((PMEM_BUFFER_SIZE - stats.byte_count)/mFrameSize);
+     LOGE("AUDIO_GET_STATUS bytes %u, mNumFramesPlayed %u", stats.byte_count/mFrameSize,mNumFramesPlayed);
+     //mNumFramesDspPlayed = mNumFramesPlayed + stats.byte_count/mFrameSize;
+
+     int64_t temp = (stats.byte_count/mFrameSize)+mNumFramesPlayed;
+     LOGE("Number of frames played by the DSP is %u", temp);
+     int64_t temp1 = -mLatencyUs + (temp * 1000000) / mSampleRate;
+     LOGE("getRealTimeUsLocked() %u", temp1);
+     return temp1;*/
+
+    return nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted + timePlayed;
+}
+
+int64_t LPAPlayer::getMediaTimeUs() {
+    Mutex::Autolock autoLock(mLock);
+/*
+if (mPositionTimeMediaUs < 0 || mPositionTimeRealUs < 0) {
+return 0;
+}
+
+int64_t realTimeOffset = getRealTimeUsLocked() - mPositionTimeRealUs;
+if (realTimeOffset < 0) {
+realTimeOffset = 0;
+}
+
+return mPositionTimeMediaUs + realTimeOffset;
+*/
+    /* When A2DP connects in the middile timePlayed will be updated to the
+       number of buffer played from zero which will be non-zero value
+       incase if user does not perform any seek operation timePlayed will be
+       willbe non-zero and which will effect the seekbar after playback
+       to resolve this sending zero when the EOS reached and A2DP enable */
+    if( isPaused && bIsA2DPEnabled && mReachedEOS )
+        return 0;
+    LOGV("getMediaTimeUs() isPaused %d timeStarted %lld timePlayed %lld", isPaused, timeStarted, timePlayed);
+    if (isPaused || timeStarted == 0) {
+        return timePlayed;
+    } else {
+        LOGV("curr_time %d", nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)));
+        return nanoseconds_to_microseconds(systemTime(SYSTEM_TIME_MONOTONIC)) - timeStarted + timePlayed;
+    }
+
+    /*int64_t bytes = (int64_t)stats.byte_count;
+    LOGV("stats %u    %u",bytes,stats.byte_count);
+    LOGV("secs played %u", ((stats.byte_count/4) * 1000000)/mSampleRate );
+    return((stats.byte_count/4) * 1000000)/mSampleRate;*/
+}
+
+bool LPAPlayer::getMediaTimeMapping(
+                                   int64_t *realtime_us, int64_t *mediatime_us) {
+    Mutex::Autolock autoLock(mLock);
+
+    *realtime_us = mPositionTimeRealUs;
+    *mediatime_us = mPositionTimeMediaUs;
+
+    return mPositionTimeRealUs != -1 && mPositionTimeMediaUs != -1;
+}
+
+void LPAPlayer::requestAndWaitForDecoderThreadExit() {
+
+    if (!decoderThreadAlive)
+        return;
+
+    LOGV("mem_request_mutex locking: %d", __LINE__);
+    pthread_mutex_lock(&mem_request_mutex);
+    LOGV("mem_request_mutex locked: %d", __LINE__);
+    killDecoderThread = true;
+    pthread_cond_signal(&decoder_cv);
+    LOGV("mem_request_mutex unlocking: %d", __LINE__);
+    pthread_mutex_unlock(&mem_request_mutex);
+    LOGV("mem_request_mutex unlocked: %d", __LINE__);
+    pthread_join(decoderThread,NULL);
+    LOGV("decoder thread killed");
+
+}
+
+void LPAPlayer::requestAndWaitForEventThreadExit() {
+    if (!eventThreadAlive)
+        return;
+    killEventThread = true;
+    pthread_mutex_lock(&event_mutex);
+    if (!eventThreadCreated)
+        pthread_cond_wait(&event_thread_cv,&event_mutex);
+    pthread_mutex_unlock(&event_mutex);
+    pthread_cond_signal(&event_cv);
+    if (ioctl(afd, AUDIO_ABORT_GET_EVENT, 0) < 0) {
+        LOGE("Audio Abort event failed");
+    }
+    /*pthread_cond_wait(&event_cv, &event_mutex);
+    pthread_mutex_unlock(&event_mutex);
+    */
+    pthread_join(eventThread,NULL);
+    LOGV("event thread killed");
+}
+
+void LPAPlayer::requestAndWaitForA2DPThreadExit() {
+    if (!a2dpThreadAlive)
+        return;
+    killA2DPThread = true;
+    pthread_cond_signal(&a2dp_cv);
+    pthread_join(A2DPThread,NULL);
+    LOGV("a2dp thread killed");
+}
+
+void LPAPlayer::requestAndWaitForEffectsThreadExit() {
+    if (!effectsThreadAlive)
+        return;
+    killEffectsThread = true;
+    pthread_cond_signal(&effect_cv);
+    pthread_join(EffectsThread,NULL);
+    LOGV("effects thread killed");
+}
+
+void LPAPlayer::onPauseTimeOut() {
+    Mutex::Autolock autoLock(resumeLock);
+    struct msm_audio_stats stats;
+    int nBytesConsumed = 0;
+    LOGV("onPauseTimeOut");
+    if (!mPauseEventPending) {
+        return;
+    }
+    mPauseEventPending = false;
+
+    if(!bIsA2DPEnabled) {
+        // Reset eosflag to resume playback where we actually paused
+        mInternalSeeking = true;
+        mReachedEOS = false;
+        mSeekTimeUs = timePlayed;
+        LOGV("%s: mSeekTimeUs %d ", __func__, mSeekTimeUs);
+
+        // 1. Get the Byte count that is consumed
+        if ( ioctl(afd, AUDIO_GET_STATS, &stats)  < 0 ) {
+            LOGE("AUDIO_GET_STATUS failed");
+        } else {
+            LOGV("Number of bytes consumed by DSP is %u", stats.byte_count);
+            nBytesConsumed = stats.byte_count;
+        }
+
+        // 2. Close the session
+        mAudioSink->closeSession();
+        bIsAudioRouted = false;
+
+        // 3. Call AUDIO_STOP on the Driver.
+        mIsDriverStarted = false;
+        if ( ioctl(afd, AUDIO_STOP, 0) < 0 ) {
+            LOGE("AUDIO_STOP failed");
+        }
+    }
+}
+
+}//namespace android
diff --git a/media/libstagefright/LPAPlayerALSA.cpp b/media/libstagefright/LPAPlayerALSA.cpp
new file mode 100755
index 0000000..8965cd3
--- /dev/null
+++ b/media/libstagefright/LPAPlayerALSA.cpp
@@ -0,0 +1,1739 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2009-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_NDDEBUG 0
+#define LOG_NDEBUG 0
+#define LOG_TAG "LPAPlayerALSA"
+
+#include <utils/Log.h>
+#include <utils/threads.h>
+
+#include <signal.h>
+#include <sys/prctl.h>
+#include <sys/resource.h>
+#include <sys/poll.h>
+#include <sys/eventfd.h>
+#include <binder/IPCThreadState.h>
+#include <media/AudioTrack.h>
+
+extern "C" {
+   #include <sound/asound.h>
+   #include "alsa_audio.h"
+}
+
+#include <media/stagefright/LPAPlayer.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/MediaErrors.h>
+
+#include <hardware_legacy/power.h>
+
+#include <linux/unistd.h>
+
+#include "include/AwesomePlayer.h"
+#include <powermanager/PowerManager.h>
+
+static const char   mName[] = "LPAPlayer";
+
+#define MEM_BUFFER_SIZE 262144
+//#define PMEM_BUFFER_SIZE (4800 * 4)
+#define MEM_BUFFER_COUNT 4
+
+//Values to exit poll via eventfd
+#define KILL_EVENT_THREAD 1
+#define SIGNAL_EVENT_THREAD 2
+#define PCM_FORMAT 2
+#define NUM_FDS 2
+#define LPA_SESSION_ID 1
+namespace android {
+int LPAPlayer::objectsAlive = 0;
+
+LPAPlayer::LPAPlayer(
+                    const sp<MediaPlayerBase::AudioSink> &audioSink, bool &initCheck,
+                    AwesomePlayer *observer)
+:mInputBuffer(NULL),
+mSampleRate(0),
+mLatencyUs(0),
+mFrameSize(0),
+mSeekTimeUs(0),
+mNumFramesPlayed(0),
+mPositionTimeMediaUs(-1),
+mPositionTimeRealUs(-1),
+mPauseTime(0),
+mNumA2DPBytesPlayed(0),
+mSeeking(false),
+mInternalSeeking(false),
+mReachedEOS(false),
+mReachedOutputEOS(false),
+mFinalStatus(OK),
+mStarted(false),
+mIsFirstBuffer(false),
+mFirstBufferResult(OK),
+mFirstBuffer(NULL),
+mAudioSink(audioSink),
+mObserver(observer),
+AudioPlayer(audioSink,observer) {
+    LOGV("LPAPlayer::LPAPlayer() ctor");
+    a2dpDisconnectPause = false;
+    mSeeked = false;
+    objectsAlive++;
+    timeStarted = 0;
+    numChannels =0;
+    afd = -1;
+    timePlayed = 0;
+    isPaused = false;
+    bIsA2DPEnabled = false;
+    mAudioFlinger = NULL;
+    AudioFlingerClient = NULL;
+    efd = -1;
+    /* Initialize Suspend/Resume related variables */
+    mQueue.start();
+    mQueueStarted      = true;
+    mPauseEvent        = new TimedEvent(this, &LPAPlayer::onPauseTimeOut);
+    mPauseEventPending = false;
+    mPlaybackSuspended = false;
+    getAudioFlinger();
+    LOGV("Registering client with AudioFlinger");
+    mAudioFlinger->registerClient(AudioFlingerClient);
+    mAudioSinkOpen = false;
+    mIsAudioRouted = false;
+    a2dpThreadStarted = true;
+    asyncReset = false;
+
+    sessionId = LPA_SESSION_ID;
+    bEffectConfigChanged = false;
+    initCheck = true;
+
+    mDeathRecipient = new PMDeathRecipient(this);
+}
+
+void LPAPlayer::acquireWakeLock()
+{
+    Mutex::Autolock _l(pmLock);
+
+    if (mPowerManager == 0) {
+        // use checkService() to avoid blocking if power service is not up yet
+        sp<IBinder> binder =
+            defaultServiceManager()->checkService(String16("power"));
+        if (binder == 0) {
+            LOGW("Thread %s cannot connect to the power manager service", mName);
+        } else {
+            mPowerManager = interface_cast<IPowerManager>(binder);
+            binder->linkToDeath(mDeathRecipient);
+        }
+    }
+    if (mPowerManager != 0 && mWakeLockToken == 0) {
+        sp<IBinder> binder = new BBinder();
+        status_t status = mPowerManager->acquireWakeLock(POWERMANAGER_PARTIAL_WAKE_LOCK,
+                                                         binder,
+                                                         String16(mName));
+        if (status == NO_ERROR) {
+            mWakeLockToken = binder;
+        }
+        LOGV("acquireWakeLock() %s status %d", mName, status);
+    }
+}
+
+void LPAPlayer::releaseWakeLock()
+{
+    Mutex::Autolock _l(pmLock);
+
+    if (mWakeLockToken != 0) {
+        LOGV("releaseWakeLock() %s", mName);
+        if (mPowerManager != 0) {
+            mPowerManager->releaseWakeLock(mWakeLockToken, 0);
+        }
+        mWakeLockToken.clear();
+    }
+}
+
+void LPAPlayer::clearPowerManager()
+{
+    Mutex::Autolock _l(pmLock);
+    releaseWakeLock();
+    mPowerManager.clear();
+}
+
+void LPAPlayer::PMDeathRecipient::binderDied(const wp<IBinder>& who)
+{
+    parentClass->clearPowerManager();
+    LOGW("power manager service died !!!");
+}
+
+LPAPlayer::~LPAPlayer() {
+    LOGV("LPAPlayer::~LPAPlayer()");
+    if (mQueueStarted) {
+        mQueue.stop();
+    }
+
+    reset();
+
+    mAudioFlinger->deregisterClient(AudioFlingerClient);
+    objectsAlive--;
+
+    releaseWakeLock();
+    if (mPowerManager != 0) {
+        sp<IBinder> binder = mPowerManager->asBinder();
+        binder->unlinkToDeath(mDeathRecipient);
+    }
+}
+
+void LPAPlayer::getAudioFlinger() {
+    Mutex::Autolock _l(AudioFlingerLock);
+
+    if ( mAudioFlinger.get() == 0 ) {
+        sp<IServiceManager> sm = defaultServiceManager();
+        sp<IBinder> binder;
+        do {
+            binder = sm->getService(String16("media.audio_flinger"));
+            if ( binder != 0 )
+                break;
+            LOGW("AudioFlinger not published, waiting...");
+            usleep(500000); // 0.5 s
+        } while ( true );
+        if ( AudioFlingerClient == NULL ) {
+            AudioFlingerClient = new AudioFlingerLPAdecodeClient(this);
+        }
+
+        binder->linkToDeath(AudioFlingerClient);
+        mAudioFlinger = interface_cast<IAudioFlinger>(binder);
+    }
+    LOGE_IF(mAudioFlinger==0, "no AudioFlinger!?");
+}
+
+LPAPlayer::AudioFlingerLPAdecodeClient::AudioFlingerLPAdecodeClient(void *obj)
+{
+    LOGV("LPAPlayer::AudioFlingerLPAdecodeClient::AudioFlingerLPAdecodeClient");
+    pBaseClass = (LPAPlayer*)obj;
+}
+
+void LPAPlayer::AudioFlingerLPAdecodeClient::binderDied(const wp<IBinder>& who) {
+    Mutex::Autolock _l(pBaseClass->AudioFlingerLock);
+
+    pBaseClass->mAudioFlinger.clear();
+    LOGW("AudioFlinger server died!");
+}
+
+void LPAPlayer::AudioFlingerLPAdecodeClient::ioConfigChanged(int event, int ioHandle, void *param2) {
+    LOGV("ioConfigChanged() event %d", event);
+
+    if ( event != AudioSystem::A2DP_OUTPUT_STATE &&
+         event != AudioSystem::EFFECT_CONFIG_CHANGED) {
+        return;
+    }
+
+    switch ( event ) {
+    case AudioSystem::A2DP_OUTPUT_STATE:
+        {
+            LOGV("ioConfigChanged() A2DP_OUTPUT_STATE iohandle is %d with A2DPEnabled in %d", ioHandle, pBaseClass->bIsA2DPEnabled);
+            if ( -1 == ioHandle ) {
+                if ( pBaseClass->bIsA2DPEnabled ) {
+                    pBaseClass->bIsA2DPEnabled = false;
+                    if (pBaseClass->mStarted) {
+                        pBaseClass->handleA2DPSwitch();
+                    }
+                    LOGV("ioConfigChanged:: A2DP Disabled");
+                }
+            } else {
+                if ( !pBaseClass->bIsA2DPEnabled ) {
+
+                    pBaseClass->bIsA2DPEnabled = true;
+                    if (pBaseClass->mStarted) {
+                        pBaseClass->handleA2DPSwitch();
+                    }
+
+                    LOGV("ioConfigChanged:: A2DP Enabled");
+                }
+            }
+        }
+        break;
+    case AudioSystem::EFFECT_CONFIG_CHANGED:
+        {
+            LOGV("Received notification for change in effect module");
+            // Seek to current media time - flush the decoded buffers with the driver
+            if(!pBaseClass->bIsA2DPEnabled) {
+                pthread_mutex_lock(&pBaseClass->effect_mutex);
+                pBaseClass->bEffectConfigChanged = true;
+                pthread_mutex_unlock(&pBaseClass->effect_mutex);
+                // Signal effects thread to re-apply effects
+                LOGV("Signalling Effects Thread");
+                pthread_cond_signal(&pBaseClass->effect_cv);
+            }
+        }
+    }
+
+    LOGV("ioConfigChanged Out");
+}
+
+void LPAPlayer::handleA2DPSwitch() {
+    Mutex::Autolock autoLock(mLock);
+
+    LOGV("handleA2dpSwitch()");
+    if (bIsA2DPEnabled) {
+        struct pcm * local_handle = (struct pcm *)handle;
+        if (!isPaused) {
+            if(mIsAudioRouted) {
+                if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_PAUSE,1) < 0) {
+                    LOGE("AUDIO PAUSE failed");
+                }
+            }
+
+            LOGV("paused for bt switch");
+            mSeekTimeUs += getTimeStamp(A2DP_CONNECT);
+        }
+        else {
+            mSeekTimeUs = mPauseTime;
+        }
+
+        mInternalSeeking = true;
+        mNumA2DPBytesPlayed = 0;
+        mReachedEOS = false;
+        mReachedOutputEOS = false;
+        pthread_cond_signal(&a2dp_notification_cv);
+    } else {
+        if (isPaused)
+            pthread_cond_signal(&a2dp_notification_cv);
+        else
+            a2dpDisconnectPause = true;
+    }
+}
+
+void LPAPlayer::setSource(const sp<MediaSource> &source) {
+    CHECK_EQ(mSource, NULL);
+    LOGV("Setting source from LPA Player");
+    mSource = source;
+}
+
+status_t LPAPlayer::start(bool sourceAlreadyStarted) {
+    CHECK(!mStarted);
+    CHECK(mSource != NULL);
+
+    LOGV("start: sourceAlreadyStarted %d", sourceAlreadyStarted);
+    //Check if the source is started, start it
+    status_t err;
+    if (!sourceAlreadyStarted) {
+        err = mSource->start();
+
+        if (err != OK) {
+            return err;
+        }
+    }
+
+    //Create event, decoder and a2dp thread and initialize all the
+    //mutexes and coditional variables
+    createThreads();
+    LOGV("All Threads Created.");
+
+    // We allow an optional INFO_FORMAT_CHANGED at the very beginning
+    // of playback, if there is one, getFormat below will retrieve the
+    // updated format, if there isn't, we'll stash away the valid buffer
+    // of data to be used on the first audio callback.
+
+    CHECK(mFirstBuffer == NULL);
+
+    MediaSource::ReadOptions options;
+    if (mSeeking) {
+        options.setSeekTo(mSeekTimeUs);
+        mSeeking = false;
+    }
+
+    mFirstBufferResult = mSource->read(&mFirstBuffer, &options);
+    if (mFirstBufferResult == INFO_FORMAT_CHANGED) {
+        LOGV("INFO_FORMAT_CHANGED!!!");
+        CHECK(mFirstBuffer == NULL);
+        mFirstBufferResult = OK;
+        mIsFirstBuffer = false;
+    } else {
+        mIsFirstBuffer = true;
+    }
+
+    /*TODO: Check for bA2dpEnabled */
+
+    sp<MetaData> format = mSource->getFormat();
+    const char *mime;
+    bool success = format->findCString(kKeyMIMEType, &mime);
+    CHECK(success);
+    CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
+
+    success = format->findInt32(kKeySampleRate, &mSampleRate);
+    CHECK(success);
+
+    success = format->findInt32(kKeyChannelCount, &numChannels);
+    CHECK(success);
+
+
+    if (!bIsA2DPEnabled) {
+        LOGV("Opening a routing session for audio playback: sessionId = %d mSampleRate %d numChannels %d",
+             sessionId, mSampleRate, numChannels);
+        status_t err = mAudioSink->openSession(AUDIO_FORMAT_PCM_16_BIT, sessionId, mSampleRate, numChannels);
+        if (err != OK) {
+            if (mFirstBuffer != NULL) {
+                mFirstBuffer->release();
+                mFirstBuffer = NULL;
+            }
+
+            if (!sourceAlreadyStarted) {
+                mSource->stop();
+            }
+
+            LOGE("Opening a routing session failed");
+            return err;
+        }
+        acquireWakeLock();
+        mIsAudioRouted = true;
+    }
+    else {
+        LOGV("Before Audio Sink Open");
+        status_t ret = mAudioSink->open(mSampleRate, numChannels,AUDIO_FORMAT_PCM_16_BIT, DEFAULT_AUDIOSINK_BUFFERCOUNT);
+        mAudioSink->start();
+        LOGV("After Audio Sink Open");
+        mAudioSinkOpen = true;
+    }
+
+    LOGV("pcm_open hardware 0,4 for LPA ");
+    //Open PCM driver
+    if (numChannels == 1)
+        handle = (void *)pcm_open((PCM_MMAP | DEBUG_ON | PCM_MONO) , "hw:0,4");
+    else
+        handle = (void *)pcm_open((PCM_MMAP | DEBUG_ON | PCM_STEREO) , "hw:0,4");
+
+    struct pcm * local_handle = (struct pcm *)handle;
+    if (!local_handle) {
+        LOGE("Failed to initialize ALSA hardware hw:0,4");
+        return BAD_VALUE;
+    }
+
+    struct snd_pcm_hw_params *params;
+    struct snd_pcm_sw_params *sparams;
+    params = (struct snd_pcm_hw_params*) calloc(1, sizeof(struct snd_pcm_hw_params));
+    if (!params) {
+      LOGV( "Aplay:Failed to allocate ALSA hardware parameters!");
+      return -1;
+    }
+    param_init(params);
+    param_set_mask(params, SNDRV_PCM_HW_PARAM_ACCESS, SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
+    param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_FORMAT_S16_LE);
+    param_set_mask(params, SNDRV_PCM_HW_PARAM_SUBFORMAT,SNDRV_PCM_SUBFORMAT_STD);
+    param_set_min(params, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, MEM_BUFFER_SIZE);
+    param_set_int(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS, 16);
+    param_set_int(params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                numChannels - 1 ? 32 : 16);
+    param_set_int(params, SNDRV_PCM_HW_PARAM_CHANNELS, numChannels);
+    param_set_int(params, SNDRV_PCM_HW_PARAM_RATE, mSampleRate);
+    param_set_hw_refine(local_handle, params);
+    if (param_set_hw_params(local_handle, params)) {
+     LOGV( "Aplay:cannot set hw params");
+     return -22;
+    }
+    param_dump(params);
+    local_handle->buffer_size = pcm_buffer_size(params);
+    local_handle->period_size = pcm_period_size(params);
+    local_handle->period_cnt = local_handle->buffer_size/local_handle->period_size;
+    LOGV("period_cnt = %d\n", local_handle->period_cnt);
+    LOGV("period_size = %d\n", local_handle->period_size);
+    LOGV("buffer_size = %d\n", local_handle->buffer_size);
+
+    sparams = (struct snd_pcm_sw_params*) calloc(1, sizeof(struct snd_pcm_sw_params));
+    if (!sparams) {
+     LOGV( "Aplay:Failed to allocate ALSA software parameters!\n");
+     return -1;
+    }
+    // Get the current software parameters
+    sparams->tstamp_mode = SNDRV_PCM_TSTAMP_NONE;
+    sparams->period_step = 1;
+    sparams->avail_min = local_handle->period_size/2;
+    sparams->start_threshold = local_handle->period_size/2;
+    sparams->stop_threshold =  local_handle->buffer_size;
+    sparams->xfer_align = (local_handle->flags & PCM_MONO) ? local_handle->period_size/2 : local_handle->period_size/4; /* needed for old kernels */
+    sparams->silence_size = 0;
+    sparams->silence_threshold = 0;
+    if (param_set_sw_params(local_handle, sparams)) {
+     LOGV( "Aplay:cannot set sw params");
+     return -22;
+    }
+    mmap_buffer(local_handle);
+    if (!bIsA2DPEnabled)
+       pcm_prepare(local_handle);
+    handle = (void *)local_handle;
+    //Map PMEM buffer
+    LOGV("LPA Driver Started");
+    mStarted = true;
+
+    LOGV("Waking up decoder thread");
+    pthread_cond_signal(&decoder_cv);
+    return OK;
+}
+
+status_t LPAPlayer::seekTo(int64_t time_us) {
+    Mutex::Autolock autoLock1(mSeekLock);
+    Mutex::Autolock autoLock(mLock);
+    LOGV("seekTo: time_us %ld", time_us);
+    if ( mReachedEOS ) {
+        mReachedEOS = false;
+        mReachedOutputEOS = false;
+    }
+    mSeeking = true;
+
+    mSeekTimeUs = time_us;
+    struct pcm * local_handle = (struct pcm *)handle;
+    LOGV("In seekTo(), mSeekTimeUs %lld",mSeekTimeUs);
+    if (!bIsA2DPEnabled) {
+        if (mStarted) {
+            LOGV("Paused case, %d",isPaused);
+
+            pthread_mutex_lock(&mem_response_mutex);
+            pthread_mutex_lock(&mem_request_mutex);
+            memBuffersResponseQueue.clear();
+            memBuffersRequestQueue.clear();
+            
+            List<BuffersAllocated>::iterator it = bufPool.begin();
+            for(;it!=bufPool.end();++it) {
+                 memBuffersRequestQueue.push_back(*it);
+            }
+
+            pthread_mutex_unlock(&mem_request_mutex);
+            pthread_mutex_unlock(&mem_response_mutex);
+            LOGV("Transferred all the buffers from response queue to rquest queue to handle seek");
+            if (!isPaused) {
+                if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_PAUSE,1) < 0) {
+                    LOGE("Audio Pause failed");
+                }
+                local_handle->start = 0;
+                pcm_prepare(local_handle);
+                LOGV("Reset, drain and prepare completed");
+                local_handle->sync_ptr->flags = SNDRV_PCM_SYNC_PTR_APPL | SNDRV_PCM_SYNC_PTR_AVAIL_MIN;
+                sync_ptr(local_handle);
+                LOGV("appl_ptr= %d", local_handle->sync_ptr->c.control.appl_ptr);
+                pthread_cond_signal(&decoder_cv);
+            }
+        }
+    } else {
+        if (!memBuffersResponseQueue.empty())
+            mSeeked = true;
+
+        if (!isPaused) {
+            mAudioSink->pause();
+            mAudioSink->flush();
+            mAudioSink->start();
+        }
+        mNumA2DPBytesPlayed = 0;
+    }
+
+    return OK;
+}
+
+void LPAPlayer::pause(bool playPendingSamples) {
+    CHECK(mStarted);
+
+    LOGV("pause: playPendingSamples %d", playPendingSamples);
+    isPaused = true;
+    A2DPState state;
+    if (playPendingSamples) {
+        isPaused = true;
+        if (!bIsA2DPEnabled) {
+            struct pcm * local_handle = (struct pcm *)handle;
+            if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_PAUSE,1) < 0) {
+                LOGE("Audio Pause failed");
+            }
+            if (!mPauseEventPending) {
+                LOGV("Posting an event for Pause timeout");
+                mQueue.postEventWithDelay(mPauseEvent, LPA_PAUSE_TIMEOUT_USEC);
+                mPauseEventPending = true;
+            }
+            if (mAudioSink.get() != NULL)
+                mAudioSink->pauseSession();
+            state = A2DP_DISABLED;
+        }
+        else {
+            if (mAudioSink.get() != NULL)
+                mAudioSink->stop();
+            state = A2DP_ENABLED;
+        }
+        mPauseTime = mSeekTimeUs + getTimeStamp(state);
+    } else {
+        if (a2dpDisconnectPause) {
+            a2dpDisconnectPause = false;
+            mAudioSink->pause();
+            mPauseTime = mSeekTimeUs + getTimeStamp(A2DP_DISCONNECT);
+            pthread_cond_signal(&a2dp_notification_cv);
+        } else {
+            if (!bIsA2DPEnabled) {
+                LOGV("LPAPlayer::Pause - Pause driver");
+                struct pcm * local_handle = (struct pcm *)handle;
+                pthread_mutex_lock(&pause_mutex);
+                if (local_handle->start != 1) {
+                    pthread_cond_wait(&pause_cv, &pause_mutex);
+                }
+                pthread_mutex_unlock(&pause_mutex);
+                if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_PAUSE,1) < 0) {
+                    LOGE("Audio Pause failed");
+                }
+
+                if(!mPauseEventPending) {
+                    LOGV("Posting an event for Pause timeout");
+                    mQueue.postEventWithDelay(mPauseEvent, LPA_PAUSE_TIMEOUT_USEC);
+                    mPauseEventPending = true;
+                }
+
+                if (mAudioSink.get() != NULL) {
+                    mAudioSink->pauseSession();
+                }
+                state = A2DP_DISABLED;
+            } else {
+                mAudioSink->pause();
+                mAudioSink->flush();
+                state = A2DP_ENABLED;
+            }
+            mPauseTime = mSeekTimeUs + getTimeStamp(state);
+        }
+    }
+}
+
+void LPAPlayer::resume() {
+    LOGV("resume: isPaused %d",isPaused);
+    Mutex::Autolock autoLock(resumeLock);
+    if ( isPaused) {
+        CHECK(mStarted);
+        if (!bIsA2DPEnabled) {
+            LOGE("LPAPlayer::resume - Resuming Driver");
+            if(mPauseEventPending) {
+                LOGV("Resume(): Cancelling the puaseTimeout event");
+                mPauseEventPending = false;
+                mQueue.cancelEvent(mPauseEvent->eventID());
+            }
+            if (mAudioSinkOpen) {
+                mAudioSink->close();
+                mAudioSinkOpen = false;
+                LOGV("Singal to A2DP thread for clean up after closing Audio sink");
+                pthread_cond_signal(&a2dp_cv);
+            }
+
+            if (!mIsAudioRouted) {
+                LOGV("Opening a session for LPA playback");
+                status_t err = mAudioSink->openSession(AUDIO_FORMAT_PCM_16_BIT, sessionId);
+                acquireWakeLock();
+                mIsAudioRouted = true;
+            }
+
+            LOGV("Attempting Sync resume\n");
+            struct pcm * local_handle = (struct pcm *)handle;
+            if (!(mSeeking || mInternalSeeking)) {
+                if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_PAUSE,0) < 0)
+                    LOGE("AUDIO Resume failed");
+                LOGV("Sync resume done\n");
+            }
+            else {
+                local_handle->start = 0;
+                pcm_prepare(local_handle);
+                LOGV("Reset, drain and prepare completed");
+                local_handle->sync_ptr->flags = SNDRV_PCM_SYNC_PTR_APPL | SNDRV_PCM_SYNC_PTR_AVAIL_MIN;
+                sync_ptr(local_handle);
+                LOGV("appl_ptr= %d", local_handle->sync_ptr->c.control.appl_ptr);
+            }
+            if (mAudioSink.get() != NULL) {
+                mAudioSink->resumeSession();
+            }
+        } else {
+            isPaused = false;
+
+            if (!mAudioSinkOpen) {
+                if (mAudioSink.get() != NULL) {
+                    LOGV("%s mAudioSink close session", __func__);
+                    mAudioSink->closeSession();
+                    releaseWakeLock();
+                    mIsAudioRouted = false;
+                } else {
+                    LOGE("close session NULL");
+                }
+
+                LOGV("Resume: Before Audio Sink Open");
+                status_t ret = mAudioSink->open(mSampleRate, numChannels,AUDIO_FORMAT_PCM_16_BIT,
+                                                DEFAULT_AUDIOSINK_BUFFERCOUNT);
+                mAudioSink->start();
+                LOGV("Resume: After Audio Sink Open");
+                mAudioSinkOpen = true;
+
+                LOGV("Resume: Waking up the decoder thread");
+                pthread_cond_signal(&decoder_cv);
+            } else {
+                /* If AudioSink is already open just start it */
+                mAudioSink->start();
+            }
+            LOGV("Waking up A2dp thread");
+            pthread_cond_signal(&a2dp_cv);
+        }
+        isPaused = false;
+        pthread_cond_signal(&decoder_cv);
+
+        /*
+        Signal to effects thread so that it can apply the new effects
+        enabled during pause state
+        */
+        pthread_cond_signal(&effect_cv);
+    }
+}
+
+void LPAPlayer::reset() {
+    LOGV("Reset called!!!!!");
+    asyncReset = true;
+
+    struct pcm * local_handle = (struct pcm *)handle;
+
+    LOGV("reset() requestQueue.size() = %d, responseQueue.size() = %d effectsQueue.size() = %d",
+         memBuffersRequestQueue.size(), memBuffersResponseQueue.size(), effectsQueue.size());
+
+    // make sure the Effects thread has exited
+    requestAndWaitForEffectsThreadExit();
+
+    // make sure Decoder thread has exited
+    requestAndWaitForDecoderThreadExit();
+
+    // make sure the event thread also has exited
+    requestAndWaitForEventThreadExit();
+
+    requestAndWaitForA2DPThreadExit();
+
+    requestAndWaitForA2DPNotificationThreadExit();
+
+
+
+    // Make sure to release any buffer we hold onto so that the
+    // source is able to stop().
+    if (mFirstBuffer != NULL) {
+        mFirstBuffer->release();
+        mFirstBuffer = NULL;
+    }
+
+    if (mInputBuffer != NULL) {
+        LOGV("AudioPlayer releasing input buffer.");
+        mInputBuffer->release();
+        mInputBuffer = NULL;
+    }
+
+    mSource->stop();
+
+    // The following hack is necessary to ensure that the OMX
+    // component is completely released by the time we may try
+    // to instantiate it again.
+    wp<MediaSource> tmp = mSource;
+    mSource.clear();
+    while (tmp.promote() != NULL) {
+        usleep(1000);
+    }
+
+    memBufferDeAlloc();
+    LOGE("Buffer Deallocation complete! Closing pcm handle");
+
+    if (local_handle->start) {
+        if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_PAUSE,1) < 0) {
+            LOGE("Audio Pause failed");
+        }
+    }
+    local_handle->start = 0;
+    if (mIsAudioRouted)
+       pcm_prepare(local_handle);
+    pcm_close(local_handle);
+    handle = (void*)local_handle;
+
+        // Close the audiosink after all the threads exited to make sure
+    // there is no thread writing data to audio sink or applying effect
+    if (bIsA2DPEnabled) {
+        mAudioSink->close();
+    } else {
+        mAudioSink->closeSession();
+        releaseWakeLock();
+    }
+    mAudioSink.clear();
+
+    LOGV("reset() after memBuffersRequestQueue.size() = %d, memBuffersResponseQueue.size() = %d ",memBuffersRequestQueue.size(),memBuffersResponseQueue.size());
+
+    mNumFramesPlayed = 0;
+    mPositionTimeMediaUs = -1;
+    mPositionTimeRealUs = -1;
+    mSeeking = false;
+    mInternalSeeking = false;
+    mReachedEOS = false;
+    mReachedOutputEOS = false;
+    mFinalStatus = OK;
+    mStarted = false;
+}
+
+
+bool LPAPlayer::isSeeking() {
+    Mutex::Autolock autoLock(mLock);
+    return mSeeking;
+}
+
+bool LPAPlayer::reachedEOS(status_t *finalStatus) {
+    *finalStatus = OK;
+    Mutex::Autolock autoLock(mLock);
+    *finalStatus = mFinalStatus;
+    return mReachedOutputEOS;
+}
+
+
+void *LPAPlayer::decoderThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->decoderThreadEntry();
+    return NULL;
+}
+
+
+void LPAPlayer::decoderThreadEntry() {
+
+    pthread_mutex_lock(&decoder_mutex);
+
+    pid_t tid  = gettid();
+    androidSetThreadPriority(tid, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"LPA DecodeThread", 0, 0, 0);
+
+    LOGV("decoderThreadEntry wait for signal \n");
+    if (!mStarted) {
+        pthread_cond_wait(&decoder_cv, &decoder_mutex);
+    }
+    LOGV("decoderThreadEntry ready to work \n");
+    pthread_mutex_unlock(&decoder_mutex);
+    if (killDecoderThread) {
+        pthread_mutex_unlock(&mem_request_mutex);
+        return;
+    }
+    pthread_cond_signal(&event_cv);
+
+    int32_t mem_fd;
+
+    //TODO check PMEM_BUFFER_SIZE from handle.
+    memBufferAlloc(MEM_BUFFER_SIZE, &mem_fd);
+    while (1) {
+        pthread_mutex_lock(&mem_request_mutex);
+
+        if (killDecoderThread) {
+            pthread_mutex_unlock(&mem_request_mutex);
+            break;
+        }
+
+        LOGV("decoder memBuffersRequestQueue.size() = %d, memBuffersResponseQueue.size() = %d ",
+             memBuffersRequestQueue.size(),memBuffersResponseQueue.size());
+
+        if (memBuffersRequestQueue.empty() || mReachedEOS || isPaused ||
+            (bIsA2DPEnabled && !mAudioSinkOpen) || asyncReset ) {
+            LOGV("decoderThreadEntry: a2dpDisconnectPause %d  mReachedEOS %d bIsA2DPEnabled %d "
+                 "mAudioSinkOpen %d asyncReset %d ", a2dpDisconnectPause,
+                 mReachedEOS, bIsA2DPEnabled, mAudioSinkOpen, asyncReset);
+            LOGV("decoderThreadEntry: waiting on decoder_cv");
+            pthread_cond_wait(&decoder_cv, &mem_request_mutex);
+            pthread_mutex_unlock(&mem_request_mutex);
+            LOGV("decoderThreadEntry: received a signal to wake up");
+            continue;
+        }
+
+        pthread_mutex_unlock(&mem_request_mutex);
+
+        //Queue the buffers back to Request queue
+        if (mReachedEOS || (bIsA2DPEnabled && !mAudioSinkOpen) || asyncReset || a2dpDisconnectPause) {
+            LOGV("%s: mReachedEOS %d bIsA2DPEnabled %d ", __func__, mReachedEOS, bIsA2DPEnabled);
+        }
+        //Queue up the buffers for writing either for A2DP or LPA Driver
+        else {
+            struct msm_audio_aio_buf aio_buf_local;
+            Mutex::Autolock autoLock(mSeekLock);
+
+            pthread_mutex_lock(&mem_request_mutex);
+            List<BuffersAllocated>::iterator it = memBuffersRequestQueue.begin();
+            BuffersAllocated buf = *it;
+            memBuffersRequestQueue.erase(it);
+            pthread_mutex_unlock(&mem_request_mutex);
+            memset(buf.localBuf, 0x0, MEM_BUFFER_SIZE);
+            memset(buf.memBuf, 0x0, MEM_BUFFER_SIZE);
+
+            LOGV("Calling fillBuffer for size %d",MEM_BUFFER_SIZE);
+            buf.bytesToWrite = fillBuffer(buf.localBuf, MEM_BUFFER_SIZE);
+            LOGV("fillBuffer returned size %d",buf.bytesToWrite);
+
+            if ( buf.bytesToWrite ==  0) {
+                /* Put the buffer back into requestQ */
+                /* This is zero byte buffer - no need to put in response Q*/
+                pthread_mutex_lock(&mem_request_mutex);
+                memBuffersRequestQueue.push_front(buf);
+                pthread_mutex_unlock(&mem_request_mutex);
+                /*Post EOS to Awesome player when i/p EOS is reached,
+                  all input buffers have been decoded and response queue is empty*/
+                if(mObserver && mReachedEOS && memBuffersResponseQueue.empty()) {
+                    LOGV("Posting EOS event..zero byte buffer and response queue is empty");
+                    mReachedOutputEOS = true;
+                    mObserver->postAudioEOS();
+                }
+                continue;
+            }
+            pthread_mutex_lock(&mem_response_mutex);
+            memBuffersResponseQueue.push_back(buf);
+            pthread_mutex_unlock(&mem_response_mutex);
+
+            if (!bIsA2DPEnabled){
+                LOGV("Start Event thread\n");
+                pthread_cond_signal(&event_cv);
+                // Make sure the buffer is added to response Q before applying effects
+                // If there is a change in effects while applying on current buffer
+                // it will be re applied as the buffer already present in responseQ
+                if (!asyncReset) {
+                    pthread_mutex_lock(&apply_effect_mutex);
+                    LOGV("decoderThread: applying effects on mem buf at buf.memBuf %x", buf.memBuf);
+                    mAudioFlinger->applyEffectsOn((int16_t*)buf.localBuf,
+                                                  (int16_t*)buf.memBuf,
+                                                  (int)buf.bytesToWrite);
+                    pthread_mutex_unlock(&apply_effect_mutex);
+                    LOGV("decoderThread: Writing buffer to driver with mem fd %d", buf.memFd);
+
+                    {
+                        if (mSeeking) {
+                            continue;
+                        }
+                        LOGV("PCM write start");
+                        struct pcm * local_handle = (struct pcm *)handle;
+                        pcm_write(local_handle, buf.memBuf, local_handle->period_size);
+                        if (mReachedEOS) {
+                            if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_START) < 0)
+                                LOGE("AUDIO Start failed");
+                            else
+                                local_handle->start = 1;
+                        }
+                        if (buf.bytesToWrite < MEM_BUFFER_SIZE && memBuffersResponseQueue.size() == 1) {
+                            LOGV("Last buffer case");
+                            uint64_t writeValue = SIGNAL_EVENT_THREAD;
+                            write(efd, &writeValue, sizeof(uint64_t));
+                        }
+                        LOGV("PCM write complete");
+                        pthread_mutex_lock(&pause_mutex);
+                        pthread_cond_signal(&pause_cv);
+                        pthread_mutex_unlock(&pause_mutex);
+                    }
+                }
+            }
+            else
+                pthread_cond_signal(&a2dp_cv);
+        }
+    }
+    decoderThreadAlive = false;
+    LOGV("decoder Thread is dying");
+}
+
+void *LPAPlayer::eventThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->eventThreadEntry();
+    return NULL;
+}
+
+void LPAPlayer::eventThreadEntry() {
+    struct msm_audio_event cur_pcmdec_event;
+
+    pthread_mutex_lock(&event_mutex);
+    int rc = 0;
+    int err_poll = 0;
+    int avail = 0;
+    int i = 0;
+
+    pid_t tid  = gettid();
+    androidSetThreadPriority(tid, ANDROID_PRIORITY_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"LPA EventThread", 0, 0, 0);
+
+
+    LOGV("eventThreadEntry wait for signal \n");
+    pthread_cond_wait(&event_cv, &event_mutex);
+    LOGV("eventThreadEntry ready to work \n");
+    pthread_mutex_unlock(&event_mutex);
+
+    if (killEventThread) {
+        eventThreadAlive = false;
+        LOGV("Event Thread is dying.");
+        return;
+    }
+
+    LOGV("Allocating poll fd");
+    struct pollfd pfd[NUM_FDS];
+
+    struct pcm * local_handle = (struct pcm *)handle;
+    pfd[0].fd = local_handle->timer_fd;
+    pfd[0].events = (POLLIN | POLLERR | POLLNVAL);
+    LOGV("Allocated poll fd");
+    bool audioEOSPosted = false;
+    int timeout = -1;
+
+    efd = eventfd(0,0);
+    pfd[1].fd = efd;
+    pfd[1].events = (POLLIN | POLLERR | POLLNVAL);
+    while (1) {
+        if (killEventThread) {
+            eventThreadAlive = false;
+            LOGV("Event Thread is dying.");
+            return;
+        }
+
+        err_poll = poll(pfd, NUM_FDS, timeout);
+
+        if (err_poll == EINTR)
+            LOGE("Timer is intrrupted");
+        if (pfd[1].revents & POLLIN) {
+            uint64_t u;
+            read(efd, &u, sizeof(uint64_t));
+            LOGE("POLLIN event occured on the event fd, value written to %llu",(unsigned long long)u);
+            pfd[1].revents = 0;
+            if (u == SIGNAL_EVENT_THREAD) {
+                BuffersAllocated tempbuf = *(memBuffersResponseQueue.begin());
+                timeout = 1000 * tempbuf.bytesToWrite / (numChannels * PCM_FORMAT * mSampleRate);
+                LOGV("Setting timeout due Last buffer seek to %d, mReachedEOS %d, memBuffersRequestQueue.size() %d", timeout, mReachedEOS,memBuffersResponseQueue.size());
+                continue;
+            }
+        }
+        if ((pfd[1].revents & POLLERR) || (pfd[1].revents & POLLNVAL))
+            LOGE("POLLERR or INVALID POLL");
+
+        LOGV("LPA event");
+        if (killEventThread) {
+            break;
+        }
+
+        if (timeout != -1 && mReachedEOS) {
+            LOGV("Timeout %d: Posting EOS event to AwesomePlayer",timeout);
+            isPaused = true;
+            mPauseTime = mSeekTimeUs + getTimeStamp(A2DP_DISABLED);
+            mReachedOutputEOS = true;
+            mObserver->postAudioEOS();
+            audioEOSPosted = true;
+            timeout = -1;
+        }
+        if (!mReachedEOS) {
+            timeout = -1;
+        }
+        if (err_poll < 0) {
+             LOGV("fatal err in poll:%d\n", err_poll);
+             eventThreadAlive = false;
+             LOGV("Event Thread is dying.");
+             break;
+        }
+        struct snd_timer_tread rbuf[4];
+        read(local_handle->timer_fd, rbuf, sizeof(struct snd_timer_tread) * 4 );
+
+        if (!(pfd[0].revents & POLLIN))
+             continue;
+
+        pfd[0].revents = 0;
+        //pfd[1].revents = 0;
+
+        LOGV("After an event occurs");
+
+        if (killEventThread) {
+            break;
+        }
+        if (memBuffersResponseQueue.empty())
+            continue;
+
+        //exit on abrupt event
+        Mutex::Autolock autoLock(mLock);
+        pthread_mutex_lock(&mem_response_mutex);
+        BuffersAllocated buf = *(memBuffersResponseQueue.begin());
+        memBuffersResponseQueue.erase(memBuffersResponseQueue.begin());
+        /* If the rendering is complete report EOS to the AwesomePlayer */
+        if (mObserver && !asyncReset && mReachedEOS && memBuffersResponseQueue.size() == 1) {
+            BuffersAllocated tempbuf = *(memBuffersResponseQueue.begin());
+            timeout = 1000 * tempbuf.bytesToWrite / (numChannels * PCM_FORMAT * mSampleRate);
+            LOGV("Setting timeout to %d,nextbuffer %d, buf.bytesToWrite %d, mReachedEOS %d, memBuffersRequestQueue.size() %d", timeout, tempbuf.bytesToWrite, buf.bytesToWrite, mReachedEOS,memBuffersResponseQueue.size());
+        }
+
+        pthread_mutex_unlock(&mem_response_mutex);
+        // Post buffer to request Q
+        pthread_mutex_lock(&mem_request_mutex);
+        memBuffersRequestQueue.push_back(buf);
+        pthread_mutex_unlock(&mem_request_mutex);
+
+        pthread_cond_signal(&decoder_cv);
+
+    }
+    eventThreadAlive = false;
+    if (efd != -1)
+        close(efd);
+    LOGV("Event Thread is dying.");
+
+}
+
+void *LPAPlayer::A2DPThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->A2DPThreadEntry();
+    return NULL;
+}
+
+void LPAPlayer::A2DPThreadEntry() {
+    pid_t tid  = gettid();
+    androidSetThreadPriority(tid,ANDROID_PRIORITY_URGENT_AUDIO);
+    prctl(PR_SET_NAME, (unsigned long)"LPA A2DPThread", 0, 0, 0);
+
+    while (1) {
+        /* If exitPending break here */
+        if (killA2DPThread) {
+            break;
+        }
+
+        //TODO: Remove this
+        pthread_mutex_lock(&mem_response_mutex);
+        if (memBuffersResponseQueue.empty() || !mAudioSinkOpen || isPaused
+			|| !bIsA2DPEnabled || mReachedOutputEOS) {
+            LOGV("A2DPThreadEntry:: responseQ empty %d mAudioSinkOpen %d isPaused %d bIsA2DPEnabled %d",
+                 memBuffersResponseQueue.empty(), mAudioSinkOpen, isPaused, bIsA2DPEnabled);
+            LOGV("A2DPThreadEntry:: Waiting on a2dp_cv");
+            pthread_cond_wait(&a2dp_cv, &mem_response_mutex);
+            LOGV("A2DPThreadEntry:: received signal to wake up");
+            pthread_mutex_unlock(&mem_response_mutex);
+            continue;
+        }
+        // A2DP got disabled -- Queue up everything back to Request Queue
+        if (!bIsA2DPEnabled) {
+            pthread_mutex_lock(&mem_request_mutex);
+            memBuffersResponseQueue.clear();
+            memBuffersRequestQueue.clear();
+
+            List<BuffersAllocated>::iterator it = bufPool.begin();
+            for(;it!=bufPool.end();++it) {
+                 memBuffersRequestQueue.push_back(*it);
+            }
+            pthread_mutex_unlock(&mem_response_mutex);
+            pthread_mutex_unlock(&mem_request_mutex);
+        }
+        //A2DP is enabled -- Continue normal Playback
+        else {
+            List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+            BuffersAllocated buf = *it;
+            memBuffersResponseQueue.erase(it);
+            pthread_mutex_unlock(&mem_response_mutex);
+            bytesToWrite = buf.bytesToWrite;
+            LOGV("bytes To write:%d",bytesToWrite);
+
+            uint32_t bytesWritten = 0;
+            uint32_t numBytesRemaining = 0;
+            uint32_t bytesAvailInBuffer = 0;
+            void* data = buf.localBuf;
+
+            while (bytesToWrite) {
+                /* If exitPending break here */
+                if (killA2DPThread || !bIsA2DPEnabled) {
+                    LOGV("A2DPThreadEntry: A2DPThread set to be killed");
+                    break;
+                }
+
+                bytesAvailInBuffer = mAudioSink->bufferSize();
+
+                uint32_t writeLen = bytesAvailInBuffer > bytesToWrite ? bytesToWrite : bytesAvailInBuffer;
+                LOGV("Writing %d bytes to A2DP ", writeLen);
+                bytesWritten = mAudioSink->write(data, writeLen);
+                if ( bytesWritten != writeLen ) {
+                    //Paused - Wait till resume
+                    if (isPaused && bIsA2DPEnabled) {
+                        LOGV("Pausing A2DP playback");
+                        pthread_mutex_lock(&a2dp_mutex);
+                        pthread_cond_wait(&a2dp_cv, &a2dp_mutex);
+                        pthread_mutex_unlock(&a2dp_mutex);
+                    }
+
+
+                    //Seeked: break out of loop, flush old buffers and write new buffers
+                    LOGV("@_@bytes To write1:%d",bytesToWrite);
+                }
+                if (mSeeked) {
+                    LOGV("Seeking A2DP Playback");
+                    break;
+                }
+                data += bytesWritten;
+                mNumA2DPBytesPlayed += bytesWritten;
+                bytesToWrite -= bytesWritten;
+                LOGV("@_@bytes To write2:%d",bytesToWrite);
+            }
+            if (mObserver && !asyncReset && mReachedEOS && memBuffersResponseQueue.empty()) {
+                LOGV("Posting EOS event to AwesomePlayer");
+                mReachedOutputEOS = true;
+                mObserver->postAudioEOS();
+            }
+            pthread_mutex_lock(&mem_request_mutex);
+            memBuffersRequestQueue.push_back(buf);
+            if (killA2DPThread) {
+                pthread_mutex_unlock(&mem_request_mutex);
+                break;
+            }
+            //flush out old buffer
+            if (mSeeked || !bIsA2DPEnabled) {
+                mSeeked = false;
+                LOGV("A2DPThread: Putting buffers back to requestQ from responseQ");
+                pthread_mutex_lock(&mem_response_mutex);
+                memBuffersResponseQueue.clear();
+                memBuffersRequestQueue.clear();
+
+                List<BuffersAllocated>::iterator it = bufPool.begin();
+                for(;it!=bufPool.end();++it) {
+                     memBuffersRequestQueue.push_back(*it);
+                }
+                pthread_mutex_unlock(&mem_response_mutex);
+            }
+            pthread_mutex_unlock(&mem_request_mutex);
+            // Signal decoder thread when a buffer is put back to request Q
+            pthread_cond_signal(&decoder_cv);
+        }
+    }
+    a2dpThreadAlive = false;
+
+    LOGV("AudioSink stop");
+    if(mAudioSinkOpen) {
+        mAudioSinkOpen = false;
+        mAudioSink->stop();
+    }
+
+    LOGV("A2DP Thread is dying.");
+}
+
+void *LPAPlayer::EffectsThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->EffectsThreadEntry();
+    return NULL;
+}
+
+void LPAPlayer::EffectsThreadEntry() {
+    while(1) {
+        if(killEffectsThread) {
+            break;
+        }
+        pthread_mutex_lock(&effect_mutex);
+
+        if(bEffectConfigChanged && !isPaused) {
+            bEffectConfigChanged = false;
+
+            // 1. Clear current effectQ
+            LOGV("Clearing EffectQ: size %d", effectsQueue.size());
+            while (!effectsQueue.empty())  {
+                List<BuffersAllocated>::iterator it = effectsQueue.begin();
+                effectsQueue.erase(it);
+            }
+
+            // 2. Lock the responseQ mutex
+            pthread_mutex_lock(&mem_response_mutex);
+
+            // 3. Copy responseQ to effectQ
+            LOGV("Copying responseQ to effectQ: responseQ size %d", memBuffersResponseQueue.size());
+            for (List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+                it != memBuffersResponseQueue.end(); ++it) {
+                BuffersAllocated buf = *it;
+                effectsQueue.push_back(buf);
+            }
+
+            // 4. Unlock the responseQ mutex
+            pthread_mutex_unlock(&mem_response_mutex);
+        }
+        // If effectQ is empty just wait for a signal
+        // Else dequeue a buffer, apply effects and delete it from effectQ
+        if(effectsQueue.empty() || asyncReset || bIsA2DPEnabled || isPaused) {
+            LOGV("EffectQ is empty or Reset called or A2DP enabled, waiting for signal");
+            pthread_cond_wait(&effect_cv, &effect_mutex);
+            LOGV("effectsThread: received signal to wake up");
+            pthread_mutex_unlock(&effect_mutex);
+        } else {
+            pthread_mutex_unlock(&effect_mutex);
+
+            List<BuffersAllocated>::iterator it = effectsQueue.begin();
+            BuffersAllocated buf = *it;
+
+            pthread_mutex_lock(&apply_effect_mutex);
+            LOGV("effectsThread: applying effects on %p fd %d", buf.memBuf, (int)buf.memFd);
+            mAudioFlinger->applyEffectsOn((int16_t*)buf.localBuf,
+                                          (int16_t*)buf.memBuf,
+                                          (int)buf.bytesToWrite);
+            pthread_mutex_unlock(&apply_effect_mutex);
+            effectsQueue.erase(it);
+        }
+    }
+    LOGV("Effects thread is dead");
+    effectsThreadAlive = false;
+}
+
+void *LPAPlayer::A2DPNotificationThreadWrapper(void *me) {
+    static_cast<LPAPlayer *>(me)->A2DPNotificationThreadEntry();
+    return NULL;
+}
+
+
+void LPAPlayer::A2DPNotificationThreadEntry() {
+    while (1) {
+        pthread_mutex_lock(&a2dp_notification_mutex);
+        pthread_cond_wait(&a2dp_notification_cv, &a2dp_notification_mutex);
+        pthread_mutex_unlock(&a2dp_notification_mutex);
+        if (killA2DPNotificationThread) {
+            break;
+        }
+
+        LOGV("A2DP notification has come bIsA2DPEnabled: %d", bIsA2DPEnabled);
+
+        if (bIsA2DPEnabled) {
+            struct pcm * local_handle = (struct pcm *)handle;
+            LOGV("Flushing all the buffers");
+            pthread_mutex_lock(&mem_response_mutex);
+            pthread_mutex_lock(&mem_request_mutex);
+            memBuffersResponseQueue.clear();
+            memBuffersRequestQueue.clear();
+
+            List<BuffersAllocated>::iterator it = bufPool.begin();
+            for(;it!=bufPool.end();++it) {
+                 memBuffersRequestQueue.push_back(*it);
+            }
+            pthread_mutex_unlock(&mem_request_mutex);
+            pthread_mutex_unlock(&mem_response_mutex);
+            LOGV("All the buffers flushed, Now flushing the driver");
+            if (ioctl(local_handle->fd, SNDRV_PCM_IOCTL_RESET))
+                LOGE("Reset failed!");
+            LOGV("Driver flushed and opening mAudioSink");
+            if (!mAudioSinkOpen) {
+                LOGV("Close Session");
+                if (mAudioSink.get() != NULL) {
+                    mAudioSink->closeSession();
+                    releaseWakeLock();
+                    LOGV("mAudioSink close session");
+                    mIsAudioRouted = false;
+                } else {
+                    LOGE("close session NULL");
+                }
+                sp<MetaData> format = mSource->getFormat();
+                const char *mime;
+                bool success = format->findCString(kKeyMIMEType, &mime);
+                CHECK(success);
+                CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
+                success = format->findInt32(kKeySampleRate, &mSampleRate);
+                CHECK(success);
+                success = format->findInt32(kKeyChannelCount, &numChannels);
+                CHECK(success);
+                LOGV("Before Audio Sink Open");
+                status_t ret = mAudioSink->open(mSampleRate, numChannels,AUDIO_FORMAT_PCM_16_BIT, DEFAULT_AUDIOSINK_BUFFERCOUNT);
+                mAudioSink->start();
+                LOGV("After Audio Sink Open");
+                mAudioSinkOpen = true;
+            }
+            LOGV("Signalling to decoder cv");
+            pthread_cond_signal(&decoder_cv);
+        }
+        else {
+            mInternalSeeking = true;
+            mReachedEOS = false;
+            mReachedOutputEOS = false;
+            mSeekTimeUs += getTimeStamp(A2DP_DISCONNECT);
+            mNumA2DPBytesPlayed = 0;
+            pthread_cond_signal(&a2dp_cv);
+        }
+    }
+    a2dpNotificationThreadAlive = false;
+    LOGV("A2DPNotificationThread is dying");
+
+}
+
+void *LPAPlayer::memBufferAlloc(int32_t nSize, int32_t *mem_fd){
+    int32_t memfd = -1;
+    void  *mem_buf = NULL;
+    void  *local_buf = NULL;
+    int i = 0;
+    struct pcm * local_handle = (struct pcm *)handle;
+
+    for (i = 0; i < MEM_BUFFER_COUNT; i++) {
+        mem_buf = (int32_t *)local_handle->addr + (nSize * i/sizeof(int));
+        local_buf = malloc(nSize);
+        if (NULL == local_buf) {
+            return NULL;
+        }
+
+        // 3. Store this information for internal mapping / maintanence
+        BuffersAllocated buf(local_buf, mem_buf, nSize, memfd);
+        memBuffersRequestQueue.push_back(buf);
+        bufPool.push_back(buf);
+
+        // 4. Send the mem fd information
+        LOGV("memBufferAlloc calling with required size %d", nSize);
+        LOGV("The MEM that is allocated is %d and buffer is %x", memfd, (unsigned int)mem_buf);
+    }
+    *mem_fd = memfd;
+    return NULL;
+}
+
+void LPAPlayer::memBufferDeAlloc()
+{
+    //Remove all the buffers from bufpool 
+    while (!bufPool.empty())  {
+        List<BuffersAllocated>::iterator it = bufPool.begin();
+        BuffersAllocated &memBuffer = *it;
+        // free the local buffer corresponding to mem buffer
+        free(memBuffer.localBuf);
+        LOGV("Removing from bufpool");
+        bufPool.erase(it);
+    }
+
+}
+
+void LPAPlayer::createThreads() {
+
+    //Initialize all the Mutexes and Condition Variables
+    pthread_mutex_init(&mem_request_mutex, NULL);
+    pthread_mutex_init(&mem_response_mutex, NULL);
+    pthread_mutex_init(&decoder_mutex, NULL);
+    pthread_mutex_init(&event_mutex, NULL);
+    pthread_mutex_init(&a2dp_mutex, NULL);
+    pthread_mutex_init(&effect_mutex, NULL);
+    pthread_mutex_init(&apply_effect_mutex, NULL);
+    pthread_mutex_init(&a2dp_notification_mutex, NULL);
+    pthread_mutex_init(&pause_mutex,NULL);
+
+    pthread_cond_init (&event_cv, NULL);
+    pthread_cond_init (&decoder_cv, NULL);
+    pthread_cond_init (&a2dp_cv, NULL);
+    pthread_cond_init (&a2dp_notification_cv, NULL);
+    pthread_cond_init (&pause_cv, NULL);
+
+    // Create 4 threads Effect, decoder, event and A2dp
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    killDecoderThread = false;
+    killEventThread = false;
+    killA2DPThread = false;
+    killEffectsThread = false;
+    killA2DPNotificationThread = false;
+
+    decoderThreadAlive = true;
+    eventThreadAlive = true;
+    a2dpThreadAlive = true;
+    effectsThreadAlive = true;
+    a2dpNotificationThreadAlive = true;
+
+    LOGV("Creating Event Thread");
+    pthread_create(&eventThread, &attr, eventThreadWrapper, this);
+
+    LOGV("Creating decoder Thread");
+    pthread_create(&decoderThread, &attr, decoderThreadWrapper, this);
+
+    LOGV("Creating A2DP Thread");
+    pthread_create(&A2DPThread, &attr, A2DPThreadWrapper, this);
+
+    LOGV("Creating Effects Thread");
+    pthread_create(&EffectsThread, &attr, EffectsThreadWrapper, this);
+
+    LOGV("Creating A2DP Notification Thread");
+    pthread_create(&A2DPNotificationThread, &attr, A2DPNotificationThreadWrapper, this);
+
+    pthread_attr_destroy(&attr);
+}
+
+
+size_t LPAPlayer::fillBuffer(void *data, size_t size) {
+    LOGE("fillBuffer");
+    if (mNumFramesPlayed == 0) {
+        LOGV("AudioCallback");
+    }
+
+    LOGV("Number of Frames Played: %u", mNumFramesPlayed);
+    if (mReachedEOS) {
+        return 0;
+    }
+
+    size_t size_done = 0;
+    size_t size_remaining = size;
+    while (size_remaining > 0) {
+        MediaSource::ReadOptions options;
+        {
+            Mutex::Autolock autoLock(mLock);
+
+            if (mSeeking) {
+                mInternalSeeking = false;
+            }
+            if (mSeeking || mInternalSeeking) {
+                if (mIsFirstBuffer) {
+                    if (mFirstBuffer != NULL) {
+                        mFirstBuffer->release();
+                        mFirstBuffer = NULL;
+                    }
+                    mIsFirstBuffer = false;
+                }
+
+                options.setSeekTo(mSeekTimeUs);
+
+                if (mInputBuffer != NULL) {
+                    mInputBuffer->release();
+                    mInputBuffer = NULL;
+                }
+
+                // This is to ignore the data already filled in the output buffer
+                size_done = 0;
+                size_remaining = size;
+
+                mSeeking = false;
+                if (mObserver && !asyncReset && !mInternalSeeking) {
+                    LOGV("fillBuffer: Posting audio seek complete event");
+                    mObserver->postAudioSeekComplete();
+                }
+                mInternalSeeking = false;
+            }
+        }
+
+        if (mInputBuffer == NULL) {
+            status_t err;
+
+            if (mIsFirstBuffer) {
+                mInputBuffer = mFirstBuffer;
+                mFirstBuffer = NULL;
+                err = mFirstBufferResult;
+
+                mIsFirstBuffer = false;
+            } else {
+                err = mSource->read(&mInputBuffer, &options);
+            }
+
+            CHECK((err == OK && mInputBuffer != NULL)
+                  || (err != OK && mInputBuffer == NULL));
+
+            Mutex::Autolock autoLock(mLock);
+
+            if (err != OK) {
+                if (err == INFO_FORMAT_CHANGED) {
+                    sp<MetaData> format = mSource->getFormat();
+                    const char *mime;
+                    bool success = format->findCString(kKeyMIMEType, &mime);
+                    CHECK(success);
+                    CHECK(!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW));
+
+                    success = format->findInt32(kKeySampleRate, &mSampleRate);
+                    CHECK(success);
+
+                    int32_t numChannels;
+                    success = format->findInt32(kKeyChannelCount, &numChannels);
+                    CHECK(success);
+
+                    if(bIsA2DPEnabled) {
+                        mAudioSink->stop();
+                        mAudioSink->close();
+                        mAudioSinkOpen = false;
+                        status_t err = mAudioSink->open(
+                                mSampleRate, numChannels, AUDIO_FORMAT_PCM_16_BIT,
+                                DEFAULT_AUDIOSINK_BUFFERCOUNT);
+                        if (err != OK) {
+                            mSource->stop();
+                            return err;
+                        }
+                        mAudioSinkOpen = true;
+                        mLatencyUs = (int64_t)mAudioSink->latency() * 1000;
+                        mFrameSize = mAudioSink->frameSize();
+                        mAudioSink->start();
+                    } else {
+                        /* TODO: LPA driver needs to be reconfigured
+                           For MP3 we might not come here but for AAC we need this */
+                        mAudioSink->stop();
+                        mAudioSink->closeSession();
+                        LOGV("Opening a routing session in fillBuffer: sessionId = %d mSampleRate %d numChannels %d",
+                             sessionId, mSampleRate, numChannels);
+                        status_t err = mAudioSink->openSession(AUDIO_FORMAT_PCM_16_BIT, sessionId, mSampleRate, numChannels);
+                        if (err != OK) {
+                            mSource->stop();
+                            return err;
+                        }
+                    }
+                    break;
+                } else {
+                    mReachedEOS = true;
+                    mFinalStatus = err;
+                    break;
+                }
+            }
+
+            CHECK(mInputBuffer->meta_data()->findInt64(
+                                                      kKeyTime, &mPositionTimeMediaUs));
+            mFrameSize = mAudioSink->frameSize();
+            mPositionTimeRealUs =
+            ((mNumFramesPlayed + size_done / mFrameSize) * 1000000)
+            / mSampleRate;
+
+        }
+
+        if (mInputBuffer->range_length() == 0) {
+            mInputBuffer->release();
+            mInputBuffer = NULL;
+            continue;
+        }
+
+        size_t copy = size_remaining;
+        if (copy > mInputBuffer->range_length()) {
+            copy = mInputBuffer->range_length();
+        }
+
+        memcpy((char *)data + size_done,
+               (const char *)mInputBuffer->data() + mInputBuffer->range_offset(),
+               copy);
+
+        mInputBuffer->set_range(mInputBuffer->range_offset() + copy,
+                                mInputBuffer->range_length() - copy);
+
+        size_done += copy;
+        size_remaining -= copy;
+    }
+    return size_done;
+}
+
+int64_t LPAPlayer::getRealTimeUs() {
+    Mutex::Autolock autoLock(mLock);
+    return getRealTimeUsLocked();
+}
+
+
+int64_t LPAPlayer::getRealTimeUsLocked(){
+    //Used for AV sync: irrelevant API for LPA.
+    return 0;
+}
+
+int64_t LPAPlayer::getTimeStamp(A2DPState state) {
+    int64_t timestamp = 0;
+    switch (state) {
+    case A2DP_ENABLED:
+    case A2DP_DISCONNECT:
+        timestamp = (mNumA2DPBytesPlayed * 1000000)
+                    /(2 * numChannels * mSampleRate);
+        break;
+    case A2DP_DISABLED:
+    case A2DP_CONNECT: {
+        struct pcm * local_handle = (struct pcm *)handle;
+        struct snd_compr_tstamp tstamp;
+        if (ioctl(local_handle->fd, SNDRV_COMPRESS_TSTAMP, &tstamp)) {
+            LOGE("Tunnel Player: failed SNDRV_COMPRESS_TSTAMP\n");
+        }
+        else {
+            LOGV("timestamp = %lld\n", tstamp.timestamp);
+            timestamp = tstamp.timestamp;
+        }
+        break;
+    }
+    default:
+        break;
+    }
+    return timestamp;
+}
+
+int64_t LPAPlayer::getMediaTimeUs() {
+    Mutex::Autolock autoLock(mLock);
+    LOGV("getMediaTimeUs() isPaused %d mSeekTimeUs %d mPauseTime %d", isPaused, mSeekTimeUs, mPauseTime);
+    if (isPaused) {
+        return mPauseTime;
+    } else {
+        A2DPState state = bIsA2DPEnabled ? A2DP_ENABLED : A2DP_DISABLED;
+        return (mSeekTimeUs + getTimeStamp(state));
+    }
+}
+
+bool LPAPlayer::getMediaTimeMapping(
+                                   int64_t *realtime_us, int64_t *mediatime_us) {
+    Mutex::Autolock autoLock(mLock);
+
+    *realtime_us = mPositionTimeRealUs;
+    *mediatime_us = mPositionTimeMediaUs;
+
+    return mPositionTimeRealUs != -1 && mPositionTimeMediaUs != -1;
+}
+
+void LPAPlayer::requestAndWaitForDecoderThreadExit() {
+
+    if (!decoderThreadAlive)
+        return;
+    killDecoderThread = true;
+    pthread_cond_signal(&decoder_cv);
+    pthread_join(decoderThread,NULL);
+    LOGV("decoder thread killed");
+
+}
+
+void LPAPlayer::requestAndWaitForEventThreadExit() {
+    if (!eventThreadAlive)
+        return;
+    killEventThread = true;
+    uint64_t writeValue = KILL_EVENT_THREAD;
+    LOGE("Writing to efd %d",efd);
+    write(efd, &writeValue, sizeof(uint64_t));
+    if(!bIsA2DPEnabled) {
+    }
+    pthread_cond_signal(&event_cv);
+    pthread_join(eventThread,NULL);
+    LOGV("event thread killed");
+}
+
+void LPAPlayer::requestAndWaitForA2DPThreadExit() {
+    if (!a2dpThreadAlive)
+        return;
+    killA2DPThread = true;
+    pthread_cond_signal(&a2dp_cv);
+    pthread_join(A2DPThread,NULL);
+    LOGV("a2dp thread killed");
+}
+
+void LPAPlayer::requestAndWaitForEffectsThreadExit() {
+    if (!effectsThreadAlive)
+        return;
+    killEffectsThread = true;
+    pthread_cond_signal(&effect_cv);
+    pthread_join(EffectsThread,NULL);
+    LOGV("effects thread killed");
+}
+
+void LPAPlayer::requestAndWaitForA2DPNotificationThreadExit() {
+    if (!a2dpNotificationThreadAlive)
+        return;
+    killA2DPNotificationThread = true;
+    pthread_cond_signal(&a2dp_notification_cv);
+    pthread_join(A2DPNotificationThread,NULL);
+    LOGV("a2dp notification thread killed");
+}
+
+void LPAPlayer::onPauseTimeOut() {
+    Mutex::Autolock autoLock(resumeLock);
+    struct msm_audio_stats stats;
+    int nBytesConsumed = 0;
+    LOGV("onPauseTimeOut");
+    if (!mPauseEventPending) {
+        return;
+    }
+    mPauseEventPending = false;
+    if(!bIsA2DPEnabled) {
+        // 1.) Set seek flags
+        mInternalSeeking = true;
+        mReachedEOS = false;
+        mReachedOutputEOS = false;
+        mSeekTimeUs += getTimeStamp(A2DP_DISABLED);
+
+        // 2.) Flush the buffers and transfer everything to request queue
+        pthread_mutex_lock(&mem_response_mutex);
+        pthread_mutex_lock(&mem_request_mutex);
+        memBuffersResponseQueue.clear();
+        memBuffersRequestQueue.clear();
+        List<BuffersAllocated>::iterator it = bufPool.begin();
+        for(;it!=bufPool.end();++it) {
+             memBuffersRequestQueue.push_back(*it);
+        }
+        pthread_mutex_unlock(&mem_request_mutex);
+        pthread_mutex_unlock(&mem_response_mutex);
+        LOGV("onPauseTimeOut after memBuffersRequestQueue.size() = %d, memBuffersResponseQueue.size() = %d ",memBuffersRequestQueue.size(),memBuffersResponseQueue.size());
+
+        // 3.) Close routing Session
+        mAudioSink->closeSession();
+        mIsAudioRouted = false;
+
+        // 4.) Release Wake Lock
+        releaseWakeLock();
+    }
+
+}
+
+} //namespace android
diff --git a/media/libstagefright/LPAPlayerION.cpp b/media/libstagefright/LPAPlayerION.cpp
new file mode 100644
index 0000000..ef94579
--- /dev/null
+++ b/media/libstagefright/LPAPlayerION.cpp
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "LPAPlayerION"
+#include <utils/Log.h>
+
+#include <media/stagefright/LPAPlayer.h>
+
+#define MEM_BUFFER_SIZE 524288
+#define MEM_BUFFER_COUNT 4
+
+namespace android {
+void LPAPlayer::audio_register_memory() {
+    void *ion_buf; int32_t ion_fd;
+    struct msm_audio_ion_info ion_info;
+    //1. Open the ion_audio
+    ionfd = open("/dev/ion", O_RDONLY | O_SYNC);
+    if (ionfd < 0) {
+        LOGE("/dev/ion open failed \n");
+        return;
+    }
+    for (int i = 0; i < MEM_BUFFER_COUNT; i++) {
+        ion_buf = memBufferAlloc(MEM_BUFFER_SIZE, &ion_fd);
+        memset(&ion_info, 0, sizeof(msm_audio_ion_info));
+        LOGV("Registering ION with fd %d and address as %x", ion_fd, ion_buf);
+        ion_info.fd = ion_fd;
+        ion_info.vaddr = ion_buf;
+        if ( ioctl(afd, AUDIO_REGISTER_ION, &ion_info) < 0 ) {
+            LOGE("Registration of ION with the Driver failed with fd %d and memory %x",
+                 ion_info.fd, (unsigned int)ion_info.vaddr);
+        }
+    }
+}
+
+void *LPAPlayer::memBufferAlloc(int32_t nSize, int32_t *ion_fd){
+    void  *ion_buf = NULL;
+    void  *local_buf = NULL;
+    struct ion_fd_data fd_data;
+    struct ion_allocation_data alloc_data;
+
+    alloc_data.len =   nSize;
+    alloc_data.align = 0x1000;
+    alloc_data.flags = ION_HEAP(ION_AUDIO_HEAP_ID);
+    int rc = ioctl(ionfd, ION_IOC_ALLOC, &alloc_data);
+    if (rc) {
+        LOGE("ION_IOC_ALLOC ioctl failed\n");
+        return ion_buf;
+    }
+    fd_data.handle = alloc_data.handle;
+
+    rc = ioctl(ionfd, ION_IOC_SHARE, &fd_data);
+    if (rc) {
+        LOGE("ION_IOC_SHARE ioctl failed\n");
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            LOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return ion_buf;
+    }
+
+    // 2. MMAP to get the virtual address
+    ion_buf = mmap(NULL, nSize, PROT_READ | PROT_WRITE, MAP_SHARED, fd_data.fd, 0);
+    if(MAP_FAILED == ion_buf) {
+        LOGE("mmap() failed \n");
+        close(fd_data.fd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            LOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return ion_buf;
+    }
+
+    local_buf = malloc(nSize);
+    if (NULL == local_buf) {
+        // unmap the corresponding ION buffer and close the fd
+        munmap(ion_buf, MEM_BUFFER_SIZE);
+        close(fd_data.fd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &(alloc_data.handle));
+        if (rc) {
+            LOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        return NULL;
+    }
+
+    // 3. Store this information for internal mapping / maintanence
+    BuffersAllocated buf(local_buf, ion_buf, nSize, fd_data.fd, alloc_data.handle);
+    memBuffersRequestQueue.push_back(buf);
+
+    // 4. Send the mem fd information
+    *ion_fd = fd_data.fd;
+    LOGV("IONBufferAlloc calling with required size %d", nSize);
+    LOGV("ION allocated is %d, fd_data.fd %d and buffer is %x", *ion_fd, fd_data.fd, (unsigned int)ion_buf);
+
+    // 5. Return the virtual address
+    return ion_buf;
+}
+
+void LPAPlayer::memBufferDeAlloc()
+{
+    int rc = 0;
+    //Remove all the buffers from request queue
+    while (!memBuffersRequestQueue.empty())  {
+        List<BuffersAllocated>::iterator it = memBuffersRequestQueue.begin();
+        BuffersAllocated &ionBuffer = *it;
+        struct msm_audio_ion_info ion_info;
+        ion_info.vaddr = (*it).memBuf;
+        ion_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_ION, &ion_info) < 0) {
+            LOGE("ION deregister failed");
+        }
+        LOGV("Ion Unmapping the address %u, size %d, fd %d from Request",ionBuffer.memBuf,ionBuffer.bytesToWrite,ionBuffer.memFd);
+        munmap(ionBuffer.memBuf,MEM_BUFFER_SIZE);
+        LOGV("closing the ion shared fd");
+        close(ionBuffer.memFd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &ionBuffer.ion_handle);
+        if (rc) {
+            LOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        // free the local buffer corresponding to ion buffer
+        free(ionBuffer.localBuf);
+        LOGE("Removing from request Q");
+        memBuffersRequestQueue.erase(it);
+    }
+
+    //Remove all the buffers from response queue
+    while(!memBuffersResponseQueue.empty()){
+        List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+        BuffersAllocated &ionBuffer = *it;
+        struct msm_audio_ion_info ion_info;
+        ion_info.vaddr = (*it).memBuf;
+        ion_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_ION, &ion_info) < 0) {
+            LOGE("ION deregister failed");
+        }
+        LOGV("Ion Unmapping the address %u, size %d, fd %d from Request",ionBuffer.memBuf,ionBuffer.bytesToWrite,ionBuffer.memFd);
+        munmap(ionBuffer.memBuf, MEM_BUFFER_SIZE);
+        LOGV("closing the ion shared fd");
+        close(ionBuffer.memFd);
+        rc = ioctl(ionfd, ION_IOC_FREE, &ionBuffer.ion_handle);
+        if (rc) {
+            LOGE("ION_IOC_FREE ioctl failed\n");
+        }
+        // free the local buffer corresponding to ion buffer
+        free(ionBuffer.localBuf);
+        LOGV("Removing from response Q");
+        memBuffersResponseQueue.erase(it);
+    }
+    if (ionfd >= 0) {
+        close(ionfd);
+        ionfd = -1;
+    }
+}
+}// namespace android
diff --git a/media/libstagefright/LPAPlayerPMEM.cpp b/media/libstagefright/LPAPlayerPMEM.cpp
new file mode 100644
index 0000000..7698d13
--- /dev/null
+++ b/media/libstagefright/LPAPlayerPMEM.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "LPAPlayerPMEM"
+#include <utils/Log.h>
+
+#include <media/stagefright/LPAPlayer.h>
+
+#define MEM_BUFFER_SIZE 524288
+#define MEM_BUFFER_COUNT 4
+
+namespace android {
+void LPAPlayer::audio_register_memory() {
+    void *pmem_buf; int32_t pmem_fd;
+    struct msm_audio_pmem_info  pmem_info;
+    for (int i = 0; i < MEM_BUFFER_COUNT; i++) {
+        pmem_buf = memBufferAlloc(MEM_BUFFER_SIZE, &pmem_fd);
+        memset(&pmem_info, 0, sizeof(msm_audio_pmem_info));
+        LOGV("Registering PMEM with fd %d and address as %x", pmem_fd, pmem_buf);
+        pmem_info.fd = pmem_fd;
+        pmem_info.vaddr = pmem_buf;
+        if ( ioctl(afd, AUDIO_REGISTER_PMEM, &pmem_info) < 0 ) {
+            LOGE("Registration of PMEM with the Driver failed with fd %d and memory %x",
+                 pmem_info.fd, (unsigned int)pmem_info.vaddr);
+        }
+    }
+
+}
+
+void *LPAPlayer::memBufferAlloc(int32_t nSize, int32_t *pmem_fd){
+    int32_t pmemfd = -1;
+    void  *pmem_buf = NULL;
+    void  *local_buf = NULL;
+
+    // 1. Open the pmem_audio
+    pmemfd = open("/dev/pmem_audio", O_RDWR);
+    if (pmemfd < 0) {
+        LOGE("memBufferAlloc failed to open pmem_audio");
+        *pmem_fd = -1;
+        return pmem_buf;
+    }
+
+    // 2. MMAP to get the virtual address
+    pmem_buf = mmap(0, nSize, PROT_READ | PROT_WRITE, MAP_SHARED, pmemfd, 0);
+    if ( NULL == pmem_buf) {
+        LOGE("memBufferAlloc failed to mmap");
+        *pmem_fd = -1;
+        return NULL;
+    }
+
+    local_buf = malloc(nSize);
+    if (NULL == local_buf) {
+        // unmap the corresponding PMEM buffer and close the fd
+        munmap(pmem_buf, MEM_BUFFER_SIZE);
+        close(pmemfd);
+        return NULL;
+    }
+
+    // 3. Store this information for internal mapping / maintanence
+    BuffersAllocated buf(local_buf, pmem_buf, nSize, pmemfd);
+    memBuffersRequestQueue.push_back(buf);
+
+    // 4. Send the pmem fd information
+    *pmem_fd = pmemfd;
+    LOGV("memBufferAlloc calling with required size %d", nSize);
+    LOGV("The PMEM that is allocated is %d and buffer is %x", pmemfd, (unsigned int)pmem_buf);
+
+    // 5. Return the virtual address
+    return pmem_buf;
+}
+
+void LPAPlayer::memBufferDeAlloc()
+{
+    //Remove all the buffers from request queue
+    while (!memBuffersRequestQueue.empty())  {
+        List<BuffersAllocated>::iterator it = memBuffersRequestQueue.begin();
+        BuffersAllocated &pmemBuffer = *it;
+        struct msm_audio_pmem_info pmem_info;
+        pmem_info.vaddr = (*it).memBuf;
+        pmem_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_PMEM, &pmem_info) < 0) {
+            LOGE("PMEM deregister failed");
+        }
+        LOGV("Unmapping the address %u, size %d, fd %d from Request",pmemBuffer.memBuf,pmemBuffer.bytesToWrite,pmemBuffer.memFd);
+        munmap(pmemBuffer.memBuf, MEM_BUFFER_SIZE);
+        LOGV("closing the pmem fd");
+        close(pmemBuffer.memFd);
+        // free the local buffer corresponding to pmem buffer
+        free(pmemBuffer.localBuf);
+        LOGV("Removing from request Q");
+        memBuffersRequestQueue.erase(it);
+    }
+
+    //Remove all the buffers from response queue
+    while(!memBuffersResponseQueue.empty()){
+        List<BuffersAllocated>::iterator it = memBuffersResponseQueue.begin();
+        BuffersAllocated &pmemBuffer = *it;
+        struct msm_audio_pmem_info pmem_info;
+        pmem_info.vaddr = (*it).memBuf;
+        pmem_info.fd = (*it).memFd;
+        if (ioctl(afd, AUDIO_DEREGISTER_PMEM, &pmem_info) < 0) {
+            LOGE("PMEM deregister failed");
+        }
+        LOGV("Unmapping the address %u, size %d, fd %d from Response",pmemBuffer.memBuf,MEM_BUFFER_SIZE,pmemBuffer.memFd);
+        munmap(pmemBuffer.memBuf, MEM_BUFFER_SIZE);
+        LOGV("closing the pmem fd");
+        close(pmemBuffer.memFd);
+        // free the local buffer corresponding to pmem buffer
+        free(pmemBuffer.localBuf);
+        LOGV("Removing from response Q");
+        memBuffersResponseQueue.erase(it);
+    }
+}
+} //namespace android
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index f6b06c7..1a81afc 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -39,6 +39,7 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/Utils.h>
 #include <utils/String8.h>
+#include <cutils/properties.h>
 
 namespace android {
 
@@ -83,6 +84,12 @@ private:
 
     uint8_t *mSrcBuffer;
 
+    //For statistics profiling
+    uint32_t mNumSamplesReadError;
+    bool mStatistics;
+    void logExpectedFrames();
+    void logTrackStatistics();
+
     size_t parseNALSize(const uint8_t *data) const;
 
     MPEG4Source(const MPEG4Source &);
@@ -256,6 +263,12 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('a', 'v', 'c', '1'):
             return MEDIA_MIMETYPE_VIDEO_AVC;
 
+#ifdef QCOM_HARDWARE
+        case FOURCC('s', 'q', 'c', 'p'):
+            return MEDIA_MIMETYPE_AUDIO_QCELP;
+        case FOURCC('s', 'e', 'v', 'c'):
+            return MEDIA_MIMETYPE_AUDIO_EVRC;
+#endif
         default:
             CHECK(!"should not be here.");
             return NULL;
@@ -608,6 +621,9 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
     uint32_t chunk_type = ntohl(hdr[1]);
     off64_t data_offset = *offset + 8;
 
+    if(chunk_size == 0)
+       return ERROR_MALFORMED;
+
     if (chunk_size == 1) {
         if (mDataSource->readAt(*offset + 8, &chunk_size, 8) < 8) {
             return ERROR_IO;
@@ -917,6 +933,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('m', 'p', '4', 'a'):
         case FOURCC('s', 'a', 'm', 'r'):
         case FOURCC('s', 'a', 'w', 'b'):
+#ifdef QCOM_HARDWARE
+        case FOURCC('s', 'e', 'v', 'c'):
+        case FOURCC('s', 'q', 'c', 'p'):
+#endif
         {
             uint8_t buffer[8 + 20];
             if (chunk_data_size < (ssize_t)sizeof(buffer)) {
@@ -1125,12 +1145,17 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
         case FOURCC('s', 't', 's', 's'):
         {
-            status_t err =
-                mLastTrack->sampleTable->setSyncSampleParams(
-                        data_offset, chunk_data_size);
+            const char *mime;
+            CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
+            if(strncmp(mime, "audio/", 6))
+            {
+                status_t err =
+                    mLastTrack->sampleTable->setSyncSampleParams(
+                           data_offset, chunk_data_size);
 
-            if (err != OK) {
-                return err;
+                if (err != OK) {
+                   return err;
+                }
             }
 
             *offset += chunk_size;
@@ -1348,6 +1373,25 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             break;
         }
 
+#ifdef QCOM_HARDWARE
+         case FOURCC('d', 'q', 'c', 'p'):
+         case FOURCC('d', 'e', 'v', 'c'):
+         {
+            uint8_t buffer[20];
+
+            if (mDataSource->readAt(
+                 data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {
+                 LOGE("Buffered returned error \n");
+                 return ERROR_IO;
+            }
+
+            uint32_t vendor = U32_AT(&buffer[0]);
+            uint8_t decoder_version = ((U16_AT(&buffer[4])) & 0xff00) >>8;
+            uint8_t frames_per_sample = (U16_AT(&buffer[4])) & 0x00ff;
+            *offset += chunk_size;
+            break;
+        }
+#endif
         case FOURCC('m', 'd', 'a', 't'):
         {
             if (!mIsDrm) {
@@ -1740,6 +1784,13 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         return ERROR_MALFORMED;
     }
 
+#ifdef QCOM_HARDWARE
+    if (objectTypeIndication == 0xA0) {
+        // This isn't MPEG4 audio at all, it's EVRC
+       mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_EVRC);
+       return OK;
+    }
+#endif
     if (objectTypeIndication == 0xe1) {
         // This isn't MPEG4 audio at all, it's QCELP 14k...
         mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_QCELP);
@@ -1812,10 +1863,6 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         numChannels = (csd[1] >> 3) & 15;
     }
 
-    if (numChannels == 0) {
-        return ERROR_UNSUPPORTED;
-    }
-
     int32_t prevSampleRate;
     CHECK(mLastTrack->meta->findInt32(kKeySampleRate, &prevSampleRate));
 
@@ -1857,11 +1904,18 @@ MPEG4Source::MPEG4Source(
       mGroup(NULL),
       mBuffer(NULL),
       mWantsNALFragments(false),
-      mSrcBuffer(NULL) {
+      mSrcBuffer(NULL),
+      mNumSamplesReadError(0){
     const char *mime;
     bool success = mFormat->findCString(kKeyMIMEType, &mime);
     CHECK(success);
 
+    //for statistics profiling
+    char value[PROPERTY_VALUE_MAX];
+    mStatistics = false;
+    property_get("persist.debug.sf.statistics", value, "0");
+    if(atoi(value)) mStatistics = true;
+
     mIsAVC = !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC);
 
     if (mIsAVC) {
@@ -1878,6 +1932,14 @@ MPEG4Source::MPEG4Source(
         // The number of bytes used to encode the length of a NAL unit.
         mNALLengthSize = 1 + (ptr[4] & 3);
     }
+
+#ifdef QCOM_HARDWARE
+    //MPEG4 extractor can give complete frames,
+    //set arbitrary mode to false
+    format->setInt32(kKeyUseArbitraryMode, 0);
+#endif
+
+    if (mStatistics) logExpectedFrames();
 }
 
 MPEG4Source::~MPEG4Source() {
@@ -1891,6 +1953,9 @@ status_t MPEG4Source::start(MetaData *params) {
 
     CHECK(!mStarted);
 
+    if (mStatistics)
+        logTrackStatistics();
+
     int32_t val;
     if (params && params->findInt32(kKeyWantsNALFragments, &val)
         && val != 0) {
@@ -2064,6 +2129,7 @@ status_t MPEG4Source::read(
                     mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample);
 
         if (err != OK) {
+            if (mStatistics) mNumSamplesReadError++;
             return err;
         }
 
@@ -2071,6 +2137,7 @@ status_t MPEG4Source::read(
 
         if (err != OK) {
             CHECK(mBuffer == NULL);
+            if (mStatistics) mNumSamplesReadError++;
             return err;
         }
     }
@@ -2084,6 +2151,7 @@ status_t MPEG4Source::read(
                 mBuffer->release();
                 mBuffer = NULL;
 
+                if (mStatistics) mNumSamplesReadError++;
                 return ERROR_IO;
             }
 
@@ -2127,6 +2195,7 @@ status_t MPEG4Source::read(
             mBuffer->release();
             mBuffer = NULL;
 
+            if (mStatistics) mNumSamplesReadError++;
             return ERROR_MALFORMED;
         }
 
@@ -2164,6 +2233,7 @@ status_t MPEG4Source::read(
             mBuffer->release();
             mBuffer = NULL;
 
+            if (mStatistics) mNumSamplesReadError++;
             return ERROR_IO;
         }
 
@@ -2186,12 +2256,24 @@ status_t MPEG4Source::read(
                 }
 
                 if (isMalFormed) {
+                    //If NAL Length is corrupt,
+                    //return custom error ERROR_CORRUPT_NAL
                     LOGE("Video is malformed");
                     mBuffer->release();
                     mBuffer = NULL;
+
+                    if (mStatistics) mNumSamplesReadError++;
+#ifndef QCOM_HARDWARE
                     return ERROR_MALFORMED;
+#else
+                    srcOffset -= mNALLengthSize;
+                    srcOffset += size;
+                    ++mCurrentSampleIndex;
+                    return ERROR_CORRUPT_NAL;
+#endif
                 }
 
+
                 if (nalLength == 0) {
                     continue;
                 }
@@ -2256,14 +2338,22 @@ static bool LegacySniffMPEG4(
         return false;
     }
 
+#ifdef QCOM_HARDWARE
+    if (!memcmp(header, "ftyp3g2a", 8) || !memcmp(header, "ftyp3g2b", 8) || !memcmp(header, "ftyp3g2c", 8)
+        || !memcmp(header, "ftyp3gp", 7) || !memcmp(header, "ftypmp42", 8)
+#else
     if (!memcmp(header, "ftyp3gp", 7) || !memcmp(header, "ftypmp42", 8)
+#endif
         || !memcmp(header, "ftyp3gr6", 8) || !memcmp(header, "ftyp3gs6", 8)
         || !memcmp(header, "ftyp3ge6", 8) || !memcmp(header, "ftyp3gg6", 8)
         || !memcmp(header, "ftypisom", 8) || !memcmp(header, "ftypM4V ", 8)
         || !memcmp(header, "ftypM4A ", 8) || !memcmp(header, "ftypf4v ", 8)
-        || !memcmp(header, "ftypkddi", 8) || !memcmp(header, "ftypM4VP", 8)) {
+        || !memcmp(header, "ftypkddi", 8) || !memcmp(header, "ftypM4VP", 8)
+        || !memcmp(header, "ftypMSNV", 8) || !memcmp(header, "ftypavc1", 8)
+        || !memcmp(header, "ftypmmp4", 8) || !memcmp(header, "ftypk3g1", 8)
+        || !memcmp(header, "ftypmp41", 8) || !memcmp(header, "ftypskm3", 8)) {
         *mimeType = MEDIA_MIMETYPE_CONTAINER_MPEG4;
-        *confidence = 0.4;
+        *confidence = 0.6;
 
         return true;
     }
@@ -2401,7 +2491,7 @@ static bool BetterSniffMPEG4(
     }
 
     *mimeType = MEDIA_MIMETYPE_CONTAINER_MPEG4;
-    *confidence = 0.4f;
+    *confidence = 0.6f;
 
     if (moovAtomEndOffset >= 0) {
         *meta = new AMessage;
@@ -2428,5 +2518,33 @@ bool SniffMPEG4(
     return false;
 }
 
+void MPEG4Source::logTrackStatistics()
+{
+    const char *mime;
+    mFormat->findCString(kKeyMIMEType, &mime);
+    LOGW("=====================================================");
+    LOGW("Mime Type: %s",mime);
+    LOGW("Total number of samples in track: %u",mSampleTable->countSamples());
+    LOGW("Number of key samples: %u",mSampleTable->getNumSyncSamples());
+    LOGW("Number of corrupt samples: %u",mNumSamplesReadError ?
+           mNumSamplesReadError-1 : mNumSamplesReadError); //last sample reads error for EOS
+    LOGW("=====================================================");
+}
+
+void MPEG4Source::logExpectedFrames()
+{
+    const char *mime;
+    mFormat->findCString(kKeyMIMEType, &mime);
+    int64_t durationUs;
+    getFormat()->findInt64(kKeyDuration, &durationUs);
+    LOGW("=====================================================");
+    LOGW("Mime type: %s",mime);
+    LOGW("Track duration: %lld",durationUs/1000);
+    LOGW("Total number of samples in track: %u",mSampleTable->countSamples());
+    LOGW("Expected frames per second: %.2f",((float)mSampleTable->countSamples()*1000)/((float)durationUs/1000));
+    LOGW("=====================================================");
+}
+
+
 }  // namespace android
 
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 46d87df..b4c0524 100755
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -1840,12 +1840,15 @@ status_t MPEG4Writer::Track::threadEntry() {
     int32_t sampleCount = 1;          // Sample count in the current stts table entry
     int64_t currCttsDurTicks = 0;     // Timescale based ticks
     int64_t lastCttsDurTicks = 0;     // Timescale based ticks
-    int32_t cttsSampleCount = 1;      // Sample count in the current ctts table entry
+    int32_t cttsSampleCount = 0;      // Sample count in the current ctts table entry
     uint32_t previousSampleSize = 0;      // Size of the previous sample
     int64_t previousPausedDurationUs = 0;
     int64_t timestampUs = 0;
     int64_t cttsDeltaTimeUs = 0;
     bool hasBFrames = false;
+#ifdef QCOM_HARDWARE
+    hasBFrames = true;
+#endif
 
 #if 1
     // XXX: Samsung's video encoder's output buffer timestamp
@@ -1941,10 +1944,14 @@ status_t MPEG4Writer::Track::threadEntry() {
 
         if (mOwner->exceedsFileSizeLimit()) {
             mOwner->notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, 0);
+            copy->release();
+            copy = NULL;
             break;
         }
         if (mOwner->exceedsFileDurationLimit()) {
             mOwner->notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, 0);
+            copy->release();
+            copy = NULL;
             break;
         }
 
@@ -1953,6 +1960,20 @@ status_t MPEG4Writer::Track::threadEntry() {
         meta_data->findInt32(kKeyIsSyncFrame, &isSync);
         CHECK(meta_data->findInt64(kKeyTime, &timestampUs));
 
+#ifdef QCOM_HARDWARE
+        if(!mIsAudio) {
+          int32_t frameRate, hfr, multiple;
+          bool success = mMeta->findInt32(kKeyFrameRate, &frameRate);
+          CHECK(success);
+          success = mMeta->findInt32(kKeyHFR, &hfr);
+          if (!success) {
+              hfr = 0;
+          }
+          multiple = hfr?(hfr/frameRate):1;
+          timestampUs = multiple * timestampUs;
+        }
+#endif
+
 ////////////////////////////////////////////////////////////////////////////////
         if (mNumSamples == 0) {
             mFirstSampleTimeRealUs = systemTime() / 1000;
@@ -1983,6 +2004,17 @@ status_t MPEG4Writer::Track::threadEntry() {
              */
             int64_t decodingTimeUs;
             CHECK(meta_data->findInt64(kKeyDecodingTime, &decodingTimeUs));
+#ifdef QCOM_HARDWARE
+            {
+              int32_t frameRate, hfr, multiple;
+              bool success = mMeta->findInt32(kKeyHFR, &hfr);
+              CHECK(success);
+              success = mMeta->findInt32(kKeyFrameRate, &frameRate);
+              CHECK(success);
+              multiple = hfr?(hfr/frameRate):1;
+              decodingTimeUs = multiple * decodingTimeUs;
+            }
+#endif
             decodingTimeUs -= previousPausedDurationUs;
             int64_t timeUs = decodingTimeUs;
             cttsDeltaTimeUs = timestampUs - decodingTimeUs;
@@ -2028,18 +2060,23 @@ status_t MPEG4Writer::Track::threadEntry() {
                 ++sampleCount;
             }
 
-            if (!mIsAudio) {
-                currCttsDurTicks =
-                     ((cttsDeltaTimeUs * mTimeScale + 500000LL) / 1000000LL -
-                     (lastCttsTimeUs * mTimeScale + 500000LL) / 1000000LL);
-                if (currCttsDurTicks != lastCttsDurTicks) {
-                    addOneCttsTableEntry(cttsSampleCount, lastCttsDurTicks);
-                    cttsSampleCount = 1;
-                } else {
-                    ++cttsSampleCount;
-                }
+        }
+
+        if (!mIsAudio && hasBFrames && (mNumSamples >= 2)) {
+            currCttsDurTicks = (cttsDeltaTimeUs * mTimeScale) / 1000000LL;
+            ++cttsSampleCount;
+            if (currCttsDurTicks != lastCttsDurTicks) {
+                LOGV("currCttsDurTicks (%lld) != lastCttsDurTicks (%lld) (%d), add one",
+                     currCttsDurTicks, lastCttsDurTicks, cttsSampleCount);
+                addOneCttsTableEntry(cttsSampleCount, lastCttsDurTicks);
+                cttsSampleCount = 0;
             }
+
+            lastCttsDurTicks = currCttsDurTicks;
+            lastCttsTimeUs = cttsDeltaTimeUs;
         }
+
+
         if (mSamplesHaveSameSize) {
             if (mNumSamples >= 2 && previousSampleSize != sampleSize) {
                 mSamplesHaveSameSize = false;
@@ -2052,11 +2089,6 @@ status_t MPEG4Writer::Track::threadEntry() {
         lastDurationTicks = currDurationTicks;
         lastTimestampUs = timestampUs;
 
-        if (!mIsAudio) {
-            lastCttsDurTicks = currCttsDurTicks;
-            lastCttsTimeUs = cttsDeltaTimeUs;
-        }
-
         if (isSync != 0) {
             addOneStssTableEntry(mNumSamples);
         }
@@ -2140,7 +2172,12 @@ status_t MPEG4Writer::Track::threadEntry() {
         addOneSttsTableEntry(sampleCount, lastDurationTicks);
     }
 
-    addOneCttsTableEntry(cttsSampleCount, lastCttsDurTicks);
+    if (!mIsAudio && hasBFrames) {
+        LOGV("Add ctts for last sample count = %d, ctts value = %lld", cttsSampleCount,
+             lastCttsDurTicks);
+        addOneCttsTableEntry(cttsSampleCount, lastCttsDurTicks);
+    }
+
     mTrackDurationUs += lastDurationUs;
     mReachedEOS = true;
 
@@ -2734,7 +2771,7 @@ void MPEG4Writer::Track::writeCttsBox() {
 
     mOwner->beginBox("ctts");
     if (mHasNegativeCttsDeltaDuration) {
-        mOwner->writeInt32(0x00010000);  // version=1, flags=0
+        mOwner->writeInt32(0x01000000);  // version=1 (1 byte), flags=0 (3 bytes)
     } else {
         mOwner->writeInt32(0);  // version=0, flags=0
     }
@@ -2747,6 +2784,7 @@ void MPEG4Writer::Track::writeCttsBox() {
         mOwner->writeInt32(it->sampleDuration);
         totalCount += it->sampleCount;
     }
+    LOGV("totalCount = %lld, mNumSamples = %d", totalCount, mNumSamples);
     CHECK(totalCount == mNumSamples);
     mOwner->endBox();  // ctts
 }
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
old mode 100644
new mode 100755
index 444e823..d022b6e
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2010-2012 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -50,7 +51,21 @@ const char *MEDIA_MIMETYPE_CONTAINER_AVI = "video/avi";
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG2PS = "video/mp2p";
 
 const char *MEDIA_MIMETYPE_CONTAINER_WVM = "video/wvm";
+#ifdef QCOM_HARDWARE
+const char *MEDIA_MIMETYPE_AUDIO_EVRC = "audio/evrc";
 
+const char *MEDIA_MIMETYPE_VIDEO_WMV = "video/x-ms-wmv";
+const char *MEDIA_MIMETYPE_AUDIO_WMA = "audio/x-ms-wma";
+const char *MEDIA_MIMETYPE_CONTAINER_ASF = "video/x-ms-asf";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX = "video/divx";
+const char *MEDIA_MIMETYPE_AUDIO_AC3 = "audio/ac3";
+const char *MEDIA_MIMETYPE_CONTAINER_AAC = "audio/aac";
+const char *MEDIA_MIMETYPE_CONTAINER_QCP = "audio/vnd.qcelp";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX311 = "video/divx311";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX4 = "video/divx4";
+const char *MEDIA_MIMETYPE_CONTAINER_MPEG2 = "video/mp2";
+const char *MEDIA_MIMETYPE_CONTAINER_3G2 = "video/3g2";
+#endif
 const char *MEDIA_MIMETYPE_TEXT_3GPP = "text/3gpp-tt";
 
 }  // namespace android
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
old mode 100644
new mode 100755
index 374ecf7..0969d16
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2010-2011 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -29,6 +30,9 @@
 #include "include/WVMExtractor.h"
 #include "include/FLACExtractor.h"
 #include "include/AACExtractor.h"
+#ifdef QCOM_HARDWARE
+#include "include/ExtendedExtractor.h"
+#endif
 
 #include "matroska/MatroskaExtractor.h"
 
@@ -125,7 +129,14 @@ sp<MediaExtractor> MediaExtractor::Create(
        }
     }
 
+#ifdef QCOM_HARDWARE
+    if (ret) return ret;
+
+        LOGV(" Using ExtendedExtractor\n");
+    return ExtendedExtractor::CreateExtractor(source, mime);
+#else
     return ret;
+#endif
 }
 
 }  // namespace android
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
old mode 100755
new mode 100644
index 86b3fe4..ac8e114
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011 - 2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,11 +19,13 @@
 #define LOG_TAG "OMXCodec"
 #include <utils/Log.h>
 
+#include "include/AACDecoder.h"
 #include "include/AACEncoder.h"
 #include "include/AMRNBEncoder.h"
 #include "include/AMRWBEncoder.h"
 #include "include/AVCEncoder.h"
 #include "include/M4vH263Encoder.h"
+#include "include/MP3Decoder.h"
 
 #include "include/ESDS.h"
 
@@ -40,14 +43,35 @@
 #include <media/stagefright/OMXCodec.h>
 #include <media/stagefright/Utils.h>
 #include <utils/Vector.h>
+#ifdef QCOM_HARDWARE
+#include <cutils/properties.h>
+#endif
 
 #include <OMX_Audio.h>
 #include <OMX_Component.h>
 
+#ifdef QCOM_HARDWARE
+#include <cutils/properties.h>
+#include <OMX_QCOMExtns.h>
+
+#include <gralloc_priv.h>
+#include <qcom_ui.h>
+#include <QOMX_AudioExtensions.h>
+#endif
 #include "include/avc_utils.h"
+#ifdef SAMSUNG_CODEC_SUPPORT
+#include "include/ColorFormat.h"
+#endif
 
 namespace android {
 
+#ifdef SAMSUNG_CODEC_SUPPORT
+static const int OMX_SEC_COLOR_FormatNV12TPhysicalAddress = 0x7F000001;
+static const int OMX_SEC_COLOR_FormatNV12LPhysicalAddress = 0x7F000002;
+static const int OMX_SEC_COLOR_FormatNV12LVirtualAddress = 0x7F000003;
+static const int OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002;
+#endif
+
 // Treat time out as an error if we have not received any output
 // buffers after 3 seconds.
 const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
@@ -59,11 +83,72 @@ const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
 // component in question is buggy or not.
 const static uint32_t kMaxColorFormatSupported = 1000;
 
+#ifdef QCOM_HARDWARE
+static const int QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03;
+static const int OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00;
+#endif
+
 struct CodecInfo {
     const char *mime;
     const char *codec;
 };
 
+#ifdef QCOM_HARDWARE
+class ColorFormatInfo {
+    private:
+        enum {
+            LOCAL = 0,
+            REMOTE = 1,
+            END = 2
+        };
+        static const int32_t preferredColorFormat[END];
+    public:
+        static int32_t getPreferredColorFormat(bool isLocal) {
+            char colorformat[10]="";
+            if(!property_get("sf.debug.colorformat", colorformat, NULL)){
+                if(isLocal) {
+                    return preferredColorFormat[LOCAL];
+                }
+                return preferredColorFormat[REMOTE];
+            } else {
+                if(!strcmp(colorformat, "yamato")) {
+                    return QOMX_COLOR_FormatYVU420PackedSemiPlanar32m4ka;
+                }
+                return preferredColorFormat[LOCAL];
+            }
+        }
+};
+
+const int32_t ColorFormatInfo::preferredColorFormat[] = {
+#ifdef TARGET7x30
+    QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka,
+    QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
+#endif
+#ifdef TARGET8x60
+    QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka,
+    QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
+#endif
+#ifdef TARGET7x27
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar,
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+    //QOMX_COLOR_FormatYVU420PackedSemiPlanar32m4ka
+#endif
+#ifdef TARGET7x27A
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar,
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+#endif
+#ifdef TARGET8x50
+    OMX_QCOM_COLOR_FormatYVU420SemiPlanar,
+    QOMX_COLOR_FormatYVU420PackedSemiPlanar32m4ka
+#endif
+};
+#endif
+
+#define FACTORY_CREATE(name) \
+static sp<MediaSource> Make##name(const sp<MediaSource> &source) { \
+    return new name(source); \
+}
+
 #define FACTORY_CREATE_ENCODER(name) \
 static sp<MediaSource> Make##name(const sp<MediaSource> &source, const sp<MetaData> &meta) { \
     return new name(source, meta); \
@@ -71,6 +156,10 @@ static sp<MediaSource> Make##name(const sp<MediaSource> &source, const sp<MetaDa
 
 #define FACTORY_REF(name) { #name, Make##name },
 
+#ifdef WITH_QCOM_LPA
+FACTORY_CREATE(MP3Decoder)
+FACTORY_CREATE(AACDecoder)
+#endif
 FACTORY_CREATE_ENCODER(AMRNBEncoder)
 FACTORY_CREATE_ENCODER(AMRWBEncoder)
 FACTORY_CREATE_ENCODER(AACEncoder)
@@ -102,13 +191,55 @@ static sp<MediaSource> InstantiateSoftwareEncoder(
     return NULL;
 }
 
+#ifdef WITH_QCOM_LPA
+static sp<MediaSource> InstantiateSoftwareDecoder(
+        const char *name, const sp<MediaSource> &source) {
+    struct FactoryInfo {
+        const char *name;
+        sp<MediaSource> (*CreateFunc)(const sp<MediaSource> &);
+    };
+
+    static const FactoryInfo kFactoryInfo[] = {
+        FACTORY_REF(MP3Decoder)
+        FACTORY_REF(AACDecoder)
+    };
+    for (size_t i = 0;
+         i < sizeof(kFactoryInfo) / sizeof(kFactoryInfo[0]); ++i) {
+        if (!strcmp(name, kFactoryInfo[i].name)) {
+            return (*kFactoryInfo[i].CreateFunc)(source);
+        }
+    }
+
+    return NULL;
+}
+#endif
+
 #undef FACTORY_REF
 #undef FACTORY_CREATE
 
 static const CodecInfo kDecoderInfo[] = {
+#ifdef SAMSUNG_OMX
+    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.SEC.mp3.dec" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.SEC.amr.dec" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.SEC.amr.dec" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.SEC.aac.dec" },
+    { MEDIA_MIMETYPE_AUDIO_FLAC, "OMX.SEC.flac.dec" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.SEC.mpeg4.dec" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.SEC.h263.dec" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.SEC.h263sr.dec" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.SEC.avc.dec" },
+    { MEDIA_MIMETYPE_CONTAINER_WVM, "OMX.SEC.vc1.dec" },
+    { MEDIA_MIMETYPE_CONTAINER_WVM, "OMX.SEC.wma.dec" },
+    { MEDIA_MIMETYPE_CONTAINER_WVM, "OMX.SEC.wmv7.dec" },
+    { MEDIA_MIMETYPE_CONTAINER_WVM, "OMX.SEC.wmv8.dec" },
+    { MEDIA_MIMETYPE_VIDEO_VPX, "OMX.SEC.vp8.dec" },
+#endif
     { MEDIA_MIMETYPE_IMAGE_JPEG, "OMX.TI.JPEG.decode" },
 //    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.TI.MP3.decode" },
     { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.google.mp3.decoder" },
+#ifdef WITH_QCOM_LPA
+    { MEDIA_MIMETYPE_AUDIO_MPEG, "MP3Decoder" },
+#endif
     { MEDIA_MIMETYPE_AUDIO_MPEG_LAYER_II, "OMX.Nvidia.mp2.decoder" },
 //    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.TI.AMR.decode" },
 //    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.Nvidia.amr.decoder" },
@@ -119,6 +250,9 @@ static const CodecInfo kDecoderInfo[] = {
 //    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.Nvidia.aac.decoder" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.decode" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.google.aac.decoder" },
+#ifdef WITH_QCOM_LPA
+    { MEDIA_MIMETYPE_AUDIO_AAC, "AACDecoder" },
+#endif
     { MEDIA_MIMETYPE_AUDIO_G711_ALAW, "OMX.google.g711.alaw.decoder" },
     { MEDIA_MIMETYPE_AUDIO_G711_MLAW, "OMX.google.g711.mlaw.decoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.DUCATI1.VIDEO.DECODER" },
@@ -140,22 +274,51 @@ static const CodecInfo kDecoderInfo[] = {
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.video.decoder.avc" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.Video.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.SEC.AVC.Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.SEC.FP.AVC.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.google.h264.decoder" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.google.avc.decoder" },
     { MEDIA_MIMETYPE_AUDIO_VORBIS, "OMX.google.vorbis.decoder" },
+    { MEDIA_MIMETYPE_VIDEO_VPX, "OMX.SEC.VP8.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_VPX, "OMX.google.vpx.decoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG2, "OMX.Nvidia.mpeg2v.decode" },
+#ifdef QCOM_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_DIVX, "OMX.qcom.video.decoder.divx"},
+    { MEDIA_MIMETYPE_VIDEO_DIVX311, "OMX.qcom.video.decoder.divx311"},
+    { MEDIA_MIMETYPE_VIDEO_DIVX4, "OMX.qcom.video.decoder.divx4"},
+    { MEDIA_MIMETYPE_AUDIO_AC3, "OMX.qcom.audio.decoder.ac3" },
+    { MEDIA_MIMETYPE_AUDIO_QCELP, "OMX.qcom.audio.decoder.Qcelp13Hw"},
+    { MEDIA_MIMETYPE_AUDIO_QCELP, "OMX.qcom.audio.decoder.Qcelp13"},
+    { MEDIA_MIMETYPE_AUDIO_EVRC, "OMX.qcom.audio.decoder.evrchw" },
+    { MEDIA_MIMETYPE_AUDIO_EVRC, "OMX.qcom.audio.decoder.evrc" },
+    { MEDIA_MIMETYPE_AUDIO_WMA, "OMX.qcom.audio.decoder.wma"},
+    { MEDIA_MIMETYPE_AUDIO_WMA, "OMX.qcom.audio.decoder.wmaLossLess"},
+    { MEDIA_MIMETYPE_AUDIO_WMA, "OMX.qcom.audio.decoder.wma10Pro"},
+    { MEDIA_MIMETYPE_VIDEO_WMV, "OMX.qcom.video.decoder.vc1"},
+#endif
 };
 
 static const CodecInfo kEncoderInfo[] = {
+#ifdef SAMSUNG_OMX
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.SEC.amr.enc" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.SEC.amr.enc" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.SEC.aac.enc" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.SEC.mpeg4.enc" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.SEC.h263.enc" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.SEC.avc.enc" },
+#endif
     { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.TI.AMR.encode" },
     { MEDIA_MIMETYPE_AUDIO_AMR_NB, "AMRNBEncoder" },
     { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.TI.WBAMR.encode" },
     { MEDIA_MIMETYPE_AUDIO_AMR_WB, "AMRWBEncoder" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.encode" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.qcom.audio.encoder.aac" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "AACEncoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.DUCATI1.VIDEO.MPEG4E" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.7x30.video.encoder.mpeg4" },
+#ifdef QCOM_HARDWARE
+    { MEDIA_MIMETYPE_AUDIO_EVRC,   "OMX.qcom.audio.encoder.evrc" },
+    { MEDIA_MIMETYPE_AUDIO_QCELP,  "OMX.qcom.audio.encoder.qcelp13" },
+#endif
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.video.encoder.mpeg4" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.Video.encoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.Nvidia.mp4.encoder" },
@@ -238,7 +401,8 @@ static void InitOMXParams(T *params) {
 }
 
 static bool IsSoftwareCodec(const char *componentName) {
-    if (!strncmp("OMX.google.", componentName, 11)) {
+    if (!strncmp("OMX.google.", componentName, 11)
+	    || !strncmp("OMX.PV.", componentName, 7)) {
         return true;
     }
 
@@ -303,6 +467,27 @@ uint32_t OMXCodec::getComponentQuirks(
         quirks |= kRequiresFlushCompleteEmulation;
         quirks |= kSupportsMultipleFramesPerInputBuffer;
     }
+#ifdef QCOM_HARDWARE
+    if (!strcmp(componentName, "OMX.qcom.audio.encoder.evrc")) {
+        quirks |= kRequiresAllocateBufferOnInputPorts;
+        quirks |= kRequiresAllocateBufferOnOutputPorts;
+    }
+
+    if (!strcmp(componentName, "OMX.qcom.audio.encoder.qcelp13")) {
+        quirks |= kRequiresAllocateBufferOnInputPorts;
+        quirks |= kRequiresAllocateBufferOnOutputPorts;
+    }
+
+    if(!strcmp(componentName, "OMX.qcom.audio.decoder.Qcelp13"))  {
+       LOGV("setting kRequiresGlobalFlush for QCELP");
+       quirks |= kRequiresGlobalFlush;
+    }
+
+    if(!strcmp(componentName, "OMX.qcom.audio.decoder.evrc"))  {
+       LOGV("setting kRequiresGlobalFlush for EVRC");
+       quirks |= kRequiresGlobalFlush;
+    }
+#endif
     if (!strncmp(componentName, "OMX.qcom.video.encoder.", 23)) {
         quirks |= kRequiresLoadedToIdleAfterAllocation;
         quirks |= kRequiresAllocateBufferOnInputPorts;
@@ -314,12 +499,17 @@ uint32_t OMXCodec::getComponentQuirks(
             // the worst/least compression ratio is 0.5. It is found that
             // sometimes, the output buffer size is larger than
             // size advertised by the encoder.
+#if defined(QCOM_LEGACY_OMX) || !defined(QCOM_HARDWARE)
             quirks |= kRequiresLargerEncoderOutputBuffer;
+#endif
         }
     }
     if (!strncmp(componentName, "OMX.qcom.7x30.video.encoder.", 28)) {
     }
     if (!strncmp(componentName, "OMX.qcom.video.decoder.", 23)) {
+#ifdef QCOM_HARDWARE
+        quirks |= kRequiresAllocateBufferOnInputPorts;
+#endif
         quirks |= kRequiresAllocateBufferOnOutputPorts;
         quirks |= kDefersOutputBufferAllocation;
     }
@@ -366,6 +556,18 @@ uint32_t OMXCodec::getComponentQuirks(
         quirks |= kOutputBuffersAreUnreadable;
     }
 
+#ifdef QCOM_HARDWARE
+    if(!strcmp(componentName,"OMX.qcom.audio.decoder.ac3")) {
+        LOGV("AC3 enabling allocate buffer on input and output ports");
+        quirks |= kRequiresAllocateBufferOnInputPorts;
+        quirks |= kRequiresAllocateBufferOnOutputPorts;
+    }
+
+    if (!strcmp(componentName, "OMX.qcom.audio.decoder.wma")) {
+        quirks |= kRequiresWMAProComponent;
+    }
+#endif
+
     return quirks;
 }
 
@@ -433,6 +635,11 @@ sp<MediaSource> OMXCodec::Create(
             && requiresSecureBuffers) {
         flags |= kIgnoreCodecSpecificData;
         flags |= kUseSecureInputBuffers;
+        flags |= kEnableGrallocUsageProtected;
+    }
+    else
+    {
+        flags &= ~kEnableGrallocUsageProtected;
     }
 
     const char *mime;
@@ -462,20 +669,41 @@ sp<MediaSource> OMXCodec::Create(
             componentName = tmp.c_str();
         }
 
+        sp<MediaSource> softwareCodec;
         if (createEncoder) {
-            sp<MediaSource> softwareCodec =
-                InstantiateSoftwareEncoder(componentName, source, meta);
-
-            if (softwareCodec != NULL) {
-                LOGV("Successfully allocated software codec '%s'", componentName);
-
-                return softwareCodec;
-            }
+            softwareCodec = InstantiateSoftwareEncoder(componentName, source, meta);
+#ifdef WITH_QCOM_LPA
+        } else {
+            softwareCodec = InstantiateSoftwareDecoder(componentName, source);
+#endif
+		}
+        if (softwareCodec != NULL) {
+            LOGI("Successfully allocated software codec '%s'", componentName);
+            return softwareCodec;
         }
 
-        LOGV("Attempting to allocate OMX node '%s'", componentName);
+        LOGI("Attempting to allocate OMX node '%s'", componentName);
 
         uint32_t quirks = getComponentQuirks(componentNameBase, createEncoder);
+#ifdef QCOM_HARDWARE
+        if(quirks & kRequiresWMAProComponent)
+        {
+           int32_t version;
+           CHECK(meta->findInt32(kKeyWMAVersion, &version));
+           if(version==kTypeWMA)
+           {
+              componentName = "OMX.qcom.audio.decoder.wma";
+           }
+           else if(version==kTypeWMAPro)
+           {
+              componentName= "OMX.qcom.audio.decoder.wma10Pro";
+           }
+           else if(version==kTypeWMALossLess)
+           {
+              componentName= "OMX.qcom.audio.decoder.wmaLossLess";
+           }
+        }
+#endif
 
         if (!createEncoder
                 && (quirks & kOutputBuffersAreUnreadable)
@@ -494,7 +722,7 @@ sp<MediaSource> OMXCodec::Create(
 
         status_t err = omx->allocateNode(componentName, observer, &node);
         if (err == OK) {
-            LOGV("Successfully allocated OMX node '%s'", componentName);
+            LOGI("Successfully allocated OMX node '%s'", componentName);
 
             sp<OMXCodec> codec = new OMXCodec(
                     omx, node, quirks, flags,
@@ -522,7 +750,7 @@ sp<MediaSource> OMXCodec::Create(
 
 status_t OMXCodec::parseAVCCodecSpecificData(
         const void *data, size_t size,
-        unsigned *profile, unsigned *level) {
+        unsigned *profile, unsigned *level, const sp<MetaData> &meta) {
     const uint8_t *ptr = (const uint8_t *)data;
 
     // verify minimum size and configurationVersion == 1.
@@ -544,6 +772,29 @@ status_t OMXCodec::parseAVCCodecSpecificData(
     // CHECK((ptr[5] >> 5) == 7);  // reserved
 
     size_t numSeqParameterSets = ptr[5] & 31;
+#ifdef QCOM_HARDWARE
+    uint16_t spsSize = (((uint16_t)ptr[6]) << 8)
+      + (uint16_t)(ptr[7]);
+    CODEC_LOGV("numSeqParameterSets = %d , spsSize = %d",
+               numSeqParameterSets,spsSize);
+    SpsInfo info;
+    if (parseSps(spsSize, ptr + 9, &info) == OK) {
+        mSPSParsed = true;
+        CODEC_LOGV("SPS parsed");
+        if (info.mInterlaced) {
+            mInterlaceFormatDetected = true;
+            mUseArbitraryMode = true;
+            CODEC_LOGI("Interlace format detected");
+        } else {
+            CODEC_LOGI("Non-Interlaced format detected");
+        }
+    }
+    else {
+        CODEC_LOGI("ParseSPS could not find if content is interlaced");
+        mSPSParsed = false;
+        mInterlaceFormatDetected = false;
+    }
+#endif
 
     ptr += 6;
     size -= 6;
@@ -607,6 +858,15 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         uint32_t type;
         const void *data;
         size_t size;
+#ifdef QCOM_HARDWARE
+        if (!strncasecmp(mMIME, "video/", 6)) {
+            int32_t arbitraryMode = 1;
+            bool success = meta->findInt32(kKeyUseArbitraryMode, &arbitraryMode);
+            if (success) {
+                mUseArbitraryMode = arbitraryMode ? true : false;
+            }
+        }
+#endif
         if (meta->findData(kKeyESDS, &type, &data, &size)) {
             ESDS esds((const char *)data, size);
             CHECK_EQ(esds.InitCheck(), (status_t)OK);
@@ -624,7 +884,7 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             unsigned profile, level;
             status_t err;
             if ((err = parseAVCCodecSpecificData(
-                            data, size, &profile, &level)) != OK) {
+                            data, size, &profile, &level, meta)) != OK) {
                 LOGE("Malformed AVC codec specific data.");
                 return err;
             }
@@ -642,11 +902,56 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
                 LOGE("Profile and/or level exceed the decoder's capabilities.");
                 return ERROR_UNSUPPORTED;
             }
+            if(!strcmp(mComponentName, "OMX.google.h264.decoder")
+                && (profile != kAVCProfileBaseline)) {
+                LOGE("%s does not support profiles > kAVCProfileBaseline", mComponentName);
+                // The profile is unsupported by the decoder
+                return ERROR_UNSUPPORTED;
+            }
+
         } else if (meta->findData(kKeyVorbisInfo, &type, &data, &size)) {
             addCodecSpecificData(data, size);
 
             CHECK(meta->findData(kKeyVorbisBooks, &type, &data, &size));
             addCodecSpecificData(data, size);
+#ifdef QCOM_HARDWARE
+        } else if (meta->findData(kKeyRawCodecSpecificData, &type, &data, &size)) {
+            LOGV("OMXCodec::configureCodec found kKeyRawCodecSpecificData of size %d\n", size);
+            addCodecSpecificData(data, size);
+        }
+
+    }
+
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mMIME) ||
+        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mMIME) ||
+        !strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mMIME)) {
+        LOGV("Setting the QOMX_VIDEO_PARAM_DIVXTYPE params ");
+        QOMX_VIDEO_PARAM_DIVXTYPE paramDivX;
+        InitOMXParams(&paramDivX);
+        paramDivX.nPortIndex = mIsEncoder ? kPortIndexOutput : kPortIndexInput;
+        int32_t DivxVersion = 0;
+        CHECK(meta->findInt32(kKeyDivXVersion,&DivxVersion));
+        CODEC_LOGV("Divx Version Type %d\n",DivxVersion);
+
+        if(DivxVersion == kTypeDivXVer_4) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat4;
+        } else if(DivxVersion == kTypeDivXVer_5) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat5;
+        } else if(DivxVersion == kTypeDivXVer_6) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat6;
+        } else if(DivxVersion == kTypeDivXVer_3_11 ) {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormat311;
+        } else {
+            paramDivX.eFormat = QOMX_VIDEO_DIVXFormatUnused;
+        }
+        paramDivX.eProfile = (QOMX_VIDEO_DIVXPROFILETYPE)0;    //Not used for now.
+
+        status_t err =  mOMX->setParameter(mNode,
+                         (OMX_INDEXTYPE)OMX_QcomIndexParamVideoDivx,
+                         &paramDivX, sizeof(paramDivX));
+        if (err!=OK) {
+            return err;
+#endif
         }
     }
 
@@ -668,6 +973,29 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             CODEC_LOGE("setAACFormat() failed (err = %d)", err);
             return err;
         }
+#ifdef QCOM_HARDWARE
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AC3, mMIME)) {
+        return BAD_TYPE;
+        /*int32_t numChannels, sampleRate;
+        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
+        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+        setAC3Format(numChannels, sampleRate);*/
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_EVRC, mMIME)) {
+        int32_t numChannels, sampleRate;
+        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
+        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+        setEVRCFormat(numChannels, sampleRate, bitRate);
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_QCELP, mMIME)) {
+        int32_t numChannels, sampleRate;
+        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
+        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+        setQCELPFormat(numChannels, sampleRate, bitRate);
+    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_WMA, mMIME))  {
+        status_t err = setWMAFormat(meta);
+        if(err!=OK){
+           return err;
+        }
+#endif
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_G711_ALAW, mMIME)
             || !strcasecmp(MEDIA_MIMETYPE_AUDIO_G711_MLAW, mMIME)) {
         // These are PCM-like formats with a fixed sample rate but
@@ -680,6 +1008,26 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     }
 
     if (!strncasecmp(mMIME, "video/", 6)) {
+#ifdef QCOM_HARDWARE
+        if (mThumbnailMode) {
+            LOGV("Enabling thumbnail mode.");
+            QOMX_ENABLETYPE enableType;
+            OMX_INDEXTYPE indexType;
+
+            status_t err = mOMX->getExtensionIndex(
+                mNode, OMX_QCOM_INDEX_PARAM_VIDEO_SYNCFRAMEDECODINGMODE, &indexType);
+
+            CHECK_EQ(err, (status_t)OK);
+
+            enableType.bEnable = OMX_TRUE;
+
+            err = mOMX->setParameter(
+                    mNode, indexType, &enableType, sizeof(enableType));
+            CHECK_EQ(err, (status_t)OK);
+
+            LOGV("Thumbnail mode enabled.");
+        }
+#endif
 
         if (mIsEncoder) {
             setVideoInputFormat(mMIME, meta);
@@ -694,6 +1042,24 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             if (err != OK) {
                 return err;
             }
+
+#ifdef QCOM_HARDWARE
+            if (mUseArbitraryMode) {
+                CODEC_LOGI("Decoder should be in arbitrary mode");
+                // Is it required to set OMX_QCOM_FramePacking_Arbitrary ??
+            }
+            else{
+                CODEC_LOGI("Enable frame by frame mode");
+                OMX_QCOM_PARAM_PORTDEFINITIONTYPE portFmt;
+                portFmt.nPortIndex = kPortIndexInput;
+                portFmt.nFramePackingFormat = OMX_QCOM_FramePacking_OnlyOneCompleteFrame;
+                err = mOMX->setParameter(
+                        mNode, (OMX_INDEXTYPE)OMX_QcomIndexPortDefn, (void *)&portFmt, sizeof(portFmt));
+                if(err != OK) {
+                    LOGW("Failed to set frame packing format on component");
+                }
+            }
+#endif
         }
     }
 
@@ -732,7 +1098,27 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     }
 
     initOutputFormat(meta);
-
+#ifdef QCOM_HARDWARE
+    if ((!strncasecmp(mMIME, "audio/", 6)) && (!strncmp(mComponentName, "OMX.qcom.", 9))) {
+        OMX_PARAM_SUSPENSIONPOLICYTYPE suspensionPolicy;
+        // Suspension policy for the OMX component to honor the Power collapse (TCXO shutdown)
+        // Whenever there is a power collapse, OMX component releases the hardware
+        // resources and hence enabling TCXO shutdown, reducing power consumption.
+        // Return value is ignored, since this is not mandated for all the OMX components.
+        memset(&suspensionPolicy,0,sizeof(suspensionPolicy));
+        suspensionPolicy.ePolicy = OMX_SuspensionEnabled;
+
+        status_t err = mOMX->setParameter(mNode,
+            OMX_IndexParamSuspensionPolicy, &suspensionPolicy, sizeof(suspensionPolicy));
+        if ( err != OMX_ErrorNone ) {
+            CODEC_LOGV("OMXCodec::configureCodec Problem setting suspension"
+                "policy parameters in output port ");
+        } else {
+            CODEC_LOGV("OMXCodec::configureCodec SUCCESS setting suspension "
+                "policy parameters in output port ");
+        }
+    }
+#endif
     if ((mFlags & kClientNeedsFramebuffer)
             && !strncmp(mComponentName, "OMX.SEC.", 8)) {
         OMX_INDEXTYPE index;
@@ -875,6 +1261,12 @@ status_t OMXCodec::setVideoPortFormatType(
     return err;
 }
 
+#ifdef SAMSUNG_CODEC_SUPPORT
+#define ALIGN_TO_8KB(x)   ((((x) + (1 << 13) - 1) >> 13) << 13)
+#define ALIGN_TO_32B(x)   ((((x) + (1 <<  5) - 1) >>  5) <<  5)
+#define ALIGN_TO_128B(x)  ((((x) + (1 <<  7) - 1) >>  7) <<  7)
+#define ALIGN(x, a)       (((x) + (a) - 1) & ~((a) - 1))
+#endif
 static size_t getFrameSize(
         OMX_COLOR_FORMATTYPE colorFormat, int32_t width, int32_t height) {
     switch (colorFormat) {
@@ -894,8 +1286,26 @@ static size_t getFrameSize(
         * this part in the future
         */
         case OMX_COLOR_FormatAndroidOpaque:
+#ifdef SAMSUNG_CODEC_SUPPORT
+    case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
+    case OMX_SEC_COLOR_FormatNV12LPhysicalAddress:
+#endif
             return (width * height * 3) / 2;
 
+#ifdef QCOM_LEGACY_OMX
+    case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
+        return (((width + 15) & -16) * ((height + 15) & -16) * 3) / 2;
+#endif
+
+#ifdef SAMSUNG_CODEC_SUPPORT
+    case OMX_SEC_COLOR_FormatNV12LVirtualAddress:
+        return ALIGN((ALIGN(width, 16) * ALIGN(height, 16)), 2048) + ALIGN((ALIGN(width, 16) * ALIGN(height >> 1, 8)), 2048);
+
+    case OMX_SEC_COLOR_FormatNV12Tiled:
+        static unsigned int frameBufferYSise = ALIGN_TO_8KB(ALIGN_TO_128B(width) * ALIGN_TO_32B(height));
+        static unsigned int frameBufferUVSise = ALIGN_TO_8KB(ALIGN_TO_128B(width) * ALIGN_TO_32B(height/2));
+        return (frameBufferYSise + frameBufferUVSise);
+#endif
         default:
             CHECK(!"Should not be here. Unsupported color format.");
             break;
@@ -964,15 +1374,28 @@ void OMXCodec::setVideoInputFormat(
         const char *mime, const sp<MetaData>& meta) {
 
     int32_t width, height, frameRate, bitRate, stride, sliceHeight;
+#ifdef QCOM_HARDWARE
+    int32_t hfr = 0, hfrRatio = 0;
+#endif
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
     success = success && meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyStride, &stride);
     success = success && meta->findInt32(kKeySliceHeight, &sliceHeight);
+    CODEC_LOGI("setVideoInputFormat width=%ld, height=%ld", width, height);
+#ifdef QCOM_HARDWARE
+    meta->findInt32(kKeyHFR, &hfr);
+#endif
     CHECK(success);
     CHECK(stride != 0);
 
+#ifdef QCOM_HARDWARE
+    hfrRatio = hfr/frameRate;
+    frameRate = hfr?hfr:frameRate;
+    bitRate = hfr ? (hfrRatio*bitRate) : bitRate;
+#endif
+
     OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingAVC;
@@ -980,6 +1403,16 @@ void OMXCodec::setVideoInputFormat(
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
+#ifdef QCOM_HARDWARE
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)){
+        compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)){
+        compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)){
+        compressionFormat= (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)){
+        compressionFormat = OMX_VIDEO_CodingWMV;
+#endif
     } else {
         LOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -1004,8 +1437,16 @@ void OMXCodec::setVideoInputFormat(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
 
+#ifdef QCOM_HARDWARE
+    if(strncmp(mComponentName, "OMX.qcom", 8) != 0) {
+        def.nBufferSize = getFrameSize(colorFormat,
+                stride > 0? stride: -stride, sliceHeight);
+    }
+#else
     def.nBufferSize = getFrameSize(colorFormat,
             stride > 0? stride: -stride, sliceHeight);
+#endif
+
 
     CHECK_EQ((int)def.eDomain, (int)OMX_PortDomainVideo);
 
@@ -1036,7 +1477,11 @@ void OMXCodec::setVideoInputFormat(
 
     video_def->nFrameWidth = width;
     video_def->nFrameHeight = height;
+#ifdef QCOM_HARDWARE
+    video_def->xFramerate = (frameRate << 16);
+#else
     video_def->xFramerate = 0;      // No need for output port
+#endif
     video_def->nBitrate = bitRate;  // Q16 format
     video_def->eCompressionFormat = compressionFormat;
     video_def->eColorFormat = OMX_COLOR_FormatUnused;
@@ -1124,7 +1569,13 @@ status_t OMXCodec::setupBitRate(int32_t bitRate) {
             &bitrateType, sizeof(bitrateType));
     CHECK_EQ(err, (status_t)OK);
 
+#ifdef SAMSUNG_CODEC_SUPPORT
+    // Samsung codecs ignore the bitrate if we don't explicitly
+    // tell them that we want a constant bitrate.
+    bitrateType.eControlRate = OMX_Video_ControlRateConstant;
+#else
     bitrateType.eControlRate = OMX_Video_ControlRateVariable;
+#endif
     bitrateType.nTargetBitrate = bitRate;
 
     err = mOMX->setParameter(
@@ -1174,6 +1625,8 @@ status_t OMXCodec::getVideoProfileLevel(
             // via OMX_SetParameter call.
             profileLevel.mProfile = profile;
             profileLevel.mLevel = level;
+            CODEC_LOGV("profile: %d, level %d is supported",
+                       profile, level);
             return OK;
         }
     }
@@ -1185,9 +1638,15 @@ status_t OMXCodec::getVideoProfileLevel(
 
 status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
     int32_t iFramesInterval, frameRate, bitRate;
+#ifdef QCOM_HARDWARE
+    int32_t hfr = 0, hfrRatio = 0;
+#endif
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
     success = success && meta->findInt32(kKeyIFramesInterval, &iFramesInterval);
+#ifdef QCOM_HARDWARE
+    meta->findInt32(kKeyHFR, &hfr);
+#endif
     CHECK(success);
     OMX_VIDEO_PARAM_H263TYPE h263type;
     InitOMXParams(&h263type);
@@ -1197,10 +1656,16 @@ status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
             mNode, OMX_IndexParamVideoH263, &h263type, sizeof(h263type));
     CHECK_EQ(err, (status_t)OK);
 
+#ifdef QCOM_HARDWARE
+    hfrRatio = hfr ? hfr/frameRate : 1;
+
+    frameRate = hfr ? hfr : frameRate;
+    bitRate = hfr ? (hfrRatio*bitRate) : bitRate;
+    h263type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate / hfrRatio);
+#endif
     h263type.nAllowedPictureTypes =
         OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP;
 
-    h263type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate);
     if (h263type.nPFrames == 0) {
         h263type.nAllowedPictureTypes = OMX_VIDEO_PictureTypeI;
     }
@@ -1232,9 +1697,15 @@ status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
 
 status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
     int32_t iFramesInterval, frameRate, bitRate;
+#ifdef QCOM_HARDWARE
+    int32_t hfr = 0, hfrRatio = 0;
+#endif
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
     success = success && meta->findInt32(kKeyIFramesInterval, &iFramesInterval);
+#ifdef QCOM_HARDWARE
+    meta->findInt32(kKeyHFR, &hfr);
+#endif
     CHECK(success);
     OMX_VIDEO_PARAM_MPEG4TYPE mpeg4type;
     InitOMXParams(&mpeg4type);
@@ -1251,7 +1722,14 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
     mpeg4type.nAllowedPictureTypes =
         OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP;
 
+#ifdef QCOM_HARDWARE
+    hfrRatio = hfr ? hfr/frameRate : 1;
+    frameRate = hfr ? hfr : frameRate;
+    bitRate = hfr ? (hfrRatio*bitRate) : bitRate;
+    mpeg4type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate / hfrRatio);
+#else
     mpeg4type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate);
+#endif
     if (mpeg4type.nPFrames == 0) {
         mpeg4type.nAllowedPictureTypes = OMX_VIDEO_PictureTypeI;
     }
@@ -1272,6 +1750,15 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
     mpeg4type.eProfile = static_cast<OMX_VIDEO_MPEG4PROFILETYPE>(profileLevel.mProfile);
     mpeg4type.eLevel = static_cast<OMX_VIDEO_MPEG4LEVELTYPE>(profileLevel.mLevel);
 
+#ifdef QCOM_HARDWARE
+    if (mpeg4type.eProfile > OMX_VIDEO_MPEG4ProfileSimple) {
+        mpeg4type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
+        mpeg4type.nBFrames = 1;
+        mpeg4type.nPFrames = mpeg4type.nPFrames / 2;
+        mNumBFrames = 1;
+    }
+#endif
+
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoMpeg4, &mpeg4type, sizeof(mpeg4type));
     CHECK_EQ(err, (status_t)OK);
@@ -1284,9 +1771,16 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
 
 status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
     int32_t iFramesInterval, frameRate, bitRate;
+#ifdef QCOM_HARDWARE
+    int32_t hfr = 0, hfrRatio = 0;
+#endif
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyFrameRate, &frameRate);
     success = success && meta->findInt32(kKeyIFramesInterval, &iFramesInterval);
+#ifdef QCOM_HARDWARE
+    meta->findInt32(kKeyHFR, &hfr);
+    success = success && meta->findInt32(kKeyHFR, &hfr);
+#endif
     CHECK(success);
 
     OMX_VIDEO_PARAM_AVCTYPE h264type;
@@ -1309,6 +1803,12 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
     h264type.eProfile = static_cast<OMX_VIDEO_AVCPROFILETYPE>(profileLevel.mProfile);
     h264type.eLevel = static_cast<OMX_VIDEO_AVCLEVELTYPE>(profileLevel.mLevel);
 
+#ifdef QCOM_HARDWARE
+    hfrRatio = hfr ? hfr/frameRate : 1;
+    frameRate = hfr ? hfr : frameRate;
+    bitRate = hfr ? (hfrRatio*bitRate) : bitRate;
+#endif
+
     // FIXME:
     // Remove the workaround after the work in done.
     if (!strncmp(mComponentName, "OMX.TI.DUCATI1", 14)) {
@@ -1320,7 +1820,11 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
         h264type.bUseHadamard = OMX_TRUE;
         h264type.nRefFrames = 1;
         h264type.nBFrames = 0;
+#ifdef QCOM_HARDWARE
+        h264type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate / hfrRatio);
+#else
         h264type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate);
+#endif
         if (h264type.nPFrames == 0) {
             h264type.nAllowedPictureTypes = OMX_VIDEO_PictureTypeI;
         }
@@ -1334,6 +1838,15 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
         h264type.nCabacInitIdc = 0;
     }
 
+#ifdef QCOM_HARDWARE
+    if (h264type.eProfile > OMX_VIDEO_AVCProfileBaseline) {
+        h264type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate / hfrRatio);
+        h264type.nBFrames = 1;
+        h264type.nPFrames = h264type.nPFrames / 2;
+        mNumBFrames = 1;
+    }
+#endif
+
     if (h264type.nBFrames != 0) {
         h264type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
     }
@@ -1374,6 +1887,16 @@ status_t OMXCodec::setVideoOutputFormat(
         compressionFormat = OMX_VIDEO_CodingVPX;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG2;
+#ifdef QCOM_HARDWARE
+    } else if(!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if(!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX311, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if(!strcasecmp(MEDIA_MIMETYPE_VIDEO_DIVX4, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime)){
+        compressionFormat = OMX_VIDEO_CodingWMV;
+#endif
     } else {
         LOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -1391,8 +1914,22 @@ status_t OMXCodec::setVideoOutputFormat(
         OMX_VIDEO_PARAM_PORTFORMATTYPE format;
         InitOMXParams(&format);
         format.nPortIndex = kPortIndexOutput;
+#if defined(QCOM_HARDWARE) && !defined(QCOM_LEGACY_OMX)
+        if (!strncmp(mComponentName, "OMX.qcom",8)) {
+            int32_t reqdColorFormat = ColorFormatInfo::getPreferredColorFormat(mOMXLivesLocally);
+            for(format.nIndex = 0;
+                    (OK == mOMX->getParameter(mNode, OMX_IndexParamVideoPortFormat, &format, sizeof(format)));
+                    format.nIndex++) {
+                if(format.eColorFormat == reqdColorFormat)
+                    break;
+            }
+        } else
+#endif
         format.nIndex = 0;
 
+        CODEC_LOGV("Video O/P format.nIndex 0x%x",format.nIndex);
+        CODEC_LOGE("Video O/P format.eColorFormat 0x%x",format.eColorFormat);
+
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
                 &format, sizeof(format));
@@ -1403,7 +1940,23 @@ status_t OMXCodec::setVideoOutputFormat(
                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
                || format.eColorFormat == OMX_COLOR_FormatCbYCrY
                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
-               || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar);
+               || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+#ifdef QCOM_HARDWARE
+               || format.eColorFormat == QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
+#endif
+#ifdef SAMSUNG_CODEC_SUPPORT
+               || format.eColorFormat == OMX_SEC_COLOR_FormatNV12TPhysicalAddress
+               || format.eColorFormat == OMX_SEC_COLOR_FormatNV12Tiled
+#endif
+               );
+#ifdef SAMSUNG_CODEC_SUPPORT
+        if (!strncmp("OMX.SEC.", mComponentName, 8)) {
+            if (mNativeWindow == NULL)
+                format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
+            else
+                format.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+        }
+#endif
 
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
@@ -1426,8 +1979,9 @@ status_t OMXCodec::setVideoOutputFormat(
 
     CHECK_EQ(err, (status_t)OK);
 
-#if 1
-    // XXX Need a (much) better heuristic to compute input buffer sizes.
+#ifdef EXYNOS4210_ENHANCEMENTS
+    const size_t X = 64 * 8 * 1024;  // const size_t X = 64 * 1024;
+#else
     const size_t X = 64 * 1024;
     if (def.nBufferSize < X) {
         def.nBufferSize = X;
@@ -1502,9 +2056,21 @@ OMXCodec::OMXCodec(
       mOutputPortSettingsChangedPending(false),
       mLeftOverBuffer(NULL),
       mPaused(false),
+#ifdef QCOM_HARDWARE
+      bInvalidState(false),
+      mInterlaceFormatDetected(false),
+      mSPSParsed(false),
+      mThumbnailMode(false),
+      mNumBFrames(0),
+      mUseArbitraryMode(true),
+#endif
       mNativeWindow(
               (!strncmp(componentName, "OMX.google.", 11)
-              || !strcmp(componentName, "OMX.Nvidia.mpeg2v.decode"))
+              || !strcmp(componentName, "OMX.Nvidia.mpeg2v.decode")
+#ifdef QCOM_LEGACY_OMX
+              || !strncmp(componentName, "OMX.qcom",8)
+#endif
+      )
                         ? NULL : nativeWindow) {
     mPortStatus[kPortIndexInput] = ENABLED;
     mPortStatus[kPortIndexOutput] = ENABLED;
@@ -1539,12 +2105,26 @@ void OMXCodec::setComponentRole(
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
             "audio_decoder.vorbis", "audio_encoder.vorbis" },
+#ifdef QCOM_HARDWARE
+        { MEDIA_MIMETYPE_AUDIO_EVRC,
+            "audio_decoder.evrchw", "audio_encoder.evrc" },
+        { MEDIA_MIMETYPE_AUDIO_QCELP,
+            "audio_decoder,qcelp13Hw", "audio_encoder.qcelp13" },
+#endif
         { MEDIA_MIMETYPE_VIDEO_AVC,
             "video_decoder.avc", "video_encoder.avc" },
         { MEDIA_MIMETYPE_VIDEO_MPEG4,
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
+#ifdef QCOM_HARDWARE
+        { MEDIA_MIMETYPE_VIDEO_DIVX,
+            "video_decoder.divx", NULL },
+        { MEDIA_MIMETYPE_AUDIO_AC3,
+            "audio_decoder.ac3", NULL },
+        { MEDIA_MIMETYPE_VIDEO_DIVX311,
+            "video_decoder.divx", NULL },
+#endif
     };
 
     static const size_t kNumMimeToRole =
@@ -1622,6 +2202,10 @@ status_t OMXCodec::init() {
 
     err = allocateBuffers();
     if (err != (status_t)OK) {
+#ifdef QCOM_HARDWARE
+        CODEC_LOGE("Allocate Buffer failed - error = %d", err);
+        setState(ERROR);
+#endif
         return err;
     }
 
@@ -1645,6 +2229,10 @@ bool OMXCodec::isIntermediateState(State state) {
         || state == IDLE_TO_EXECUTING
         || state == EXECUTING_TO_IDLE
         || state == IDLE_TO_LOADED
+#ifdef QCOM_HARDWARE
+        || state == PAUSING
+        || state == FLUSHING
+#endif
         || state == RECONFIGURING;
 }
 
@@ -1669,14 +2257,17 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     }
 
     status_t err = OK;
+#ifndef QCOM_LEGACY_OMX
     if ((mFlags & kStoreMetaDataInVideoBuffers)
             && portIndex == kPortIndexInput) {
+        LOGW("Trying to enable metadata mode on encoder");
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
         if (err != OK) {
             LOGE("Storing meta data in video buffers is not supported");
             return err;
         }
     }
+#endif
 
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
@@ -1689,6 +2280,26 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         return err;
     }
 
+#if defined(QCOM_HARDWARE) && !defined(QCOM_LEGACY_OMX)
+    if (mFlags & kUseMinBufferCount) {
+        def.nBufferCountActual = def.nBufferCountMin;
+        if (!mIsEncoder) {
+                if (portIndex == kPortIndexOutput) {
+                    def.nBufferCountActual += 2;
+                }else {
+                    def.nBufferCountActual += 1;
+                }
+        }
+        err = mOMX->setParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        if (err != OK) {
+            CODEC_LOGE("setting nBufferCountActual to %lu failed: %d",
+                    def.nBufferCountActual, err);
+            return err;
+        }
+    }
+#endif
+
     CODEC_LOGV("allocating %lu buffers of size %lu on %s port",
             def.nBufferCountActual, def.nBufferSize,
             portIndex == kPortIndexInput ? "input" : "output");
@@ -1703,6 +2314,8 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         BufferInfo info;
         info.mData = NULL;
         info.mSize = def.nBufferSize;
+        info.mAllocatedBuffer = NULL;
+        info.mAllocatedSize = 0;
 
         IOMX::buffer_id buffer;
         if (portIndex == kPortIndexInput
@@ -1735,7 +2348,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         }
 
         if (err != OK) {
-            LOGE("allocate_buffer_with_backup failed");
+            CODEC_LOGE("allocate_buffer_with_backup failed");
             return err;
         }
 
@@ -1842,18 +2455,75 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+#ifdef QCOM_HARDWARE
+    int format = (def.format.video.eColorFormat ==
+                  QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka)?
+                 HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED : def.format.video.eColorFormat;
+    if(def.format.video.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar)
+        format = HAL_PIXEL_FORMAT_YCrCb_420_SP;
+
+    format ^= (mInterlaceFormatDetected ? HAL_PIXEL_FORMAT_INTERLACE : 0);
+#endif
+
+#ifndef SAMSUNG_CODEC_SUPPORT
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
+#ifdef QCOM_HARDWARE
+            def.format.video.nStride,
+            def.format.video.nSliceHeight,
+            format);
+#else
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
             def.format.video.eColorFormat);
+#endif
+#else
+    OMX_COLOR_FORMATTYPE eColorFormat;
 
+    switch (def.format.video.eColorFormat) {
+    case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
+        eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_SP_TILED;
+        break;
+    case OMX_COLOR_FormatYUV420SemiPlanar:
+        eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
+        break;
+    case OMX_COLOR_FormatYUV420Planar:
+    default:
+        eColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
+        break;
+    }
+
+    err = native_window_set_buffers_geometry(
+            mNativeWindow.get(),
+            def.format.video.nFrameWidth,
+            def.format.video.nFrameHeight,
+            eColorFormat);
+#endif
     if (err != 0) {
         LOGE("native_window_set_buffers_geometry failed: %s (%d)",
                 strerror(-err), -err);
         return err;
     }
 
+#ifdef QCOM_HARDWARE
+    // Crop the native window to the proper display resolution
+    int32_t left, top, right, bottom;
+    CHECK(mOutputFormat->findRect(
+                kKeyCropRect,
+                &left, &top, &right, &bottom));
+
+    android_native_rect_t crop;
+    crop.left = left;
+    crop.top = top;
+    crop.right = right + 1;
+    crop.bottom = bottom + 1;
+
+    err = native_window_set_crop(mNativeWindow.get(), &crop);
+    if (err != OK) {
+        LOGE("native_window_set_crop failed: %s (%d)", strerror(-err), -err);
+    }
+#endif
+
     err = applyRotation();
     if (err != OK) {
         return err;
@@ -1891,8 +2561,13 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     }
 
     LOGV("native_window_set_usage usage=0x%lx", usage);
+#ifndef SAMSUNG_CODEC_SUPPORT
     err = native_window_set_usage(
             mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
+#else
+    err = native_window_set_usage(
+            mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP | GRALLOC_USAGE_HW_FIMC1 | GRALLOC_USAGE_HWC_HWOVERLAY);
+#endif
     if (err != 0) {
         LOGE("native_window_set_usage failed: %s (%d)", strerror(-err), -err);
         return err;
@@ -1930,6 +2605,16 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
+#ifdef QCOM_HARDWARE
+    err = mNativeWindow.get()->perform(mNativeWindow.get(),
+                             NATIVE_WINDOW_SET_BUFFERS_SIZE, def.nBufferSize);
+    if (err != 0) {
+        LOGE("native_window_set_buffers_size failed: %s (%d)", strerror(-err),
+                -err);
+        return err;
+    }
+#endif
+
     CODEC_LOGV("allocating %lu buffers from a native window of size %lu on "
             "output port", def.nBufferCountActual, def.nBufferSize);
 
@@ -1942,12 +2627,23 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
             break;
         }
 
+#ifdef QCOM_HARDWARE
+        private_handle_t *handle = (private_handle_t *)buf->handle;
+        if(!handle) {
+                LOGE("Native Buffer handle is NULL");
+                break;
+        }
+        CHECK_EQ(def.nBufferSize, handle->size); //otherwise it might cause memory corruption issues. It may fail because of alignment or extradata.
+#endif
+
         sp<GraphicBuffer> graphicBuffer(new GraphicBuffer(buf, false));
         BufferInfo info;
         info.mData = NULL;
         info.mSize = def.nBufferSize;
         info.mStatus = OWNED_BY_US;
         info.mMem = NULL;
+        info.mAllocatedBuffer = NULL;
+        info.mAllocatedSize = 0;
         info.mMediaBuffer = new MediaBuffer(graphicBuffer);
         info.mMediaBuffer->setObserver(this);
         mPortBuffers[kPortIndexOutput].push(info);
@@ -1980,9 +2676,13 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         cancelEnd = def.nBufferCountActual;
     }
 
-    for (OMX_U32 i = cancelStart; i < cancelEnd; i++) {
-        BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(i);
-        cancelBufferToNativeWindow(info);
+    if (err != 0) {
+        freeBuffersOnPort(kPortIndexOutput);
+    } else {
+        for (OMX_U32 i = cancelStart; i < cancelEnd; i++) {
+            BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(i);
+            cancelBufferToNativeWindow(info);
+        }
     }
 
     return err;
@@ -2195,7 +2895,9 @@ int64_t OMXCodec::retrieveDecodingTimeUs(bool isCodecSpecific) {
     CHECK(mIsEncoder);
 
     if (mDecodingTimeList.empty()) {
+#ifndef QCOM_HARDWARE
         CHECK(mSignalledEOS || mNoMoreOutputData);
+#endif
         // No corresponding input frame available.
         // This could happen when EOS is reached.
         return 0;
@@ -2213,7 +2915,7 @@ int64_t OMXCodec::retrieveDecodingTimeUs(bool isCodecSpecific) {
 }
 
 void OMXCodec::on_message(const omx_message &msg) {
-    if (mState == ERROR) {
+    if (mState == ERROR && !strncmp(mComponentName, "OMX.google.", 11)) {
         LOGW("Dropping OMX message - we're in ERROR state.");
         return;
     }
@@ -2248,6 +2950,13 @@ void OMXCodec::on_message(const omx_message &msg) {
 
             BufferInfo* info = &buffers->editItemAt(i);
             info->mStatus = OWNED_BY_US;
+#ifdef QCOM_HARDWARE
+            if ((mState == ERROR)  && (bInvalidState == true)) {
+              CODEC_LOGV("mState ERROR, freeing i/p buffer %p", buffer);
+              status_t err = freeBuffer(kPortIndexInput, i);
+              CHECK_EQ(err, (status_t)OK);
+            }
+#endif
 
             // Buffer could not be released until empty buffer done is called.
             if (info->mMediaBuffer != NULL) {
@@ -2307,6 +3016,13 @@ void OMXCodec::on_message(const omx_message &msg) {
             }
 
             info->mStatus = OWNED_BY_US;
+#ifdef QCOM_HARDWARE
+            if ((mState == ERROR) && (bInvalidState == true)) {
+              CODEC_LOGV("mState ERROR, freeing o/p buffer %p", buffer);
+              status_t err = freeBuffer(kPortIndexOutput, i);
+              CHECK_EQ(err, (status_t)OK);
+            }
+#endif
 
             if (mPortStatus[kPortIndexOutput] == DISABLING) {
                 CODEC_LOGV("Port is disabled, freeing buffer %p", buffer);
@@ -2389,6 +3105,9 @@ void OMXCodec::on_message(const omx_message &msg) {
 
                 if (mIsEncoder) {
                     int64_t decodingTimeUs = retrieveDecodingTimeUs(isCodecSpecific);
+                    CODEC_LOGV("kkeyTime = %lld, kKeyDecodingTime = %lld, ctts = %lld",
+                               msg.u.extended_buffer_data.timestamp, decodingTimeUs,
+                               msg.u.extended_buffer_data.timestamp - decodingTimeUs);
                     buffer->meta_data()->setInt64(kKeyDecodingTime, decodingTimeUs);
                 }
 
@@ -2521,6 +3240,13 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
         case OMX_EventError:
         {
             CODEC_LOGE("ERROR(0x%08lx, %ld)", data1, data2);
+#ifdef QCOM_HARDWARE
+            if (data1 == OMX_ErrorInvalidState) {
+                bInvalidState = true;
+                mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
+                mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
+            }
+#endif
 
             setState(ERROR);
             break;
@@ -2587,7 +3313,19 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
             }
             break;
         }
-
+#ifdef QCOM_HARDWARE
+        case OMX_EventIndexsettingChanged:
+        {
+            OMX_INTERLACETYPE format = (OMX_INTERLACETYPE)data1;
+            if (format == OMX_InterlaceInterleaveFrameTopFieldFirst ||
+                format == OMX_InterlaceInterleaveFrameBottomFieldFirst)
+            {
+                mInterlaceFormatDetected = true;
+                LOGW("Interlace detected");
+            }
+            break;
+        }
+#endif
 #if 0
         case OMX_EventBufferFlag:
         {
@@ -2682,11 +3420,23 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
 
             CODEC_LOGV("FLUSH_DONE(%ld)", portIndex);
 
+#ifdef QCOM_HARDWARE
+            if (portIndex == -1) {
+                CHECK_EQ((int)mPortStatus[kPortIndexInput], (int)SHUTTING_DOWN);
+                mPortStatus[kPortIndexInput] = ENABLED;
+
+                CHECK_EQ((int)mPortStatus[kPortIndexOutput], (int)SHUTTING_DOWN);
+                mPortStatus[kPortIndexOutput] = ENABLED;
+            } else {
+#endif
             CHECK_EQ((int)mPortStatus[portIndex], (int)SHUTTING_DOWN);
             mPortStatus[portIndex] = ENABLED;
 
             CHECK_EQ(countBuffersWeOwn(mPortBuffers[portIndex]),
                      mPortBuffers[portIndex].size());
+#ifdef QCOM_HARDWARE
+            }
+#endif
 
             if (mState == RECONFIGURING) {
                 CHECK_EQ(portIndex, (OMX_U32)kPortIndexOutput);
@@ -2779,14 +3529,33 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
                 mPortStatus[kPortIndexInput] = ENABLED;
                 mPortStatus[kPortIndexOutput] = ENABLED;
 
-                if ((mFlags & kEnableGrallocUsageProtected) &&
-                        mNativeWindow != NULL) {
-                    // We push enough 1x1 blank buffers to ensure that one of
-                    // them has made it to the display.  This allows the OMX
-                    // component teardown to zero out any protected buffers
-                    // without the risk of scanning out one of those buffers.
-                    pushBlankBuffersToNativeWindow();
+#ifdef QCOM_HARDWARE
+                if (mNativeWindow != NULL) {
+                    /*
+                     * reset buffer size field with SurfaceTexture
+                     * back to 0. This will ensure proper size
+                     * buffers are allocated if the same SurfaceTexture
+                     * is re-used in a different decode session
+                     */
+                    int err =
+                        mNativeWindow.get()->perform(mNativeWindow.get(),
+                                                     NATIVE_WINDOW_SET_BUFFERS_SIZE,
+                                                     0);
+                    if (err != 0) {
+                        LOGE("set_buffers_size failed: %s (%d)", strerror(-err),
+                             -err);
+                    }
+#endif
+                    if (mFlags & kEnableGrallocUsageProtected) {
+                        // We push enough 1x1 blank buffers to ensure that one of
+                        // them has made it to the display.  This allows the OMX
+                        // component teardown to zero out any protected buffers
+                        // without the risk of scanning out one of those buffers.
+                        pushBlankBuffersToNativeWindow();
+                    }
+#ifdef QCOM_HARDWARE
                 }
+#endif
 
                 setState(IDLE_TO_LOADED);
             }
@@ -2813,6 +3582,9 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
 
         case OMX_StateLoaded:
         {
+            if (mState == ERROR)
+                CODEC_LOGE("We are in error state, should have been in idle->loaded");
+
             CHECK_EQ((int)mState, (int)IDLE_TO_LOADED);
 
             CODEC_LOGV("Now Loaded.");
@@ -2820,7 +3592,17 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
             setState(LOADED);
             break;
         }
+#ifdef QCOM_HARDWARE
+        case OMX_StatePause:
+        {
+           CODEC_LOGV("Now paused.");
 
+           CHECK_EQ(mState, PAUSING);
+
+           setState(PAUSED);
+           break;
+        }
+#endif
         case OMX_StateInvalid:
         {
             setState(ERROR);
@@ -2883,6 +3665,12 @@ status_t OMXCodec::freeBuffer(OMX_U32 portIndex, size_t bufIndex) {
 
     BufferInfo *info = &buffers->editItemAt(bufIndex);
 
+    if (info->mAllocatedBuffer != NULL) {
+        OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *) info->mBuffer;
+        header->pBuffer = info->mAllocatedBuffer;
+        header->nAllocLen = info->mAllocatedSize;
+    }
+
     status_t err = mOMX->freeBuffer(mNode, portIndex, info->mBuffer);
 
     if (err == OK && info->mMediaBuffer != NULL) {
@@ -2905,6 +3693,13 @@ status_t OMXCodec::freeBuffer(OMX_U32 portIndex, size_t bufIndex) {
     if (err == OK) {
         buffers->removeAt(bufIndex);
     }
+#ifdef QCOM_HARDWARE
+    else {
+        LOGW("Warning, free Buffer failed, to be freed later"
+             " returning OK to prevent crash..");
+        return OK;
+    }
+#endif
 
     return err;
 }
@@ -2935,8 +3730,17 @@ void OMXCodec::onPortSettingsChanged(OMX_U32 portIndex) {
 
 bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
     CHECK(mState == EXECUTING || mState == RECONFIGURING
+#ifdef QCOM_HARDWARE
+            || mState == EXECUTING_TO_IDLE || mState == FLUSHING);
+#else
             || mState == EXECUTING_TO_IDLE);
-
+#endif
+#ifdef QCOM_HARDWARE
+    if ( portIndex == -1 ) {
+        mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
+        mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
+    } else {
+#endif
     CODEC_LOGV("flushPortAsync(%ld): we own %d out of %d buffers already.",
          portIndex, countBuffersWeOwn(mPortBuffers[portIndex]),
          mPortBuffers[portIndex].size());
@@ -2951,6 +3755,9 @@ bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
         // flush-complete event in this case.
 
         return false;
+#ifdef QCOM_HARDWARE
+        }
+#endif
     }
 
     status_t err =
@@ -2985,22 +3792,37 @@ status_t OMXCodec::enablePortAsync(OMX_U32 portIndex) {
 }
 
 void OMXCodec::fillOutputBuffers() {
+#ifdef QCOM_HARDWARE
+    CHECK(mState == EXECUTING || mState == FLUSHING);
+#else
     CHECK_EQ((int)mState, (int)EXECUTING);
+#endif
 
     // This is a workaround for some decoders not properly reporting
     // end-of-output-stream. If we own all input buffers and also own
     // all output buffers and we already signalled end-of-input-stream,
     // the end-of-output-stream is implied.
-    if (mSignalledEOS
+
+#ifdef QCOM_HARDWARE
+    // NOTE: Thumbnail mode needs a call to fillOutputBuffer in order
+    // to get the decoded frame from the component. Currently,
+    // thumbnail mode calls emptyBuffer with an EOS flag on its first
+    // frame and sets mSignalledEOS to true, so without the check for
+    // !mThumbnailMode, fillOutputBuffer will never be called.
+    if (!mThumbnailMode) {
+#endif
+        if (mSignalledEOS
             && countBuffersWeOwn(mPortBuffers[kPortIndexInput])
                 == mPortBuffers[kPortIndexInput].size()
             && countBuffersWeOwn(mPortBuffers[kPortIndexOutput])
                 == mPortBuffers[kPortIndexOutput].size()) {
-        mNoMoreOutputData = true;
-        mBufferFilled.signal();
-
-        return;
+            mNoMoreOutputData = true;
+            mBufferFilled.signal();
+            return;
+        }
+#ifdef QCOM_HARDWARE
     }
+#endif
 
     Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexOutput];
     for (size_t i = 0; i < buffers->size(); ++i) {
@@ -3012,7 +3834,11 @@ void OMXCodec::fillOutputBuffers() {
 }
 
 void OMXCodec::drainInputBuffers() {
+#ifdef QCOM_HARDWARE
+    CHECK(mState == EXECUTING || mState == RECONFIGURING || mState == FLUSHING);
+#else
     CHECK(mState == EXECUTING || mState == RECONFIGURING);
+#endif
 
     if (mFlags & kUseSecureInputBuffers) {
         Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
@@ -3023,6 +3849,9 @@ void OMXCodec::drainInputBuffers() {
             }
         }
     } else {
+#ifdef QCOM_HARDWARE
+        size_t CAMERA_BUFFERS = 4;
+#endif
         Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
         for (size_t i = 0; i < buffers->size(); ++i) {
             BufferInfo *info = &buffers->editItemAt(i);
@@ -3031,11 +3860,19 @@ void OMXCodec::drainInputBuffers() {
                 continue;
             }
 
+#ifdef QCOM_HARDWARE
+            if(mIsEncoder && (i == CAMERA_BUFFERS))
+                break;
+#endif
+
             if (!drainInputBuffer(info)) {
                 break;
             }
 
             if (mFlags & kOnlySubmitOneInputBufferAtOneTime) {
+#ifdef QCOM_HARDWARE
+                if (i == mNumBFrames)
+#endif
                 break;
             }
         }
@@ -3177,6 +4014,12 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
             err = mSource->read(&srcBuffer);
         }
 
+#ifdef QCOM_HARDWARE
+        if (err == ERROR_CORRUPT_NAL) {
+            LOGW("Ignore Corrupt NAL");
+            continue;
+        } else 
+#endif
         if (err != OK) {
             signalEOS = true;
             mFinalStatus = err;
@@ -3217,10 +4060,18 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
             OMX_BUFFERHEADERTYPE *header =
                 (OMX_BUFFERHEADERTYPE *)info->mBuffer;
 
+            //not commenting this one for now. XXX - remove when memcopy can be avoided
+            //for encoder
             CHECK(header->pBuffer == info->mData);
 
+            if (info->mAllocatedBuffer == NULL) {
+                info->mAllocatedBuffer = header->pBuffer;
+                info->mAllocatedSize = header->nAllocLen;
+            }
+
             header->pBuffer =
                 (OMX_U8 *)srcBuffer->data() + srcBuffer->range_offset();
+            header->nAllocLen = srcBuffer->size() - srcBuffer->range_offset();
 
             releaseBuffer = false;
             info->mMediaBuffer = srcBuffer;
@@ -3238,11 +4089,47 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
                 CHECK(info->mMediaBuffer == NULL);
                 info->mMediaBuffer = srcBuffer;
             } else {
+#ifndef SAMSUNG_CODEC_SUPPORT
                 CHECK(srcBuffer->data() != NULL) ;
                 memcpy((uint8_t *)info->mData + offset,
                         (const uint8_t *)srcBuffer->data()
                             + srcBuffer->range_offset(),
                         srcBuffer->range_length());
+#else
+                OMX_PARAM_PORTDEFINITIONTYPE def;
+                InitOMXParams(&def);
+                def.nPortIndex = kPortIndexInput;
+
+                status_t err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,
+                                                  &def, sizeof(def));
+                CHECK_EQ(err, (status_t)OK);
+
+                if (def.eDomain == OMX_PortDomainVideo) {
+                    OMX_VIDEO_PORTDEFINITIONTYPE *videoDef = &def.format.video;
+                    switch (videoDef->eColorFormat) {
+                    case OMX_SEC_COLOR_FormatNV12LVirtualAddress: {
+                        CHECK(srcBuffer->data() != NULL);
+                        void *pSharedMem = (void *)(srcBuffer->data());
+                        memcpy((uint8_t *)info->mData + offset,
+                                (const void *)&pSharedMem, sizeof(void *));
+                        break;
+                    }
+                    default:
+                        CHECK(srcBuffer->data() != NULL);
+                        memcpy((uint8_t *)info->mData + offset,
+                                (const uint8_t *)srcBuffer->data()
+                                    + srcBuffer->range_offset(),
+                                srcBuffer->range_length());
+                        break;
+                    }
+                } else {
+                    CHECK(srcBuffer->data() != NULL);
+                    memcpy((uint8_t *)info->mData + offset,
+                            (const uint8_t *)srcBuffer->data()
+                                + srcBuffer->range_offset(),
+                            srcBuffer->range_length());
+                }
+#endif
             }
         }
 
@@ -3250,6 +4137,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         CHECK(srcBuffer->meta_data()->findInt64(kKeyTime, &lastBufferTimeUs));
         CHECK(lastBufferTimeUs >= 0);
         if (mIsEncoder) {
+            CODEC_LOGV("pushing %lld to mDecodingTimeList", lastBufferTimeUs);
             mDecodingTimeList.push_back(lastBufferTimeUs);
         }
 
@@ -3303,6 +4191,18 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     if (signalEOS) {
         flags |= OMX_BUFFERFLAG_EOS;
+#ifdef QCOM_HARDWARE
+    } else if (mThumbnailMode) {
+        // Because we don't get an EOS after getting the first frame, we
+        // need to notify the component with OMX_BUFFERFLAG_EOS, set
+        // mNoMoreOutputData to false so fillOutputBuffer gets called on
+        // the first output buffer (see comment in fillOutputBuffer), and
+        // mSignalledEOS must be true so drainInputBuffer is not executed
+        // on extra frames.
+        flags |= OMX_BUFFERFLAG_EOS;
+        mNoMoreOutputData = false;
+        mSignalledEOS = true;
+#endif
     } else {
         mNoMoreOutputData = false;
     }
@@ -3440,6 +4340,9 @@ void OMXCodec::setRawAudioFormat(
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
+#ifdef QCOM_HARDWARE
+    def.format.audio.cMIMEType = NULL;
+#endif
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
@@ -3640,6 +4543,182 @@ status_t OMXCodec::setAACFormat(int32_t numChannels, int32_t sampleRate, int32_t
     return OK;
 }
 
+#ifdef QCOM_HARDWARE
+void OMXCodec::setAC3Format(int32_t /*numChannels*/, int32_t /*sampleRate*/) {
+/*
+    QOMX_AUDIO_PARAM_AC3TYPE profileAC3;
+    QOMX_AUDIO_PARAM_AC3PP profileAC3PP;
+    OMX_INDEXTYPE indexTypeAC3;
+    OMX_INDEXTYPE indexTypeAC3PP;
+    OMX_PARAM_PORTDEFINITIONTYPE portParam;
+
+    //configure input port
+    InitOMXParams(&portParam);
+    portParam.nPortIndex = 0;
+    status_t err = mOMX->getParameter(
+       mNode, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, OK);
+
+    portParam.nBufferSize = 2*4096;
+    err = mOMX->setParameter(
+       mNode, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, OK);
+
+    //configure output port
+    portParam.nPortIndex = 1;
+    err = mOMX->getParameter(
+       mNode, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, OK);
+    portParam.nBufferSize = 20*4096;
+    err = mOMX->setParameter(
+       mNode, OMX_IndexParamPortDefinition, &portParam, sizeof(portParam));
+    CHECK_EQ(err, OK);
+
+    err = mOMX->getExtensionIndex(mNode, OMX_QCOM_INDEX_PARAM_AC3TYPE, &indexTypeAC3);
+
+    InitOMXParams(&profileAC3);
+    profileAC3.nPortIndex = kPortIndexInput;
+    err = mOMX->getParameter(mNode, indexTypeAC3, &profileAC3, sizeof(profileAC3));
+    CHECK_EQ(err, OK);
+
+    profileAC3.nSamplingRate  =  sampleRate;
+    profileAC3.nChannels      =  2;
+    profileAC3.eChannelConfig =  OMX_AUDIO_AC3_CHANNEL_CONFIG_2_0;
+
+    LOGE("numChannels = %d, profileAC3.nChannels = %d", numChannels, profileAC3.nChannels);
+
+    err = mOMX->setParameter(mNode, indexTypeAC3, &profileAC3, sizeof(profileAC3));
+    CHECK_EQ(err, OK);
+
+    //for output port
+    OMX_AUDIO_PARAM_PCMMODETYPE profilePcm;
+    InitOMXParams(&profilePcm);
+    profilePcm.nPortIndex = kPortIndexOutput;
+    err = mOMX->getParameter(mNode, OMX_IndexParamAudioPcm, &profilePcm, sizeof(profilePcm));
+    profilePcm.nSamplingRate  =  sampleRate;
+    err = mOMX->setParameter(mNode, OMX_IndexParamAudioPcm, &profilePcm, sizeof(profilePcm));
+    LOGE("for output port profileAC3.nSamplingRate = %d", profileAC3.nSamplingRate);
+
+    mOMX->getExtensionIndex(mNode, OMX_QCOM_INDEX_PARAM_AC3PP, &indexTypeAC3PP);
+
+    InitOMXParams(&profileAC3PP);
+    profileAC3PP.nPortIndex = kPortIndexInput;
+    err = mOMX->getParameter(mNode, indexTypeAC3PP, &profileAC3PP, sizeof(profileAC3PP));
+    CHECK_EQ(err, OK);
+
+    int i;
+    int channel_routing[6];
+
+    for (i=0; i<6; i++) {
+        channel_routing[i] = -1;
+    }
+    for (i=0; i<6; i++) {
+        profileAC3PP.eChannelRouting[i] =  (OMX_AUDIO_AC3_CHANNEL_ROUTING)channel_routing[i];
+    }
+    profileAC3PP.eChannelRouting[0] =  OMX_AUDIO_AC3_CHANNEL_LEFT;
+    profileAC3PP.eChannelRouting[1] =  OMX_AUDIO_AC3_CHANNEL_RIGHT;
+    err = mOMX->setParameter(mNode, indexTypeAC3PP, &profileAC3PP, sizeof(profileAC3PP));
+    CHECK_EQ(err, OK);
+*/
+}
+
+
+status_t OMXCodec::setWMAFormat(const sp<MetaData> &meta)
+	{
+	    if (mIsEncoder) {
+	        CODEC_LOGE("WMA encoding not supported");
+	        return OK;
+	    } else {
+	        int32_t version;
+	        OMX_AUDIO_PARAM_WMATYPE paramWMA;
+	        QOMX_AUDIO_PARAM_WMA10PROTYPE paramWMA10;
+	        CHECK(meta->findInt32(kKeyWMAVersion, &version));
+	        int32_t numChannels;
+	        int32_t bitRate;
+	        int32_t sampleRate;
+	        int32_t encodeOptions;
+	        int32_t blockAlign;
+	        int32_t bitspersample;
+	        int32_t formattag;
+	        int32_t advencopt1;
+	        int32_t advencopt2;
+	        int32_t VirtualPktSize;
+        if(version==kTypeWMAPro || version==kTypeWMALossLess) {
+	           CHECK(meta->findInt32(kKeyWMABitspersample, &bitspersample));
+	           CHECK(meta->findInt32(kKeyWMAFormatTag, &formattag));
+	           CHECK(meta->findInt32(kKeyWMAAdvEncOpt1,&advencopt1));
+	           CHECK(meta->findInt32(kKeyWMAAdvEncOpt2,&advencopt2));
+	           CHECK(meta->findInt32(kKeyWMAVirPktSize,&VirtualPktSize));
+	        }
+	        if(version==kTypeWMA) {
+	           InitOMXParams(&paramWMA);
+	           paramWMA.nPortIndex = kPortIndexInput;
+        } else if(version==kTypeWMAPro || version==kTypeWMALossLess) {
+	           InitOMXParams(&paramWMA10);
+	           paramWMA10.nPortIndex = kPortIndexInput;
+	        }
+	        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
+	        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
+	        CHECK(meta->findInt32(kKeyBitRate, &bitRate));
+	        CHECK(meta->findInt32(kKeyWMAEncodeOpt, &encodeOptions));
+	        CHECK(meta->findInt32(kKeyWMABlockAlign, &blockAlign));
+	        CODEC_LOGV("Channels: %d, SampleRate: %d, BitRate; %d"
+	                   "EncodeOptions: %d, blockAlign: %d", numChannels,
+	                   sampleRate, bitRate, encodeOptions, blockAlign);
+	        if(sampleRate>48000 || numChannels>2)
+	        {
+	           LOGE("Unsupported samplerate/channels");
+	           return ERROR_UNSUPPORTED;
+	        }
+        if(version==kTypeWMAPro || version==kTypeWMALossLess)
+	        {
+	           CODEC_LOGV("Bitspersample: %d, wmaformattag: %d,"
+	                      "advencopt1: %d, advencopt2: %d VirtualPktSize %d", bitspersample,
+	                      formattag, advencopt1, advencopt2, VirtualPktSize);
+	        }
+	        status_t err = OK;
+	        OMX_INDEXTYPE index;
+	        if(version==kTypeWMA) {
+	           err = mOMX->getParameter(
+	                   mNode, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+        } else if(version==kTypeWMAPro || version==kTypeWMALossLess) {
+	           mOMX->getExtensionIndex(mNode,"OMX.Qualcomm.index.audio.wma10Pro",&index);
+	           err = mOMX->getParameter(
+	                   mNode, index, &paramWMA10, sizeof(paramWMA10));
+	        }
+	        CHECK_EQ(err, (status_t)OK);
+	        if(version==kTypeWMA) {
+	           paramWMA.nChannels = numChannels;
+	           paramWMA.nSamplingRate = sampleRate;
+	           paramWMA.nEncodeOptions = encodeOptions;
+	           paramWMA.nBitRate = bitRate;
+	           paramWMA.nBlockAlign = blockAlign;
+        } else if(version==kTypeWMAPro || version==kTypeWMALossLess) {
+	           paramWMA10.nChannels = numChannels;
+	           paramWMA10.nSamplingRate = sampleRate;
+	           paramWMA10.nEncodeOptions = encodeOptions;
+	           paramWMA10.nBitRate = bitRate;
+	           paramWMA10.nBlockAlign = blockAlign;
+	        }
+        if(version==kTypeWMAPro || version==kTypeWMALossLess) {
+	           paramWMA10.advancedEncodeOpt = advencopt1;
+	           paramWMA10.advancedEncodeOpt2 = advencopt2;
+	           paramWMA10.formatTag = formattag;
+	           paramWMA10.validBitsPerSample = bitspersample;
+	           paramWMA10.nVirtualPktSize = VirtualPktSize;
+	        }
+	        if(version==kTypeWMA) {
+	           err = mOMX->setParameter(
+	                   mNode, OMX_IndexParamAudioWma, &paramWMA, sizeof(paramWMA));
+        } else if(version==kTypeWMAPro || version==kTypeWMALossLess) {
+	           err = mOMX->setParameter(
+	                   mNode, index, &paramWMA10, sizeof(paramWMA10));
+	        }
+	        return err;
+	    }
+	}
+#endif
+
 void OMXCodec::setG711Format(int32_t numChannels) {
     CHECK(!mIsEncoder);
     setRawAudioFormat(kPortIndexInput, 8000, numChannels);
@@ -3647,7 +4726,7 @@ void OMXCodec::setG711Format(int32_t numChannels) {
 
 void OMXCodec::setImageOutputFormat(
         OMX_COLOR_FORMATTYPE format, OMX_U32 width, OMX_U32 height) {
-    CODEC_LOGV("setImageOutputFormat(%ld, %ld)", width, height);
+    CODEC_LOGE("setImageOutputFormat(%ld, %ld)", width, height);
 
 #if 0
     OMX_INDEXTYPE index;
@@ -3761,8 +4840,32 @@ void OMXCodec::clearCodecSpecificData() {
 }
 
 status_t OMXCodec::start(MetaData *meta) {
+    CODEC_LOGV("OMXCodec::start ");
     Mutex::Autolock autoLock(mLock);
 
+#ifdef QCOM_HARDWARE
+    if(mPaused) {
+        if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
+            while (isIntermediateState(mState)) {
+                mAsyncCompletion.wait(mLock);
+            }
+            CHECK_EQ(mState, (status_t)PAUSED);
+            status_t err = mOMX->sendCommand(mNode,
+            OMX_CommandStateSet, OMX_StateExecuting);
+            CHECK_EQ(err, (status_t)OK);
+            setState(IDLE_TO_EXECUTING);
+            mPaused = false;
+            while (mState != EXECUTING && mState != ERROR) {
+                mAsyncCompletion.wait(mLock);
+            }
+            drainInputBuffers();
+            return mState == ERROR ? UNKNOWN_ERROR : OK;
+        } else {   // SW Codec
+            mPaused = false;
+            return OK;
+        }
+    }
+#endif
     if (mState != LOADED) {
         return UNKNOWN_ERROR;
     }
@@ -3815,17 +4918,68 @@ status_t OMXCodec::stop() {
 
         case ERROR:
         {
+            CODEC_LOGE("in error state, check omx il state and decide whether to free or skip");
+
             OMX_STATETYPE state = OMX_StateInvalid;
             status_t err = mOMX->getState(mNode, &state);
             CHECK_EQ(err, (status_t)OK);
 
+#ifdef QCOM_HARDWARE
+            CODEC_LOGE("OMX IL is in state %d", state);
+
+            /* OMX IL spec page 98
+               The call should be performed under the following conditions:
+               . While the component is in the OMX_StateIdle state and the IL client has
+                 already sent a request for the state transition to OMX_StateLoaded
+                 (e.g., during the stopping of the component)
+               . On a disabled port when the component is in the OMX_StateExecuting,
+                 the OMX_StatePause, or the OMX_StateIdle state.
+            */
+
+            bool canFree = true;
+            if (!strncmp(mComponentName, "OMX.qcom.video.decoder.", 23) ||
+                    !strncmp(mComponentName, "OMX.qcom.video.encoder.", 23)) {
+                if (state == OMX_StateInvalid) {
+                    canFree = true;
+                }
+                else if ((state == OMX_StateIdle) && mState == IDLE_TO_LOADED) {
+                    canFree = true;
+                }
+                else if ((state == OMX_StateExecuting || state == OMX_StatePause ||
+                          state == OMX_StateIdle) &&
+                         (mPortStatus[kPortIndexOutput] == DISABLED ||
+                          mPortStatus[kPortIndexOutput] == DISABLING)) {
+                    canFree = true;
+                }
+                else
+                    canFree = false;
+            }
+
+            if (canFree) {
+                err = freeBuffersOnPort(kPortIndexOutput, true);
+                CHECK_EQ(err, (status_t)OK);
+            }
+            else {
+                LOGW("%s IL component does not match conditions for free, skip freeing for later",
+                     mComponentName);
+            }
+#endif
+
             if (state != OMX_StateExecuting) {
                 break;
             }
+#ifdef QCOM_HARDWARE
+            else {
+                CODEC_LOGV("Component is still in executing state, fall through and move component"
+                           " to idle");
+            }
+#endif
             // else fall through to the idling code
             isError = true;
         }
-
+#ifdef QCOM_HARDWARE
+        case PAUSED:
+#endif
         case EXECUTING:
         {
             setState(EXECUTING_TO_IDLE);
@@ -3833,7 +4987,18 @@ status_t OMXCodec::stop() {
             if (mQuirks & kRequiresFlushBeforeShutdown) {
                 CODEC_LOGV("This component requires a flush before transitioning "
                      "from EXECUTING to IDLE...");
+#ifdef QCOM_HARDWARE
+            //DSP supports flushing of ports simultaneously. Flushing individual port is not supported.
+
+                if(mQuirks & kRequiresGlobalFlush) {
+                  bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
 
+                  if (emulateFlushCompletion) {
+                    onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
+                  }
+                }
+                else {
+#endif
                 bool emulateInputFlushCompletion =
                     !flushPortAsync(kPortIndexInput);
 
@@ -3847,6 +5012,9 @@ status_t OMXCodec::stop() {
                 if (emulateOutputFlushCompletion) {
                     onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
                 }
+#ifdef QCOM_HARDWARE
+               }
+#endif
             } else {
                 mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
                 mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
@@ -3957,6 +5125,17 @@ status_t OMXCodec::read(
         mFilledBuffers.clear();
 
         CHECK_EQ((int)mState, (int)EXECUTING);
+#ifdef QCOM_HARDWARE
+        setState(FLUSHING);
+        //DSP supports flushing of ports simultaneously. Flushing individual port is not supported.
+
+        if(mQuirks & kRequiresGlobalFlush) {
+          bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
+          if (emulateFlushCompletion) {
+              onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
+          }
+        } else {
+#endif
 
         bool emulateInputFlushCompletion = !flushPortAsync(kPortIndexInput);
         bool emulateOutputFlushCompletion = !flushPortAsync(kPortIndexOutput);
@@ -3968,6 +5147,9 @@ status_t OMXCodec::read(
         if (emulateOutputFlushCompletion) {
             onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
         }
+#ifdef QCOM_HARDWARE
+        }
+#endif
 
         while (mSeekTimeUs >= 0) {
             if ((err = waitForBufferFilled_l()) != OK) {
@@ -3985,7 +5167,12 @@ status_t OMXCodec::read(
     if (mState == ERROR) {
         return UNKNOWN_ERROR;
     }
-
+#ifdef QCOM_HARDWARE
+    if(seeking) {
+        CHECK_EQ((int)mState, (int)FLUSHING);
+        setState(EXECUTING);
+    }
+#endif
     if (mFilledBuffers.empty()) {
         return mSignalledEOS ? mFinalStatus : ERROR_END_OF_STREAM;
     }
@@ -4130,9 +5317,36 @@ static const char *colorFormatString(OMX_COLOR_FORMATTYPE type) {
 
     if (type == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar) {
         return "OMX_TI_COLOR_FormatYUV420PackedSemiPlanar";
-    } else if (type == OMX_QCOM_COLOR_FormatYVU420SemiPlanar) {
+	}
+#ifdef SAMSUNG_CODEC_SUPPORT
+    if (type == OMX_SEC_COLOR_FormatNV12TPhysicalAddress) {
+        return "OMX_SEC_COLOR_FormatNV12TPhysicalAddress";
+    }
+    if (type == OMX_SEC_COLOR_FormatNV12LPhysicalAddress) {
+        return "OMX_SEC_COLOR_FormatNV12LPhysicalAddress";
+    }
+    if (type == OMX_SEC_COLOR_FormatNV12LVirtualAddress) {
+        return "OMX_SEC_COLOR_FormatNV12LVirtualAddress";
+    }
+    if (type == OMX_SEC_COLOR_FormatNV12Tiled) {
+        return "OMX_SEC_COLOR_FormatNV12Tiled";
+    }
+#endif
+    else if (type == OMX_QCOM_COLOR_FormatYVU420SemiPlanar) {
         return "OMX_QCOM_COLOR_FormatYVU420SemiPlanar";
+#ifdef QCOM_HARDWARE
+    } else if (type == QOMX_COLOR_FormatYVU420PackedSemiPlanar32m4ka) {
+        return "QOMX_COLOR_FormatYVU420PackedSemiPlanar32m4ka";
+    } else if (type == QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka) {
+        return "QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka";
+    }
+    /*else if (type ==  OMX_QCOM_COLOR_FormatYVU420SemiPlanarInterlace) {
+        return "OMX_QCOM_COLOR_FormatYVU420SemiPlanarInterlace";
+    } */
+    else if (type < 0 || (size_t)type >= numNames) {
+#else
     } else if (type < 0 || (size_t)type >= numNames) {
+#endif
         return "UNKNOWN";
     } else {
         return kNames[type];
@@ -4527,6 +5741,28 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setInt32(kKeyChannelCount, numChannels);
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
                 mOutputFormat->setInt32(kKeyBitRate, bitRate);
+#ifdef QCOM_HARDWARE
+            } else if (audio_def->eEncoding == OMX_AUDIO_CodingQCELP13 ) {
+                mOutputFormat->setCString(
+                        kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_QCELP);
+                int32_t numChannels, sampleRate, bitRate;
+                inputFormat->findInt32(kKeyChannelCount, &numChannels);
+                inputFormat->findInt32(kKeySampleRate, &sampleRate);
+                inputFormat->findInt32(kKeyBitRate, &bitRate);
+                mOutputFormat->setInt32(kKeyChannelCount, numChannels);
+                mOutputFormat->setInt32(kKeySampleRate, sampleRate);
+                mOutputFormat->setInt32(kKeyBitRate, bitRate);
+            } else if (audio_def->eEncoding == OMX_AUDIO_CodingEVRC ) {
+                mOutputFormat->setCString(
+                        kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_EVRC);
+                int32_t numChannels, sampleRate, bitRate;
+                inputFormat->findInt32(kKeyChannelCount, &numChannels);
+                inputFormat->findInt32(kKeySampleRate, &sampleRate);
+                inputFormat->findInt32(kKeyBitRate, &bitRate);
+                mOutputFormat->setInt32(kKeyChannelCount, numChannels);
+                mOutputFormat->setInt32(kKeySampleRate, sampleRate);
+                mOutputFormat->setInt32(kKeyBitRate, bitRate);
+#endif
             } else {
                 CHECK(!"Should not be here. Unknown audio encoding.");
             }
@@ -4555,6 +5791,12 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
 
             mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
             mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);
+#ifdef QCOM_LEGACY_OMX
+            // With legacy codec we get wrong color format here
+            if (!strncmp(mComponentName, "OMX.qcom.", 9))
+                mOutputFormat->setInt32(kKeyColorFormat, OMX_QCOM_COLOR_FormatYVU420SemiPlanar);
+            else
+#endif
             mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
 
             if (!mIsEncoder) {
@@ -4571,6 +5813,13 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                         video_def->nFrameWidth, video_def->nFrameHeight);
 
                 if (err == OK) {
+#ifdef SAMSUNG_CODEC_SUPPORT
+                    /* Hack GetConfig */
+                    rect.nLeft = 0;
+                    rect.nTop = 0;
+                    rect.nWidth = video_def->nFrameWidth;
+                    rect.nHeight = video_def->nFrameHeight;
+#endif
                     CHECK_GE(rect.nLeft, 0);
                     CHECK_GE(rect.nTop, 0);
                     CHECK_GE(rect.nWidth, 0u);
@@ -4599,6 +5848,22 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 if (mNativeWindow != NULL) {
                      initNativeWindowCrop();
                 }
+#ifdef QCOM_HARDWARE
+            } else {
+                int32_t width, height;
+                bool success = inputFormat->findInt32(kKeyWidth, &width) &&
+                               inputFormat->findInt32(kKeyHeight, &height);
+                CHECK(success);
+                int32_t frameRate = 0, hfr = 0;
+
+                success = inputFormat->findInt32(kKeyHFR, &hfr);
+                success = inputFormat->findInt32(kKeyFrameRate, &frameRate);
+
+                mOutputFormat->setInt32(kKeyWidth, width);
+                mOutputFormat->setInt32(kKeyHeight, height);
+                mOutputFormat->setInt32(kKeyHFR, hfr);
+                mOutputFormat->setInt32(kKeyFrameRate, frameRate);
+#endif
             }
             break;
         }
@@ -4620,12 +5885,44 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
 }
 
 status_t OMXCodec::pause() {
-    Mutex::Autolock autoLock(mLock);
-
-    mPaused = true;
+   CODEC_LOGV("pause mState=%d", mState);
+
+   Mutex::Autolock autoLock(mLock);
+#ifdef QCOM_HARDWARE
+   if (mState != EXECUTING) {
+       return UNKNOWN_ERROR;
+   }
+
+   while (isIntermediateState(mState)) {
+       mAsyncCompletion.wait(mLock);
+   }
+   if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
+       status_t err = mOMX->sendCommand(mNode,
+           OMX_CommandStateSet, OMX_StatePause);
+       CHECK_EQ(err, (status_t)OK);
+       setState(PAUSING);
+
+       mPaused = true;
+       while (mState != PAUSED && mState != ERROR) {
+           mAsyncCompletion.wait(mLock);
+       }
+       return mState == ERROR ? UNKNOWN_ERROR : OK;
+   } else {
+#endif
+       mPaused = true;
+       return OK;
+#ifdef QCOM_HARDWARE
+   }
+#endif
 
-    return OK;
 }
+#ifdef QCOM_HARDWARE
+void OMXCodec::parseFlags(uint32_t flags) {
+    //TODO - uncomment if needed
+    //    mGPUComposition = ((flags & kEnableGPUComposition) ? true : false);
+    mThumbnailMode = ((flags & kEnableThumbnailMode) ? true : false);
+}
+#endif
 
 ////////////////////////////////////////////////////////////////////////////////
 
@@ -4724,4 +6021,106 @@ void OMXCodec::restorePatchedDataPointer(BufferInfo *info) {
     header->pBuffer = (OMX_U8 *)info->mData;
 }
 
+#ifdef QCOM_HARDWARE
+void OMXCodec::setEVRCFormat(int32_t numChannels, int32_t sampleRate, int32_t bitRate) {
+    if (mIsEncoder) {
+      CHECK(numChannels == 1);
+        //////////////// input port ////////////////////
+        setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+        //////////////// output port ////////////////////
+        // format
+        OMX_AUDIO_PARAM_PORTFORMATTYPE format;
+        format.nPortIndex = kPortIndexOutput;
+        format.nIndex = 0;
+        status_t err = OMX_ErrorNone;
+        while (OMX_ErrorNone == err) {
+            CHECK_EQ(mOMX->getParameter(mNode, OMX_IndexParamAudioPortFormat,
+                    &format, sizeof(format)), (status_t)OK);
+            if (format.eEncoding == OMX_AUDIO_CodingEVRC) {
+                break;
+            }
+            format.nIndex++;
+        }
+        CHECK_EQ((status_t)OK, err);
+        CHECK_EQ(mOMX->setParameter(mNode, OMX_IndexParamAudioPortFormat,
+                &format, sizeof(format)), (status_t)OK);
+
+        // port definition
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+        def.format.audio.cMIMEType = NULL;
+        CHECK_EQ(mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+        def.format.audio.bFlagErrorConcealment = OMX_TRUE;
+        def.format.audio.eEncoding = OMX_AUDIO_CodingEVRC;
+        CHECK_EQ(mOMX->setParameter(mNode, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+
+        // profile
+        OMX_AUDIO_PARAM_EVRCTYPE profile;
+        InitOMXParams(&profile);
+        profile.nPortIndex = kPortIndexOutput;
+        CHECK_EQ(mOMX->getParameter(mNode, OMX_IndexParamAudioEvrc,
+                &profile, sizeof(profile)), (status_t)OK);
+        profile.nChannels = numChannels;
+        CHECK_EQ(mOMX->setParameter(mNode, OMX_IndexParamAudioEvrc,
+                &profile, sizeof(profile)), (status_t)OK);
+    }
+    else{
+      LOGI("EVRC decoder \n");
+    }
+}
+
+void OMXCodec::setQCELPFormat(int32_t numChannels, int32_t sampleRate, int32_t bitRate) {
+    if (mIsEncoder) {
+        CHECK(numChannels == 1);
+        //////////////// input port ////////////////////
+        setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
+        //////////////// output port ////////////////////
+        // format
+        OMX_AUDIO_PARAM_PORTFORMATTYPE format;
+        format.nPortIndex = kPortIndexOutput;
+        format.nIndex = 0;
+        status_t err = OMX_ErrorNone;
+        while (OMX_ErrorNone == err) {
+            CHECK_EQ(mOMX->getParameter(mNode, OMX_IndexParamAudioPortFormat,
+                    &format, sizeof(format)), (status_t)OK);
+            if (format.eEncoding == OMX_AUDIO_CodingQCELP13) {
+                break;
+            }
+            format.nIndex++;
+        }
+        CHECK_EQ((status_t)OK, err);
+        CHECK_EQ(mOMX->setParameter(mNode, OMX_IndexParamAudioPortFormat,
+                &format, sizeof(format)), (status_t)OK);
+
+        // port definition
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+        def.format.audio.cMIMEType = NULL;
+        CHECK_EQ(mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+        def.format.audio.bFlagErrorConcealment = OMX_TRUE;
+        def.format.audio.eEncoding = OMX_AUDIO_CodingQCELP13;
+        CHECK_EQ(mOMX->setParameter(mNode, OMX_IndexParamPortDefinition,
+                &def, sizeof(def)), (status_t)OK);
+
+        // profile
+        OMX_AUDIO_PARAM_QCELP13TYPE profile;
+        InitOMXParams(&profile);
+        profile.nPortIndex = kPortIndexOutput;
+        CHECK_EQ(mOMX->getParameter(mNode, OMX_IndexParamAudioQcelp13,
+                &profile, sizeof(profile)), (status_t)OK);
+        profile.nChannels = numChannels;
+        CHECK_EQ(mOMX->setParameter(mNode, OMX_IndexParamAudioQcelp13,
+                &profile, sizeof(profile)), (status_t)OK);
+    }
+    else{
+      LOGI("QCELP decoder \n");
+    }
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/OggExtractor.cpp b/media/libstagefright/OggExtractor.cpp
index 29e6907..01e3e98 100644
--- a/media/libstagefright/OggExtractor.cpp
+++ b/media/libstagefright/OggExtractor.cpp
@@ -1019,7 +1019,7 @@ bool SniffOgg(
     }
 
     mimeType->setTo(MEDIA_MIMETYPE_CONTAINER_OGG);
-    *confidence = 0.2f;
+    *confidence = 0.6f;
 
     return true;
 }
diff --git a/media/libstagefright/SampleIterator.cpp b/media/libstagefright/SampleIterator.cpp
index c7b00b1..85c2ccd 100644
--- a/media/libstagefright/SampleIterator.cpp
+++ b/media/libstagefright/SampleIterator.cpp
@@ -307,7 +307,7 @@ status_t SampleIterator::findSampleTime(
 
     *time = mTTSSampleTime + mTTSDuration * (sampleIndex - mTTSSampleIndex);
 
-    *time += mTable->getCompositionTimeOffset(sampleIndex);
+    *time = (int64_t)(*time) + (int32_t)mTable->getCompositionTimeOffset(sampleIndex);
 
     return OK;
 }
diff --git a/media/libstagefright/SampleTable.cpp b/media/libstagefright/SampleTable.cpp
index bf31947..d664078 100644
--- a/media/libstagefright/SampleTable.cpp
+++ b/media/libstagefright/SampleTable.cpp
@@ -360,8 +360,9 @@ status_t SampleTable::setCompositionTimeToSampleParams(
         return ERROR_IO;
     }
 
-    if (U32_AT(header) != 0) {
-        // Expected version = 0, flags = 0.
+    if (U32_AT(header) != 0 &&
+        U32_AT(header) != 0x01000000) { //version 1 (1 byte), flags (3 bytes)
+        // Expected version = 0 or 1, flags = 0.
         return ERROR_MALFORMED;
     }
 
@@ -502,7 +503,7 @@ void SampleTable::buildSampleEntriesTable() {
 
                 mSampleTimeEntries[sampleIndex].mSampleIndex = sampleIndex;
 
-                uint32_t compTimeDelta =
+                int32_t compTimeDelta = (int32_t)
                     mCompositionDeltaLookup->getCompositionTimeOffset(
                             sampleIndex);
 
@@ -814,5 +815,9 @@ uint32_t SampleTable::getCompositionTimeOffset(uint32_t sampleIndex) {
     return mCompositionDeltaLookup->getCompositionTimeOffset(sampleIndex);
 }
 
+uint32_t SampleTable::getNumSyncSamples()
+{
+    return mNumSyncSamples;
+}
 }  // namespace android
 
diff --git a/media/libstagefright/StagefrightMediaScanner.cpp b/media/libstagefright/StagefrightMediaScanner.cpp
old mode 100644
new mode 100755
index 2505096..a5c3da9
--- a/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/media/libstagefright/StagefrightMediaScanner.cpp
@@ -37,8 +37,12 @@ static bool FileHasAcceptableExtension(const char *extension) {
         ".mp3", ".mp4", ".m4a", ".3gp", ".3gpp", ".3g2", ".3gpp2",
         ".mpeg", ".ogg", ".mid", ".smf", ".imy", ".wma", ".aac",
         ".wav", ".amr", ".midi", ".xmf", ".rtttl", ".rtx", ".ota",
-        ".mkv", ".mka", ".webm", ".ts", ".fl", ".flac", ".mxmf",
-        ".avi", ".mpeg", ".mpg"
+        ".mkv", ".mka", ".webm", ".ts", ".fl", ".flac", ".mxmf", ".mpg",
+#ifdef QCOM_HARDWARE
+        ".avi"
+#else
+        ".qcp"
+#endif
     };
     static const size_t kNumValidExtensions =
         sizeof(kValidExtensions) / sizeof(kValidExtensions[0]);
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
old mode 100644
new mode 100755
index 4491c97..9b09bd1
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2011 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -247,9 +248,15 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
 
     ColorConverter converter(
             (OMX_COLOR_FORMATTYPE)srcFormat, OMX_COLOR_Format16bitRGB565);
+
+#ifdef QCOM_HARDWARE
+    if (converter.isValid()) {
+        err = converter.convert(
+#else
     CHECK(converter.isValid());
 
     err = converter.convert(
+#endif
             (const uint8_t *)buffer->data() + buffer->range_offset(),
             width, height,
             crop_left, crop_top, crop_right, crop_bottom,
@@ -257,6 +264,12 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
             frame->mWidth,
             frame->mHeight,
             0, 0, frame->mWidth - 1, frame->mHeight - 1);
+#ifdef QCOM_HARDWARE
+    }
+    else {
+        err = ERROR_UNSUPPORTED;
+    }
+#endif
 
     buffer->release();
     buffer = NULL;
@@ -335,19 +348,39 @@ VideoFrame *StagefrightMetadataRetriever::getFrameAtTime(
         memcpy(mAlbumArt->mData, data, dataSize);
     }
 
+#ifdef QCOM_HARDWARE
+    const char *mime;
+    bool success = trackMeta->findCString(kKeyMIMEType, &mime);
+    CHECK(success);
+    VideoFrame *frame = NULL;
+
+    if ((!strcmp(mime, MEDIA_MIMETYPE_VIDEO_DIVX))||
+            (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_DIVX311))||
+            (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_DIVX4))||
+            (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_WMV)))
+    {
+        LOGV("Software codec is not being used for %s clips for thumbnail ",
+            mime);
+    } else {
+        frame = extractVideoFrameWithCodecFlags(
+#else
     VideoFrame *frame =
         extractVideoFrameWithCodecFlags(
+#endif
                 &mClient, trackMeta, source, OMXCodec::kPreferSoftwareCodecs,
                 timeUs, option);
+#ifdef QCOM_HARDWARE
+    }
+#endif
 
+#if defined(TARGET8x60) || !defined(QCOM_HARDWARE)
     if (frame == NULL) {
         LOGV("Software decoder failed to extract thumbnail, "
              "trying hardware decoder.");
-
-        frame = extractVideoFrameWithCodecFlags(&mClient, trackMeta, source, 0,
+            frame = extractVideoFrameWithCodecFlags(&mClient, trackMeta, source, 0,
                         timeUs, option);
     }
-
+#endif
     return frame;
 }
 
@@ -528,7 +561,13 @@ void StagefrightMetadataRetriever::parseMetaData() {
 
     if (numTracks == 1) {
         const char *fileMIME;
+#ifdef QCOM_HARDWARE
+        sp<MetaData> trackmeta = mExtractor->getTrackMetaData(0);
+        CHECK(trackmeta->findCString(kKeyMIMEType, &fileMIME));
+#else
         CHECK(meta->findCString(kKeyMIMEType, &fileMIME));
+#endif
+
 
         if (!strcasecmp(fileMIME, "video/x-matroska")) {
             sp<MetaData> trackMeta = mExtractor->getTrackMetaData(0);
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 38daf72..5ab507e 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -32,6 +32,11 @@
 #include <utils/Log.h>
 #include <utils/String8.h>
 
+#ifdef QCOM_HARDWARE
+#include <cutils/properties.h>
+#include <gralloc_priv.h>
+#endif
+
 namespace android {
 
 SurfaceMediaSource::SurfaceMediaSource(uint32_t bufW, uint32_t bufH) :
@@ -339,6 +344,22 @@ status_t SurfaceMediaSource::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
             // XXX: This will be changed to USAGE_HW_VIDEO_ENCODER once driver
             // issues with that flag get fixed.
             usage |= GraphicBuffer::USAGE_HW_TEXTURE;
+#ifdef QCOM_HARDWARE
+            char value[PROPERTY_VALUE_MAX] = {0};
+            if (property_get("ro.board.platform", value, "0")) {
+#ifndef CAMERA_MM_HEAP
+                if (!strncmp(value, "msm8660", sizeof("msm8660") - 1)) {
+                    usage |= (GRALLOC_USAGE_PRIVATE_SMI_HEAP |
+                            GRALLOC_USAGE_PRIVATE_UNCACHED);
+                }
+                else
+#endif
+                {
+                    usage |= (GRALLOC_USAGE_PRIVATE_MM_HEAP |
+                            GRALLOC_USAGE_PRIVATE_UNCACHED);
+                }
+            }
+#endif
             status_t error;
             sp<GraphicBuffer> graphicBuffer(
                     mGraphicBufferAlloc->createGraphicBuffer(
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index c563ce6..d5f88e6 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (C) 2011 Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +18,128 @@
 #include <arpa/inet.h>
 
 #include <media/stagefright/Utils.h>
+#ifdef QCOM_HARDWARE
+#include <media/stagefright/MediaDebug.h>
+#define NIDEBUG 0
+#include <utils/Log.h>
+#undef LOG_TAG
+#define LOG_TAG "Utils"
+
+#include <utils/Errors.h>
+
+namespace {
+
+#define STD_MIN(x,y) (((x) < (y)) ? (x) : (y))
+
+  class RbspParser
+  {
+    public:
+      RbspParser(const uint8_t * begin, const uint8_t * end);
+
+      virtual ~ RbspParser();
+
+      uint32_t next();
+      void advance();
+      uint32_t u(uint32_t n);
+      uint32_t ue();
+      int32_t se();
+
+    private:
+      const uint8_t *begin, *end;
+      int32_t pos;
+      uint32_t bit;
+      uint32_t cursor;
+      bool advanceNeeded;
+  };
+
+  RbspParser::RbspParser(const uint8_t * _begin, const uint8_t * _end)
+    :begin(_begin), end(_end), pos(-1), bit(0),
+    cursor(0xFFFFFF), advanceNeeded(true)
+  {
+  }
+
+  // Destructor
+  /*lint -e{1540}  Pointer member neither freed nor zeroed by destructor
+   * No problem
+   */
+  RbspParser::~RbspParser()
+  {
+  }
+
+  // Return next RBSP byte as a word
+  uint32_t RbspParser::next()
+  {
+    if (advanceNeeded)
+      advance();
+    //return static_cast<uint32> (*pos);
+    return static_cast < uint32_t > (begin[pos]);
+  }
+
+  // Advance RBSP decoder to next byte
+  void RbspParser::advance()
+  {
+    ++pos;
+    //if (pos >= stop)
+    if (begin + pos == end) {
+      /*lint -e{730}  Boolean argument to function
+       * I don't see a problem here
+       */
+      //throw false;
+        LOGE("H264Parser-->NEED TO THROW THE EXCEPTION...\n");
+    }
+    cursor <<= 8;
+    //cursor |= static_cast<uint32> (*pos);
+    cursor |= static_cast < uint32_t > (begin[pos]);
+    if ((cursor & 0xFFFFFF) == 0x000003) {
+      advance();
+    }
+    advanceNeeded = false;
+  }
+
+  // Decode unsigned integer
+  uint32_t RbspParser::u(uint32_t n)
+  {
+    uint32_t i, s, x = 0;
+    for (i = 0; i < n; i += s) {
+      s = static_cast < uint32_t > STD_MIN(static_cast < int >(8 - bit),
+          static_cast < int >(n - i));
+      x <<= s;
+
+      x |= ((next() >> ((8 - static_cast < uint32_t > (bit)) - s)) &
+          ((1 << s) - 1));
+
+      bit = (bit + s) % 8;
+      if (!bit) {
+        advanceNeeded = true;
+      }
+    }
+    return x;
+  }
+
+  // Decode unsigned integer Exp-Golomb-coded syntax element
+  uint32_t RbspParser::ue()
+  {
+    int leadingZeroBits = -1;
+    for (uint32_t b = 0; !b; ++leadingZeroBits) {
+      b = u(1);
+    }
+    return ((1 << leadingZeroBits) - 1) +
+      u(static_cast < uint32_t > (leadingZeroBits));
+  }
+
+  // Decode signed integer Exp-Golomb-coded syntax element
+  int32_t RbspParser::se()
+  {
+    const uint32_t x = ue();
+    if (!x)
+      return 0;
+    else if (x & 1)
+      return static_cast < int32_t > ((x >> 1) + 1);
+    else
+      return -static_cast < int32_t > (x >> 1);
+  }
+}
+#endif
 
 namespace android {
 
@@ -53,5 +176,125 @@ uint64_t hton64(uint64_t x) {
     return ((uint64_t)htonl(x & 0xffffffff) << 32) | htonl(x >> 32);
 }
 
+#ifdef QCOM_HARDWARE
+status_t
+parseSps (uint16_t naluSize, const uint8_t *encodedBytes, SpsInfo * info) {
+
+    if(!encodedBytes || naluSize <= 0)
+        return BAD_VALUE;
+
+    uint8_t profile_id = 0;
+    uint8_t level_id = 0;
+    uint8_t tmp = 0;
+    uint32_t id = 0;
+    uint8_t log2MaxFrameNumMinus4 = 0;
+    uint8_t picOrderCntType = 0;
+    uint8_t log2MaxPicOrderCntLsbMinus4 = 0;
+    uint8_t deltaPicOrderAlwaysZeroFlag = 0;
+    uint32_t numRefFramesInPicOrderCntCycle = 0;
+    uint8_t picWidthInMbsMinus1 = 0;
+    uint8_t picHeightInMapUnitsMinus1 = 0;
+    uint8_t frameMbsOnlyFlag = 0;
+    uint8_t cropLeft= 0, cropRight = 0, cropTop = 0, cropBot = 0;
+
+    RbspParser rbsp(&encodedBytes[0],
+                    &encodedBytes[naluSize]);
+    profile_id = rbsp.u(8);
+    tmp = rbsp.u(8);
+    level_id = rbsp.u(8);
+    id = rbsp.ue();
+
+    LOGV("profile_id = %u", profile_id);
+
+    if(100 == profile_id) {
+        tmp = rbsp.ue();
+        if(3 == tmp) {
+            (void)rbsp.u(1);
+        }
+        //bit_depth_luma_minus8
+        (void)rbsp.ue();
+        //bit_depth_chroma_minus8
+        (void)rbsp.ue();
+        //qpprime_y_zero_transform_bypass_flag
+        (void)rbsp.u(1);
+        // seq_scaling_matrix_present_flag
+        tmp = rbsp.u(1);
+        if (tmp) {
+            unsigned int tmp1, t;
+            //seq_scaling_list_present_flag
+            for (t = 0; t < 6; t++) {
+                tmp1 = rbsp.u(1);
+                if (tmp1) {
+                    unsigned int last_scale = 8, next_scale = 8, delta_scale;
+                    for (int j = 0; j < 16; j++)
+                        {
+                            if (next_scale) {
+                                delta_scale = rbsp.se();
+                                next_scale = (last_scale + delta_scale + 256) % 256;
+                            }
+                            last_scale = next_scale?next_scale:last_scale;
+                        }
+                }
+            }
+            for (t = 0; t < 2; t++) {
+                tmp1 = rbsp.u(1);
+                if (tmp1) {
+                    unsigned int last_scale = 8, next_scale = 8, delta_scale;
+                    for (int j = 0; j < 64; j++)
+                        {
+                            if (next_scale) {
+                                delta_scale = rbsp.se();
+                                next_scale = (last_scale + delta_scale + 256) % 256;
+                            }
+                            last_scale = next_scale?next_scale : last_scale;
+                        }
+                }
+            }
+        }
+    }
+
+    log2MaxFrameNumMinus4 = rbsp.ue();
+    picOrderCntType = rbsp.ue();
+    if(0 == picOrderCntType) {
+        log2MaxPicOrderCntLsbMinus4 = rbsp.ue();
+    } else if(1 == picOrderCntType) {
+        deltaPicOrderAlwaysZeroFlag = (rbsp.u(1) == 1);
+        (void)rbsp.se();
+        (void)rbsp.se();
+        numRefFramesInPicOrderCntCycle = rbsp.ue();
+        for (uint32_t i = 0; i < numRefFramesInPicOrderCntCycle; ++i) {
+            (void)rbsp.se();
+        }
+    }
+    info->mNumRefFrames = rbsp.ue();
+    tmp = rbsp.u(1);
+    picWidthInMbsMinus1 = rbsp.ue();
+    picHeightInMapUnitsMinus1 = rbsp.ue();
+    frameMbsOnlyFlag = (rbsp.u(1) == 1);
+    if(!frameMbsOnlyFlag)
+        (void)rbsp.u(1);
+    (void)rbsp.u(1);
+      tmp = rbsp.u(1);
+      cropLeft = 0;
+      cropRight = 0;
+      cropTop = 0;
+      cropBot = 0;
+      if(tmp) {
+          cropLeft = rbsp.ue();
+          cropRight = rbsp.ue();
+          cropTop = rbsp.ue();
+          cropBot = rbsp.ue();
+          LOGV("crop (%d,%d,%d,%d)", cropLeft, cropRight, cropTop, cropBot);
+      }
+      info->mHeightInMBs = (2 - frameMbsOnlyFlag ) * (picHeightInMapUnitsMinus1 + 1);
+      info->mWidthInMBs = picWidthInMbsMinus1 + 1;
+      info->mProfile = profile_id;
+      info->mLevel = level_id;
+      info->mInterlaced = !frameMbsOnlyFlag;
+      LOGV("mInterlaced = 0x%x", info->mInterlaced );
+      return OK;
+}
+#endif
+
 }  // namespace android
 
diff --git a/media/libstagefright/WAVExtractor.cpp b/media/libstagefright/WAVExtractor.cpp
index c406964..e5f4b52 100644
--- a/media/libstagefright/WAVExtractor.cpp
+++ b/media/libstagefright/WAVExtractor.cpp
@@ -435,7 +435,7 @@ bool SniffWAV(
     }
 
     *mimeType = MEDIA_MIMETYPE_CONTAINER_WAV;
-    *confidence = 0.3f;
+    *confidence = 0.6f;
 
     return true;
 }
diff --git a/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp b/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
index 180460b..be59eb1 100644
--- a/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
+++ b/media/libstagefright/chromium_http/ChromiumHTTPDataSource.cpp
@@ -59,6 +59,7 @@ status_t ChromiumHTTPDataSource::connect(
         const char *uri,
         const KeyedVector<String8, String8> *headers,
         off64_t offset) {
+    Mutex::Autolock autoSerializer(mSerializer);
     Mutex::Autolock autoLock(mLock);
 
     uid_t uid;
@@ -127,6 +128,7 @@ void ChromiumHTTPDataSource::onConnectionFailed(status_t err) {
 }
 
 void ChromiumHTTPDataSource::disconnect() {
+    Mutex::Autolock autoSerializer(mSerializer);
     Mutex::Autolock autoLock(mLock);
     disconnect_l();
 }
diff --git a/media/libstagefright/codecs/aacdec/AACDecoder.cpp b/media/libstagefright/codecs/aacdec/AACDecoder.cpp
new file mode 100644
index 0000000..5a32e42
--- /dev/null
+++ b/media/libstagefright/codecs/aacdec/AACDecoder.cpp
@@ -0,0 +1,504 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ *Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+*/
+#include "AACDecoder.h"
+#define LOG_TAG "AACDecoder"
+
+#include "../../include/ESDS.h"
+
+#include "pvmp4audiodecoder_api.h"
+
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MetaData.h>
+
+namespace android {
+
+AACDecoder::AACDecoder(const sp<MediaSource> &source)
+    : mSource(source),
+      mStarted(false),
+      mBufferGroup(NULL),
+      mConfig(new tPVMP4AudioDecoderExternal),
+      mDecoderBuf(NULL),
+      mAnchorTimeUs(0),
+      mNumSamplesOutput(0),
+      mInputBuffer(NULL),
+      mTempInputBuffer(NULL),
+      mTempBufferTotalSize(0),
+      mTempBufferDataLen(0),
+      mInputBufferSize(0) {
+
+    sp<MetaData> srcFormat = mSource->getFormat();
+
+    int32_t sampleRate;
+    CHECK(srcFormat->findInt32(kKeySampleRate, &sampleRate));
+
+    mMeta = new MetaData;
+    mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+
+    // We'll always output stereo, regardless of how many channels are
+    // present in the input due to decoder limitations.
+    mMeta->setInt32(kKeyChannelCount, 2);
+    mMeta->setInt32(kKeySampleRate, sampleRate);
+
+    int64_t durationUs;
+    if (srcFormat->findInt64(kKeyDuration, &durationUs)) {
+        mMeta->setInt64(kKeyDuration, durationUs);
+    }
+    mMeta->setCString(kKeyDecoderComponent, "AACDecoder");
+
+    mInitCheck = initCheck();
+}
+
+status_t AACDecoder::initCheck() {
+    memset(mConfig, 0, sizeof(tPVMP4AudioDecoderExternal));
+    mConfig->outputFormat = OUTPUTFORMAT_16PCM_INTERLEAVED;
+    mConfig->aacPlusEnabled = 1;
+
+    // The software decoder doesn't properly support mono output on
+    // AACplus files. Always output stereo.
+    mConfig->desiredChannels = 2;
+
+
+    int32_t samplingRate;
+    sp<MetaData> meta = mSource->getFormat();
+    meta->findInt32(kKeySampleRate, &samplingRate);
+    mConfig->samplingRate = samplingRate;
+
+    int32_t bitRate;
+    meta->findInt32(kKeyBitRate, &bitRate);
+
+    int32_t encodedChannelCnt;
+    meta->findInt32(kKeyChannelCount, &encodedChannelCnt);
+    //mConfig->desiredChannels = encodedChannelCnt;
+
+    // The software decoder doesn't properly support mono output on
+    // AACplus files. Always output stereo.
+    mConfig->desiredChannels = 2;
+
+    UInt32 memRequirements = PVMP4AudioDecoderGetMemRequirements();
+    mDecoderBuf = malloc(memRequirements);
+
+    status_t err = PVMP4AudioDecoderInitLibrary(mConfig, mDecoderBuf);
+    if (err != MP4AUDEC_SUCCESS) {
+        LOGE("Failed to initialize MP4 audio decoder");
+        return UNKNOWN_ERROR;
+    }
+
+    uint32_t type;
+    const void *data;
+    size_t size;
+    if (meta->findData(kKeyESDS, &type, &data, &size)) {
+        ESDS esds((const char *)data, size);
+        CHECK_EQ(esds.InitCheck(), OK);
+
+        const void *codec_specific_data;
+        size_t codec_specific_data_size;
+        esds.getCodecSpecificInfo(
+                &codec_specific_data, &codec_specific_data_size);
+
+        mConfig->pInputBuffer = (UChar *)codec_specific_data;
+        mConfig->inputBufferCurrentLength = codec_specific_data_size;
+        mConfig->inputBufferMaxLength = 0;
+
+        if (PVMP4AudioDecoderConfig(mConfig, mDecoderBuf)
+                != MP4AUDEC_SUCCESS) {
+            LOGE("Error in setting AAC decoder config");
+            return ERROR_UNSUPPORTED;
+        }
+    }
+
+    //this is used by mm-parser only, usually format block size is 2
+    if (meta->findData(kKeyAacCodecSpecificData, &type, &data, &size)) {
+       if( size > AAC_MAX_FORMAT_BLOCK_SIZE ) {
+          LOGE("AAC FormatBlock is too big %d", size);
+          return ERROR_UNSUPPORTED;
+       }
+       memcpy( mFormatBlock, (uint8_t*)data, size);
+       mConfig->pInputBuffer = mFormatBlock;
+       mConfig->inputBufferCurrentLength = size;
+       mConfig->inputBufferMaxLength = 0;
+
+       if (PVMP4AudioDecoderConfig(mConfig, mDecoderBuf)
+           != MP4AUDEC_SUCCESS) {
+          LOGE("Error in setting AAC decoder config");
+          return ERROR_UNSUPPORTED;
+      }
+    }
+    return OK;
+}
+
+AACDecoder::~AACDecoder() {
+    if (mStarted) {
+        stop();
+    }
+
+    delete mConfig;
+    mConfig = NULL;
+
+    //Reset temp buffer
+    if( mTempInputBuffer != NULL ) {
+       free(mTempInputBuffer);
+       mTempInputBuffer = NULL;
+    }
+}
+
+status_t AACDecoder::start(MetaData *params) {
+    CHECK(!mStarted);
+
+    if (mInitCheck != OK) {
+        LOGE("InitCheck Failed");
+        return UNKNOWN_ERROR;
+    }
+
+    mBufferGroup = new MediaBufferGroup;
+    mBufferGroup->add_buffer(new MediaBuffer(4096 * 2));
+
+    mSource->start();
+
+    mAnchorTimeUs = 0;
+    mNumSamplesOutput = 0;
+    mStarted = true;
+    mNumDecodedBuffers = 0;
+    mUpsamplingFactor = 2;
+
+    return OK;
+}
+
+status_t AACDecoder::stop() {
+    CHECK(mStarted);
+
+    if (mInputBuffer) {
+        mInputBuffer->release();
+        mInputBuffer = NULL;
+    }
+
+    free(mDecoderBuf);
+    mDecoderBuf = NULL;
+
+    delete mBufferGroup;
+    mBufferGroup = NULL;
+
+    if( mTempInputBuffer != NULL ) {
+       free(mTempInputBuffer);
+       mTempInputBuffer = NULL;
+    }
+    mTempBufferDataLen = 0;
+    mTempBufferTotalSize = 0;
+
+    mSource->stop();
+
+    mStarted = false;
+
+    return OK;
+}
+
+sp<MetaData> AACDecoder::getFormat() {
+    return mMeta;
+}
+
+status_t AACDecoder::read(
+        MediaBuffer **out, const ReadOptions *options) {
+    status_t err;
+
+    *out = NULL;
+
+    int64_t seekTimeUs;
+    ReadOptions::SeekMode mode;
+    if (options && options->getSeekTo(&seekTimeUs, &mode)) {
+        CHECK(seekTimeUs >= 0);
+
+        mNumSamplesOutput = 0;
+
+        if (mInputBuffer) {
+            mInputBuffer->release();
+            mInputBuffer = NULL;
+        }
+
+        // Make sure that the next buffer output does not still
+        // depend on fragments from the last one decoded.
+        PVMP4AudioDecoderResetBuffer(mDecoderBuf);
+    } else {
+        seekTimeUs = -1;
+    }
+
+
+    uint8_t* inputBuffer = NULL;
+    uint32_t inputBufferSize = 0;
+
+    if (mInputBuffer == NULL) {
+        err = mSource->read(&mInputBuffer, options);
+
+        if (err != OK) {
+            if(mInputBuffer){
+                mInputBuffer->release();
+                mInputBuffer = NULL;
+            }
+
+            if(mTempInputBuffer != NULL){
+                free(mTempInputBuffer);
+                mTempInputBuffer = NULL;
+            }
+
+            mTempBufferDataLen = 0;
+            mTempBufferTotalSize = 0;
+            mInputBufferSize = 0;
+            return err;
+        }
+
+        int64_t timeUs;
+        if (mInputBuffer->meta_data()->findInt64(kKeyTime, &timeUs)) {
+            mAnchorTimeUs = timeUs;
+            if( timeUs != 0 ) {
+                mNumSamplesOutput = 0;
+            }
+        } else {
+            // We must have a new timestamp after seeking.
+            CHECK(seekTimeUs < 0);
+        }
+
+        inputBuffer = (UChar *)mInputBuffer->data() + mInputBuffer->range_offset();
+        inputBufferSize = mInputBuffer->range_length();
+        if ( mInputBufferSize == 0 ) {
+            // Remember the first input buffer size
+            mInputBufferSize = mInputBuffer->size();
+        }
+        //Check if there was incomplete frame assembly started
+        if (  mTempBufferDataLen ) {
+            LOGV("Incomplete frame assembly is in progress mTempBufferDataLen %d", mTempBufferDataLen);
+            if ( mTempBufferDataLen + inputBufferSize > mTempBufferTotalSize ) {
+                LOGE("Temp buffer size exceeded %d input size %d", mTempBufferTotalSize, inputBufferSize);
+                return UNKNOWN_ERROR;
+            }
+            //append new input buffer to temp buffer
+            memcpy( mTempInputBuffer + mTempBufferDataLen, inputBuffer, inputBufferSize );
+
+            //update the new iput buffer data
+            if ( inputBufferSize + mTempBufferDataLen < mInputBufferSize ) {
+                LOGV("Reached end of stream case" );
+                inputBufferSize += mTempBufferDataLen;
+                mTempBufferDataLen = 0;
+                mInputBufferSize = inputBufferSize;
+                mInputBuffer->set_range(0, inputBufferSize);
+            }
+            memcpy( inputBuffer, mTempInputBuffer, inputBufferSize);
+        }
+    }
+    else {
+        inputBuffer = (UChar *)mInputBuffer->data() + mInputBuffer->range_offset();
+        inputBufferSize = mInputBuffer->range_length();
+    }
+
+    //Allocate Output buffer
+    MediaBuffer *buffer;
+    CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), (status_t)OK);
+
+    //Get the input buffer
+    LOGV("Input Buffer Length %d Offset %d size %d", mInputBuffer->range_length(), mInputBuffer->range_offset(), mInputBufferSize);
+
+    mConfig->pInputBuffer = inputBuffer;
+
+    mConfig->inputBufferCurrentLength = inputBufferSize;
+    mConfig->inputBufferMaxLength = 0;
+    mConfig->inputBufferUsedLength = 0;
+    mConfig->remainderBits = 0;
+
+    mConfig->pOutputBuffer = static_cast<Int16 *>(buffer->data());
+    mConfig->pOutputBuffer_plus = &mConfig->pOutputBuffer[2048];
+    mConfig->repositionFlag = false;
+
+    Int decoderErr;
+
+    decoderErr = PVMP4AudioDecodeFrame(mConfig, mDecoderBuf);
+
+    /*
+     * AAC+/eAAC+ streams can be signalled in two ways: either explicitly
+     * or implicitly, according to MPEG4 spec. AAC+/eAAC+ is a dual
+     * rate system and the sampling rate in the final output is actually
+     * doubled compared with the core AAC decoder sampling rate.
+     *
+     * Explicit signalling is done by explicitly defining SBR audio object
+     * type in the bitstream. Implicit signalling is done by embedding
+     * SBR content in AAC extension payload specific to SBR, and hence
+     * requires an AAC decoder to perform pre-checks on actual audio frames.
+     *
+     * Thus, we could not say for sure whether a stream is
+     * AAC+/eAAC+ until the first data frame is decoded.
+     */
+    if (++mNumDecodedBuffers <= 2) {
+        LOGV("audio/extended audio object type: %d + %d",
+            mConfig->audioObjectType, mConfig->extendedAudioObjectType);
+        LOGV("aac+ upsampling factor: %d desired channels: %d",
+            mConfig->aacPlusUpsamplingFactor, mConfig->desiredChannels);
+
+        CHECK(mNumDecodedBuffers > 0);
+        if (mNumDecodedBuffers == 1) {
+            mUpsamplingFactor = mConfig->aacPlusUpsamplingFactor;
+            // Check on the sampling rate to see whether it is changed.
+            int32_t sampleRate;
+            CHECK(mMeta->findInt32(kKeySampleRate, &sampleRate));
+            if (mConfig->samplingRate != sampleRate) {
+                mMeta->setInt32(kKeySampleRate, mConfig->samplingRate);
+                LOGW("Sample rate was %d Hz, but now is %d Hz",
+                        sampleRate, mConfig->samplingRate);
+                buffer->release();
+                mInputBuffer->release();
+                mInputBuffer = NULL;
+                return INFO_FORMAT_CHANGED;
+            }
+        } else {  // mNumDecodedBuffers == 2
+            if (mConfig->extendedAudioObjectType == MP4AUDIO_AAC_LC ||
+                mConfig->extendedAudioObjectType == MP4AUDIO_LTP) {
+                if (mUpsamplingFactor == 2) {
+                    // The stream turns out to be not aacPlus mode anyway
+                    LOGW("Disable AAC+/eAAC+ since extended audio object type is %d",
+                        mConfig->extendedAudioObjectType);
+                    mConfig->aacPlusEnabled = 0;
+                }
+            } else {
+                if (mUpsamplingFactor == 1) {
+                    // aacPlus mode does not buy us anything, but to cause
+                    // 1. CPU load to increase, and
+                    // 2. a half speed of decoding
+                    LOGW("Disable AAC+/eAAC+ since upsampling factor is 1");
+                    mConfig->aacPlusEnabled = 0;
+                }
+            }
+        }
+    }
+
+    size_t numOutBytes =
+        mConfig->frameLength * sizeof(int16_t) * mConfig->desiredChannels;
+    if (mUpsamplingFactor == 2) {
+        if (mConfig->desiredChannels == 1) {
+            memcpy(&mConfig->pOutputBuffer[1024], &mConfig->pOutputBuffer[2048], numOutBytes * 2);
+        }
+        numOutBytes *= 2;
+    }
+
+    LOGV("AAC decoder %d frame length %d used length %d ", decoderErr, inputBufferSize, mConfig->inputBufferUsedLength);
+    if( inputBufferSize < mConfig->inputBufferUsedLength ) {
+        LOGE("unexpected error actual len %d is less than used len %d", inputBufferSize, mConfig->inputBufferUsedLength);
+        decoderErr = MP4AUDEC_INVALID_FRAME;
+    }
+
+    int aacformattype = 0;
+    sp<MetaData> metadata = mSource->getFormat();
+    metadata->findInt32(kkeyAacFormatAdif, &aacformattype);
+
+    if ( decoderErr == MP4AUDEC_INCOMPLETE_FRAME  && aacformattype == true) {
+        LOGW("Handle Incomplete frame error inputBufSize %d, usedLength %d", inputBufferSize, mConfig->inputBufferUsedLength);
+        if(mConfig->inputBufferUsedLength == mInputBufferSize){
+           LOGW("Decoder cannot process the buffer due to invalid frame");
+           decoderErr = MP4AUDEC_INVALID_FRAME;
+        } else {
+            if ( !mTempInputBuffer ) {
+                //Allocate Temp buffer
+                uint32_t bytesToAllocate = 2 * mInputBuffer->size();
+                mTempInputBuffer = (uint8_t*)malloc( bytesToAllocate );
+                mTempBufferDataLen = 0;
+                if (mTempInputBuffer == NULL) {
+                   LOGE("Could not allocate temp buffer bytesToAllocate quit playing");
+                   return UNKNOWN_ERROR;
+                }
+                mTempBufferTotalSize = bytesToAllocate;
+                LOGV("Allocated tempBuffer of size %d data len %d", mTempBufferTotalSize, mTempBufferDataLen);
+            }
+            // copy the remaining data into temp buffer
+            memcpy( mTempInputBuffer, inputBuffer, mConfig->inputBufferUsedLength );
+
+            if (mTempBufferDataLen != 0) {
+                //append previous remaining data back into temp buffer
+                LOGV("Appending remaining data tempDataLen %d usedLength %d", mTempBufferDataLen, mConfig->inputBufferUsedLength);
+                memcpy( mTempInputBuffer + mConfig->inputBufferUsedLength,
+                    mTempInputBuffer + mInputBufferSize,
+                    mTempBufferDataLen );
+            }
+
+            mTempBufferDataLen += mConfig->inputBufferUsedLength;
+            LOGV("mTempBufferDataLen %d inputBufferUsedLength %d", mTempBufferDataLen, mConfig->inputBufferUsedLength);
+            // temp buffer has accumulated one frame size worth data
+            // copy it back to input buffer so that it is fed to decoder next
+            if ( mTempBufferDataLen >= mInputBufferSize ) {
+                LOGV("mTempBufferDataLen %d exceeded mInputBufferSize %d ", mTempBufferDataLen, mInputBufferSize);
+                memcpy((UChar*)mInputBuffer->data(), mTempInputBuffer, mInputBufferSize );
+                mTempBufferDataLen -= mInputBufferSize;
+                mInputBuffer->set_range( 0, mInputBufferSize );
+                mConfig->inputBufferUsedLength = 0;
+            }
+
+            //reset the output buffer size
+            numOutBytes = 0;
+        } // end of else INVALID FRAME
+
+    }
+    if (decoderErr != MP4AUDEC_SUCCESS && decoderErr != MP4AUDEC_INCOMPLETE_FRAME) {
+        LOGW("AAC decoder returned error %d, substituting silence", decoderErr);
+
+        memset(buffer->data(), 0, numOutBytes);
+
+        // Discard input buffer.
+        if( mInputBuffer != NULL ) {
+            mInputBuffer->release();
+            mInputBuffer = NULL;
+        }
+
+        if(mTempBufferDataLen) {
+            //put previous remaining data to temp buffer beginning
+            memcpy( mTempInputBuffer,
+                    mTempInputBuffer + mInputBufferSize,
+                    mTempBufferDataLen );
+        }
+
+        // fall through
+    }
+
+    buffer->set_range(0, numOutBytes);
+
+    if (mInputBuffer != NULL) {
+        mInputBuffer->set_range(
+                mInputBuffer->range_offset() + mConfig->inputBufferUsedLength,
+                mInputBuffer->range_length() - mConfig->inputBufferUsedLength);
+
+        if (mInputBuffer->range_length() == 0) {
+            if(decoderErr == MP4AUDEC_SUCCESS && mTempBufferDataLen) {
+                //put previous remaining data to temp buffer beginning
+                memcpy( mTempInputBuffer,
+                        mTempInputBuffer + mInputBufferSize,
+                        mTempBufferDataLen );
+            }
+            mInputBuffer->release();
+            mInputBuffer = NULL;
+        }
+    }
+
+    buffer->meta_data()->setInt64(
+            kKeyTime,
+            mAnchorTimeUs
+                + (mNumSamplesOutput * 1000000) / mConfig->samplingRate);
+
+    if(numOutBytes > 0)
+        mNumSamplesOutput += mConfig->frameLength * mUpsamplingFactor;
+
+    *out = buffer;
+
+    return OK;
+}
+
+}  // namespace android
diff --git a/media/libstagefright/codecs/aacdec/Android.mk b/media/libstagefright/codecs/aacdec/Android.mk
index 20c7bc0..c8bfd28 100644
--- a/media/libstagefright/codecs/aacdec/Android.mk
+++ b/media/libstagefright/codecs/aacdec/Android.mk
@@ -151,7 +151,7 @@ LOCAL_C_INCLUDES := \
 
 LOCAL_ARM_MODE := arm
 
-LOCAL_MODULE := libstagefright_aacdec
+LOCAL_MODULE := libstagefright_aacdec_omx
 
 include $(BUILD_STATIC_LIBRARY)
 
@@ -169,7 +169,7 @@ LOCAL_C_INCLUDES := \
 LOCAL_CFLAGS := -DOSCL_IMPORT_REF=
 
 LOCAL_STATIC_LIBRARIES := \
-        libstagefright_aacdec
+        libstagefright_aacdec_omx
 
 LOCAL_SHARED_LIBRARIES := \
         libstagefright_omx libstagefright_foundation libutils
@@ -178,3 +178,161 @@ LOCAL_MODULE := libstagefright_soft_aacdec
 LOCAL_MODULE_TAGS := optional
 
 include $(BUILD_SHARED_LIBRARY)
+
+################################################################################
+
+ifeq ($(TARGET_USES_QCOM_LPA),true)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	analysis_sub_band.cpp \
+ 	apply_ms_synt.cpp \
+ 	apply_tns.cpp \
+ 	buf_getbits.cpp \
+ 	byte_align.cpp \
+ 	calc_auto_corr.cpp \
+ 	calc_gsfb_table.cpp \
+ 	calc_sbr_anafilterbank.cpp \
+ 	calc_sbr_envelope.cpp \
+ 	calc_sbr_synfilterbank.cpp \
+ 	check_crc.cpp \
+ 	dct16.cpp \
+ 	dct64.cpp \
+ 	decode_huff_cw_binary.cpp \
+ 	decode_noise_floorlevels.cpp \
+ 	deinterleave.cpp \
+ 	digit_reversal_tables.cpp \
+ 	dst16.cpp \
+ 	dst32.cpp \
+ 	dst8.cpp \
+ 	esc_iquant_scaling.cpp \
+ 	extractframeinfo.cpp \
+ 	fft_rx4_long.cpp \
+ 	fft_rx4_short.cpp \
+ 	fft_rx4_tables_fxp.cpp \
+ 	find_adts_syncword.cpp \
+ 	fwd_long_complex_rot.cpp \
+ 	fwd_short_complex_rot.cpp \
+ 	gen_rand_vector.cpp \
+ 	get_adif_header.cpp \
+ 	get_adts_header.cpp \
+ 	get_audio_specific_config.cpp \
+ 	get_dse.cpp \
+ 	get_ele_list.cpp \
+ 	get_ga_specific_config.cpp \
+ 	get_ics_info.cpp \
+ 	get_prog_config.cpp \
+ 	get_pulse_data.cpp \
+ 	get_sbr_bitstream.cpp \
+ 	get_sbr_startfreq.cpp \
+ 	get_sbr_stopfreq.cpp \
+ 	get_tns.cpp \
+ 	getfill.cpp \
+ 	getgroup.cpp \
+ 	getics.cpp \
+ 	getmask.cpp \
+ 	hcbtables_binary.cpp \
+ 	huffcb.cpp \
+ 	huffdecode.cpp \
+ 	hufffac.cpp \
+ 	huffspec_fxp.cpp \
+ 	idct16.cpp \
+ 	idct32.cpp \
+ 	idct8.cpp \
+ 	imdct_fxp.cpp \
+ 	infoinit.cpp \
+ 	init_sbr_dec.cpp \
+ 	intensity_right.cpp \
+ 	inv_long_complex_rot.cpp \
+ 	inv_short_complex_rot.cpp \
+ 	iquant_table.cpp \
+ 	long_term_prediction.cpp \
+ 	long_term_synthesis.cpp \
+ 	lt_decode.cpp \
+ 	mdct_fxp.cpp \
+ 	mdct_tables_fxp.cpp \
+ 	mdst.cpp \
+ 	mix_radix_fft.cpp \
+ 	ms_synt.cpp \
+ 	pns_corr.cpp \
+ 	pns_intensity_right.cpp \
+ 	pns_left.cpp \
+ 	ps_all_pass_filter_coeff.cpp \
+ 	ps_all_pass_fract_delay_filter.cpp \
+ 	ps_allocate_decoder.cpp \
+ 	ps_applied.cpp \
+ 	ps_bstr_decoding.cpp \
+ 	ps_channel_filtering.cpp \
+ 	ps_decode_bs_utils.cpp \
+ 	ps_decorrelate.cpp \
+ 	ps_fft_rx8.cpp \
+ 	ps_hybrid_analysis.cpp \
+ 	ps_hybrid_filter_bank_allocation.cpp \
+ 	ps_hybrid_synthesis.cpp \
+ 	ps_init_stereo_mixing.cpp \
+ 	ps_pwr_transient_detection.cpp \
+ 	ps_read_data.cpp \
+ 	ps_stereo_processing.cpp \
+ 	pulse_nc.cpp \
+ 	pv_div.cpp \
+ 	pv_log2.cpp \
+ 	pv_normalize.cpp \
+ 	pv_pow2.cpp \
+ 	pv_sine.cpp \
+ 	pv_sqrt.cpp \
+ 	pvmp4audiodecoderconfig.cpp \
+ 	pvmp4audiodecoderframe.cpp \
+ 	pvmp4audiodecodergetmemrequirements.cpp \
+ 	pvmp4audiodecoderinitlibrary.cpp \
+ 	pvmp4audiodecoderresetbuffer.cpp \
+ 	q_normalize.cpp \
+ 	qmf_filterbank_coeff.cpp \
+ 	sbr_aliasing_reduction.cpp \
+ 	sbr_applied.cpp \
+ 	sbr_code_book_envlevel.cpp \
+ 	sbr_crc_check.cpp \
+ 	sbr_create_limiter_bands.cpp \
+ 	sbr_dec.cpp \
+ 	sbr_decode_envelope.cpp \
+ 	sbr_decode_huff_cw.cpp \
+ 	sbr_downsample_lo_res.cpp \
+ 	sbr_envelope_calc_tbl.cpp \
+ 	sbr_envelope_unmapping.cpp \
+ 	sbr_extract_extended_data.cpp \
+ 	sbr_find_start_andstop_band.cpp \
+ 	sbr_generate_high_freq.cpp \
+ 	sbr_get_additional_data.cpp \
+ 	sbr_get_cpe.cpp \
+ 	sbr_get_dir_control_data.cpp \
+ 	sbr_get_envelope.cpp \
+ 	sbr_get_header_data.cpp \
+ 	sbr_get_noise_floor_data.cpp \
+ 	sbr_get_sce.cpp \
+ 	sbr_inv_filt_levelemphasis.cpp \
+ 	sbr_open.cpp \
+ 	sbr_read_data.cpp \
+ 	sbr_requantize_envelope_data.cpp \
+ 	sbr_reset_dec.cpp \
+ 	sbr_update_freq_scale.cpp \
+ 	set_mc_info.cpp \
+ 	sfb.cpp \
+ 	shellsort.cpp \
+ 	synthesis_sub_band.cpp \
+ 	tns_ar_filter.cpp \
+ 	tns_decode_coef.cpp \
+ 	tns_inv_filter.cpp \
+ 	trans4m_freq_2_time_fxp.cpp \
+ 	trans4m_time_2_freq_fxp.cpp \
+ 	unpack_idx.cpp \
+ 	window_tables_fxp.cpp \
+ 	pvmp4setaudioconfig.cpp \
+    AACDecoder.cpp
+
+LOCAL_CFLAGS := -DAAC_PLUS -DHQ_SBR -DPARAMETRICSTEREO -DOSCL_IMPORT_REF= -DOSCL_EXPORT_REF= -DOSCL_UNUSED_ARG=
+
+LOCAL_C_INCLUDES := frameworks/base/media/libstagefright/include
+
+LOCAL_MODULE := libstagefright_aacdec
+
+include $(BUILD_STATIC_LIBRARY)
+endif
diff --git a/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp b/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp
index aa07e57..ddced5f 100644
--- a/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp
+++ b/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp
@@ -421,13 +421,8 @@ void SoftMPEG4::onQueueFilled(OMX_U32 portIndex) {
 
         int32_t bufferSize = inHeader->nFilledLen;
 
-        // The PV decoder is lying to us, sometimes it'll claim to only have
-        // consumed a subset of the buffer when it clearly consumed all of it.
-        // ignore whatever it says...
-        int32_t tmp = bufferSize;
-
         if (PVDecodeVideoFrame(
-                    mHandle, &bitstream, &timestamp, &tmp,
+                    mHandle, &bitstream, &timestamp, &bufferSize,
                     &useExtTimestamp,
                     outHeader->pBuffer) != PV_TRUE) {
             LOGE("failed to decode video frame.");
diff --git a/media/libstagefright/codecs/mp3dec/Android.mk b/media/libstagefright/codecs/mp3dec/Android.mk
index a08c9f0..4b29871 100644
--- a/media/libstagefright/codecs/mp3dec/Android.mk
+++ b/media/libstagefright/codecs/mp3dec/Android.mk
@@ -1,7 +1,10 @@
 LOCAL_PATH:= $(call my-dir)
+
+ifeq ($(TARGET_USES_QCOM_LPA),true)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := \
+        MP3Decoder.cpp \
 	src/pvmp3_normalize.cpp \
  	src/pvmp3_alias_reduction.cpp \
  	src/pvmp3_crc.cpp \
@@ -52,6 +55,65 @@ LOCAL_CFLAGS := \
 
 LOCAL_MODULE := libstagefright_mp3dec
 
+include $(BUILD_STATIC_LIBRARY)
+
+endif
+
+
+#LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	src/pvmp3_normalize.cpp \
+ 	src/pvmp3_alias_reduction.cpp \
+ 	src/pvmp3_crc.cpp \
+ 	src/pvmp3_decode_header.cpp \
+ 	src/pvmp3_decode_huff_cw.cpp \
+ 	src/pvmp3_getbits.cpp \
+ 	src/pvmp3_dequantize_sample.cpp \
+ 	src/pvmp3_framedecoder.cpp \
+ 	src/pvmp3_get_main_data_size.cpp \
+ 	src/pvmp3_get_side_info.cpp \
+ 	src/pvmp3_get_scale_factors.cpp \
+ 	src/pvmp3_mpeg2_get_scale_data.cpp \
+ 	src/pvmp3_mpeg2_get_scale_factors.cpp \
+ 	src/pvmp3_mpeg2_stereo_proc.cpp \
+ 	src/pvmp3_huffman_decoding.cpp \
+ 	src/pvmp3_huffman_parsing.cpp \
+ 	src/pvmp3_tables.cpp \
+ 	src/pvmp3_imdct_synth.cpp \
+ 	src/pvmp3_mdct_6.cpp \
+ 	src/pvmp3_dct_6.cpp \
+ 	src/pvmp3_poly_phase_synthesis.cpp \
+ 	src/pvmp3_equalizer.cpp \
+ 	src/pvmp3_seek_synch.cpp \
+ 	src/pvmp3_stereo_proc.cpp \
+ 	src/pvmp3_reorder.cpp \
+
+ifeq ($(TARGET_ARCH),arm)
+LOCAL_SRC_FILES += \
+	src/asm/pvmp3_polyphase_filter_window_gcc.s \
+ 	src/asm/pvmp3_mdct_18_gcc.s \
+ 	src/asm/pvmp3_dct_9_gcc.s \
+	src/asm/pvmp3_dct_16_gcc.s
+else
+LOCAL_SRC_FILES += \
+ 	src/pvmp3_polyphase_filter_window.cpp \
+ 	src/pvmp3_mdct_18.cpp \
+ 	src/pvmp3_dct_9.cpp \
+ 	src/pvmp3_dct_16.cpp
+endif
+
+LOCAL_C_INCLUDES := \
+        frameworks/base/media/libstagefright/include \
+        $(LOCAL_PATH)/src \
+        $(LOCAL_PATH)/include
+
+LOCAL_CFLAGS := \
+        -DOSCL_UNUSED_ARG=
+
+LOCAL_MODULE := libstagefright_mp3dec_omx
+
 LOCAL_ARM_MODE := arm
 
 include $(BUILD_STATIC_LIBRARY)
@@ -73,7 +135,7 @@ LOCAL_SHARED_LIBRARIES := \
         libstagefright libstagefright_omx libstagefright_foundation libutils
 
 LOCAL_STATIC_LIBRARIES := \
-        libstagefright_mp3dec
+        libstagefright_mp3dec_omx
 
 LOCAL_MODULE := libstagefright_soft_mp3dec
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/codecs/mp3dec/MP3Decoder.cpp b/media/libstagefright/codecs/mp3dec/MP3Decoder.cpp
new file mode 100644
index 0000000..f53ff10
--- /dev/null
+++ b/media/libstagefright/codecs/mp3dec/MP3Decoder.cpp
@@ -0,0 +1,586 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "MP3Decoder.h"
+
+#include "include/pvmp3decoder_api.h"
+
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
+
+namespace android {
+
+// Everything must match except for
+// protection, bitrate, padding, private bits, mode extension,
+// copyright bit, original bit and emphasis.
+// Yes ... there are things that must indeed match...
+static const uint32_t kMask = 0xfffe0cc0;
+
+static bool get_mp3_frame_size(
+        uint32_t header, size_t *frame_size,
+        int *out_sampling_rate = NULL, int *out_channels = NULL,
+        int *out_bitrate = NULL) {
+    *frame_size = 0;
+
+    if (out_sampling_rate) {
+        *out_sampling_rate = 0;
+    }
+
+    if (out_channels) {
+        *out_channels = 0;
+    }
+
+    if (out_bitrate) {
+        *out_bitrate = 0;
+    }
+
+    if ((header & 0xffe00000) != 0xffe00000) {
+        return false;
+    }
+
+    unsigned version = (header >> 19) & 3;
+
+    if (version == 0x01) {
+        return false;
+    }
+
+    unsigned layer = (header >> 17) & 3;
+
+    if (layer == 0x00) {
+        return false;
+    }
+
+    unsigned protection = (header >> 16) & 1;
+
+    unsigned bitrate_index = (header >> 12) & 0x0f;
+
+    if (bitrate_index == 0 || bitrate_index == 0x0f) {
+        // Disallow "free" bitrate.
+        return false;
+    }
+
+    unsigned sampling_rate_index = (header >> 10) & 3;
+
+    if (sampling_rate_index == 3) {
+        return false;
+    }
+
+    static const int kSamplingRateV1[] = { 44100, 48000, 32000 };
+    int sampling_rate = kSamplingRateV1[sampling_rate_index];
+    if (version == 2 /* V2 */) {
+        sampling_rate /= 2;
+    } else if (version == 0 /* V2.5 */) {
+        sampling_rate /= 4;
+    }
+
+    unsigned padding = (header >> 9) & 1;
+
+    if (layer == 3) {
+        // layer I
+
+        static const int kBitrateV1[] = {
+            32, 64, 96, 128, 160, 192, 224, 256,
+            288, 320, 352, 384, 416, 448
+        };
+
+        static const int kBitrateV2[] = {
+            32, 48, 56, 64, 80, 96, 112, 128,
+            144, 160, 176, 192, 224, 256
+        };
+
+        int bitrate =
+            (version == 3 /* V1 */)
+                ? kBitrateV1[bitrate_index - 1]
+                : kBitrateV2[bitrate_index - 1];
+
+        if (out_bitrate) {
+            *out_bitrate = bitrate;
+        }
+
+        *frame_size = (12000 * bitrate / sampling_rate + padding) * 4;
+    } else {
+        // layer II or III
+
+        static const int kBitrateV1L2[] = {
+            32, 48, 56, 64, 80, 96, 112, 128,
+            160, 192, 224, 256, 320, 384
+        };
+
+        static const int kBitrateV1L3[] = {
+            32, 40, 48, 56, 64, 80, 96, 112,
+            128, 160, 192, 224, 256, 320
+        };
+
+        static const int kBitrateV2[] = {
+            8, 16, 24, 32, 40, 48, 56, 64,
+            80, 96, 112, 128, 144, 160
+        };
+
+        int bitrate;
+        if (version == 3 /* V1 */) {
+            bitrate = (layer == 2 /* L2 */)
+                ? kBitrateV1L2[bitrate_index - 1]
+                : kBitrateV1L3[bitrate_index - 1];
+        } else {
+            // V2 (or 2.5)
+
+            bitrate = kBitrateV2[bitrate_index - 1];
+        }
+
+        if (out_bitrate) {
+            *out_bitrate = bitrate;
+        }
+
+        if (version == 3 /* V1 */) {
+            *frame_size = 144000 * bitrate / sampling_rate + padding;
+        } else {
+            // V2 or V2.5
+            *frame_size = 72000 * bitrate / sampling_rate + padding;
+        }
+    }
+
+    if (out_sampling_rate) {
+        *out_sampling_rate = sampling_rate;
+    }
+
+    if (out_channels) {
+        int channel_mode = (header >> 6) & 3;
+
+        *out_channels = (channel_mode == 3) ? 1 : 2;
+    }
+
+    return true;
+}
+
+static bool resync(
+        uint8_t *data, uint32_t size, uint32_t match_header, off_t *out_pos) {
+
+    bool valid = false;
+    off_t pos = 0;
+    *out_pos = 0;
+    do {
+        if (pos + 4 > size) {
+            // Don't scan forever.
+            LOGV("no dice, no valid sequence of frames found.");
+            break;
+        }
+
+        uint32_t header = U32_AT(data + pos);
+
+        if (match_header != 0 && (header & kMask) != (match_header & kMask)) {
+            ++pos;
+            continue;
+        }
+
+        LOGV("found possible frame at %ld (header = 0x%08x)", pos, header);
+
+        // We found what looks like a valid frame,
+        valid = true;
+        *out_pos = pos;
+    } while (!valid);
+
+    return valid;
+}
+
+
+MP3Decoder::MP3Decoder(const sp<MediaSource> &source)
+    : mSource(source),
+      mNumChannels(0),
+      mStarted(false),
+      mBufferGroup(NULL),
+      mConfig(new tPVMP3DecoderExternal),
+      mDecoderBuf(NULL),
+      mAnchorTimeUs(0),
+      mNumFramesOutput(0),
+      mInputBuffer(NULL),
+      mPartialBuffer(NULL),
+      mFixedHeader(0) {
+    init();
+}
+
+void MP3Decoder::init() {
+    sp<MetaData> srcFormat = mSource->getFormat();
+
+    int32_t sampleRate;
+    CHECK(srcFormat->findInt32(kKeyChannelCount, &mNumChannels));
+    CHECK(srcFormat->findInt32(kKeySampleRate, &sampleRate));
+
+    mMeta = new MetaData;
+    mMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+    mMeta->setInt32(kKeyChannelCount, mNumChannels);
+    mMeta->setInt32(kKeySampleRate, sampleRate);
+
+    int64_t durationUs;
+    if (srcFormat->findInt64(kKeyDuration, &durationUs)) {
+        mMeta->setInt64(kKeyDuration, durationUs);
+    }
+
+    mMeta->setCString(kKeyDecoderComponent, "MP3Decoder");
+}
+
+MP3Decoder::~MP3Decoder() {
+    if (mStarted) {
+        stop();
+    }
+
+    delete mConfig;
+    mConfig = NULL;
+}
+
+status_t MP3Decoder::start(MetaData *params) {
+    CHECK(!mStarted);
+
+    mBufferGroup = new MediaBufferGroup;
+    mBufferGroup->add_buffer(new MediaBuffer(4608 * 2));
+
+    mConfig->equalizerType = flat;
+    mConfig->crcEnabled = false;
+
+    uint32_t memRequirements = pvmp3_decoderMemRequirements();
+    mDecoderBuf = malloc(memRequirements);
+
+    pvmp3_InitDecoder(mConfig, mDecoderBuf);
+
+    mSource->start();
+
+    mAnchorTimeUs = 0;
+    mNumFramesOutput = 0;
+    mStarted = true;
+
+    return OK;
+}
+
+status_t MP3Decoder::stop() {
+    CHECK(mStarted);
+
+    if (mInputBuffer) {
+        mInputBuffer->release();
+        mInputBuffer = NULL;
+    }
+
+    free(mDecoderBuf);
+    mDecoderBuf = NULL;
+
+    delete mBufferGroup;
+    mBufferGroup = NULL;
+
+    mSource->stop();
+
+    mStarted = false;
+
+    return OK;
+}
+
+sp<MetaData> MP3Decoder::getFormat() {
+    return mMeta;
+}
+
+status_t MP3Decoder::updatePartialFrame() {
+    status_t err = OK;
+    if (mPartialBuffer == NULL) {
+        return err;
+    }
+
+    size_t frameSize = 0;
+    uint32_t partialBufLen = mPartialBuffer->range_length();
+    uint32_t inputBufLen = mInputBuffer->range_length();
+    uint8_t frameHeader[4];
+    uint8_t *frmHdr;
+    uint32_t header;
+
+
+    // Look at the frame size and complete the partial frame
+    // Also check if a vaild header is found after the partial frame
+    if (partialBufLen < 4) { // check if partial frame has the 4 bytes header
+        if (inputBufLen < (4 - partialBufLen)) {
+            // input buffer does not have the frame header bytes
+            // bail out TODO
+            LOGE("MP3Decoder::updatePartialFrame buffer to small header not found"
+                 " partial buffer len %d, input buffer len %d",
+                 partialBufLen, inputBufLen);
+            //mPartialBuffer->release();
+            //mPartialBuffer = NULL;
+            return UNKNOWN_ERROR;
+        }
+
+        // copy the header bytes to frameHeader
+        memcpy (frameHeader, mPartialBuffer->data(), partialBufLen);
+        memcpy (frameHeader + partialBufLen, mInputBuffer->data(), (4 - partialBufLen));
+        // get the first 4 bytes of the buffer
+        header = U32_AT((uint8_t *)frameHeader);
+        frmHdr = frameHeader;
+    } else {
+        frmHdr = (uint8_t *)mPartialBuffer->data();
+    }
+
+    // check if its a good frame, and the frame size
+    // get the first 4 bytes of the buffer
+    header = U32_AT(frmHdr);
+    bool curFrame = get_mp3_frame_size(header,&frameSize);
+    if (!curFrame) {
+        LOGE("MP3Decoder::read - partial frame does not have a vaild header 0x%x",
+             header);
+        return UNKNOWN_ERROR;
+    }
+
+    // check if the following frame is good
+    uint32_t nextFrameOffset = frameSize - partialBufLen;
+    if ((nextFrameOffset + 4) <= inputBufLen) {
+        header = U32_AT((uint8_t *)mInputBuffer->data() + nextFrameOffset);
+        if ((header & 0xffe00000) != 0xffe00000) {
+            // next frame does not have a valid header,
+            // this may not be the next buffer, bail out.
+            LOGE("MP3Decoder::read - next frame does not have a vaild header 0x%x",
+                 header);
+            return UNKNOWN_ERROR;
+        }
+    } else {
+        // next frame header is out of range
+        // assume good header for now
+        LOGE("MP3Decoder::read - assuming next frame is good");
+    }
+
+    // check if the input buffer has the remaining partial frame
+    if (frameSize > (partialBufLen + inputBufLen)) {
+        // input buffer does not have the remaining partial frame,
+        // discard data here as frame split in 3 buffers not supported
+        LOGE("MP3Decoder::updatePartialFrame - input buffer does not have the complete frame."
+             " frame size %d, saved partial buffer len %d,"
+             " input buffer len %d", frameSize, partialBufLen, inputBufLen);
+        return UNKNOWN_ERROR;
+    }
+
+    // check if the mPartialBuffer can fit the remaining frame
+    if ((mPartialBuffer->size() - partialBufLen) < (frameSize - partialBufLen)) {
+        // mPartialBuffer is small to hold the reaming frame
+        //TODO
+        LOGE("MP3Decoder::updatePartialFrame - mPartialBuffer is small, size %d, required &d",
+             (mPartialBuffer->size() - partialBufLen), (frameSize - partialBufLen));
+        return UNKNOWN_ERROR;
+    }
+
+    // done with error checks
+    // copy the partial frames to from a complete frame
+    // Copy the remaining frame from input buffer
+    uint32_t bytesRemaining = frameSize - mPartialBuffer->range_length();
+    memcpy ((uint8_t *)mPartialBuffer->data() + mPartialBuffer->range_length(),
+            (uint8_t *)mInputBuffer->data() + mInputBuffer->range_offset(),
+            bytesRemaining);
+
+    // mark the bytes as consumed from input buffer
+    mInputBuffer->set_range(
+                           mInputBuffer->range_offset() + bytesRemaining,
+                           mInputBuffer->range_length() - bytesRemaining);
+
+    // set the range and length of mPartialBuffer
+    mPartialBuffer->set_range(0,
+                              mPartialBuffer->range_length() + bytesRemaining);
+
+    LOGE("MP3Decoder::updatePartialFrame - copied the partial frame %d, input buffer length %d",
+         bytesRemaining, mInputBuffer->range_length());
+
+    return err;
+}
+
+status_t MP3Decoder::read(
+        MediaBuffer **out, const ReadOptions *options) {
+    status_t err;
+
+    *out = NULL;
+    bool usedPartialFrame = false;
+    bool seekSource = false;
+
+    int64_t seekTimeUs;
+    ReadOptions::SeekMode mode;
+    if (options && options->getSeekTo(&seekTimeUs, &mode)) {
+        CHECK(seekTimeUs >= 0);
+
+        mNumFramesOutput = 0;
+        seekSource = true;
+
+        if (mInputBuffer) {
+            mInputBuffer->release();
+            mInputBuffer = NULL;
+        }
+
+        if (mPartialBuffer) {
+            mPartialBuffer->release();
+            mPartialBuffer = NULL;
+        }
+
+        // Make sure that the next buffer output does not still
+        // depend on fragments from the last one decoded.
+        pvmp3_InitDecoder(mConfig, mDecoderBuf);
+    } else {
+        seekTimeUs = -1;
+    }
+
+    if (mInputBuffer == NULL) {
+        err = mSource->read(&mInputBuffer, options);
+
+        if (err != OK) {
+            return err;
+        }
+
+        if ((mFixedHeader == 0) && (mInputBuffer->range_length() > 4)) {
+            //save the first 4 bytes as fixed header for the reset of the file
+            mFixedHeader = U32_AT((uint8_t *)mInputBuffer->data());
+        }
+
+        if (seekSource == true) {
+            off_t syncOffset = 0;
+            bool valid = resync((uint8_t *)mInputBuffer->data() + mInputBuffer->range_offset()
+                                ,mInputBuffer->range_length(), mFixedHeader, &syncOffset);
+            if (valid) {
+                // consume these bytes, we might find a frame header in next buffer
+                mInputBuffer->set_range(
+                    mInputBuffer->range_offset() + syncOffset,
+                    mInputBuffer->range_length() - syncOffset);
+                LOGV("mp3 decoder found a sync point after seek syncOffset %d", syncOffset);
+            } else {
+                LOGV("NO SYNC POINT found, buffer length %d",mInputBuffer->range_length());
+            }
+        }
+
+        int64_t timeUs;
+        if (mInputBuffer->meta_data()->findInt64(kKeyTime, &timeUs)) {
+            mAnchorTimeUs = timeUs;
+            mNumFramesOutput = 0;
+        } else {
+            // We must have a new timestamp after seeking.
+            CHECK(seekTimeUs < 0);
+        }
+        // check for partial frame
+        if (mPartialBuffer != NULL) {
+            err = updatePartialFrame();
+            if (err != OK) {
+                // updating partial frame failed, discard the previously
+                // saved partial frame and continue
+                mPartialBuffer->release();
+                mPartialBuffer = NULL;
+                err = OK;
+            }
+        }
+    }
+
+    MediaBuffer *buffer;
+    CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), OK);
+
+    if (mPartialBuffer != NULL) {
+        mConfig->pInputBuffer =
+        (uint8_t *)mPartialBuffer->data() + mPartialBuffer->range_offset();
+        mConfig->inputBufferCurrentLength = mPartialBuffer->range_length();
+        usedPartialFrame = true;
+    } else {
+        mConfig->pInputBuffer =
+            (uint8_t *)mInputBuffer->data() + mInputBuffer->range_offset();
+        mConfig->inputBufferCurrentLength = mInputBuffer->range_length();
+    }
+
+    mConfig->inputBufferMaxLength = 0;
+    mConfig->inputBufferUsedLength = 0;
+
+    mConfig->outputFrameSize = buffer->size() / sizeof(int16_t);
+    mConfig->pOutputBuffer = static_cast<int16_t *>(buffer->data());
+
+    ERROR_CODE decoderErr;
+    if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))
+            != NO_DECODING_ERROR) {
+        LOGV("mp3 decoder returned error %d", decoderErr);
+
+        if ((decoderErr != NO_ENOUGH_MAIN_DATA_ERROR) &&
+            (decoderErr != SYNCH_LOST_ERROR)) {
+            buffer->release();
+            buffer = NULL;
+
+            mInputBuffer->release();
+            mInputBuffer = NULL;
+            if (mPartialBuffer) {
+                mPartialBuffer->release();
+                mPartialBuffer = NULL;
+            }
+            LOGE("mp3 decoder returned UNKNOWN_ERROR");
+
+            return UNKNOWN_ERROR;
+        }
+
+        if ((mPartialBuffer == NULL) && (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR)) {
+            // Might be a partial frame, save it
+            mPartialBuffer = new MediaBuffer(mInputBuffer->size());
+            memcpy ((uint8_t *)mPartialBuffer->data(),
+                    mConfig->pInputBuffer, mConfig->inputBufferCurrentLength);
+            mPartialBuffer->set_range(0, mConfig->inputBufferCurrentLength);
+            // set output buffer to 0
+            mConfig->outputFrameSize = 0;
+            // consume the copied bytes from input
+            mConfig->inputBufferUsedLength = mConfig->inputBufferCurrentLength;
+        } else if(decoderErr == SYNCH_LOST_ERROR) {
+            // Try to find the mp3 frame header in the current buffer
+            off_t syncOffset = 0;
+            bool valid = resync(mConfig->pInputBuffer, mConfig->inputBufferCurrentLength,
+                                mFixedHeader, &syncOffset);
+            if (!valid || !syncOffset) {
+                // consume these bytes, we might find a frame header in next buffer
+                syncOffset = mConfig->inputBufferCurrentLength;
+            }
+            // set output buffer to 0
+            mConfig->outputFrameSize = 0;
+            // consume the junk bytes from input buffer
+            mConfig->inputBufferUsedLength = syncOffset;
+        } else {
+            // This is recoverable, just ignore the current frame and
+            // play silence instead.
+            memset(buffer->data(), 0, mConfig->outputFrameSize * sizeof(int16_t));
+            mConfig->inputBufferUsedLength = mInputBuffer->range_length();
+        }
+    }
+
+    buffer->set_range(
+            0, mConfig->outputFrameSize * sizeof(int16_t));
+
+    if ((mPartialBuffer != NULL) && usedPartialFrame) {
+        mPartialBuffer->set_range(
+            mPartialBuffer->range_offset() + mConfig->inputBufferUsedLength,
+            mPartialBuffer->range_length() - mConfig->inputBufferUsedLength);
+        mPartialBuffer->release();
+        mPartialBuffer = NULL;
+    } else {
+        mInputBuffer->set_range(
+            mInputBuffer->range_offset() + mConfig->inputBufferUsedLength,
+            mInputBuffer->range_length() - mConfig->inputBufferUsedLength);
+    }
+
+    if (mInputBuffer->range_length() == 0) {
+        mInputBuffer->release();
+        mInputBuffer = NULL;
+    }
+
+    buffer->meta_data()->setInt64(
+            kKeyTime,
+            mAnchorTimeUs
+                + (mNumFramesOutput * 1000000) / mConfig->samplingRate);
+
+    mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;
+
+    *out = buffer;
+
+    return OK;
+}
+
+}  // namespace android
diff --git a/media/libstagefright/colorconversion/Android.mk b/media/libstagefright/colorconversion/Android.mk
index 62ba40f..f62665e 100644
--- a/media/libstagefright/colorconversion/Android.mk
+++ b/media/libstagefright/colorconversion/Android.mk
@@ -9,6 +9,10 @@ LOCAL_C_INCLUDES := \
         $(TOP)/frameworks/base/include/media/stagefright/openmax \
         $(TOP)/hardware/msm7k
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+        LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= libstagefright_color_conversion
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 5cc3f78..5bda1f6 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,6 +23,12 @@
 #include <media/stagefright/MediaDebug.h>
 #include <media/stagefright/MediaErrors.h>
 
+#ifdef QCOM_HARDWARE
+#include <dlfcn.h>
+#include <OMX_QCOMExtns.h>
+#include <QOMX_AudioExtensions.h>
+#endif
+
 namespace android {
 
 ColorConverter::ColorConverter(
@@ -47,6 +54,9 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef QCOM_HARDWARE
+        case QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka:
+#endif
             return true;
 
         default:
@@ -122,6 +132,58 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
+#ifdef QCOM_HARDWARE
+        case QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka:
+            {
+                void * lib = dlopen("libmm-color-convertor.so", RTLD_NOW);
+
+                if (!lib) {
+                    LOGE("dlopen for libmm-color-convertor failed with errno %d", errno);
+                    return ERROR_UNSUPPORTED;
+                }
+
+
+                typedef int (*convertFn)(ColorConvertParams src, ColorConvertParams dst, uint8_t *adjustedClip);
+
+                convertFn convertNV12Tile = (convertFn)dlsym(lib, "_ZN7android7convertENS_18ColorConvertParamsES0_Ph");
+                if (!convertNV12Tile) {
+                    dlclose(lib);
+                    LOGE("dlsym on libmm-color-convertor failed with errno %d", errno);
+                    return ERROR_UNSUPPORTED;
+                }
+
+                struct ColorConvertParams srcTemp;
+                srcTemp.width = srcWidth;
+                srcTemp.height = srcHeight;
+                srcTemp.cropWidth = src.cropWidth();
+                srcTemp.cropHeight = src.cropHeight();
+                srcTemp.cropLeft = src.mCropLeft;
+                srcTemp.cropRight = src.mCropRight;
+                srcTemp.cropTop = src.mCropTop;
+                srcTemp.cropBottom = src.mCropBottom;
+                srcTemp.data = src.mBits;
+                srcTemp.colorFormat = YCbCr420Tile;
+                srcTemp.flags = 0;
+
+                struct ColorConvertParams dstTemp;
+                dstTemp.width = dstWidth;
+                dstTemp.height = dstHeight;
+                dstTemp.cropWidth = dst.cropWidth();
+                dstTemp.cropHeight = dst.cropHeight();
+                dstTemp.cropLeft = dst.mCropLeft;
+                dstTemp.cropRight = dst.mCropRight;
+                dstTemp.cropTop = dst.mCropTop;
+                dstTemp.cropBottom = dst.mCropBottom;
+                dstTemp.data = dst.mBits;
+                dstTemp.colorFormat = RGB565;
+                dstTemp.flags = 0;
+
+                uint8_t * adjustedClip = initClip();
+                err = convertNV12Tile(srcTemp, dstTemp, adjustedClip);
+                dlclose(lib);
+            }
+            break;
+#endif
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index 3246021..47828ab 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -30,6 +30,11 @@
 
 namespace android {
 
+#ifdef QCOM_HARDWARE
+static const int QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03;
+static const int OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00;
+#endif
+
 SoftwareRenderer::SoftwareRenderer(
         const sp<ANativeWindow> &nativeWindow, const sp<MetaData> &meta)
     : mConverter(NULL),
@@ -62,6 +67,7 @@ SoftwareRenderer::SoftwareRenderer(
     size_t bufWidth, bufHeight;
 
     switch (mColorFormat) {
+#ifndef MISSING_EGL_PIXEL_FORMAT_YV12
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
         {
@@ -70,6 +76,17 @@ SoftwareRenderer::SoftwareRenderer(
             bufHeight = (mCropHeight + 1) & ~1;
             break;
         }
+#endif
+#ifdef QCOM_LEGACY_OMX
+        case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
+        {
+            halFormat = HAL_PIXEL_FORMAT_YCrCb_420_SP;
+            bufWidth = (mCropWidth + 1) & ~1;
+            bufHeight = (mCropHeight + 1) & ~1;
+            mAlign = ((mWidth + 15) & -16) * ((mHeight + 15) & -16);
+            break;
+        }
+#endif
 
         default:
             halFormat = HAL_PIXEL_FORMAT_RGB_565;
@@ -82,6 +99,10 @@ SoftwareRenderer::SoftwareRenderer(
             break;
     }
 
+    LOGI("Buffer color format: 0x%X", mColorFormat);
+    LOGI("Video params: mWidth: %d, mHeight: %d, mCropWidth: %d, mCropHeight: %d, mCropTop: %d, mCropLeft: %d",
+         mWidth, mHeight, mCropWidth, mCropHeight, mCropTop, mCropLeft);
+
     CHECK(mNativeWindow != NULL);
     CHECK(mCropWidth > 0);
     CHECK(mCropHeight > 0);
@@ -162,12 +183,25 @@ void SoftwareRenderer::render(
         const uint8_t *src_u = (const uint8_t *)data + mWidth * mHeight;
         const uint8_t *src_v = src_u + (mWidth / 2 * mHeight / 2);
 
-        uint8_t *dst_y = (uint8_t *)dst;
-        size_t dst_y_size = buf->stride * buf->height;
+#ifdef EXYNOS4210_ENHANCEMENTS
+        void *pYUVBuf[3];
+
+        CHECK_EQ(0, mapper.unlock(buf->handle));
+        CHECK_EQ(0, mapper.lock(
+                buf->handle, GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_YUV_ADDR, bounds, pYUVBuf));
+
+        size_t dst_c_stride = buf->stride / 2;
+        uint8_t *dst_y = (uint8_t *)pYUVBuf[0];
+        uint8_t *dst_v = (uint8_t *)pYUVBuf[1];
+        uint8_t *dst_u = (uint8_t *)pYUVBuf[2];
+#else
         size_t dst_c_stride = ALIGN(buf->stride / 2, 16);
+        size_t dst_y_size = buf->stride * buf->height;
         size_t dst_c_size = dst_c_stride * buf->height / 2;
+        uint8_t *dst_y = (uint8_t *)dst;
         uint8_t *dst_v = dst_y + dst_y_size;
         uint8_t *dst_u = dst_v + dst_c_size;
+#endif
 
         for (int y = 0; y < mCropHeight; ++y) {
             memcpy(dst_y, src_y, mCropWidth);
@@ -185,6 +219,31 @@ void SoftwareRenderer::render(
             dst_u += dst_c_stride;
             dst_v += dst_c_stride;
         }
+#ifdef QCOM_LEGACY_OMX
+    } else if (mColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar) {
+        // Legacy Qualcomm color format
+
+        uint8_t *src_y = (uint8_t *)data;
+        uint8_t *src_u = src_y + mAlign;
+        uint8_t *dst_y = (uint8_t *)dst;
+        uint8_t *dst_u = dst_y + buf->stride * buf->height;
+
+        // Legacy codec doesn't return crop params. Ignore it for speedup :)
+        memcpy(dst_y, src_y, mCropWidth * mCropHeight);
+        memcpy(dst_u, src_u, mCropWidth * mCropHeight / 2);
+
+        /*for(size_t y = 0; y < mCropHeight; ++y) {
+            memcpy(dst_y, src_y, mCropWidth);
+            dst_y += buf->stride;
+            src_y += mWidth;
+
+            if(y & 1) {
+                memcpy(dst_u, src_u, mCropWidth);
+                dst_u += buf->stride;
+                src_u += mWidth;
+            }
+        }*/
+#endif
     } else {
         CHECK_EQ(mColorFormat, OMX_TI_COLOR_FormatYUV420PackedSemiPlanar);
 
@@ -230,4 +289,4 @@ void SoftwareRenderer::render(
     buf = NULL;
 }
 
-}  // namespace android
+}  // namespace android
\ No newline at end of file
diff --git a/media/libstagefright/httplive/LiveSession.cpp b/media/libstagefright/httplive/LiveSession.cpp
index f67cdac..9f47c98 100644
--- a/media/libstagefright/httplive/LiveSession.cpp
+++ b/media/libstagefright/httplive/LiveSession.cpp
@@ -56,10 +56,11 @@ LiveSession::LiveSession(uint32_t flags, bool uidValid, uid_t uid)
       mSeekTimeUs(-1),
       mNumRetries(0),
       mDurationUs(-1),
-      mSeekDone(false),
+      mSeeking(false),
       mDisconnectPending(false),
       mMonitorQueueGeneration(0),
-      mRefreshState(INITIAL_MINIMUM_RELOAD_DELAY) {
+      mRefreshState(INITIAL_MINIMUM_RELOAD_DELAY),
+      mFirstSeqNumber(-1) {
     if (mUIDValid) {
         mHTTPDataSource->setUID(mUID);
     }
@@ -95,17 +96,23 @@ void LiveSession::disconnect() {
     (new AMessage(kWhatDisconnect, id()))->post();
 }
 
-void LiveSession::seekTo(int64_t timeUs) {
+void LiveSession::seekTo(int64_t timeUs, int64_t* newSeekTime ) {
     Mutex::Autolock autoLock(mLock);
-    mSeekDone = false;
+    mSeeking = true;
+    mHTTPDataSource->disconnect();
 
     sp<AMessage> msg = new AMessage(kWhatSeek, id());
     msg->setInt64("timeUs", timeUs);
     msg->post();
 
-    while (!mSeekDone) {
+    while (mSeeking) {
         mCondition.wait(mLock);
+        if( newSeekTime != NULL ) {
+           *newSeekTime = mSeekTimeUs;
+           LOGV("new Seek Time %lld", mSeekTimeUs);
+        }
     }
+    mSeekTimeUs = -1;
 }
 
 void LiveSession::onMessageReceived(const sp<AMessage> &msg) {
@@ -503,13 +510,16 @@ rinse_repeat:
         bool unchanged;
         sp<M3UParser> playlist = fetchPlaylist(url.c_str(), &unchanged);
         if (playlist == NULL) {
+            Mutex::Autolock autoLock(mLock);
             if (unchanged) {
                 // We succeeded in fetching the playlist, but it was
                 // unchanged from the last time we tried.
-            } else {
+            } else if (!mSeeking) {
                 LOGE("failed to load playlist at url '%s'", url.c_str());
                 mDataSource->queueEOS(ERROR_IO);
                 return;
+            } else {
+                LOGV("fetchPlaylist stopped due to seek, let seek complete");
             }
         } else {
             mPlaylist = playlist;
@@ -538,73 +548,23 @@ rinse_repeat:
         mLastPlaylistFetchTimeUs = ALooper::GetNowUs();
     }
 
-    int32_t firstSeqNumberInPlaylist;
     if (mPlaylist->meta() == NULL || !mPlaylist->meta()->findInt32(
-                "media-sequence", &firstSeqNumberInPlaylist)) {
-        firstSeqNumberInPlaylist = 0;
+                "media-sequence", &mFirstSeqNumber)) {
+        mFirstSeqNumber = 0;
     }
 
-    bool seekDiscontinuity = false;
     bool explicitDiscontinuity = false;
     bool bandwidthChanged = false;
 
-    if (mSeekTimeUs >= 0) {
-        if (mPlaylist->isComplete()) {
-            size_t index = 0;
-            int64_t segmentStartUs = 0;
-            while (index < mPlaylist->size()) {
-                sp<AMessage> itemMeta;
-                CHECK(mPlaylist->itemAt(
-                            index, NULL /* uri */, &itemMeta));
-
-                int64_t itemDurationUs;
-                CHECK(itemMeta->findInt64("durationUs", &itemDurationUs));
-
-                if (mSeekTimeUs < segmentStartUs + itemDurationUs) {
-                    break;
-                }
-
-                segmentStartUs += itemDurationUs;
-                ++index;
-            }
-
-            if (index < mPlaylist->size()) {
-                int32_t newSeqNumber = firstSeqNumberInPlaylist + index;
-
-                if (newSeqNumber != mSeqNumber) {
-                    LOGI("seeking to seq no %d", newSeqNumber);
-
-                    mSeqNumber = newSeqNumber;
-
-                    mDataSource->reset();
-
-                    // reseting the data source will have had the
-                    // side effect of discarding any previously queued
-                    // bandwidth change discontinuity.
-                    // Therefore we'll need to treat these seek
-                    // discontinuities as involving a bandwidth change
-                    // even if they aren't directly.
-                    seekDiscontinuity = true;
-                    bandwidthChanged = true;
-                }
-            }
-        }
-
-        mSeekTimeUs = -1;
-
-        Mutex::Autolock autoLock(mLock);
-        mSeekDone = true;
-        mCondition.broadcast();
-    }
 
     if (mSeqNumber < 0) {
-        mSeqNumber = firstSeqNumberInPlaylist;
+        mSeqNumber = mFirstSeqNumber;
     }
 
     int32_t lastSeqNumberInPlaylist =
-        firstSeqNumberInPlaylist + (int32_t)mPlaylist->size() - 1;
+        mFirstSeqNumber + (int32_t)mPlaylist->size() - 1;
 
-    if (mSeqNumber < firstSeqNumberInPlaylist
+    if (mSeqNumber < mFirstSeqNumber
             || mSeqNumber > lastSeqNumberInPlaylist) {
         if (mPrevBandwidthIndex != (ssize_t)bandwidthIndex) {
             // Go back to the previous bandwidth.
@@ -637,8 +597,8 @@ rinse_repeat:
         } else {
             LOGE("Cannot find sequence number %d in playlist "
                  "(contains %d - %d)",
-                 mSeqNumber, firstSeqNumberInPlaylist,
-                 firstSeqNumberInPlaylist + mPlaylist->size() - 1);
+                 mSeqNumber, mFirstSeqNumber,
+                 mFirstSeqNumber + mPlaylist->size() - 1);
 
             mDataSource->queueEOS(ERROR_END_OF_STREAM);
             return;
@@ -650,7 +610,7 @@ rinse_repeat:
     AString uri;
     sp<AMessage> itemMeta;
     CHECK(mPlaylist->itemAt(
-                mSeqNumber - firstSeqNumberInPlaylist,
+                mSeqNumber - mFirstSeqNumber,
                 &uri,
                 &itemMeta));
 
@@ -662,14 +622,19 @@ rinse_repeat:
     sp<ABuffer> buffer;
     status_t err = fetchFile(uri.c_str(), &buffer);
     if (err != OK) {
-        LOGE("failed to fetch .ts segment at url '%s'", uri.c_str());
-        mDataSource->queueEOS(err);
+        Mutex::Autolock autoLock(mLock);
+        if( !mSeeking ) {
+           mDataSource->queueEOS(err);
+           LOGE("failed to fetch .ts segment at url '%s'", uri.c_str());
+        } else {
+           LOGV("fetchFile stopped due to seek, ignore this");
+        }
         return;
     }
 
     CHECK(buffer != NULL);
 
-    err = decryptBuffer(mSeqNumber - firstSeqNumberInPlaylist, buffer);
+    err = decryptBuffer(mSeqNumber - mFirstSeqNumber, buffer);
 
     if (err != OK) {
         LOGE("decryptBuffer failed w/ error %d", err);
@@ -701,7 +666,20 @@ rinse_repeat:
     }
 
     if ((size_t)mPrevBandwidthIndex != bandwidthIndex) {
+#ifdef QCOM_HARDWARE
+        char value[PROPERTY_VALUE_MAX];
+        if(property_get("httplive.enable.discontinuity", value, NULL) &&
+           (!strcasecmp(value, "true") || !strcmp(value, "1")) ) {
+           bandwidthChanged = true;
+           LOGV("discontinuity property set, queue discontinuity");
+        }
+        else {
+           LOGV("BW changed, but do not queue discontinuity");
+           bandwidthChanged = false;
+        }
+#else
         bandwidthChanged = true;
+#endif
     }
 
     if (mPrevBandwidthIndex < 0) {
@@ -710,11 +688,11 @@ rinse_repeat:
         bandwidthChanged = false;
     }
 
-    if (seekDiscontinuity || explicitDiscontinuity || bandwidthChanged) {
+    if (explicitDiscontinuity || bandwidthChanged) {
         // Signal discontinuity.
 
-        LOGI("queueing discontinuity (seek=%d, explicit=%d, bandwidthChanged=%d)",
-             seekDiscontinuity, explicitDiscontinuity, bandwidthChanged);
+        LOGI("queueing discontinuity (explicit=%d, bandwidthChanged=%d)",
+              explicitDiscontinuity, bandwidthChanged);
 
         sp<ABuffer> tmp = new ABuffer(188);
         memset(tmp->data(), 0, tmp->size());
@@ -734,8 +712,7 @@ rinse_repeat:
 }
 
 void LiveSession::onMonitorQueue() {
-    if (mSeekTimeUs >= 0
-            || mDataSource->countQueuedBuffers() < kMaxNumQueuedFragments) {
+    if( mDataSource->countQueuedBuffers() < kMaxNumQueuedFragments) {
         onDownloadNext();
     } else {
         postMonitorQueue(1000000ll);
@@ -891,8 +868,56 @@ void LiveSession::postMonitorQueue(int64_t delayUs) {
 void LiveSession::onSeek(const sp<AMessage> &msg) {
     int64_t timeUs;
     CHECK(msg->findInt64("timeUs", &timeUs));
+    LOGV("onSeek %lld ", timeUs);
 
+    Mutex::Autolock autoLock(mLock);
     mSeekTimeUs = timeUs;
+
+    if (mPlaylist != NULL && mPlaylist->isComplete() ) {
+        size_t index = 0;
+        int64_t segmentStartUs = 0;
+        while (index < mPlaylist->size()) {
+            sp<AMessage> itemMeta;
+            CHECK(mPlaylist->itemAt(
+                       index, NULL /* uri */, &itemMeta));
+
+            int64_t itemDurationUs;
+            CHECK(itemMeta->findInt64("durationUs", &itemDurationUs));
+
+            if (mSeekTimeUs < segmentStartUs + itemDurationUs) {
+                break;
+            }
+
+            segmentStartUs += itemDurationUs;
+            ++index;
+        }
+
+        if (index < mPlaylist->size()) {
+             int32_t newSeqNumber = mFirstSeqNumber + index;
+
+             if (newSeqNumber == mSeqNumber) {
+                 LOGV("Seek not required current seq %d", mSeqNumber);
+                 mSeekTimeUs = -1;
+
+             } else {
+                 mSeqNumber = newSeqNumber;
+                 mDataSource->reset();
+                 mSeekTimeUs = segmentStartUs;
+                 LOGV("Seeking to seq %d new seek time %0.2f secs", newSeqNumber, mSeekTimeUs/1E6);
+             }
+        }
+    } else {
+        mSeekTimeUs = -1;
+        if( mPlaylist != NULL ) {
+           LOGI("Seeking Live Streams is not supported, ignore seek");
+        } else {
+           LOGE("onSeek error - Playlist is NULL");
+        }
+    }
+
+    mSeeking = false;
+    mCondition.broadcast();
+
     postMonitorQueue();
 }
 
diff --git a/media/libstagefright/httplive/M3UParser.cpp b/media/libstagefright/httplive/M3UParser.cpp
index 9df9f59..b9b04d3 100644
--- a/media/libstagefright/httplive/M3UParser.cpp
+++ b/media/libstagefright/httplive/M3UParser.cpp
@@ -157,9 +157,6 @@ status_t M3UParser::parse(const void *_data, size_t size) {
         while (offsetLF < size && data[offsetLF] != '\n') {
             ++offsetLF;
         }
-        if (offsetLF >= size) {
-            break;
-        }
 
         AString line;
         if (offsetLF > offset && data[offsetLF - 1] == '\r') {
diff --git a/media/libstagefright/include/AACDecoder.h b/media/libstagefright/include/AACDecoder.h
index 886a3b7..a5160a4 100644
--- a/media/libstagefright/include/AACDecoder.h
+++ b/media/libstagefright/include/AACDecoder.h
@@ -19,6 +19,7 @@
 #define AAC_DECODER_H_
 
 #include <media/stagefright/MediaSource.h>
+#define AAC_MAX_FORMAT_BLOCK_SIZE 16
 
 struct tPVMP4AudioDecoderExternal;
 
@@ -40,7 +41,6 @@ struct AACDecoder : public MediaSource {
 
 protected:
     virtual ~AACDecoder();
-
 private:
     sp<MetaData>    mMeta;
     sp<MediaSource> mSource;
@@ -57,6 +57,13 @@ private:
     int32_t  mUpsamplingFactor;
 
     MediaBuffer *mInputBuffer;
+    uint8_t mFormatBlock[AAC_MAX_FORMAT_BLOCK_SIZE];
+
+    // Temporary buffer to store incomplete frame buffers
+    uint8_t* mTempInputBuffer;        // data ptr
+    uint32_t mTempBufferTotalSize;    // total size allocated
+    uint32_t mTempBufferDataLen;      // actual data length
+    uint32_t mInputBufferSize;         // input data length
 
     status_t initCheck();
     AACDecoder(const AACDecoder &);
diff --git a/media/libstagefright/include/AwesomePlayer.h b/media/libstagefright/include/AwesomePlayer.h
index 0985f47..7b23110 100644
--- a/media/libstagefright/include/AwesomePlayer.h
+++ b/media/libstagefright/include/AwesomePlayer.h
@@ -297,6 +297,17 @@ private:
         ASSIGN
     };
     void modifyFlags(unsigned value, FlagMode mode);
+    void logStatistics();
+    void logFirstFrame();
+    void logSeek();
+    void logPause();
+    void logCatchUp(int64_t ts, int64_t clock, int64_t delta);
+    void logLate(int64_t ts, int64_t clock, int64_t delta);
+    void logOnTime(int64_t ts, int64_t clock, int64_t delta);
+    void logSyncLoss();
+    int64_t getTimeOfDayUs();
+    bool mVeryFirstFrame;
+    bool mStatistics;
 
     struct TrackStat {
         String8 mMIME;
@@ -316,6 +327,21 @@ private:
         int32_t mVideoHeight;
         uint32_t mFlags;
         Vector<TrackStat> mTracks;
+
+        int64_t mConsecutiveFramesDropped;
+        uint32_t mCatchupTimeStart;
+        uint32_t mNumTimesSyncLoss;
+        uint32_t mMaxEarlyDelta;
+        uint32_t mMaxLateDelta;
+        uint32_t mMaxTimeSyncLoss;
+        uint32_t mTotalFrames;
+        int64_t mFirstFrameLatencyStartUs; //first frame latency start
+        int64_t mLastFrame;
+        int64_t mLastFrameUs;
+        int64_t mFPSSumUs;
+        int64_t mStatisticsFrames;
+        bool mVeryFirstFrame;
+
     } mStats;
 
     AwesomePlayer(const AwesomePlayer &);
diff --git a/media/libstagefright/include/ChromiumHTTPDataSource.h b/media/libstagefright/include/ChromiumHTTPDataSource.h
index 18f8913..bc8563a 100644
--- a/media/libstagefright/include/ChromiumHTTPDataSource.h
+++ b/media/libstagefright/include/ChromiumHTTPDataSource.h
@@ -92,6 +92,8 @@ private:
     sp<DecryptHandle> mDecryptHandle;
     DrmManagerClient *mDrmManagerClient;
 
+    Mutex mSerializer;
+
     void disconnect_l();
 
     status_t connect_l(
diff --git a/media/libstagefright/include/ColorFormat.h b/media/libstagefright/include/ColorFormat.h
new file mode 100644
index 0000000..6b66a2b
--- /dev/null
+++ b/media/libstagefright/include/ColorFormat.h
@@ -0,0 +1,30 @@
+/*************************************************
+   Author: Annamalai Lakshmanan
+   Added Color formats for Samsung OMX Decode
+*************************************************/
+
+enum {
+    HAL_PIXEL_FORMAT_YCbCr_422_P         = 0x100,
+    HAL_PIXEL_FORMAT_YCbCr_420_P         = 0x101,
+    HAL_PIXEL_FORMAT_YCbCr_420_I         = 0x102,
+    HAL_PIXEL_FORMAT_CbYCrY_422_I        = 0x103,
+    HAL_PIXEL_FORMAT_CbYCrY_420_I        = 0x104,
+    HAL_PIXEL_FORMAT_YCbCr_420_SP        = 0x105,
+    HAL_PIXEL_FORMAT_YCrCb_422_SP        = 0x106,
+    // support custom format for zero copy
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_SP = 0x110,
+    HAL_PIXEL_FORMAT_CUSTOM_YCrCb_420_SP = 0x111,
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_SP_TILED = 0x112,
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_422_SP = 0x113,
+    HAL_PIXEL_FORMAT_CUSTOM_YCrCb_422_SP = 0x114,
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_422_I = 0x115,
+    HAL_PIXEL_FORMAT_CUSTOM_YCrCb_422_I = 0x116,
+    HAL_PIXEL_FORMAT_CUSTOM_CbYCrY_422_I = 0x117,
+    HAL_PIXEL_FORMAT_CUSTOM_CrYCbY_422_I = 0x118,
+    HAL_PIXEL_FORMAT_CUSTOM_CbYCr_422_I  = 0x11B,
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_P_SBS_LR = 0x11C,
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_P_SBS_RL = 0x11D,
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_P_TB_LR = 0x11E,
+    HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_P_TB_RL = 0x11F,
+    HAL_PIXEL_FORMAT_CUSTOM_MAX
+};
diff --git a/media/libstagefright/include/ExtendedExtractor.h b/media/libstagefright/include/ExtendedExtractor.h
new file mode 100755
index 0000000..526c76b
--- /dev/null
+++ b/media/libstagefright/include/ExtendedExtractor.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of Code Aurora Forum, Inc. nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef EXTENDED_EXTRACTOR_
+#define EXTENDED_EXTRACTOR_
+
+namespace android {
+
+class DataSource;
+class MediaExtractor;
+class String8;
+
+class ExtendedExtractor
+{
+public:
+    static sp<MediaExtractor> CreateExtractor(const sp<DataSource> &source, const char *mime);
+    static void RegisterSniffers();
+};
+
+}  // namespace android
+
+#endif //EXTENDED_EXTRACTOR_
diff --git a/media/libstagefright/include/LiveSession.h b/media/libstagefright/include/LiveSession.h
index 116ed0e..32613af 100644
--- a/media/libstagefright/include/LiveSession.h
+++ b/media/libstagefright/include/LiveSession.h
@@ -46,7 +46,7 @@ struct LiveSession : public AHandler {
     void disconnect();
 
     // Blocks until seek is complete.
-    void seekTo(int64_t timeUs);
+    void seekTo(int64_t timeUs, int64_t* newSeekTime = NULL);
 
     status_t getDuration(int64_t *durationUs);
     bool isSeekable();
@@ -99,7 +99,7 @@ private:
     Mutex mLock;
     Condition mCondition;
     int64_t mDurationUs;
-    bool mSeekDone;
+    bool mSeeking;
     bool mDisconnectPending;
 
     int32_t mMonitorQueueGeneration;
@@ -114,6 +114,8 @@ private:
 
     uint8_t mPlaylistHash[16];
 
+    int32_t mFirstSeqNumber;
+
     void onConnect(const sp<AMessage> &msg);
     void onDisconnect();
     void onDownloadNext();
diff --git a/media/libstagefright/include/MP3Decoder.h b/media/libstagefright/include/MP3Decoder.h
index 4086fb6..8ff570a 100644
--- a/media/libstagefright/include/MP3Decoder.h
+++ b/media/libstagefright/include/MP3Decoder.h
@@ -53,13 +53,16 @@ private:
     void *mDecoderBuf;
     int64_t mAnchorTimeUs;
     int64_t mNumFramesOutput;
+    uint32_t mFixedHeader;
 
     MediaBuffer *mInputBuffer;
+    MediaBuffer *mPartialBuffer;
 
     void init();
 
     MP3Decoder(const MP3Decoder &);
     MP3Decoder &operator=(const MP3Decoder &);
+    status_t updatePartialFrame();
 };
 
 }  // namespace android
diff --git a/media/libstagefright/include/OMXNodeInstance.h b/media/libstagefright/include/OMXNodeInstance.h
old mode 100644
new mode 100755
index 47ca579..0423227
--- a/media/libstagefright/include/OMXNodeInstance.h
+++ b/media/libstagefright/include/OMXNodeInstance.h
@@ -13,6 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*--------------------------------------------------------------------------
+Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+--------------------------------------------------------------------------*/
 
 #ifndef OMX_NODE_INSTANCE_H_
 
diff --git a/media/libstagefright/include/SampleTable.h b/media/libstagefright/include/SampleTable.h
index 847dff7..3130e8f 100644
--- a/media/libstagefright/include/SampleTable.h
+++ b/media/libstagefright/include/SampleTable.h
@@ -81,7 +81,7 @@ public:
             uint32_t flags);
 
     status_t findThumbnailSample(uint32_t *sample_index);
-
+    uint32_t getNumSyncSamples();
 protected:
     ~SampleTable();
 
diff --git a/media/libstagefright/include/SoftwareRenderer.h b/media/libstagefright/include/SoftwareRenderer.h
index 8f2ea95..3b37d1e 100644
--- a/media/libstagefright/include/SoftwareRenderer.h
+++ b/media/libstagefright/include/SoftwareRenderer.h
@@ -48,6 +48,9 @@ private:
     int32_t mWidth, mHeight;
     int32_t mCropLeft, mCropTop, mCropRight, mCropBottom;
     int32_t mCropWidth, mCropHeight;
+#ifdef QCOM_LEGACY_OMX
+    int32_t mAlign;
+#endif
 
     SoftwareRenderer(const SoftwareRenderer &);
     SoftwareRenderer &operator=(const SoftwareRenderer &);
diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index 20a25d7..e2bcd47 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -369,8 +369,9 @@ status_t MatroskaSource::readBlock() {
     const mkvparser::Block *block = mBlockIter.block();
 
     int64_t timeUs = mBlockIter.blockTimeUs();
+    int frameCount = block->GetFrameCount();
 
-    for (int i = 0; i < block->GetFrameCount(); ++i) {
+    for (int i = 0; i < frameCount; ++i) {
         const mkvparser::Block::Frame &frame = block->GetFrame(i);
 
         MediaBuffer *mbuf = new MediaBuffer(frame.len);
@@ -390,6 +391,27 @@ status_t MatroskaSource::readBlock() {
 
     mBlockIter.advance();
 
+    if (!mBlockIter.eos() && frameCount > 1) {
+        // For files with lacing enabled, we need to amend they kKeyTime of
+        // each frame so that their kKeyTime are advanced accordingly (instead
+        // of being set to the same value). To do this, we need to find out
+        // the duration of the block using the start time of the next block.
+        int64_t duration = mBlockIter.blockTimeUs() - timeUs;
+        int64_t durationPerFrame = duration / frameCount;
+        int64_t durationRemainder = duration % frameCount;
+
+        // We split duration to each of the frame, distributing the remainder (if any)
+        // to the later frames. The later frames are processed first due to the
+        // use of the iterator for the doubly linked list
+        List<MediaBuffer *>::iterator it = mPendingFrames.end();
+        for (int i = frameCount - 1; i >= 0; --i) {
+            --it;
+            int64_t frameRemainder = durationRemainder >= frameCount - i ? 1 : 0;
+            int64_t frameTimeUs = timeUs + durationPerFrame * i + frameRemainder;
+            (*it)->meta_data()->setInt64(kKeyTime, frameTimeUs);
+        }
+    }
+
     return OK;
 }
 
diff --git a/media/libstagefright/mpeg2ts/ATSParser.cpp b/media/libstagefright/mpeg2ts/ATSParser.cpp
index 6cec63a..89ff593 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -34,6 +34,9 @@
 #include <media/stagefright/MetaData.h>
 #include <media/IStreamSource.h>
 #include <utils/KeyedVector.h>
+#ifdef QCOM_HARDWARE
+#include <cutils/properties.h>
+#endif
 
 namespace android {
 
@@ -307,10 +310,44 @@ status_t ATSParser::Program::parseProgramMap(ABitReader *br) {
 
         // The only case we can recover from is if we have two streams
         // and they switched PIDs.
-
         bool success = false;
+#ifdef QCOM_HARDWARE
+        bool bDiscontinuityOn = false;
+        char value[PROPERTY_VALUE_MAX];
+        if (property_get("httplive.enable.discontinuity", value, NULL) &&
+           (!strcasecmp(value, "true") || !strcmp(value, "1")) ) {
+           LOGI("discontinuity property is set");
+           bDiscontinuityOn = true;
+        }
 
-        if (mStreams.size() == 2 && infos.size() == 2) {
+        if (!bDiscontinuityOn) {
+            LOGI("Discontinuity is not enabled, handle PID change");
+            //PIDs can change in between due to BW switches
+            //Set PID based on stream type
+            for (int i = 0; i < infos.size(); i++) {
+                for (int j = 0; j < mStreams.size(); j++){
+
+                    sp<Stream> stream = mStreams.editValueAt(j);
+                    if (infos.itemAt(i).mType == stream->type() &&
+                        infos.itemAt(i).mPID != stream->pid()) {
+
+                        LOGI("PID change for stream %d to %d stream type %x",
+                           stream->pid(), infos.itemAt(i).mPID, infos.itemAt(i).mType);
+                        mStreams.removeItem(stream->pid());
+                        stream->setPID(infos.itemAt(i).mPID);
+                        mStreams.add(stream->pid(), stream);
+                    }
+                }
+            }
+            success = true;
+        }
+#endif
+
+        if (
+#ifdef QCOM_HARDWARE
+                !success &&
+#endif
+                mStreams.size() == 2 && infos.size() == 2) {
             const StreamInfo &info1 = infos.itemAt(0);
             const StreamInfo &info2 = infos.itemAt(1);
 
diff --git a/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp b/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp
index f782ce5..679c6f4 100644
--- a/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp
+++ b/media/libstagefright/mpeg2ts/AnotherPacketSource.cpp
@@ -153,8 +153,17 @@ void AnotherPacketSource::queueAccessUnit(const sp<ABuffer> &buffer) {
 void AnotherPacketSource::queueDiscontinuity(
         ATSParser::DiscontinuityType type,
         const sp<AMessage> &extra) {
+
     Mutex::Autolock autoLock(mLock);
 
+    if (type == ATSParser::DISCONTINUITY_SEEK ) {
+        LOGI("Flushing all Access units for seek");
+        mBuffers.clear();
+        mEOSResult = OK;
+        mCondition.signal();
+        return;
+    }
+
     // Leave only discontinuities in the queue.
     List<sp<ABuffer> >::iterator it = mBuffers.begin();
     while (it != mBuffers.end()) {
diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index d844f3d..bb14f64 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -25,6 +25,10 @@ LOCAL_SHARED_LIBRARIES :=               \
         libstagefright_foundation       \
         libdl
 
+ifeq ($(BOARD_USES_PROPRIETARY_OMX),SAMSUNG)
+LOCAL_CFLAGS     += -DSAMSUNG_OMX
+endif
+
 LOCAL_MODULE:= libstagefright_omx
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
index 3715fe9..b820b6a 100644
--- a/media/libstagefright/omx/OMX.cpp
+++ b/media/libstagefright/omx/OMX.cpp
@@ -251,10 +251,12 @@ status_t OMX::allocateNode(
 
 status_t OMX::freeNode(node_id node) {
     OMXNodeInstance *instance = findInstance(node);
-
-    ssize_t index = mLiveNodes.indexOfKey(instance->observer()->asBinder());
-    CHECK(index >= 0);
-    mLiveNodes.removeItemsAt(index);
+    {
+        Mutex::Autolock autoLock(mLock);
+        ssize_t index = mLiveNodes.indexOfKey(instance->observer()->asBinder());
+        CHECK(index >= 0);
+        mLiveNodes.removeItemsAt(index);
+    }
 
     instance->observer()->asBinder()->unlinkToDeath(this);
 
@@ -262,7 +264,7 @@ status_t OMX::freeNode(node_id node) {
 
     {
         Mutex::Autolock autoLock(mLock);
-        index = mDispatchers.indexOfKey(node);
+        ssize_t index = mDispatchers.indexOfKey(node);
         CHECK(index >= 0);
         mDispatchers.removeItemsAt(index);
     }
diff --git a/media/libstagefright/omx/OMXMaster.cpp b/media/libstagefright/omx/OMXMaster.cpp
index c8278ab..1594dcc 100644
--- a/media/libstagefright/omx/OMXMaster.cpp
+++ b/media/libstagefright/omx/OMXMaster.cpp
@@ -44,13 +44,18 @@ OMXMaster::~OMXMaster() {
 }
 
 void OMXMaster::addVendorPlugin() {
+#ifdef SAMSUNG_OMX
+    addPlugin("libsomxcore.so");
+#else
     addPlugin("libstagefrighthw.so");
+#endif
 }
 
 void OMXMaster::addPlugin(const char *libname) {
     mVendorLibHandle = dlopen(libname, RTLD_NOW);
 
     if (mVendorLibHandle == NULL) {
+        LOGE("dlopen() failed.");
         return;
     }
 
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 0ff398a..26338bb 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -455,7 +455,9 @@ status_t OMXNodeInstance::useGraphicBuffer2_l(
         return UNKNOWN_ERROR;
     }
 
+#ifndef QCOM_HARDWARE
     CHECK_EQ(header->pBuffer, bufferHandle);
+#endif
     CHECK_EQ(header->pAppPrivate, bufferMeta);
 
     *buffer = header;
@@ -599,15 +601,30 @@ status_t OMXNodeInstance::freeBuffer(
         OMX_U32 portIndex, OMX::buffer_id buffer) {
     Mutex::Autolock autoLock(mLock);
 
+#ifndef QCOM_HARDWARE
     removeActiveBuffer(portIndex, buffer);
+#endif
 
     OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *)buffer;
     BufferMeta *buffer_meta = static_cast<BufferMeta *>(header->pAppPrivate);
 
     OMX_ERRORTYPE err = OMX_FreeBuffer(mHandle, portIndex, header);
 
+#ifdef QCOM_HARDWARE
+    if (err == OMX_ErrorNone) {
+        removeActiveBuffer(portIndex, buffer);
+
+        if (buffer_meta) {
+            delete buffer_meta;
+            buffer_meta = NULL;
+        }
+    } else {
+        LOGE("OMX_FreeBuffer failed with err 0x%08x", err);
+    }
+#else
     delete buffer_meta;
     buffer_meta = NULL;
+#endif
 
     return StatusFromOMXError(err);
 }
diff --git a/media/mediaserver/Android.mk b/media/mediaserver/Android.mk
index 0559812..376fc52 100644
--- a/media/mediaserver/Android.mk
+++ b/media/mediaserver/Android.mk
@@ -11,6 +11,16 @@ LOCAL_SHARED_LIBRARIES := \
 	libutils \
 	libbinder
 
+ifeq ($(BOARD_USE_YAMAHAPLAYER),true)
+    LOCAL_CFLAGS += -DYAMAHAPLAYER
+    LOCAL_SHARED_LIBRARIES += libmediayamahaservice
+endif
+
+ifeq ($(BOARD_USE_SECTVOUT),true)
+    LOCAL_CFLAGS += -DSECTVOUT
+	LOCAL_SHARED_LIBRARIES += libTVOut
+endif
+
 base := $(LOCAL_PATH)/../..
 
 LOCAL_C_INCLUDES := \
diff --git a/media/mediaserver/main_mediaserver.cpp b/media/mediaserver/main_mediaserver.cpp
index 7094cfa..2adddf2 100644
--- a/media/mediaserver/main_mediaserver.cpp
+++ b/media/mediaserver/main_mediaserver.cpp
@@ -33,11 +33,29 @@
 
 using namespace android;
 
+#ifdef YAMAHAPLAYER
+namespace android { namespace yamaha { namespace media {
+void InstantiateService(void);
+} } }
+#endif
+
+#ifdef SECTVOUT
+namespace android { namespace SecTVOutService {
+void instantiate(void);
+} }
+#endif
+
 int main(int argc, char** argv)
 {
     sp<ProcessState> proc(ProcessState::self());
     sp<IServiceManager> sm = defaultServiceManager();
     LOGI("ServiceManager: %p", sm.get());
+#ifdef YAMAHAPLAYER
+    yamaha::media::InstantiateService();
+#endif
+#ifdef SECTVOUT
+    SecTVOutService::instantiate();
+#endif
     AudioFlinger::instantiate();
     MediaPlayerService::instantiate();
     CameraService::instantiate();
diff --git a/obex/javax/obex/ClientOperation.java b/obex/javax/obex/ClientOperation.java
index 05b498c..3ef08b2 100644
--- a/obex/javax/obex/ClientOperation.java
+++ b/obex/javax/obex/ClientOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2009, Motorola, Inc.
+ * Copyright (c) 2010-2011, Motorola, Inc.
  *
  * All rights reserved.
  *
@@ -121,6 +121,13 @@ public final class ClientOperation implements Operation, BaseStream {
                     (header).mAuthResp.length);
 
         }
+        if ((header).mConnectionID != null) {
+            mRequestHeader.mConnectionID = new byte[4];
+            System.arraycopy((header).mConnectionID, 0, mRequestHeader.mConnectionID, 0,
+                    4);
+
+        }
+
     }
 
     /**
@@ -723,4 +730,8 @@ public final class ClientOperation implements Operation, BaseStream {
             }
         }
     }
+
+    public void noEndofBody() {
+
+    }
 }
diff --git a/obex/javax/obex/Operation.java b/obex/javax/obex/Operation.java
index 25656ed..05cecc5 100644
--- a/obex/javax/obex/Operation.java
+++ b/obex/javax/obex/Operation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2009, Motorola, Inc.
+ * Copyright (c) 2010-2011, Motorola, Inc.
  *
  * All rights reserved.
  *
@@ -175,6 +175,8 @@ public interface Operation {
 
     DataOutputStream openDataOutputStream() throws IOException;
 
+    void noEndofBody();
+
     void close() throws IOException;
 
     int getMaxPacketSize();
diff --git a/obex/javax/obex/ServerOperation.java b/obex/javax/obex/ServerOperation.java
index d1476d2..5ddb933 100644
--- a/obex/javax/obex/ServerOperation.java
+++ b/obex/javax/obex/ServerOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2009, Motorola, Inc.
+ * Copyright (c) 2010-2011, Motorola, Inc.
  *
  * All rights reserved.
  *
@@ -88,6 +88,8 @@ public final class ServerOperation implements Operation, BaseStream {
 
     private boolean mHasBody;
 
+    private boolean mEndofBody = true;
+
     /**
      * Creates new ServerOperation
      * @param p the parent that created this object
@@ -364,23 +366,30 @@ public final class ServerOperation implements Operation, BaseStream {
                  * (End of Body) otherwise, we need to send 0x48 (Body)
                  */
                 if ((finalBitSet) || (mPrivateOutput.isClosed())) {
-                    out.write(0x49);
+                    if (mEndofBody) {
+                        out.write((byte)0x49);
+                        bodyLength += 3;
+                        out.write((byte)(bodyLength >> 8));
+                        out.write((byte)bodyLength);
+                        out.write(body);
+                    }
                 } else {
                     out.write(0x48);
+                    bodyLength += 3;
+                    out.write((byte)(bodyLength >> 8));
+                    out.write((byte)bodyLength);
+                    out.write(body);
                 }
-
-                bodyLength += 3;
-                out.write((byte)(bodyLength >> 8));
-                out.write((byte)bodyLength);
-                out.write(body);
             }
         }
 
         if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
-            out.write(0x49);
-            orginalBodyLength = 3;
-            out.write((byte)(orginalBodyLength >> 8));
-            out.write((byte)orginalBodyLength);
+            if (mEndofBody) {
+               out.write(0x49);
+               orginalBodyLength = 3;
+               out.write((byte)(orginalBodyLength >> 8));
+               out.write((byte)orginalBodyLength);
+           }
 
         }
 
@@ -711,4 +720,9 @@ public final class ServerOperation implements Operation, BaseStream {
     public void streamClosed(boolean inStream) throws IOException {
 
     }
+
+    public void noEndofBody() {
+        mEndofBody = false;
+    }
+
 }
diff --git a/opengl/include/EGL/eglext.h b/opengl/include/EGL/eglext.h
index ca11863..8034f74 100644
--- a/opengl/include/EGL/eglext.h
+++ b/opengl/include/EGL/eglext.h
@@ -229,6 +229,20 @@ struct ANativeWindowBuffer;
 #define EGL_NATIVE_BUFFER_ANDROID               0x3140  /* eglCreateImageKHR target */
 #endif
 
+#ifdef QCOM_HARDWARE
+#ifndef EGL_EGLEXT_PROTOTYPES
+#define EGL_EGLEXT_PROTOTYPES 1
+#endif
+
+#ifndef EGL_ANDROID_get_render_buffer
+#define EGL_ANDROID_get_render_buffer 1
+#ifdef EGL_EGLEXT_PROTOTYPES
+EGLAPI EGLClientBuffer EGLAPIENTRY eglGetRenderBufferANDROID(EGLDisplay dpy, EGLSurface draw);
+#endif
+typedef EGLClientBuffer (EGLAPIENTRYP PFNEGLGETRENDERBUFFERANDROIDPROC) (EGLDisplay dpy, EGLSurface draw);
+#endif
+#endif // QCOM_HARDWARE
+
 #ifndef EGL_ANDROID_recordable
 #define EGL_ANDROID_recordable 1
 #define EGL_RECORDABLE_ANDROID                  0x3142  /* EGLConfig attribute */
diff --git a/opengl/include/GLES/glext.h b/opengl/include/GLES/glext.h
index 65ab5e4..05ac93e 100644
--- a/opengl/include/GLES/glext.h
+++ b/opengl/include/GLES/glext.h
@@ -213,7 +213,11 @@ typedef void* GLeglImageOES;
 
 /* GL_OES_EGL_image_external */
 #ifndef GL_OES_EGL_image_external
+#ifdef MISSING_EGL_EXTERNAL_IMAGE
+#define GL_TEXTURE_EXTERNAL_OES                                 0x0DE1
+#else
 #define GL_TEXTURE_EXTERNAL_OES                                 0x8D65
+#endif
 #define GL_SAMPLER_EXTERNAL_OES                                 0x8D66
 #define GL_TEXTURE_BINDING_EXTERNAL_OES                         0x8D67
 #define GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES                     0x8D68
diff --git a/opengl/include/GLES2/gl2ext.h b/opengl/include/GLES2/gl2ext.h
index 9db4e25..82befc2 100644
--- a/opengl/include/GLES2/gl2ext.h
+++ b/opengl/include/GLES2/gl2ext.h
@@ -16,6 +16,10 @@ extern "C" {
 #   define GL_APIENTRYP GL_APIENTRY*
 #endif
 
+#ifdef QCOM_HARDWARE
+#define GL_GLEXT_PROTOTYPES
+#endif
+
 /*------------------------------------------------------------------------*
  * OES extension tokens
  *------------------------------------------------------------------------*/
@@ -148,7 +152,11 @@ typedef void* GLeglImageOES;
 
 /* GL_OES_EGL_image_external */
 #ifndef GL_OES_EGL_image_external
+#ifdef MISSING_EGL_EXTERNAL_IMAGE
+#define GL_TEXTURE_EXTERNAL_OES                                 0x0DE1
+#else
 #define GL_TEXTURE_EXTERNAL_OES                                 0x8D65
+#endif
 #define GL_SAMPLER_EXTERNAL_OES                                 0x8D66
 #define GL_TEXTURE_BINDING_EXTERNAL_OES                         0x8D67
 #define GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES                     0x8D68
diff --git a/opengl/java/android/opengl/GLSurfaceView.java b/opengl/java/android/opengl/GLSurfaceView.java
index 8fd866c..6787c77 100644
--- a/opengl/java/android/opengl/GLSurfaceView.java
+++ b/opengl/java/android/opengl/GLSurfaceView.java
@@ -1125,6 +1125,7 @@ public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback
                 int error = mEgl.eglGetError();
                 switch(error) {
                 case EGL11.EGL_CONTEXT_LOST:
+                case EGL10.EGL_BAD_ALLOC:
                     return false;
                 case EGL10.EGL_BAD_NATIVE_WINDOW:
                     // The native window is bad, probably because the
diff --git a/opengl/libagl/Android.mk b/opengl/libagl/Android.mk
index 15e58f2..ce55093 100644
--- a/opengl/libagl/Android.mk
+++ b/opengl/libagl/Android.mk
@@ -44,6 +44,9 @@ endif
 ifeq ($(TARGET_ARCH)-$(ARCH_ARM_HAVE_TLS_REGISTER),arm-true)
     LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
 endif
+ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+    LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+endif
 LOCAL_C_INCLUDES += bionic/libc/private
 
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/egl
diff --git a/opengl/libagl/egl.cpp b/opengl/libagl/egl.cpp
index 6d4098c..4c6d306 100644
--- a/opengl/libagl/egl.cpp
+++ b/opengl/libagl/egl.cpp
@@ -165,6 +165,9 @@ struct egl_surface_t
     virtual     EGLint      getSwapBehavior() const;
     virtual     EGLBoolean  swapBuffers();
     virtual     EGLBoolean  setSwapRectangle(EGLint l, EGLint t, EGLint w, EGLint h);
+#ifdef QCOM_HARDWARE
+    virtual     EGLClientBuffer getRenderBuffer() const;
+#endif
 protected:
     GGLSurface              depth;
 };
@@ -208,6 +211,11 @@ EGLBoolean egl_surface_t::setSwapRectangle(
 {
     return EGL_FALSE;
 }
+#ifdef QCOM_HARDWARE
+EGLClientBuffer egl_surface_t::getRenderBuffer() const {
+    return 0;
+}
+#endif
 
 // ----------------------------------------------------------------------------
 
@@ -233,6 +241,9 @@ struct egl_window_surface_v2_t : public egl_surface_t
     virtual     EGLint      getRefreshRate() const;
     virtual     EGLint      getSwapBehavior() const;
     virtual     EGLBoolean  setSwapRectangle(EGLint l, EGLint t, EGLint w, EGLint h);
+#ifdef QCOM_HARDWARE
+    virtual     EGLClientBuffer  getRenderBuffer() const;
+#endif
     
 private:
     status_t lock(ANativeWindowBuffer* buf, int usage, void** vaddr);
@@ -571,6 +582,13 @@ EGLBoolean egl_window_surface_v2_t::setSwapRectangle(
     return EGL_TRUE;
 }
 
+#ifdef QCOM_HARDWARE
+EGLClientBuffer egl_window_surface_v2_t::getRenderBuffer() const
+{
+    return buffer;
+}
+#endif
+
 EGLBoolean egl_window_surface_v2_t::bindDrawSurface(ogles_context_t* gl)
 {
     GGLSurface buffer;
@@ -800,6 +818,9 @@ static char const * const gExtensionsString =
         // "KHR_image_pixmap "
         "EGL_ANDROID_image_native_buffer "
         "EGL_ANDROID_swap_rectangle "
+#ifdef QCOM_HARDWARE
+        "EGL_ANDROID_get_render_buffer "
+#endif
         ;
 
 // ----------------------------------------------------------------------------
@@ -852,6 +873,10 @@ static const extention_map_t gExtentionMap[] = {
             (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR }, 
     { "eglSetSwapRectangleANDROID", 
             (__eglMustCastToProperFunctionPointerType)&eglSetSwapRectangleANDROID }, 
+#ifdef QCOM_HARDWARE
+    { "eglGetRenderBufferANDROID",
+            (__eglMustCastToProperFunctionPointerType)&eglGetRenderBufferANDROID },
+#endif
 };
 
 /*
@@ -2077,3 +2102,20 @@ EGLBoolean eglSetSwapRectangleANDROID(EGLDisplay dpy, EGLSurface draw,
 
     return EGL_TRUE;
 }
+
+#ifdef QCOM_HARDWARE
+EGLClientBuffer eglGetRenderBufferANDROID(EGLDisplay dpy, EGLSurface draw)
+{
+    if (egl_display_t::is_valid(dpy) == EGL_FALSE)
+        return setError(EGL_BAD_DISPLAY, (EGLClientBuffer)0);
+
+    egl_surface_t* d = static_cast<egl_surface_t*>(draw);
+    if (!d->isValid())
+        return setError(EGL_BAD_SURFACE, (EGLClientBuffer)0);
+    if (d->dpy != dpy)
+        return setError(EGL_BAD_DISPLAY, (EGLClientBuffer)0);
+
+    // post the surface
+    return d->getRenderBuffer();
+}
+#endif
diff --git a/opengl/libagl/state.cpp b/opengl/libagl/state.cpp
index 90e9612..7321182 100644
--- a/opengl/libagl/state.cpp
+++ b/opengl/libagl/state.cpp
@@ -191,9 +191,11 @@ static void enable_disable(ogles_context_t* c, GLenum cap, int enabled)
         // these need to fall through into the rasterizer
         c->rasterizer.procs.enableDisable(c, cap, enabled);
         break;
+#ifndef MISSING_EGL_EXTERNAL_IMAGE
     case GL_TEXTURE_EXTERNAL_OES:
         c->rasterizer.procs.enableDisable(c, GL_TEXTURE_2D, enabled);
         break;
+#endif
 
     case GL_MULTISAMPLE:
     case GL_SAMPLE_ALPHA_TO_COVERAGE:
diff --git a/opengl/libs/Android.mk b/opengl/libs/Android.mk
index 9c1a10e..f76e353 100644
--- a/opengl/libs/Android.mk
+++ b/opengl/libs/Android.mk
@@ -16,19 +16,22 @@ LOCAL_SRC_FILES:= 	       \
 	EGL/trace.cpp              \
 	EGL/getProcAddress.cpp.arm \
 	EGL/Loader.cpp 	       \
-#
 
 LOCAL_SHARED_LIBRARIES += libcutils libutils libGLESv2_dbg
 LOCAL_LDLIBS := -lpthread -ldl
 LOCAL_MODULE:= libEGL
 LOCAL_LDFLAGS += -Wl,--exclude-libs=ALL
 LOCAL_SHARED_LIBRARIES += libdl
+
 # Bionic's private TLS header relies on the ARCH_ARM_HAVE_TLS_REGISTER to
 # select the appropriate TLS codepath
 ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
     LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
 endif
 # we need to access the private Bionic header <bionic_tls.h>
+ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+    LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+endif
 LOCAL_C_INCLUDES += bionic/libc/private
 
 LOCAL_CFLAGS += -DLOG_TAG=\"libEGL\"
@@ -36,14 +39,6 @@ LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 LOCAL_CFLAGS += -fvisibility=hidden
 LOCAL_CFLAGS += -DEGL_TRACE=1
 
-ifeq ($(TARGET_BOARD_PLATFORM),msm7k)
-LOCAL_CFLAGS += -DADRENO130=1
-endif
-
-ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
-  LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
-endif
-
 ifneq ($(MAX_EGL_CACHE_ENTRY_SIZE),)
   LOCAL_CFLAGS += -DMAX_EGL_CACHE_ENTRY_SIZE=$(MAX_EGL_CACHE_ENTRY_SIZE)
 endif
@@ -77,9 +72,7 @@ endif
 
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES:= 		\
-	GLES_CM/gl.cpp.arm 	\
-#
+LOCAL_SRC_FILES := GLES_CM/gl.cpp.arm
 
 LOCAL_SHARED_LIBRARIES += libcutils libEGL
 LOCAL_LDLIBS := -lpthread -ldl
@@ -90,16 +83,15 @@ LOCAL_SHARED_LIBRARIES += libdl
 ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
     LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
 endif
+ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+    LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+endif
 LOCAL_C_INCLUDES += bionic/libc/private
 
 LOCAL_CFLAGS += -DLOG_TAG=\"libGLESv1\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 LOCAL_CFLAGS += -fvisibility=hidden
 
-ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
-  LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
-endif
-
 include $(BUILD_SHARED_LIBRARY)
 
 
@@ -109,9 +101,7 @@ include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES:= 		\
-	GLES2/gl2.cpp.arm 	\
-#
+LOCAL_SRC_FILES := GLES2/gl2.cpp.arm
 
 LOCAL_SHARED_LIBRARIES += libcutils libEGL
 LOCAL_LDLIBS := -lpthread -ldl
@@ -122,16 +112,15 @@ LOCAL_SHARED_LIBRARIES += libdl
 ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
     LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
 endif
+ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+    LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+endif
 LOCAL_C_INCLUDES += bionic/libc/private
 
 LOCAL_CFLAGS += -DLOG_TAG=\"libGLESv2\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 LOCAL_CFLAGS += -fvisibility=hidden
 
-ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
-  LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
-endif
-
 include $(BUILD_SHARED_LIBRARY)
 
 ###############################################################################
@@ -140,9 +129,7 @@ include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES:= 		\
-	ETC1/etc1.cpp 	\
-#
+LOCAL_SRC_FILES := ETC1/etc1.cpp
 
 LOCAL_LDLIBS := -lpthread -ldl
 LOCAL_MODULE:= libETC1
@@ -155,9 +142,7 @@ include $(BUILD_HOST_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES:= 		\
-	ETC1/etc1.cpp 	\
-#
+LOCAL_SRC_FILES := ETC1/etc1.cpp
 
 LOCAL_LDLIBS := -lpthread -ldl
 LOCAL_MODULE:= libETC1
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 2b0ed5d..7310093 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -69,6 +69,10 @@ static const extention_map_t sExtentionMap[] = {
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
     { "eglGetSystemTimeNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
+#ifdef QCOM_HARDWARE
+    { "eglGetRenderBufferANDROID",
+            (__eglMustCastToProperFunctionPointerType)&eglGetRenderBufferANDROID },
+#endif
 };
 
 // accesses protected by sExtensionMapMutex
@@ -1444,6 +1448,26 @@ EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute
 
 /* ANDROID extensions entry-point go here */
 
+#ifdef QCOM_HARDWARE
+EGLClientBuffer eglGetRenderBufferANDROID(EGLDisplay dpy, EGLSurface draw)
+{
+    clearError();
+
+    egl_display_t const * const dp = validate_display(dpy);
+    if (!dp) return EGL_FALSE;
+
+    SurfaceRef _s(dp, draw);
+    if (!_s.get()) return setError(EGL_BAD_SURFACE, (EGLClientBuffer*)0);
+
+    egl_surface_t const * const s = get_surface(draw);
+    if (s->cnx->egl.eglGetRenderBufferANDROID) {
+        return s->cnx->egl.eglGetRenderBufferANDROID(
+                dp->disp[s->impl].dpy, s->surface);
+    }
+    return setError(EGL_BAD_DISPLAY, (EGLClientBuffer*)0);
+}
+#endif
+
 // ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
diff --git a/opengl/libs/EGL/egl_display.cpp b/opengl/libs/EGL/egl_display.cpp
index 31119f9..c8916b8 100644
--- a/opengl/libs/EGL/egl_display.cpp
+++ b/opengl/libs/EGL/egl_display.cpp
@@ -51,6 +51,9 @@ static char const * const sExtensionString  =
         "EGL_KHR_fence_sync "
         "EGL_NV_system_time "
         "EGL_ANDROID_image_native_buffer "      // mandatory
+#ifdef QCOM_HARDWARE
+        "EGL_ANDROID_get_render_buffer "
+#endif
         ;
 
 // extensions not exposed to applications but used by the ANDROID system
diff --git a/opengl/libs/GLES2/gl2.cpp b/opengl/libs/GLES2/gl2.cpp
index fee4609..27ec907 100644
--- a/opengl/libs/GLES2/gl2.cpp
+++ b/opengl/libs/GLES2/gl2.cpp
@@ -43,9 +43,18 @@ using namespace android;
 
 #if USE_FAST_TLS_KEY
 
+    #ifdef HAVE_TEGRA_ERRATA_657451
+        #define MUNGE_TLS(_tls) \
+            "bfi " #_tls ", " #_tls ", #20, #1 \n" \
+            "bic " #_tls ", " #_tls ", #1 \n"
+    #else
+        #define MUNGE_TLS(_tls) "\n"
+    #endif
+
     #ifdef HAVE_ARM_TLS_REGISTER
         #define GET_TLS(reg) \
-            "mrc p15, 0, " #reg ", c13, c0, 3 \n"
+            "mrc p15, 0, " #reg ", c13, c0, 3 \n" \
+            MUNGE_TLS(reg)
     #else
         #define GET_TLS(reg) \
             "mov   " #reg ", #0xFFFF0FFF      \n"  \
diff --git a/opengl/libs/GLES_CM/gl.cpp b/opengl/libs/GLES_CM/gl.cpp
index ee29f12..b62515b 100644
--- a/opengl/libs/GLES_CM/gl.cpp
+++ b/opengl/libs/GLES_CM/gl.cpp
@@ -97,9 +97,18 @@ GL_API void GL_APIENTRY glWeightPointerOESBounds(GLint size, GLenum type,
 
 #if USE_FAST_TLS_KEY && !CHECK_FOR_GL_ERRORS
 
+    #ifdef HAVE_TEGRA_ERRATA_657451
+        #define MUNGE_TLS(_tls) \
+            "bfi " #_tls ", " #_tls ", #20, #1 \n" \
+            "bic " #_tls ", " #_tls ", #1 \n"
+    #else
+        #define MUNGE_TLS(_tls) "\n"
+    #endif
+
     #ifdef HAVE_ARM_TLS_REGISTER
         #define GET_TLS(reg) \
-            "mrc p15, 0, " #reg ", c13, c0, 3 \n"
+            "mrc p15, 0, " #reg ", c13, c0, 3 \n" \
+            MUNGE_TLS(reg)
     #else
         #define GET_TLS(reg) \
             "mov   " #reg ", #0xFFFF0FFF      \n"  \
diff --git a/packages/SystemUI/src/com/android/systemui/usb/StorageNotification.java b/packages/SystemUI/src/com/android/systemui/usb/StorageNotification.java
index 7dff549..3039b7c 100644
--- a/packages/SystemUI/src/com/android/systemui/usb/StorageNotification.java
+++ b/packages/SystemUI/src/com/android/systemui/usb/StorageNotification.java
@@ -16,6 +16,7 @@
 
 package com.android.systemui.usb;
 
+import android.app.KeyguardManager;
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
@@ -126,8 +127,9 @@ public class StorageNotification extends StorageEventListener {
     }
 
     private void onStorageStateChangedAsync(String path, String oldState, String newState) {
+        boolean isPrimary = Environment.getExternalStorageDirectory().getPath().equals(path);
         Slog.i(TAG, String.format(
-                "Media {%s} state changed from {%s} -> {%s}", path, oldState, newState));
+                "Media {%s} state changed from {%s} -> {%s} (primary = %b)", path, oldState, newState, isPrimary));
         if (newState.equals(Environment.MEDIA_SHARED)) {
             /*
              * Storage is now shared. Modify the UMS notification
@@ -227,25 +229,25 @@ public class StorageNotification extends StorageEventListener {
         } else if (newState.equals(Environment.MEDIA_REMOVED)) {
             /*
              * Storage has been removed. Show nomedia media notification,
-             * and disable UMS notification regardless of connection state.
+             * and disable UMS notification if the removed storage is the primary storage.
              */
             setMediaStorageNotification(
                     com.android.internal.R.string.ext_media_nomedia_notification_title,
                     com.android.internal.R.string.ext_media_nomedia_notification_message,
                     com.android.internal.R.drawable.stat_notify_sdcard_usb,
-                    true, false, null);
-            updateUsbMassStorageNotification(false);
+                    true, !isPrimary, null);
+            updateUsbMassStorageNotification(isPrimary ? false : mUmsAvailable);
         } else if (newState.equals(Environment.MEDIA_BAD_REMOVAL)) {
             /*
              * Storage has been removed unsafely. Show bad removal media notification,
-             * and disable UMS notification regardless of connection state.
+             * and disable UMS notification if the removed storage is the primary storage.
              */
             setMediaStorageNotification(
                     com.android.internal.R.string.ext_media_badremoval_notification_title,
                     com.android.internal.R.string.ext_media_badremoval_notification_message,
                     com.android.internal.R.drawable.stat_sys_warning,
                     true, true, null);
-            updateUsbMassStorageNotification(false);
+            updateUsbMassStorageNotification(isPrimary ? false : mUmsAvailable);
         } else {
             Slog.w(TAG, String.format("Ignoring unknown state {%s}", newState));
         }
@@ -320,7 +322,11 @@ public class StorageNotification extends StorageEventListener {
                 Settings.Secure.ADB_ENABLED,
                 0);
 
-            if (POP_UMS_ACTIVITY_ON_CONNECT && !adbOn) {
+            KeyguardManager keyguardManager =
+                    (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
+
+            if (POP_UMS_ACTIVITY_ON_CONNECT && !adbOn &&
+                !keyguardManager.isKeyguardLocked() && !keyguardManager.isKeyguardSecure()) {
                 // Pop up a full-screen alert to coach the user through enabling UMS. The average
                 // user has attached the device to USB either to charge the phone (in which case
                 // this is harmless) or transfer files, and in the latter case this alert saves
diff --git a/services/audioflinger/Android.mk b/services/audioflinger/Android.mk
index fa49592..83d18ac 100644
--- a/services/audioflinger/Android.mk
+++ b/services/audioflinger/Android.mk
@@ -30,4 +30,16 @@ LOCAL_STATIC_LIBRARIES := \
 
 LOCAL_MODULE:= libaudioflinger
 
+ifeq ($(BOARD_USE_MOTO_DOCK_HACK),true)
+   LOCAL_CFLAGS += -DMOTO_DOCK_HACK
+endif
+
+ifeq ($(BOARD_HAS_SAMSUNG_VOLUME_BUG),true)
+   LOCAL_CFLAGS += -DHAS_SAMSUNG_VOLUME_BUG
+endif
+
+ifeq ($(ARCH_ARM_HAVE_NEON),true)
+   LOCAL_CFLAGS += -D__ARM_HAVE_NEON
+endif
+
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index e35435e..3ac04f5 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -21,4 +21,8 @@ LOCAL_SHARED_LIBRARIES:= \
 
 LOCAL_MODULE:= libcameraservice
 
+ifeq ($(BOARD_HAVE_HTC_FFC), true)
+LOCAL_CFLAGS += -DBOARD_HAVE_HTC_FFC
+endif
+
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/camera/libcameraservice/CameraHardwareInterface.h b/services/camera/libcameraservice/CameraHardwareInterface.h
old mode 100644
new mode 100755
index c3ced4c2..1d75a40
--- a/services/camera/libcameraservice/CameraHardwareInterface.h
+++ b/services/camera/libcameraservice/CameraHardwareInterface.h
@@ -115,6 +115,15 @@ public:
         LOGV("%s(%s) buf %p", __FUNCTION__, mName.string(), buf.get());
 
         if (mDevice->ops->set_preview_window) {
+#ifdef QCOM_HARDWARE
+#ifndef NO_UPDATE_PREVIEW
+            LOGV("%s buf %p mPreviewWindow %p", __FUNCTION__, buf.get(), mPreviewWindow.get());
+            if (mPreviewWindow.get() && (buf.get() != mPreviewWindow.get())) {
+                 mDevice->ops->set_preview_window(mDevice, 0);
+            }
+#endif
+#endif
+
             mPreviewWindow = buf;
             mHalPreviewWindow.user = this;
             LOGV("%s &mHalPreviewWindow %p mHalPreviewWindow.user %p", __FUNCTION__,
@@ -458,13 +467,17 @@ private:
         LOGV("%s", __FUNCTION__);
         CameraHardwareInterface *__this =
                 static_cast<CameraHardwareInterface *>(user);
-        sp<CameraHeapMemory> mem(static_cast<CameraHeapMemory *>(data->handle));
-        if (index >= mem->mNumBufs) {
+        if (data != NULL) {
+          sp<CameraHeapMemory> mem(static_cast<CameraHeapMemory *>(data->handle));
+          if (index >= mem->mNumBufs) {
             LOGE("%s: invalid buffer index %d, max allowed is %d", __FUNCTION__,
                  index, mem->mNumBufs);
             return;
+          }
+          __this->mDataCb(msg_type, mem->mBuffers[index], metadata, __this->mCbUser);
+        } else {
+          __this->mDataCb(msg_type, NULL, metadata, __this->mCbUser);
         }
-        __this->mDataCb(msg_type, mem->mBuffers[index], metadata, __this->mCbUser);
     }
 
     static void __data_cb_timestamp(nsecs_t timestamp, int32_t msg_type,
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index 52d9bf3..c03238e 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -21,6 +21,8 @@
 #include <stdio.h>
 #include <sys/types.h>
 #include <pthread.h>
+#include <unistd.h>
+#include <fcntl.h>
 
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
@@ -36,7 +38,7 @@
 #include <utils/Errors.h>
 #include <utils/Log.h>
 #include <utils/String16.h>
-
+#include <system/camera.h>
 #include "CameraService.h"
 #include "CameraHardwareInterface.h"
 
@@ -66,6 +68,23 @@ static int getCallingUid() {
 
 // ----------------------------------------------------------------------------
 
+#if defined(BOARD_HAVE_HTC_FFC)
+#define HTC_SWITCH_CAMERA_FILE_PATH "/sys/android_camera2/htcwc"
+static void htcCameraSwitch(int cameraId)
+{
+    char buffer[16];
+    int fd;
+
+    if (access(HTC_SWITCH_CAMERA_FILE_PATH, W_OK) == 0) {
+        snprintf(buffer, sizeof(buffer), "%d", cameraId);
+
+        fd = open(HTC_SWITCH_CAMERA_FILE_PATH, O_WRONLY);
+        write(fd, buffer, strlen(buffer));
+        close(fd);
+    }
+}
+#endif
+
 // This is ugly and only safe if we never re-create the CameraService, but
 // should be ok for now.
 static CameraService *gCameraService;
@@ -157,6 +176,10 @@ sp<ICamera> CameraService::connect(
         return NULL;
     }
 
+#if defined(BOARD_HAVE_HTC_FFC)
+    htcCameraSwitch(cameraId);
+#endif
+
     Mutex::Autolock lock(mServiceLock);
     if (mClient[cameraId] != 0) {
         client = mClient[cameraId].promote();
@@ -299,8 +322,19 @@ void CameraService::loadSound() {
     LOG1("CameraService::loadSound ref=%d", mSoundRef);
     if (mSoundRef++) return;
 
-    mSoundPlayer[SOUND_SHUTTER] = newMediaPlayer("/system/media/audio/ui/camera_click.ogg");
-    mSoundPlayer[SOUND_RECORDING] = newMediaPlayer("/system/media/audio/ui/VideoRecord.ogg");
+    char value[PROPERTY_VALUE_MAX];
+    property_get("ro.camera.sound.disabled", value, "0");
+    int systemMute = atoi(value);
+    property_get("persist.sys.camera-mute", value, "0");
+    int userMute = atoi(value);
+
+    if(!systemMute && !userMute) {
+        mSoundPlayer[SOUND_SHUTTER] = newMediaPlayer("/system/media/audio/ui/camera_click.ogg");
+        mSoundPlayer[SOUND_RECORDING] = newMediaPlayer("/system/media/audio/ui/VideoRecord.ogg");
+    } else {
+        mSoundPlayer[SOUND_SHUTTER] = NULL;
+        mSoundPlayer[SOUND_RECORDING] = NULL;
+    }
 }
 
 void CameraService::releaseSound() {
@@ -342,6 +376,7 @@ CameraService::Client::Client(const sp<CameraService>& cameraService,
     mCameraFacing = cameraFacing;
     mClientPid = clientPid;
     mMsgEnabled = 0;
+    mburstCnt = 0;
     mSurface = 0;
     mPreviewWindow = 0;
     mHardware->setCallbacks(notifyCallback,
@@ -350,8 +385,11 @@ CameraService::Client::Client(const sp<CameraService>& cameraService,
                             (void *)cameraId);
 
     // Enable zoom, error, focus, and metadata messages by default
-    enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS |
-                  CAMERA_MSG_PREVIEW_METADATA);
+    enableMsgType(CAMERA_MSG_ERROR | CAMERA_MSG_ZOOM | CAMERA_MSG_FOCUS
+#ifndef QCOM_HARDWARE
+                  | CAMERA_MSG_PREVIEW_METADATA
+#endif
+                  );
 
     // Callback is disabled by default
     mPreviewCallbackFlag = CAMERA_FRAME_CALLBACK_FLAG_NOOP;
@@ -359,6 +397,9 @@ CameraService::Client::Client(const sp<CameraService>& cameraService,
     mPlayShutterSound = true;
     cameraService->setCameraBusy(cameraId);
     cameraService->loadSound();
+#ifdef QCOM_HARDWARE
+    mFaceDetection = false;
+#endif
     LOG1("Client::Client X (pid %d)", callingPid);
 }
 
@@ -498,9 +539,13 @@ void CameraService::Client::disconnect() {
 
     // Release the held ANativeWindow resources.
     if (mPreviewWindow != 0) {
+#ifdef QCOM_HARDWARE
+#ifndef NO_UPDATE_PREVIEW
+        mHardware->setPreviewWindow(0);
+#endif
+#endif
         disconnectWindow(mPreviewWindow);
         mPreviewWindow = 0;
-        mHardware->setPreviewWindow(mPreviewWindow);
     }
     mHardware.clear();
 
@@ -540,6 +585,15 @@ status_t CameraService::Client::setPreviewWindow(const sp<IBinder>& binder,
             native_window_set_buffers_transform(window.get(), mOrientation);
             result = mHardware->setPreviewWindow(window);
         }
+#ifdef QCOM_HARDWARE
+#ifndef NO_UPDATE_PREVIEW
+    } else {
+        if (window != 0) {
+            native_window_set_buffers_transform(window.get(), mOrientation);
+        }
+        result = mHardware->setPreviewWindow(window);
+#endif
+#endif
     }
 
     if (result == NO_ERROR) {
@@ -599,6 +653,10 @@ void CameraService::Client::setPreviewCallbackFlag(int callback_flag) {
 // start preview mode
 status_t CameraService::Client::startPreview() {
     LOG1("startPreview (pid %d)", getCallingPid());
+#ifdef QCOM_HARDWARE
+    if (mFaceDetection)
+      enableMsgType(CAMERA_MSG_PREVIEW_METADATA);
+#endif
     return startCameraMode(CAMERA_PREVIEW_MODE);
 }
 
@@ -684,6 +742,7 @@ status_t CameraService::Client::startRecordingMode() {
 // stop preview mode
 void CameraService::Client::stopPreview() {
     LOG1("stopPreview (pid %d)", getCallingPid());
+    disableMsgType(CAMERA_MSG_PREVIEW_METADATA);
     Mutex::Autolock lock(mLock);
     if (checkPidAndHardware() != NO_ERROR) return;
 
@@ -700,9 +759,9 @@ void CameraService::Client::stopRecording() {
     Mutex::Autolock lock(mLock);
     if (checkPidAndHardware() != NO_ERROR) return;
 
-    mCameraService->playSound(SOUND_RECORDING);
     disableMsgType(CAMERA_MSG_VIDEO_FRAME);
     mHardware->stopRecording();
+    mCameraService->playSound(SOUND_RECORDING);
 
     mPreviewBuffer.clear();
 }
@@ -783,9 +842,11 @@ status_t CameraService::Client::takePicture(int msgType) {
                            CAMERA_MSG_RAW_IMAGE |
                            CAMERA_MSG_RAW_IMAGE_NOTIFY |
                            CAMERA_MSG_COMPRESSED_IMAGE);
-
+    disableMsgType(CAMERA_MSG_PREVIEW_METADATA);
     enableMsgType(picMsgType);
-
+    mburstCnt = mHardware->getParameters().getInt("num-snaps-per-shutter");
+    if(mburstCnt <= 0) mburstCnt = 1;
+    LOG1("mburstCnt = %d", mburstCnt);
     return mHardware->takePicture();
 }
 
@@ -875,6 +936,21 @@ status_t CameraService::Client::sendCommand(int32_t cmd, int32_t arg1, int32_t a
     } else if (cmd == CAMERA_CMD_PLAY_RECORDING_SOUND) {
         mCameraService->playSound(SOUND_RECORDING);
     }
+    else if (cmd == CAMERA_CMD_HISTOGRAM_ON ) {
+        enableMsgType(CAMERA_MSG_STATS_DATA);
+    }
+    else if (cmd ==  CAMERA_CMD_HISTOGRAM_OFF) {
+        disableMsgType(CAMERA_MSG_STATS_DATA);
+#ifdef QCOM_HARDWARE
+    } else if (cmd ==   CAMERA_CMD_START_FACE_DETECTION) {
+      mFaceDetection = true;
+      enableMsgType(CAMERA_MSG_PREVIEW_METADATA);
+    } else if (cmd ==   CAMERA_CMD_STOP_FACE_DETECTION) {
+      mFaceDetection = false;
+      disableMsgType(CAMERA_MSG_PREVIEW_METADATA);
+#endif
+    }
+
 
     return mHardware->sendCommand(cmd, arg1, arg2);
 }
@@ -990,7 +1066,7 @@ void CameraService::Client::dataCallback(int32_t msgType,
 
     if (dataPtr == 0 && metadata == NULL) {
         LOGE("Null data returned in data callback");
-        client->handleGenericNotify(CAMERA_MSG_ERROR, UNKNOWN_ERROR, 0);
+        client->handleGenericNotify(CAMERA_MSG_ERROR, CAMERA_ERROR_UNKNOWN, 0);
         return;
     }
 
@@ -1042,7 +1118,9 @@ void CameraService::Client::handleShutter(void) {
         c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
         if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
     }
+#ifndef SAMSUNG_CAMERA_QCOM
     disableMsgType(CAMERA_MSG_SHUTTER);
+#endif
 
     mLock.unlock();
 }
@@ -1121,8 +1199,17 @@ void CameraService::Client::handleRawPicture(const sp<IMemory>& mem) {
 
 // picture callback - compressed picture ready
 void CameraService::Client::handleCompressedPicture(const sp<IMemory>& mem) {
-    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
-
+    if (mburstCnt) mburstCnt--;
+
+    if (!mburstCnt) {
+        LOG1("mburstCnt = %d", mburstCnt);
+        disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+#ifdef QCOM_HARDWARE
+        if (mFaceDetection) {
+          enableMsgType(CAMERA_MSG_PREVIEW_METADATA);
+        }
+#endif
+    }
     sp<ICameraClient> c = mCameraClient;
     mLock.unlock();
     if (c != 0) {
diff --git a/services/camera/libcameraservice/CameraService.h b/services/camera/libcameraservice/CameraService.h
index bad41f5..33f7226 100644
--- a/services/camera/libcameraservice/CameraService.h
+++ b/services/camera/libcameraservice/CameraService.h
@@ -182,7 +182,9 @@ private:
         int                             mPreviewCallbackFlag;
         int                             mOrientation;     // Current display orientation
         bool                            mPlayShutterSound;
-
+#ifdef QCOM_HARDWARE
+        bool                            mFaceDetection;
+#endif
         // Ensures atomicity among the public methods
         mutable Mutex                   mLock;
         // This is a binder of Surface or SurfaceTexture.
@@ -210,6 +212,7 @@ private:
         // This function keeps trying to grab mLock, or give up if the message
         // is found to be disabled. It returns true if mLock is grabbed.
         bool                    lockIfMessageWanted(int32_t msgType);
+        int                     mburstCnt;
     };
 
     camera_module_t *mModule;
diff --git a/services/input/Android.mk b/services/input/Android.mk
index 86c6c8a..85dddb8 100644
--- a/services/input/Android.mk
+++ b/services/input/Android.mk
@@ -39,6 +39,10 @@ LOCAL_SHARED_LIBRARIES := \
 LOCAL_C_INCLUDES := \
     external/skia/include/core
 
+ifeq ($(BOARD_USE_LEGACY_TOUCHSCREEN),true)
+LOCAL_CFLAGS += -DLEGACY_TOUCHSCREEN
+endif
+
 LOCAL_MODULE:= libinput
 
 LOCAL_MODULE_TAGS := optional
diff --git a/services/input/InputReader.cpp b/services/input/InputReader.cpp
index b34ff25..f7b9c8d 100644
--- a/services/input/InputReader.cpp
+++ b/services/input/InputReader.cpp
@@ -1290,6 +1290,14 @@ void TouchButtonAccumulator::process(const RawEvent* rawEvent) {
             break;
         }
     }
+
+#ifdef LEGACY_TOUCHSCREEN
+    // set true to mBtnTouch by multi-touch event with pressure more than zero
+    // some touchscreen driver which has BTN_TOUCH feature doesn't send BTN_TOUCH event
+    else if (rawEvent->type == EV_ABS && rawEvent->scanCode == ABS_MT_TOUCH_MAJOR && rawEvent->value > 0)
+        mBtnTouch = true;
+#endif
+
 }
 
 uint32_t TouchButtonAccumulator::getButtonState() const {
@@ -1565,7 +1573,12 @@ void MultiTouchMotionAccumulator::process(const RawEvent* rawEvent) {
                 break;
             case ABS_MT_TOUCH_MAJOR:
                 slot->mInUse = true;
+#ifdef LEGACY_TOUCHSCREEN
+                // emulate ABS_MT_PRESSURE
+                slot->mAbsMTPressure = rawEvent->value;
+#else
                 slot->mAbsMTTouchMajor = rawEvent->value;
+#endif
                 break;
             case ABS_MT_TOUCH_MINOR:
                 slot->mInUse = true;
@@ -1574,7 +1587,12 @@ void MultiTouchMotionAccumulator::process(const RawEvent* rawEvent) {
                 break;
             case ABS_MT_WIDTH_MAJOR:
                 slot->mInUse = true;
+#ifdef LEGACY_TOUCHSCREEN
+                // emulate ABS_MT_TOUCH_MAJOR
+                slot->mAbsMTTouchMajor = rawEvent->value;
+#else
                 slot->mAbsMTWidthMajor = rawEvent->value;
+#endif
                 break;
             case ABS_MT_WIDTH_MINOR:
                 slot->mInUse = true;
@@ -1611,6 +1629,12 @@ void MultiTouchMotionAccumulator::process(const RawEvent* rawEvent) {
             }
         }
     } else if (rawEvent->type == EV_SYN && rawEvent->scanCode == SYN_MT_REPORT) {
+#ifdef LEGACY_TOUCHSCREEN
+        // don't use the slot with pressure less than or qeual to zero
+        // some touchscreen driver sends multi-touch event for not-in-use pointer
+        if (mSlots[mCurrentSlot].mAbsMTPressure <= 0)
+            mSlots[mCurrentSlot].mInUse = false;
+#endif
         // MultiTouch Sync: The driver has returned all data for *one* of the pointers.
         mCurrentSlot += 1;
     }
@@ -5663,12 +5687,20 @@ void MultiTouchInputMapper::configureRawPointerAxes() {
 
     getAbsoluteAxisInfo(ABS_MT_POSITION_X, &mRawPointerAxes.x);
     getAbsoluteAxisInfo(ABS_MT_POSITION_Y, &mRawPointerAxes.y);
+#ifdef LEGACY_TOUCHSCREEN
+    getAbsoluteAxisInfo(ABS_MT_WIDTH_MAJOR, &mRawPointerAxes.touchMajor);
+#else
     getAbsoluteAxisInfo(ABS_MT_TOUCH_MAJOR, &mRawPointerAxes.touchMajor);
+#endif
     getAbsoluteAxisInfo(ABS_MT_TOUCH_MINOR, &mRawPointerAxes.touchMinor);
     getAbsoluteAxisInfo(ABS_MT_WIDTH_MAJOR, &mRawPointerAxes.toolMajor);
     getAbsoluteAxisInfo(ABS_MT_WIDTH_MINOR, &mRawPointerAxes.toolMinor);
     getAbsoluteAxisInfo(ABS_MT_ORIENTATION, &mRawPointerAxes.orientation);
+#ifdef LEGACY_TOUCHSCREEN
+    getAbsoluteAxisInfo(ABS_MT_TOUCH_MAJOR, &mRawPointerAxes.pressure);
+#else
     getAbsoluteAxisInfo(ABS_MT_PRESSURE, &mRawPointerAxes.pressure);
+#endif
     getAbsoluteAxisInfo(ABS_MT_DISTANCE, &mRawPointerAxes.distance);
     getAbsoluteAxisInfo(ABS_MT_TRACKING_ID, &mRawPointerAxes.trackingId);
     getAbsoluteAxisInfo(ABS_MT_SLOT, &mRawPointerAxes.slot);
diff --git a/services/java/com/android/server/MountService.java b/services/java/com/android/server/MountService.java
index 5425813..42d24eb 100644
--- a/services/java/com/android/server/MountService.java
+++ b/services/java/com/android/server/MountService.java
@@ -369,6 +369,13 @@ class MountService extends IMountService.Stub
                 case H_UNMOUNT_PM_UPDATE: {
                     if (DEBUG_UNMOUNT) Slog.i(TAG, "H_UNMOUNT_PM_UPDATE");
                     UnmountCallBack ucb = (UnmountCallBack) msg.obj;
+                    if (!mUpdatingStatus && !isExternalStorage(ucb.path)) {
+                        // If PM isn't already updating, and this isn't an ASEC
+                        // mount, then go ahead and do the unmount immediately.
+                        if (DEBUG_UNMOUNT) Slog.i(TAG, " skipping PackageManager for " + ucb.path);
+                        ucb.handleFinished();
+                        break;
+                    }
                     mForceUnmounts.add(ucb);
                     if (DEBUG_UNMOUNT) Slog.i(TAG, " registered = " + mUpdatingStatus);
                     // Register only if needed.
@@ -588,7 +595,9 @@ class MountService extends IMountService.Stub
             // Update state on PackageManager, but only of real events
             if (!mEmulateExternalStorage) {
                 if (Environment.MEDIA_UNMOUNTED.equals(state)) {
-                    mPms.updateExternalMediaStatus(false, false);
+                    if (isExternalStorage(path)) {
+                        mPms.updateExternalMediaStatus(false, false);
+                    }
 
                     /*
                      * Some OBBs might have been unmounted when this volume was
@@ -598,7 +607,9 @@ class MountService extends IMountService.Stub
                     mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(
                             OBB_FLUSH_MOUNT_STATE, path));
                 } else if (Environment.MEDIA_MOUNTED.equals(state)) {
-                    mPms.updateExternalMediaStatus(true, false);
+                    if (isExternalStorage(path)) {
+                        mPms.updateExternalMediaStatus(true, false);
+                    }
                 }
             }
         }
@@ -907,7 +918,9 @@ class MountService extends IMountService.Stub
         Runtime.getRuntime().gc();
 
         // Redundant probably. But no harm in updating state again.
-        mPms.updateExternalMediaStatus(false, false);
+        if (isExternalStorage(path)) {
+            mPms.updateExternalMediaStatus(false, false);
+        }
         try {
             String arg = removeEncryption
                     ? " force_and_revert"
@@ -1007,8 +1020,13 @@ class MountService extends IMountService.Stub
             mSendUmsConnectedOnBoot = avail;
         }
 
-        final String path = Environment.getExternalStorageDirectory().getPath();
-        if (avail == false && getVolumeState(path).equals(Environment.MEDIA_SHARED)) {
+        final ArrayList<String> volumes = getShareableVolumes();
+        boolean mediaShared = false;
+        for (String path : volumes) {
+            if (getVolumeState(path).equals(Environment.MEDIA_SHARED))
+                mediaShared = true;
+        }
+        if (avail == false && mediaShared) {
             /*
              * USB mass storage disconnected while enabled
              */
@@ -1018,11 +1036,15 @@ class MountService extends IMountService.Stub
                     try {
                         int rc;
                         Slog.w(TAG, "Disabling UMS after cable disconnect");
-                        doShareUnshareVolume(path, "ums", false);
-                        if ((rc = doMountVolume(path)) != StorageResultCode.OperationSucceeded) {
-                            Slog.e(TAG, String.format(
-                                    "Failed to remount {%s} on UMS enabled-disconnect (%d)",
-                                            path, rc));
+                        for (String path : volumes) {
+                            if (getVolumeState(path).equals(Environment.MEDIA_SHARED)) {
+                                doShareUnshareVolume(path, "ums", false);
+                                if ((rc = doMountVolume(path)) != StorageResultCode.OperationSucceeded) {
+                                    Slog.e(TAG, String.format(
+                                            "Failed to remount {%s} on UMS enabled-disconnect (%d)",
+                                                    path, rc));
+                                }
+                            }
                         }
                     } catch (Exception ex) {
                         Slog.w(TAG, "Failed to mount media on UMS enabled-disconnect", ex);
@@ -1132,6 +1154,60 @@ class MountService extends IMountService.Stub
             }
             parser.close();
         }
+
+        // If persist.sys.vold.switchexternal is in effect, switch volume
+        // properties for correct display. We switch everything except
+        // "primary" (position = 0) as that should always belong to /mnt/sdcard.
+        if (SystemProperties.getInt("persist.sys.vold.switchexternal", 0) == 1) {
+            String[] pair = SystemProperties.get("ro.vold.switchablepair", "").split(",");
+
+            if (pair.length != 2) {
+                Slog.e(TAG, "invalid switchable mountpoints");
+                return;
+            }
+
+            Slog.d(TAG, "Switching storage path " + pair[0] + " and " + pair[1]);
+
+            StorageVolume left = null;
+            StorageVolume right = null;
+            int leftIndex = -1;
+            int rightIndex = -1;
+            for (int i = 0; i < mVolumes.size(); i++) {
+                StorageVolume v = mVolumes.get(i);
+                String path = v.getPath();
+                if (path.equals(pair[0])) {
+                    left = v;
+                    leftIndex = i;
+                } else if (path.equals(pair[1])) {
+                    right = v;
+                    rightIndex = i;
+                }
+            }
+
+            if (left == null || right == null) {
+                Slog.e(TAG, "unable to locate volume for switchable mountpoints");
+                return;
+            }
+
+            // Create new volumes
+            StorageVolume newLeft = new StorageVolume(left.getPath(),
+                right.getDescription(), right.isRemovable(),
+                right.isEmulated(), right.getMtpReserveSpace(),
+                right.allowMassStorage(), right.getMaxFileSize());
+            newLeft.setStorageId(leftIndex);
+
+            StorageVolume newRight = new StorageVolume(right.getPath(),
+                left.getDescription(), left.isRemovable(),
+                left.isEmulated(), left.getMtpReserveSpace(),
+                left.allowMassStorage(), left.getMaxFileSize());
+            newRight.setStorageId(rightIndex);
+
+            mVolumes.remove(leftIndex);
+            mVolumes.add(leftIndex, newLeft);
+
+            mVolumes.remove(rightIndex);
+            mVolumes.add(rightIndex, newRight);
+        }
     }
 
     /**
@@ -1305,46 +1381,69 @@ class MountService extends IMountService.Stub
         }
     }
 
+    private boolean isExternalStorage(String path) {
+        return Environment.getExternalStorageDirectory().getPath().equals(path);
+    }
+
+    private ArrayList<String> getShareableVolumes() {
+        // Sharable volumes have android:allowMassStorage="true" in storage_list.xml
+        ArrayList<String> volumesToMount = new ArrayList<String>();
+        synchronized (mVolumes) {
+            for (StorageVolume v : mVolumes) {
+                if (v.allowMassStorage()) {
+                    volumesToMount.add(v.getPath());
+                }
+            }
+        }
+        return volumesToMount;
+    }
+
     public void setUsbMassStorageEnabled(boolean enable) {
         waitForReady();
         validatePermission(android.Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS);
 
         // TODO: Add support for multiple share methods
 
-        /*
-         * If the volume is mounted and we're enabling then unmount it
-         */
-        String path = Environment.getExternalStorageDirectory().getPath();
-        String vs = getVolumeState(path);
-        String method = "ums";
-        if (enable && vs.equals(Environment.MEDIA_MOUNTED)) {
-            // Override for isUsbMassStorageEnabled()
-            setUmsEnabling(enable);
-            UmsEnableCallBack umscb = new UmsEnableCallBack(path, method, true);
-            mHandler.sendMessage(mHandler.obtainMessage(H_UNMOUNT_PM_UPDATE, umscb));
-            // Clear override
-            setUmsEnabling(false);
-        }
-        /*
-         * If we disabled UMS then mount the volume
-         */
-        if (!enable) {
-            doShareUnshareVolume(path, method, enable);
-            if (doMountVolume(path) != StorageResultCode.OperationSucceeded) {
-                Slog.e(TAG, "Failed to remount " + path +
-                        " after disabling share method " + method);
-                /*
-                 * Even though the mount failed, the unshare didn't so don't indicate an error.
-                 * The mountVolume() call will have set the storage state and sent the necessary
-                 * broadcasts.
-                 */
+        for (String path : getShareableVolumes()) {
+            /*
+             * If the volume is mounted and we're enabling then unmount it
+             */
+            String vs = getVolumeState(path);
+            String method = "ums";
+            if (enable && vs.equals(Environment.MEDIA_MOUNTED)) {
+                // Override for isUsbMassStorageEnabled()
+                setUmsEnabling(enable);
+                UmsEnableCallBack umscb = new UmsEnableCallBack(path, method, true);
+                mHandler.sendMessage(mHandler.obtainMessage(H_UNMOUNT_PM_UPDATE, umscb));
+                // Clear override
+                setUmsEnabling(false);
+            }
+            /*
+             * If we disabled UMS then mount the volume
+             */
+            if (!enable) {
+                doShareUnshareVolume(path, method, enable);
+                if (doMountVolume(path) != StorageResultCode.OperationSucceeded) {
+                    Slog.e(TAG, "Failed to remount " + path +
+                            " after disabling share method " + method);
+                    /*
+                     * Even though the mount failed, the unshare didn't so don't indicate an error.
+                     * The mountVolume() call will have set the storage state and sent the necessary
+                     * broadcasts.
+                     */
+                }
             }
         }
     }
 
     public boolean isUsbMassStorageEnabled() {
         waitForReady();
-        return doGetVolumeShared(Environment.getExternalStorageDirectory().getPath(), "ums");
+        for (String path : getShareableVolumes()) {
+            if (doGetVolumeShared(path, "ums"))
+                return true;
+        }
+        // no volume is shared
+        return false;
     }
 
     /**
diff --git a/services/java/com/android/server/NetworkManagementService.java b/services/java/com/android/server/NetworkManagementService.java
index 75e5366..25c890d 100644
--- a/services/java/com/android/server/NetworkManagementService.java
+++ b/services/java/com/android/server/NetworkManagementService.java
@@ -29,6 +29,7 @@ import static com.android.server.NetworkManagementSocketTagger.PROP_QTAGUID_ENAB
 
 import android.content.Context;
 import android.content.pm.PackageManager;
+import android.content.res.Resources;
 import android.net.INetworkManagementEventObserver;
 import android.net.InterfaceConfiguration;
 import android.net.LinkAddress;
@@ -945,10 +946,16 @@ public class NetworkManagementService extends INetworkManagementService.Stub
         mContext.enforceCallingOrSelfPermission(
                 android.Manifest.permission.CHANGE_WIFI_STATE, "NetworkManagementService");
         try {
-            wifiFirmwareReload(wlanIface, "AP");
-            mConnector.doCommand(String.format("softap start " + wlanIface));
+            Resources resources = mContext.getResources();
+            String mainIface = resources.getBoolean(
+                    com.android.internal.R.bool.config_wifi_ap_use_single_interface)
+                    ? softapIface : wlanIface;
+
+            if (resources.getBoolean(com.android.internal.R.bool.config_wifi_ap_firmware_reload))
+                wifiFirmwareReload(wlanIface, "AP");
+            mConnector.doCommand(String.format("softap start " + mainIface));
             if (wifiConfig == null) {
-                mConnector.doCommand(String.format("softap set " + wlanIface + " " + softapIface));
+                mConnector.doCommand(String.format("softap set " + mainIface + " " + softapIface));
             } else {
                 /**
                  * softap set arg1 arg2 arg3 [arg4 arg5 arg6 arg7 arg8]
@@ -961,7 +968,7 @@ public class NetworkManagementService extends INetworkManagementService.Stub
                  * argv7 - Preamble
                  * argv8 - Max SCB
                  */
-                 String str = String.format("softap set " + wlanIface + " " + softapIface +
+                 String str = String.format("softap set " + mainIface + " " + softapIface +
                                        " %s %s %s", convertQuotedString(wifiConfig.SSID),
                                        getSecurityType(wifiConfig),
                                        convertQuotedString(wifiConfig.preSharedKey));
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index cffb391..744f4c2 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -2991,7 +2991,7 @@ public final class ActivityManagerService extends ActivityManagerNative
     }
 
     final void logAppTooSlow(ProcessRecord app, long startTime, String msg) {
-        if (IS_USER_BUILD) {
+        if (true || IS_USER_BUILD) {
             return;
         }
         String tracesPath = SystemProperties.get("dalvik.vm.stack-trace-file", null);
diff --git a/services/java/com/android/server/usb/LegacyUsbDeviceManager.java b/services/java/com/android/server/usb/LegacyUsbDeviceManager.java
new file mode 100644
index 0000000..c4963eb
--- /dev/null
+++ b/services/java/com/android/server/usb/LegacyUsbDeviceManager.java
@@ -0,0 +1,655 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions an
+ * limitations under the License.
+ */
+
+package com.android.server.usb;
+
+import android.app.PendingIntent;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.database.ContentObserver;
+import android.hardware.usb.UsbAccessory;
+import android.hardware.usb.UsbManager;
+import android.os.FileUtils;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Process;
+import android.os.storage.StorageManager;
+import android.os.storage.StorageVolume;
+import android.os.SystemProperties;
+import android.os.UEventObserver;
+import android.provider.Settings;
+import android.util.Slog;
+
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Arrays;
+
+/**
+ * LegacyUsbDeviceManager manages USB state in devices with legacy USB stacks.
+ */
+public class LegacyUsbDeviceManager extends UsbDeviceManager {
+
+    private static final String TAG = LegacyUsbDeviceManager.class.getSimpleName();
+    private static final boolean DEBUG = false;
+
+    private static final String USB_CONNECTED_MATCH =
+            "DEVPATH=/devices/virtual/switch/usb_connected";
+    private static final String USB_CONFIGURATION_MATCH =
+            "DEVPATH=/devices/virtual/switch/usb_configuration";
+    private static final String USB_LEGACY_MATCH =
+            "DEVPATH=/devices/virtual/switch/usb_mass_storage";
+    private static final String USB_CONNECTED_PATH =
+            "/sys/class/switch/usb_connected/state";
+    private static final String USB_CONFIGURATION_PATH =
+            "/sys/class/switch/usb_configuration/state";
+    private static final String USB_LEGACY_PATH =
+            "/sys/class/switch/usb_mass_storage/state";
+    private static final String FUNCTIONS_PATH =
+            "/sys/devices/virtual/usb_composite/";
+    private static final String MASS_STORAGE_FILE_PATH =
+            Resources.getSystem().getString(com.android.internal.R.string.config_legacyUmsLunFile);
+
+    private static final int MSG_UPDATE_STATE = 0;
+    private static final int MSG_ENABLE_ADB = 1;
+    private static final int MSG_SET_CURRENT_FUNCTION = 2;
+    private static final int MSG_SYSTEM_READY = 3;
+    private static final int MSG_BOOT_COMPLETED = 4;
+
+    private boolean mConnected = false;
+    private boolean mConfigured = false;
+
+    // Delay for debouncing USB disconnects.
+    // We often get rapid connect/disconnect events when enabling USB functions,
+    // which need debouncing.
+    private static final int UPDATE_DELAY = 1000;
+
+    private LegacyUsbHandler mHandler;
+    private boolean mBootCompleted;
+
+    private final Context mContext;
+    private final ContentResolver mContentResolver;
+    private final UsbSettingsManager mSettingsManager;
+    private NotificationManager mNotificationManager;
+    private final boolean mHasUsbAccessory;
+    private boolean mUseUsbNotification;
+    private boolean mAdbEnabled;
+    private boolean mLegacy = false;
+
+    private class AdbSettingsObserver extends ContentObserver {
+        public AdbSettingsObserver() {
+            super(null);
+        }
+        @Override
+        public void onChange(boolean selfChange) {
+            boolean enable = (Settings.Secure.getInt(mContentResolver,
+                    Settings.Secure.ADB_ENABLED, 0) > 0);
+            mHandler.sendMessage(MSG_ENABLE_ADB, enable);
+        }
+    }
+
+    /*
+     * Listens for uevent messages from the kernel to monitor the USB state
+     */
+
+    private final UEventObserver mUEventObserver = new UEventObserver() {
+        @Override
+        public void onUEvent(UEventObserver.UEvent event) {
+            if (DEBUG) Slog.v(TAG, "USB UEVENT: " + event.toString());
+
+            String name = event.get("SWITCH_NAME");
+            String state = event.get("SWITCH_STATE");
+
+            if (name != null && state != null) {
+                if (mLegacy) {
+                    if ("usb_mass_storage".equals(name)) {
+                        mConnected  = "online".equals(state);
+                        mConfigured = "online".equals(state);
+                    }
+                } else {
+                    if ("usb_connected".equals(name))
+                        mConnected = "1".equals(state);
+                    else if ("usb_configuration".equals(name))
+                        mConfigured = "1".equals(state);
+                }
+
+                if (!mConnected && !mConfigured) mHandler.updateState("DISCONNECTED");
+                else if(mConnected && !mConfigured) mHandler.updateState("CONNECTED");
+                else if(mConnected && mConfigured) mHandler.updateState("CONFIGURED");
+                else mHandler.updateState("UNKNOWN");
+            }
+        }
+    };
+
+    public LegacyUsbDeviceManager(Context context, UsbSettingsManager settingsManager) {
+        super();
+        mContext = context;
+        mContentResolver = context.getContentResolver();
+        mSettingsManager = settingsManager;
+        PackageManager pm = mContext.getPackageManager();
+        mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);
+
+        // create a thread for our Handler
+        HandlerThread thread = new HandlerThread("LegacyUsbDeviceManager",
+                Process.THREAD_PRIORITY_BACKGROUND);
+        thread.start();
+        mHandler = new LegacyUsbHandler(thread.getLooper());
+    }
+
+    @Override
+    public void systemReady() {
+        if (DEBUG) Slog.d(TAG, "systemReady");
+
+        mNotificationManager = (NotificationManager)
+                mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        // We do not show the USB notification if the primary volume supports mass storage.
+        // The legacy mass storage UI will be used instead.
+        boolean massStorageSupported = false;
+        StorageManager storageManager = (StorageManager)
+                mContext.getSystemService(Context.STORAGE_SERVICE);
+        StorageVolume[] volumes = storageManager.getVolumeList();
+
+        if (volumes.length > 0) {
+            if (Settings.Secure.getInt(mContentResolver, Settings.Secure.USB_MASS_STORAGE_ENABLED, 0) == 1 ) {
+                massStorageSupported = volumes[0].allowMassStorage();
+            } else {
+                massStorageSupported = false;
+            }
+        }
+
+        mUseUsbNotification = !massStorageSupported;
+
+        // make sure the ADB_ENABLED setting value matches the current state
+        Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED, mAdbEnabled ? 1 : 0);
+        if (DEBUG) Slog.d(TAG, "mAdbEnable="+mAdbEnabled);
+
+        mHandler.sendEmptyMessage(MSG_SYSTEM_READY);
+    }
+
+    private static String addFunction(String functions, String function) {
+        if (!containsFunction(functions, function)) {
+            if (functions.length() > 0) {
+                functions += ",";
+            }
+            functions += function;
+        }
+        return functions;
+    }
+
+    private static String removeFunction(String functions, String function) {
+        String[] split = functions.split(",");
+        for (int i = 0; i < split.length; i++) {
+            if (function.equals(split[i])) {
+                split[i] = null;
+            }
+        }
+        StringBuilder builder = new StringBuilder();
+         for (int i = 0; i < split.length; i++) {
+            String s = split[i];
+            if (s != null) {
+                if (builder.length() > 0) {
+                    builder.append(",");
+                }
+                builder.append(s);
+            }
+        }
+        return builder.toString();
+    }
+
+    private static boolean containsFunction(String functions, String function) {
+        int index = functions.indexOf(function);
+        if (index < 0) return false;
+        if (index > 0 && functions.charAt(index - 1) != ',') return false;
+        int charAfter = index + function.length();
+        if (charAfter < functions.length() && functions.charAt(charAfter) != ',') return false;
+        return true;
+    }
+
+    private final class LegacyUsbHandler extends Handler {
+
+        // current USB state
+        private boolean mConnected = false;
+        private boolean mConfigured = false;
+        private String mCurrentFunctions;
+        private String mDefaultFunctions;
+        private UsbAccessory mCurrentAccessory;
+        private int mUsbNotificationId;
+        private boolean mAdbNotificationShown;
+
+         final BroadcastReceiver mBootCompletedReceiver = new BroadcastReceiver() {
+            public void onReceive(Context context, Intent intent) {
+                if (DEBUG) Slog.d(TAG, "boot completed");
+                mHandler.sendEmptyMessage(MSG_BOOT_COMPLETED);
+            }
+        };
+
+        public LegacyUsbHandler(Looper looper) {
+            super(looper);
+            char[] buffer = new char[1024];
+
+            try {
+                // persist.sys.usb.config should never be unset.  But if it is, set it to "adb"
+                // so we have a chance of debugging what happened.
+                mDefaultFunctions = SystemProperties.get("persist.sys.usb.config", "adb");
+                // sanity check the sys.usb.config system property
+                // this may be necessary if we crashed while switching USB configurations
+                String config = SystemProperties.get("sys.usb.config", "none");
+                if (!config.equals(mDefaultFunctions)) {
+                    Slog.w(TAG, "resetting config to persistent property: " + mDefaultFunctions);
+                    SystemProperties.set("sys.usb.config", mDefaultFunctions);
+                }
+
+                // Read initial USB state (device mode)
+                try {
+                    FileReader file = new FileReader(USB_CONNECTED_PATH);
+                    int len = file.read(buffer, 0, 1024);
+                    file.close();
+                    mConnected = "1".equals((new String(buffer, 0, len)).trim());
+
+                    file = new FileReader(USB_CONFIGURATION_PATH);
+                    len = file.read(buffer, 0, 1024);
+                    file.close();
+                    mConfigured = "1".equals((new String(buffer, 0, len)).trim());
+                } catch (FileNotFoundException e) {
+                    Slog.i(TAG, "This kernel does not have USB configuration switch support");
+                    Slog.i(TAG, "Trying legacy USB configuration switch support");
+                    try {
+                        FileReader file = new FileReader(USB_LEGACY_PATH);
+                        int len = file.read(buffer, 0, 1024);
+                        file.close();
+                        mConnected = "online".equals((new String(buffer, 0, len)).trim());
+                        mLegacy = true;
+                        mConfigured = false;
+                    } catch (FileNotFoundException f) {
+                        Slog.i(TAG, "This kernel does not have legacy USB configuration switch support");
+                    } catch (Exception f) {
+                        Slog.e(TAG, "" , f);
+                    }
+                }
+
+                mCurrentFunctions = mDefaultFunctions;
+                if (!mConnected && !mConfigured) updateState("DISCONNECTED");
+                else if(mConnected && !mConfigured) updateState("CONNECTED");
+                else if(mConnected && mConfigured) updateState("CONFIGURED");
+                else updateState("UNKNOWN");
+
+                mAdbEnabled = containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ADB);
+                // Upgrade step for previous versions that used persist.service.adb.enable
+                String value = SystemProperties.get("persist.service.adb.enable", "0");
+                if (value.length() > 0) {
+                    char enable = value.charAt(0);
+                    if (enable == '1') {
+                        setAdbEnabled(true);
+                    } else if (enable == '0') {
+                        setAdbEnabled(false);
+                    }
+                }
+
+                // register observer to listen for settings changes
+                mContentResolver.registerContentObserver(
+                    Settings.Secure.getUriFor(Settings.Secure.ADB_ENABLED),
+                    false, new AdbSettingsObserver());
+
+                // Watch for USB configuration changes
+                if (mLegacy) {
+                    mUEventObserver.startObserving(USB_LEGACY_MATCH);
+                } else {
+                    mUEventObserver.startObserving(USB_CONNECTED_MATCH);
+                    mUEventObserver.startObserving(USB_CONFIGURATION_MATCH);
+                }
+                mContext.registerReceiver(mBootCompletedReceiver,
+                                          new IntentFilter(Intent.ACTION_BOOT_COMPLETED));
+                if(DEBUG) Slog.d(TAG, "Initialised USB event listeners");
+            } catch (Exception e) {
+                Slog.e(TAG, "Error initializing listener", e);
+            }
+        }
+
+        public boolean isConnected() {
+            return mConnected;
+        }
+
+        public boolean isConfigured() {
+            return mConfigured;
+        }
+
+        public void sendMessage(int what, boolean arg) {
+            removeMessages(what);
+            Message m = Message.obtain(this, what);
+            m.arg1 = (arg ? 1 : 0);
+            sendMessage(m);
+        }
+
+        public void sendMessage(int what, Object arg) {
+            removeMessages(what);
+            Message m = Message.obtain(this, what);
+            m.obj = arg;
+            sendMessage(m);
+        }
+
+        public void sendMessage(int what, Object arg0, boolean arg1) {
+            removeMessages(what);
+            Message m = Message.obtain(this, what);
+            m.obj = arg0;
+            m.arg1 = (arg1 ? 1 : 0);
+            sendMessage(m);
+        }
+
+       public void updateState(String state) {
+            int connected, configured;
+
+            if ("DISCONNECTED".equals(state)) {
+                connected = 0;
+                configured = 0;
+            } else if ("CONNECTED".equals(state)) {
+                connected = 1;
+                configured = 0;
+            } else if ("CONFIGURED".equals(state)) {
+                connected = 1;
+                configured = 1;
+            } else {
+                Slog.e(TAG, "unknown state " + state);
+                return;
+            }
+            removeMessages(MSG_UPDATE_STATE);
+            Message msg = Message.obtain(this, MSG_UPDATE_STATE);
+            msg.arg1 = connected;
+            msg.arg2 = configured;
+            // debounce disconnects to avoid problems bringing up USB tethering
+            sendMessageDelayed(msg, (connected == 0) ? UPDATE_DELAY : 0);
+        }
+
+        private boolean waitForState(String state) {
+            // wait for the transition to complete.
+            // give up after 1 second.
+            for (int i = 0; i < 20; i++) {
+                // State transition is done when sys.usb.state is set to the new configuration
+                if (state.equals(SystemProperties.get("sys.usb.state"))) return true;
+                try {
+                    // try again in 50ms
+                    Thread.sleep(50);
+                } catch (InterruptedException e) {
+                }
+            }
+            Slog.e(TAG, "waitForState(" + state + ") FAILED");
+            return false;
+        }
+
+        private boolean setUsbConfig(String config) {
+            if (DEBUG) Slog.d(TAG, "setUsbConfig(" + config + ")");
+            // set the new configuration
+            SystemProperties.set("sys.usb.config", config);
+            return waitForState(config);
+        }
+
+        private void setAdbEnabled(boolean enable) {
+            if (DEBUG) Slog.d(TAG, "setAdbEnabled: " + enable);
+            if (enable != mAdbEnabled) {
+                mAdbEnabled = enable;
+                // Due to the persist.sys.usb.config property trigger, changing adb state requires
+                // switching to default function
+                setEnabledFunctions(mDefaultFunctions, true);
+                updateAdbNotification();
+            }
+            SystemProperties.set("persist.service.adb.enable", enable ? "1":"0");
+        }
+
+        private void setEnabledFunctions(String functions, boolean makeDefault) {
+            if (functions != null && makeDefault) {
+                if (mAdbEnabled) {
+                    functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);
+                } else {
+                    functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);
+                }
+                if (!mDefaultFunctions.equals(functions)) {
+                    if (!setUsbConfig("none")) {
+                        Slog.e(TAG, "Failed to disable USB");
+                        // revert to previous configuration if we fail
+                        setUsbConfig(mCurrentFunctions);
+                        return;
+                    }
+                    // setting this property will also change the current USB state
+                    // via a property trigger
+                    SystemProperties.set("persist.sys.usb.config", functions);
+                    if (waitForState(functions)) {
+                        mCurrentFunctions = functions;
+                        mDefaultFunctions = functions;
+                    } else {
+                        Slog.e(TAG, "Failed to switch persistent USB config to " + functions);
+                        // revert to previous configuration if we fail
+                        SystemProperties.set("persist.sys.usb.config", mDefaultFunctions);
+                    }
+                }
+            } else {
+                if (functions == null) {
+                    functions = mDefaultFunctions;
+                }
+                if (mAdbEnabled) {
+                    functions = addFunction(functions, UsbManager.USB_FUNCTION_ADB);
+                } else {
+                    functions = removeFunction(functions, UsbManager.USB_FUNCTION_ADB);
+                }
+                if (!mCurrentFunctions.equals(functions)) {
+                    if (!setUsbConfig("none")) {
+                        Slog.e(TAG, "Failed to disable USB");
+                        // revert to previous configuration if we fail
+                        setUsbConfig(mCurrentFunctions);
+                        return;
+                    }
+                    if (setUsbConfig(functions)) {
+                        mCurrentFunctions = functions;
+                    } else {
+                        Slog.e(TAG, "Failed to switch USB config to " + functions);
+                        // revert to previous configuration if we fail
+                        setUsbConfig(mCurrentFunctions);
+                    }
+                }
+            }
+        }
+
+        private void updateUsbState() {
+            // send a sticky broadcast containing current USB state
+            Intent intent = new Intent(UsbManager.ACTION_USB_STATE);
+            intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+            intent.putExtra(UsbManager.USB_CONNECTED, mConnected);
+            intent.putExtra(UsbManager.USB_CONFIGURED, mConfigured);
+
+            if (mCurrentFunctions != null) {
+                String[] functions = mCurrentFunctions.split(",");
+                for (int i = 0; i < functions.length; i++) {
+                    intent.putExtra(functions[i], true);
+                }
+            }
+
+            mContext.sendStickyBroadcast(intent);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_UPDATE_STATE:
+                    if (DEBUG) Slog.d(TAG, "Got MSG_UPDATE_STATE. Connected="+msg.arg1+" Configured="+msg.arg2);
+                    mConnected = (msg.arg1 == 1);
+                    mConfigured = (msg.arg2 == 1);
+                    updateUsbNotification();
+                    updateAdbNotification();
+
+                    if (!mConnected) {
+                        // restore defaults when USB is disconnected
+                        setEnabledFunctions(mDefaultFunctions, false);
+                    }
+                    if (mBootCompleted) {
+                        updateUsbState();
+                    }
+                    break;
+                case MSG_ENABLE_ADB:
+                    setAdbEnabled(msg.arg1 == 1);
+                    break;
+                case MSG_SET_CURRENT_FUNCTION:
+                    String function = (String)msg.obj;
+                    boolean makeDefault = (msg.arg1 == 1);
+                    setEnabledFunctions(function, makeDefault);
+                    break;
+                case MSG_SYSTEM_READY:
+                    updateUsbNotification();
+                    updateAdbNotification();
+                    updateUsbState();
+                    break;
+                case MSG_BOOT_COMPLETED:
+                    mBootCompleted = true;
+                    if (mCurrentAccessory != null) {
+                        mSettingsManager.accessoryAttached(mCurrentAccessory);
+                    }
+                    break;
+            }
+        }
+
+        public UsbAccessory getCurrentAccessory() {
+            return mCurrentAccessory;
+        }
+
+        private void updateUsbNotification() {
+            if (mNotificationManager == null || !mUseUsbNotification) {
+                if(DEBUG && mNotificationManager == null) Slog.d(TAG, "mNotificationManager == null");
+                if(DEBUG && !mUseUsbNotification) Slog.d(TAG, "!mUseUsbNotification");
+            return;
+            }
+            int id = 0;
+            Resources r = mContext.getResources();
+            if (mConnected) {
+                if (containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_MTP)) {
+                    id = com.android.internal.R.string.usb_mtp_notification_title;
+                } else if (containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_PTP)) {
+                    id = com.android.internal.R.string.usb_ptp_notification_title;
+                } /* else if (containsFunction(mCurrentFunctions, 
+                        UsbManager.USB_FUNCTION_MASS_STORAGE)) { // Disable this as it causes double USB settings menues when in UMS mode.
+                        id = com.android.internal.R.string.usb_cd_installer_notification_title; 
+                } */ else if (containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ACCESSORY)) {
+                    id = com.android.internal.R.string.usb_accessory_notification_title;
+                } else {
+                    // There is a different notification for USB tethering so we don't need one here
+                    if (!containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_RNDIS)) {
+                        Slog.e(TAG, "No known USB function in updateUsbNotification");
+                    }
+                }
+            }
+            if (id != mUsbNotificationId) {
+                // clear notification if title needs changing
+                if (mUsbNotificationId != 0) {
+                    mNotificationManager.cancel(mUsbNotificationId);
+                    mUsbNotificationId = 0;
+                }
+                if (id != 0) {
+                    CharSequence message = r.getText(
+                            com.android.internal.R.string.usb_notification_message);
+                    CharSequence title = r.getText(id);
+
+                    Notification notification = new Notification();
+                    notification.icon = com.android.internal.R.drawable.stat_sys_data_usb;
+                    notification.when = 0;
+                    notification.flags = Notification.FLAG_ONGOING_EVENT;
+                    notification.tickerText = title;
+                    notification.defaults = 0; // please be quiet
+                    notification.sound = null;
+                    notification.vibrate = null;
+
+                    Intent intent = Intent.makeRestartActivityTask(
+                            new ComponentName("com.android.settings",
+                                    "com.android.settings.UsbSettings"));
+                    PendingIntent pi = PendingIntent.getActivity(mContext, 0,
+                            intent, 0);
+                    notification.setLatestEventInfo(mContext, title, message, pi);
+                    mNotificationManager.notify(id, notification);
+                    mUsbNotificationId = id;
+                }
+            }
+        }
+
+        private void updateAdbNotification() {
+            if (mNotificationManager == null) return;
+            final int id = com.android.internal.R.string.adb_active_notification_title;
+            if (mAdbEnabled && mConnected) {
+                if ("0".equals(SystemProperties.get("persist.adb.notify"))) return;
+
+                if (!mAdbNotificationShown) {
+                    Resources r = mContext.getResources();
+                    CharSequence title = r.getText(id);
+                    CharSequence message = r.getText(
+                            com.android.internal.R.string.adb_active_notification_message);
+
+                    Notification notification = new Notification();
+                    notification.icon = com.android.internal.R.drawable.stat_sys_adb;
+                    notification.when = 0;
+                    notification.flags = Notification.FLAG_ONGOING_EVENT;
+                    notification.tickerText = title;
+                    notification.defaults = 0; // please be quiet
+                    notification.sound = null;
+                    notification.vibrate = null;
+
+                    Intent intent = Intent.makeRestartActivityTask(
+                            new ComponentName("com.android.settings",
+                                    "com.android.settings.DevelopmentSettings"));
+                    PendingIntent pi = PendingIntent.getActivity(mContext, 0,
+                            intent, 0);
+                    notification.setLatestEventInfo(mContext, title, message, pi);
+                    mAdbNotificationShown = true;
+                    mNotificationManager.notify(id, notification);
+                }
+            } else if (mAdbNotificationShown) {
+                mAdbNotificationShown = false;
+                mNotificationManager.cancel(id);
+            }
+        }
+
+        public void dump(FileDescriptor fd, PrintWriter pw) {
+            pw.println("  USB Device State:");
+            pw.println("    Current Functions: " + mCurrentFunctions);
+            pw.println("    Default Functions: " + mDefaultFunctions);
+            pw.println("    mConnected: " + mConnected);
+            pw.println("    mConfigured: " + mConfigured);
+            pw.println("    mCurrentAccessory: " + mCurrentAccessory);
+            try {
+                pw.println("    Kernel function list: "
+               + Arrays.toString(new File(FUNCTIONS_PATH).list()));
+                pw.println("    Mass storage backing file: "
+                        + FileUtils.readTextFile(new File(MASS_STORAGE_FILE_PATH), 0, null).trim());
+            } catch (IOException e) {
+                pw.println("IOException: " + e);
+            }
+        }
+    }
+
+    @Override
+    public void setCurrentFunction(String function, boolean makeDefault) {
+        if (DEBUG) Slog.d(TAG, "setCurrentFunction(" + function + ") default: " + makeDefault);
+        mHandler.sendMessage(MSG_SET_CURRENT_FUNCTION, function, makeDefault);
+    }
+}
diff --git a/services/java/com/android/server/usb/UsbDeviceManager.java b/services/java/com/android/server/usb/UsbDeviceManager.java
index ed83fbe..2e6025a 100644
--- a/services/java/com/android/server/usb/UsbDeviceManager.java
+++ b/services/java/com/android/server/usb/UsbDeviceManager.java
@@ -137,6 +137,14 @@ public class UsbDeviceManager {
         }
     };
 
+    // Dummy constructor to use when extending class
+    public UsbDeviceManager() {
+        mContext = null;
+        mContentResolver = null;
+        mSettingsManager = null;
+        mHasUsbAccessory = false;
+    }
+
     public UsbDeviceManager(Context context, UsbSettingsManager settingsManager) {
         mContext = context;
         mContentResolver = context.getContentResolver();
@@ -557,10 +565,10 @@ public class UsbDeviceManager {
                     id = com.android.internal.R.string.usb_mtp_notification_title;
                 } else if (containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_PTP)) {
                     id = com.android.internal.R.string.usb_ptp_notification_title;
-                } else if (containsFunction(mCurrentFunctions,
-                        UsbManager.USB_FUNCTION_MASS_STORAGE)) {
-                    id = com.android.internal.R.string.usb_cd_installer_notification_title;
-                } else if (containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ACCESSORY)) {
+                } /* else if (containsFunction(mCurrentFunctions,
+                     UsbManager.USB_FUNCTION_MASS_STORAGE)) { // Disable this as it causes double USB settings menues when in UMS mode.
+                     id = com.android.internal.R.string.usb_cd_installer_notification_title; 
+                     } */ else if (containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ACCESSORY)) {
                     id = com.android.internal.R.string.usb_accessory_notification_title;
                 } else {
                     // There is a different notification for USB tethering so we don't need one here
diff --git a/services/java/com/android/server/usb/UsbService.java b/services/java/com/android/server/usb/UsbService.java
index 9f2c17a..ce8206c 100644
--- a/services/java/com/android/server/usb/UsbService.java
+++ b/services/java/com/android/server/usb/UsbService.java
@@ -19,6 +19,7 @@ package com.android.server.usb;
 import android.app.PendingIntent;
 import android.content.Context;
 import android.content.pm.PackageManager;
+import android.content.res.Resources;
 import android.hardware.usb.IUsbManager;
 import android.hardware.usb.UsbAccessory;
 import android.hardware.usb.UsbDevice;
@@ -53,6 +54,8 @@ public class UsbService extends IUsbManager.Stub {
         if (new File("/sys/class/android_usb").exists()) {
             mDeviceManager = new UsbDeviceManager(context, mSettingsManager);
         }
+        else if(new File(Resources.getSystem().getString(com.android.internal.R.string.config_legacyUmsLunFile)).exists())
+            mDeviceManager = new LegacyUsbDeviceManager(context, mSettingsManager);
     }
 
     public void systemReady() {
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index f63c0c1..486a403 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -1,6 +1,10 @@
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
+ifeq ($(BOARD_HAVE_CODEC_SUPPORT),SAMSUNG_CODEC_SUPPORT)
+LOCAL_CFLAGS     += -DSAMSUNG_CODEC_SUPPORT
+endif
+
 LOCAL_SRC_FILES:= \
     Layer.cpp 								\
     LayerBase.cpp 							\
@@ -14,7 +18,7 @@ LOCAL_SRC_FILES:= \
     MessageQueue.cpp 						\
     SurfaceFlinger.cpp 						\
     SurfaceTextureLayer.cpp 				\
-    Transform.cpp 							\
+    Transform.cpp 							
     
 
 LOCAL_CFLAGS:= -DLOG_TAG=\"SurfaceFlinger\"
@@ -27,7 +31,7 @@ ifeq ($(TARGET_BOARD_PLATFORM), omap4)
 	LOCAL_CFLAGS += -DHAS_CONTEXT_PRIORITY
 endif
 ifeq ($(TARGET_BOARD_PLATFORM), s5pc110)
-	LOCAL_CFLAGS += -DHAS_CONTEXT_PRIORITY -DNEVER_DEFAULT_TO_ASYNC_MODE
+	LOCAL_CFLAGS += -DHAS_CONTEXT_PRIORITY -DNEVER_DEFAULT_TO_ASYNC_MODE -DSURFACEFLINGER_FORCE_SCREEN_RELEASE
 	LOCAL_CFLAGS += -DREFRESH_RATE=56
 endif
 
@@ -45,11 +49,30 @@ LOCAL_SHARED_LIBRARIES := \
 # this is only needed for DDMS debugging
 LOCAL_SHARED_LIBRARIES += libdvm libandroid_runtime
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
 LOCAL_C_INCLUDES := \
 	$(call include-path-for, corecg graphics)
 
 LOCAL_C_INCLUDES += hardware/libhardware/modules/gralloc
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+ifeq ($(TARGET_HAVE_BYPASS),true)
+    LOCAL_CFLAGS += -DBUFFER_COUNT_SERVER=3
+else
+    LOCAL_CFLAGS += -DBUFFER_COUNT_SERVER=2
+endif
+
+LOCAL_SHARED_LIBRARIES += \
+	libQcomUI
+LOCAL_C_INCLUDES += hardware/qcom/display/libqcomui
+ifeq ($(TARGET_QCOM_HDMI_OUT),true)
+LOCAL_CFLAGS += -DQCOM_HDMI_OUT
+endif
+endif
+
 LOCAL_MODULE:= libsurfaceflinger
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
index f94d321..84573c0 100644
--- a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
+++ b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
@@ -173,6 +173,17 @@ void DisplayHardware::init(uint32_t dpy)
             LOGW("H/W composition disabled");
             attribs[2] = EGL_CONFIG_CAVEAT;
             attribs[3] = EGL_SLOW_CONFIG;
+#ifdef QCOM_HARDWARE
+        } else {
+            // We have hardware composition enabled. Check the composition type
+            if (property_get("debug.composition.type", property, NULL) > 0) {
+                if ((strncmp(property, "c2d", 3) == 0) ||
+                    (strncmp(property, "dyn", 3) == 0))
+                    mFlags |= C2D_COMPOSITION;
+                else if ((strncmp(property, "mdp", 3)) == 0)
+                    mFlags |= MDP_COMPOSITION;
+            }
+#endif
         }
     }
 
@@ -184,9 +195,13 @@ void DisplayHardware::init(uint32_t dpy)
     eglGetConfigs(display, NULL, 0, &numConfigs);
 
     EGLConfig config = NULL;
+#ifdef FORCE_EGL_CONFIG
+    config = (EGLConfig)FORCE_EGL_CONFIG;
+#else
     err = selectConfigForPixelFormat(display, attribs, format, &config);
     LOGE_IF(err, "couldn't find an EGLConfig matching the screen format");
-    
+#endif
+
     EGLint r,g,b,a;
     eglGetConfigAttrib(display, config, EGL_RED_SIZE,   &r);
     eglGetConfigAttrib(display, config, EGL_GREEN_SIZE, &g);
diff --git a/services/surfaceflinger/DisplayHardware/DisplayHardware.h b/services/surfaceflinger/DisplayHardware/DisplayHardware.h
index f02c954..d12e187 100644
--- a/services/surfaceflinger/DisplayHardware/DisplayHardware.h
+++ b/services/surfaceflinger/DisplayHardware/DisplayHardware.h
@@ -47,6 +47,10 @@ public:
         PARTIAL_UPDATES             = 0x00020000,   // video driver feature
         SLOW_CONFIG                 = 0x00040000,   // software
         SWAP_RECTANGLE              = 0x00080000,
+#ifdef QCOM_HARDWARE
+        C2D_COMPOSITION             = 0x00100000,   // C2D composition
+        MDP_COMPOSITION             = 0x00200000    // MDP composition
+#endif
     };
 
     DisplayHardware(
@@ -76,6 +80,9 @@ public:
 
     uint32_t getPageFlipCount() const;
     EGLDisplay getEGLDisplay() const { return mDisplay; }
+#ifdef QCOM_HARDWARE
+    EGLDisplay getEGLSurface() const { return mSurface; }
+#endif
 
     void dump(String8& res) const;
 
diff --git a/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp b/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp
index 3b7c09e..539f862 100644
--- a/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp
+++ b/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp
@@ -40,8 +40,10 @@
 // ----------------------------------------------------------------------------
 namespace android {
 
-static char const * const kSleepFileName = "/sys/power/wait_for_fb_sleep";
-static char const * const kWakeFileName  = "/sys/power/wait_for_fb_wake";
+static char const * kSleepFileName = "/sys/power/wait_for_fb_sleep";
+static char const * kWakeFileName  = "/sys/power/wait_for_fb_wake";
+static char const * const kOldSleepFileName = "/sys/android_power/wait_for_fb_sleep";
+static char const * const kOldWakeFileName = "/sys/android_power/wait_for_fb_wake";
 
 // ----------------------------------------------------------------------------
 
@@ -109,13 +111,21 @@ status_t DisplayHardwareBase::DisplayEventThread::releaseScreen() const
 
 status_t DisplayHardwareBase::DisplayEventThread::readyToRun()
 {
+    if (access(kSleepFileName, R_OK) || access(kWakeFileName, R_OK)) {
+        if (access(kOldSleepFileName, R_OK) || access(kOldWakeFileName, R_OK)) {
+            LOGE("Couldn't open %s or %s", kSleepFileName, kWakeFileName);
+            return NO_INIT;
+        }
+        kSleepFileName = kOldSleepFileName;
+        kWakeFileName = kOldWakeFileName;
+    }
     return NO_ERROR;
 }
 
 status_t DisplayHardwareBase::DisplayEventThread::initCheck() const
 {
-    return ((access(kSleepFileName, R_OK) == 0 &&
-            access(kWakeFileName, R_OK) == 0)) ? NO_ERROR : NO_INIT;
+    return (access(kSleepFileName, R_OK) == 0 && access(kWakeFileName, R_OK) == 0) ||
+           (access(kOldSleepFileName, R_OK) == 0 && access(kOldWakeFileName, R_OK) == 0) ? NO_ERROR : NO_INIT;
 }
 
 // ----------------------------------------------------------------------------
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index be9b226..1b843b1 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -34,6 +34,10 @@
 #include "HWComposer.h"
 #include "SurfaceFlinger.h"
 
+#ifdef QCOM_HARDWARE
+#include <qcom_ui.h>
+#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -89,6 +93,7 @@ status_t HWComposer::createWorkList(size_t numLayers) {
             free(mList);
             size_t size = sizeof(hwc_layer_list) + numLayers*sizeof(hwc_layer_t);
             mList = (hwc_layer_list_t*)malloc(size);
+            memset(mList, 0, size);
             mCapacity = numLayers;
         }
         mList->flags = HWC_GEOMETRY_CHANGED;
@@ -98,6 +103,10 @@ status_t HWComposer::createWorkList(size_t numLayers) {
 }
 
 status_t HWComposer::prepare() const {
+#ifdef QCOM_HARDWARE
+    // Reset the Skip composition flag
+    mList->flags &= ~HWC_SKIP_COMPOSITION;
+#endif
     int err = mHwc->prepare(mHwc, mList);
     if (err == NO_ERROR) {
         size_t numOVLayers = 0;
@@ -115,6 +124,12 @@ status_t HWComposer::prepare() const {
                 case HWC_FRAMEBUFFER:
                     numFBLayers++;
                     break;
+#ifdef QCOM_HARDWARE
+                default:
+                    if(isUpdatingFB((HWCCompositionType)l.compositionType))
+                        numFBLayers++;
+                    break;
+#endif
             }
         }
         mNumOVLayers = numOVLayers;
@@ -167,6 +182,12 @@ hwc_layer_t* HWComposer::getLayers() const {
     return mList ? mList->hwLayers : 0;
 }
 
+#ifdef QCOM_HARDWARE
+uint32_t HWComposer::getFlags() const {
+    return mList ? mList->flags : 0;
+}
+#endif
+
 void HWComposer::dump(String8& result, char* buffer, size_t SIZE,
         const Vector< sp<LayerBase> >& visibleLayersSortedByZ) const {
     if (mHwc && mList) {
@@ -191,8 +212,13 @@ void HWComposer::dump(String8& result, char* buffer, size_t SIZE,
             }
             snprintf(buffer, SIZE,
                     " %8s | %08x | %08x | %08x | %02x | %05x | %08x | [%5d,%5d,%5d,%5d] | [%5d,%5d,%5d,%5d] %s\n",
+#ifdef QCOM_HARDWARE
+                    l.compositionType ? (l.compositionType == HWC_OVERLAY ? "OVERLAY" : "COPYBIT") : "FB",
+                    intptr_t(l.handle), l.hints, l.flags, l.transform & FINAL_TRANSFORM_MASK, l.blending, format,
+#else
                     l.compositionType ? "OVERLAY" : "FB",
                     intptr_t(l.handle), l.hints, l.flags, l.transform, l.blending, format,
+#endif
                     l.sourceCrop.left, l.sourceCrop.top, l.sourceCrop.right, l.sourceCrop.bottom,
                     l.displayFrame.left, l.displayFrame.top, l.displayFrame.right, l.displayFrame.bottom,
                     layer->getName().string());
@@ -205,5 +231,13 @@ void HWComposer::dump(String8& result, char* buffer, size_t SIZE,
     }
 }
 
+#ifdef QCOM_HARDWARE
+void HWComposer::perform(int event, int value) {
+    if (mHwc) {
+        mHwc->perform(mHwc, event, value);
+    }
+}
+#endif
+
 // ---------------------------------------------------------------------------
 }; // namespace android
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.h b/services/surfaceflinger/DisplayHardware/HWComposer.h
index aa8ebe1..faf7f16 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.h
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.h
@@ -67,6 +67,12 @@ public:
     // updated in preapre()
     size_t getLayerCount(int type) const;
 
+#ifdef QCOM_HARDWARE
+    // gets the list flags
+    uint32_t getFlags() const;
+    void perform(int event, int value);
+#endif
+
     // for debugging
     void dump(String8& out, char* scratch, size_t SIZE,
             const Vector< sp<LayerBase> >& visibleLayersSortedByZ) const;
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index d3b0dbf..9380e82 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -39,6 +39,11 @@
 #include "SurfaceFlinger.h"
 #include "SurfaceTextureLayer.h"
 
+#ifdef QCOM_HARDWARE
+#include <qcom_ui.h>
+#define SHIFT_SRC_TRANSFORM 4
+#endif
+ 
 #define DEBUG_RESIZE    0
 
 
@@ -59,10 +64,16 @@ Layer::Layer(SurfaceFlinger* flinger,
         mOpaqueLayer(true),
         mNeedsDithering(false),
         mSecure(false),
+#ifdef QCOM_HARDWARE
+        mLayerQcomFlags(0),
+#endif
         mProtectedByApp(false)
 {
     mCurrentCrop.makeInvalid();
     glGenTextures(1, &mTextureName);
+#ifdef QCOM_HARDWARE
+    updateLayerQcomFlags(LAYER_UPDATE_STATUS, true, mLayerQcomFlags);
+#endif
 }
 
 void Layer::onFirstRef()
@@ -83,7 +94,11 @@ void Layer::onFirstRef()
     mSurfaceTexture = new SurfaceTextureLayer(mTextureName, this);
     mSurfaceTexture->setFrameAvailableListener(new FrameQueuedListener(this));
     mSurfaceTexture->setSynchronousMode(true);
+#ifdef QCOM_HARDWARE
+    mSurfaceTexture->setBufferCountServer(BUFFER_COUNT_SERVER);
+#else
     mSurfaceTexture->setBufferCountServer(2);
+#endif
 }
 
 Layer::~Layer()
@@ -168,10 +183,14 @@ status_t Layer::setBuffers( uint32_t w, uint32_t h,
     mSurfaceTexture->setDefaultBufferSize(w, h);
     mSurfaceTexture->setDefaultBufferFormat(format);
 
-    // we use the red index
-    int displayRedSize = displayInfo.getSize(PixelFormatInfo::INDEX_RED);
-    int layerRedsize = info.getSize(PixelFormatInfo::INDEX_RED);
-    mNeedsDithering = layerRedsize > displayRedSize;
+    if (mFlinger->getUseDithering()) {
+        // we use the red index
+        int displayRedSize = displayInfo.getSize(PixelFormatInfo::INDEX_RED);
+        int layerRedsize = info.getSize(PixelFormatInfo::INDEX_RED);
+        mNeedsDithering = layerRedsize > displayRedSize;
+    } else {
+        mNeedsDithering = false;
+    }
 
     return NO_ERROR;
 }
@@ -182,11 +201,28 @@ void Layer::setGeometry(hwc_layer_t* hwcl)
 
     hwcl->flags &= ~HWC_SKIP_LAYER;
 
+#ifdef QCOM_HARDWARE
+    const DisplayHardware& hw(graphicPlane(0).displayHardware());
+    // we can't do alpha-fade with the hwc HAL. C2D composition
+    // can handle fade cases
+    const State& s(drawingState());
+    if (s.alpha < 0xFF) {
+        if ((DisplayHardware::C2D_COMPOSITION & hw.getFlags()) && (!isOpaque())) {
+            hwcl->blending = mPremultipliedAlpha ?
+                HWC_BLENDING_PREMULT : HWC_BLENDING_COVERAGE;
+        } else {
+            hwcl->flags = HWC_SKIP_LAYER;
+        }
+    }
+
+    hwcl->alpha = s.alpha;
+#else
     // we can't do alpha-fade with the hwc HAL
     const State& s(drawingState());
     if (s.alpha < 0xFF) {
         hwcl->flags = HWC_SKIP_LAYER;
-    }
+     }
+#endif
 
     /*
      * Transformations are applied in this order:
@@ -208,6 +244,12 @@ void Layer::setGeometry(hwc_layer_t* hwcl)
         hwcl->flags = HWC_SKIP_LAYER;
     } else {
         hwcl->transform = finalTransform;
+#ifdef QCOM_HARDWARE
+        //mBufferTransform will have the srcTransform
+        //include src and final transform in the hwcl->transform
+        hwcl->transform = (( bufferOrientation.getOrientation() <<
+                                       SHIFT_SRC_TRANSFORM) | hwcl->transform);
+#endif
     }
 
     if (isCropped()) {
@@ -240,6 +282,10 @@ void Layer::setPerFrameData(hwc_layer_t* hwcl) {
     } else {
         hwcl->handle = buffer->handle;
     }
+#ifdef QCOM_HARDWARE
+    updateLayerQcomFlags(LAYER_ASYNCHRONOUS_STATUS, !mSurfaceTexture->isSynchronousMode(), mLayerQcomFlags);
+    hwcl->flags = getPerFrameFlags(hwcl->flags, mLayerQcomFlags);
+#endif
 }
 
 void Layer::onDraw(const Region& clip) const
@@ -267,38 +313,91 @@ void Layer::onDraw(const Region& clip) const
         // if not everything below us is covered, we plug the holes!
         Region holes(clip.subtract(under));
         if (!holes.isEmpty()) {
-            clearWithOpenGL(holes, 0, 0, 0, 1);
+#ifdef SAMSUNG_CODEC_SUPPORT
+            clearWithOpenGL(holes, 0, 0, 0, 0);
+#else
+             clearWithOpenGL(holes, 0, 0, 0, 1);
+#endif
         }
         return;
     }
 
+#ifdef QCOM_HARDWARE
+        if (!isGPUSupportedFormat(mActiveBuffer->format)) {
+	    clearWithOpenGL(clip, 0, 0, 0, 1);
+        return;
+	}
+
+#ifdef DECIDE_TEXTURE_TARGET
+    GLuint currentTextureTarget = mSurfaceTexture->getCurrentTextureTarget();
+#endif
+#endif
+
     if (!isProtected()) {
-        glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+#ifdef DECIDE_TEXTURE_TARGET
+        glBindTexture(currentTextureTarget, mTextureName);
+#else
+         glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+#endif
         GLenum filter = GL_NEAREST;
         if (getFiltering() || needsFiltering() || isFixedSize() || isCropped()) {
             // TODO: we could be more subtle with isFixedSize()
             filter = GL_LINEAR;
         }
+#ifdef DECIDE_TEXTURE_TARGET
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MAG_FILTER, filter);
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MIN_FILTER, filter);
+#else
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, filter);
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, filter);
+#endif
         glMatrixMode(GL_TEXTURE);
         glLoadMatrixf(mTextureMatrix);
         glMatrixMode(GL_MODELVIEW);
         glDisable(GL_TEXTURE_2D);
-        glEnable(GL_TEXTURE_EXTERNAL_OES);
-    } else {
-        glBindTexture(GL_TEXTURE_2D, mFlinger->getProtectedTexName());
-        glMatrixMode(GL_TEXTURE);
-        glLoadIdentity();
-        glMatrixMode(GL_MODELVIEW);
-        glDisable(GL_TEXTURE_EXTERNAL_OES);
-        glEnable(GL_TEXTURE_2D);
+#ifdef DECIDE_TEXTURE_TARGET
+        glEnable(currentTextureTarget);
+#else
+         glEnable(GL_TEXTURE_EXTERNAL_OES);
+#endif
+     } else {
+#ifdef DECIDE_TEXTURE_TARGET
+        glBindTexture(currentTextureTarget, mFlinger->getProtectedTexName());
+#else
+         glBindTexture(GL_TEXTURE_2D, mFlinger->getProtectedTexName());
+#endif
+         glMatrixMode(GL_TEXTURE);
+         glLoadIdentity();
+         glMatrixMode(GL_MODELVIEW);
+#ifdef DECIDE_TEXTURE_TARGET
+        glEnable(currentTextureTarget);
+#else
+         glDisable(GL_TEXTURE_EXTERNAL_OES);
+         glEnable(GL_TEXTURE_2D);
+#endif
+     }
+ 
+#ifdef QCOM_HARDWARE
+    if(needsDithering()) {
+        glEnable(GL_DITHER);
     }
 
-    drawWithOpenGL(clip);
-
-    glDisable(GL_TEXTURE_EXTERNAL_OES);
-    glDisable(GL_TEXTURE_2D);
+    int composeS3DFormat = mQCLayer->needsS3DCompose();
+    if (composeS3DFormat)
+        drawS3DUIWithOpenGL(clip);
+    else
+        drawWithOpenGL(clip);
+#else
+     drawWithOpenGL(clip);
+#endif
+ 
+     glDisable(GL_TEXTURE_EXTERNAL_OES);
+     glDisable(GL_TEXTURE_2D);
+#ifdef QCOM_HARDWARE
+    if(needsDithering()) {
+        glDisable(GL_DITHER);
+    }
+#endif
 }
 
 // As documented in libhardware header, formats in the range
@@ -339,6 +438,12 @@ bool Layer::isProtected() const
     return (activeBuffer != 0) &&
             (activeBuffer->getUsage() & GRALLOC_USAGE_PROTECTED);
 }
+#ifdef QCOM_HARDWARE
+void Layer::setIsUpdating(bool isUpdating)
+{
+    updateLayerQcomFlags(LAYER_UPDATE_STATUS, isUpdating, mLayerQcomFlags);
+}
+#endif
 
 uint32_t Layer::doTransaction(uint32_t flags)
 {
@@ -400,14 +505,34 @@ void Layer::lockPageFlip(bool& recomputeVisibleRegions)
             mFlinger->signalEvent();
         }
 
-        if (mSurfaceTexture->updateTexImage() < NO_ERROR) {
+#ifdef DECIDE_TEXTURE_TARGET
+        // While calling updateTexImage() from SurfaceFlinger, let it know
+        // by passing an extra parameter
+        // This will be true always.
+
+        bool isComposition = true;
+
+        if (mSurfaceTexture->updateTexImage(isComposition) < NO_ERROR) {
+#else
+         if (mSurfaceTexture->updateTexImage() < NO_ERROR) {
+#endif
             // something happened!
             recomputeVisibleRegions = true;
             return;
         }
 
-        // update the active buffer
-        mActiveBuffer = mSurfaceTexture->getCurrentBuffer();
+#ifdef QCOM_HARDWARE
+        updateLayerQcomFlags(LAYER_UPDATE_STATUS, true, mLayerQcomFlags);
+#endif
+         // update the active buffer
+         mActiveBuffer = mSurfaceTexture->getCurrentBuffer();
+ 
+#ifdef QCOM_HARDWARE
+        //Buffer validity changed. Reset HWC geometry flags.
+        if(oldActiveBuffer == NULL && mActiveBuffer != NULL) {
+            mFlinger->invalidateHwcGeometry();
+        }
+#endif
 
         const Rect crop(mSurfaceTexture->getCurrentCrop());
         const uint32_t transform(mSurfaceTexture->getCurrentTransform());
@@ -493,6 +618,10 @@ void Layer::lockPageFlip(bool& recomputeVisibleRegions)
                     bufWidth, bufHeight, mCurrentTransform,
                     front.requested_w, front.requested_h);
         }
+#ifdef QCOM_HARDWARE
+    } else {
+        updateLayerQcomFlags(LAYER_UPDATE_STATUS, false, mLayerQcomFlags);
+#endif
     }
 }
 
@@ -550,7 +679,12 @@ uint32_t Layer::getEffectiveUsage(uint32_t usage) const
         // need a hardware-protected path to external video sink
         usage |= GraphicBuffer::USAGE_PROTECTED;
     }
-    usage |= GraphicBuffer::USAGE_HW_COMPOSER;
+#ifdef MISSING_GRALLOC_BUFFERS
+    usage |= GraphicBuffer::USAGE_HW_TEXTURE;
+#else
+     usage |= GraphicBuffer::USAGE_HW_COMPOSER;
+#endif
+
     return usage;
 }
 
diff --git a/services/surfaceflinger/Layer.h b/services/surfaceflinger/Layer.h
index 2b9471b..3347c85 100644
--- a/services/surfaceflinger/Layer.h
+++ b/services/surfaceflinger/Layer.h
@@ -71,6 +71,9 @@ public:
     virtual bool needsDithering() const     { return mNeedsDithering; }
     virtual bool isSecure() const           { return mSecure; }
     virtual bool isProtected() const;
+#ifdef QCOM_HARDWARE
+    virtual void setIsUpdating(bool isUpdating);
+#endif
     virtual void onRemoved();
     virtual sp<Layer> getLayer() const { return const_cast<Layer*>(this); }
     virtual void setName(const String8& name);
@@ -124,6 +127,11 @@ private:
 
     // binder thread, transaction thread
     mutable Mutex mLock;
+
+#ifdef QCOM_HARDWARE
+    // Qcom specific flags for this layer.
+    int mLayerQcomFlags;
+#endif
 };
 
 // ---------------------------------------------------------------------------
diff --git a/services/surfaceflinger/LayerBase.cpp b/services/surfaceflinger/LayerBase.cpp
index f04add1..3d14dc0 100644
--- a/services/surfaceflinger/LayerBase.cpp
+++ b/services/surfaceflinger/LayerBase.cpp
@@ -32,6 +32,9 @@
 #include "LayerBase.h"
 #include "SurfaceFlinger.h"
 #include "DisplayHardware/DisplayHardware.h"
+#ifdef QCOM_HARDWARE
+#include "qcom_ui.h"
+#endif
 
 namespace android {
 
@@ -52,10 +55,16 @@ LayerBase::LayerBase(SurfaceFlinger* flinger, DisplayID display)
 {
     const DisplayHardware& hw(flinger->graphicPlane(0).displayHardware());
     mFlags = hw.getFlags();
+#ifdef QCOM_HARDWARE
+    mQCLayer = new QCBaseLayer;
+#endif
 }
 
 LayerBase::~LayerBase()
 {
+#ifdef QCOM_HARDWARE
+    delete mQCLayer;
+#endif
 }
 
 void LayerBase::setName(const String8& name) {
@@ -391,6 +400,7 @@ void LayerBase::clearWithOpenGL(const Region& clip, GLclampf red,
     glDisable(GL_TEXTURE_EXTERNAL_OES);
     glDisable(GL_TEXTURE_2D);
     glDisable(GL_BLEND);
+    glDisable(GL_DITHER);
 
     Region::const_iterator it = clip.begin();
     Region::const_iterator const end = clip.end();
@@ -452,6 +462,12 @@ void LayerBase::drawWithOpenGL(const Region& clip) const
     texCoords[3].u = 1;
     texCoords[3].v = 1;
 
+    if (needsDithering()) {
+        glEnable(GL_DITHER);
+    } else {
+        glDisable(GL_DITHER);
+    }
+
     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
     glVertexPointer(2, GL_FLOAT, 0, mVertices);
     glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
@@ -468,6 +484,136 @@ void LayerBase::drawWithOpenGL(const Region& clip) const
     glDisable(GL_BLEND);
 }
 
+#ifdef QCOM_HARDWARE
+void LayerBase::drawS3DUIWithOpenGL(const Region& clip) const
+{
+    const DisplayHardware& hw(graphicPlane(0).displayHardware());
+    const uint32_t fbHeight = hw.getHeight();
+    const uint32_t fbWidth = hw.getWidth();
+    const State& s(drawingState());
+
+    GLfloat tmpVertices[8][2];
+
+    GLenum src = mPremultipliedAlpha ? GL_ONE : GL_SRC_ALPHA;
+    if (UNLIKELY(s.alpha < 0xFF)) {
+        const GLfloat alpha = s.alpha * (1.0f/255.0f);
+        if (mPremultipliedAlpha) {
+            glColor4f(alpha, alpha, alpha, alpha);
+        } else {
+            glColor4f(1, 1, 1, alpha);
+        }
+        glEnable(GL_BLEND);
+        glBlendFunc(src, GL_ONE_MINUS_SRC_ALPHA);
+        glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    } else {
+        glColor4f(1, 1, 1, 1);
+        glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+        if (!isOpaque()) {
+            glEnable(GL_BLEND);
+            glBlendFunc(src, GL_ONE_MINUS_SRC_ALPHA);
+        } else {
+            glDisable(GL_BLEND);
+        }
+    }
+
+    struct TexCoords {
+        GLfloat u;
+        GLfloat v;
+    };
+
+    TexCoords texCoords[4];
+    texCoords[0].u = 0;
+    texCoords[0].v = 1;
+    texCoords[1].u = 0;
+    texCoords[1].v = 0;
+    texCoords[2].u = 1;
+    texCoords[2].v = 0;
+    texCoords[3].u = 1;
+    texCoords[3].v = 1;
+
+    if (needsDithering()) {
+        glEnable(GL_DITHER);
+    } else {
+        glDisable(GL_DITHER);
+    }
+
+    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+
+    Region::const_iterator it = clip.begin();
+    Region::const_iterator const end = clip.end();
+
+    // Check if layer needs to be converted to S3D format
+    int composeS3DFormat = mQCLayer->needsS3DCompose();
+    int xoffset = fbWidth/2 ;
+    int yoffset = fbHeight/2;
+    glClearColor(0,0,0,0);
+    // Calculate the new vertices for S3D conversion
+    switch (composeS3DFormat) {
+        case QCBaseLayer::eS3D_SIDE_BY_SIDE:
+            for (int i = 0; i < 4; i++) {
+                tmpVertices[i][0] = mVertices[i][0]/2;
+                tmpVertices[i][1] = mVertices[i][1];
+                tmpVertices[i+4][0] = xoffset + mVertices[i][0]/2;
+                tmpVertices[i+4][1] = mVertices[i][1];
+            }
+            glVertexPointer(2, GL_FLOAT, 0, tmpVertices);
+            glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
+            while (it != end) {
+                const Rect& r = *it++;
+                const GLint sy = fbHeight - (r.top + r.height());
+                glScissor(r.left/2, sy, r.width()/2, r.height());
+                glClear(GL_COLOR_BUFFER_BIT);
+                glDrawArrays(GL_TRIANGLE_FAN, 0, 4);//glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, pindices);
+            }
+
+            glVertexPointer(2, GL_FLOAT, 0, tmpVertices[4]);
+            glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
+            it = clip.begin();
+            while (it != end) {
+                const Rect& r = *it++;
+                const GLint sy = fbHeight - (r.top + r.height());
+                glScissor(xoffset+r.left/2, sy, r.width()/2, r.height());
+                glClear(GL_COLOR_BUFFER_BIT);
+                glDrawArrays(GL_TRIANGLE_FAN, 0, 4);//glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, pindices);
+            }
+            break;
+        case QCBaseLayer::eS3D_TOP_BOTTOM:
+            for (int i = 0; i < 4; i++) {
+                tmpVertices[i][0] = mVertices[i][0];
+                tmpVertices[i][1] = mVertices[i][1]/2;
+                tmpVertices[i+4][0] = mVertices[i][0];
+                tmpVertices[i+4][1] = yoffset + mVertices[i][1]/2;
+            }
+            glVertexPointer(2, GL_FLOAT, 0, tmpVertices);
+            glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
+            while (it != end) {
+                const Rect& r = *it++;
+                const GLint sy = fbHeight - (r.top + r.height());
+                glScissor(r.left, sy/2, r.width(), r.height()/2);
+                glClear(GL_COLOR_BUFFER_BIT);
+                glDrawArrays(GL_TRIANGLE_FAN, 0, 4);//glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, pindices);
+            }
+
+            glVertexPointer(2, GL_FLOAT, 0, tmpVertices[4]);
+            glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
+            it = clip.begin();
+            while (it != end) {
+                const Rect& r = *it++;
+                const GLint sy = fbHeight - (r.top + r.height());
+                glScissor(r.left, yoffset+sy/2, r.width(), r.height()/2);
+                glClear(GL_COLOR_BUFFER_BIT);
+                glDrawArrays(GL_TRIANGLE_FAN, 0, 4);//glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, pindices);
+            }
+            break;
+        default:
+            LOGE("%s: Unknown S3D format", __FUNCTION__);
+            break;
+    }
+    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+    glDisable(GL_BLEND);
+}
+#endif
+
 void LayerBase::dump(String8& result, char* buffer, size_t SIZE) const
 {
     const Layer::State& s(drawingState());
diff --git a/services/surfaceflinger/LayerBase.h b/services/surfaceflinger/LayerBase.h
index 7f62145..d43e888 100644
--- a/services/surfaceflinger/LayerBase.h
+++ b/services/surfaceflinger/LayerBase.h
@@ -37,6 +37,9 @@
 
 #include "DisplayHardware/DisplayHardware.h"
 #include "Transform.h"
+#ifdef QCOM_HARDWARE
+#include "qcom_ui.h"
+#endif
 
 namespace android {
 
@@ -205,7 +208,12 @@ public:
     /** called with the state lock when the surface is removed from the
      *  current list */
     virtual void onRemoved() { };
-    
+
+#ifdef QCOM_HARDWARE
+    /** Called from surfaceFlinger to update the layer */
+    virtual void setIsUpdating(bool isUpdating) { };
+#endif
+
     /** always call base class first */
     virtual void dump(String8& result, char* scratch, size_t size) const;
     virtual void shortDump(String8& result, char* scratch, size_t size) const;
@@ -222,6 +230,9 @@ public:
 
     int32_t  getOrientation() const { return mOrientation; }
     int32_t  getPlaneOrientation() const { return mPlaneOrientation; }
+#ifdef QCOM_HARDWARE
+    QCBaseLayer * mQCLayer;
+#endif
     
 protected:
     const GraphicPlane& graphicPlane(int dpy) const;
@@ -231,6 +242,9 @@ protected:
                                GLclampf b, GLclampf alpha) const;
           void clearWithOpenGL(const Region& clip) const;
           void drawWithOpenGL(const Region& clip) const;
+#ifdef QCOM_HARDWARE
+          void drawS3DUIWithOpenGL(const Region& clip) const;
+#endif
 
           void setFiltering(bool filtering);
           bool getFiltering() const;
diff --git a/services/surfaceflinger/LayerScreenshot.cpp b/services/surfaceflinger/LayerScreenshot.cpp
index 68e6660..e8f628a 100644
--- a/services/surfaceflinger/LayerScreenshot.cpp
+++ b/services/surfaceflinger/LayerScreenshot.cpp
@@ -124,6 +124,11 @@ void LayerScreenshot::onDraw(const Region& clip) const
         }
 
         glColor4f(0, 0, 0, alpha);
+#ifdef QCOM_HARDWARE
+        if(hw.getFormat() == PIXEL_FORMAT_RGB_565) {
+            glEnable(GL_DITHER);
+        }
+#endif
 
         glDisable(GL_TEXTURE_EXTERNAL_OES);
         glEnable(GL_TEXTURE_2D);
@@ -148,6 +153,11 @@ void LayerScreenshot::onDraw(const Region& clip) const
         glDisable(GL_BLEND);
         glDisable(GL_TEXTURE_2D);
         glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+#ifdef QCOM_HARDWARE
+        if(hw.getFormat() == PIXEL_FORMAT_RGB_565) {
+            glDisable(GL_DITHER);
+        }
+#endif
     }
 }
 
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 24bd2a6..cca971e 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -57,6 +57,9 @@
 #include "DisplayHardware/HWComposer.h"
 
 #include <private/surfaceflinger/SharedBufferStack.h>
+#ifdef QCOM_HARDWARE
+#include <qcom_ui.h>
+#endif
 
 /* ideally AID_GRAPHICS would be in a semi-public header
  * or there would be a way to map a user/group name to its id
@@ -69,6 +72,10 @@
 
 #define DISPLAY_COUNT       1
 
+//#ifdef USE_LGE_HDMI
+//extern "C" void NvDispMgrAutoOrientation(int rotation);
+//#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -98,8 +105,15 @@ SurfaceFlinger::SurfaceFlinger()
         mDebugInTransaction(0),
         mLastTransactionTime(0),
         mBootFinished(false),
+#ifdef QCOM_HDMI_OUT
+        mExtDispOutput(EXT_TYPE_NONE),
+#endif
+#ifdef QCOM_HARDWARE
+        mCanSkipComposition(false),
+#endif
         mConsoleSignals(0),
-        mSecureFrameBuffer(0)
+        mSecureFrameBuffer(0),
+        mUseDithering(false)
 {
     init();
 }
@@ -119,6 +133,10 @@ void SurfaceFlinger::init()
 
     property_get("debug.sf.ddms", value, "0");
     mDebugDDMS = atoi(value);
+
+    property_get("persist.sys.use_dithering", value, "0");
+    mUseDithering = atoi(value) == 1;
+
     if (mDebugDDMS) {
         DdmConnection::start(getServiceName());
     }
@@ -126,6 +144,7 @@ void SurfaceFlinger::init()
     LOGI_IF(mDebugRegion,       "showupdates enabled");
     LOGI_IF(mDebugBackground,   "showbackground enabled");
     LOGI_IF(mDebugDDMS,         "DDMS debugging enabled");
+    LOGI_IF(mUseDithering,      "use dithering");
 }
 
 SurfaceFlinger::~SurfaceFlinger()
@@ -404,7 +423,16 @@ bool SurfaceFlinger::threadLoop()
         handleConsoleEvents();
     }
 
+#ifdef QCOM_HDMI_OUT
+    //Serializes HDMI event handling and drawing.
+    //Necessary for race-free overlay channel management.
+    //Must always be held only after handleConsoleEvents() since
+    //that could enable / disable HDMI based on suspend resume
+    Mutex::Autolock _l(mExtDispLock);
+#else
     // if we're in a global transaction, don't do anything.
+#endif
+
     const uint32_t mask = eTransactionNeeded | eTraversalNeeded;
     uint32_t transactionFlags = peekTransactionFlags(mask);
     if (UNLIKELY(transactionFlags)) {
@@ -433,19 +461,39 @@ bool SurfaceFlinger::threadLoop()
 
         logger.log(GraphicLog::SF_REPAINT, index);
         handleRepaint();
+#ifdef QCOM_HARDWARE
+        if (!mCanSkipComposition) {
+            // inform the h/w that we're done compositing
+            logger.log(GraphicLog::SF_COMPOSITION_COMPLETE, index);
+            hw.compositionComplete();
+
+            logger.log(GraphicLog::SF_SWAP_BUFFERS, index);
+            postFramebuffer();
+        } else {
+            HWComposer& hwc(graphicPlane(0).displayHardware().getHwComposer());
+            hwc.commit();
+        }
+#else
+    // inform the h/w that we're done compositing
+	logger.log(GraphicLog::SF_COMPOSITION_COMPLETE, index);
+	hw.compositionComplete();
 
-        // inform the h/w that we're done compositing
-        logger.log(GraphicLog::SF_COMPOSITION_COMPLETE, index);
-        hw.compositionComplete();
-
-        logger.log(GraphicLog::SF_SWAP_BUFFERS, index);
-        postFramebuffer();
+	logger.log(GraphicLog::SF_SWAP_BUFFERS, index);
+	postFramebuffer();
+#endif
 
         logger.log(GraphicLog::SF_REPAINT_DONE, index);
     } else {
         // pretend we did the post
         hw.compositionComplete();
         usleep(16667); // 60 fps period
+
+#ifdef QCOM_HARDWARE
+        //If the draw is skipped by any chance, we need to force
+        //composition atleast once.
+        HWComposer& hwc(hw.getHwComposer());
+        hwc.perform(EVENT_FORCE_COMPOSITION, 1);
+#endif
     }
     return true;
 }
@@ -457,7 +505,18 @@ void SurfaceFlinger::postFramebuffer()
     LOGW_IF(mSwapRegion.isEmpty(), "mSwapRegion is empty");
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
     const nsecs_t now = systemTime();
+#ifdef QCOM_HDMI_OUT
+    const GraphicPlane& plane(graphicPlane(0));
+    const Transform& planeTransform(plane.transform());
+#endif
     mDebugInSwapBuffers = now;
+#ifdef QCOM_HDMI_OUT
+    //If orientation has changed, inform gralloc for HDMI mirroring
+    if(mOrientationChanged) {
+        mOrientationChanged = false;
+        hw.orientationChanged(planeTransform.getOrientation());
+    }
+#endif
     hw.flip(mSwapRegion);
     mLastSwapBufferTime = systemTime() - now;
     mDebugInSwapBuffers = 0;
@@ -472,14 +531,17 @@ void SurfaceFlinger::handleConsoleEvents()
     int what = android_atomic_and(0, &mConsoleSignals);
     if (what & eConsoleAcquired) {
         hw.acquireScreen();
-        // this is a temporary work-around, eventually this should be called
-        // by the power-manager
-        SurfaceFlinger::turnElectronBeamOn(mElectronBeamAnimationMode);
+#ifdef QCOM_HDMI_OUT
+        updateHwcExternalDisplay(mExtDispOutput);
+#endif
     }
 
     if (what & eConsoleReleased) {
         if (hw.isScreenAcquired()) {
             hw.releaseScreen();
+#ifdef QCOM_HDMI_OUT
+            updateHwcExternalDisplay(false);
+#endif
         }
     }
 
@@ -545,6 +607,9 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
             // Currently unused: const uint32_t flags = mCurrentState.orientationFlags;
             GraphicPlane& plane(graphicPlane(dpy));
             plane.setOrientation(orientation);
+#ifdef QCOM_HDMI_OUT
+            mOrientationChanged = true;
+#endif
 
             // update the shared control block
             const DisplayHardware& hw(plane.displayHardware());
@@ -662,6 +727,9 @@ void SurfaceFlinger::computeVisibleRegions(
             // as well, as the old visible region
             dirty.orSelf(layer->visibleRegionScreen);
             layer->contentDirty = false;
+#ifdef QCOM_HARDWARE
+            layer->setIsUpdating(true);
+#endif
         } else {
             /* compute the exposed region:
              *   the exposed region consists of two components:
@@ -851,13 +919,41 @@ void SurfaceFlinger::handleRepaint()
     }
 
     setupHardwareComposer(mDirtyRegion);
+#ifdef QCOM_HARDWARE
+    if (!mCanSkipComposition)
+        composeSurfaces(mDirtyRegion);
+#else
     composeSurfaces(mDirtyRegion);
+#endif
 
     // update the swap region and clear the dirty region
     mSwapRegion.orSelf(mDirtyRegion);
     mDirtyRegion.clear();
 }
 
+#ifdef QCOM_HARDWARE
+bool SurfaceFlinger::isGPULayerPresent()
+{
+    bool isGPULayerPresent = false;
+    const DisplayHardware& hw(graphicPlane(0).displayHardware());
+    HWComposer& hwc(hw.getHwComposer());
+    hwc_layer_t* const cur(hwc.getLayers());
+    if (!cur) {
+        isGPULayerPresent = true;
+    }
+
+    const Vector< sp<LayerBase> >& layers(mVisibleLayersSortedByZ);
+    size_t count = layers.size();
+    for (size_t i = 0; i<count; i++) {
+        if (HWC_FRAMEBUFFER == cur[i].compositionType) {
+            isGPULayerPresent = true;
+            break;
+        }
+    }
+    return isGPULayerPresent;
+}
+#endif
+
 void SurfaceFlinger::setupHardwareComposer(Region& dirtyInOut)
 {
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
@@ -891,6 +987,9 @@ void SurfaceFlinger::setupHardwareComposer(Region& dirtyInOut)
     status_t err = hwc.prepare();
     LOGE_IF(err, "HWComposer::prepare failed (%s)", strerror(-err));
 
+#ifdef QCOM_HARDWARE
+    mCanSkipComposition = (hwc.getFlags() & HWC_SKIP_COMPOSITION) ? true : false;
+#endif
     if (err == NO_ERROR) {
         // what's happening here is tricky.
         // we want to clear all the layers with the CLEAR_FB flags
@@ -935,6 +1034,9 @@ void SurfaceFlinger::setupHardwareComposer(Region& dirtyInOut)
                     dirtyInOut.orSelf(layer->visibleRegionScreen);
                 }
                 layer->setOverlay(isOverlay);
+#ifdef QCOM_HARDWARE
+                layer->mQCLayer->setS3DComposeFormat(cur[i].hints);
+#endif
             }
             // don't erase stuff outside the dirty region
             transparent.andSelf(dirtyInOut);
@@ -943,7 +1045,19 @@ void SurfaceFlinger::setupHardwareComposer(Region& dirtyInOut)
         /*
          *  clear the area of the FB that need to be transparent
          */
-        if (!transparent.isEmpty()) {
+#ifdef QCOM_HARDWARE
+        if (!transparent.isEmpty() && !mCanSkipComposition) {
+            // If we have any GPU layers present, don't use libQcomUI's
+            // clearRegion
+            if (false == isGPULayerPresent()) {
+                if (0 == qcomuiClearRegion(transparent, hw.getEGLDisplay(),
+                                        hw.getEGLSurface())) {
+                    return;
+                }
+            }
+#else
+	if (!transparent.isEmpty()) {
+#endif
             glClearColor(0,0,0,0);
             Region::const_iterator it = transparent.begin();
             Region::const_iterator const end = transparent.end();
@@ -967,7 +1081,22 @@ void SurfaceFlinger::composeSurfaces(const Region& dirty)
     if (UNLIKELY(fbLayerCount && !mWormholeRegion.isEmpty())) {
         // should never happen unless the window manager has a bug
         // draw something...
+#ifdef QCOM_HARDWARE
+        if (false == isGPULayerPresent()) {
+            // Use libQcomUI to draw the wormhole since there are no GPU layers
+            const Region region(mWormholeRegion.intersect(mDirtyRegion));
+            if (!region.isEmpty()) {
+                if (0 != qcomuiClearRegion(region, hw.getEGLDisplay(),
+                                             hw.getEGLSurface())) {
+                    drawWormhole();
+                }
+            }
+        } else {
+            drawWormhole();
+        }
+#else
         drawWormhole();
+#endif
     }
 
     /*
@@ -1270,6 +1399,35 @@ int SurfaceFlinger::setOrientation(DisplayID dpy,
     return orientation;
 }
 
+#ifdef QCOM_HDMI_OUT
+void SurfaceFlinger::updateHwcExternalDisplay(int externaltype)
+{
+    invalidateHwcGeometry();
+    const DisplayHardware& hw(graphicPlane(0).displayHardware());
+    mDirtyRegion.set(hw.bounds());
+    HWComposer& hwc(hw.getHwComposer());
+    hwc.perform(EVENT_EXTERNAL_DISPLAY, externaltype);
+}
+
+/*
+ * Handles the externalDisplay event
+ * @param: disp_type - external display type(HDMI/WFD)
+ * @param: value     - value(on/off)
+ * */
+void SurfaceFlinger::enableExternalDisplay(int disp_type, int value)
+{
+    Mutex::Autolock _l(mExtDispLock);
+    external_display_type newType = handleEventHDMI(
+                                      (external_display_type) disp_type, value,
+                                      (external_display_type) mExtDispOutput);
+    if(newType != mExtDispOutput) {
+        mExtDispOutput = (int) newType;
+        updateHwcExternalDisplay(mExtDispOutput);
+        signalEvent();
+    }
+}
+#endif
+
 sp<ISurface> SurfaceFlinger::createSurface(
         ISurfaceComposerClient::surface_data_t* params,
         const String8& name,
@@ -1469,6 +1627,11 @@ uint32_t SurfaceFlinger::setClientStateLocked(
 
 void SurfaceFlinger::screenReleased(int dpy)
 {
+#ifdef SURFACEFLINGER_FORCE_SCREEN_RELEASE
+    const DisplayHardware& hw = graphicPlane(0).displayHardware();
+    hw.releaseScreen();
+#endif
+
     // this may be called by a signal handler, we can't do too much in here
     android_atomic_or(eConsoleReleased, &mConsoleSignals);
     signalEvent();
@@ -1988,6 +2151,11 @@ status_t SurfaceFlinger::electronBeamOffAnimationImplLocked()
     glDeleteTextures(1, &tname);
     glDisable(GL_TEXTURE_2D);
     glDisable(GL_BLEND);
+
+#ifdef SURFACEFLINGER_FORCE_SCREEN_RELEASE
+    hw.releaseScreen();
+#endif
+
     return NO_ERROR;
 }
 
@@ -2003,7 +2171,7 @@ status_t SurfaceFlinger::electronBeamOnAnimationImplLocked()
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
     const uint32_t hw_w = hw.getWidth();
     const uint32_t hw_h = hw.getHeight();
-    const Region screenBounds(hw.bounds());
+    const Region screenBounds(hw.getBounds());
 
     GLfloat u, v;
     GLuint tname;
@@ -2013,9 +2181,9 @@ status_t SurfaceFlinger::electronBeamOnAnimationImplLocked()
     }
 
     GLfloat vtx[8];
-    const GLfloat texCoords[4][2] = { {0,v}, {0,0}, {u,0}, {u,v} };
+    const GLfloat texCoords[4][2] = { {0,0}, {0,v}, {u,v}, {u,0} };
     glBindTexture(GL_TEXTURE_2D, tname);
-    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
     glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
@@ -2072,7 +2240,7 @@ status_t SurfaceFlinger::electronBeamOnAnimationImplLocked()
     };
 
     // the full animation is 12 frames
-    int nbFrames = 8;
+    int nbFrames = 12;
     s_curve_interpolator itr(nbFrames, 7.5f);
     s_curve_interpolator itg(nbFrames, 8.0f);
     s_curve_interpolator itb(nbFrames, 8.5f);
@@ -2090,8 +2258,13 @@ status_t SurfaceFlinger::electronBeamOnAnimationImplLocked()
         hw.flip(screenBounds);
     }
 
-    nbFrames = 4;
     v_stretch vverts(hw_w, hw_h);
+
+    glMatrixMode(GL_TEXTURE);
+    glLoadIdentity();
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+
     glEnable(GL_BLEND);
     glBlendFunc(GL_ONE, GL_ONE);
     for (int i=nbFrames-1 ; i>=0 ; i--) {
@@ -2120,6 +2293,12 @@ status_t SurfaceFlinger::electronBeamOnAnimationImplLocked()
         glColorMask(0,0,1,1);
         glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
 
+        // draw the white highlight (we use the last vertices)
+        glDisable(GL_TEXTURE_2D);
+        glColorMask(1,1,1,1);
+        glColor4f(vg, vg, vg, 1);
+        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
         hw.flip(screenBounds);
     }
 
@@ -2303,7 +2482,12 @@ status_t SurfaceFlinger::captureScreenImplLocked(DisplayID dpy,
         glClear(GL_COLOR_BUFFER_BIT);
 
         const LayerVector& layers(mDrawingState.layersSortedByZ);
+#ifdef QCOM_HARDWARE
+        //if we have secure windows, do not draw any layers.
+        const size_t count = mSecureFrameBuffer ? 0: layers.size();
+#else
         const size_t count = layers.size();
+#endif
         for (size_t i=0 ; i<count ; ++i) {
             const sp<LayerBase>& layer(layers[i]);
             const uint32_t flags = layer->drawingState().flags;
@@ -2407,9 +2591,11 @@ status_t SurfaceFlinger::captureScreen(DisplayID dpy,
         virtual bool handler() {
             Mutex::Autolock _l(flinger->mStateLock);
 
+#ifndef QCOM_HARDWARE
             // if we have secure windows, never allow the screen capture
             if (flinger->mSecureFrameBuffer)
                 return true;
+#endif
 
             result = flinger->captureScreenImplLocked(dpy,
                     heap, w, h, f, sw, sh, minLayerZ, maxLayerZ);
@@ -2563,7 +2749,14 @@ status_t Client::destroySurface(SurfaceID sid) {
 
 // ---------------------------------------------------------------------------
 
+#ifdef QCOM_HARDWARE
+GraphicBufferAlloc::GraphicBufferAlloc() {
+    mFreedIndex = -1;
+    mSize = 0;
+}
+#else
 GraphicBufferAlloc::GraphicBufferAlloc() {}
+#endif
 
 GraphicBufferAlloc::~GraphicBufferAlloc() {}
 
@@ -2581,9 +2774,50 @@ sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h
                 w, h, strerror(-err), graphicBuffer->handle);
         return 0;
     }
+#ifdef QCOM_HARDWARE
+    err = checkBuffer((native_handle_t *)graphicBuffer->handle, mSize, usage);
+    if (err) {
+        LOGE("%s: checkBuffer failed",__FUNCTION__);
+        return 0;
+    }
+    Mutex::Autolock _l(mLock);
+    if (-1 != mFreedIndex) {
+        mBuffers.insertAt(graphicBuffer, mFreedIndex);
+        mFreedIndex = -1;
+    } else {
+        mBuffers.add(graphicBuffer);
+    }
+#endif
     return graphicBuffer;
 }
 
+#ifdef QCOM_HARDWARE
+void GraphicBufferAlloc::freeAllGraphicBuffersExcept(int bufIdx) {
+    Mutex::Autolock _l(mLock);
+    if (bufIdx >= 0 && bufIdx < (int)mBuffers.size()) {
+        sp<GraphicBuffer> b(mBuffers[bufIdx]);
+        mBuffers.clear();
+        mBuffers.add(b);
+    } else {
+        mBuffers.clear();
+    }
+    mFreedIndex = -1;
+}
+
+void GraphicBufferAlloc::freeGraphicBufferAtIndex(int bufIdx) {
+     Mutex::Autolock _l(mLock);
+     if (bufIdx >= 0 && bufIdx < (int)mBuffers.size()) {
+        mBuffers.removeItemsAt(bufIdx);
+        mFreedIndex = bufIdx;
+     } else {
+        mFreedIndex = -1;
+     }
+}
+
+void GraphicBufferAlloc::setGraphicBufferSize(int size) {
+    mSize = size;
+}
+#endif
 // ---------------------------------------------------------------------------
 
 GraphicPlane::GraphicPlane()
@@ -2621,6 +2855,9 @@ void GraphicPlane::setDisplayHardware(DisplayHardware *hw)
         case 90:
             displayOrientation = ISurfaceComposer::eOrientation90;
             break;
+        case 180:
+            displayOrientation = ISurfaceComposer::eOrientation180;
+            break;
         case 270:
             displayOrientation = ISurfaceComposer::eOrientation270;
             break;
@@ -2677,6 +2914,9 @@ status_t GraphicPlane::setOrientation(int orientation)
     mWidth = int(w);
     mHeight = int(h);
 
+// #ifdef USE_LGE_HDMI
+//    NvDispMgrAutoOrientation(orientation);
+//#endif
     Transform orientationTransform;
     GraphicPlane::orientationToTransfrom(orientation, w, h,
             &orientationTransform);
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index 17b80a6..86e1f20 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -97,6 +97,16 @@ public:
     virtual ~GraphicBufferAlloc();
     virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t w, uint32_t h,
         PixelFormat format, uint32_t usage, status_t* error);
+#ifdef QCOM_HARDWARE
+    virtual void freeAllGraphicBuffersExcept(int bufIdx);
+    virtual void freeGraphicBufferAtIndex(int bufIdx);
+    virtual void setGraphicBufferSize(int size);
+private:
+    Vector<sp<GraphicBuffer> > mBuffers;
+    Mutex mLock;
+    int mFreedIndex;
+    int mSize;
+#endif
 };
 
 // ---------------------------------------------------------------------------
@@ -204,6 +214,8 @@ public:
 
     GLuint getProtectedTexName() const { return mProtectedTexName; }
 
+    inline int  getUseDithering() const { return mUseDithering; }
+
 
     class MessageDestroyGLTexture : public MessageBase {
         GLuint texture;
@@ -334,7 +346,14 @@ private:
             void        debugFlashRegions();
             void        debugShowFPS() const;
             void        drawWormhole() const;
-           
+
+#ifdef QCOM_HDMI_OUT
+            //HDMI Specific
+            void updateHwcExternalDisplay(int externaltype);
+#endif
+#ifdef QCOM_HARDWARE
+            bool isGPULayerPresent();
+#endif
 
     mutable     MessageQueue    mEventQueue;
 
@@ -387,6 +406,16 @@ private:
                 volatile nsecs_t            mDebugInTransaction;
                 nsecs_t                     mLastTransactionTime;
                 bool                        mBootFinished;
+                
+#ifdef QCOM_HDMI_OUT
+                //HDMI specific
+                int                         mExtDispOutput;
+                Mutex                       mExtDispLock;
+                bool                        mOrientationChanged;
+#endif
+#ifdef QCOM_HARDWARE
+                bool                        mCanSkipComposition;
+#endif
 
                 // these are thread safe
     mutable     Barrier                     mReadyToRunBarrier;
@@ -405,6 +434,8 @@ private:
 
    // only written in the main thread, only read in other threads
    volatile     int32_t                     mSecureFrameBuffer;
+
+                bool                        mUseDithering;
 };
 
 // ---------------------------------------------------------------------------
diff --git a/services/surfaceflinger/SurfaceTextureLayer.cpp b/services/surfaceflinger/SurfaceTextureLayer.cpp
index 5020e00..bef8b79 100644
--- a/services/surfaceflinger/SurfaceTextureLayer.cpp
+++ b/services/surfaceflinger/SurfaceTextureLayer.cpp
@@ -52,6 +52,27 @@ status_t SurfaceTextureLayer::setBufferCount(int bufferCount) {
     return res;
 }
 
+#ifdef QCOM_HARDWARE
+int SurfaceTextureLayer::query(int what, int* value) {
+    int ret = SurfaceTexture::query(what, value);
+
+    sp<Layer> layer(mLayer.promote());
+    if (layer == NULL) return NO_INIT;
+
+    switch (what) {
+    case NATIVE_WINDOW_TRANSFORM_HINT:
+        *value = layer->getTransformHint();
+        ret = NO_ERROR;
+        break;
+    default:
+        // for later use
+        break;
+    }
+
+    return ret;
+}
+#endif
+
 status_t SurfaceTextureLayer::queueBuffer(int buf, int64_t timestamp,
         uint32_t* outWidth, uint32_t* outHeight, uint32_t* outTransform) {
 
diff --git a/services/surfaceflinger/SurfaceTextureLayer.h b/services/surfaceflinger/SurfaceTextureLayer.h
index 9508524..4bf934a 100644
--- a/services/surfaceflinger/SurfaceTextureLayer.h
+++ b/services/surfaceflinger/SurfaceTextureLayer.h
@@ -45,6 +45,10 @@ public:
     virtual status_t setBufferCount(int bufferCount);
 
 protected:
+#ifdef QCOM_HARDWARE
+    virtual int query(int what, int* value);
+#endif
+
     virtual status_t queueBuffer(int buf, int64_t timestamp,
             uint32_t* outWidth, uint32_t* outHeight, uint32_t* outTransform);
 
diff --git a/telephony/java/android/telephony/NeighboringCellInfo.java b/telephony/java/android/telephony/NeighboringCellInfo.java
index 0f9a3b9..51e1e95 100644
--- a/telephony/java/android/telephony/NeighboringCellInfo.java
+++ b/telephony/java/android/telephony/NeighboringCellInfo.java
@@ -25,8 +25,7 @@ import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
-
-
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPAP;
 
 /**
  * Represents the neighboring cell information, including
@@ -108,7 +107,8 @@ public class NeighboringCellInfo implements Parcelable
      * {@link TelephonyManager#NETWORK_TYPE_UMTS TelephonyManager.NETWORK_TYPE_UMTS},
      * {@link TelephonyManager#NETWORK_TYPE_HSDPA TelephonyManager.NETWORK_TYPE_HSDPA},
      * {@link TelephonyManager#NETWORK_TYPE_HSUPA TelephonyManager.NETWORK_TYPE_HSUPA},
-     * and {@link TelephonyManager#NETWORK_TYPE_HSPA TelephonyManager.NETWORK_TYPE_HSPA}.
+     * {@link TelephonyManager#NETWORK_TYPE_HSPA TelephonyManager.NETWORK_TYPE_HSPA},
+     * and {@link TelephonyManager#NETWORK_TYPE_HSPAP TelephonyManager.NETWORK_TYPE_HSPAP}.
      */
     public NeighboringCellInfo(int rssi, String location, int radioType) {
         // set default value
@@ -143,6 +143,7 @@ public class NeighboringCellInfo implements Parcelable
             case NETWORK_TYPE_HSDPA:
             case NETWORK_TYPE_HSUPA:
             case NETWORK_TYPE_HSPA:
+            case NETWORK_TYPE_HSPAP:
                 mNetworkType = radioType;
                 mPsc = Integer.valueOf(location, 16);
                 break;
@@ -218,7 +219,8 @@ public class NeighboringCellInfo implements Parcelable
      * Return {@link TelephonyManager#NETWORK_TYPE_UMTS TelephonyManager.NETWORK_TYPE_UMTS},
      * {@link TelephonyManager#NETWORK_TYPE_HSDPA TelephonyManager.NETWORK_TYPE_HSDPA},
      * {@link TelephonyManager#NETWORK_TYPE_HSUPA TelephonyManager.NETWORK_TYPE_HSUPA},
-     * or {@link TelephonyManager#NETWORK_TYPE_HSPA TelephonyManager.NETWORK_TYPE_HSPA}
+     * {@link TelephonyManager#NETWORK_TYPE_HSPA TelephonyManager.NETWORK_TYPE_HSPA},
+     * or {@link TelephonyManager#NETWORK_TYPE_HSPAP TelephonyManager.NETWORK_TYPE_HSPAP}
      * means that Neighboring Cell information is stored for UMTS network, in
      * which {@link NeighboringCellInfo#getPsc NeighboringCellInfo.getPsc}
      * should be called to access location.
diff --git a/telephony/java/android/telephony/PhoneNumberUtils.java b/telephony/java/android/telephony/PhoneNumberUtils.java
index 07afe30..18bc951 100644
--- a/telephony/java/android/telephony/PhoneNumberUtils.java
+++ b/telephony/java/android/telephony/PhoneNumberUtils.java
@@ -1480,6 +1480,13 @@ public class PhoneNumberUtils
      * @hide
      */
     public static String normalizeNumber(String phoneNumber) {
+        // chop off CLIR prefix
+        if (phoneNumber.startsWith(CLIR_ON)) {
+            phoneNumber = phoneNumber.substring(CLIR_ON.length() - 1);
+        } else if (phoneNumber.startsWith(CLIR_OFF)) {
+            phoneNumber = phoneNumber.substring(CLIR_OFF.length() - 1);
+        }
+
         StringBuilder sb = new StringBuilder();
         int len = phoneNumber.length();
         for (int i = 0; i < len; i++) {
diff --git a/telephony/java/com/android/internal/telephony/AdnRecord.java b/telephony/java/com/android/internal/telephony/AdnRecord.java
index 1bf2d3c..a01b00d 100644
--- a/telephony/java/com/android/internal/telephony/AdnRecord.java
+++ b/telephony/java/com/android/internal/telephony/AdnRecord.java
@@ -283,7 +283,7 @@ public class AdnRecord implements Parcelable {
     private void
     parseRecord(byte[] record) {
         try {
-            alphaTag = IccUtils.adnStringFieldToString(
+            alphaTag = IccUtils.adnStringFieldToStringKsc5601Support(
                             record, 0, record.length - FOOTER_SIZE_BYTES);
 
             int footerOffset = record.length - FOOTER_SIZE_BYTES;
diff --git a/telephony/java/com/android/internal/telephony/BaseCommands.java b/telephony/java/com/android/internal/telephony/BaseCommands.java
index 07b6183..0d7cb27 100644
--- a/telephony/java/com/android/internal/telephony/BaseCommands.java
+++ b/telephony/java/com/android/internal/telephony/BaseCommands.java
@@ -898,4 +898,5 @@ public abstract class BaseCommands implements CommandsInterface {
                 "' lteOnCdmaProductType='" + sLteOnCdmaProductType + "'");
         return retVal;
     }
+
 }
diff --git a/telephony/java/com/android/internal/telephony/CallManager.java b/telephony/java/com/android/internal/telephony/CallManager.java
index 3dd57ee..1f7b8f1 100644
--- a/telephony/java/com/android/internal/telephony/CallManager.java
+++ b/telephony/java/com/android/internal/telephony/CallManager.java
@@ -395,6 +395,31 @@ public final class CallManager {
                 }
                 break;
         }
+
+        // Set additional audio parameters needed for incall audio
+        String[] audioParams = context.getResources().getStringArray(com.android.internal.R.array.config_telephony_set_audioparameters);
+        String[] aPValues;
+
+        for (String parameter : audioParams) {
+            aPValues = parameter.split("=");
+
+            if(aPValues[1] == null || aPValues[1].length() == 0) {
+                aPValues[1] = "on";
+            }
+
+            if(aPValues[2] == null || aPValues[2].length() == 0) {
+                aPValues[2] = "off";
+            }
+
+            if (mode == AudioManager.MODE_IN_CALL) {
+                Log.d(LOG_TAG, "setAudioMode(): " + aPValues[0] + "=" + aPValues[1]);
+                audioManager.setParameters(aPValues[0] + "=" + aPValues[1]);
+            } else if (mode == AudioManager.MODE_NORMAL) {
+                Log.d(LOG_TAG, "setAudioMode(): " + aPValues[0] + "=" + aPValues[2]);
+                audioManager.setParameters(aPValues[0] + "=" + aPValues[2]);
+            }
+        }
+
         // calling audioManager.setMode() multiple times in a short period of
         // time seems to break the audio recorder in in-call mode
         if (audioManager.getMode() != mode) audioManager.setMode(mode);
diff --git a/telephony/java/com/android/internal/telephony/CommandsInterface.java b/telephony/java/com/android/internal/telephony/CommandsInterface.java
index d6e6ae0..84a8fc1 100644
--- a/telephony/java/com/android/internal/telephony/CommandsInterface.java
+++ b/telephony/java/com/android/internal/telephony/CommandsInterface.java
@@ -1641,4 +1641,16 @@ public interface CommandsInterface {
      * @param response a callback message with the String response in the obj field
      */
     public void requestIsimAuthentication(String nonce, Message response);
+    /**
+     * @hide
+     * CM-specific: Ask the RIL about the presence of back-compat flags
+     */
+    public boolean needsOldRilFeature(String feature);
+    /**
+     * @hide
+     * samsung stk service implementation - set up registrant for sending
+     * sms send result from modem(RIL) to catService
+     */
+    void setOnCatSendSmsResult(Handler h, int what, Object obj);
+    void unSetOnCatSendSmsResult(Handler h);
 }
diff --git a/telephony/java/com/android/internal/telephony/DataCallState.java b/telephony/java/com/android/internal/telephony/DataCallState.java
index efbf608..a5a5965 100644
--- a/telephony/java/com/android/internal/telephony/DataCallState.java
+++ b/telephony/java/com/android/internal/telephony/DataCallState.java
@@ -81,7 +81,7 @@ public class DataCallState {
            .append(" retry=").append(suggestedRetryTime)
            .append(" cid=").append(cid)
            .append(" active=").append(active)
-           .append(" type=").append(type)
+           .append(" type='").append(type)
            .append("' ifname='").append(ifname);
         sb.append("' addresses=[");
         for (String addr : addresses) {
diff --git a/telephony/java/com/android/internal/telephony/DataConnection.java b/telephony/java/com/android/internal/telephony/DataConnection.java
index d0e304f..0056701 100644
--- a/telephony/java/com/android/internal/telephony/DataConnection.java
+++ b/telephony/java/com/android/internal/telephony/DataConnection.java
@@ -355,12 +355,27 @@ public abstract class DataConnection extends StateMachine {
         if (DBG) log("NotifyDisconnectCompleted DisconnectParams=" + dp);
     }
 
+    protected boolean needsOldRilFeature(String feature) {
+        String[] features = SystemProperties.get("ro.telephony.ril.v3", "").split(",");
+        for (String found: features) {
+            if (found.equals(feature))
+                return true;
+        }
+        return false;
+    }
+
     protected int getRadioTechnology(int defaultRadioTechnology) {
         int radioTechnology;
         if (mRilVersion < 6) {
             radioTechnology = defaultRadioTechnology;
         } else {
-            radioTechnology = phone.getServiceState().getRadioTechnology() + 2;
+             if (needsOldRilFeature("usehcradio") ) {
+               radioTechnology = phone.getServiceState().getRadioTechnology() - 2;
+               if (radioTechnology != 1) // in reality if it is not 1 something is wrong for hc ??
+		   radioTechnology = 1;
+	       }
+               else
+		  radioTechnology = phone.getServiceState().getRadioTechnology() + 2; // orginal code
         }
         return radioTechnology;
     }
diff --git a/telephony/java/com/android/internal/telephony/DataConnectionTracker.java b/telephony/java/com/android/internal/telephony/DataConnectionTracker.java
index 863235b..7281f28 100644
--- a/telephony/java/com/android/internal/telephony/DataConnectionTracker.java
+++ b/telephony/java/com/android/internal/telephony/DataConnectionTracker.java
@@ -150,6 +150,14 @@ public abstract class DataConnectionTracker extends Handler {
     public static final int DISABLED = 0;
     public static final int ENABLED = 1;
 
+    /**
+     * Constants for the data connection activity:
+     * physical link down/up
+     */
+    protected static final int DATA_CONNECTION_ACTIVE_PH_LINK_INACTIVE = 0;
+    protected static final int DATA_CONNECTION_ACTIVE_PH_LINK_DOWN = 1;
+    protected static final int DATA_CONNECTION_ACTIVE_PH_LINK_UP = 2;
+
     public static final String APN_TYPE_KEY = "apnType";
 
     /** Delay between APN attempts.
diff --git a/telephony/java/com/android/internal/telephony/HTCQualcommRIL.java b/telephony/java/com/android/internal/telephony/HTCQualcommRIL.java
new file mode 100644
index 0000000..ec7ec85
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/HTCQualcommRIL.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Message;
+import android.os.Parcel;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.util.ArrayList;
+
+/**
+ * Qualcomm RIL class for basebands that do not send the SIM status
+ * piggybacked in RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED. Instead,
+ * these radios will send radio state and we have to query for SIM
+ * status separately.
+ *
+ * {@hide}
+ */
+public class HTCQualcommRIL extends QualcommSharedRIL implements CommandsInterface {
+
+    public HTCQualcommRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        boolean oldRil = needsOldRilFeature("icccardstatus");
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+
+        if (!oldRil)
+            status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2           = ca.PinStateFromRILInt(p.readInt());
+            status.addApplication(ca);
+        }
+
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        mAid = status.getApplication(appIndex).aid;
+
+        return status;
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 14;
+        int response[];
+
+        /* HTC signal strength format:
+         * 0: GW_SignalStrength
+         * 1: GW_SignalStrength.bitErrorRate
+         * 2: CDMA_SignalStrength.dbm
+         * 3: CDMA_SignalStrength.ecio
+         * 4: EVDO_SignalStrength.dbm
+         * 5: EVDO_SignalStrength.ecio
+         * 6: EVDO_SignalStrength.signalNoiseRatio
+         * 7: ATT_SignalStrength.dbm
+         * 8: ATT_SignalStrength.ecno
+         * 9: LTE_SignalStrength.signalStrength
+         * 10: LTE_SignalStrength.rsrp
+         * 11: LTE_SignalStrength.rsrq
+         * 12: LTE_SignalStrength.rssnr
+         * 13: LTE_SignalStrength.cqi
+         */
+
+        response = new int[numInts];
+        for (int i = 0; i < numInts; i++) {
+            if (i > 8) {
+                response[i-2] = p.readInt();
+                response[i] = -1;
+            } else {
+                response[i] = p.readInt();
+            }
+        }
+
+        return response;
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition(); // save off position within the Parcel
+        int response = p.readInt();
+
+        switch(response) {
+            case 21004: ret = responseVoid(p); break; // RIL_UNSOL_VOICE_RADIO_TECH_CHANGED
+            case 21005: ret = responseVoid(p); break; // RIL_UNSOL_IMS_NETWORK_STATE_CHANGED
+            case 21007: ret = responseVoid(p); break; // RIL_UNSOL_DATA_NETWORK_STATE_CHANGED
+
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+
+        switch(response) {
+            case 21004:
+            case 21005:
+            case 21007:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mExitEmergencyCallbackModeRegistrants != null) {
+                    mExitEmergencyCallbackModeRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, null, null));
+                }
+                break;
+                    }
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/HuaweiRIL.java b/telephony/java/com/android/internal/telephony/HuaweiRIL.java
new file mode 100644
index 0000000..c5d736c
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/HuaweiRIL.java
@@ -0,0 +1,909 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_CHANGE_SIM_PIN;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_CHANGE_SIM_PIN2;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_ENTER_SIM_PIN;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_ENTER_SIM_PIN2;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_ENTER_SIM_PUK;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_ENTER_SIM_PUK2;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_GET_CURRENT_CALLS;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_GET_IMEI;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_GET_IMEISV;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_GET_IMSI;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_GET_NEIGHBORING_CELL_IDS;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_QUERY_FACILITY_LOCK;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SETUP_DATA_CALL;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SET_FACILITY_LOCK;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SIM_IO;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_CALL_RING;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_CDMA_CALL_WAITING;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_CDMA_INFO_REC;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_CDMA_OTA_PROVISION_STATUS;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_DATA_CALL_LIST_CHANGED;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_NITZ_TIME_RECEIVED;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_OEM_HOOK_RAW;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_ON_USSD;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_ON_USSD_REQUEST;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESEND_INCALL_MUTE;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_CDMA_NEW_SMS;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_NEW_SMS;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RESTRICTED_STATE_CHANGED;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_RINGBACK_TONE;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_SIGNAL_STRENGTH;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_SIM_REFRESH;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_SIM_SMS_STORAGE_FULL;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_STK_CALL_SETUP;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_STK_EVENT_NOTIFY;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_STK_PROACTIVE_COMMAND;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_STK_SESSION_END;
+import static com.android.internal.telephony.RILConstants.RIL_UNSOL_SUPP_SVC_NOTIFICATION;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.os.AsyncResult;
+import android.os.Message;
+import android.os.Parcel;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.SmsMessage;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+
+import java.util.ArrayList;
+
+/**
+ * Custom Huawei ril {@hide}
+ */
+public class HuaweiRIL extends RIL implements CommandsInterface {
+    protected String mAid;
+
+    // Override RILConstants
+    public static final int RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED = 1032;
+    public static final int RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED = 1034;
+    public static final int RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE = 1037;
+    public static final int RIL_UNSOL_RIL_CONNECTED = 1031;
+
+
+    public HuaweiRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    public void
+            supplyIccPin(String pin, Message result) {
+        // but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
+
+        if (RILJ_LOGD)
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override public void
+    supplyIccPin2ForApp(String pin, String aid, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override public void
+    supplyIccPukForApp(String puk, String newPin, String aid, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override public void
+    supplyIccPuk2ForApp(String puk, String newPin2, String aid, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+            getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+
+        if (RILJ_LOGD)
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+
+        send(rr);
+    }
+
+    @Override public void
+    changeIccPinForApp(String oldPin, String newPin, String aid, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeString(oldPin);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override public void
+    changeIccPin2ForApp(String oldPin2, String newPin2, String aid, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeString(oldPin2);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+            supplyNetworkDepersonalization(String netpin, Message result) {
+        RILRequest rr =
+                RILRequest.obtain(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result);
+
+        if (RILJ_LOGD)
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(3);
+        rr.mp.writeString(netpin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+            setupDataCall(String radioTechnology, String profile, String apn,
+                    String user, String password, String authType, String ipVersion,
+                    Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(7);
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString("0"); // ipVersion
+
+        if (RILJ_LOGD)
+            riljLog(rr.serialString() + "> "
+                    + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                    + profile + " " + apn + " " + user + " "
+                    + password + " " + authType + " " + ipVersion);
+
+        send(rr);
+    }
+
+    public void
+            iccIO(int command, int fileid, String path, int p1, int p2, int p3,
+                    String data, String pin2, Message result) {
+        // Note: This RIL request has not been renamed to ICC,
+        // but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SIM_IO, result);
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeInt(command);
+        rr.mp.writeInt(fileid);
+        rr.mp.writeString(path);
+        rr.mp.writeInt(p1);
+        rr.mp.writeInt(p2);
+        rr.mp.writeInt(p3);
+        rr.mp.writeString(data);
+        rr.mp.writeString(pin2);
+
+        if (RILJ_LOGD)
+            riljLog(rr.serialString() + "> iccIO: " + requestToString(rr.mRequest)
+                    + " 0x" + Integer.toHexString(command)
+                    + " 0x" + Integer.toHexString(fileid) + " "
+                    + " path: " + path + ","
+                    + p1 + "," + p2 + "," + p3);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+            queryFacilityLock(String facility, String password, int serviceClass,
+                    Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD)
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(4);
+        rr.mp.writeString(null); //mAid);
+        rr.mp.writeString(facility);
+        rr.mp.writeString(password);
+        rr.mp.writeString(Integer.toString(serviceClass));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setFacilityLockForApp(String facility, boolean lockState, String password,
+                        int serviceClass, String appId, Message response) {
+        String lockString;
+         RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(5);
+        rr.mp.writeString(null);
+        rr.mp.writeString(facility);
+        lockString = (lockState)?"1":"0";
+        rr.mp.writeString(lockString);
+        rr.mp.writeString(password);
+        rr.mp.writeString(Integer.toString(serviceClass));
+
+        send(rr);
+
+    }
+
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+
+        status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0; i < numApplications; i++) {
+            ca = new IccCardApplication();
+            ca.app_type = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid = p.readString();
+            ca.app_label = p.readString();
+            ca.pin1_replaced = p.readInt();
+            ca.pin1 = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2 = ca.PinStateFromRILInt(p.readInt());
+            status.addApplication(ca);
+        }
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        if (numApplications > 0) {
+            IccCardApplication application = status.getApplication(appIndex);
+            Log.d(LOG_TAG, "mAid " + application.aid);
+            mAid = application.aid;
+        }
+        return status;
+    }
+
+    @Override
+    protected DataCallState getDataCallState(Parcel p, int version) {
+        DataCallState dataCall = new DataCallState();
+
+        riljLog("getDataCallState ver=" + version);
+        dataCall.version = version;
+        if (version < 5) {
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            //p.readString(); // APN - not used
+            String addresses = p.readString();
+            if (!TextUtils.isEmpty(addresses)) {
+                dataCall.addresses = addresses.split(" ");
+            }
+            // DataCallState needs an ifname. Since we don't have one use the name from the ThrottleService resource (default=rmnet0).
+            dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
+        } else {
+            dataCall.status = p.readInt();
+            dataCall.suggestedRetryTime = p.readInt();
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            dataCall.ifname = p.readString();
+            if ((dataCall.status == DataConnection.FailCause.NONE.getErrorCode()) &&
+                    TextUtils.isEmpty(dataCall.ifname)) {
+              throw new RuntimeException("getDataCallState, no ifname");
+            }
+            String addresses = p.readString();
+            if (!TextUtils.isEmpty(addresses)) {
+                dataCall.addresses = addresses.split(" ");
+            }
+            String dnses = p.readString();
+            if (!TextUtils.isEmpty(dnses)) {
+                dataCall.dnses = dnses.split(" ");
+            }
+            String gateways = p.readString();
+            if (!TextUtils.isEmpty(gateways)) {
+                dataCall.gateways = gateways.split(" ");
+            }
+        }
+        return dataCall;
+    }
+
+    protected String
+    retToString(int req, Object ret) {
+        if (ret == null) return "";
+        switch (req) {
+            // Don't log these return values, for privacy's sake.
+            case RIL_REQUEST_GET_IMSI:
+            case RIL_REQUEST_GET_IMEI:
+            case RIL_REQUEST_GET_IMEISV:
+                if (!RILJ_LOGV) {
+                    // If not versbose logging just return and don't display IMSI and IMEI, IMEISV
+                    return "";
+                }
+        }
+
+        StringBuilder sb;
+        String s;
+        int length;
+        if (ret instanceof int[]){
+            int[] intArray = (int[]) ret;
+            length = intArray.length;
+            sb = new StringBuilder("{");
+            if (length > 0) {
+                int i = 0;
+                sb.append(intArray[i++]);
+                while ( i < length) {
+                    sb.append(", ").append(intArray[i++]);
+                }
+            }
+            sb.append("}");
+            s = sb.toString();
+        } else if (ret instanceof String[]) {
+            String[] strings = (String[]) ret;
+            length = strings.length;
+            sb = new StringBuilder("{");
+            if (length > 0) {
+                int i = 0;
+                sb.append(strings[i++]);
+                while ( i < length) {
+                    sb.append(", ").append(strings[i++]);
+                }
+            }
+            sb.append("}");
+            s = sb.toString();
+        }else if (req == RIL_REQUEST_GET_CURRENT_CALLS) {
+            ArrayList<DriverCall> calls = (ArrayList<DriverCall>) ret;
+            sb = new StringBuilder(" ");
+            for (DriverCall dc : calls) {
+                sb.append("[").append(dc).append("] ");
+            }
+            s = sb.toString();
+        } else if (req == RIL_REQUEST_GET_NEIGHBORING_CELL_IDS) {
+            ArrayList<NeighboringCellInfo> cells;
+            cells = (ArrayList<NeighboringCellInfo>) ret;
+            sb = new StringBuilder(" ");
+            for (NeighboringCellInfo cell : cells) {
+                sb.append(cell).append(" ");
+            }
+            s = sb.toString();
+        } else {
+            s = ret.toString();
+        }
+        return s;
+    }
+
+    protected void
+    processUnsolicited (Parcel p) {
+        int response;
+        Object ret;
+
+        response = p.readInt();
+
+        try {switch(response) {
+/*
+ cat libs/telephony/ril_unsol_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: \2(rr, p); break;/'
+*/
+
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: ret =  responseInts(p); break;
+            case RIL_UNSOL_ON_USSD: ret =  responseStrings(p); break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseString(p); break;
+            case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: ret = responseDataCallList(p);break;
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_STK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_STK_CALL_SETUP: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+            case RIL_UNSOL_SIM_REFRESH: ret =  responseInts(p); break;
+            case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:  ret =  responseCdmaSms(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseRaw(p); break;
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_CALL_WAITING: ret = responseCdmaCallWaiting(p); break;
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: ret = responseInts(p); break;
+            case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+            case RIL_UNSOL_OEM_HOOK_RAW: ret = responseRaw(p); break;
+            case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+            case RIL_UNSOL_RESEND_INCALL_MUTE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+            case RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED: ret = responseInts(p); break; // 1032
+
+            default:
+                throw new RuntimeException("Unrecognized unsol response: " + response);
+            //break; (implied)
+        }} catch (Throwable tr) {
+            Log.e(LOG_TAG, "Exception processing unsol response: " + response +
+                "Exception:" + tr.toString());
+            return;
+        }
+
+        switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                /* has bonus radio state int */
+                RadioState newState = getRadioStateFromInt(p.readInt());
+                if (RILJ_LOGD) unsljLogMore(response, newState.toString());
+
+                switchToRadioState(newState);
+            break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mCallStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mVoiceNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: {
+                if (RILJ_LOGD) unsljLog(response);
+
+                // FIXME this should move up a layer
+                String a[] = new String[2];
+
+                a[1] = (String)ret;
+
+                SmsMessage sms;
+
+                sms = SmsMessage.newFromCMT(a);
+                if (mGsmSmsRegistrant != null) {
+                    mGsmSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+            break;
+            }
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSmsStatusRegistrant != null) {
+                    mSmsStatusRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                int[] smsIndex = (int[])ret;
+
+                if(smsIndex.length == 1) {
+                    if (mSmsOnSimRegistrant != null) {
+                        mSmsOnSimRegistrant.
+                                notifyRegistrant(new AsyncResult(null, smsIndex, null));
+                    }
+                } else {
+                    if (RILJ_LOGD) riljLog(" NEW_SMS_ON_SIM ERROR with wrong length "
+                            + smsIndex.length);
+                }
+            break;
+            case RIL_UNSOL_ON_USSD:
+                String[] resp = (String[])ret;
+
+                if (resp.length < 2) {
+                    resp = new String[2];
+                    resp[0] = ((String[])ret)[0];
+                    resp[1] = null;
+                }
+                if (RILJ_LOGD) unsljLogMore(response, resp[0]);
+                if (mUSSDRegistrant != null) {
+                    mUSSDRegistrant.notifyRegistrant(
+                        new AsyncResult (null, resp, null));
+                }
+            break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // has bonus long containing milliseconds since boot that the NITZ
+                // time was received
+                long nitzReceiveTime = p.readLong();
+
+                Object[] result = new Object[2];
+
+                result[0] = ret;
+                result[1] = Long.valueOf(nitzReceiveTime);
+
+                if (mNITZTimeRegistrant != null) {
+
+                    mNITZTimeRegistrant
+                        .notifyRegistrant(new AsyncResult (null, result, null));
+                } else {
+                    // in case NITZ time registrant isnt registered yet
+                    mLastNITZTimeInfo = result;
+                }
+            break;
+
+            case RIL_UNSOL_SIGNAL_STRENGTH:
+                // Note this is set to "verbose" because it happens
+                // frequently
+                if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+                if (mSignalStrengthRegistrant != null) {
+                    mSignalStrengthRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+            break;
+
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSsnRegistrant != null) {
+                    mSsnRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_SESSION_END:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mCatSessionEndRegistrant != null) {
+                    mCatSessionEndRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatProCmdRegistrant != null) {
+                    mCatProCmdRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_EVENT_NOTIFY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatEventRegistrant != null) {
+                    mCatEventRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_CALL_SETUP:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatCallSetUpRegistrant != null) {
+                    mCatCallSetUpRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_SIM_REFRESH:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mIccRefreshRegistrants != null) {
+                    mIccRefreshRegistrants.notifyRegistrants(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CALL_RING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mRingRegistrant != null) {
+                    mRingRegistrant.notifyRegistrant(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRestrictedStateRegistrant != null) {
+                    mRestrictedStateRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccStatusChangedRegistrants != null) {
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                SmsMessage sms = (SmsMessage) ret;
+
+                if (mCdmaSmsRegistrant != null) {
+                    mCdmaSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mGsmBroadcastSmsRegistrant != null) {
+                    mGsmBroadcastSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mEmergencyCallbackModeRegistrant != null) {
+                    mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_CALL_WAITING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCallWaitingInfoRegistrants != null) {
+                    mCallWaitingInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mOtaProvisionRegistrants != null) {
+                    mOtaProvisionRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_INFO_REC:
+                ArrayList<CdmaInformationRecords> listInfoRecs;
+
+                try {
+                    listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+                } catch (ClassCastException e) {
+                    Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+                    break;
+                }
+
+                for (CdmaInformationRecords rec : listInfoRecs) {
+                    if (RILJ_LOGD) unsljLogRet(response, rec);
+                    notifyRegistrantsCdmaInfoRec(rec);
+                }
+                break;
+
+            case RIL_UNSOL_OEM_HOOK_RAW:
+                if (RILJ_LOGD) unsljLogvRet(response, IccUtils.bytesToHexString((byte[])ret));
+                if (mUnsolOemHookRawRegistrant != null) {
+                    mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RINGBACK_TONE:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRingbackToneRegistrants != null) {
+                    boolean playtone = (((int[])ret)[0] == 1);
+                    mRingbackToneRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, playtone, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESEND_INCALL_MUTE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mResendIncallMuteRegistrants != null) {
+                    mResendIncallMuteRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCdmaSubscriptionChangedRegistrants != null) {
+                    mCdmaSubscriptionChangedRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mExitEmergencyCallbackModeRegistrants != null) {
+                    mExitEmergencyCallbackModeRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, null, null));
+                }
+                break;
+
+            case RIL_UNSOL_RIL_CONNECTED: {
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // Initial conditions
+                setRadioPower(false, null);
+                setPreferredNetworkType(mPreferredNetworkType, null);
+                setCdmaSubscriptionSource(mCdmaSubscription, null);
+                notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Notifiy all registrants that the ril has connected or disconnected.
+     *
+     * @param rilVer is the version of the ril or -1 if disconnected.
+     */
+    private void notifyRegistrantsRilConnectionChanged(int rilVer) {
+        mRilVersion = rilVer;
+        if (mRilConnectedRegistrants != null) {
+            mRilConnectedRegistrants.notifyRegistrants(
+                                new AsyncResult (null, new Integer(rilVer), null));
+        }
+    }
+
+    static String
+    responseToString(int request)
+    {
+    /*
+     cat libs/telephony/ril_unsol_commands.h \
+     | egrep "^ *{RIL_" \
+     | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
+    */
+        switch(request) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_NEW_SMS: return "UNSOL_RESPONSE_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
+            case RIL_UNSOL_ON_USSD: return "UNSOL_ON_USSD";
+            case RIL_UNSOL_ON_USSD_REQUEST: return "UNSOL_ON_USSD_REQUEST";
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: return "UNSOL_NITZ_TIME_RECEIVED";
+            case RIL_UNSOL_SIGNAL_STRENGTH: return "UNSOL_SIGNAL_STRENGTH";
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: return "UNSOL_DATA_CALL_LIST_CHANGED";
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: return "UNSOL_SUPP_SVC_NOTIFICATION";
+            case RIL_UNSOL_STK_SESSION_END: return "UNSOL_STK_SESSION_END";
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: return "UNSOL_STK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_STK_EVENT_NOTIFY: return "UNSOL_STK_EVENT_NOTIFY";
+            case RIL_UNSOL_STK_CALL_SETUP: return "UNSOL_STK_CALL_SETUP";
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: return "UNSOL_SIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_SIM_REFRESH: return "UNSOL_SIM_REFRESH";
+            case RIL_UNSOL_CALL_RING: return "UNSOL_CALL_RING";
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED: return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS: return "UNSOL_RESPONSE_CDMA_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL: return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: return "UNSOL_RESTRICTED_STATE_CHANGED";
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_CDMA_CALL_WAITING: return "UNSOL_CDMA_CALL_WAITING";
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
+            case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
+            case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
+            case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONG";
+            case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
+            case RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED: return "RIL_UNSOL_RESPONSE_TETHERED_MODE_STATE_CHANGED";
+            default: return "<unknown reponse>";
+        }
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/IccCard.java b/telephony/java/com/android/internal/telephony/IccCard.java
index 955849d..288fc7a 100644
--- a/telephony/java/com/android/internal/telephony/IccCard.java
+++ b/telephony/java/com/android/internal/telephony/IccCard.java
@@ -764,7 +764,9 @@ public abstract class IccCard {
         if (app.app_state.isPukRequired()) {
             return IccCard.State.PUK_REQUIRED;
         }
-        if (app.app_state.isSubscriptionPersoEnabled()) {
+        if (app.app_state.isSubscriptionPersoEnabled() &&
+            (!(this.mPhone.mCM.needsOldRilFeature("qcomuiccstack")) ||
+               app.perso_substate.isPersoSubStateNetworkLocked())) {
             return IccCard.State.NETWORK_LOCKED;
         }
         if (app.app_state.isAppReady()) {
diff --git a/telephony/java/com/android/internal/telephony/IccCardApplication.java b/telephony/java/com/android/internal/telephony/IccCardApplication.java
index abb740e..3ae9603 100644
--- a/telephony/java/com/android/internal/telephony/IccCardApplication.java
+++ b/telephony/java/com/android/internal/telephony/IccCardApplication.java
@@ -94,6 +94,11 @@ public class IccCardApplication {
         boolean isPersoSubStateUnknown() {
             return this == PERSOSUBSTATE_UNKNOWN;
         }
+
+        boolean isPersoSubStateNetworkLocked()
+        {
+            return this == PERSOSUBSTATE_SIM_NETWORK;
+        }
     };
 
     public AppType        app_type;
diff --git a/telephony/java/com/android/internal/telephony/IccCardStatus.java b/telephony/java/com/android/internal/telephony/IccCardStatus.java
index c751a21..874727a 100644
--- a/telephony/java/com/android/internal/telephony/IccCardStatus.java
+++ b/telephony/java/com/android/internal/telephony/IccCardStatus.java
@@ -29,7 +29,8 @@ public class IccCardStatus {
     public enum CardState {
         CARDSTATE_ABSENT,
         CARDSTATE_PRESENT,
-        CARDSTATE_ERROR;
+        CARDSTATE_ERROR,
+        CARDSTATE_NOT_READY;
 
         boolean isCardPresent() {
             return this == CARDSTATE_PRESENT;
@@ -82,6 +83,9 @@ public class IccCardStatus {
         case 2:
             mCardState = CardState.CARDSTATE_ERROR;
             break;
+        case 3:
+            mCardState = CardState.CARDSTATE_NOT_READY;
+            break;
         default:
             throw new RuntimeException("Unrecognized RIL_CardState: " + state);
         }
diff --git a/telephony/java/com/android/internal/telephony/IccSmsInterfaceManager.java b/telephony/java/com/android/internal/telephony/IccSmsInterfaceManager.java
index 9763265..d0da285 100644
--- a/telephony/java/com/android/internal/telephony/IccSmsInterfaceManager.java
+++ b/telephony/java/com/android/internal/telephony/IccSmsInterfaceManager.java
@@ -212,6 +212,19 @@ public abstract class IccSmsInterfaceManager extends ISms.Stub {
         return data;
     }
 
+    /**
+     * stk send sms Samsung way
+     * @param smsc
+     * @param pdu
+     * @param sentIntent
+     * @param deliveryIntent
+     */
+    public void sendRawPduSat(byte[] smsc, byte[] pdu, PendingIntent sentIntent,
+            PendingIntent deliveryIntent) {
+        mPhone.getContext();
+        mDispatcher.sendRawPdu(smsc, pdu, sentIntent, deliveryIntent);
+    }
+
     protected abstract void log(String msg);
 
 }
diff --git a/telephony/java/com/android/internal/telephony/IccUtils.java b/telephony/java/com/android/internal/telephony/IccUtils.java
index a966f76..2fb96fe 100644
--- a/telephony/java/com/android/internal/telephony/IccUtils.java
+++ b/telephony/java/com/android/internal/telephony/IccUtils.java
@@ -176,6 +176,47 @@ public class IccUtils {
      */
     public static String
     adnStringFieldToString(byte[] data, int offset, int length) {
+        String s = adnStringFieldToStringUcs2Helper(data, offset, length);
+        if (s == null) {
+            s = adnStringFieldToStringGsm8BitHelper(data, offset, length);
+        }
+        return s;
+    }
+
+    /**
+     * Almost identical to the method {@link #adnStringFieldToString}.
+     *
+     * Exception:
+     * If the SIM is Korean (MCC equals "450"), KSC5601 encoding will be
+     * assumed (instead of GSM8Bit). This could lead to unintended consequences,
+     * if the ADN alphaTag was saved with GSM8Bit. This is considered an
+     * acceptable risk.
+     */
+    public static String
+    adnStringFieldToStringKsc5601Support(byte[] data, int offset, int length) {
+        String s = adnStringFieldToStringUcs2Helper(data, offset, length);
+
+        if (s == null) {
+            if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+                try {
+                    int len = offset;
+                    byte stop = (byte)0xFF;
+                    while (len < length && data[len] != stop) {
+                        len++;
+                    }
+                    return new String(data, offset, len, "KSC5601");
+                } catch (UnsupportedEncodingException e) {
+                    Log.e(LOG_TAG, "implausible UnsupportedEncodingException", e);
+                }
+            }
+
+            return adnStringFieldToStringGsm8BitHelper(data, offset, length);
+        }
+        return s;
+    }
+
+    private static String
+    adnStringFieldToStringUcs2Helper(byte[] data, int offset, int length) {
         if (length == 0) {
             return "";
         }
@@ -253,7 +294,11 @@ public class IccUtils {
 
             return ret.toString();
         }
+        return null;
+    }
 
+    private static String
+    adnStringFieldToStringGsm8BitHelper(byte[] data, int offset, int length) {
         Resources resource = Resources.getSystem();
         String defaultCharset = "";
         try {
diff --git a/telephony/java/com/android/internal/telephony/JellaxyRIL.java b/telephony/java/com/android/internal/telephony/JellaxyRIL.java
new file mode 100644
index 0000000..3d9f550
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/JellaxyRIL.java
@@ -0,0 +1,908 @@
+package com.android.internal.telephony;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import static com.android.internal.telephony.RILConstants.*;
+
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+import com.android.internal.telephony.cdma.CdmaInformationRecords.CdmaSignalInfoRec;
+import com.android.internal.telephony.cdma.SignalToneUtil;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.os.Message;
+import android.os.AsyncResult;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.util.Log;
+import android.telephony.SmsMessage;
+import android.text.TextUtils;
+
+import android.telephony.PhoneNumberUtils;
+
+
+public class JellaxyRIL extends RIL implements CommandsInterface {
+
+    private boolean mSignalbarCount = SystemProperties.getInt("ro.telephony.sends_barcount", 0) == 1 ? true : false;
+    private boolean mIsSamsungCdma = SystemProperties.getBoolean("ro.ril.samsung_cdma", false);
+
+    public JellaxyRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    // Gio states
+
+    static final int RIL_UNSOL_DEVICE_READY_NOTI = 11008;
+    static final int RIL_UNSOL_GPS_NOTI = 11009;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST = 11010;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_2 = 11012;
+    static final int RIL_REQUEST_DIAL_EMERGENCY = 10016;
+
+    static String MypdpAddress;
+
+    @Override
+    public void
+    setRadioPower(boolean on, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
+
+        //samsung crap for airplane mode
+        if (on)
+        {
+            rr.mp.writeInt(1);
+            rr.mp.writeInt(1);
+        } else {
+            rr.mp.writeInt(2);
+            rr.mp.writeInt(0);
+            rr.mp.writeInt(0);
+        }
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    @Override
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseLastCallFailCause(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseVoiceRegistrationState(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseCdmaSubscription(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case RIL_REQUEST_DIAL_EMERGENCY: ret = responseVoid(p); break;
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+//            rr.onError(error, ret);
+            rr.release();
+            return;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    /*@Override
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            ret.add (
+                new OperatorInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }*/
+
+    protected Object
+    responseIMSI(Parcel p) {
+        String response;
+
+        response = p.readString();
+        if (response.length() > 8)
+            response = response.substring(0, 8);
+
+        return response;
+    }
+
+    @Override
+    protected DataCallState getDataCallState(Parcel p, int version) {
+
+        DataCallState dataCall = new DataCallState();
+
+        dataCall.version = version;
+        dataCall.cid = p.readInt();
+        dataCall.active = p.readInt();
+        dataCall.type = p.readString();
+        p.readString(); // APN - not used
+        String addresses = p.readString();
+
+        if (!TextUtils.isEmpty(addresses)) {
+            dataCall.addresses = addresses.split(" ");
+        } else {
+            dataCall.addresses = new String[] { MypdpAddress };
+        }
+
+        // DataCallState needs an ifname. Since we don't have one use the name from the ThrottleService resource (default=rmnet0).
+        dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
+
+        dataCall.gateways  = new String[] {SystemProperties.get("net." + dataCall.ifname + ".gw")};
+        dataCall.dnses     = new String[] {SystemProperties.get("net." + dataCall.ifname + ".dns1"),
+                                           SystemProperties.get("net." + dataCall.ifname + ".dns2")};
+        return dataCall;
+    }
+
+
+
+    @Override
+    protected Object
+    responseDataCallList(Parcel p) {
+        ArrayList<DataCallState> response;
+        int ver = 3;
+        int num = p.readInt();
+        riljLog("responseDataCallList ver=" + ver + " num=" + num);
+
+        response = new ArrayList<DataCallState>(num);
+        for (int i = 0; i < num; i++) {
+            response.add(getDataCallState(p, ver));
+        }
+
+        return response;
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        int response;
+        Object ret;
+
+        response = p.readInt();
+
+        try {switch(response) {
+/*
+ cat libs/telephony/ril_unsol_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: \2(rr, p); break;/'
+*/
+
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: ret =  responseInts(p); break;
+            case RIL_UNSOL_ON_USSD: ret =  responseStrings(p); break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseString(p); break;
+            case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: ret = responseDataCallList(p);break;
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_STK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_STK_CALL_SETUP: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+            case RIL_UNSOL_SIM_REFRESH: ret =  responseInts(p); break;
+            case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:  ret =  responseCdmaSms(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseRaw(p); break;
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_CALL_WAITING: ret = responseCdmaCallWaiting(p); break;
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: ret = responseInts(p); break;
+            case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+            case RIL_UNSOL_OEM_HOOK_RAW: ret = responseRaw(p); break;
+            case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+            case RIL_UNSOL_RESEND_INCALL_MUTE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_CDMA_PRL_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+
+            // unknown responses 
+            case RIL_UNSOL_DEVICE_READY_NOTI: ret = responseVoid(p); break;
+            case RIL_UNSOL_GPS_NOTI: ret = responseVoid(p); break;
+            case RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST: ret = responseVoid(p); break;
+            case RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_2: ret = responseVoid(p); break;
+
+            default:
+                throw new RuntimeException("Unrecognized unsol response: " + response);
+            //break; (implied)
+        }} catch (Throwable tr) {
+            Log.e(LOG_TAG, "Exception processing unsol response: " + response +
+                "Exception:" + tr.toString());
+            return;
+        }
+
+        switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                /* has bonus radio state int */
+                RadioState newState = getRadioStateFromInt(p.readInt());
+                if (RILJ_LOGD) unsljLogMore(response, newState.toString());
+
+                switchToRadioState(newState);
+            break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mCallStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mVoiceNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: {
+                if (RILJ_LOGD) unsljLog(response);
+
+                // FIXME this should move up a layer
+                String a[] = new String[2];
+
+                a[1] = (String)ret;
+
+                SmsMessage sms;
+
+                sms = SmsMessage.newFromCMT(a);
+                if (mGsmSmsRegistrant != null) {
+                    mGsmSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+            break;
+            }
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSmsStatusRegistrant != null) {
+                    mSmsStatusRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                int[] smsIndex = (int[])ret;
+
+                if(smsIndex.length == 1) {
+                    if (mSmsOnSimRegistrant != null) {
+                        mSmsOnSimRegistrant.
+                                notifyRegistrant(new AsyncResult(null, smsIndex, null));
+                    }
+                } else {
+                    if (RILJ_LOGD) riljLog(" NEW_SMS_ON_SIM ERROR with wrong length "
+                            + smsIndex.length);
+                }
+            break;
+            case RIL_UNSOL_ON_USSD:
+                String[] resp = (String[])ret;
+
+                if (resp.length < 2) {
+                    resp = new String[2];
+                    resp[0] = ((String[])ret)[0];
+                    resp[1] = null;
+                }
+                if (RILJ_LOGD) unsljLogMore(response, resp[0]);
+                if (mUSSDRegistrant != null) {
+                    mUSSDRegistrant.notifyRegistrant(
+                        new AsyncResult (null, resp, null));
+                }
+            break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // has bonus long containing milliseconds since boot that the NITZ
+                // time was received
+                long nitzReceiveTime = p.readLong();
+
+                Object[] result = new Object[2];
+
+                result[0] = ret;
+                result[1] = Long.valueOf(nitzReceiveTime);
+
+                if (mNITZTimeRegistrant != null) {
+
+                    mNITZTimeRegistrant
+                        .notifyRegistrant(new AsyncResult (null, result, null));
+                } else {
+                    // in case NITZ time registrant isnt registered yet
+                    mLastNITZTimeInfo = result;
+                }
+            break;
+
+            case RIL_UNSOL_SIGNAL_STRENGTH:
+                // Note this is set to "verbose" because it happens
+                // frequently
+                if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+                if (mSignalStrengthRegistrant != null) {
+                    mSignalStrengthRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                boolean oldRil = needsOldRilFeature("skipbrokendatacall");
+                if (oldRil && "IP".equals(((ArrayList<DataCallState>)ret).get(0).type))
+                    break;
+
+                mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+            break;
+
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSsnRegistrant != null) {
+                    mSsnRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_SESSION_END:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mCatSessionEndRegistrant != null) {
+                    mCatSessionEndRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatProCmdRegistrant != null) {
+                    mCatProCmdRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_EVENT_NOTIFY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatEventRegistrant != null) {
+                    mCatEventRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_CALL_SETUP:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatCallSetUpRegistrant != null) {
+                    mCatCallSetUpRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_SIM_REFRESH:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mIccRefreshRegistrants != null) {
+                    mIccRefreshRegistrants.notifyRegistrants(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CALL_RING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mRingRegistrant != null) {
+                    mRingRegistrant.notifyRegistrant(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRestrictedStateRegistrant != null) {
+                    mRestrictedStateRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccStatusChangedRegistrants != null) {
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                SmsMessage sms = (SmsMessage) ret;
+
+                if (mCdmaSmsRegistrant != null) {
+                    mCdmaSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mGsmBroadcastSmsRegistrant != null) {
+                    mGsmBroadcastSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mEmergencyCallbackModeRegistrant != null) {
+                    mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_CALL_WAITING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCallWaitingInfoRegistrants != null) {
+                    mCallWaitingInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mOtaProvisionRegistrants != null) {
+                    mOtaProvisionRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_INFO_REC:
+                ArrayList<CdmaInformationRecords> listInfoRecs;
+
+                try {
+                    listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+                } catch (ClassCastException e) {
+                    Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+                    break;
+                }
+
+                for (CdmaInformationRecords rec : listInfoRecs) {
+                    if (RILJ_LOGD) unsljLogRet(response, rec);
+                    notifyRegistrantsCdmaInfoRec(rec);
+                }
+                break;
+
+            case RIL_UNSOL_OEM_HOOK_RAW:
+                if (RILJ_LOGD) unsljLogvRet(response, IccUtils.bytesToHexString((byte[])ret));
+                if (mUnsolOemHookRawRegistrant != null) {
+                    mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RINGBACK_TONE:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRingbackToneRegistrants != null) {
+                    boolean playtone = (((int[])ret)[0] == 1);
+                    mRingbackToneRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, playtone, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESEND_INCALL_MUTE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mResendIncallMuteRegistrants != null) {
+                    mResendIncallMuteRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCdmaSubscriptionChangedRegistrants != null) {
+                    mCdmaSubscriptionChangedRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_PRL_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCdmaPrlChangedRegistrants != null) {
+                    mCdmaPrlChangedRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mExitEmergencyCallbackModeRegistrants != null) {
+                    mExitEmergencyCallbackModeRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, null, null));
+                }
+                break;
+
+            case RIL_UNSOL_RIL_CONNECTED: {
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // Initial conditions
+                setRadioPower(false, null);
+                setPreferredNetworkType(mPreferredNetworkType, null);
+                setCdmaSubscriptionSource(mCdmaSubscription, null);
+                notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Notifiy all registrants that the ril has connected or disconnected.
+     *
+     * @param rilVer is the version of the ril or -1 if disconnected.
+     */
+    private void notifyRegistrantsRilConnectionChanged(int rilVer) {
+        mRilVersion = rilVer;
+        if (mRilConnectedRegistrants != null) {
+            mRilConnectedRegistrants.notifyRegistrants(
+                                new AsyncResult (null, new Integer(rilVer), null));
+        }
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        int voiceSettings;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+        int dataAvail = p.dataAvail();
+        int pos = p.dataPosition();
+        int size = p.dataSize();
+
+        Log.d(LOG_TAG, "Parcel size = " + size);
+        Log.d(LOG_TAG, "Parcel pos = " + pos);
+        Log.d(LOG_TAG, "Parcel dataAvail = " + dataAvail);
+
+        //Samsung fucked up here
+
+        num = p.readInt();
+
+        Log.d(LOG_TAG, "num = " + num);
+        response = new ArrayList<DriverCall>(num);
+
+        for (int i = 0 ; i < num ; i++) {
+
+            dc = new DriverCall();
+
+            dc.state = DriverCall.stateFromCLCC(p.readInt());
+            Log.d(LOG_TAG, "state = " + dc.state);
+            dc.index = p.readInt();
+            Log.d(LOG_TAG, "index = " + dc.index);
+            dc.TOA = p.readInt();
+            Log.d(LOG_TAG, "state = " + dc.TOA);
+            dc.isMpty = (0 != p.readInt());
+            Log.d(LOG_TAG, "isMpty = " + dc.isMpty);
+            dc.isMT = (0 != p.readInt());
+            Log.d(LOG_TAG, "isMT = " + dc.isMT);
+            dc.als = p.readInt();
+            Log.d(LOG_TAG, "als = " + dc.als);
+            voiceSettings = p.readInt();
+            dc.isVoice = (0 == voiceSettings) ? false : true;
+            Log.d(LOG_TAG, "isVoice = " + dc.isVoice);
+            dc.isVoicePrivacy =  (0 != p.readInt());
+            dc.number = p.readString();
+            Log.d(LOG_TAG, "number = " + dc.number);
+            int np = p.readInt();
+            Log.d(LOG_TAG, "np = " + np);
+            dc.numberPresentation = DriverCall.presentationFromCLIP(np);
+            dc.name = p.readString();
+            Log.d(LOG_TAG, "name = " + dc.name);
+            dc.namePresentation = p.readInt();
+            Log.d(LOG_TAG, "namePresentation = " + dc.namePresentation);
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+    }
+ 
+   protected Object
+    responseLastCallFailCause(Parcel p) {
+        int response[] = (int[])responseInts(p);
+
+        if (mIsSamsungCdma && response.length > 0 &&
+            response[0] == com.android.internal.telephony.cdma.CallFailCause.ERROR_UNSPECIFIED) {
+
+            // Far-end hangup returns ERROR_UNSPECIFIED, which shows "Call Lost" dialog.
+            Log.d(LOG_TAG, "Overriding ERROR_UNSPECIFIED fail cause with NORMAL_CLEARING.");
+            response[0] = com.android.internal.telephony.cdma.CallFailCause.NORMAL_CLEARING;
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        // When SIM is PIN-unlocked, the RIL responds with APPSTATE_UNKNOWN and
+        // does not follow up with RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED. We
+        // notify the system here.
+        String state = SystemProperties.get(TelephonyProperties.PROPERTY_SIM_STATE);
+        if ("NOT_READY".equals(state) && mIccStatusChangedRegistrants != null) {
+            mIccStatusChangedRegistrants.notifyRegistrants();
+        }
+
+        int numInts = 12;
+        int response[];
+
+        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+        response = new int[numInts];
+        for (int i = 0 ; i < 7 ; i++) {
+            response[i] = p.readInt();
+        }
+        // SamsungRIL is a v3 RIL, fill the rest with -1
+        for (int i = 7; i < numInts; i++) {
+            response[i] = -1;
+        }
+
+        if (mIsSamsungCdma){
+            if(response[3] < 0){
+               response[3] = -response[3];
+            }
+            // Framework takes care of the rest for us.
+            return response;
+         }
+        /* Matching Samsung signal strength to asu.
+		   Method taken from Samsungs cdma/gsmSignalStateTracker */
+        if(mSignalbarCount)
+        {
+            // Samsung sends the count of bars that should be displayed instead of
+            // a real signal strength
+            response[0] = ((response[0] & 0xFF00) >> 8) * 3; // gsmDbm
+        } else {
+            response[0] = response[0] & 0xFF; // gsmDbm
+        }
+        response[1] = -1; // gsmEcio
+        response[2] = (response[2] < 0)?-120:-response[2]; // cdmaDbm
+        response[3] = (response[3] < 0)?-160:-response[3]; // cdmaEcio
+        response[4] = (response[4] < 0)?-120:-response[4]; // evdoRssi
+        response[5] = (response[5] < 0)?-1:-response[5]; // evdoEcio
+        if(response[6] < 0 || response[6] > 8)
+            response[6] = -1;
+
+        return response;
+    }
+
+    protected Object
+    responseVoiceRegistrationState(Parcel p) {
+        String response[] = (String[])responseStrings(p);
+
+        if (mIsSamsungCdma && response.length > 6) {
+            // These values are provided in hex, convert to dec.
+            response[4] = Integer.toString(Integer.parseInt(response[4], 16)); // baseStationId
+            response[5] = Integer.toString(Integer.parseInt(response[5], 16)); // baseStationLatitude
+            response[6] = Integer.toString(Integer.parseInt(response[6], 16)); // baseStationLongitude
+        }
+
+        return response;
+   }
+
+    protected Object
+    responseCdmaSubscription(Parcel p) {
+        String response[] = (String[])responseStrings(p);
+
+        if (/* mIsSamsungCdma && */ response.length == 4) {
+            // PRL version is missing in subscription parcel, add it from properties.
+            String prlVersion = SystemProperties.get("ril.prl_ver_1").split(":")[1];
+            response          = new String[] {response[0], response[1], response[2],
+                                              response[3], prlVersion};
+        }
+
+        return response;
+    }
+
+    protected Object
+    responseNetworkType(Parcel p) {
+        int response[] = (int[]) responseInts(p);
+
+        // When the modem responds Phone.NT_MODE_GLOBAL, it means Phone.NT_MODE_WCDMA_PREF
+        if (!mIsSamsungCdma && response[0] == Phone.NT_MODE_GLOBAL) {
+            Log.d(LOG_TAG, "Overriding network type response from global to WCDMA preferred");
+            response[0] = Phone.NT_MODE_WCDMA_PREF;
+        }
+
+        return response;
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/LGEQualcommRIL.java b/telephony/java/com/android/internal/telephony/LGEQualcommRIL.java
new file mode 100644
index 0000000..f8bcc32
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/LGEQualcommRIL.java
@@ -0,0 +1,379 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.util.Log;
+
+/**
+ * Qualcomm RIL class for basebands that do not send the SIM status
+ * piggybacked in RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED. Instead,
+ * these radios will send radio state and we have to query for SIM
+ * status separately.
+ * Custom Qualcomm No SimReady RIL for LGE
+ *
+ * {@hide}
+ */
+
+public class LGEQualcommRIL extends QualcommSharedRIL implements CommandsInterface {
+    protected int mPinState;
+    boolean RILJ_LOGV = true;
+    boolean RILJ_LOGD = true;
+
+    public LGEQualcommRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    public void
+    supplyIccPin(String pin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
+
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPuk(String puk, String newPin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPin2(String pin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPuk2(String puk, String newPin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    changeIccPin(String oldPin, String newPin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(oldPin);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    changeIccPin2(String oldPin2, String newPin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(oldPin2);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+
+        rr.mp.writeString(mAid);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() +
+                              "> getIMSI:RIL_REQUEST_GET_IMSI " +
+                              RIL_REQUEST_GET_IMSI +
+                              " aid: " + mAid +
+                              " " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String ipVersion,
+            Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(7);
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString("IP"); // ipVersion
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + ipVersion);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    iccIO (int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_IO, result);
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeInt(command);
+        rr.mp.writeInt(fileid);
+        rr.mp.writeString(path);
+        rr.mp.writeInt(p1);
+        rr.mp.writeInt(p2);
+        rr.mp.writeInt(p3);
+        rr.mp.writeString(data);
+        rr.mp.writeString(pin2);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccIO: "
+                    + " aid: " + mAid + " "
+                    + requestToString(rr.mRequest)
+                    + " 0x" + Integer.toHexString(command)
+                    + " 0x" + Integer.toHexString(fileid) + " "
+                    + " path: " + path + ","
+                    + p1 + "," + p2 + "," + p3);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    queryFacilityLock (String facility, String password, int serviceClass,
+                            Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " aid: " + mAid + " facility: " + facility);
+
+        if (facility.equals("SC") &&
+               SystemProperties.get("ro.cm.device").indexOf("e73") == 0) {
+            int [] iccstatus = new int[1];
+            iccstatus[0] = mPinState;
+            AsyncResult.forMessage(response, iccstatus, null);
+            response.sendToTarget();
+        } else {
+            // count strings
+            rr.mp.writeInt(4);
+
+            rr.mp.writeString(mAid);
+            rr.mp.writeString(facility);
+            rr.mp.writeString(password);
+
+            rr.mp.writeString(Integer.toString(serviceClass));
+
+            send(rr);
+        }
+    }
+
+    @Override
+    public void
+    setFacilityLock (String facility, boolean lockState, String password,
+                        int serviceClass, Message response) {
+        String lockString;
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " aid: " + mAid + " facility: " + facility
+                    + " lockstate: " + lockState);
+
+        // count strings
+        rr.mp.writeInt(5);
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(facility);
+        lockString = (lockState)?"1":"0";
+        rr.mp.writeString(lockString);
+        rr.mp.writeString(password);
+        rr.mp.writeString(Integer.toString(serviceClass));
+
+        send(rr);
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        int gsmUmtsSubscriptionAppCount = p.readInt();
+        for (int i = 0; i < gsmUmtsSubscriptionAppCount; i++) {
+            if (i == 0)
+                status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+            else
+                p.readInt();
+        }
+
+        int cdmaSubscriptionAppCount = p.readInt();
+        for (int i = 0; i < cdmaSubscriptionAppCount; i++) {
+            if (i == 0)
+                status.setCdmaSubscriptionAppIndex(p.readInt());
+            else
+                p.readInt();
+        }
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2           = ca.PinStateFromRILInt(p.readInt());
+            status.addApplication(ca);
+            p.readInt();
+            p.readInt();
+            p.readInt();
+            p.readInt();
+        }
+
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        IccCardApplication application = status.getApplication(appIndex);
+        mAid = application.aid;
+        mPinState = (application.pin1 == IccCardStatus.PinState.PINSTATE_DISABLED || 
+                     application.pin1 == IccCardStatus.PinState.PINSTATE_UNKNOWN) ? 0 : 1;
+
+        return status;
+    }
+
+    @Override
+    protected DataCallState getDataCallState(Parcel p, int version) {
+        DataCallState dataCall = new DataCallState();
+
+        boolean oldRil = needsOldRilFeature("datacall");
+
+        if (!oldRil)
+           return super.getDataCallState(p, version);
+
+        dataCall.version = 3; // was dataCall.version = version;
+        dataCall.cid = p.readInt();
+        dataCall.active = p.readInt();
+        dataCall.type = p.readString();
+        p.readString(); // apn
+        String addresses = p.readString();
+        if (!TextUtils.isEmpty(addresses)) {
+            dataCall.addresses = addresses.split(" ");
+        }
+        dataCall.ifname = "rmnet0";
+        p.readInt(); // RadioTechnology
+        p.readInt(); // inactiveReason
+
+        dataCall.dnses = new String[2];
+        dataCall.dnses[0] = SystemProperties.get("net."+dataCall.ifname+".dns1");
+        dataCall.dnses[1] = SystemProperties.get("net."+dataCall.ifname+".dns2");
+
+        return dataCall;
+    }
+
+    @Override
+    public void
+    getBasebandVersion (Message response) {
+        if (SystemProperties.get("ro.cm.device").indexOf("e73") == 0) {
+            /* This model wants a RIL_REQUEST_GET_MODEM_VERSION */
+            RILRequest rr
+                = RILRequest.obtain(220, response);
+
+            if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+            send(rr);
+        } else {
+            super.getBasebandVersion(response);
+        }
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/LGEQualcommUiccRIL.java b/telephony/java/com/android/internal/telephony/LGEQualcommUiccRIL.java
new file mode 100644
index 0000000..98fe360
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/LGEQualcommUiccRIL.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.util.ArrayList;
+
+/**
+ * Custom Qualcomm No SimReady RIL for LGE using the latest Uicc stack
+ *
+ * {@hide}
+ */
+public class LGEQualcommUiccRIL extends QualcommSharedRIL implements CommandsInterface {
+    boolean RILJ_LOGV = true;
+    boolean RILJ_LOGD = true;
+
+    public LGEQualcommUiccRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    /*
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+
+        RILRequest rrSPT = RILRequest.obtain(
+                121, null); //121 - RIL_REQUEST_VSS_SET_PDN_TABLE
+        rrSPT.mp.writeInt(1); // pdnId
+        rrSPT.mp.writeInt(apn.length()); // apnLength
+        rrSPT.mp.writeString(apn); // apn
+        rrSPT.mp.writeInt(0); // ipType
+        rrSPT.mp.writeInt(0); // inactivityTime
+        rrSPT.mp.writeInt(1); // enable
+        send(rrSPT);
+
+
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(7);
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString(protocol);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol);
+
+        send(rr);
+    }
+    */
+
+    @Override
+    protected Object
+    responseSetupDataCall(Parcel p) {
+        DataCallState dataCall;
+
+        boolean oldRil = needsOldRilFeature("datacall");
+
+        if (!oldRil)
+           return super.responseSetupDataCall(p);
+
+        p.readString();
+        return super.responseSetupDataCall(p);
+
+    }
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+
+        status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0; i < numApplications; i++) {
+            ca = new IccCardApplication();
+            ca.app_type = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid = p.readString();
+            ca.app_label = p.readString();
+            ca.pin1_replaced = p.readInt();
+            ca.pin1 = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2 = ca.PinStateFromRILInt(p.readInt());
+            p.readInt(); //remaining_count_pin1
+            p.readInt(); //remaining_count_puk1
+            p.readInt(); //remaining_count_pin2
+            p.readInt(); //remaining_count_puk2
+            status.addApplication(ca);
+        }
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        if (numApplications > 0) {
+            IccCardApplication application = status.getApplication(appIndex);
+            mAid = application.aid;
+            mUSIM = application.app_type
+                      == IccCardApplication.AppType.APPTYPE_USIM;
+            mSetPreferredNetworkType = mPreferredNetworkType;
+
+            if (TextUtils.isEmpty(mAid))
+               mAid = "";
+            Log.d(LOG_TAG, "mAid " + mAid);
+        }
+
+        return status;
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        boolean oldRil = needsOldRilFeature("signalstrength");
+        boolean noLte = false;
+
+        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            if ((oldRil || noLte) && i > 6 && i < 12) {
+                response[i] = -1;
+            } else {
+                response[i] = p.readInt();
+            }
+            if (i == 7 && response[i] == 99) {
+                response[i] = -1;
+                noLte = true;
+            }
+            if (i == 8 && !(noLte || oldRil)) {
+                response[i] *= -1;
+            }
+        }
+
+        return response;
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/LGEStarRIL.java b/telephony/java/com/android/internal/telephony/LGEStarRIL.java
new file mode 100644
index 0000000..9fd00cf
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/LGEStarRIL.java
@@ -0,0 +1,1179 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_EDGE;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_GPRS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.os.PowerManager.WakeLock;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.util.Config;
+import android.util.Log;
+
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.DataCallState;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.SmsResponse;
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+
+import android.os.SystemClock;
+
+/* NITZ stuffs */
+import java.util.Date;
+import java.text.SimpleDateFormat;
+
+import android.telephony.PhoneStateListener;
+import android.telephony.TelephonyManager;
+
+
+/**
+ * RIL implementation of the CommandsInterface.
+ * FIXME public only for testing
+ *
+ * {@hide}
+ */
+public class LGEStarRIL extends RIL implements CommandsInterface {
+
+    protected int mCallState = TelephonyManager.CALL_STATE_IDLE;
+    public LGEStarRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+        /* The star needs to ignore SCREEN_X states, in order to keep the
+         * batt updates running. The others don't need this */
+        if (SystemProperties.get("ro.build.product").indexOf("p99") == 0) {
+            context.unregisterReceiver(mIntentReceiver);
+            BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+                @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                            Log.d(LOG_TAG, "RIL received ACTION_SCREEN_ON Intent -> SKIP");
+                        } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                            Log.d(LOG_TAG, "RIL received ACTION_SCREEN_OFF Intent -> SKIP");
+                        } else {
+                            Log.w(LOG_TAG, "RIL received unexpected Intent: " + intent.getAction());
+                        }
+                    }
+            };
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_ON);
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+            context.registerReceiver(mIntentReceiver, filter);
+
+
+        } else {
+            BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+                @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                            Log.d(LOG_TAG, "Enabling FAST_DORMANCY");
+                            RILRequest rrSPR = RILRequest.obtain(
+                                    279, null);
+                            rrSPR.mp.writeInt(1);
+                            rrSPR.mp.writeInt(1);
+                            send(rrSPR);
+                        }
+                    }
+            };
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+            context.registerReceiver(mIntentReceiver, filter);
+        }
+        PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
+            @Override
+            public void onCallStateChanged(int state, String incomingNumber) {
+                /* Higher state wins, unless going back to idle */
+                if (state == TelephonyManager.CALL_STATE_IDLE || state > mCallState)
+                    mCallState = state;
+            }
+        };
+
+        // register for phone state notifications.
+        ((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE))
+            .listen(mPhoneStateListener,
+                    PhoneStateListener.LISTEN_CALL_STATE);
+    }
+
+    protected boolean mPrepSetupPending = true;
+    public void
+    setRadioPower(boolean on, Message result) {
+        if(mPrepSetupPending) {
+            if (SystemProperties.get("ro.build.product").equals("p999")) {
+                /* Set radio access tech */
+                RILRequest rrSPR = RILRequest.obtain(
+                        296, null);
+                rrSPR.mp.writeInt(1);
+                rrSPR.mp.writeInt(1);
+                if (RILJ_LOGD) riljLog(rrSPR.serialString() + "> "
+                        + requestToString(rrSPR.mRequest));
+                send(rrSPR);
+                /* Set time zone reporting */
+                rrSPR = RILRequest.obtain(
+                        189, null);
+                rrSPR.mp.writeInt(1);
+                rrSPR.mp.writeInt(1);
+                if (RILJ_LOGD) riljLog(rrSPR.serialString() + "> "
+                        + requestToString(rrSPR.mRequest));
+                send(rrSPR);
+            } else {
+                /* Set GPRS class */
+                RILRequest rrCs = RILRequest.obtain(
+                        273, null);
+                rrCs.mp.writeInt(2);
+                rrCs.mp.writeInt(1);
+                rrCs.mp.writeInt(1);
+                if (RILJ_LOGD) riljLog(rrCs.serialString() + "> "
+                        + requestToString(rrCs.mRequest));
+                send(rrCs);
+            }
+            /* Get charset */
+            RILRequest rrGCS = RILRequest.obtain(
+                    152, null);
+            if (RILJ_LOGD) riljLog(rrGCS.serialString() + "> "
+                    + requestToString(rrGCS.mRequest));
+            send(rrGCS);
+        }
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
+
+        rr.mp.writeInt(3);
+        rr.mp.writeInt(on ? 1 : 0);
+        rr.mp.writeInt(0);
+        rr.mp.writeInt(0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+
+    }
+
+    protected void LGEswitchToRadioState(RadioState newState) {
+
+        if (!mPrepSetupPending && newState == RadioState.RADIO_UNAVAILABLE) {
+            /* We seem to have lost the radio, reset the setup flag */
+	    mPrepSetupPending = true;
+        }
+        if (newState.isOn() && mPrepSetupPending) {
+            RILRequest rrPnt = RILRequest.obtain(
+                    RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, null);
+
+            rrPnt.mp.writeInt(1);
+            rrPnt.mp.writeInt(mPreferredNetworkType);
+            if (RILJ_LOGD) riljLog(rrPnt.serialString() + "> "
+                    + requestToString(rrPnt.mRequest) + " : " + mPreferredNetworkType);
+
+            send(rrPnt);
+
+            /* Set "ready" */
+            RILRequest rrSc = RILRequest.obtain(
+                    (SystemProperties.get("ro.build.product").equals("p999") ? 304 : 298), null);
+            rrSc.mp.writeInt(1);
+            rrSc.mp.writeInt(0);
+            if (RILJ_LOGD) riljLog(rrSc.serialString() + "> "
+                    + requestToString(rrSc.mRequest));
+            send(rrSc);
+
+            /* Use this to initialize network state trackers */
+            RILRequest rrSSt = RILRequest.obtain(
+                    RIL_REQUEST_SCREEN_STATE, null);
+            rrSSt.mp.writeInt(1);
+            rrSSt.mp.writeInt(1);
+            if (RILJ_LOGD) riljLog(rrSSt.serialString() + "> "
+                    + requestToString(rrSSt.mRequest));
+            send(rrSSt);
+
+            mPrepSetupPending = false;
+
+        }
+        switchToRadioState(newState);
+    }
+
+
+    /**
+     * Request ID overwrites
+     */
+
+    static final int RIL_REQUEST_HANG_UP_CALL = 204;
+
+    public void
+    hangupWaitingOrBackground (Message result) {
+        RILRequest rr = RILRequest.obtain(mCallState == TelephonyManager.CALL_STATE_OFFHOOK ?
+                                        RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND :
+                                        RIL_REQUEST_HANG_UP_CALL,
+                                        result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * long DTMF needs an additional int arg. -1 appears to act
+     * as a "backwards-compat" value.
+     */
+    public void
+    startDtmf(char c, Message result) {
+        RILRequest rr;
+        rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(Character.toString(c));
+        rr.mp.writeInt(-1);
+
+        send(rr);
+    }
+
+    /**
+     * Wrong parameter order for CALL_FORWARD
+     * Also, replace "all" (0) with the actual sum of all classes
+     */
+
+    public void
+    queryCallForwardStatus(int cfReason, int serviceClass,
+                String number, Message response) {
+        RILRequest rr
+            = RILRequest.obtain(RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, response);
+
+        rr.mp.writeInt(cfReason);
+        rr.mp.writeInt(2); // 2 is for query action, not in used anyway
+        if (serviceClass == 0)
+            serviceClass = 511;
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(PhoneNumberUtils.toaFromString(number));
+        rr.mp.writeString(number);
+        rr.mp.writeInt (0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + cfReason + " " + serviceClass);
+
+        send(rr);
+    }
+
+    private Message saveDataCall;
+
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+
+        saveDataCall = result;
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(1); // count becomes contextId
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString(protocol);
+        rr.mp.writeString("0");
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol);
+
+        send(rr);
+    }
+
+    public void
+    showPdpAddress(Message result) {
+        RILRequest rr
+                = RILRequest.obtain(161, result);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(1); // cid
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    deactivateDataCall(int cid, int reason, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_DEACTIVATE_DATA_CALL, result);
+
+        rr.mp.writeInt(2);
+        rr.mp.writeInt(cid);
+        rr.mp.writeInt(1); //cid
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " +
+                requestToString(rr.mRequest) + " " + cid);
+
+        send(rr);
+    }
+
+    /* This one needs an extra param... */
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric);
+
+        rr.mp.writeInt(0); // Not standard, but mandatory: radio tech
+        rr.mp.writeString(operatorNumeric);
+
+        send(rr);
+    }
+
+    public void
+    getNetworkSelectionMode(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+        /* ADAPTED_NETWORK_NAME */
+        rr
+                = RILRequest.obtain(143, null);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(6);
+
+        send(rr);
+    }
+
+    public void
+    getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() +
+                              "> getIMSI:RIL_REQUEST_GET_IMSI " +
+                              RIL_REQUEST_GET_IMSI +
+                              " " + requestToString(rr.mRequest));
+
+        send(rr);
+
+        /* Request service line */
+        RILRequest rrSL = RILRequest.obtain(
+                (SystemProperties.get("ro.build.product").equals("p999") ? 294 : 286), null);
+        rrSL.mp.writeInt(0);
+        if (RILJ_LOGD) riljLog(rrSL.serialString() + "> "
+                + requestToString(rrSL.mRequest));
+        send(rrSL);
+    }
+
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANG_UP_CALL: ret =  responseVoid(p); break; /* LGE */
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case 143: ret =  responseVoid(p); break; // ADAPTED_NETWORK_NAME
+            case 152: ret =  responseString(p); break; // RIL_REQUEST_GET_TE_CHARACTER_SET
+            case 161: ret =  responsePdpAddress(p); break; // SHOW_PDP_ADDRESS
+            case 189: ret =  responseVoid(p); break; // RIL_REQUEST_SET_TIME_ZONE_REPORTING
+            case 273: ret =  responseVoid(p); break; // SET_GMM_ATTACH_MODE
+            case 279: ret =  responseVoid(p); break; // FAST_DORMANCY
+            case 286: ret =  responseVoid(p); break; // GET_SERVICE_LINE
+            case 294: ret =  responseVoid(p); break; // GET_SERVICE_LINE
+            case 296: ret =  responseVoid(p); break; // RIL_REQUEST_SET_PRODUCT_RAT
+            case 298: ret =  responseVoid(p); break; // SEND_COMMAND
+            case 304: ret =  responseVoid(p); break; // SEND_COMMAND
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            rr.onError(error, ret);
+            rr.release();
+            return;
+        }
+
+        if (rr.mRequest == RIL_REQUEST_SETUP_DATA_CALL) {
+            String[] strings = (String[]) ret;
+            if (strings.length <=2 || strings[1].indexOf("vsnet") == 0) {
+                rr.release();
+                showPdpAddress(saveDataCall);
+                return;
+            }
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    protected Object
+    responseDataCallListChanged(Parcel p) {
+        ArrayList<DataCallState> response;
+
+        int ver = p.readInt();
+        int num = p.readInt();
+        riljLog("responseDataCallList ver=" + ver + " num=" + num);
+
+        response = new ArrayList<DataCallState>(num);
+        for (int i = 0; i < num; i++) {
+            DataCallState tmpRes = getDataCallState(p, ver);
+            if (tmpRes.active != 0 && 
+                 tmpRes.ifname.indexOf("vsnet") == 0)
+                showPdpAddress(null);
+            response.add(tmpRes);
+        }
+
+        return response;
+    }
+
+
+
+    protected void
+    processUnsolicited (Parcel p) {
+        int response;
+        Object ret;
+
+        response = p.readInt();
+
+        try {switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: ret =  responseInts(p); break;
+            case RIL_UNSOL_ON_USSD: ret =  responseStrings(p); break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseNitz(p); break;
+            case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: ret = responseDataCallListChanged(p);break;
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_STK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_STK_CALL_SETUP: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+            case RIL_UNSOL_SIM_REFRESH: ret =  responseInts(p); break;
+            case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:  ret =  responseCdmaSms(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseRaw(p); break;
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_CALL_WAITING: ret = responseCdmaCallWaiting(p); break;
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: ret = responseInts(p); break;
+            case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+            case RIL_UNSOL_OEM_HOOK_RAW: ret = responseRaw(p); break;
+            case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+            case RIL_UNSOL_RESEND_INCALL_MUTE: ret = responseVoid(p); break;
+
+            default:
+                throw new RuntimeException("Unrecognized unsol response: " + response);
+            //break; (implied)
+        }} catch (Throwable tr) {
+            Log.e(LOG_TAG, "Exception processing unsol response: " + response +
+                "Exception:" + tr.toString());
+            return;
+        }
+
+        switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                /* has bonus radio state int */
+                RadioState newState = getRadioStateFromInt(p.readInt());
+                if (RILJ_LOGD) unsljLogMore(response, newState.toString());
+
+                LGEswitchToRadioState(newState);
+            break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mCallStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mVoiceNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: {
+                if (RILJ_LOGD) unsljLog(response);
+
+                // FIXME this should move up a layer
+                String a[] = new String[2];
+
+                a[1] = (String)ret;
+
+                SmsMessage sms;
+
+                sms = SmsMessage.newFromCMT(a);
+                if (mGsmSmsRegistrant != null) {
+                    mGsmSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+            break;
+            }
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSmsStatusRegistrant != null) {
+                    mSmsStatusRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                int[] smsIndex = (int[])ret;
+
+                if(smsIndex.length == 1) {
+                    if (mSmsOnSimRegistrant != null) {
+                        mSmsOnSimRegistrant.
+                                notifyRegistrant(new AsyncResult(null, smsIndex, null));
+                    }
+                } else {
+                    if (RILJ_LOGD) riljLog(" NEW_SMS_ON_SIM ERROR with wrong length "
+                            + smsIndex.length);
+                }
+            break;
+            case RIL_UNSOL_ON_USSD:
+                String[] resp = (String[])ret;
+
+                if (resp.length < 2) {
+                    resp = new String[2];
+                    resp[0] = ((String[])ret)[0];
+                    resp[1] = null;
+                }
+                if (RILJ_LOGD) unsljLogMore(response, resp[0]);
+                if (mUSSDRegistrant != null) {
+                    mUSSDRegistrant.notifyRegistrant(
+                        new AsyncResult (null, resp, null));
+                }
+            break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // should have bonus long containing milliseconds since boot that the NITZ
+                // time was received. It doesn't, use "now"
+                long nitzReceiveTime = SystemClock.elapsedRealtime();//p.readLong();
+                //long nitzReceiveTime = p.readLong();
+
+                Object[] result = new Object[2];
+
+                result[0] = ret;
+                result[1] = Long.valueOf(nitzReceiveTime);
+
+                if (mNITZTimeRegistrant != null) {
+
+                    mNITZTimeRegistrant
+                        .notifyRegistrant(new AsyncResult (null, result, null));
+                } else {
+                    // in case NITZ time registrant isnt registered yet
+                    mLastNITZTimeInfo = result;
+                }
+            break;
+
+            case RIL_UNSOL_SIGNAL_STRENGTH:
+                // Note this is set to "verbose" because it happens
+                // frequently
+                if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+                if (mSignalStrengthRegistrant != null) {
+                    mSignalStrengthRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+            break;
+
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSsnRegistrant != null) {
+                    mSsnRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_SESSION_END:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mCatSessionEndRegistrant != null) {
+                    mCatSessionEndRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatProCmdRegistrant != null) {
+                    mCatProCmdRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_EVENT_NOTIFY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatEventRegistrant != null) {
+                    mCatEventRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_CALL_SETUP:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCatCallSetUpRegistrant != null) {
+                    mCatCallSetUpRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_SIM_REFRESH:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mIccRefreshRegistrants != null) {
+                    mIccRefreshRegistrants.notifyRegistrants(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CALL_RING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mRingRegistrant != null) {
+                    mRingRegistrant.notifyRegistrant(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRestrictedStateRegistrant != null) {
+                    mRestrictedStateRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccStatusChangedRegistrants != null) {
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                SmsMessage sms = (SmsMessage) ret;
+
+                if (mCdmaSmsRegistrant != null) {
+                    mCdmaSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mGsmBroadcastSmsRegistrant != null) {
+                    mGsmBroadcastSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mEmergencyCallbackModeRegistrant != null) {
+                    mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_CALL_WAITING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCallWaitingInfoRegistrants != null) {
+                    mCallWaitingInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mOtaProvisionRegistrants != null) {
+                    mOtaProvisionRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_INFO_REC:
+                ArrayList<CdmaInformationRecords> listInfoRecs;
+
+                try {
+                    listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+                } catch (ClassCastException e) {
+                    Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+                    break;
+                }
+
+                for (CdmaInformationRecords rec : listInfoRecs) {
+                    if (RILJ_LOGD) unsljLogRet(response, rec);
+                    notifyRegistrantsCdmaInfoRec(rec);
+                }
+                break;
+
+            case RIL_UNSOL_OEM_HOOK_RAW:
+                if (RILJ_LOGD) unsljLogvRet(response, IccUtils.bytesToHexString((byte[])ret));
+                if (mUnsolOemHookRawRegistrant != null) {
+                    mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RINGBACK_TONE:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                /* Sink these to get rid of phantom ringtone */
+                break;
+
+            case RIL_UNSOL_RESEND_INCALL_MUTE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mResendIncallMuteRegistrants != null) {
+                    mResendIncallMuteRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+        }
+    }
+
+    protected Object
+    responsePdpAddress(Parcel p) {
+        int num;
+        String response[];
+        String ifname;
+        DataCallState callState;
+        String dnses[] = new String[2];
+        String gateways[] = new String[1];
+
+        num = p.readInt();
+
+        response = new String[3];
+
+        response[0] = p.readString();
+        response[2] = p.readString();
+        ifname = p.readString();
+        response[1] = ifname;
+
+        if (ifname.length() > 0) {
+            SystemProperties.set("net."+ifname+".ip",response[2]);
+            dnses[0] = p.readString();
+            dnses[1] = p.readString();
+            gateways[0] = p.readString();
+            if (dnses[0].length() > 0)
+                SystemProperties.set("net."+ifname+".dns1",dnses[0]);
+            if (dnses[1].length() > 0)
+                SystemProperties.set("net."+ifname+".dns2",dnses[1]);
+            SystemProperties.set("net."+ifname+".gw",gateways[0]);
+        }
+
+        callState = new DataCallState();
+        callState.version = 4;
+        callState.status = 0;
+        callState.cid = Integer.parseInt(response[0]);
+        callState.active = 1;
+        callState.ifname = response[1];
+        callState.dnses = dnses;
+        callState.gateways = gateways;
+        callState.addresses = response[2].split(" ");
+
+
+        return callState;
+    }
+
+    protected Object
+    responseNitz(Parcel p) {
+        int num, dst=0;
+        String parceldata, parcelextra;
+        String response;
+        SimpleDateFormat dateFormatter;
+        SimpleDateFormat dateParser;
+        boolean isIfx = !SystemProperties.get("ro.build.product").equals("p999");
+
+        num = p.readInt(); // TZ diff in quarter-hours
+
+        /* Get the actual date string */
+        parceldata = p.readString();
+
+        /* Infineon modems need some additional hax... */
+        if (isIfx) {
+            String [] parcelarray = parceldata.split(",");
+            parceldata = parcelarray[0] + "," + parcelarray[1]; // assuming there is always one comma at least
+            parcelextra = (parcelarray.length > 2 ? parcelarray[2] : "0");
+            dst = Integer.parseInt(parcelextra);
+        }
+
+        /* WTH... Date may come with 4 digits in the year, reduce to 2 */
+        try {
+            dateFormatter = new SimpleDateFormat("yy/MM/dd,HH:mm:ss");
+            dateParser = new SimpleDateFormat("yy/MM/dd,HH:mm:ss");
+
+            /* Ifx delivers localtime, convert to UTC */
+            if (isIfx) {
+                /* Directly calculate UTC time using DST Offset */
+                int offset = num*15*60*1000;	// DST corrected
+                long when = dateParser.parse(parceldata).getTime() - offset;
+                Date d = new Date(when);
+                response = dateFormatter.format(d);
+            } else {
+                response = dateFormatter.format(dateParser.parse(parceldata));
+            }
+
+        } catch (java.text.ParseException tpe) {
+            Log.d(LOG_TAG, "NITZ TZ conversion failed: " + tpe);
+            response = parceldata;
+        }
+
+        /* Append the timezone */
+        response = response + ((num < 0) ? "" : "+") + num;
+        if (isIfx) {
+            /* Add DST */
+            response = response + "," + dst;
+        }
+
+        return response;
+    }
+
+    static String
+    requestToString(int request) {
+        switch(request) {
+            case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
+            case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
+            case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
+            case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
+            case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
+            case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
+            case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: return "ENTER_NETWORK_DEPERSONALIZATION";
+            case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
+            case RIL_REQUEST_DIAL: return "DIAL";
+            case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
+            case RIL_REQUEST_HANGUP: return "HANGUP";
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
+            case RIL_REQUEST_HANG_UP_CALL: return "HANG_UP_CALL"; /* LGE */
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
+            case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
+            case RIL_REQUEST_UDUB: return "UDUB";
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: return "REGISTRATION_STATE";
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: return "GPRS_REGISTRATION_STATE";
+            case RIL_REQUEST_OPERATOR: return "OPERATOR";
+            case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
+            case RIL_REQUEST_DTMF: return "DTMF";
+            case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
+            case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
+            case RIL_REQUEST_SIM_IO: return "SIM_IO";
+            case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
+            case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
+            case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
+            case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
+            case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
+            case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
+            case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
+            case RIL_REQUEST_ANSWER: return "ANSWER";
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
+            case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_DTMF_START: return "DTMF_START";
+            case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
+            case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
+            case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
+            case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
+            case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
+            case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
+            case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
+            case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
+            case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
+            case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: return "SET_SUPP_SVC_NOTIFICATION";
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: return "DELETE_SMS_ON_SIM";
+            case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
+            case RIL_REQUEST_STK_GET_PROFILE: return "REQUEST_STK_GET_PROFILE";
+            case RIL_REQUEST_STK_SET_PROFILE: return "REQUEST_STK_SET_PROFILE";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "REQUEST_EXPLICIT_CALL_TRANSFER";
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "REQUEST_GET_NEIGHBORING_CELL_IDS";
+            case RIL_REQUEST_SET_LOCATION_UPDATES: return "REQUEST_SET_LOCATION_UPDATES";
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
+            case RIL_REQUEST_SET_TTY_MODE: return "RIL_REQUEST_SET_TTY_MODE";
+            case RIL_REQUEST_QUERY_TTY_MODE: return "RIL_REQUEST_QUERY_TTY_MODE";
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_FLASH: return "RIL_REQUEST_CDMA_FLASH";
+            case RIL_REQUEST_CDMA_BURST_DTMF: return "RIL_REQUEST_CDMA_BURST_DTMF";
+            case RIL_REQUEST_CDMA_SEND_SMS: return "RIL_REQUEST_CDMA_SEND_SMS";
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: return "RIL_REQUEST_CDMA_SUBSCRIPTION";
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
+            case RIL_REQUEST_DEVICE_IDENTITY: return "RIL_REQUEST_DEVICE_IDENTITY";
+            case RIL_REQUEST_GET_SMSC_ADDRESS: return "RIL_REQUEST_GET_SMSC_ADDRESS";
+            case RIL_REQUEST_SET_SMSC_ADDRESS: return "RIL_REQUEST_SET_SMSC_ADDRESS";
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
+            case 152: return "RIL_REQUEST_GET_TE_CHARACTER_SET";
+            case 143: return "ADAPTED_NETWORK_NAME";
+            case 161: return "SHOW_PDP_ADDRESS";
+            case 189: return "RIL_REQUEST_SET_TIME_ZONE_REPORTING";
+            case 273: return "SET_GMM_ATTACH_MODE";
+            case 286: return "GET_SERVICE_LINE"; // p990
+            case 294: return "GET_SERVICE_LINE"; // p999
+            case 296: return "RIL_REQUEST_SET_PRODUCT_RAT";
+            case 298: return "SEND_COMMAND"; // p990
+            case 304: return "SEND_COMMAND"; // p999
+            default: return "<unknown request>";
+        }
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java b/telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java
new file mode 100644
index 0000000..4ad7433
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.os.Parcel;
+import android.telephony.PhoneNumberUtils;
+import android.util.Log;
+
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+/**
+ * RIL class for Motorola Wrigley 3G RILs which need
+ * supplementary service notification post-processing
+ *
+ * {@hide}
+ */
+public class MotoWrigley3GRIL extends RIL {
+
+    public MotoWrigley3GRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected Object
+    responseSuppServiceNotification(Parcel p) {
+        SuppServiceNotification notification = new SuppServiceNotification();
+
+        notification.notificationType = p.readInt();
+        notification.code = p.readInt();
+        notification.index = p.readInt();
+        notification.type = p.readInt();
+        notification.number = p.readString();
+
+        /**
+         * Moto's RIL seems to confuse code2 0 ('forwarded call') and
+         * 10 ('additional incoming call forwarded') and sends 10 when an
+         * incoming call is forwarded and _no_ call is currently active.
+         * It never sends 10 where it would be appropriate, so it's safe
+         * to just convert every occurence of 10 to 0.
+         */
+        if (notification.notificationType == 1) {
+            if (notification.code == SuppServiceNotification.MT_CODE_ADDITIONAL_CALL_FORWARDED) {
+                notification.code = SuppServiceNotification.MT_CODE_FORWARDED_CALL;
+            }
+        }
+
+        return notification;
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        int voiceSettings;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+
+        num = p.readInt();
+        response = new ArrayList<DriverCall>(num);
+
+        for (int i = 0 ; i < num ; i++) {
+            dc = new DriverCall();
+
+            dc.state = DriverCall.stateFromCLCC(p.readInt());
+            dc.index = p.readInt();
+            dc.TOA = p.readInt();
+            dc.isMpty = (0 != p.readInt());
+            dc.isMT = (0 != p.readInt());
+            dc.als = p.readInt();
+            voiceSettings = p.readInt();
+            dc.isVoice = (0 == voiceSettings) ? false : true;
+            dc.isVoicePrivacy = (0 != p.readInt());
+            dc.number = p.readString();
+            int np = p.readInt();
+            /** numberPresentation needs to be overriden for outgoing calls
+                in case of Moto Wrigley3G RIL under ICS, to prevent outgoing calls
+                to be identified as "Unknown" on InCallScreen and in the call logs
+                when CallerID option is set to "Network default" or "Hide number". **/
+            if (!dc.isMT) np = 0;
+            dc.numberPresentation = DriverCall.presentationFromCLIP(np);
+            dc.name = p.readString();
+            dc.namePresentation = p.readInt();
+            int uusInfoPresent = p.readInt();
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                                dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                                dc.uusInfo.getUserData().length));
+                riljLogv("Incoming UUS : data (string)="
+                        + new String(dc.uusInfo.getUserData()));
+                riljLogv("Incoming UUS : data (hex): "
+                        + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                riljLogv("Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/Phone.java b/telephony/java/com/android/internal/telephony/Phone.java
index 9d189c1..407002a 100644
--- a/telephony/java/com/android/internal/telephony/Phone.java
+++ b/telephony/java/com/android/internal/telephony/Phone.java
@@ -209,12 +209,15 @@ public interface Phone {
     int NT_MODE_GSM_ONLY     = RILConstants.NETWORK_MODE_GSM_ONLY;
     int NT_MODE_WCDMA_ONLY   = RILConstants.NETWORK_MODE_WCDMA_ONLY;
     int NT_MODE_GSM_UMTS     = RILConstants.NETWORK_MODE_GSM_UMTS;
+    int NT_MODE_LTE_GSM_WCDMA= RILConstants.NETWORK_MODE_LTE_GSM_WCDMA;
 
     int NT_MODE_CDMA         = RILConstants.NETWORK_MODE_CDMA;
 
     int NT_MODE_CDMA_NO_EVDO = RILConstants.NETWORK_MODE_CDMA_NO_EVDO;
     int NT_MODE_EVDO_NO_CDMA = RILConstants.NETWORK_MODE_EVDO_NO_CDMA;
     int NT_MODE_GLOBAL       = RILConstants.NETWORK_MODE_GLOBAL;
+    int NT_MODE_LTE_CDMA_EVDO = RILConstants.NETWORK_MODE_LTE_CDMA_EVDO;
+    int NT_MODE_LTE_CMDA_EVDO_GSM_WCDMA = RILConstants.NETWORK_MODE_LTE_CMDA_EVDO_GSM_WCDMA;
 
     int NT_MODE_LTE_ONLY     = RILConstants.NETWORK_MODE_LTE_ONLY;
     int PREFERRED_NT_MODE    = RILConstants.PREFERRED_NETWORK_MODE;
diff --git a/telephony/java/com/android/internal/telephony/PhoneBase.java b/telephony/java/com/android/internal/telephony/PhoneBase.java
index 94f7a13..d547802 100644
--- a/telephony/java/com/android/internal/telephony/PhoneBase.java
+++ b/telephony/java/com/android/internal/telephony/PhoneBase.java
@@ -1076,6 +1076,11 @@ public abstract class PhoneBase extends Handler implements Phone {
         if (!mIsVoiceCapable)
             return;
         AsyncResult ar = new AsyncResult(null, cn, null);
+        if (SystemProperties.getBoolean(
+                "ro.telephony.call_ring.absent", true)) {
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, mCallRingContinueToken, 0), mCallRingDelay);
+        }
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
 
diff --git a/telephony/java/com/android/internal/telephony/PhoneFactory.java b/telephony/java/com/android/internal/telephony/PhoneFactory.java
index 74bae44..c554273 100644
--- a/telephony/java/com/android/internal/telephony/PhoneFactory.java
+++ b/telephony/java/com/android/internal/telephony/PhoneFactory.java
@@ -29,6 +29,8 @@ import com.android.internal.telephony.gsm.GSMPhone;
 import com.android.internal.telephony.sip.SipPhone;
 import com.android.internal.telephony.sip.SipPhoneFactory;
 
+import java.lang.reflect.Constructor;
+
 /**
  * {@hide}
  */
@@ -133,7 +135,20 @@ public class PhoneFactory {
                 Log.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
 
                 //reads the system properties and makes commandsinterface
-                sCommandsInterface = new RIL(context, networkMode, cdmaSubscription);
+                String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL");
+                Log.i(LOG_TAG, "RILClassname is " + sRILClassname);
+
+                // Use reflection to construct the RIL class (defaults to RIL)
+                try {
+                    Class<?> classDefinition = Class.forName("com.android.internal.telephony." + sRILClassname);
+                    Constructor<?> constructor = classDefinition.getConstructor(new Class[] {Context.class, int.class, int.class});
+                    sCommandsInterface = (RIL) constructor.newInstance(new Object[] {context, networkMode, cdmaSubscription});
+                } catch (Exception e) {
+                    // 6 different types of exceptions are thrown here that it's
+                    // easier to just catch Exception as our "error handling" is the same.
+                    Log.wtf(LOG_TAG, "Unable to construct command interface", e);
+                    throw new RuntimeException(e);
+                }
 
                 int phoneType = getPhoneType(networkMode);
                 if (phoneType == Phone.PHONE_TYPE_GSM) {
@@ -179,6 +194,7 @@ public class PhoneFactory {
         case RILConstants.NETWORK_MODE_GSM_ONLY:
         case RILConstants.NETWORK_MODE_WCDMA_ONLY:
         case RILConstants.NETWORK_MODE_GSM_UMTS:
+        case RILConstants.NETWORK_MODE_LTE_GSM_WCDMA:
             return Phone.PHONE_TYPE_GSM;
 
         // Use CDMA Phone for the global mode including CDMA
diff --git a/telephony/java/com/android/internal/telephony/QualcommSharedRIL.java b/telephony/java/com/android/internal/telephony/QualcommSharedRIL.java
new file mode 100644
index 0000000..4c29b2f
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/QualcommSharedRIL.java
@@ -0,0 +1,844 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.telephony.SmsMessage;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+
+import java.util.ArrayList;
+
+/**
+ * Custom Qualcomm No SimReady RIL using the latest Uicc stack
+ *
+ * {@hide}
+ */
+public class QualcommSharedRIL extends RIL implements CommandsInterface {
+    protected HandlerThread mIccThread;
+    protected IccHandler mIccHandler;
+    protected String mAid;
+    protected boolean mUSIM = false;
+    protected String[] mLastDataIface = new String[20];
+    boolean RILJ_LOGV = true;
+    boolean RILJ_LOGD = true;
+
+    private final int RIL_INT_RADIO_OFF = 0;
+    private final int RIL_INT_RADIO_UNAVALIABLE = 1;
+    private final int RIL_INT_RADIO_ON = 2;
+    private final int RIL_INT_RADIO_ON_NG = 10;
+    private final int RIL_INT_RADIO_ON_HTC = 13;
+
+
+    public QualcommSharedRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+        mSetPreferredNetworkType = -1;
+    }
+
+    @Override public void
+    supplyIccPin2(String pin, Message result) {
+        supplyIccPin2ForApp(pin, mAid, result);
+    }
+
+    @Override public void
+    changeIccPin2(String oldPin2, String newPin2, Message result) {
+        changeIccPin2ForApp(oldPin2, newPin2, mAid, result);
+    }
+
+    @Override public void
+    supplyIccPuk(String puk, String newPin, Message result) {
+        supplyIccPukForApp(puk, newPin, mAid, result);
+    }
+
+    @Override public void
+    supplyIccPuk2(String puk2, String newPin2, Message result) {
+        supplyIccPuk2ForApp(puk2, newPin2, mAid, result);
+    }
+
+    @Override
+    public void
+    queryFacilityLock(String facility, String password, int serviceClass,
+                            Message response) {
+        queryFacilityLockForApp(facility, password, serviceClass, mAid, response);
+    }
+
+    @Override
+    public void
+    setFacilityLock (String facility, boolean lockState, String password,
+                        int serviceClass, Message response) {
+        setFacilityLockForApp(facility, lockState, password, serviceClass, mAid, response);
+    }
+
+    @Override
+    public void
+    getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeString(mAid);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() +
+                              "> getIMSI:RIL_REQUEST_GET_IMSI " +
+                              RIL_REQUEST_GET_IMSI +
+                              " aid: " + mAid +
+                              " " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    iccIO (int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_IO, result);
+
+        if (mUSIM)
+            path = path.replaceAll("7F20$","7FFF");
+
+        rr.mp.writeInt(command);
+        rr.mp.writeInt(fileid);
+        rr.mp.writeString(path);
+        rr.mp.writeInt(p1);
+        rr.mp.writeInt(p2);
+        rr.mp.writeInt(p3);
+        rr.mp.writeString(data);
+        rr.mp.writeString(pin2);
+        rr.mp.writeString(mAid);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccIO: "
+                    + " aid: " + mAid + " "
+                    + requestToString(rr.mRequest)
+                    + " 0x" + Integer.toHexString(command)
+                    + " 0x" + Integer.toHexString(fileid) + " "
+                    + " path: " + path + ","
+                    + p1 + "," + p2 + "," + p3);
+
+        send(rr);
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+
+        status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0; i < numApplications; i++) {
+            ca = new IccCardApplication();
+            ca.app_type = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid = p.readString();
+            ca.app_label = p.readString();
+            ca.pin1_replaced = p.readInt();
+            ca.pin1 = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2 = ca.PinStateFromRILInt(p.readInt());
+            p.readInt(); //remaining_count_pin1
+            p.readInt(); //remaining_count_puk1
+            p.readInt(); //remaining_count_pin2
+            p.readInt(); //remaining_count_puk2
+            status.addApplication(ca);
+        }
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        if (numApplications > 0) {
+            IccCardApplication application = status.getApplication(appIndex);
+            mAid = application.aid;
+            mUSIM = application.app_type
+                      == IccCardApplication.AppType.APPTYPE_USIM;
+            mSetPreferredNetworkType = mPreferredNetworkType;
+
+            if (TextUtils.isEmpty(mAid))
+               mAid = "";
+            Log.d(LOG_TAG, "mAid " + mAid);
+        }
+
+        return status;
+    }
+
+    @Override
+    protected DataCallState getDataCallState(Parcel p, int version) {
+        DataCallState dataCall = new DataCallState();
+
+        boolean oldRil = needsOldRilFeature("datacall");
+
+        if (!oldRil && version < 5) {
+            return super.getDataCallState(p, version);
+        } else if (!oldRil) {
+            dataCall.version = version;
+            dataCall.status = p.readInt();
+            dataCall.suggestedRetryTime = p.readInt();
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            dataCall.ifname = p.readString();
+            if ((dataCall.status == DataConnection.FailCause.NONE.getErrorCode()) &&
+                    TextUtils.isEmpty(dataCall.ifname) && dataCall.active != 0) {
+              throw new RuntimeException("getDataCallState, no ifname");
+            }
+            String addresses = p.readString();
+            if (!TextUtils.isEmpty(addresses)) {
+                dataCall.addresses = addresses.split(" ");
+            }
+            String dnses = p.readString();
+            if (!TextUtils.isEmpty(dnses)) {
+                dataCall.dnses = dnses.split(" ");
+            }
+            String gateways = p.readString();
+            if (!TextUtils.isEmpty(gateways)) {
+                dataCall.gateways = gateways.split(" ");
+            }
+        } else {
+            dataCall.version = 4; // was dataCall.version = version;
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            dataCall.ifname = mLastDataIface[dataCall.cid];
+            p.readString(); // skip APN
+
+            if (TextUtils.isEmpty(dataCall.ifname)) {
+                dataCall.ifname = mLastDataIface[0];
+            }
+
+            String addresses = p.readString();
+            if (!TextUtils.isEmpty(addresses)) {
+                dataCall.addresses = addresses.split(" ");
+            }
+            p.readInt(); // RadioTechnology
+            p.readInt(); // inactiveReason
+
+            dataCall.dnses = new String[2];
+            dataCall.dnses[0] = SystemProperties.get("net."+dataCall.ifname+".dns1");
+            dataCall.dnses[1] = SystemProperties.get("net."+dataCall.ifname+".dns2");
+        }
+
+        return dataCall;
+    }
+
+    @Override
+    protected Object
+    responseSetupDataCall(Parcel p) {
+        DataCallState dataCall;
+
+        boolean oldRil = needsOldRilFeature("datacall");
+
+        if (!oldRil)
+           return super.responseSetupDataCall(p);
+
+        dataCall = new DataCallState();
+        dataCall.version = 4;
+
+        dataCall.cid = 0; // Integer.parseInt(p.readString());
+        p.readString();
+        dataCall.ifname = p.readString();
+        if ((dataCall.status == DataConnection.FailCause.NONE.getErrorCode()) &&
+             TextUtils.isEmpty(dataCall.ifname) && dataCall.active != 0) {
+            throw new RuntimeException(
+                    "RIL_REQUEST_SETUP_DATA_CALL response, no ifname");
+        }
+        /* Use the last digit of the interface id as the cid */
+        if (!needsOldRilFeature("singlepdp")) {
+            dataCall.cid =
+                Integer.parseInt(dataCall.ifname.substring(dataCall.ifname.length() - 1));
+        }
+
+        mLastDataIface[dataCall.cid] = dataCall.ifname;
+
+
+        String addresses = p.readString();
+        if (!TextUtils.isEmpty(addresses)) {
+          dataCall.addresses = addresses.split(" ");
+        }
+
+        dataCall.dnses = new String[2];
+        dataCall.dnses[0] = SystemProperties.get("net."+dataCall.ifname+".dns1");
+        dataCall.dnses[1] = SystemProperties.get("net."+dataCall.ifname+".dns2");
+        dataCall.active = 1;
+        dataCall.status = 0;
+
+        return dataCall;
+    }
+
+    @Override
+    public void getNeighboringCids(Message response) {
+        if (!getRadioState().isOn())
+            return;
+
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void setCurrentPreferredNetworkType() {
+        if (RILJ_LOGD) riljLog("setCurrentPreferredNetworkType: " + mSetPreferredNetworkType);
+        setPreferredNetworkType(mSetPreferredNetworkType, null);
+    }
+
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+        /**
+          * If not using a USIM, ignore LTE mode and go to 3G
+          */
+        if (!mUSIM && networkType == RILConstants.NETWORK_MODE_LTE_GSM_WCDMA &&
+                 mSetPreferredNetworkType >= RILConstants.NETWORK_MODE_WCDMA_PREF) {
+            networkType = RILConstants.NETWORK_MODE_WCDMA_PREF;
+        }
+        mSetPreferredNetworkType = networkType;
+
+        super.setPreferredNetworkType(networkType, response);
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        boolean oldRil = needsOldRilFeature("signalstrength");
+        boolean noLte = false;
+
+        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            if ((oldRil || noLte) && i > 6 && i < 12) {
+                response[i] = -1;
+            } else {
+                response[i] = p.readInt();
+            }
+            if (i == 7 && response[i] == 99) {
+                response[i] = -1;
+                noLte = true;
+            }
+            if (i == 8 && !(noLte || oldRil)) {
+                response[i] *= -1;
+            }
+        }
+
+        return response;
+    }
+
+    @Override
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+
+            /* Convert RIL_REQUEST_GET_MODEM_VERSION back */
+            if (SystemProperties.get("ro.cm.device").indexOf("e73") == 0 &&
+                  rr.mRequest == 220) {
+                rr.mRequest = RIL_REQUEST_BASEBAND_VERSION;
+            }
+
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseGetPreferredNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case 104: ret = responseInts(p); break; // RIL_REQUEST_VOICE_RADIO_TECH
+            case 105: ret = responseInts(p); break; // RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE
+            case 106: ret = responseStrings(p); break; // RIL_REQUEST_CDMA_PRL_VERSION
+            case 107: ret = responseInts(p);  break; // RIL_REQUEST_IMS_REGISTRATION_STATE
+            case 108: ret = responseSMS(p);  break; // RIL_REQUEST_IMS_SEND_SMS
+
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            rr.onError(error, ret);
+            rr.release();
+            return;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition(); // save off position within the Parcel
+        int response = p.readInt();
+
+        /* Assume devices needing the "datacall" GB-compatibility flag are
+         * running GB RILs, so skip 1031-1034 for those */
+        if (needsOldRilFeature("datacall")) {
+            switch(response) {
+                 case 1031:
+                 case 1032:
+                 case 1033:
+                 case 1034:
+                     ret = responseVoid(p);
+                     return;
+            }
+        }
+
+        switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+            case 1035: ret = responseVoid(p); break; // RIL_UNSOL_VOICE_RADIO_TECH_CHANGED
+            case 1036: ret = responseVoid(p); break; // RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED
+            case 1037: ret = responseVoid(p); break; // RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE
+            case 1038: ret = responseVoid(p); break; // RIL_UNSOL_DATA_NETWORK_STATE_CHANGED
+
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+
+        switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                int state = p.readInt();
+                setRadioStateFromRILInt(state);
+                break;
+            case RIL_UNSOL_RIL_CONNECTED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
+                break;
+            case 1035:
+            case 1036:
+                break;
+            case 1037: // RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mExitEmergencyCallbackModeRegistrants != null) {
+                    mExitEmergencyCallbackModeRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, null, null));
+                }
+                break;
+            case 1038:
+                break;
+        }
+    }
+
+    /**
+     * Notify all registrants that the ril has connected or disconnected.
+     *
+     * @param rilVer is the version of the ril or -1 if disconnected.
+     */
+    private void notifyRegistrantsRilConnectionChanged(int rilVer) {
+        mRilVersion = rilVer;
+        if (mRilConnectedRegistrants != null) {
+            mRilConnectedRegistrants.notifyRegistrants(
+                                new AsyncResult (null, new Integer(rilVer), null));
+        }
+    }
+
+    protected void setRadioStateFromRILInt (int stateCode) {
+        CommandsInterface.RadioState radioState;
+        HandlerThread handlerThread;
+        Looper looper;
+        IccHandler iccHandler;
+
+        switch (stateCode) {
+            case RIL_INT_RADIO_OFF:
+                radioState = CommandsInterface.RadioState.RADIO_OFF;
+                if (mIccHandler != null) {
+                    mIccThread = null;
+                    mIccHandler = null;
+                }
+                break;
+            case RIL_INT_RADIO_UNAVALIABLE:
+                radioState = CommandsInterface.RadioState.RADIO_UNAVAILABLE;
+                break;
+            case RIL_INT_RADIO_ON:
+            case RIL_INT_RADIO_ON_NG:
+            case RIL_INT_RADIO_ON_HTC:
+                if (mIccHandler == null) {
+                    handlerThread = new HandlerThread("IccHandler");
+                    mIccThread = handlerThread;
+
+                    mIccThread.start();
+
+                    looper = mIccThread.getLooper();
+                    mIccHandler = new IccHandler(this,looper);
+                    mIccHandler.run();
+                }
+                if (mPhoneType == RILConstants.CDMA_PHONE) {
+                    radioState = CommandsInterface.RadioState.RUIM_NOT_READY;
+                } else {
+                    radioState = CommandsInterface.RadioState.SIM_NOT_READY;
+                }
+                setRadioState(radioState);
+                break;
+            default:
+                throw new RuntimeException("Unrecognized RIL_RadioState: " + stateCode);
+        }
+
+        setRadioState (radioState);
+    }
+
+    class IccHandler extends Handler implements Runnable {
+        private static final int EVENT_RADIO_ON = 1;
+        private static final int EVENT_ICC_STATUS_CHANGED = 2;
+        private static final int EVENT_GET_ICC_STATUS_DONE = 3;
+        private static final int EVENT_RADIO_OFF_OR_UNAVAILABLE = 4;
+
+        private RIL mRil;
+        private boolean mRadioOn = false;
+
+        public IccHandler (RIL ril, Looper looper) {
+            super (looper);
+            mRil = ril;
+        }
+
+        public void handleMessage (Message paramMessage) {
+            switch (paramMessage.what) {
+                case EVENT_RADIO_ON:
+                    mRadioOn = true;
+                    Log.d(LOG_TAG, "Radio on -> Forcing sim status update");
+                    sendMessage(obtainMessage(EVENT_ICC_STATUS_CHANGED));
+                    break;
+                case EVENT_GET_ICC_STATUS_DONE:
+                    AsyncResult asyncResult = (AsyncResult) paramMessage.obj;
+                    if (asyncResult.exception != null) {
+                        Log.e (LOG_TAG, "IccCardStatusDone shouldn't return exceptions!", asyncResult.exception);
+                        break;
+                    }
+                    IccCardStatus status = (IccCardStatus) asyncResult.result;
+                    if (status.getNumApplications() == 0) {
+                        if (!mRil.getRadioState().isOn()) {
+                            break;
+                        }
+
+                        if (mPhoneType == RILConstants.CDMA_PHONE) {
+                            mRil.setRadioState(CommandsInterface.RadioState.RUIM_LOCKED_OR_ABSENT);
+                        } else {
+                            mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                        }
+                    } else {
+                        int appIndex = -1;
+                        if (mPhoneType == RILConstants.CDMA_PHONE) {
+                            appIndex = status.getCdmaSubscriptionAppIndex();
+                            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+                        } else {
+                            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+                            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+                        }
+
+                        IccCardApplication application = status.getApplication(appIndex);
+                        IccCardApplication.AppState app_state = application.app_state;
+                        IccCardApplication.AppType app_type = application.app_type;
+
+                        switch (app_state) {
+                            case APPSTATE_PIN:
+                            case APPSTATE_PUK:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            case APPSTATE_READY:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_READY);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_READY);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            default:
+                                return;
+                        }
+                    }
+                    break;
+                case EVENT_ICC_STATUS_CHANGED:
+                    if (mRadioOn) {
+                        Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
+                         mRil.getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, paramMessage.obj));
+                    } else {
+                         Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED while radio is not ON. Ignoring");
+                    }
+                    break;
+                case EVENT_RADIO_OFF_OR_UNAVAILABLE:
+                    mRadioOn = false;
+                    // disposeCards(); // to be verified;
+                default:
+                    Log.e(LOG_TAG, " Unknown Event " + paramMessage.what);
+                    break;
+            }
+        }
+
+        public void run () {
+            mRil.registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, null);
+            Message msg = obtainMessage(EVENT_RADIO_ON);
+            mRil.getIccCardStatus(msg);
+        }
+    }
+
+
+    @Override
+    public void
+    supplyNetworkDepersonalization(String netpin, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(3);
+        rr.mp.writeString(netpin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric);
+
+        rr.mp.writeInt(2);
+        rr.mp.writeString(operatorNumeric);
+        rr.mp.writeString("NOCHANGE");
+
+        send(rr);
+    }
+
+    @Override
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multiple of 5");
+        }
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            ret.add (
+                new OperatorInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/RIL.java b/telephony/java/com/android/internal/telephony/RIL.java
index f2e7f45..35f5c12 100644
--- a/telephony/java/com/android/internal/telephony/RIL.java
+++ b/telephony/java/com/android/internal/telephony/RIL.java
@@ -24,11 +24,13 @@ import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPAP;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.content.res.Resources;
 import android.net.ConnectivityManager;
 import android.net.LocalSocket;
 import android.net.LocalSocketAddress;
@@ -40,6 +42,7 @@ import android.os.Message;
 import android.os.Parcel;
 import android.os.PowerManager;
 import android.os.SystemProperties;
+import android.os.Registrant;
 import android.os.PowerManager.WakeLock;
 import android.telephony.NeighboringCellInfo;
 import android.telephony.PhoneNumberUtils;
@@ -196,7 +199,7 @@ class RILRequest {
  *
  * {@hide}
  */
-public final class RIL extends BaseCommands implements CommandsInterface {
+public class RIL extends BaseCommands implements CommandsInterface {
     static final String LOG_TAG = "RILJ";
     static final boolean RILJ_LOGD = true;
     static final boolean RILJ_LOGV = false; // STOP SHIP if true
@@ -266,6 +269,26 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     };
 
+    protected Registrant mCatSendSmsResultRegistrant;
+    /**
+     * samsung stk service implementation - set up registrant for sending
+     * sms send result from modem(RIL) to catService
+     * @param h
+     * @param what
+     * @param obj
+     */
+    public void setOnCatSendSmsResult(Handler h, int what, Object obj) {
+        mCatSendSmsResultRegistrant = new Registrant(h, what, obj);
+    }
+
+    /**
+     *
+     * @param h
+     */
+    public void unSetOnCatSendSmsResult(Handler h) {
+        mCatSendSmsResultRegistrant.clear();
+    }
+
     class RILSender extends Handler implements Runnable {
         public RILSender(Looper looper) {
             super(looper);
@@ -609,6 +632,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
         mCdmaSubscription  = cdmaSubscription;
         mPreferredNetworkType = preferredNetworkType;
+        mSetPreferredNetworkType = preferredNetworkType;
         mPhoneType = RILConstants.NO_PHONE;
 
         PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
@@ -681,9 +705,13 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
-        rr.mp.writeInt(2);
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
+        rr.mp.writeInt(oldRil ? 1 : 2);
         rr.mp.writeString(pin);
-        rr.mp.writeString(aid);
+
+        if (!oldRil)
+            rr.mp.writeString(aid);
 
         send(rr);
     }
@@ -701,10 +729,14 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
-        rr.mp.writeInt(3);
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
+        rr.mp.writeInt(oldRil ? 2 : 3);
         rr.mp.writeString(puk);
         rr.mp.writeString(newPin);
-        rr.mp.writeString(aid);
+
+        if (!oldRil)
+            rr.mp.writeString(aid);
 
         send(rr);
     }
@@ -722,9 +754,13 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
-        rr.mp.writeInt(2);
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
+        rr.mp.writeInt(oldRil ? 1 : 2);
         rr.mp.writeString(pin);
-        rr.mp.writeString(aid);
+
+        if (!oldRil)
+            rr.mp.writeString(aid);
 
         send(rr);
     }
@@ -742,10 +778,14 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
-        rr.mp.writeInt(3);
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
+        rr.mp.writeInt(oldRil ? 2 : 3);
         rr.mp.writeString(puk);
         rr.mp.writeString(newPin2);
-        rr.mp.writeString(aid);
+
+        if (!oldRil)
+            rr.mp.writeString(aid);
 
         send(rr);
     }
@@ -763,10 +803,14 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
-        rr.mp.writeInt(3);
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
+        rr.mp.writeInt(oldRil ? 2 : 3);
         rr.mp.writeString(oldPin);
         rr.mp.writeString(newPin);
-        rr.mp.writeString(aid);
+
+        if (!oldRil)
+            rr.mp.writeString(aid);
 
         send(rr);
     }
@@ -784,10 +828,14 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
-        rr.mp.writeInt(3);
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
+        rr.mp.writeInt(oldRil ? 2 : 3);
         rr.mp.writeString(oldPin2);
         rr.mp.writeString(newPin2);
-        rr.mp.writeString(aid);
+
+        if (!oldRil)
+            rr.mp.writeString(aid);
 
         send(rr);
     }
@@ -1625,14 +1673,18 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
         // count strings
-        rr.mp.writeInt(4);
+        rr.mp.writeInt(oldRil ? 3 : 4);
 
         rr.mp.writeString(facility);
         rr.mp.writeString(password);
 
         rr.mp.writeString(Integer.toString(serviceClass));
-        rr.mp.writeString(appId);
+
+        if (!oldRil)
+            rr.mp.writeString(appId);
 
         send(rr);
     }
@@ -1654,15 +1706,19 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
 
+        boolean oldRil = needsOldRilFeature("facilitylock");
+
         // count strings
-        rr.mp.writeInt(5);
+        rr.mp.writeInt(oldRil ? 4 : 5);
 
         rr.mp.writeString(facility);
         lockString = (lockState)?"1":"0";
         rr.mp.writeString(lockString);
         rr.mp.writeString(password);
         rr.mp.writeString(Integer.toString(serviceClass));
-        rr.mp.writeString(appId);
+
+        if (!oldRil)
+            rr.mp.writeString(appId);
 
         send(rr);
 
@@ -1828,7 +1884,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         if (RILJ_LOGD) riljLog("setCurrentPreferredNetworkType: " + mSetPreferredNetworkType);
         setPreferredNetworkType(mSetPreferredNetworkType, null);
     }
-    private int mSetPreferredNetworkType;
+    protected int mSetPreferredNetworkType;
 
     /**
      * {@inheritDoc}
@@ -1992,7 +2048,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
     //***** Private Methods
 
-    private void sendScreenState(boolean on) {
+    protected void sendScreenState(boolean on) {
         RILRequest rr = RILRequest.obtain(RIL_REQUEST_SCREEN_STATE, null);
         rr.mp.writeInt(1);
         rr.mp.writeInt(on ? 1 : 0);
@@ -2013,7 +2069,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         sendScreenState(true);
    }
 
-    private RadioState getRadioStateFromInt(int stateInt) {
+    protected RadioState getRadioStateFromInt(int stateInt) {
         RadioState state;
 
         /* RIL_RadioState ril.h */
@@ -2036,7 +2092,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return state;
     }
 
-    private void switchToRadioState(RadioState newState) {
+    protected void switchToRadioState(RadioState newState) {
         setRadioState(newState);
     }
 
@@ -2073,7 +2129,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void
+    protected void
     send(RILRequest rr) {
         Message msg;
 
@@ -2090,7 +2146,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         msg.sendToTarget();
     }
 
-    private void
+    protected void
     processResponse (Parcel p) {
         int type;
 
@@ -2110,7 +2166,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
      * @param error is the RIL_Errno sent back
      * @param loggable true means to print all requests in mRequestslist
      */
-    private void clearRequestsList(int error, boolean loggable) {
+    protected void clearRequestsList(int error, boolean loggable) {
         RILRequest rr;
         synchronized (mRequestsList) {
             int count = mRequestsList.size();
@@ -2134,7 +2190,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private RILRequest findAndRemoveRequestFromList(int serial) {
+    protected RILRequest findAndRemoveRequestFromList(int serial) {
         synchronized (mRequestsList) {
             for (int i = 0, s = mRequestsList.size() ; i < s ; i++) {
                 RILRequest rr = mRequestsList.get(i);
@@ -2151,10 +2207,9 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return null;
     }
 
-    private void
+    protected void
     processSolicited (Parcel p) {
         int serial, error;
-        boolean found = false;
 
         serial = p.readInt();
         error = p.readInt();
@@ -2322,7 +2377,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         rr.release();
     }
 
-    private String
+    protected String
     retToString(int req, Object ret) {
         if (ret == null) return "";
         switch (req) {
@@ -2386,7 +2441,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return s;
     }
 
-    private void
+    protected void
     processUnsolicited (Parcel p) {
         int response;
         Object ret;
@@ -2431,9 +2486,11 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
             case RIL_UNSOL_RESEND_INCALL_MUTE: ret = responseVoid(p); break;
             case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: ret = responseInts(p); break;
-            case RIL_UNSOl_CDMA_PRL_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_CDMA_PRL_CHANGED: ret = responseInts(p); break;
             case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
             case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+            //samsung stk service implementation
+            case RIL_UNSOL_STK_SEND_SMS_RESULT: ret = responseInts(p); break;
 
             default:
                 throw new RuntimeException("Unrecognized unsol response: " + response);
@@ -2553,6 +2610,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
                 if (RILJ_LOGD) unsljLogRet(response, ret);
 
+                boolean oldRil = needsOldRilFeature("skipbrokendatacall");
+                if (oldRil && "IP".equals(((ArrayList<DataCallState>)ret).get(0).type))
+                    break;
+
                 mDataNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
             break;
 
@@ -2747,7 +2808,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
                 }
                 break;
 
-            case RIL_UNSOl_CDMA_PRL_CHANGED:
+            case RIL_UNSOL_CDMA_PRL_CHANGED:
                 if (RILJ_LOGD) unsljLogRet(response, ret);
 
                 if (mCdmaPrlChangedRegistrants != null) {
@@ -2775,6 +2836,19 @@ public final class RIL extends BaseCommands implements CommandsInterface {
                 notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
                 break;
             }
+
+            //samsung stk service implementation
+            case RIL_UNSOL_STK_SEND_SMS_RESULT:
+                if (Resources.getSystem().
+                        getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
+                    if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                    if (mCatSendSmsResultRegistrant != null) {
+                        mCatSendSmsResultRegistrant.notifyRegistrant(
+                                new AsyncResult (null, ret, null));
+                    }
+                }
+                break;
         }
     }
 
@@ -2791,7 +2865,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private Object
+    protected Object
     responseInts(Parcel p) {
         int numInts;
         int response[];
@@ -2808,12 +2882,12 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     }
 
 
-    private Object
+    protected Object
     responseVoid(Parcel p) {
         return null;
     }
 
-    private Object
+    protected Object
     responseCallForward(Parcel p) {
         int numInfos;
         CallForwardInfo infos[];
@@ -2836,7 +2910,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return infos;
     }
 
-    private Object
+    protected Object
     responseSuppServiceNotification(Parcel p) {
         SuppServiceNotification notification = new SuppServiceNotification();
 
@@ -2849,7 +2923,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return notification;
     }
 
-    private Object
+    protected Object
     responseCdmaSms(Parcel p) {
         SmsMessage sms;
         sms = SmsMessage.newFromParcel(p);
@@ -2857,7 +2931,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return sms;
     }
 
-    private Object
+    protected Object
     responseString(Parcel p) {
         String response;
 
@@ -2866,7 +2940,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseStrings(Parcel p) {
         int num;
         String response[];
@@ -2885,7 +2959,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseRaw(Parcel p) {
         int num;
         byte response[];
@@ -2895,7 +2969,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSMS(Parcel p) {
         int messageRef, errorCode;
         String ackPDU;
@@ -2910,8 +2984,8 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     }
 
 
-    private Object
-    responseICC_IO(Parcel p) {
+    protected Object
+     responseICC_IO(Parcel p) {
         int sw1, sw2;
         byte data[] = null;
         Message ret;
@@ -2929,16 +3003,31 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return new IccIoResult(sw1, sw2, s);
     }
 
-    private Object
+    @Override
+    public boolean needsOldRilFeature(String feature) {
+        String[] features = SystemProperties.get("ro.telephony.ril.v3", "").split(",");
+        for (String found: features) {
+            if (found.equals(feature))
+                return true;
+        }
+        return false;
+    }
+
+    protected Object
     responseIccCardStatus(Parcel p) {
         IccCardApplication ca;
 
+        boolean oldRil = needsOldRilFeature("icccardstatus");
+
         IccCardStatus status = new IccCardStatus();
         status.setCardState(p.readInt());
         status.setUniversalPinState(p.readInt());
         status.setGsmUmtsSubscriptionAppIndex(p.readInt());
         status.setCdmaSubscriptionAppIndex(p.readInt());
-        status.setImsSubscriptionAppIndex(p.readInt());
+
+        if (!oldRil)
+            status.setImsSubscriptionAppIndex(p.readInt());
+
         int numApplications = p.readInt();
 
         // limit to maximum allowed applications
@@ -2962,7 +3051,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return status;
     }
 
-    private Object
+    protected Object
     responseCallList(Parcel p) {
         int num;
         int voiceSettings;
@@ -3026,7 +3115,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private DataCallState getDataCallState(Parcel p, int version) {
+    protected DataCallState getDataCallState(Parcel p, int version) {
         DataCallState dataCall = new DataCallState();
 
         dataCall.version = version;
@@ -3034,13 +3123,19 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             dataCall.cid = p.readInt();
             dataCall.active = p.readInt();
             dataCall.type = p.readString();
+            p.readString(); // APN - not used
             String addresses = p.readString();
             if (!TextUtils.isEmpty(addresses)) {
                 dataCall.addresses = addresses.split(" ");
             }
+            // DataCallState needs an ifname. Since we don't have one use the name from the ThrottleService resource (default=rmnet0).
+            dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
         } else {
             dataCall.status = p.readInt();
-            dataCall.suggestedRetryTime = p.readInt();
+            if (needsOldRilFeature("usehcradio"))
+                dataCall.suggestedRetryTime = -1;
+            else
+	      dataCall.suggestedRetryTime = p.readInt();
             dataCall.cid = p.readInt();
             dataCall.active = p.readInt();
             dataCall.type = p.readString();
@@ -3065,11 +3160,11 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return dataCall;
     }
 
-    private Object
+    protected Object
     responseDataCallList(Parcel p) {
         ArrayList<DataCallState> response;
-
-        int ver = p.readInt();
+        boolean oldRil = needsOldRilFeature("datacall");
+        int ver = (oldRil ? 3 : p.readInt());
         int num = p.readInt();
         riljLog("responseDataCallList ver=" + ver + " num=" + num);
 
@@ -3081,9 +3176,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSetupDataCall(Parcel p) {
-        int ver = p.readInt();
+        boolean oldRil = needsOldRilFeature("datacall");
+        int ver = (oldRil ? 3 : p.readInt());
         int num = p.readInt();
         if (RILJ_LOGV) riljLog("responseSetupDataCall ver=" + ver + " num=" + num);
 
@@ -3128,7 +3224,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return dataCall;
     }
 
-    private Object
+    protected Object
     responseOperatorInfos(Parcel p) {
         String strings[] = (String [])responseStrings(p);
         ArrayList<OperatorInfo> ret;
@@ -3153,8 +3249,8 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return ret;
     }
 
-    private Object
-    responseCellList(Parcel p) {
+   protected Object
+   responseCellList(Parcel p) {
        int num, rssi;
        String location;
        ArrayList<NeighboringCellInfo> response;
@@ -3166,6 +3262,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
        // Determine the radio access type
        String radioString = SystemProperties.get(
                TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, "unknown");
+       if (radioString.contains(":")) {
+           String[] parts = radioString.split(":");
+           radioString = parts[0];
+       }
        int radioType;
        if (radioString.equals("GPRS")) {
            radioType = NETWORK_TYPE_GPRS;
@@ -3179,6 +3279,8 @@ public final class RIL extends BaseCommands implements CommandsInterface {
            radioType = NETWORK_TYPE_HSUPA;
        } else if (radioString.equals("HSPA")) {
            radioType = NETWORK_TYPE_HSPA;
+       } else if (radioString.equals("HSPAP")) {
+           radioType = NETWORK_TYPE_HSPAP;
        } else {
            radioType = NETWORK_TYPE_UNKNOWN;
        }
@@ -3195,7 +3297,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
        return response;
     }
 
-    private Object responseGetPreferredNetworkType(Parcel p) {
+    protected Object responseGetPreferredNetworkType(Parcel p) {
        int [] response = (int[]) responseInts(p);
 
        if (response.length >= 1) {
@@ -3207,7 +3309,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
        return response;
     }
 
-    private Object responseGmsBroadcastConfig(Parcel p) {
+    protected Object responseGmsBroadcastConfig(Parcel p) {
         int num;
         ArrayList<SmsBroadcastConfigInfo> response;
         SmsBroadcastConfigInfo info;
@@ -3229,7 +3331,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseCdmaBroadcastConfig(Parcel p) {
         int numServiceCategories;
         int response[];
@@ -3268,21 +3370,27 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSignalStrength(Parcel p) {
         int numInts = 12;
         int response[];
 
+        boolean oldRil = needsOldRilFeature("signalstrength");
+
         /* TODO: Add SignalStrength class to match RIL_SignalStrength */
         response = new int[numInts];
         for (int i = 0 ; i < numInts ; i++) {
-            response[i] = p.readInt();
+            if (oldRil && i > 6 && i < 12) {
+                response[i] = -1;
+            } else {
+                response[i] = p.readInt();
+            }
         }
 
         return response;
     }
 
-    private ArrayList<CdmaInformationRecords>
+    protected ArrayList<CdmaInformationRecords>
     responseCdmaInformationRecord(Parcel p) {
         int numberOfInfoRecs;
         ArrayList<CdmaInformationRecords> response;
@@ -3302,7 +3410,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseCdmaCallWaiting(Parcel p) {
         CdmaCallWaitingNotification notification = new CdmaCallWaitingNotification();
 
@@ -3320,7 +3428,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return notification;
     }
 
-    private Object
+    protected Object
     responseCallRing(Parcel p){
         char response[] = new char[4];
 
@@ -3332,7 +3440,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private void
+    protected void
     notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
         int response = RIL_UNSOL_CDMA_INFO_REC;
         if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
@@ -3495,7 +3603,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_ISIM_AUTHENTICATION: return "RIL_REQUEST_ISIM_AUTHENTICATION";
             case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
             case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
-            default: return "<unknown request>";
+            default: return "<unknown request: "+request+">";
         }
     }
 
@@ -3537,37 +3645,38 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
             case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
             case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
-            case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONG";
+            case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONE";
             case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
             case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
-            case RIL_UNSOl_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
+            case RIL_UNSOL_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
             case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
             case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
-            default: return "<unknown reponse>";
+            case RIL_UNSOL_STK_SEND_SMS_RESULT: return "RIL_UNSOL_STK_SEND_SMS_RESULT";
+            default: return "<unknown response: "+request+">";
         }
     }
 
-    private void riljLog(String msg) {
+    protected void riljLog(String msg) {
         Log.d(LOG_TAG, msg);
     }
 
-    private void riljLogv(String msg) {
+    protected void riljLogv(String msg) {
         Log.v(LOG_TAG, msg);
     }
 
-    private void unsljLog(int response) {
+    protected void unsljLog(int response) {
         riljLog("[UNSL]< " + responseToString(response));
     }
 
-    private void unsljLogMore(int response, String more) {
+    protected void unsljLogMore(int response, String more) {
         riljLog("[UNSL]< " + responseToString(response) + " " + more);
     }
 
-    private void unsljLogRet(int response, Object ret) {
+    protected void unsljLogRet(int response, Object ret) {
         riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
-    private void unsljLogvRet(int response, Object ret) {
+    protected void unsljLogvRet(int response, Object ret) {
         riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
diff --git a/telephony/java/com/android/internal/telephony/RILConstants.java b/telephony/java/com/android/internal/telephony/RILConstants.java
index ba9d07a..36c616a 100644
--- a/telephony/java/com/android/internal/telephony/RILConstants.java
+++ b/telephony/java/com/android/internal/telephony/RILConstants.java
@@ -297,7 +297,8 @@ cat include/telephony/ril.h | \
     int RIL_UNSOL_RINGBACK_TONE = 1029;
     int RIL_UNSOL_RESEND_INCALL_MUTE = 1030;
     int RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED = 1031;
-    int RIL_UNSOl_CDMA_PRL_CHANGED = 1032;
+    int RIL_UNSOL_CDMA_PRL_CHANGED = 1032;
     int RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE = 1033;
     int RIL_UNSOL_RIL_CONNECTED = 1034;
+    int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002; /* Samsung specific */
 }
diff --git a/telephony/java/com/android/internal/telephony/SamsungCDMAQualcommRIL.java b/telephony/java/com/android/internal/telephony/SamsungCDMAQualcommRIL.java
new file mode 100644
index 0000000..643c181
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungCDMAQualcommRIL.java
@@ -0,0 +1,429 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.telephony.SmsMessage;
+import android.os.SystemProperties;
+import android.text.TextUtils;
+import android.util.Log;
+
+import android.telephony.PhoneNumberUtils;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+import com.android.internal.telephony.cdma.CdmaInformationRecords.CdmaSignalInfoRec;
+import com.android.internal.telephony.cdma.SignalToneUtil;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+/**
+ * Samsung CDMA RIL doesn't send CDMA NV in RIUM infomation format which causes the CDMA RIL stack to crash and end up not being provisioned.
+ * Samsung put CDMA NV in GSM format. I forced the RIL stack to process CDMA NV request as a GSM SIM in CDMA mode.
+ * Custom Qualcomm No SimReady RIL using the latest Uicc stack
+ * Check for CDMA phone on RADIO_ON* event and if so set status to RUIM_NOT_READY to trigger CSIM/RUIM processing
+ *
+ * {@hide}
+ */
+public class SamsungCDMAQualcommRIL extends QualcommSharedRIL implements CommandsInterface {
+    protected IccHandler mIccHandler;
+    private final int RIL_INT_RADIO_OFF = 0;
+    private final int RIL_INT_RADIO_UNAVALIABLE = 1;
+    private final int RIL_INT_RADIO_ON = 2;
+    private final int RIL_INT_RADIO_ON_NG = 10;
+    private final int RIL_INT_RADIO_ON_HTC = 13;
+
+    public SamsungCDMAQualcommRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+
+        status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0; i < numApplications; i++) {
+            ca = new IccCardApplication();
+            ca.app_type = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid = p.readString();
+            ca.app_label = p.readString();
+            ca.pin1_replaced = p.readInt();
+            ca.pin1 = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2 = ca.PinStateFromRILInt(p.readInt());
+            p.readInt(); //remaining_count_pin1   - pin1_num_retries
+            p.readInt(); //remaining_count_puk1   - puk1_num_retries
+            p.readInt(); //remaining_count_pin2   - pin2_num_retries
+            p.readInt(); //remaining_count_puk2   - puk2_num_retries
+            p.readInt(); //                       - perso_unblock_retries
+            status.addApplication(ca);
+        }
+        int appIndex = -1;
+        appIndex = status.getGsmUmtsSubscriptionAppIndex();
+        Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+
+        if (numApplications > 0) {
+            IccCardApplication application = status.getApplication(appIndex);
+            mAid = application.aid;
+            mUSIM = application.app_type
+                      == IccCardApplication.AppType.APPTYPE_USIM;
+            mSetPreferredNetworkType = mPreferredNetworkType;
+
+            if (TextUtils.isEmpty(mAid))
+               mAid = "";
+            Log.d(LOG_TAG, "mAid " + mAid);
+        }
+
+        return status;
+    }
+
+    @Override
+    protected void setRadioStateFromRILInt (int stateCode) {
+        CommandsInterface.RadioState radioState;
+        HandlerThread handlerThread;
+        Looper looper;
+        IccHandler iccHandler;
+
+        switch (stateCode) {
+            case RIL_INT_RADIO_OFF:
+                radioState = CommandsInterface.RadioState.RADIO_OFF;
+                if (mIccHandler != null) {
+                    mIccThread = null;
+                    mIccHandler = null;
+                }
+                break;
+            case RIL_INT_RADIO_UNAVALIABLE:
+                radioState = CommandsInterface.RadioState.RADIO_UNAVAILABLE;
+                break;
+            case RIL_INT_RADIO_ON:
+            case RIL_INT_RADIO_ON_NG:
+            case RIL_INT_RADIO_ON_HTC:
+                if (mIccHandler == null) {
+                    handlerThread = new HandlerThread("IccHandler");
+                    mIccThread = handlerThread;
+
+                    mIccThread.start();
+
+                    looper = mIccThread.getLooper();
+                    mIccHandler = new IccHandler(this,looper);
+                    mIccHandler.run();
+                }
+
+                if (mPhoneType == RILConstants.CDMA_PHONE) {
+                    radioState = CommandsInterface.RadioState.RUIM_NOT_READY;
+                } else {
+                    radioState = CommandsInterface.RadioState.SIM_NOT_READY;
+                }
+                setRadioState(radioState);
+                break;
+            default:
+                throw new RuntimeException("Unrecognized RIL_RadioState: " + stateCode);
+        }
+
+        setRadioState (radioState);
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        // This is a mashup of algorithms used in
+        // SamsungQualcommUiccRIL.java
+
+        // Get raw data
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+        }
+        //Workaround: use cdmaecio and evdoecio to determine signal strength and it is better than no signal bars
+        //TODO: find a proper fix for it
+        response[2] = response[3]*4; // mutiply by 4 simulate dbm so the signal bars do not jump often to full bars
+        response[4] = response[5]*4;
+        // RIL_LTE_SignalStrength
+        if (response[7] == 99) {
+            // If LTE is not enabled, clear LTE results
+            // 7-11 must be -1 for GSM signal strength to be used (see frameworks/base/telephony/java/android/telephony/SignalStrength.java)
+            response[7]  = -1;
+            response[8]  = -1;
+            response[9]  = -1;
+            response[10] = -1;
+            response[11] = -1;
+        } else {
+            response[8] *= -1;
+        }
+
+        return response;
+
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        int voiceSettings;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+
+        num = p.readInt();
+        response = new ArrayList<DriverCall>(num);
+
+        for (int i = 0 ; i < num ; i++) {
+            dc = new DriverCall();
+
+            dc.state = DriverCall.stateFromCLCC(p.readInt());
+            dc.index = p.readInt();
+            dc.TOA = p.readInt();
+            dc.isMpty = (0 != p.readInt());
+            dc.isMT = (0 != p.readInt());
+            dc.als = p.readInt();
+            voiceSettings = p.readInt();
+            dc.isVoice = (0 == voiceSettings) ? false : true;
+            dc.isVoicePrivacy = (0 != p.readInt());
+            //Some Samsung magic data for Videocalls
+            // hack taken from smdk4210ril class
+            voiceSettings = p.readInt();
+            //printing it to cosole for later investigation
+            Log.d(LOG_TAG, "Samsung magic = " + voiceSettings);
+            dc.number = p.readString();
+            int np = p.readInt();
+            dc.numberPresentation = DriverCall.presentationFromCLIP(np);
+            dc.name = p.readString();
+            dc.namePresentation = p.readInt();
+            int uusInfoPresent = p.readInt();
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                                       dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                                       dc.uusInfo.getUserData().length));
+                riljLogv("Incoming UUS : data (string)="
+                         + new String(dc.uusInfo.getUserData()));
+                riljLogv("Incoming UUS : data (hex): "
+                         + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                riljLogv("Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+    }
+
+    // Workaround for Samsung CDMA "ring of death" bug:
+    //
+    // Symptom: As soon as the phone receives notice of an incoming call, an
+    //   audible "old fashioned ring" is emitted through the earpiece and
+    //   persists through the duration of the call, or until reboot if the call
+    //   isn't answered.
+    //
+    // Background: The CDMA telephony stack implements a number of "signal info
+    //   tones" that are locally generated by ToneGenerator and mixed into the
+    //   voice call path in response to radio RIL_UNSOL_CDMA_INFO_REC requests.
+    //   One of these tones, IS95_CONST_IR_SIG_IS54B_L, is requested by the
+    //   radio just prior to notice of an incoming call when the voice call
+    //   path is muted.  CallNotifier is responsible for stopping all signal
+    //   tones (by "playing" the TONE_CDMA_SIGNAL_OFF tone) upon receipt of a
+    //   "new ringing connection", prior to unmuting the voice call path.
+    //
+    // Problem: CallNotifier's incoming call path is designed to minimize
+    //   latency to notify users of incoming calls ASAP.  Thus,
+    //   SignalInfoTonePlayer requests are handled asynchronously by spawning a
+    //   one-shot thread for each.  Unfortunately the ToneGenerator API does
+    //   not provide a mechanism to specify an ordering on requests, and thus,
+    //   unexpected thread interleaving may result in ToneGenerator processing
+    //   them in the opposite order that CallNotifier intended.  In this case,
+    //   playing the "signal off" tone first, followed by playing the "old
+    //   fashioned ring" indefinitely.
+    //
+    // Solution: An API change to ToneGenerator is required to enable
+    //   SignalInfoTonePlayer to impose an ordering on requests (i.e., drop any
+    //   request that's older than the most recent observed).  Such a change,
+    //   or another appropriate fix should be implemented in AOSP first.
+    //
+    // Workaround: Intercept RIL_UNSOL_CDMA_INFO_REC requests from the radio,
+    //   check for a signal info record matching IS95_CONST_IR_SIG_IS54B_L, and
+    //   drop it so it's never seen by CallNotifier.  If other signal tones are
+    //   observed to cause this problem, they should be dropped here as well.
+    @Override
+    protected void
+    notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
+        final int response = RIL_UNSOL_CDMA_INFO_REC;
+
+        if (infoRec.record instanceof CdmaSignalInfoRec) {
+            CdmaSignalInfoRec sir = (CdmaSignalInfoRec)infoRec.record;
+            if (sir != null && sir.isPresent &&
+                sir.signalType == SignalToneUtil.IS95_CONST_IR_SIGNAL_IS54B &&
+                sir.alertPitch == SignalToneUtil.IS95_CONST_IR_ALERT_MED    &&
+                sir.signal     == SignalToneUtil.IS95_CONST_IR_SIG_IS54B_L) {
+
+                Log.d(LOG_TAG, "Dropping \"" + responseToString(response) + " " +
+                      retToString(response, sir) + "\" to prevent \"ring of death\" bug.");
+                return;
+            }
+        }
+
+        super.notifyRegistrantsCdmaInfoRec(infoRec);
+    }
+
+    class IccHandler extends Handler implements Runnable {
+        private static final int EVENT_RADIO_ON = 1;
+        private static final int EVENT_ICC_STATUS_CHANGED = 2;
+        private static final int EVENT_GET_ICC_STATUS_DONE = 3;
+        private static final int EVENT_RADIO_OFF_OR_UNAVAILABLE = 4;
+
+        private RIL mRil;
+        private boolean mRadioOn = false;
+
+        public IccHandler (RIL ril, Looper looper) {
+            super (looper);
+            mRil = ril;
+        }
+
+        public void handleMessage (Message paramMessage) {
+            switch (paramMessage.what) {
+                case EVENT_RADIO_ON:
+                    mRadioOn = true;
+                    Log.d(LOG_TAG, "Radio on -> Forcing sim status update");
+                    sendMessage(obtainMessage(EVENT_ICC_STATUS_CHANGED));
+                    break;
+                case EVENT_GET_ICC_STATUS_DONE:
+                    AsyncResult asyncResult = (AsyncResult) paramMessage.obj;
+                    if (asyncResult.exception != null) {
+                        Log.e (LOG_TAG, "IccCardStatusDone shouldn't return exceptions!", asyncResult.exception);
+                        break;
+                    }
+                    IccCardStatus status = (IccCardStatus) asyncResult.result;
+                    if (status.getNumApplications() == 0) {
+                        if (!mRil.getRadioState().isOn()) {
+                            break;
+                        }
+                        mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                    } else {
+                        int appIndex = -1;
+                        appIndex = status.getGsmUmtsSubscriptionAppIndex();
+                        Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+
+                        IccCardApplication application = status.getApplication(appIndex);
+                        IccCardApplication.AppState app_state = application.app_state;
+                        IccCardApplication.AppType app_type = application.app_type;
+
+                        switch (app_state) {
+                            case APPSTATE_PIN:
+                            case APPSTATE_PUK:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            case APPSTATE_READY:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_READY);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_READY);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            default:
+                                return;
+                        }
+                    }
+                    break;
+                case EVENT_ICC_STATUS_CHANGED:
+                    if (mRadioOn) {
+                        Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
+                         mRil.getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, paramMessage.obj));
+                    } else {
+                         Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED while radio is not ON. Ignoring");
+                    }
+                    break;
+                case EVENT_RADIO_OFF_OR_UNAVAILABLE:
+                    mRadioOn = false;
+                    // disposeCards(); // to be verified;
+                default:
+                    Log.e(LOG_TAG, " Unknown Event " + paramMessage.what);
+                    break;
+            }
+        }
+
+        public void run () {
+            mRil.registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, null);
+            Message msg = obtainMessage(EVENT_RADIO_ON);
+            mRil.getIccCardStatus(msg);
+        }
+    }
+
+
+}
diff --git a/telephony/java/com/android/internal/telephony/SamsungCDMAv6RIL.java b/telephony/java/com/android/internal/telephony/SamsungCDMAv6RIL.java
new file mode 100644
index 0000000..505adc0
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungCDMAv6RIL.java
@@ -0,0 +1,936 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (C) 2011, 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.lang.Runtime;
+import java.io.IOException;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.AsyncResult;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import static com.android.internal.telephony.RILConstants.*;
+
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.DataCallState;
+import com.android.internal.telephony.DataConnection.FailCause;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.SmsResponse;
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+import com.android.internal.telephony.cdma.CdmaInformationRecords.CdmaSignalInfoRec;
+import com.android.internal.telephony.cdma.SignalToneUtil;
+
+import android.util.Log;
+
+public class SamsungCDMAv6RIL extends RIL implements CommandsInterface {
+
+    public SamsungCDMAv6RIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    // SAMSUNG SGS STATES
+    static final int RIL_UNSOL_O2_HOME_ZONE_INFO = 11007;
+    static final int RIL_UNSOL_DEVICE_READY_NOTI = 11008;
+    static final int RIL_UNSOL_GPS_NOTI = 11009;
+    static final int RIL_UNSOL_AM = 11010;
+    static final int RIL_UNSOL_DATA_SUSPEND_RESUME = 11012;
+    static final int RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL = 11011;
+    static final int RIL_UNSOL_HSDPA_STATE_CHANGED = 11016;
+    static final int RIL_REQUEST_DIAL_EMERGENCY = 10016;
+
+    static String
+    requestToString(int request) {
+        switch (request) {
+            case RIL_REQUEST_DIAL_EMERGENCY: return "DIAL_EMERGENCY";
+            default: return RIL.requestToString(request);
+        }
+    }
+
+    static String
+    samsungResponseToString(int request)
+    {
+    switch(request) {
+        // SAMSUNG STATES
+        case RIL_UNSOL_AM: return "RIL_UNSOL_AM";
+        case RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL: return "RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL";
+        case RIL_UNSOL_DATA_SUSPEND_RESUME: return "RIL_UNSOL_DATA_SUSPEND_RESUME";
+        default:  return "<unknown response: "+request+">";
+    }
+}
+
+    protected void samsungUnsljLogRet(int response, Object ret) {
+        riljLog("[UNSL]< " + samsungResponseToString(response) + " " + retToString(response, ret));
+    }
+
+    @Override
+    public void
+    setRadioPower(boolean on, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
+
+        if (on) {
+            rr.mp.writeInt(1);
+            rr.mp.writeInt(1);
+        } else {
+            rr.mp.writeInt(2);
+            rr.mp.writeInt(0);
+            rr.mp.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    @Override
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        Log.d(LOG_TAG, "Serial: " + serial);
+        Log.d(LOG_TAG, "Error: " + error);
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                    + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+            cat libs/telephony/ril_commands.h \
+            | egrep "^ *{RIL_" \
+            | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseLastCallFailCause(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseVoiceRegistrationState(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseCdmaSubscription(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case RIL_REQUEST_DIAL_EMERGENCY: ret = responseVoid(p); break;
+            case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+                //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            // Ugly fix for Samsung messing up SMS_SEND request fail in binary RIL
+            if (error == -1 && rr.mRequest == RIL_REQUEST_SEND_SMS)
+            {
+                try
+                {
+                    ret = responseSMS(p);
+                } catch (Throwable tr) {
+                    Log.w(LOG_TAG, rr.serialString() + "< "
+                            + requestToString(rr.mRequest)
+                            + " exception, Processing Samsung SMS fix ", tr);
+                    rr.onError(error, ret);
+                    rr.release();
+                    return;
+                }
+            } else {
+                rr.onError(error, ret);
+                rr.release();
+                return;
+            }
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+                + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr;
+
+        rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+        rr.mp.writeString(address);
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mp.writeInt(0); // UUS information is absent
+        } else {
+            rr.mp.writeInt(1); // UUS information is present
+            rr.mp.writeInt(uusInfo.getType());
+            rr.mp.writeInt(uusInfo.getDcs());
+            rr.mp.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    dialEmergencyCall(String address, int clirMode, Message result) {
+        RILRequest rr;
+        Log.v(LOG_TAG, "Emergency dial: " + address);
+
+        rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
+        rr.mp.writeString(address + "/");
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0);
+        rr.mp.writeInt(0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        int response;
+        Object ret;
+        int dataPosition = p.dataPosition();
+
+        response = p.readInt();
+
+        switch(response) {
+        /*
+                cat libs/telephony/ril_unsol_commands.h \
+                | egrep "^ *{RIL_" \
+                | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: \2(rr, p); break;/'
+         */
+
+        case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseString(p); break;
+        case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+        case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+        case RIL_UNSOL_HSDPA_STATE_CHANGED: ret = responseInts(p); break;
+        case RIL_UNSOL_O2_HOME_ZONE_INFO: ret = responseVoid(p); break;
+        case RIL_UNSOL_DEVICE_READY_NOTI: ret = responseVoid(p); break;
+        case RIL_UNSOL_GPS_NOTI: ret = responseVoid(p); break; // Ignored in TW RIL.
+        // SAMSUNG STATES
+        case RIL_UNSOL_AM: ret = responseString(p); break;
+        case RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL: ret = responseVoid(p); break;
+        case RIL_UNSOL_DATA_SUSPEND_RESUME: ret = responseInts(p); break;
+        case RIL_UNSOL_RIL_CONNECTED: ret = responseString(p); break;
+
+        default:
+            // Rewind the Parcel
+            p.setDataPosition(dataPosition);
+
+            // Forward responses that we are not overriding to the super class
+            super.processUnsolicited(p);
+            return;
+        }
+
+        switch(response) {
+            case RIL_UNSOL_HSDPA_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                boolean newHsdpa = ((int[])ret)[0] == 1;
+                String curState = SystemProperties.get(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE);
+                boolean curHsdpa = false;
+
+                if (curState.equals("HSDPA:9")) {
+                    curHsdpa = true;
+                } else if (!curState.equals("UMTS:3")) {
+                    // Don't send poll request if not on 3g
+                    break;
+                }
+
+                if (curHsdpa != newHsdpa) {
+                    mVoiceNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+                }
+                break;
+
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // has bonus long containing milliseconds since boot that the NITZ
+                // time was received
+                long nitzReceiveTime = p.readLong();
+
+                Object[] result = new Object[2];
+
+                String nitz = (String)ret;
+                if (RILJ_LOGD) riljLog(" RIL_UNSOL_NITZ_TIME_RECEIVED length = "
+                                         + nitz.split("[/:,+-]").length);
+
+                // remove the tailing information that samsung added to the string
+                if(nitz.split("[/:,+-]").length >= 9)
+                nitz = nitz.substring(0,(nitz.lastIndexOf(",")));
+
+                if (RILJ_LOGD) riljLog(" RIL_UNSOL_NITZ_TIME_RECEIVED striped nitz = "
+                                         + nitz);
+
+                result[0] = nitz;
+                result[1] = Long.valueOf(nitzReceiveTime);
+
+                if (mNITZTimeRegistrant != null) {
+
+                    mNITZTimeRegistrant
+                    .notifyRegistrant(new AsyncResult (null, result, null));
+                } else {
+                    // in case NITZ time registrant isnt registered yet
+                    mLastNITZTimeInfo = nitz;
+                }
+                break;
+
+            case RIL_UNSOL_SIGNAL_STRENGTH:
+                // Note this is set to "verbose" because it happens
+                // frequently
+                if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+                if (mSignalStrengthRegistrant != null) {
+                    mSignalStrengthRegistrant.notifyRegistrant(
+                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_INFO_REC:
+                ArrayList<CdmaInformationRecords> listInfoRecs;
+
+                try {
+                    listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+                } catch (ClassCastException e) {
+                    Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+                    break;
+                }
+
+                for (CdmaInformationRecords rec : listInfoRecs) {
+                    if (RILJ_LOGD) unsljLogRet(response, rec);
+                    notifyRegistrantsCdmaInfoRec(rec);
+                }
+                break;
+
+            case RIL_UNSOL_RIL_CONNECTED:
+                // FIXME: Processing this state breaks data call.
+                break;
+            // SAMSUNG STATES
+            case RIL_UNSOL_AM:
+                String amString = (String) ret;
+                Log.d(LOG_TAG, "Executing AM: " + amString);
+
+                try {
+                    Runtime.getRuntime().exec("am " + amString);
+                } catch (IOException e) {
+                    e.printStackTrace();
+                    Log.e(LOG_TAG, "am " + amString + " could not be executed.");
+                }
+                break;
+            case RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                break;
+            case RIL_UNSOL_DATA_SUSPEND_RESUME:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                break;
+        }
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        boolean isVideo;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+        int dataAvail = p.dataAvail();
+        int pos = p.dataPosition();
+        int size = p.dataSize();
+
+        Log.d(LOG_TAG, "Parcel size = " + size);
+        Log.d(LOG_TAG, "Parcel pos = " + pos);
+        Log.d(LOG_TAG, "Parcel dataAvail = " + dataAvail);
+
+        num = p.readInt();
+        response = new ArrayList<DriverCall>(num);
+
+        for (int i = 0 ; i < num ; i++) {
+            dc = new SamsungDriverCall();
+
+            dc.state                = DriverCall.stateFromCLCC(p.readInt());
+            dc.index                = p.readInt();
+            dc.TOA                  = p.readInt();
+            dc.isMpty               = (0 != p.readInt());
+            dc.isMT                 = (0 != p.readInt());
+            dc.als                  = p.readInt();
+            dc.isVoice              = (0 != p.readInt());
+            isVideo                 = (0 != p.readInt());
+            dc.isVoicePrivacy       = (0 != p.readInt());
+            dc.number               = p.readString();
+            int np                  = p.readInt();
+            dc.numberPresentation   = DriverCall.presentationFromCLIP(np);
+            dc.name                 = p.readString();
+            dc.namePresentation     = p.readInt();
+            int uusInfoPresent      = p.readInt();
+
+            Log.d(LOG_TAG, "state = " + dc.state);
+            Log.d(LOG_TAG, "index = " + dc.index);
+            Log.d(LOG_TAG, "state = " + dc.TOA);
+            Log.d(LOG_TAG, "isMpty = " + dc.isMpty);
+            Log.d(LOG_TAG, "isMT = " + dc.isMT);
+            Log.d(LOG_TAG, "als = " + dc.als);
+            Log.d(LOG_TAG, "isVoice = " + dc.isVoice);
+            Log.d(LOG_TAG, "isVideo = " + isVideo);
+            Log.d(LOG_TAG, "number = " + dc.number);
+            Log.d(LOG_TAG, "numberPresentation = " + np);
+            Log.d(LOG_TAG, "name = " + dc.name);
+            Log.d(LOG_TAG, "namePresentation = " + dc.namePresentation);
+            Log.d(LOG_TAG, "uusInfoPresent = " + uusInfoPresent);
+
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                Log
+                .v(LOG_TAG, String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                        dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                        dc.uusInfo.getUserData().length));
+                Log.v(LOG_TAG, "Incoming UUS : data (string)="
+                        + new String(dc.uusInfo.getUserData()));
+                Log.v(LOG_TAG, "Incoming UUS : data (hex): "
+                        + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                Log.v(LOG_TAG, "Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+    }
+
+    protected Object
+    responseLastCallFailCause(Parcel p) {
+        int response[] = (int[])responseInts(p);
+
+        if (response.length > 0 &&
+            response[0] == com.android.internal.telephony.cdma.CallFailCause.ERROR_UNSPECIFIED) {
+
+            // Far-end hangup returns ERROR_UNSPECIFIED, which shows "Call Lost" dialog.
+            Log.d(LOG_TAG, "Overriding ERROR_UNSPECIFIED fail cause with NORMAL_CLEARING.");
+            response[0] = com.android.internal.telephony.cdma.CallFailCause.NORMAL_CLEARING;
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+        response = new int[numInts];
+        for (int i = 0 ; i < 7 ; i++) {
+            response[i] = p.readInt();
+        }
+
+        if(response[3] < 0){
+           response[3] = -response[3];
+        }
+        // Scale cdmaDbm so Samsung's -95..-105 range for SIGNAL_STRENGTH_POOR
+        // fits in AOSP's -95..-100 range
+        if(response[2] > 95){
+        //   Log.d(LOG_TAG, "SignalStrength: Scaling cdmaDbm \"" + response[2] + "\" for smaller SIGNAL_STRENGTH_POOR bucket.");
+           response[2] = ((response[2]-96)/2)+96;
+        }
+        // Framework takes care of the rest for us.
+        return response;
+    }
+
+    protected Object
+    responseVoiceRegistrationState(Parcel p) {
+        String response[] = (String[])responseStrings(p);
+
+        // These values are provided in hex, convert to dec.
+        response[4] = Integer.toString(Integer.parseInt(response[4], 16)); // baseStationId
+        response[5] = Integer.toString(Integer.parseInt(response[5], 16)); // baseStationLatitude
+        response[6] = Integer.toString(Integer.parseInt(response[6], 16)); // baseStationLongitude
+
+        return response;
+    }
+
+    protected Object
+    responseNetworkType(Parcel p) {
+        int response[] = (int[]) responseInts(p);
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseSetupDataCall(Parcel p) {
+        DataCallState dataCall = new DataCallState();
+        String strings[] = (String []) responseStrings(p);
+
+        if (strings.length >= 2) {
+            dataCall.cid = Integer.parseInt(strings[0]);
+
+            // We're responsible for starting/stopping the pppd_cdma service.
+            if (!startPppdCdmaService(strings[1])) {
+                // pppd_cdma service didn't respond timely.
+                dataCall.status = FailCause.ERROR_UNSPECIFIED.getErrorCode();
+                return dataCall;
+            }
+
+            // pppd_cdma service responded, pull network parameters set by ip-up script.
+            dataCall.ifname = SystemProperties.get("net.cdma.ppp.interface");
+            String   ifprop = "net." + dataCall.ifname;
+
+            dataCall.addresses = new String[] {SystemProperties.get(ifprop + ".local-ip")};
+            dataCall.gateways  = new String[] {SystemProperties.get(ifprop + ".remote-ip")};
+            dataCall.dnses     = new String[] {SystemProperties.get(ifprop + ".dns1"),
+                                               SystemProperties.get(ifprop + ".dns2")};
+        } else {
+            // On rare occasion the pppd_cdma service is left active from a stale
+            // session, causing the data call setup to fail.  Make sure that pppd_cdma
+            // is stopped now, so that the next setup attempt may succeed.
+            Log.d(LOG_TAG, "Set ril.cdma.data_state=0 to make sure pppd_cdma is stopped.");
+            SystemProperties.set("ril.cdma.data_state", "0");
+
+            dataCall.status = FailCause.ERROR_UNSPECIFIED.getErrorCode(); // Who knows?
+        }
+
+        return dataCall;
+    }
+
+    private boolean startPppdCdmaService(String ttyname) {
+        SystemProperties.set("net.cdma.datalinkinterface", ttyname);
+
+        // Connecting: Set ril.cdma.data_state=1 to (re)start pppd_cdma service,
+        // which responds by setting ril.cdma.data_state=2 once connection is up.
+        SystemProperties.set("ril.cdma.data_state", "1");
+        Log.d(LOG_TAG, "Set ril.cdma.data_state=1, waiting for ril.cdma.data_state=2.");
+
+        // Typically takes < 200 ms on my Epic, so sleep in 100 ms intervals.
+        for (int i = 0; i < 10; i++) {
+            try {Thread.sleep(100);} catch (InterruptedException e) {}
+
+            if (SystemProperties.getInt("ril.cdma.data_state", 1) == 2) {
+                Log.d(LOG_TAG, "Got ril.cdma.data_state=2, connected.");
+                return true;
+            }
+        }
+
+        // Taking > 1 s here, try up to 10 s, which is hopefully long enough.
+        for (int i = 1; i < 10; i++) {
+            try {Thread.sleep(1000);} catch (InterruptedException e) {}
+
+            if (SystemProperties.getInt("ril.cdma.data_state", 1) == 2) {
+                Log.d(LOG_TAG, "Got ril.cdma.data_state=2, connected.");
+                return true;
+            }
+        }
+
+        // Disconnect: Set ril.cdma.data_state=0 to stop pppd_cdma service.
+        Log.d(LOG_TAG, "Didn't get ril.cdma.data_state=2 timely, aborting.");
+        SystemProperties.set("ril.cdma.data_state", "0");
+
+        return false;
+    }
+
+    @Override
+    public void
+    deactivateDataCall(int cid, int reason, Message result) {
+        // Disconnect: Set ril.cdma.data_state=0 to stop pppd_cdma service.
+        Log.d(LOG_TAG, "Set ril.cdma.data_state=0.");
+        SystemProperties.set("ril.cdma.data_state", "0");
+
+        super.deactivateDataCall(cid, reason, result);
+    }
+
+    protected Object
+    responseCdmaSubscription(Parcel p) {
+        String response[] = (String[])responseStrings(p);
+
+        if (response.length == 4) {
+            // PRL version is missing in subscription parcel, add it from properties.
+            String prlVersion = SystemProperties.get("ril.prl_ver_1").split(":")[1];
+            response          = new String[] {response[0], response[1], response[2],
+                                              response[3], prlVersion};
+        }
+
+        return response;
+    }
+
+    // Workaround for Samsung CDMA "ring of death" bug:
+    //
+    // Symptom: As soon as the phone receives notice of an incoming call, an
+    //   audible "old fashioned ring" is emitted through the earpiece and
+    //   persists through the duration of the call, or until reboot if the call
+    //   isn't answered.
+    //
+    // Background: The CDMA telephony stack implements a number of "signal info
+    //   tones" that are locally generated by ToneGenerator and mixed into the
+    //   voice call path in response to radio RIL_UNSOL_CDMA_INFO_REC requests.
+    //   One of these tones, IS95_CONST_IR_SIG_IS54B_L, is requested by the
+    //   radio just prior to notice of an incoming call when the voice call
+    //   path is muted.  CallNotifier is responsible for stopping all signal
+    //   tones (by "playing" the TONE_CDMA_SIGNAL_OFF tone) upon receipt of a
+    //   "new ringing connection", prior to unmuting the voice call path.
+    //
+    // Problem: CallNotifier's incoming call path is designed to minimize
+    //   latency to notify users of incoming calls ASAP.  Thus,
+    //   SignalInfoTonePlayer requests are handled asynchronously by spawning a
+    //   one-shot thread for each.  Unfortunately the ToneGenerator API does
+    //   not provide a mechanism to specify an ordering on requests, and thus,
+    //   unexpected thread interleaving may result in ToneGenerator processing
+    //   them in the opposite order that CallNotifier intended.  In this case,
+    //   playing the "signal off" tone first, followed by playing the "old
+    //   fashioned ring" indefinitely.
+    //
+    // Solution: An API change to ToneGenerator is required to enable
+    //   SignalInfoTonePlayer to impose an ordering on requests (i.e., drop any
+    //   request that's older than the most recent observed).  Such a change,
+    //   or another appropriate fix should be implemented in AOSP first.
+    //
+    // Workaround: Intercept RIL_UNSOL_CDMA_INFO_REC requests from the radio,
+    //   check for a signal info record matching IS95_CONST_IR_SIG_IS54B_L, and
+    //   drop it so it's never seen by CallNotifier.  If other signal tones are
+    //   observed to cause this problem, they should be dropped here as well.
+    @Override
+    protected void
+    notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
+        final int response = RIL_UNSOL_CDMA_INFO_REC;
+
+        if (infoRec.record instanceof CdmaSignalInfoRec) {
+            CdmaSignalInfoRec sir = (CdmaSignalInfoRec)infoRec.record;
+            if (sir != null && sir.isPresent &&
+                sir.signalType == SignalToneUtil.IS95_CONST_IR_SIGNAL_IS54B &&
+                sir.alertPitch == SignalToneUtil.IS95_CONST_IR_ALERT_MED    &&
+                sir.signal     == SignalToneUtil.IS95_CONST_IR_SIG_IS54B_L) {
+
+                Log.d(LOG_TAG, "Dropping \"" + responseToString(response) + " " +
+                      retToString(response, sir) + "\" to prevent \"ring of death\" bug.");
+                return;
+            }
+        }
+
+        super.notifyRegistrantsCdmaInfoRec(infoRec);
+    }
+
+    protected class SamsungDriverCall extends DriverCall {
+        @Override
+        public String
+        toString() {
+            // Samsung CDMA devices' call parcel is formatted differently
+            // fake unused data for video calls, and fix formatting
+            // so that voice calls' information can be correctly parsed
+            return "id=" + index + ","
+            + state + ","
+            + "toa=" + TOA + ","
+            + (isMpty ? "conf" : "norm") + ","
+            + (isMT ? "mt" : "mo") + ","
+            + "als=" + als + ","
+            + (isVoice ? "voc" : "nonvoc") + ","
+            + "nonvid" + ","
+            + number + ","
+            + "cli=" + numberPresentation + ","
+            + "name=" + name + ","
+            + namePresentation;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setCurrentPreferredNetworkType() {
+        if (RILJ_LOGD) riljLog("setCurrentPreferredNetworkType IGNORED");
+        /* Google added this as a fix for crespo loosing network type after
+         * taking an OTA. This messes up the data connection state for us
+         * due to the way we handle network type change (disable data
+         * then change then re-enable).
+         */
+    }
+
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+        /* Samsung modem implementation does bad things when a datacall is running
+         * while switching the preferred networktype.
+         */
+        ConnectivityManager cm =
+            (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        if(cm.getMobileDataEnabled())
+        {
+            ConnectivityHandler handler = new ConnectivityHandler(mContext);
+            handler.setPreferedNetworkType(networkType, response);
+        } else {
+            sendPreferredNetworkType(networkType, response);
+        }
+    }
+
+
+    //Sends the real RIL request to the modem.
+    private void sendPreferredNetworkType(int networkType, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(networkType);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " : " + networkType);
+
+        send(rr);
+    }
+    /* private class that does the handling for the dataconnection
+     * dataconnection is done async, so we send the request for disabling it,
+     * wait for the response, set the prefered networktype and notify the
+     * real sender with its result.
+     */
+    private class ConnectivityHandler extends Handler{
+
+        private static final int MESSAGE_SET_PREFERRED_NETWORK_TYPE = 30;
+        private Context mContext;
+        private int mDesiredNetworkType;
+        //the original message, we need it for calling back the original caller when done
+        private Message mNetworktypeResponse;
+        private ConnectivityBroadcastReceiver mConnectivityReceiver =  new ConnectivityBroadcastReceiver();
+
+        public ConnectivityHandler(Context context)
+        {
+            mContext = context;
+        }
+
+        private void startListening() {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+            mContext.registerReceiver(mConnectivityReceiver, filter);
+        }
+
+        private synchronized void stopListening() {
+            mContext.unregisterReceiver(mConnectivityReceiver);
+        }
+
+        public void setPreferedNetworkType(int networkType, Message response)
+        {
+            Log.d(LOG_TAG, "Mobile Dataconnection is online setting it down");
+            mDesiredNetworkType = networkType;
+            mNetworktypeResponse = response;
+            ConnectivityManager cm =
+                (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+            //start listening for the connectivity change broadcast
+            startListening();
+            cm.setMobileDataEnabled(false);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch(msg.what) {
+            //networktype was set, now we can enable the dataconnection again
+            case MESSAGE_SET_PREFERRED_NETWORK_TYPE:
+                ConnectivityManager cm =
+                    (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+                Log.d(LOG_TAG, "preferred NetworkType set upping Mobile Dataconnection");
+
+                cm.setMobileDataEnabled(true);
+                //everything done now call back that we have set the networktype
+                AsyncResult.forMessage(mNetworktypeResponse, null, null);
+                mNetworktypeResponse.sendToTarget();
+                mNetworktypeResponse = null;
+                break;
+            default:
+                throw new RuntimeException("unexpected event not handled");
+            }
+        }
+
+        private class ConnectivityBroadcastReceiver extends BroadcastReceiver {
+
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+                if (!action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
+                    Log.w(LOG_TAG, "onReceived() called with " + intent);
+                    return;
+                }
+                boolean noConnectivity =
+                    intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);
+
+                if (noConnectivity) {
+                    //Ok dataconnection is down, now set the networktype
+                    Log.w(LOG_TAG, "Mobile Dataconnection is now down setting preferred NetworkType");
+                    stopListening();
+                    sendPreferredNetworkType(mDesiredNetworkType, obtainMessage(MESSAGE_SET_PREFERRED_NETWORK_TYPE));
+                    mDesiredNetworkType = -1;
+                }
+            }
+        }
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/SamsungHCRIL.java b/telephony/java/com/android/internal/telephony/SamsungHCRIL.java
new file mode 100644
index 0000000..106de6f
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungHCRIL.java
@@ -0,0 +1,87 @@
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.util.Log;
+import static com.android.internal.telephony.RILConstants.*;
+
+public class SamsungHCRIL extends RIL implements CommandsInterface {
+
+    private boolean mSignalbarCount = SystemProperties.getInt("ro.telephony.sends_barcount", 0) == 1 ? true : false;        
+
+    public SamsungHCRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+    static final String LOG_TAG = "RILJ";
+    //SAMSUNG SGS STATES
+    static final int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002;
+    static final int RIL_UNSOL_O2_HOME_ZONE_INFO = 11007;
+    static final int RIL_UNSOL_DEVICE_READY_NOTI = 11008;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_3 = 11010;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_2 = 11011;
+    static final int RIL_UNSOL_HSDPA_STATE_CHANGED = 11016;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST = 11012;
+    static final int RIL_REQUEST_DIAL_EMERGENCY = 10016;
+
+    @Override
+    public void
+    setRadioPower(boolean on, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
+        //samsung stuff for airplane mode
+        if (on) {
+            rr.mp.writeInt(1);
+            rr.mp.writeInt(1);
+        } else {
+            rr.mp.writeInt(2);
+            rr.mp.writeInt(0);
+            rr.mp.writeInt(0);
+        }
+        if (RILJ_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + (on ? " on" : " off"));
+        }
+        send(rr);
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        boolean oldRil = needsOldRilFeature("signalstrength");
+
+        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            if (oldRil && i > 6 && i < 12) {
+                response[i] = -1;
+            } else {
+                response[i] = p.readInt();
+            }
+        }
+
+        /* Matching Samsung signal strength to asu.
+		   Method taken from Samsungs cdma/gsmSignalStateTracker */
+        if(mSignalbarCount)
+        {
+            //Samsung sends the count of bars that should be displayed instead of
+            //a real signal strength
+            response[0] = ((response[0] & 0xFF00) >> 8) * 3; //gsmDbm
+        } else {
+            response[0] = response[0] & 0xFF; //gsmDbm
+        }
+        response[1] = -1; //gsmEcio
+        response[2] = (response[2] < 0)?-120:-response[2]; //cdmaDbm
+        response[3] = (response[3] < 0)?-160:-response[3]; //cdmaEcio
+        response[4] = (response[4] < 0)?-120:-response[4]; //evdoRssi
+        response[5] = (response[5] < 0)?-1:-response[5]; //evdoEcio
+        if(response[6] < 0 || response[6] > 8)
+            response[6] = -1;
+
+        return response;
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/SamsungMSMRIL.java b/telephony/java/com/android/internal/telephony/SamsungMSMRIL.java
new file mode 100644
index 0000000..fb42ae7
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungMSMRIL.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.Parcel;
+import android.os.AsyncResult;
+import android.util.Log;
+import com.android.internal.telephony.RILConstants;
+
+/**
+ * Custom RIL to handle unique behavior of Samsung's MSM7X30 devices radio
+ *
+ * {@hide}
+ */
+public class SamsungMSMRIL extends RIL implements CommandsInterface {
+
+    public SamsungMSMRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition();   // save off position within the Parcel
+        int response     = p.readInt();
+
+        switch(response) {
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                handleNitzTimeReceived(p);
+                return;
+
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+    }
+
+    protected void
+    handleNitzTimeReceived(Parcel p) {
+        String nitz = (String)responseString(p);
+        if (RILJ_LOGD) unsljLogRet(RIL_UNSOL_NITZ_TIME_RECEIVED, nitz);
+
+        // has bonus long containing milliseconds since boot that the NITZ
+        // time was received
+        long nitzReceiveTime = p.readLong();
+
+        Object[] result = new Object[2];
+
+        String fixedNitz = nitz;
+        String[] nitzParts = nitz.split(",");
+        if (nitzParts.length == 4) {
+            // 0=date, 1=time+zone, 2=dst, 3=garbage that confuses GsmServiceStateTracker (so remove it)
+            fixedNitz = nitzParts[0]+","+nitzParts[1]+","+nitzParts[2]+",";
+        }
+
+        result[0] = fixedNitz;
+        result[1] = Long.valueOf(nitzReceiveTime);
+
+        if (mNITZTimeRegistrant != null) {
+
+            mNITZTimeRegistrant
+                .notifyRegistrant(new AsyncResult (null, result, null));
+        } else {
+            // in case NITZ time registrant isnt registered yet
+            mLastNITZTimeInfo = result;
+        }
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+        response = new int[numInts];
+        for (int i = 0 ; i < 7 ; i++) {
+            response[i] = p.readInt();
+        }
+        // SamsungRIL is a v3 RIL, fill the rest with -1
+        for (int i = 7; i < numInts; i++) {
+            response[i] = -1;
+        }
+
+        response[0] = response[0] & 0xFF; // gsmDbm
+
+        return response;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/SamsungQualcommD2RIL.java b/telephony/java/com/android/internal/telephony/SamsungQualcommD2RIL.java
new file mode 100644
index 0000000..bd7c1d5
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungQualcommD2RIL.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.util.Log;
+import com.android.internal.telephony.RILConstants;
+import java.util.Collections;
+import android.telephony.PhoneNumberUtils;
+
+import java.util.ArrayList;
+
+/**
+ * Custom RIL to handle unique behavior of D2 radio
+ *
+ * {@hide}
+ */
+public class SamsungQualcommD2RIL extends SamsungQualcommUiccRIL implements CommandsInterface {
+    public SamsungQualcommD2RIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        int voiceSettings;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+
+        num = p.readInt();
+        response = new ArrayList<DriverCall>(num);
+
+        for (int i = 0 ; i < num ; i++) {
+            dc = new DriverCall();
+
+            dc.state = DriverCall.stateFromCLCC(p.readInt());
+            dc.index = p.readInt();
+            dc.TOA = p.readInt();
+            dc.isMpty = (0 != p.readInt());
+            dc.isMT = (0 != p.readInt());
+            dc.als = p.readInt();
+            voiceSettings = p.readInt();
+            dc.isVoice = (0 == voiceSettings) ? false : true;
+            dc.isVoicePrivacy = (0 != p.readInt());
+            //Some Samsung magic data for Videocalls
+            // hack taken from smdk4210ril class
+            voiceSettings = p.readInt();
+            //printing it to cosole for later investigation
+            Log.d(LOG_TAG, "Samsung magic = " + voiceSettings);
+            dc.number = p.readString();
+            int np = p.readInt();
+            dc.numberPresentation = DriverCall.presentationFromCLIP(np);
+            dc.name = p.readString();
+            dc.namePresentation = p.readInt();
+            int uusInfoPresent = p.readInt();
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                                       dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                                       dc.uusInfo.getUserData().length));
+                riljLogv("Incoming UUS : data (string)="
+                         + new String(dc.uusInfo.getUserData()));
+                riljLogv("Incoming UUS : data (hex): "
+                         + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                riljLogv("Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                riljLog("InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/SamsungQualcommUiccRIL.java b/telephony/java/com/android/internal/telephony/SamsungQualcommUiccRIL.java
new file mode 100644
index 0000000..2c942ea
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungQualcommUiccRIL.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.os.AsyncResult;
+import android.text.TextUtils;
+import android.util.Log;
+import com.android.internal.telephony.RILConstants;
+
+import java.util.ArrayList;
+
+/**
+ * Custom RIL to handle unique behavior of Hercules/Skyrocket/Note radio
+ *
+ * {@hide}
+ */
+public class SamsungQualcommUiccRIL extends QualcommSharedRIL implements CommandsInterface {
+    boolean RILJ_LOGV = true;
+    boolean RILJ_LOGD = true;
+
+    public static final int INVALID_SNR = 0x7fffffff;
+    private boolean mSignalbarCount = SystemProperties.getBoolean("ro.telephony.sends_barcount", false);
+
+    public SamsungQualcommUiccRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition();   // save off position within the Parcel
+        int response     = p.readInt();
+
+        switch(response) {
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                handleNitzTimeReceived(p);
+                return;
+            case 1038: ret = responseVoid(p); break; // RIL_UNSOL_DATA_NETWORK_STATE_CHANGED
+
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+
+        switch(response) {
+            case 1038: // RIL_UNSOL_DATA_NETWORK_STATE_CHANGED
+                if (RILJ_LOGD) unsljLog(response);
+
+                // Notifying on voice state change since it just causes a
+                // GsmServiceStateTracker::pollState() like CAF RIL does.
+                mVoiceNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+        }
+    }
+
+    protected void
+    handleNitzTimeReceived(Parcel p) {
+        String nitz = (String)responseString(p);
+        if (RILJ_LOGD) unsljLogRet(RIL_UNSOL_NITZ_TIME_RECEIVED, nitz);
+
+        // has bonus long containing milliseconds since boot that the NITZ
+        // time was received
+        long nitzReceiveTime = p.readLong();
+
+        Object[] result = new Object[2];
+
+        String fixedNitz = nitz;
+        String[] nitzParts = nitz.split(",");
+        if (nitzParts.length == 4) {
+            // 0=date, 1=time+zone, 2=dst, 3=garbage that confuses GsmServiceStateTracker (so remove it)
+            fixedNitz = nitzParts[0]+","+nitzParts[1]+","+nitzParts[2]+",";
+        }
+
+        result[0] = fixedNitz;
+        result[1] = Long.valueOf(nitzReceiveTime);
+
+        if (mNITZTimeRegistrant != null) {
+
+            mNITZTimeRegistrant
+                .notifyRegistrant(new AsyncResult (null, result, null));
+        } else {
+            // in case NITZ time registrant isnt registered yet
+            mLastNITZTimeInfo = result;
+        }
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric);
+
+        rr.mp.writeString(operatorNumeric);
+
+        send(rr);
+    }
+
+    @Override
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 4 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 4");
+        }
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 4);
+
+        for (int i = 0 ; i < strings.length ; i += 4) {
+            ret.add (
+                new OperatorInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt() );
+
+        status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2           = ca.PinStateFromRILInt(p.readInt());
+
+            p.readInt(); //remaining_count_pin1   - pin1_num_retries
+            p.readInt(); //remaining_count_puk1   - puk1_num_retries
+            p.readInt(); //remaining_count_pin2   - pin2_num_retries
+            p.readInt(); //remaining_count_puk2   - puk2_num_retries
+            p.readInt(); //                       - perso_unblock_retries
+            status.addApplication(ca);
+        }
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        if (numApplications > 0) {
+            IccCardApplication application = status.getApplication(appIndex);
+            mAid = application.aid;
+            mUSIM = application.app_type
+                      == IccCardApplication.AppType.APPTYPE_USIM;
+            mSetPreferredNetworkType = mPreferredNetworkType;
+
+            if (TextUtils.isEmpty(mAid))
+               mAid = "";
+            Log.d(LOG_TAG, "mAid " + mAid + " mUSIM=" + mUSIM + " mSetPreferredNetworkType=" + mSetPreferredNetworkType);
+        }
+
+        return status;
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        // This is a mashup of algorithms used in
+        // LGEQualcommUiccRIL.java and SamsungHCRIL.java
+
+        // Get raw data
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+        }
+        Log.d(LOG_TAG, "responseSignalStength BEFORE: mode=" + (mSignalbarCount ? "bars" : "raw") +
+            " gsmDbm=" + response[0] + " gsmEcio=" + response[1] +
+            " lteSignalStrength=" + response[7] + " lteRsrp=" + response[8] + " lteRsrq=" + response[9] +
+            " lteRssnr=" + response[10] + " lteCqi=" + response[11]);
+
+        // RIL_GW_SignalStrength
+        if (mSignalbarCount) {
+            //Samsung sends the count of bars that should be displayed instead of
+            //a real signal strength
+            int num_bars = (response[0] & 0xff00) >> 8;
+
+            // Translate number of bars into something SignalStrength.java can understand
+            switch (num_bars) {
+                case 0  : response[0] = 1;     break; // map to 0 bars
+                case 1  : response[0] = 3;     break; // map to 1 bar
+                case 2  : response[0] = 5;     break; // map to 2 bars
+                case 3  : response[0] = 8;     break; // map to 3 bars
+                case 4  : response[0] = 12;    break; // map to 4 bars
+                case 5  : response[0] = 15;    break; // map to 4 bars but give an extra 10 dBm
+                default : response[0] &= 0xff; break; // no idea; just pass value through
+            }
+        } else {
+            response[0] &= 0xff; //gsmDbm
+        }
+        response[1] = -1; // gsmEcio
+
+        // RIL_CDMA_SignalStrength (unused)
+        response[2] = -1; // cdmaDbm
+        response[3] = -1; // cdmaEcio
+
+        // RIL_EVDO_SignalStrength (unused)
+        response[4] = -1; // evdoRssi
+        response[5] = -1; // evdoEcio
+        response[6] = -1; // evdoSNR
+
+        // RIL_LTE_SignalStrength
+        if (response[7] == 99) {
+            // If LTE is not enabled, clear LTE results
+            // 7-11 must be -1 for GSM signal strength to be used (see frameworks/base/telephony/java/android/telephony/SignalStrength.java)
+            response[7]  = -1; // lteSignalStrength
+            response[8]  = -1; // lteRsrp
+            response[9]  = -1; // lteRsrq
+            response[10] = -1; // lteRssnr
+            response[11] = -1; // lteCqi
+        } else if (mSignalbarCount) {
+            int num_bars = (response[7] & 0xff00) >> 8;
+            response[7] &= 0xff;        // remove the Samsung number of bars field
+            response[10] = INVALID_SNR; // mark lteRssnr invalid so it doesn't get used
+
+            // Translate number of bars into something SignalStrength.java can understand
+            switch (num_bars) {
+                case 0  : response[8] = -1;   break; // map to 0 bars
+                case 1  : response[8] = -116; break; // map to 1 bar
+                case 2  : response[8] = -115; break; // map to 2 bars
+                case 3  : response[8] = -105; break; // map to 3 bars
+                case 4  : response[8] = -95;  break; // map to 4 bars
+                case 5  : response[8] = -85;  break; // map to 4 bars but give an extra 10 dBm
+                default : response[8] *= -1;  break; // no idea; just pass value through
+            }
+        } else {
+            response[7] &= 0xff;  // remove the Samsung number of bars field
+            response[8] *= -1;
+        }
+
+        Log.d(LOG_TAG, "responseSignalStength AFTER: mode=" + (mSignalbarCount ? "bars" : "raw") +
+            " gsmDbm=" + response[0] + " gsmEcio=" + response[1] +
+            " lteSignalStrength=" + response[7] + " lteRsrp=" + response[8] + " lteRsrq=" + response[9] +
+            " lteRssnr=" + response[10] + " lteCqi=" + response[11]);
+        return response;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/SamsungRIL.java b/telephony/java/com/android/internal/telephony/SamsungRIL.java
new file mode 100644
index 0000000..fa19714
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungRIL.java
@@ -0,0 +1,960 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (C) 2011, 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.lang.Runtime;
+import java.io.IOException;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.AsyncResult;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import static com.android.internal.telephony.RILConstants.*;
+
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.DataCallState;
+import com.android.internal.telephony.DataConnection.FailCause;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.SmsResponse;
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+import com.android.internal.telephony.cdma.CdmaInformationRecords.CdmaSignalInfoRec;
+import com.android.internal.telephony.cdma.SignalToneUtil;
+
+import android.util.Log;
+
+public class SamsungRIL extends RIL implements CommandsInterface {
+
+    private boolean mSignalbarCount = SystemProperties.getInt("ro.telephony.sends_barcount", 0) == 1 ? true : false;
+    private boolean mIsSamsungCdma = SystemProperties.getBoolean("ro.ril.samsung_cdma", false);
+
+    public SamsungRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    // SAMSUNG SGS STATES
+    static final int RIL_UNSOL_O2_HOME_ZONE_INFO = 11007;
+    static final int RIL_UNSOL_DEVICE_READY_NOTI = 11008;
+    static final int RIL_UNSOL_GPS_NOTI = 11009;
+    static final int RIL_UNSOL_AM = 11010;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST = 11012;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_2 = 11011;
+    static final int RIL_UNSOL_HSDPA_STATE_CHANGED = 11016;
+    static final int RIL_REQUEST_DIAL_EMERGENCY = 10016;
+
+    static String
+    requestToString(int request) {
+        switch (request) {
+            case RIL_REQUEST_DIAL_EMERGENCY: return "DIAL_EMERGENCY";
+            default: return RIL.requestToString(request);
+        }
+    }
+
+    @Override
+    public void
+    setRadioPower(boolean on, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
+
+        if (on) {
+            rr.mp.writeInt(1);
+            rr.mp.writeInt(1);
+        } else {
+            rr.mp.writeInt(2);
+            rr.mp.writeInt(0);
+            rr.mp.writeInt(0);
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    @Override
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        Log.d(LOG_TAG, "Serial: " + serial);
+        Log.d(LOG_TAG, "Error: " + error);
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                    + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+            cat libs/telephony/ril_commands.h \
+            | egrep "^ *{RIL_" \
+            | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseLastCallFailCause(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseVoiceRegistrationState(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseCdmaSubscription(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case RIL_REQUEST_DIAL_EMERGENCY: ret = responseVoid(p); break;
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+                //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            // Ugly fix for Samsung messing up SMS_SEND request fail in binary RIL
+            if (error == -1 && rr.mRequest == RIL_REQUEST_SEND_SMS)
+            {
+                try
+                {
+                    ret = responseSMS(p);
+                } catch (Throwable tr) {
+                    Log.w(LOG_TAG, rr.serialString() + "< "
+                            + requestToString(rr.mRequest)
+                            + " exception, Processing Samsung SMS fix ", tr);
+                    rr.onError(error, ret);
+                    rr.release();
+                    return;
+                }
+            } else {
+                rr.onError(error, ret);
+                rr.release();
+                return;
+            }
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+                + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr;
+        if (!mIsSamsungCdma && PhoneNumberUtils.isEmergencyNumber(address)) {
+            dialEmergencyCall(address, clirMode, result);
+            return;
+        }
+
+        rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+        rr.mp.writeString(address);
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mp.writeInt(0); // UUS information is absent
+        } else {
+            rr.mp.writeInt(1); // UUS information is present
+            rr.mp.writeInt(uusInfo.getType());
+            rr.mp.writeInt(uusInfo.getDcs());
+            rr.mp.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    dialEmergencyCall(String address, int clirMode, Message result) {
+        RILRequest rr;
+        Log.v(LOG_TAG, "Emergency dial: " + address);
+
+        rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
+        rr.mp.writeString(address + "/");
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0);
+        rr.mp.writeInt(0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        int response;
+        Object ret;
+        int dataPosition = p.dataPosition();
+
+        response = p.readInt();
+
+        switch(response) {
+        /*
+				cat libs/telephony/ril_unsol_commands.h \
+				| egrep "^ *{RIL_" \
+				| sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: \2(rr, p); break;/'
+         */
+
+        case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseString(p); break;
+        case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+        case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+        case RIL_UNSOL_HSDPA_STATE_CHANGED: ret = responseInts(p); break;
+
+        //fixing anoying Exceptions caused by the new Samsung states
+        //FIXME figure out what the states mean an what data is in the parcel
+
+        case RIL_UNSOL_O2_HOME_ZONE_INFO: ret = responseVoid(p); break;
+        case RIL_UNSOL_DEVICE_READY_NOTI: ret = responseVoid(p); break;
+        case RIL_UNSOL_GPS_NOTI: ret = responseVoid(p); break; // Ignored in TW RIL.
+        case RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST: ret = responseVoid(p); break;
+        case RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_2: ret = responseVoid(p); break;
+        case RIL_UNSOL_AM: ret = responseString(p); break;
+
+        default:
+            // Rewind the Parcel
+            p.setDataPosition(dataPosition);
+
+            // Forward responses that we are not overriding to the super class
+            super.processUnsolicited(p);
+            return;
+        }
+
+        switch(response) {
+        case RIL_UNSOL_HSDPA_STATE_CHANGED:
+            if (RILJ_LOGD) unsljLog(response);
+
+            boolean newHsdpa = ((int[])ret)[0] == 1;
+            String curState = SystemProperties.get(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE);
+            boolean curHsdpa = false;
+
+            if (curState.equals("HSDPA:9")) {
+                curHsdpa = true;
+            } else if (!curState.equals("UMTS:3")) {
+                // Don't send poll request if not on 3g
+                break;
+            }
+
+            if (curHsdpa != newHsdpa) {
+                mVoiceNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            }
+            break;
+
+        case RIL_UNSOL_NITZ_TIME_RECEIVED:
+            if (RILJ_LOGD) unsljLogRet(response, ret);
+
+            // has bonus long containing milliseconds since boot that the NITZ
+            // time was received
+            long nitzReceiveTime = p.readLong();
+
+            Object[] result = new Object[2];
+
+            String nitz = (String)ret;
+            if (RILJ_LOGD) riljLog(" RIL_UNSOL_NITZ_TIME_RECEIVED length = "
+                    + nitz.split("[/:,+-]").length);
+
+            // remove the tailing information that samsung added to the string
+            if(nitz.split("[/:,+-]").length >= 9)
+                nitz = nitz.substring(0,(nitz.lastIndexOf(",")));
+
+            if (RILJ_LOGD) riljLog(" RIL_UNSOL_NITZ_TIME_RECEIVED striped nitz = "
+                    + nitz);
+
+            result[0] = nitz;
+            result[1] = Long.valueOf(nitzReceiveTime);
+
+            if (mNITZTimeRegistrant != null) {
+
+                mNITZTimeRegistrant
+                .notifyRegistrant(new AsyncResult (null, result, null));
+            } else {
+                // in case NITZ time registrant isnt registered yet
+                mLastNITZTimeInfo = nitz;
+            }
+            break;
+
+        case RIL_UNSOL_SIGNAL_STRENGTH:
+            // Note this is set to "verbose" because it happens
+            // frequently
+            if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+            if (mSignalStrengthRegistrant != null) {
+                mSignalStrengthRegistrant.notifyRegistrant(
+                                    new AsyncResult (null, ret, null));
+            }
+            break;
+
+        case RIL_UNSOL_CDMA_INFO_REC:
+            ArrayList<CdmaInformationRecords> listInfoRecs;
+
+            try {
+                listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+            } catch (ClassCastException e) {
+                Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+                break;
+            }
+
+            for (CdmaInformationRecords rec : listInfoRecs) {
+                if (RILJ_LOGD) unsljLogRet(response, rec);
+                notifyRegistrantsCdmaInfoRec(rec);
+            }
+            break;
+
+        case RIL_UNSOL_AM:
+            String amString = (String) ret;
+            Log.d(LOG_TAG, "Executing AM: " + amString);
+
+            try {
+                Runtime.getRuntime().exec("am " + amString);
+            } catch (IOException e) {
+                e.printStackTrace();
+                Log.e(LOG_TAG, "am " + amString + " could not be executed.");
+            }
+            break;
+        }
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        boolean isVideo;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+        int dataAvail = p.dataAvail();
+        int pos = p.dataPosition();
+        int size = p.dataSize();
+
+        Log.d(LOG_TAG, "Parcel size = " + size);
+        Log.d(LOG_TAG, "Parcel pos = " + pos);
+        Log.d(LOG_TAG, "Parcel dataAvail = " + dataAvail);
+
+        num = p.readInt();
+        response = new ArrayList<DriverCall>(num);
+
+        for (int i = 0 ; i < num ; i++) {
+            if (mIsSamsungCdma)
+                dc = new SamsungDriverCall();
+            else
+                dc = new DriverCall();
+
+            dc.state                = DriverCall.stateFromCLCC(p.readInt());
+            dc.index                = p.readInt();
+            dc.TOA                  = p.readInt();
+            dc.isMpty               = (0 != p.readInt());
+            dc.isMT                 = (0 != p.readInt());
+            dc.als                  = p.readInt();
+            dc.isVoice              = (0 != p.readInt());
+            isVideo                 = (0 != p.readInt());
+            dc.isVoicePrivacy       = (0 != p.readInt());
+            dc.number               = p.readString();
+            int np                  = p.readInt();
+            dc.numberPresentation   = DriverCall.presentationFromCLIP(np);
+            dc.name                 = p.readString();
+            dc.namePresentation     = p.readInt();
+            int uusInfoPresent      = p.readInt();
+
+            Log.d(LOG_TAG, "state = " + dc.state);
+            Log.d(LOG_TAG, "index = " + dc.index);
+            Log.d(LOG_TAG, "state = " + dc.TOA);
+            Log.d(LOG_TAG, "isMpty = " + dc.isMpty);
+            Log.d(LOG_TAG, "isMT = " + dc.isMT);
+            Log.d(LOG_TAG, "als = " + dc.als);
+            Log.d(LOG_TAG, "isVoice = " + dc.isVoice);
+            Log.d(LOG_TAG, "isVideo = " + isVideo);
+            Log.d(LOG_TAG, "number = " + dc.number);
+            Log.d(LOG_TAG, "numberPresentation = " + np);
+            Log.d(LOG_TAG, "name = " + dc.name);
+            Log.d(LOG_TAG, "namePresentation = " + dc.namePresentation);
+            Log.d(LOG_TAG, "uusInfoPresent = " + uusInfoPresent);
+
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                Log
+                .v(LOG_TAG, String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                        dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                        dc.uusInfo.getUserData().length));
+                Log.v(LOG_TAG, "Incoming UUS : data (string)="
+                        + new String(dc.uusInfo.getUserData()));
+                Log.v(LOG_TAG, "Incoming UUS : data (hex): "
+                        + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                Log.v(LOG_TAG, "Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+    }
+
+    protected Object
+    responseLastCallFailCause(Parcel p) {
+        int response[] = (int[])responseInts(p);
+
+        if (mIsSamsungCdma && response.length > 0 &&
+            response[0] == com.android.internal.telephony.cdma.CallFailCause.ERROR_UNSPECIFIED) {
+
+            // Far-end hangup returns ERROR_UNSPECIFIED, which shows "Call Lost" dialog.
+            Log.d(LOG_TAG, "Overriding ERROR_UNSPECIFIED fail cause with NORMAL_CLEARING.");
+            response[0] = com.android.internal.telephony.cdma.CallFailCause.NORMAL_CLEARING;
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+        response = new int[numInts];
+        for (int i = 0 ; i < 7 ; i++) {
+            response[i] = p.readInt();
+        }
+        // SamsungRIL is a v3 RIL, fill the rest with -1
+        for (int i = 7; i < numInts; i++) {
+            response[i] = -1;
+        }
+
+        if (mIsSamsungCdma){
+            if(response[3] < 0){
+               response[3] = -response[3];
+            }
+            // Framework takes care of the rest for us.
+            return response;
+         }
+        /* Matching Samsung signal strength to asu.
+		   Method taken from Samsungs cdma/gsmSignalStateTracker */
+        if(mSignalbarCount)
+        {
+            // Samsung sends the count of bars that should be displayed instead of
+            // a real signal strength
+            response[0] = ((response[0] & 0xFF00) >> 8) * 3; // gsmDbm
+        } else {
+            response[0] = response[0] & 0xFF; // gsmDbm
+        }
+        response[1] = -1; // gsmEcio
+        response[2] = (response[2] < 0)?-120:-response[2]; // cdmaDbm
+        response[3] = (response[3] < 0)?-160:-response[3]; // cdmaEcio
+        response[4] = (response[4] < 0)?-120:-response[4]; // evdoRssi
+        response[5] = (response[5] < 0)?-1:-response[5]; // evdoEcio
+        if(response[6] < 0 || response[6] > 8)
+            response[6] = -1;
+
+        return response;
+    }
+
+    protected Object
+    responseVoiceRegistrationState(Parcel p) {
+        String response[] = (String[])responseStrings(p);
+
+        if (mIsSamsungCdma && response.length > 6) {
+            // These values are provided in hex, convert to dec.
+            response[4] = Integer.toString(Integer.parseInt(response[4], 16)); // baseStationId
+            response[5] = Integer.toString(Integer.parseInt(response[5], 16)); // baseStationLatitude
+            response[6] = Integer.toString(Integer.parseInt(response[6], 16)); // baseStationLongitude
+        }
+
+        return response;
+    }
+
+    protected Object
+    responseNetworkType(Parcel p) {
+        int response[] = (int[]) responseInts(p);
+
+        // When the modem responds Phone.NT_MODE_GLOBAL, it means Phone.NT_MODE_WCDMA_PREF
+        if (!mIsSamsungCdma && response[0] == Phone.NT_MODE_GLOBAL) {
+            Log.d(LOG_TAG, "Overriding network type response from global to WCDMA preferred");
+            response[0] = Phone.NT_MODE_WCDMA_PREF;
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseSetupDataCall(Parcel p) {
+        DataCallState dataCall = new DataCallState();
+        String strings[] = (String []) responseStrings(p);
+
+        if (strings.length >= 2) {
+            dataCall.cid = Integer.parseInt(strings[0]);
+
+            if (mIsSamsungCdma) {
+                // We're responsible for starting/stopping the pppd_cdma service.
+                if (!startPppdCdmaService(strings[1])) {
+                    // pppd_cdma service didn't respond timely.
+                    dataCall.status = FailCause.ERROR_UNSPECIFIED.getErrorCode();
+                    return dataCall;
+                }
+
+                // pppd_cdma service responded, pull network parameters set by ip-up script.
+                dataCall.ifname = SystemProperties.get("net.cdma.ppp.interface");
+                String   ifprop = "net." + dataCall.ifname;
+
+                dataCall.addresses = new String[] {SystemProperties.get(ifprop + ".local-ip")};
+                dataCall.gateways  = new String[] {SystemProperties.get(ifprop + ".remote-ip")};
+                dataCall.dnses     = new String[] {SystemProperties.get(ifprop + ".dns1"),
+                                                   SystemProperties.get(ifprop + ".dns2")};
+            } else {
+                dataCall.ifname = strings[1];
+
+                if (strings.length >= 3) {
+                    dataCall.addresses = strings[2].split(" ");
+                }
+            }
+        } else {
+            if (mIsSamsungCdma) {
+                // On rare occasion the pppd_cdma service is left active from a stale
+                // session, causing the data call setup to fail.  Make sure that pppd_cdma
+                // is stopped now, so that the next setup attempt may succeed.
+                Log.d(LOG_TAG, "Set ril.cdma.data_state=0 to make sure pppd_cdma is stopped.");
+                SystemProperties.set("ril.cdma.data_state", "0");
+            }
+
+            dataCall.status = FailCause.ERROR_UNSPECIFIED.getErrorCode(); // Who knows?
+        }
+
+        return dataCall;
+    }
+
+    private boolean startPppdCdmaService(String ttyname) {
+        SystemProperties.set("net.cdma.datalinkinterface", ttyname);
+
+        // Connecting: Set ril.cdma.data_state=1 to (re)start pppd_cdma service,
+        // which responds by setting ril.cdma.data_state=2 once connection is up.
+        SystemProperties.set("ril.cdma.data_state", "1");
+        Log.d(LOG_TAG, "Set ril.cdma.data_state=1, waiting for ril.cdma.data_state=2.");
+
+        // Typically takes < 200 ms on my Epic, so sleep in 100 ms intervals.
+        for (int i = 0; i < 10; i++) {
+            try {Thread.sleep(100);} catch (InterruptedException e) {}
+
+            if (SystemProperties.getInt("ril.cdma.data_state", 1) == 2) {
+                Log.d(LOG_TAG, "Got ril.cdma.data_state=2, connected.");
+                return true;
+            }
+        }
+
+        // Taking > 1 s here, try up to 10 s, which is hopefully long enough.
+        for (int i = 1; i < 10; i++) {
+            try {Thread.sleep(1000);} catch (InterruptedException e) {}
+
+            if (SystemProperties.getInt("ril.cdma.data_state", 1) == 2) {
+                Log.d(LOG_TAG, "Got ril.cdma.data_state=2, connected.");
+                return true;
+            }
+        }
+
+        // Disconnect: Set ril.cdma.data_state=0 to stop pppd_cdma service.
+        Log.d(LOG_TAG, "Didn't get ril.cdma.data_state=2 timely, aborting.");
+        SystemProperties.set("ril.cdma.data_state", "0");
+
+        return false;
+    }
+
+    @Override
+    public void
+    deactivateDataCall(int cid, int reason, Message result) {
+        if (mIsSamsungCdma) {
+            // Disconnect: Set ril.cdma.data_state=0 to stop pppd_cdma service.
+            Log.d(LOG_TAG, "Set ril.cdma.data_state=0.");
+            SystemProperties.set("ril.cdma.data_state", "0");
+        }
+
+        super.deactivateDataCall(cid, reason, result);
+    }
+
+    protected Object
+    responseCdmaSubscription(Parcel p) {
+        String response[] = (String[])responseStrings(p);
+
+        if (/* mIsSamsungCdma && */ response.length == 4) {
+            // PRL version is missing in subscription parcel, add it from properties.
+            String prlVersion = SystemProperties.get("ril.prl_ver_1").split(":")[1];
+            response          = new String[] {response[0], response[1], response[2],
+                                              response[3], prlVersion};
+        }
+
+        return response;
+    }
+
+    // Workaround for Samsung CDMA "ring of death" bug:
+    //
+    // Symptom: As soon as the phone receives notice of an incoming call, an
+    //   audible "old fashioned ring" is emitted through the earpiece and
+    //   persists through the duration of the call, or until reboot if the call
+    //   isn't answered.
+    //
+    // Background: The CDMA telephony stack implements a number of "signal info
+    //   tones" that are locally generated by ToneGenerator and mixed into the
+    //   voice call path in response to radio RIL_UNSOL_CDMA_INFO_REC requests.
+    //   One of these tones, IS95_CONST_IR_SIG_IS54B_L, is requested by the
+    //   radio just prior to notice of an incoming call when the voice call
+    //   path is muted.  CallNotifier is responsible for stopping all signal
+    //   tones (by "playing" the TONE_CDMA_SIGNAL_OFF tone) upon receipt of a
+    //   "new ringing connection", prior to unmuting the voice call path.
+    //
+    // Problem: CallNotifier's incoming call path is designed to minimize
+    //   latency to notify users of incoming calls ASAP.  Thus,
+    //   SignalInfoTonePlayer requests are handled asynchronously by spawning a
+    //   one-shot thread for each.  Unfortunately the ToneGenerator API does
+    //   not provide a mechanism to specify an ordering on requests, and thus,
+    //   unexpected thread interleaving may result in ToneGenerator processing
+    //   them in the opposite order that CallNotifier intended.  In this case,
+    //   playing the "signal off" tone first, followed by playing the "old
+    //   fashioned ring" indefinitely.
+    //
+    // Solution: An API change to ToneGenerator is required to enable
+    //   SignalInfoTonePlayer to impose an ordering on requests (i.e., drop any
+    //   request that's older than the most recent observed).  Such a change,
+    //   or another appropriate fix should be implemented in AOSP first.
+    //
+    // Workaround: Intercept RIL_UNSOL_CDMA_INFO_REC requests from the radio,
+    //   check for a signal info record matching IS95_CONST_IR_SIG_IS54B_L, and
+    //   drop it so it's never seen by CallNotifier.  If other signal tones are
+    //   observed to cause this problem, they should be dropped here as well.
+    @Override
+    protected void
+    notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
+        final int response = RIL_UNSOL_CDMA_INFO_REC;
+
+        if (/* mIsSamsungCdma && */ infoRec.record instanceof CdmaSignalInfoRec) {
+            CdmaSignalInfoRec sir = (CdmaSignalInfoRec)infoRec.record;
+            if (sir != null && sir.isPresent &&
+                sir.signalType == SignalToneUtil.IS95_CONST_IR_SIGNAL_IS54B &&
+                sir.alertPitch == SignalToneUtil.IS95_CONST_IR_ALERT_MED    &&
+                sir.signal     == SignalToneUtil.IS95_CONST_IR_SIG_IS54B_L) {
+
+                Log.d(LOG_TAG, "Dropping \"" + responseToString(response) + " " +
+                      retToString(response, sir) + "\" to prevent \"ring of death\" bug.");
+                return;
+            }
+        }
+
+        super.notifyRegistrantsCdmaInfoRec(infoRec);
+    }
+
+    protected class SamsungDriverCall extends DriverCall {
+        @Override
+        public String
+        toString() {
+            // Samsung CDMA devices' call parcel is formatted differently
+            // fake unused data for video calls, and fix formatting
+            // so that voice calls' information can be correctly parsed
+            return "id=" + index + ","
+            + state + ","
+            + "toa=" + TOA + ","
+            + (isMpty ? "conf" : "norm") + ","
+            + (isMT ? "mt" : "mo") + ","
+            + "als=" + als + ","
+            + (isVoice ? "voc" : "nonvoc") + ","
+            + "nonvid" + ","
+            + number + ","
+            + "cli=" + numberPresentation + ","
+            + "name=" + name + ","
+            + namePresentation;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setCurrentPreferredNetworkType() {
+        if (RILJ_LOGD) riljLog("setCurrentPreferredNetworkType IGNORED");
+        /* Google added this as a fix for crespo loosing network type after
+         * taking an OTA. This messes up the data connection state for us
+         * due to the way we handle network type change (disable data
+         * then change then re-enable).
+         */
+    }
+
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+        /* Samsung modem implementation does bad things when a datacall is running
+         * while switching the preferred networktype.
+         */
+        ConnectivityManager cm =
+            (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        if(cm.getMobileDataEnabled())
+        {
+            ConnectivityHandler handler = new ConnectivityHandler(mContext);
+            handler.setPreferedNetworkType(networkType, response);
+        } else {
+            sendPreferedNetworktype(networkType, response);
+        }
+    }
+
+
+    //Sends the real RIL request to the modem.
+    private void sendPreferedNetworktype(int networkType, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(networkType);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " : " + networkType);
+
+        send(rr);
+    }
+    /* private class that does the handling for the dataconnection
+     * dataconnection is done async, so we send the request for disabling it,
+     * wait for the response, set the prefered networktype and notify the
+     * real sender with its result.
+     */
+    private class ConnectivityHandler extends Handler{
+
+        private static final int MESSAGE_SET_PREFERRED_NETWORK_TYPE = 30;
+        private Context mContext;
+        private int mDesiredNetworkType;
+        //the original message, we need it for calling back the original caller when done
+        private Message mNetworktypeResponse;
+        private ConnectivityBroadcastReceiver mConnectivityReceiver =  new ConnectivityBroadcastReceiver();
+
+        public ConnectivityHandler(Context context)
+        {
+            mContext = context;
+        }
+
+        private void startListening() {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+            mContext.registerReceiver(mConnectivityReceiver, filter);
+        }
+
+        private synchronized void stopListening() {
+            mContext.unregisterReceiver(mConnectivityReceiver);
+        }
+
+        public void setPreferedNetworkType(int networkType, Message response)
+        {
+            Log.d(LOG_TAG, "Mobile Dataconnection is online setting it down");
+            mDesiredNetworkType = networkType;
+            mNetworktypeResponse = response;
+            ConnectivityManager cm =
+                (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+            //start listening for the connectivity change broadcast
+            startListening();
+            cm.setMobileDataEnabled(false);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch(msg.what) {
+            //networktype was set, now we can enable the dataconnection again
+            case MESSAGE_SET_PREFERRED_NETWORK_TYPE:
+                ConnectivityManager cm =
+                    (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+                Log.d(LOG_TAG, "preferred NetworkType set upping Mobile Dataconnection");
+
+                cm.setMobileDataEnabled(true);
+                //everything done now call back that we have set the networktype
+                AsyncResult.forMessage(mNetworktypeResponse, null, null);
+                mNetworktypeResponse.sendToTarget();
+                mNetworktypeResponse = null;
+                break;
+            default:
+                throw new RuntimeException("unexpected event not handled");
+            }
+        }
+
+        private class ConnectivityBroadcastReceiver extends BroadcastReceiver {
+
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+                if (!action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
+                    Log.w(LOG_TAG, "onReceived() called with " + intent);
+                    return;
+                }
+                boolean noConnectivity =
+                    intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);
+
+                if (noConnectivity) {
+                    //Ok dataconnection is down, now set the networktype
+                    Log.w(LOG_TAG, "Mobile Dataconnection is now down setting preferred NetworkType");
+                    stopListening();
+                    sendPreferedNetworktype(mDesiredNetworkType, obtainMessage(MESSAGE_SET_PREFERRED_NETWORK_TYPE));
+                    mDesiredNetworkType = -1;
+                }
+            }
+        }
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/SemcRIL.java b/telephony/java/com/android/internal/telephony/SemcRIL.java
new file mode 100644
index 0000000..837f148
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SemcRIL.java
@@ -0,0 +1,454 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.*;
+import android.net.*;
+import android.os.*;
+import android.telephony.*;
+import android.text.TextUtils;
+import android.util.Log;
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import java.io.*;
+import java.util.*;
+
+/**
+ * Custom SEMC ril
+ *
+ * {@hide}
+ */
+public class SemcRIL extends RIL {
+    String mAid = "";
+    IccHandler mIccHandler;
+    HandlerThread mIccThread;
+
+    public SemcRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+        mIccHandler = null;
+    }
+
+    @Override
+    protected RadioState getRadioStateFromInt(int stateInt) {
+        RadioState state;
+
+        /* RIL_RadioState ril.h */
+        switch(stateInt) {
+            case 0: state = RadioState.RADIO_OFF; break;
+            case 1: state = RadioState.RADIO_UNAVAILABLE; break;
+            case 2: {
+                if (mIccHandler == null)
+                {
+                    mIccThread = new HandlerThread("IccHandler");
+                    mIccThread.start();
+                    mIccHandler = new IccHandler(this, mIccThread.getLooper());
+                }
+                mIccHandler.run();
+                state = mPhoneType == RILConstants.CDMA_PHONE ? RadioState.RUIM_NOT_READY : RadioState.SIM_NOT_READY;
+                break;
+            }
+            case 3: state = RadioState.SIM_LOCKED_OR_ABSENT; break;
+            case 4: state = RadioState.SIM_READY; break;
+            case 5: state = RadioState.RUIM_NOT_READY; break;
+            case 6: state = RadioState.RUIM_READY; break;
+            case 7: state = RadioState.RUIM_LOCKED_OR_ABSENT; break;
+            case 8: state = RadioState.NV_NOT_READY; break;
+            case 9: state = RadioState.NV_READY; break;
+
+            default:
+                throw new RuntimeException(
+                            "Unrecognized RIL_RadioState: " + stateInt);
+        }
+        return state;
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+        status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2           = ca.PinStateFromRILInt(p.readInt());
+            status.addApplication(ca);
+        }
+
+        updateIccType(status);
+        return status;
+    }
+
+    private void updateIccType (IccCardStatus status) {
+        if (status.getNumApplications() > 0)
+        {
+            int appType;
+            if (mPhoneType == RILConstants.CDMA_PHONE)
+            {
+                appType = status.getCdmaSubscriptionAppIndex();
+            } else {
+                appType = status.getGsmUmtsSubscriptionAppIndex();
+            }
+
+            IccCardApplication application = status.getApplication(appType);
+            mAid = application.aid;
+            Log.d(LOG_TAG, "Picked default AID: " + mAid);
+            SystemProperties.set("ril.icctype", Integer.toString(application.app_type.ordinal()));
+        }
+    }
+
+    @Override
+    protected DataCallState getDataCallState(Parcel p, int version) {
+        DataCallState dataCall = new DataCallState();
+
+        dataCall.version = version;
+        if (version < 5) {
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            String addresses = p.readString();
+            if (!TextUtils.isEmpty(addresses)) {
+                dataCall.addresses = addresses.split(" ");
+            }
+            // DataCallState needs an ifname. Since we don't have one use the name from the ThrottleService resource (default=rmnet0).
+            dataCall.ifname = "rmnet0";
+        } else {
+            dataCall.status = p.readInt();
+	          dataCall.suggestedRetryTime = p.readInt();
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            dataCall.ifname = p.readString();
+            if ((dataCall.status == DataConnection.FailCause.NONE.getErrorCode()) &&
+                    TextUtils.isEmpty(dataCall.ifname)) {
+              throw new RuntimeException("getDataCallState, no ifname");
+            }
+            String addresses = p.readString();
+            if (!TextUtils.isEmpty(addresses)) {
+                dataCall.addresses = addresses.split(" ");
+            }
+            String dnses = p.readString();
+            if (!TextUtils.isEmpty(dnses)) {
+                dataCall.dnses = dnses.split(" ");
+            }
+            String gateways = p.readString();
+            if (!TextUtils.isEmpty(gateways)) {
+                dataCall.gateways = gateways.split(" ");
+            }
+        }
+        return dataCall;
+    }
+
+
+    @Override public void
+    supplyIccPin(String pin, Message result) {
+        supplyIccPinForApp(pin, mAid, result);
+    }
+
+    @Override public void
+    changeIccPin(String oldPin, String newPin, Message result) {
+        changeIccPinForApp(oldPin, newPin, mAid, result);
+    }
+
+    @Override public void
+    supplyIccPin2(String pin, Message result) {
+        supplyIccPin2ForApp(pin, mAid, result);
+    }
+
+    @Override public void
+    changeIccPin2(String oldPin2, String newPin2, Message result) {
+        changeIccPin2ForApp(oldPin2, newPin2, mAid, result);
+    }
+
+    @Override public void
+    supplyIccPuk(String puk, String newPin, Message result) {
+        supplyIccPukForApp(puk, newPin, mAid, result);
+    }
+
+    @Override public void
+    supplyIccPuk2(String puk2, String newPin2, Message result) {
+        supplyIccPuk2ForApp(puk2, newPin2, mAid, result);
+    }
+
+    @Override
+    public void
+    queryFacilityLock(String facility, String password, int serviceClass,
+                            Message response) {
+        queryFacilityLockForApp(facility, password, serviceClass, mAid, response);
+    }
+
+    @Override
+    public void
+    setFacilityLock (String facility, boolean lockState, String password,
+                        int serviceClass, Message response) {
+        setFacilityLockForApp(facility, lockState, password, serviceClass, mAid, response);
+    }
+
+    @Override
+    public void
+    iccIO (int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_IO, result);
+
+        rr.mp.writeInt(command);
+        rr.mp.writeInt(fileid);
+        rr.mp.writeString(path);
+        rr.mp.writeInt(p1);
+        rr.mp.writeInt(p2);
+        rr.mp.writeInt(p3);
+        rr.mp.writeString(data);
+        rr.mp.writeString(pin2);
+        rr.mp.writeString(mAid);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccIO: " + requestToString(rr.mRequest)
+                + " 0x" + Integer.toHexString(command)
+                + " 0x" + Integer.toHexString(fileid) + " "
+                + " path: " + path + ","
+                + p1 + "," + p2 + "," + p3);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+        rr.mp.writeString(mAid);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeAutomatic(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeInt(-1);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric);
+
+        rr.mp.writeString(operatorNumeric);
+        rr.mp.writeInt(-1);
+
+        send(rr);
+    }
+
+    @Override
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 4);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            ret.add (
+                new OperatorInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+        return ret;
+    }
+
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+
+        rr.mp.writeString(address);
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mp.writeInt(0); // UUS information is absent
+        } else {
+            rr.mp.writeInt(1); // UUS information is present
+            rr.mp.writeInt(uusInfo.getType());
+            rr.mp.writeInt(uusInfo.getDcs());
+            rr.mp.writeByteArray(uusInfo.getUserData());
+        }
+        rr.mp.writeInt(255);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    class IccHandler extends Handler implements Runnable {
+        private static final int EVENT_RADIO_ON = 1;
+        private static final int EVENT_ICC_STATUS_CHANGED = 2;
+        private static final int EVENT_GET_ICC_STATUS_DONE = 3;
+        private static final int EVENT_RADIO_OFF_OR_UNAVAILABLE = 4;
+
+        private RIL mRil;
+        private boolean mRadioOn = false;
+
+        public IccHandler (RIL ril, Looper looper) {
+            super (looper);
+            mRil = ril;
+        }
+
+        public void handleMessage (Message paramMessage) {
+            switch (paramMessage.what) {
+                case EVENT_RADIO_ON:
+                    mRadioOn = true;
+                    Log.d(LOG_TAG, "Radio on -> Forcing sim status update");
+                    sendMessage(obtainMessage(EVENT_ICC_STATUS_CHANGED));
+                    break;
+                case EVENT_GET_ICC_STATUS_DONE:
+                    AsyncResult asyncResult = (AsyncResult) paramMessage.obj;
+                    if (asyncResult.exception != null) {
+                        Log.e (LOG_TAG, "IccCardStatusDone shouldn't return exceptions!", asyncResult.exception);
+                        break;
+                    }
+                    IccCardStatus status = (IccCardStatus) asyncResult.result;
+                    if (status.getNumApplications() == 0) {
+                        if (!mRil.getRadioState().isOn()) {
+                            break;
+                        }
+
+                        if (mPhoneType == RILConstants.CDMA_PHONE) {
+                            mRil.setRadioState(CommandsInterface.RadioState.RUIM_LOCKED_OR_ABSENT);
+                        } else {
+                            mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                        }
+                    } else {
+                        int appIndex = -1;
+                        if (mPhoneType == RILConstants.CDMA_PHONE) {
+                            appIndex = status.getCdmaSubscriptionAppIndex();
+                            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+                        } else {
+                            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+                            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+                        }
+
+                        IccCardApplication application = status.getApplication(appIndex);
+                        IccCardApplication.AppState app_state = application.app_state;
+                        IccCardApplication.AppType app_type = application.app_type;
+
+                        switch (app_state) {
+                            case APPSTATE_PIN:
+                            case APPSTATE_PUK:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            case APPSTATE_READY:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_READY);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_READY);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            default:
+                                return;
+                        }
+                    }
+                    break;
+                case EVENT_ICC_STATUS_CHANGED:
+                    if (mRadioOn) {
+                        Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
+                         mRil.getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, paramMessage.obj));
+                    } else {
+                         Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED while radio is not ON. Ignoring");
+                    }
+                    break;
+                case EVENT_RADIO_OFF_OR_UNAVAILABLE:
+                    mRadioOn = false;
+                    // disposeCards(); // to be verified;
+                default:
+                    Log.e(LOG_TAG, " Unknown Event " + paramMessage.what);
+                    break;
+            }
+        }
+
+        public void run () {
+            mRil.registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, null);
+            Message msg = obtainMessage(EVENT_RADIO_ON);
+            mRil.getIccCardStatus(msg);
+        }
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/SimRegionCache.java b/telephony/java/com/android/internal/telephony/SimRegionCache.java
new file mode 100644
index 0000000..2cf6d25
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SimRegionCache.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.os.SystemProperties;
+
+public class SimRegionCache {
+    public static final int MCC_UNSET  = Integer.MIN_VALUE;
+    public static final int MCC_KOREAN = 450;
+
+    private static int regionFromMcc = MCC_UNSET;
+
+    /**
+     * Returns the region as read from the MCC of the SIM card.
+     * If the property {@link TelephonyProperties#
+     * PROPERTY_ICC_OPERATOR_NUMERIC}
+     * returns null or an empty String, the value is {@link #MCC_UNSET}
+     *
+     * @return the cached region, if set.
+     */
+    public static int getRegion() {
+        if (regionFromMcc == MCC_UNSET) {
+            String plmn = SystemProperties.get(
+                    TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC,
+                    null);
+
+            if (plmn != null && plmn.length() >= 3) {
+                try {
+                    regionFromMcc = Integer.parseInt(plmn.substring(0, 3));
+                } catch(Exception e) {
+                    // Nothing that can be done here.
+                }
+            }
+        }
+        return regionFromMcc;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/Smdk4210RIL.java b/telephony/java/com/android/internal/telephony/Smdk4210RIL.java
new file mode 100644
index 0000000..b385627
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/Smdk4210RIL.java
@@ -0,0 +1,808 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_EDGE;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_GPRS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.media.AudioManager;
+import android.net.ConnectivityManager;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.net.NetworkInfo;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.os.PowerManager.WakeLock;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.Runtime;
+import java.util.ArrayList;
+import java.util.Collections;
+
+public class Smdk4210RIL extends RIL implements CommandsInterface {
+
+    //SAMSUNG STATES
+    static final int RIL_REQUEST_GET_CELL_BROADCAST_CONFIG = 10002;
+
+    static final int RIL_REQUEST_SEND_ENCODED_USSD = 10005;
+    static final int RIL_REQUEST_SET_PDA_MEMORY_STATUS = 10006;
+    static final int RIL_REQUEST_GET_PHONEBOOK_STORAGE_INFO = 10007;
+    static final int RIL_REQUEST_GET_PHONEBOOK_ENTRY = 10008;
+    static final int RIL_REQUEST_ACCESS_PHONEBOOK_ENTRY = 10009;
+    static final int RIL_REQUEST_DIAL_VIDEO_CALL = 10010;
+    static final int RIL_REQUEST_CALL_DEFLECTION = 10011;
+    static final int RIL_REQUEST_READ_SMS_FROM_SIM = 10012;
+    static final int RIL_REQUEST_USIM_PB_CAPA = 10013;
+    static final int RIL_REQUEST_LOCK_INFO = 10014;
+
+    static final int RIL_REQUEST_DIAL_EMERGENCY = 10016;
+    static final int RIL_REQUEST_GET_STOREAD_MSG_COUNT = 10017;
+    static final int RIL_REQUEST_STK_SIM_INIT_EVENT = 10018;
+    static final int RIL_REQUEST_GET_LINE_ID = 10019;
+    static final int RIL_REQUEST_SET_LINE_ID = 10020;
+    static final int RIL_REQUEST_GET_SERIAL_NUMBER = 10021;
+    static final int RIL_REQUEST_GET_MANUFACTURE_DATE_NUMBER = 10022;
+    static final int RIL_REQUEST_GET_BARCODE_NUMBER = 10023;
+    static final int RIL_REQUEST_UICC_GBA_AUTHENTICATE_BOOTSTRAP = 10024;
+    static final int RIL_REQUEST_UICC_GBA_AUTHENTICATE_NAF = 10025;
+    static final int RIL_REQUEST_SIM_TRANSMIT_BASIC = 10026;
+    static final int RIL_REQUEST_SIM_OPEN_CHANNEL = 10027;
+    static final int RIL_REQUEST_SIM_CLOSE_CHANNEL = 10028;
+    static final int RIL_REQUEST_SIM_TRANSMIT_CHANNEL = 10029;
+    static final int RIL_REQUEST_SIM_AUTH = 10030;
+    static final int RIL_REQUEST_PS_ATTACH = 10031;
+    static final int RIL_REQUEST_PS_DETACH = 10032;
+    static final int RIL_REQUEST_ACTIVATE_DATA_CALL = 10033;
+    static final int RIL_REQUEST_CHANGE_SIM_PERSO = 10034;
+    static final int RIL_REQUEST_ENTER_SIM_PERSO = 10035;
+    static final int RIL_REQUEST_GET_TIME_INFO = 10036;
+    static final int RIL_REQUEST_OMADM_SETUP_SESSION = 10037;
+    static final int RIL_REQUEST_OMADM_SERVER_START_SESSION = 10038;
+    static final int RIL_REQUEST_OMADM_CLIENT_START_SESSION = 10039;
+    static final int RIL_REQUEST_OMADM_SEND_DATA = 10040;
+    static final int RIL_REQUEST_CDMA_GET_DATAPROFILE = 10041;
+    static final int RIL_REQUEST_CDMA_SET_DATAPROFILE = 10042;
+    static final int RIL_REQUEST_CDMA_GET_SYSTEMPROPERTIES = 10043;
+    static final int RIL_REQUEST_CDMA_SET_SYSTEMPROPERTIES = 10044;
+    static final int RIL_REQUEST_SEND_SMS_COUNT = 10045;
+    static final int RIL_REQUEST_SEND_SMS_MSG = 10046;
+    static final int RIL_REQUEST_SEND_SMS_MSG_READ_STATUS = 10047;
+    static final int RIL_REQUEST_MODEM_HANGUP = 10048;
+    static final int RIL_REQUEST_SET_SIM_POWER = 10049;
+    static final int RIL_REQUEST_SET_PREFERRED_NETWORK_LIST = 10050;
+    static final int RIL_REQUEST_GET_PREFERRED_NETWORK_LIST = 10051;
+    static final int RIL_REQUEST_HANGUP_VT = 10052;
+
+    static final int RIL_UNSOL_RELEASE_COMPLETE_MESSAGE = 11001;
+    //static final int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002;
+    static final int RIL_UNSOL_STK_CALL_CONTROL_RESULT = 11003;
+    static final int RIL_UNSOL_DUN_CALL_STATUS = 11004;
+
+    static final int RIL_UNSOL_O2_HOME_ZONE_INFO = 11007;
+    static final int RIL_UNSOL_DEVICE_READY_NOTI = 11008;
+    static final int RIL_UNSOL_GPS_NOTI = 11009;
+    static final int RIL_UNSOL_AM = 11010;
+    static final int RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL = 11011;
+    static final int RIL_UNSOL_DATA_SUSPEND_RESUME = 11012;
+    static final int RIL_UNSOL_SAP = 11013;
+
+    static final int RIL_UNSOL_SIM_SMS_STORAGE_AVAILALE = 11015;
+    static final int RIL_UNSOL_HSDPA_STATE_CHANGED = 11016;
+    static final int RIL_UNSOL_WB_AMR_STATE = 11017;
+    static final int RIL_UNSOL_TWO_MIC_STATE = 11018;
+    static final int RIL_UNSOL_DHA_STATE = 11019;
+    static final int RIL_UNSOL_UART = 11020;
+    static final int RIL_UNSOL_RESPONSE_HANDOVER = 11021;
+    static final int RIL_UNSOL_IPV6_ADDR = 11022;
+    static final int RIL_UNSOL_NWK_INIT_DISC_REQUEST = 11023;
+    static final int RIL_UNSOL_RTS_INDICATION = 11024;
+    static final int RIL_UNSOL_OMADM_SEND_DATA = 11025;
+    static final int RIL_UNSOL_DUN = 11026;
+    static final int RIL_UNSOL_SYSTEM_REBOOT = 11027;
+    static final int RIL_UNSOL_VOICE_PRIVACY_CHANGED = 11028;
+    static final int RIL_UNSOL_UTS_GETSMSCOUNT = 11029;
+    static final int RIL_UNSOL_UTS_GETSMSMSG = 11030;
+    static final int RIL_UNSOL_UTS_GET_UNREAD_SMS_STATUS = 11031;
+    static final int RIL_UNSOL_MIP_CONNECT_STATUS = 11032;
+
+    protected HandlerThread mSmdk4210Thread;
+    protected ConnectivityHandler mSmdk4210Handler;
+    private AudioManager audioManager;
+
+    public Smdk4210RIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+        audioManager = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
+    }
+
+    @Override
+    public void setCurrentPreferredNetworkType() {
+        if (RILJ_LOGD) riljLog("setCurrentPreferredNetworkType IGNORED");
+        /* Google added this as a fix for crespo loosing network type after
+         * taking an OTA. This messes up the data connection state for us
+         * due to the way we handle network type change (disable data
+         * then change then re-enable).
+         */
+    }
+
+    private boolean NeedReconnect()
+    {
+        ConnectivityManager cm =
+            (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo ni_active = cm.getActiveNetworkInfo();
+
+        return ni_active != null && ni_active.getTypeName().equalsIgnoreCase( "mobile" ) &&
+                ni_active.isConnected() && cm.getMobileDataEnabled();
+    }
+
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+        /* Samsung modem implementation does bad things when a datacall is running
+         * while switching the preferred networktype.
+         */
+        HandlerThread handlerThread;
+        Looper looper;
+
+        if(NeedReconnect())
+        {
+            if (mSmdk4210Handler == null) {
+
+                handlerThread = new HandlerThread("mSmdk4210Thread");
+                mSmdk4210Thread = handlerThread;
+
+                mSmdk4210Thread.start();
+
+                looper = mSmdk4210Thread.getLooper();
+                mSmdk4210Handler = new ConnectivityHandler(mContext, looper);
+            }
+            mSmdk4210Handler.setPreferedNetworkType(networkType, response);
+        } else {
+            if (mSmdk4210Handler != null) {
+                mSmdk4210Thread = null;
+                mSmdk4210Handler = null;
+            }
+            sendPreferedNetworktype(networkType, response);
+        }
+
+    }
+
+    //Sends the real RIL request to the modem.
+    private void sendPreferedNetworktype(int networkType, Message response) {
+        RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(networkType);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " : " + networkType);
+
+        send(rr);
+    }
+
+    /* private class that does the handling for the dataconnection
+     * dataconnection is done async, so we send the request for disabling it,
+     * wait for the response, set the prefered networktype and notify the
+     * real sender with its result.
+     */
+    private class ConnectivityHandler extends Handler{
+
+        private static final int MESSAGE_SET_PREFERRED_NETWORK_TYPE = 30;
+        private Context mContext;
+        private int mDesiredNetworkType;
+        //the original message, we need it for calling back the original caller when done
+        private Message mNetworktypeResponse;
+        private ConnectivityBroadcastReceiver mConnectivityReceiver =  new ConnectivityBroadcastReceiver();
+
+        public ConnectivityHandler(Context context, Looper looper)
+        {
+            super (looper);
+            mContext = context;
+        }
+
+        private void startListening() {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+            mContext.registerReceiver(mConnectivityReceiver, filter);
+        }
+
+        private synchronized void stopListening() {
+            mContext.unregisterReceiver(mConnectivityReceiver);
+        }
+
+        public void setPreferedNetworkType(int networkType, Message response)
+        {
+            Log.d(LOG_TAG, "Mobile Dataconnection is online setting it down");
+            mDesiredNetworkType = networkType;
+            mNetworktypeResponse = response;
+            ConnectivityManager cm =
+                (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+            //start listening for the connectivity change broadcast
+            startListening();
+            cm.setMobileDataEnabled(false);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch(msg.what) {
+            //networktype was set, now we can enable the dataconnection again
+            case MESSAGE_SET_PREFERRED_NETWORK_TYPE:
+                ConnectivityManager cm =
+                    (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+                Log.d(LOG_TAG, "preferred NetworkType set upping Mobile Dataconnection");
+                cm.setMobileDataEnabled(true);
+                //everything done now call back that we have set the networktype
+                AsyncResult.forMessage(mNetworktypeResponse, null, null);
+                mNetworktypeResponse.sendToTarget();
+                mNetworktypeResponse = null;
+                break;
+            default:
+                throw new RuntimeException("unexpected event not handled");
+            }
+        }
+
+        private class ConnectivityBroadcastReceiver extends BroadcastReceiver {
+
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+                if (!action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
+                    Log.w(LOG_TAG, "onReceived() called with " + intent);
+                    return;
+                }
+                boolean noConnectivity =
+                    intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);
+
+                if (noConnectivity) {
+                    //Ok dataconnection is down, now set the networktype
+                    Log.w(LOG_TAG, "Mobile Dataconnection is now down setting preferred NetworkType");
+                    stopListening();
+                    sendPreferedNetworktype(mDesiredNetworkType, obtainMessage(MESSAGE_SET_PREFERRED_NETWORK_TYPE));
+                    mDesiredNetworkType = -1;
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void processSolicited (Parcel p) {
+    int serial, error;
+    boolean found = false;
+
+    serial = p.readInt();
+    error = p.readInt();
+
+    RILRequest rr;
+
+    rr = findAndRemoveRequestFromList(serial);
+
+    if (rr == null) {
+        Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                        + serial + " error: " + error);
+            return;
+    }
+
+    Object ret = null;
+
+    if (error == 0 || p.dataAvail() > 0) {
+        // either command succeeds or command fails but with data payload
+        try {switch (rr.mRequest) {
+
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseSetupDataCall(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseOperatorInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseGetPreferredNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseVoid(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_ISIM_AUTHENTICATION: ret =  responseString(p); break;
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+                //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            //ugly fix for Samsung messing up SMS_SEND request fail in binary RIL
+            if(!(error == -1 && rr.mRequest == RIL_REQUEST_SEND_SMS))
+            {
+                rr.onError(error, ret);
+                rr.release();
+                return;
+            } else {
+                try
+                {
+                    ret =  responseSMS(p);
+                } catch (Throwable tr) {
+                    Log.w(LOG_TAG, rr.serialString() + "< "
+                            + requestToString(rr.mRequest)
+                            + " exception, Processing Samsung SMS fix ", tr);
+                    rr.onError(error, ret);
+                    rr.release();
+                    return;
+                }
+            }
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        Object ret;
+        int dataPosition = p.dataPosition();
+        int response = p.readInt();
+
+        switch (response) {
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: ret = responseString(p); break;
+            case RIL_UNSOL_RIL_CONNECTED: ret = responseInts(p); break;
+            // SAMSUNG STATES
+            case RIL_UNSOL_AM: ret = responseString(p); break;
+            case RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL: ret = responseVoid(p); break;
+            case RIL_UNSOL_DATA_SUSPEND_RESUME: ret = responseInts(p); break;
+            case RIL_UNSOL_STK_CALL_CONTROL_RESULT: ret = responseVoid(p); break;
+            case RIL_UNSOL_TWO_MIC_STATE: ret = responseInts(p); break;
+            case RIL_UNSOL_WB_AMR_STATE: ret = responseInts(p); break;
+
+            default:
+                // Rewind the Parcel
+                p.setDataPosition(dataPosition);
+
+                // Forward responses that we are not overriding to the super class
+                super.processUnsolicited(p);
+                return;
+        }
+
+        switch (response) {
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mGsmBroadcastSmsRegistrant != null) {
+                    mGsmBroadcastSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+            case RIL_UNSOL_RIL_CONNECTED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // Initial conditions
+                setRadioPower(false, null);
+                sendPreferedNetworktype(mPreferredNetworkType, null);
+                setCdmaSubscriptionSource(mCdmaSubscription, null);
+                notifyRegistrantsRilConnectionChanged(((int[])ret)[0]);
+                break;
+            // SAMSUNG STATES
+            case RIL_UNSOL_AM:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                String amString = (String) ret;
+                Log.d(LOG_TAG, "Executing AM: " + amString);
+
+                try {
+                    Runtime.getRuntime().exec("am " + amString);
+                } catch (IOException e) {
+                    e.printStackTrace();
+                    Log.e(LOG_TAG, "am " + amString + " could not be executed.");
+                }
+                break;
+            case RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                break;
+            case RIL_UNSOL_DATA_SUSPEND_RESUME:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                break;
+            case RIL_UNSOL_STK_CALL_CONTROL_RESULT:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                break;
+            case RIL_UNSOL_TWO_MIC_STATE:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                break;
+            case RIL_UNSOL_WB_AMR_STATE:
+                if (RILJ_LOGD) samsungUnsljLogRet(response, ret);
+                setWbAmr(((int[])ret)[0]);
+                break;
+        }
+    }
+
+    static String
+    samsungResponseToString(int request)
+    {
+        switch(request) {
+            // SAMSUNG STATES
+            case RIL_UNSOL_AM: return "RIL_UNSOL_AM";
+            case RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL: return "RIL_UNSOL_DUN_PIN_CONTROL_SIGNAL";
+            case RIL_UNSOL_DATA_SUSPEND_RESUME: return "RIL_UNSOL_DATA_SUSPEND_RESUME";
+            case RIL_UNSOL_STK_CALL_CONTROL_RESULT: return "RIL_UNSOL_STK_CALL_CONTROL_RESULT";
+            case RIL_UNSOL_TWO_MIC_STATE: return "RIL_UNSOL_TWO_MIC_STATE";
+            case RIL_UNSOL_WB_AMR_STATE: return "RIL_UNSOL_WB_AMR_STATE";
+            default: return "<unknown response: "+request+">";
+        }
+    }
+
+    protected void samsungUnsljLog(int response) {
+        riljLog("[UNSL]< " + samsungResponseToString(response));
+    }
+
+    protected void samsungUnsljLogMore(int response, String more) {
+        riljLog("[UNSL]< " + samsungResponseToString(response) + " " + more);
+    }
+
+    protected void samsungUnsljLogRet(int response, Object ret) {
+        riljLog("[UNSL]< " + samsungResponseToString(response) + " " + retToString(response, ret));
+    }
+
+    protected void samsungUnsljLogvRet(int response, Object ret) {
+        riljLogv("[UNSL]< " + samsungResponseToString(response) + " " + retToString(response, ret));
+    }
+
+    /**
+     * Notifiy all registrants that the ril has connected or disconnected.
+     *
+     * @param rilVer is the version of the ril or -1 if disconnected.
+     */
+    private void notifyRegistrantsRilConnectionChanged(int rilVer) {
+        mRilVersion = rilVer;
+        if (mRilConnectedRegistrants != null) {
+            mRilConnectedRegistrants.notifyRegistrants(
+                                new AsyncResult (null, new Integer(rilVer), null));
+        }
+    }
+
+    /**
+     * Set audio parameter "wb_amr" for HD-Voice (Wideband AMR).
+     *
+     * @param state: 0 = unsupported, 1 = supported.
+     */
+    private void setWbAmr(int state) {
+        if (state == 1) {
+            Log.d(LOG_TAG, "setWbAmr(): setting audio parameter - wb_amr=on");
+            audioManager.setParameters("wb_amr=on");
+        } else {
+            Log.d(LOG_TAG, "setWbAmr(): setting audio parameter - wb_amr=off");
+            audioManager.setParameters("wb_amr=off");
+        }
+    }
+
+    @Override
+    protected Object
+    responseCallList(Parcel p) {
+        int num;
+        boolean isVideo;
+        ArrayList<DriverCall> response;
+        DriverCall dc;
+        int dataAvail = p.dataAvail();
+        int pos = p.dataPosition();
+        int size = p.dataSize();
+
+        Log.d(LOG_TAG, "Parcel size = " + size);
+        Log.d(LOG_TAG, "Parcel pos = " + pos);
+        Log.d(LOG_TAG, "Parcel dataAvail = " + dataAvail);
+
+        //Samsung changes
+        num = p.readInt();
+
+        Log.d(LOG_TAG, "num = " + num);
+        response = new ArrayList<DriverCall>(num);
+
+        for (int i = 0 ; i < num ; i++) {
+
+            dc                      = new DriverCall();
+            dc.state                = DriverCall.stateFromCLCC(p.readInt());
+            dc.index                = p.readInt();
+            dc.TOA                  = p.readInt();
+            dc.isMpty               = (0 != p.readInt());
+            dc.isMT                 = (0 != p.readInt());
+            dc.als                  = p.readInt();
+            dc.isVoice              = (0 != p.readInt());
+            isVideo                 = (0 != p.readInt());
+            dc.isVoicePrivacy       = (0 != p.readInt());
+            dc.number               = p.readString();
+            int np                  = p.readInt();
+            dc.numberPresentation   = DriverCall.presentationFromCLIP(np);
+            dc.name                 = p.readString();
+            dc.namePresentation     = p.readInt();
+            int uusInfoPresent      = p.readInt();
+
+            Log.d(LOG_TAG, "state = " + dc.state);
+            Log.d(LOG_TAG, "index = " + dc.index);
+            Log.d(LOG_TAG, "state = " + dc.TOA);
+            Log.d(LOG_TAG, "isMpty = " + dc.isMpty);
+            Log.d(LOG_TAG, "isMT = " + dc.isMT);
+            Log.d(LOG_TAG, "als = " + dc.als);
+            Log.d(LOG_TAG, "isVoice = " + dc.isVoice);
+            Log.d(LOG_TAG, "isVideo = " + isVideo);
+            Log.d(LOG_TAG, "number = " + dc.number);
+            Log.d(LOG_TAG, "np = " + np);
+            Log.d(LOG_TAG, "name = " + dc.name);
+            Log.d(LOG_TAG, "namePresentation = " + dc.namePresentation);
+            Log.d(LOG_TAG, "uusInfoPresent = " + uusInfoPresent);
+
+            if (uusInfoPresent == 1) {
+                dc.uusInfo = new UUSInfo();
+                dc.uusInfo.setType(p.readInt());
+                dc.uusInfo.setDcs(p.readInt());
+                byte[] userData = p.createByteArray();
+                dc.uusInfo.setUserData(userData);
+                Log
+                .v(LOG_TAG, String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+                        dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+                        dc.uusInfo.getUserData().length));
+                Log.v(LOG_TAG, "Incoming UUS : data (string)="
+                        + new String(dc.uusInfo.getUserData()));
+                Log.v(LOG_TAG, "Incoming UUS : data (hex): "
+                        + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+            } else {
+                Log.v(LOG_TAG, "Incoming UUS : NOT present!");
+            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+    }
+
+    @Override
+    protected Object responseGetPreferredNetworkType(Parcel p) {
+        int [] response = (int[]) responseInts(p);
+
+        if (response.length >= 1) {
+            // Since this is the response for getPreferredNetworkType
+            // we'll assume that it should be the value we want the
+            // vendor ril to take if we reestablish a connection to it.
+            mPreferredNetworkType = response[0];
+        }
+
+        // When the modem responds Phone.NT_MODE_GLOBAL, it means Phone.NT_MODE_WCDMA_PREF
+        if (response[0] == Phone.NT_MODE_GLOBAL) {
+            Log.d(LOG_TAG, "Overriding network type response from GLOBAL to WCDMA preferred");
+            response[0] = Phone.NT_MODE_WCDMA_PREF;
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseOperatorInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<OperatorInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<OperatorInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            ret.add (
+                new OperatorInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+
+    @Override
+    protected Object
+    responseSignalStrength(Parcel p) {
+        int numInts = 12;
+        int response[];
+
+        // Get raw data
+        response = new int[numInts];
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+        }
+
+        Log.d(LOG_TAG, "responseSignalStength BEFORE: gsmDbm=" + response[0]);
+
+        //Samsung sends the count of bars that should be displayed instead of
+        //a real signal strength
+        int num_bars = (response[0] & 0xff00) >> 8;
+
+        // Translate number of bars into something SignalStrength.java can understand
+        switch (num_bars) {
+            case 0  : response[0] = 1;     break; // map to 0 bars
+            case 1  : response[0] = 3;     break; // map to 1 bar
+            case 2  : response[0] = 5;     break; // map to 2 bars
+            case 3  : response[0] = 8;     break; // map to 3 bars
+            case 4  : response[0] = 12;    break; // map to 4 bars
+            case 5  : response[0] = 15;    break; // map to 4 bars but give an extra 10 dBm
+            default : response[0] &= 0xff; break; // no idea; just pass value through
+        }
+
+        response[1] = -1; //gsmEcio
+        response[2] = (response[2] < 0)?-120:-response[2]; //cdmaDbm
+        response[3] = (response[3] < 0)?-160:-response[3]; //cdmaEcio
+        response[4] = (response[4] < 0)?-120:-response[4]; //evdoRssi
+        response[5] = (response[5] < 0)?-1:-response[5]; //evdoEcio
+        if (response[6] < 0 || response[6] > 8) {
+            response[6] = -1;
+        }
+
+        Log.d(LOG_TAG, "responseSignalStength AFTER: gsmDbm=" + response[0]);
+
+        return response;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/SonyQualcommRIL.java b/telephony/java/com/android/internal/telephony/SonyQualcommRIL.java
new file mode 100644
index 0000000..5fea45b
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SonyQualcommRIL.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Message;
+import android.os.Parcel;
+import android.text.TextUtils;
+import android.util.Log;
+
+/*
+ * Qualcomm RIL class for basebands that do not send the SIM status
+ * piggybacked in RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED. Instead,
+ * these radios will send radio state and we have to query for SIM
+ * status separately.
+ * Custom Qualcomm No SimReady RIL for Sony
+ *
+ * {@hide}
+ */
+
+public class SonyQualcommRIL extends QualcommSharedRIL implements CommandsInterface {
+    boolean RILJ_LOGV = true;
+    boolean RILJ_LOGD = true;
+
+    public SonyQualcommRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+        status.setImsSubscriptionAppIndex(p.readInt());
+
+        int numApplications = p.readInt();
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = ca.PinStateFromRILInt(p.readInt());
+            ca.pin2           = ca.PinStateFromRILInt(p.readInt());
+            status.addApplication(ca);
+        }
+
+        updateIccType(status);
+        return status;
+    }
+
+    private void updateIccType (IccCardStatus status) {
+        int appType;
+        if (status.getNumApplications() > 0) {
+            if (mPhoneType == RILConstants.CDMA_PHONE)
+                appType = status.getCdmaSubscriptionAppIndex();
+            else
+                appType = status.getGsmUmtsSubscriptionAppIndex();
+
+            IccCardApplication application = status.getApplication(appType);
+            mUSIM = application.app_type
+                      == IccCardApplication.AppType.APPTYPE_USIM;
+            mSetPreferredNetworkType = mPreferredNetworkType;
+            mAid = application.aid;
+            if (TextUtils.isEmpty(mAid))
+               mAid = "";
+            Log.d(LOG_TAG, "Picked default AID: " + mAid);
+        }
+    }
+
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+
+        rr.mp.writeString(address);
+        rr.mp.writeInt(clirMode);
+
+        if (uusInfo == null) {
+            rr.mp.writeInt(0); // UUS information is absent
+        } else {
+            rr.mp.writeInt(1); // UUS information is present
+            rr.mp.writeInt(uusInfo.getType());
+            rr.mp.writeInt(uusInfo.getDcs());
+            rr.mp.writeByteArray(uusInfo.getUserData());
+        }
+        rr.mp.writeInt(255);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    setNetworkSelectionMode(String operatorNumeric, Message response) {
+        RILRequest rr;
+
+        if (operatorNumeric == null)
+            rr = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, response);
+        else
+            rr = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, response);
+
+        rr.mp.writeString(operatorNumeric);
+        rr.mp.writeInt(-1);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeAutomatic(Message response) {
+        setNetworkSelectionMode(null, response);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        setNetworkSelectionMode(operatorNumeric, response);
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/TelephonyProperties.java b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
index abb4523..38048e3 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyProperties.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
@@ -88,6 +88,11 @@ public interface TelephonyProperties
      */
     static final String PROPERTY_LTE_ON_CDMA_DEVICE = "telephony.lteOnCdmaDevice";
 
+    /**
+     * {@see BaseCommands#getLteOnGsmMode()}
+     */
+    static final String PROPERTY_LTE_ON_GSM_DEVICE = "telephony.lteOnGsmDevice";
+
     static final String CURRENT_ACTIVE_PHONE = "gsm.current.phone-type";
 
     //****** SIM Card
diff --git a/telephony/java/com/android/internal/telephony/cat/CallControlResult.java b/telephony/java/com/android/internal/telephony/cat/CallControlResult.java
new file mode 100644
index 0000000..2dbc0d4
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/cat/CallControlResult.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.cat;
+
+
+public enum CallControlResult {
+
+    CALL_CONTROL_NO_CONTROL(0x00),
+    CALL_CONTROL_ALLOWED_NO_MOD(0x01),
+    CALL_CONTROL_NOT_ALLOWED(0x02),
+    CALL_CONTROL_ALLOWED_WITH_MOD(0x03);
+    private int mValue;
+
+    CallControlResult(int value) {
+        mValue = value;
+    }
+
+    public static CallControlResult fromInt(int value) {
+        for (CallControlResult e : CallControlResult.values()) {
+            if (e.mValue == value) {
+                return e;
+            }
+        }
+        return null;
+    }
+
+    public int value() {
+        return mValue;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/cat/CatService.java b/telephony/java/com/android/internal/telephony/cat/CatService.java
index 74af9fa..cd6f9b4 100644
--- a/telephony/java/com/android/internal/telephony/cat/CatService.java
+++ b/telephony/java/com/android/internal/telephony/cat/CatService.java
@@ -25,13 +25,14 @@ import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Message;
 import android.os.SystemProperties;
+import android.widget.Toast;
 
 import com.android.internal.telephony.IccUtils;
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.IccCard;
 import com.android.internal.telephony.IccFileHandler;
 import com.android.internal.telephony.IccRecords;
-
+import com.android.internal.telephony.IccSmsInterfaceManager;
 
 import java.io.ByteArrayOutputStream;
 import java.util.List;
@@ -73,6 +74,9 @@ public class CatService extends Handler implements AppInterface {
     private Context mContext;
     private CatCmdMessage mCurrntCmd = null;
     private CatCmdMessage mMenuCmd = null;
+    private IccSmsInterfaceManager mIccSms = null;
+    private int mTimeoutDest = 0;
+    private int mCallControlResultCode = 0;
 
     private RilMessageDecoder mMsgDecoder = null;
     private boolean mStkAppInstalled = false;
@@ -85,8 +89,10 @@ public class CatService extends Handler implements AppInterface {
     static final int MSG_ID_REFRESH                  = 5;
     static final int MSG_ID_RESPONSE                 = 6;
     static final int MSG_ID_SIM_READY                = 7;
+    static final int MSG_ID_TIMEOUT                  = 9;
 
     static final int MSG_ID_RIL_MSG_DECODED          = 10;
+    static final int MSG_ID_SEND_SMS_RESULT          = 12;//samsung ril response
 
     // Events to signal SIM presence or absent in the device.
     private static final int MSG_ID_ICC_RECORDS_LOADED       = 20;
@@ -100,17 +106,25 @@ public class CatService extends Handler implements AppInterface {
 
     static final String STK_DEFAULT = "Defualt Message";
 
+    // Sms send result constants.
+    static final int SMS_SEND_OK = 0;
+    static final int SMS_SEND_FAIL = 32790;
+    static final int SMS_SEND_RETRY = 32810;
+
+    static final int WAITING_SMS_RESULT = 2;
+    static final int WAITING_SMS_RESULT_TIME = 60000;
+
     /* Intentionally private for singleton */
     private CatService(CommandsInterface ci, IccRecords ir, Context context,
-            IccFileHandler fh, IccCard ic) {
+            IccFileHandler fh, IccCard ic, IccSmsInterfaceManager iccSmsInt) {
         if (ci == null || ir == null || context == null || fh == null
-                || ic == null) {
+                || ic == null || iccSmsInt == null) {
             throw new NullPointerException(
                     "Service: Input parameters must not be null");
         }
         mCmdIf = ci;
         mContext = context;
-
+        mIccSms = iccSmsInt;
         // Get the RilMessagesDecoder for decoding the messages.
         mMsgDecoder = RilMessageDecoder.getInstance(this, fh);
 
@@ -119,6 +133,8 @@ public class CatService extends Handler implements AppInterface {
         mCmdIf.setOnCatProactiveCmd(this, MSG_ID_PROACTIVE_COMMAND, null);
         mCmdIf.setOnCatEvent(this, MSG_ID_EVENT_NOTIFY, null);
         mCmdIf.setOnCatCallSetUp(this, MSG_ID_CALL_SETUP, null);
+        // samsung ril sms send result
+        mCmdIf.setOnCatSendSmsResult(this, MSG_ID_SEND_SMS_RESULT, null);
         //mCmdIf.setOnSimRefresh(this, MSG_ID_REFRESH, null);
 
         mIccRecords = ir;
@@ -141,6 +157,7 @@ public class CatService extends Handler implements AppInterface {
         mCmdIf.unSetOnCatProactiveCmd(this);
         mCmdIf.unSetOnCatEvent(this);
         mCmdIf.unSetOnCatCallSetUp(this);
+        mCmdIf.unSetOnCatSendSmsResult(this);
 
         this.removeCallbacksAndMessages(null);
     }
@@ -267,6 +284,19 @@ public class CatService extends Handler implements AppInterface {
                 break;
             case SEND_DTMF:
             case SEND_SMS:
+                if (mContext.getResources().
+                        getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
+                    handleProactiveCommandSendSMS(cmdParams);
+                    if (((DisplayTextParams)cmdParams).textMsg == null
+                            || ((DisplayTextParams)cmdParams).textMsg.text == null)
+                        break;
+                    if (((DisplayTextParams)cmdParams).textMsg.text.equals(STK_DEFAULT)) {
+                        message = mContext.getText(com.android.internal.R.string.sending);
+                        ((DisplayTextParams)cmdParams).textMsg.text = message.toString();
+                        Toast.makeText(mContext, ((DisplayTextParams)cmdParams).textMsg.text, 1).show();
+                    }
+                }
+                break;
             case SEND_SS:
             case SEND_USSD:
                 if ((((DisplayTextParams)cmdParams).textMsg.text != null)
@@ -556,16 +586,16 @@ public class CatService extends Handler implements AppInterface {
      * @return The only Service object in the system
      */
     public static CatService getInstance(CommandsInterface ci, IccRecords ir,
-            Context context, IccFileHandler fh, IccCard ic) {
+            Context context, IccFileHandler fh, IccCard ic, IccSmsInterfaceManager iccSmsInt) {
         synchronized (sInstanceLock) {
             if (sInstance == null) {
                 if (ci == null || ir == null || context == null || fh == null
-                        || ic == null) {
+                        || ic == null || iccSmsInt == null) {
                     return null;
                 }
                 HandlerThread thread = new HandlerThread("Cat Telephony service");
                 thread.start();
-                sInstance = new CatService(ci, ir, context, fh, ic);
+                sInstance = new CatService(ci, ir, context, fh, ic, iccSmsInt);
                 CatLog.d(sInstance, "NEW sInstance");
             } else if ((ir != null) && (mIccRecords != ir)) {
                 CatLog.d(sInstance, "Reinitialize the Service with SIMRecords");
@@ -587,7 +617,7 @@ public class CatService extends Handler implements AppInterface {
      * @return The only Service object in the system
      */
     public static AppInterface getInstance() {
-        return getInstance(null, null, null, null, null);
+        return getInstance(null, null, null, null, null, null);
     }
 
     @Override
@@ -627,6 +657,64 @@ public class CatService extends Handler implements AppInterface {
             CatLog.d(this, "SIM ready. Reporting STK service running now...");
             mCmdIf.reportStkServiceIsRunning(null);
             break;
+        // Samsung ril sms send handling part
+        case MSG_ID_SEND_SMS_RESULT:
+            if (mContext.getResources().
+                        getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
+                int[] sendResult;
+                AsyncResult ar;
+                CatLog.d(this, "handleMsg : MSG_ID_SEND_SMS_RESULT");
+                cancelTimeOut();
+                CatLog.d(this, "The Msg ID data:" + msg.what);
+                if (msg.obj == null)
+                    break;
+                ar = (AsyncResult) msg.obj;
+                if (ar == null || ar.result == null || mCurrntCmd == null || mCurrntCmd.mCmdDet == null)
+                    break;
+                sendResult = (int[]) ar.result;
+                switch (sendResult[0]) {
+                    default:
+                        CatLog.d(this, "SMS SEND GENERIC FAIL");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED)
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        else
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
+                        break;
+                    case SMS_SEND_OK: // '\0'
+                        CatLog.d(this, "SMS SEND OK");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED)
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        else
+                            sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.OK, false, 0, null);
+                        break;
+                    case SMS_SEND_FAIL:
+                        CatLog.d(this, "SMS SEND FAIL - MEMORY NOT AVAILABLE");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED)
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        else
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.TERMINAL_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
+                        break;
+                    case SMS_SEND_RETRY:
+                        CatLog.d(this, "SMS SEND FAIL RETRY");
+                        if (CallControlResult.fromInt(mCallControlResultCode) ==
+                                CallControlResult.CALL_CONTROL_NOT_ALLOWED)
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.USIM_CALL_CONTROL_PERMANENT, true, 1, null);
+                        else
+                            sendTerminalResponse(mCurrntCmd.mCmdDet,
+                                    ResultCode.NETWORK_CRNTLY_UNABLE_TO_PROCESS, false, 0, null);
+                        break;
+                    }
+            }
+            break;
         default:
             throw new AssertionError("Unrecognized CAT command: " + msg.what);
         }
@@ -749,4 +837,27 @@ public class CatService extends Handler implements AppInterface {
 
         return (numReceiver > 0);
     }
+
+    /**
+     * samsung send sms
+     * @param cmdPar
+     */
+    private void handleProactiveCommandSendSMS(CommandParams cmdPar) {
+        CatLog.d(this, "The smscaddress is: " + ((SendSMSParams)cmdPar).smscAddress);
+        CatLog.d(this, "The SMS tpdu is: " + ((SendSMSParams)cmdPar).pdu);
+        mIccSms.sendRawPduSat(IccUtils.hexStringToBytes(((SendSMSParams)cmdPar).smscAddress),
+                IccUtils.hexStringToBytes(((SendSMSParams)cmdPar).pdu), null, null);
+        startTimeOut(WAITING_SMS_RESULT, WAITING_SMS_RESULT_TIME);
+    }
+
+    private void cancelTimeOut() {
+        removeMessages(MSG_ID_TIMEOUT);
+        mTimeoutDest = 0;
+    }
+
+    private void startTimeOut(int timeout, int delay) {
+        cancelTimeOut();
+        mTimeoutDest = timeout;
+        sendMessageDelayed(obtainMessage(MSG_ID_TIMEOUT), delay);
+    }
 }
diff --git a/telephony/java/com/android/internal/telephony/cat/CommandParams.java b/telephony/java/com/android/internal/telephony/cat/CommandParams.java
index 959c9e2..31e8bbdb 100644
--- a/telephony/java/com/android/internal/telephony/cat/CommandParams.java
+++ b/telephony/java/com/android/internal/telephony/cat/CommandParams.java
@@ -192,3 +192,14 @@ class BIPClientParams extends CommandParams {
         return false;
     }
 }
+
+class SendSMSParams extends DisplayTextParams {
+    String pdu;
+    String smscAddress;
+
+    SendSMSParams(CommandDetails cmdDet, TextMessage textmessage, String smscaddress, String smsPdu) {
+        super(cmdDet, textmessage);
+        smscAddress = smscaddress;
+        pdu = smsPdu;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/cat/CommandParamsFactory.java b/telephony/java/com/android/internal/telephony/cat/CommandParamsFactory.java
index 89c1329..5b8ec5b 100644
--- a/telephony/java/com/android/internal/telephony/cat/CommandParamsFactory.java
+++ b/telephony/java/com/android/internal/telephony/cat/CommandParamsFactory.java
@@ -16,6 +16,7 @@
 
 package com.android.internal.telephony.cat;
 
+import android.content.res.Resources;
 import android.graphics.Bitmap;
 import android.os.Handler;
 import android.os.Message;
@@ -134,43 +135,43 @@ class CommandParamsFactory extends Handler {
             case DISPLAY_TEXT:
                 cmdPending = processDisplayText(cmdDet, ctlvs);
                 break;
-             case SET_UP_IDLE_MODE_TEXT:
-                 cmdPending = processSetUpIdleModeText(cmdDet, ctlvs);
-                 break;
-             case GET_INKEY:
+            case SET_UP_IDLE_MODE_TEXT:
+                cmdPending = processSetUpIdleModeText(cmdDet, ctlvs);
+                break;
+            case GET_INKEY:
                 cmdPending = processGetInkey(cmdDet, ctlvs);
                 break;
-             case GET_INPUT:
-                 cmdPending = processGetInput(cmdDet, ctlvs);
-                 break;
-             case SEND_DTMF:
-             case SEND_SMS:
-             case SEND_SS:
-             case SEND_USSD:
-                 cmdPending = processEventNotify(cmdDet, ctlvs);
-                 break;
-             case SET_UP_CALL:
-                 cmdPending = processSetupCall(cmdDet, ctlvs);
-                 break;
-             case REFRESH:
+            case GET_INPUT:
+                cmdPending = processGetInput(cmdDet, ctlvs);
+                break;
+            case SEND_DTMF:
+            case SEND_SMS:
+            case SEND_SS:
+            case SEND_USSD:
+                cmdPending = processEventNotify(cmdDet, ctlvs);
+                break;
+            case SET_UP_CALL:
+                cmdPending = processSetupCall(cmdDet, ctlvs);
+                break;
+            case REFRESH:
                 processRefresh(cmdDet, ctlvs);
                 cmdPending = false;
                 break;
-             case LAUNCH_BROWSER:
-                 cmdPending = processLaunchBrowser(cmdDet, ctlvs);
-                 break;
-             case PLAY_TONE:
+            case LAUNCH_BROWSER:
+                cmdPending = processLaunchBrowser(cmdDet, ctlvs);
+                break;
+            case PLAY_TONE:
                 cmdPending = processPlayTone(cmdDet, ctlvs);
                 break;
-             case PROVIDE_LOCAL_INFORMATION:
+            case PROVIDE_LOCAL_INFORMATION:
                 cmdPending = processProvideLocalInfo(cmdDet, ctlvs);
                 break;
-             case OPEN_CHANNEL:
-             case CLOSE_CHANNEL:
-             case RECEIVE_DATA:
-             case SEND_DATA:
-                 cmdPending = processBIPClient(cmdDet, ctlvs);
-                 break;
+            case OPEN_CHANNEL:
+            case CLOSE_CHANNEL:
+            case RECEIVE_DATA:
+            case SEND_DATA:
+                cmdPending = processBIPClient(cmdDet, ctlvs);
+                break;
             default:
                 // unsupported proactive commands
                 mCmdParams = new CommandParams(cmdDet);
@@ -641,7 +642,34 @@ class CommandParamsFactory extends Handler {
         }
 
         textMsg.responseNeeded = false;
-        mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+
+        // samsung stk overlay
+        if (Resources.getSystem().getBoolean(com.android.internal.R.bool.config_samsung_stk)) {
+            String smscAddress = null;
+            String pdu = null;
+
+            ctlv = searchForTag(ComprehensionTlvTag.ADDRESS, ctlvs);
+            if (ctlv != null) {
+                smscAddress = ValueParser.retrieveSMSCaddress(ctlv);
+                CatLog.d(this, "The smsc address is " + smscAddress);
+            }
+            else {
+                CatLog.d(this, "The smsc address is null");
+            }
+
+            ctlv = searchForTag(ComprehensionTlvTag.SMS_TPDU, ctlvs);
+            if (ctlv != null) {
+                pdu = ValueParser.retrieveSMSTPDU(ctlv);
+                CatLog.d(this, "The SMS tpdu is " + pdu);
+            }
+            else {
+                CatLog.d(this, "The SMS tpdu is null");
+            }
+            mCmdParams = new SendSMSParams(cmdDet, textMsg, smscAddress, pdu);
+        }
+        else {
+            mCmdParams = new DisplayTextParams(cmdDet, textMsg);
+        }
 
         if (iconId != null) {
             mIconLoadState = LOAD_SINGLE_ICON;
diff --git a/telephony/java/com/android/internal/telephony/cat/ValueParser.java b/telephony/java/com/android/internal/telephony/cat/ValueParser.java
index 584d96c..66c0c67 100644
--- a/telephony/java/com/android/internal/telephony/cat/ValueParser.java
+++ b/telephony/java/com/android/internal/telephony/cat/ValueParser.java
@@ -338,4 +338,71 @@ abstract class ValueParser {
             throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
         }
     }
+
+    /**
+     * samsung part for converting byte[] to hexstring
+     * @param ctlv
+     * @return
+     * @throws ResultException
+     */
+    static String retrieveSMSCaddress(ComprehensionTlv ctlv)
+        throws ResultException {
+        byte[] rawValue = ctlv.getRawValue();
+        int valueIndex = ctlv.getValueIndex();
+        int length = ctlv.getLength();
+        byte[] outputValue = new byte[length + 1];
+
+        for (int k = 0; k <= length; k++) {
+            try {
+                outputValue[k] = rawValue[k + (valueIndex - 1)];
+            }
+            catch (IndexOutOfBoundsException indexoutofboundsexception) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+        }
+        if (length != 0)
+            return IccUtils.bytesToHexString(outputValue);
+        else
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+    }
+
+    /**
+     *
+     * @param ctlv
+     * @return
+     * @throws ResultException
+     */
+    static String retrieveSMSTPDU(ComprehensionTlv ctlv)
+            throws ResultException {
+        byte[] rawValue = ctlv.getRawValue();
+        int valueIndex = ctlv.getValueIndex();
+        int pduLength = ctlv.getLength();
+        byte[] outputValue;
+        int k;
+        String result;
+        if (rawValue[valueIndex + 2] % 2 == 0)
+            k = rawValue[valueIndex + 2] / 2;
+        else
+            k = (1 + rawValue[valueIndex + 2]) / 2;
+
+        if (pduLength == k + 6)
+            outputValue = new byte[pduLength + 1];
+        else
+            outputValue = new byte[pduLength];
+
+        for (int l = 0; l < pduLength; l++) {
+            try {
+                outputValue[l] = rawValue[valueIndex + l];
+            }
+            catch (IndexOutOfBoundsException ex) {
+                throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+            }
+        }
+        if (pduLength != 0)
+            result = IccUtils.bytesToHexString(outputValue);
+        else
+            throw new ResultException(ResultCode.CMD_DATA_NOT_UNDERSTOOD);
+
+        return result;
+    }
 }
diff --git a/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java b/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java
index 58e3e5f..276c6c5 100755
--- a/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -165,7 +165,7 @@ public class CDMAPhone extends PhoneBase {
         mSubInfo = new PhoneSubInfo(this);
         mEriManager = new EriManager(this, context, EriManager.ERI_FROM_XML);
         mCcatService = CatService.getInstance(mCM, mIccRecords, mContext,
-                mIccFileHandler, mIccCard);
+                mIccFileHandler, mIccCard, mRuimSmsInterfaceManager);
 
         mCM.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
         mIccRecords.registerForRecordsLoaded(this, EVENT_RUIM_RECORDS_LOADED, null);
diff --git a/telephony/java/com/android/internal/telephony/cdma/CdmaLteServiceStateTracker.java b/telephony/java/com/android/internal/telephony/cdma/CdmaLteServiceStateTracker.java
index 610cd5d..2c08480 100644
--- a/telephony/java/com/android/internal/telephony/cdma/CdmaLteServiceStateTracker.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CdmaLteServiceStateTracker.java
@@ -359,6 +359,10 @@ public class CdmaLteServiceStateTracker extends CdmaServiceStateTracker {
                 // new ERI text
                 if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
                     eriText = phone.getCdmaEriText();
+                } else if (ss.getState() == ServiceState.STATE_POWER_OFF) {
+                    // We're in Airplane Mode
+                    eriText = phone.getContext().getText(
+                            com.android.internal.R.string.roamingTextAirplaneMode).toString();
                 } else {
                     // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                     // for
diff --git a/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java b/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
index ca8d9ae..4387a17 100755
--- a/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
@@ -45,6 +45,7 @@ import com.android.internal.telephony.TelephonyProperties;
 import com.android.internal.telephony.WspTypeDecoder;
 import com.android.internal.telephony.cdma.sms.SmsEnvelope;
 import com.android.internal.telephony.cdma.sms.UserData;
+import com.android.internal.util.BitwiseInputStream;
 import com.android.internal.util.HexDump;
 
 import java.io.ByteArrayOutputStream;
@@ -181,10 +182,78 @@ final class CdmaSMSDispatcher extends SMSDispatcher {
                 (SmsEnvelope.MESSAGE_TYPE_BROADCAST != sms.getMessageType())) {
             return Intents.RESULT_SMS_UNSUPPORTED;
         }
-
+        /*
+         * Check to see if we have a Virgin Mobile MMS
+         * If so, do extra processsing for Virgin Mobile's non-standard format.
+         * Otherwise, dispatch normal message.
+         */
+        if (sms.getOriginatingAddress().equals("9999999999")) {
+            Log.d(TAG, "Got a suspect SMS from the Virgin MMS originator");
+                byte virginMMSPayload[] = null;
+                try {
+                    int[] ourMessageRef = new int[1];
+                    virginMMSPayload = getVirginMMS(sms.getUserData(), ourMessageRef);
+                    if (virginMMSPayload == null) {
+                        Log.e(TAG, "Not a virgin MMS like we were expecting");
+                        throw new Exception("Not a Virgin MMS like we were expecting");
+                    } else {
+                        Log.d(TAG, "Sending our deflowered MMS to processCdmaWapPdu");
+                        return processCdmaWapPdu(virginMMSPayload, ourMessageRef[0], "9999999999");
+                    }
+                } catch (Exception ourException) {
+                    Log.e(TAG, "Got an exception trying to get VMUS MMS data " + ourException);
+                }
+        }
         return dispatchNormalMessage(smsb);
     }
 
+    private synchronized byte[] getVirginMMS(final byte[] someEncodedMMSData, int[] aMessageRef) throws Exception {
+        if ((aMessageRef == null) || (aMessageRef.length != 1)) {
+            throw new Exception("aMessageRef is not usable. Must be an int array with one element.");
+        }
+        BitwiseInputStream ourInputStream;
+        int i1=0;
+        int desiredBitLength;
+        Log.d(TAG, "mmsVirginGetMsgId");
+        Log.d(TAG, "EncodedMMS: " + someEncodedMMSData);
+        try {
+            ourInputStream = new BitwiseInputStream(someEncodedMMSData);
+            ourInputStream.skip(20);
+            final int j = ourInputStream.read(8) << 8;
+            final int k = ourInputStream.read(8);
+            aMessageRef[0] = j | k;
+            Log.d(TAG, "MSGREF IS : " + aMessageRef[0]);
+            ourInputStream.skip(12);
+            i1 = ourInputStream.read(8) + -2;
+            ourInputStream.skip(13);
+            byte abyte1[] = new byte[i1];
+            for (int j1 = 0; j1 < i1; j1++) {
+                abyte1[j1] = 0;
+            }
+            desiredBitLength = i1 * 8;
+            if (ourInputStream.available() < desiredBitLength) {
+                int availableBitLength = ourInputStream.available();
+                Log.e(TAG, "mmsVirginGetMsgId inStream.available() = " + availableBitLength + " wantedBits = " + desiredBitLength);
+                throw new Exception("insufficient data (wanted " + desiredBitLength + " bits, but only have " + availableBitLength + ")");
+            }
+        } catch (com.android.internal.util.BitwiseInputStream.AccessException ourException) {
+            final String ourExceptionText = "mmsVirginGetMsgId failed: " + ourException;
+            Log.e(TAG, ourExceptionText);
+            throw new Exception(ourExceptionText);
+        }
+        byte ret[] = null;
+            try {
+            ret = ourInputStream.readByteArray(desiredBitLength);
+            Log.d(TAG, "mmsVirginGetMsgId user_length = " + i1 + " msgid = " + aMessageRef[0]);
+                Log.d(TAG, "mmsVirginGetMsgId userdata = " + ret.toString());
+            } catch (com.android.internal.util.BitwiseInputStream.AccessException ourException) {
+                final String ourExceptionText = "mmsVirginGetMsgId failed: " + ourException;
+                Log.e(TAG, ourExceptionText);
+                throw new Exception(ourExceptionText);
+            }
+            return ret;
+    }
+
     /**
      * Processes inbound messages that are in the WAP-WDP PDU format. See
      * wap-259-wdp-20010614-a section 6.5 for details on the WAP-WDP PDU format.
diff --git a/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
index d939e98..77910fc 100755
--- a/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -951,6 +951,10 @@ public class CdmaServiceStateTracker extends ServiceStateTracker {
                 // Now the CDMAPhone sees the new ServiceState so it can get the new ERI text
                 if (ss.getState() == ServiceState.STATE_IN_SERVICE) {
                     eriText = phone.getCdmaEriText();
+                } else if (ss.getState() == ServiceState.STATE_POWER_OFF) {
+                    // We're in Airplane Mode
+                    eriText = phone.getContext().getText(
+                            com.android.internal.R.string.roamingTextAirplaneMode).toString();
                 } else {
                     // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                     // mRegistrationState 0,2,3 and 4
diff --git a/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java b/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java
index 6743da0..5aeeef3 100755
--- a/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java
+++ b/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java
@@ -878,10 +878,21 @@ public final class BearerData {
             paramBits -= EXPECTED_PARAM_SIZE;
             decodeSuccess = true;
             bData.messageType = inStream.read(4);
-            bData.messageId = inStream.read(8) << 8;
-            bData.messageId |= inStream.read(8);
-            bData.hasUserDataHeader = (inStream.read(1) == 1);
-            inStream.skip(3);
+            // Some Samsung CDMAphones parses messageId differently than other devices
+            // fix it here so that incoming sms works correctly
+            boolean hasSamsungCDMAAlternateMessageIDEncoding = Resources.getSystem()
+                    .getBoolean(com.android.internal.R.bool.config_smsSamsungCdmaAlternateMessageIDEncoding);
+            if (hasSamsungCDMAAlternateMessageIDEncoding) {
+                inStream.skip(4);
+                bData.messageId = inStream.read(8) << 8;
+                bData.messageId |= inStream.read(8);
+                bData.hasUserDataHeader = (inStream.read(8) == 1);
+            } else {
+                bData.messageId = inStream.read(8) << 8;
+                bData.messageId |= inStream.read(8);
+                bData.hasUserDataHeader = (inStream.read(1) == 1);
+                inStream.skip(3);
+            }
         }
         if ((! decodeSuccess) || (paramBits > 0)) {
             Log.d(LOG_TAG, "MESSAGE_IDENTIFIER decode " +
diff --git a/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java b/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java
index e1f4c4b..3a30f9c 100644
--- a/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -147,7 +147,8 @@ public class GSMPhone extends PhoneBase {
             mSimSmsIntManager = new SimSmsInterfaceManager(this, mSMS);
             mSubInfo = new PhoneSubInfo(this);
         }
-        mStkService = CatService.getInstance(mCM, mIccRecords, mContext, mIccFileHandler, mIccCard);
+        mStkService = CatService.getInstance(mCM, mIccRecords, mContext, mIccFileHandler, mIccCard,
+                mSimSmsIntManager);
 
         mCM.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
         mIccRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
@@ -350,6 +351,10 @@ public class GSMPhone extends PhoneBase {
                 case DATAINANDOUT:
                     ret = DataActivityState.DATAINANDOUT;
                 break;
+
+                case DORMANT:
+                    ret = DataActivityState.DORMANT;
+                break;
             }
         }
 
diff --git a/telephony/java/com/android/internal/telephony/gsm/GsmConnection.java b/telephony/java/com/android/internal/telephony/gsm/GsmConnection.java
index c1ad7b3..1941362 100644
--- a/telephony/java/com/android/internal/telephony/gsm/GsmConnection.java
+++ b/telephony/java/com/android/internal/telephony/gsm/GsmConnection.java
@@ -26,6 +26,7 @@ import android.os.SystemClock;
 import android.util.Log;
 import android.telephony.PhoneNumberUtils;
 import android.telephony.ServiceState;
+import android.text.TextUtils;
 
 import com.android.internal.telephony.*;
 
@@ -46,6 +47,7 @@ public class GsmConnection extends Connection {
     boolean isIncoming;
     boolean disconnected;
 
+    String cnapName;
     int index;          // index in GsmCallTracker.connections[], -1 if unassigned
                         // The GSM index is 1 + this
 
@@ -72,6 +74,7 @@ public class GsmConnection extends Connection {
     DisconnectCause cause = DisconnectCause.NOT_DISCONNECTED;
     PostDialState postDialState = PostDialState.NOT_STARTED;
     int numberPresentation = Connection.PRESENTATION_ALLOWED;
+    int cnapNamePresentation = Connection.PRESENTATION_ALLOWED;
     UUSInfo uusInfo;
 
     Handler h;
@@ -125,6 +128,8 @@ public class GsmConnection extends Connection {
 
         isIncoming = dc.isMT;
         createTime = System.currentTimeMillis();
+        cnapName = dc.name;
+        cnapNamePresentation = dc.namePresentation;
         numberPresentation = dc.numberPresentation;
         uusInfo = dc.uusInfo;
 
@@ -151,6 +156,9 @@ public class GsmConnection extends Connection {
         index = -1;
 
         isIncoming = false;
+        cnapName = null;
+        cnapNamePresentation = Connection.PRESENTATION_ALLOWED;
+        numberPresentation = Connection.PRESENTATION_ALLOWED;
         createTime = System.currentTimeMillis();
 
         this.parent = parent;
@@ -189,6 +197,14 @@ public class GsmConnection extends Connection {
         return parent;
     }
 
+    public String getCnapName() {
+        return cnapName;
+    }
+
+    public int getCnapNamePresentation() {
+        return cnapNamePresentation;
+    }
+
     public long getCreateTime() {
         return createTime;
     }
@@ -437,6 +453,21 @@ public class GsmConnection extends Connection {
             changed = true;
         }
 
+        // A null cnapName should be the same as ""
+        if (TextUtils.isEmpty(dc.name)) {
+            if (!TextUtils.isEmpty(cnapName)) {
+                changed = true;
+                cnapName = "";
+            }
+	} else if (!dc.name.equals(cnapName)) {
+                changed = true;
+                cnapName = dc.name;
+        }
+
+        if (Phone.DEBUG_PHONE) log("--dssds----"+cnapName);
+        cnapNamePresentation = dc.namePresentation;
+        numberPresentation = dc.numberPresentation;
+
         if (newParent != parent) {
             if (parent != null) {
                 parent.detach(this);
diff --git a/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java b/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
index 95ea107..d715dac 100644
--- a/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
+++ b/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
@@ -488,6 +488,12 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
             if (DBG) log("enableApnType: return APN_ALREADY_ACTIVE");
             return Phone.APN_ALREADY_ACTIVE;
         }
+        if (mPhone.mCM.needsOldRilFeature("singlepdp") && !Phone.APN_TYPE_DEFAULT.equals(apnType)) {
+            ApnContext defContext = mApnContexts.get(Phone.APN_TYPE_DEFAULT);
+            if (defContext.isEnabled()) {
+                setEnabled(apnTypeToId(Phone.APN_TYPE_DEFAULT), false);
+            }
+        }
         setEnabled(apnTypeToId(apnType), true);
         if (DBG) {
             log("enableApnType: new apn request for type " + apnType +
@@ -522,6 +528,9 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
 
         if (apnContext != null) {
             setEnabled(apnTypeToId(type), false);
+            if (mPhone.mCM.needsOldRilFeature("singlepdp") && !Phone.APN_TYPE_DEFAULT.equals(type)) {
+                setEnabled(apnTypeToId(Phone.APN_TYPE_DEFAULT), true);
+            }
             if (apnContext.getState() != State.IDLE && apnContext.getState() != State.FAILED) {
                 if (DBG) log("diableApnType: return APN_REQUEST_STARTED");
                 return Phone.APN_REQUEST_STARTED;
@@ -1160,6 +1169,28 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
     }
 
     /**
+     * Clear data call entries with duplicate call ids.
+     * The function will retain the first found unique call id.
+     *
+     * @param dataCalls
+     * @return unique set of dataCalls.
+     */
+    private ArrayList<DataCallState> clearDuplicates(
+            ArrayList<DataCallState> dataCalls) {
+        // clear duplicate cid's
+        ArrayList<Integer> cids = new ArrayList<Integer>();
+        ArrayList<DataCallState> uniqueCalls = new ArrayList<DataCallState>();
+        for (DataCallState dc : dataCalls) {
+            if (!cids.contains(dc.cid)) {
+                uniqueCalls.add(dc);
+                cids.add(dc.cid);
+            }
+        }
+        log("Number of DataCallStates:" + dataCalls.size() + "Unique count:" + uniqueCalls.size());
+        return uniqueCalls;
+    }
+
+    /**
      * @param ar is the result of RIL_REQUEST_DATA_CALL_LIST
      * or RIL_UNSOL_DATA_CALL_LIST_CHANGED
      */
@@ -1178,6 +1209,11 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
         }
         if (DBG) log("onDataStateChanged(ar): DataCallState size=" + dataCallStates.size());
 
+        dataCallStates = clearDuplicates(dataCallStates);
+
+        boolean isAnyDataCallDormant = false;
+        boolean isAnyDataCallActive = false;
+
         // Create a hash map to store the dataCallState of each DataConnectionAc
         HashMap<DataCallState, DataConnectionAc> dataCallStateToDcac;
         dataCallStateToDcac = new HashMap<DataCallState, DataConnectionAc>();
@@ -1199,6 +1235,9 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
                 continue;
             }
 
+            if (newState.active == DATA_CONNECTION_ACTIVE_PH_LINK_UP) isAnyDataCallActive = true;
+            if (newState.active == DATA_CONNECTION_ACTIVE_PH_LINK_DOWN) isAnyDataCallDormant = true;
+
             // The list of apn's associated with this DataConnection
             Collection<ApnContext> apns = dcac.getApnListSync();
 
@@ -1279,6 +1318,32 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
             }
         }
 
+        if (isAnyDataCallDormant && !isAnyDataCallActive) {
+            // There is no way to indicate link activity per APN right now. So
+            // Link Activity will be considered dormant only when all data calls
+            // are dormant.
+            // If a single data call is in dormant state and none of the data
+            // calls are active broadcast overall link state as dormant.
+            mActivity = Activity.DORMANT;
+            if (DBG) {
+                log("onDataStateChanged: Data Activity updated to DORMANT. stopNetStatePoll");
+            }
+            stopNetStatPoll();
+            stopDataStallAlarm();
+        } else {
+            mActivity = Activity.NONE;
+            if (DBG) {
+                log("onDataStateChanged: Data Activity updated to NONE. " +
+                         "isAnyDataCallActive = " + isAnyDataCallActive +
+                         " isAnyDataCallDormant = " + isAnyDataCallDormant);
+            }
+            if (isAnyDataCallActive) {
+                startNetStatPoll();
+                startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
+            }
+        }
+        mPhone.notifyDataActivity();
+
         if (apnsToCleanup.size() != 0) {
             // Add an event log when the network drops PDP
             int cid = getCellLocationId();
@@ -1300,6 +1365,8 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
                 + ", reason:" + apnContext.getReason());
         }
         apnContext.setState(State.CONNECTED);
+        mActiveApn = apnContext.getApnSetting();
+
         // setState(State.CONNECTED);
         mPhone.notifyDataConnection(apnContext.getReason(), apnContext.getApnType());
         startNetStatPoll();
@@ -1513,7 +1580,7 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
             } else if (sent == 0 && received > 0) {
                 newActivity = Activity.DATAIN;
             } else {
-                newActivity = Activity.NONE;
+                newActivity = (mActivity == Activity.DORMANT) ? mActivity : Activity.NONE;
             }
 
             if (mActivity != newActivity && mIsScreenOn) {
@@ -1676,7 +1743,7 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
         intent.putExtra(DATA_STALL_ALARM_TAG_EXTRA, mDataStallAlarmTag);
         mDataStallAlarmIntent = PendingIntent.getBroadcast(mPhone.getContext(), 0, intent,
                 PendingIntent.FLAG_UPDATE_CURRENT);
-        am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,
+        am.set(AlarmManager.ELAPSED_REALTIME,
                 SystemClock.elapsedRealtime() + delayInMs, mDataStallAlarmIntent);
     }
 
@@ -2328,13 +2395,37 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
                 }
             }
         }
+
+        // If the currently active data connect can handle the requested type, try it first
+        if ((mActiveApn != null) && mActiveApn.canHandleType(requestedApnType)) {
+            if (DBG) log("buildWaitingApns: X added already active apnList=" + apnList);
+            apnList.add(mActiveApn);
+        }
+
         if (mAllApns != null) {
+            // Use the preferred APN if it can handle the type being requested
+            if (canSetPreferApn && mPreferredApn != null) {
+                if (DBG) {
+                    log("buildWaitingApns: Preferred APN:" + operator + ":"
+                        + mPreferredApn.numeric + ":" + mPreferredApn);
+                }
+                if ((mPreferredApn.numeric.equals(operator) && mPreferredApn.canHandleType(requestedApnType)) &&
+                    (mPreferredApn.bearer == 0 || mPreferredApn.bearer == radioTech) && 
+                    !apnList.contains(mPreferredApn))
+                {
+                    apnList.add(mPreferredApn);
+                    if (DBG) log("buildWaitingApns: X added preferred apnList=" + apnList);
+                }
+            }
+
+            // Add all the rest of the apns that can handle the requested type
             for (ApnSetting apn : mAllApns) {
-                if (apn.canHandleType(requestedApnType)) {
-                    if (apn.bearer == 0 || apn.bearer == radioTech) {
-                        if (DBG) log("apn info : " +apn.toString());
-                        apnList.add(apn);
-                    }
+                if ((apn.canHandleType(requestedApnType)) &&
+                    (apn.bearer == 0 || apn.bearer == radioTech) &&
+                    !apnList.contains(apn))
+                {
+                    if (DBG) log("apn info : " +apn.toString());
+                    apnList.add(apn);
                 }
             }
         } else {
@@ -2547,4 +2638,5 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
     protected void loge(String s) {
         Log.e(LOG_TAG, "[GsmDCT] " + s);
     }
+
 }
diff --git a/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 6e2b262..8e31e5a 100644
--- a/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -610,7 +610,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
                             regState = Integer.parseInt(states[0]);
 
                             // states[3] (if present) is the current radio technology
-                            if (states.length >= 4 && states[3] != null) {
+                            if (states.length >= 4 && states[3] != null && !states[3].equals("")) {
                                 type = Integer.parseInt(states[3]);
                             }
                             if ((states.length >= 5 ) && (regState == 3)) {
@@ -1222,7 +1222,9 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         } catch (Exception e){
         }
 
-        return gsmRoaming && !(equalsMcc && (equalsOnsl || equalsOnss));
+        boolean mvnoRoaming = Settings.System.getInt(phone.getContext().getContentResolver(),
+            Settings.System.MVNO_ROAMING, 0) == 1;
+        return gsmRoaming && !(equalsMcc && (equalsOnsl || equalsOnss || mvnoRoaming));
     }
 
     private static int twoDigitsAt(String s, int offset) {
@@ -1354,8 +1356,10 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
             // As a special extension, the Android emulator appends the name of
             // the host computer's timezone to the nitz string. this is zoneinfo
             // timezone name of the form Area!Location or Area!Location!SubLocation
-            // so we need to convert the ! into /
-            if (nitzSubs.length >= 9) {
+            // so we need to convert the ! into /.  If there's no "!", then maybe
+            // the carrier is appending something extra (as AT&T does) and it
+            // should be ignored
+            if ((nitzSubs.length >= 9) && (nitzSubs[8].indexOf('!') != -1)) {
                 String  tzname = nitzSubs[8].replace('!','/');
                 zone = TimeZone.getTimeZone( tzname );
             }
diff --git a/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java b/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java
index e8d10f9..3a5af31 100644
--- a/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java
@@ -57,6 +57,12 @@ public final class SIMFileHandler extends IccFileHandler implements IccConstants
     }
 
     protected String getEFPath(int efid) {
+        if (phone.mCM.needsOldRilFeature("qcomuiccstack")) {
+            IccCard icccard = phone.getIccCard();
+            if (icccard != null && icccard.isApplicationOnIcc(IccCardApplication.AppType.APPTYPE_USIM))
+                return getEFPathForUICC(efid);
+        }
+
         // TODO(): DF_GSM can be 7F20 or 7F21 to handle backward compatibility.
         // Implement this after discussion with OEMs.
         switch(efid) {
@@ -102,6 +108,41 @@ public final class SIMFileHandler extends IccFileHandler implements IccConstants
         return path;
     }
 
+    protected String getEFPathForUICC(int efid) {
+        switch (efid) {
+            case EF_SMS:
+            case EF_EXT6:
+            case EF_MWIS:
+            case EF_MBI:
+            case EF_SPN:
+            case EF_AD:
+            case EF_MBDN:
+            case EF_PNN:
+            case EF_SPDI:
+            case EF_SST:
+            case EF_CFIS:
+            case EF_MAILBOX_CPHS:
+            case EF_VOICE_MAIL_INDICATOR_CPHS:
+            case EF_CFF_CPHS:
+            case EF_SPN_CPHS:
+            case EF_SPN_SHORT_CPHS:
+            case EF_INFO_CPHS:
+            case EF_PBR:
+            case EF_MSISDN:
+            case EF_FDN:
+                return MF_SIM + DF_ADFISIM;
+
+            case EF_CSP_CPHS:
+                // we only support global phonebook.
+                return MF_SIM + DF_TELECOM + DF_PHONEBOOK;
+
+        }
+        String path = getCommonIccEFPath(efid);
+        if (path == null)
+            Log.e(LOG_TAG, "Error: EF Path being returned in null");
+        return path;
+    }
+
     protected void logd(String msg) {
         Log.d(LOG_TAG, "[SIMFileHandler] " + msg);
     }
diff --git a/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java b/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
index da60584..bef222d 100644
--- a/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
@@ -22,6 +22,7 @@ import android.util.Log;
 
 import com.android.internal.telephony.EncodeException;
 import com.android.internal.telephony.GsmAlphabet;
+import com.android.internal.telephony.SimRegionCache;
 import com.android.internal.telephony.IccUtils;
 import com.android.internal.telephony.SmsHeader;
 import com.android.internal.telephony.SmsMessageBase;
@@ -1043,6 +1044,10 @@ public class SmsMessage extends SmsMessageBase {
                     Log.w(LOG_TAG, "1 - Unsupported SMS data coding scheme "
                             + (dataCodingScheme & 0xff));
                     encodingType = ENCODING_8BIT;
+                    if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+                        Log.w(LOG_TAG, "Korean SIM, using KSC5601 for decoding.");
+                        encodingType = ENCODING_KSC5601;
+                    }
                     break;
                 }
             }
@@ -1101,6 +1106,10 @@ public class SmsMessage extends SmsMessageBase {
         } else {
             Log.w(LOG_TAG, "3 - Unsupported SMS data coding scheme "
                     + (dataCodingScheme & 0xff));
+            if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+                Log.w(LOG_TAG, "Korean SIM, using KSC5601 for decoding.");
+                encodingType = ENCODING_KSC5601;
+            }
         }
 
         // set both the user data and the user data header.
diff --git a/telephony/java/com/android/internal/telephony/sip/SipCommandInterface.java b/telephony/java/com/android/internal/telephony/sip/SipCommandInterface.java
index ab01012..e2ba8bf 100644
--- a/telephony/java/com/android/internal/telephony/sip/SipCommandInterface.java
+++ b/telephony/java/com/android/internal/telephony/sip/SipCommandInterface.java
@@ -412,4 +412,18 @@ class SipCommandInterface extends BaseCommands implements CommandsInterface {
 
     public void requestIsimAuthentication(String nonce, Message response) {
     }
+
+    public boolean needsOldRilFeature(String feature) { return false; }
+
+    /**
+     * added samsung part to command interface
+     * @param h
+     * @param what
+     * @param obj
+     */
+    public void setOnCatSendSmsResult(Handler h, int what, Object obj) {
+    }
+
+    public void unSetOnCatSendSmsResult(Handler h) {
+    }
 }
diff --git a/telephony/java/com/android/internal/telephony/test/SimulatedCommands.java b/telephony/java/com/android/internal/telephony/test/SimulatedCommands.java
index a0c7d5d..e662cd3 100644
--- a/telephony/java/com/android/internal/telephony/test/SimulatedCommands.java
+++ b/telephony/java/com/android/internal/telephony/test/SimulatedCommands.java
@@ -17,6 +17,7 @@
 package com.android.internal.telephony.test;
 
 import android.os.AsyncResult;
+import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
@@ -1517,4 +1518,22 @@ public final class SimulatedCommands extends BaseCommands
     public void requestIsimAuthentication(String nonce, Message response) {
         unimplemented(response);
     }
+
+    public boolean needsOldRilFeature(String feature) { return false; }
+
+    /**
+     * added samsung part to command interface
+     * @param h
+     * @param what
+     * @param obj
+     */
+    public void setOnCatSendSmsResult(Handler h, int what, Object obj) {
+    }
+
+    /**
+     *
+     * @param h
+     */
+    public void unSetOnCatSendSmsResult(Handler h) {
+    }
 }
diff --git a/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java b/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java
index 8a4a285..5511c09 100644
--- a/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java
+++ b/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java
@@ -170,6 +170,18 @@ public class AdnRecordTest extends TestCase {
         assertEquals("Adgjm", adn.getAlphaTag());
         assertEquals("+18885551212,12345678", adn.getNumber());
         assertFalse(adn.isEmpty());
+
+        //
+        // Test that a ADN record with KSC5601 will get converted correctly
+        // This test will only be run when using a Korean SIM
+        //
+        if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+            adn = new AdnRecord(IccUtils.hexStringToBytes(
+                  "3030312C20C8AB41B1E6FFFFFFFFFFFF07811010325476F8FFFFFFFFFFFF"));
+            assertEquals("001, \uD64DA\uAE38", adn.getAlphaTag());
+            assertEquals("01012345678", adn.getNumber());
+            assertFalse(adn.isEmpty());
+        }
     }
 }
 
diff --git a/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java b/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java
index 8a66614..f578a8d 100644
--- a/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java
+++ b/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java
@@ -102,4 +102,25 @@ public class SMSDispatcherTest extends AndroidTestCase {
        sms = SmsMessage.createFromEfRecord(1, data);
        assertNotNull(sms.getMessageBody());
     }
+
+    @MediumTest
+    public void testEfRecordKorean() throws Exception {
+        if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+            SmsMessage sms;
+
+            String s = "01089128010099010259040ba11000000000f00095013091900563008c4142"
+                     + "434445b0a1b3aab4d9b6f3b8b631323334354142434445b0a1b3aab4d9b6f3"
+                     + "b8b631323334354142434445b0a1b3aab4d9b6f3b8b6313233343541424344"
+                     + "45b0a1b3aab4d9b6f3b8b63132333435000000000000000000000000000000"
+                     + "00000000000000000000000000000000000000000000000000000000000000"
+                     + "0000000000000000000000000000ffffffffffffff";
+
+
+           byte[] data = IccUtils.hexStringToBytes(s);
+
+           sms = SmsMessage.createFromEfRecord(1, data);
+           assertNotNull(sms.getMessageBody());
+           assertTrue(sms.getMessageBody().startsWith("ABCDE\uAC00\uB098\uB2E4\uB77C\uB9C812345ABCDE"));
+        }
+    }
 }
diff --git a/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java b/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java
index ef62d85..2e76bd3 100644
--- a/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java
+++ b/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java
@@ -86,6 +86,30 @@ public class SimUtilsTest extends TestCase {
         data = IccUtils.hexStringToBytes("820505302D82d32d31");
         // Example from 3GPP TS 11.11 V18.1.3.0 annex B
         assertEquals("-\u0532\u0583-1", IccUtils.adnStringFieldToString(data, 0, data.length));
+
+        /*
+         * adnStringFieldToStringKsc5601Support()
+         * Tests equal the ones above, and will only be run if the SIM is NOT korean.
+         */
+
+        if (SimRegionCache.getRegion() != SimRegionCache.MCC_KOREAN) {
+            data = IccUtils.hexStringToBytes("00566f696365204d61696c07918150367742f3ffffffffffff");
+            // Again, skip prepended 0
+            // (this is an EF[ADN] record)
+            assertEquals("Voice Mail", IccUtils.adnStringFieldToStringKsc5601Support(data, 1, data.length - 15));
+
+            data = IccUtils.hexStringToBytes("809673539A5764002F004DFFFFFFFFFF");
+            // (this is from an EF[ADN] record)
+            assertEquals("\u9673\u539A\u5764/M", IccUtils.adnStringFieldToStringKsc5601Support(data, 0, data.length));
+
+            data = IccUtils.hexStringToBytes("810A01566fec6365204de0696cFFFFFF");
+            // (this is made up to test since I don't have a real one)
+            assertEquals("Vo\u00ECce M\u00E0il", IccUtils.adnStringFieldToStringKsc5601Support(data, 0, data.length));
+
+            data = IccUtils.hexStringToBytes("820505302D82d32d31");
+            // Example from 3GPP TS 11.11 V18.1.3.0 annex B
+            assertEquals("-\u0532\u0583-1", IccUtils.adnStringFieldToStringKsc5601Support(data, 0, data.length));
+        }
     }
 
 }
diff --git a/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java b/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java
index 7e0d3c4..4f77473 100644
--- a/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java
+++ b/telephony/tests/telephonytests/src/com/android/internal/telephony/gsm/UsimDataDownloadCommands.java
@@ -18,6 +18,7 @@ package com.android.internal.telephony.gsm;
 
 import android.content.Context;
 import android.os.AsyncResult;
+import android.os.Handler;
 import android.os.Message;
 import android.os.SystemClock;
 import android.util.Log;
@@ -608,4 +609,15 @@ class UsimDataDownloadCommands extends BaseCommands {
     @Override
     public void requestIsimAuthentication(String nonce, Message response) {
     }
+
+    @Override
+    public boolean needsOldRilFeature(String feature) { return false; }
+
+    @Override
+    public void setOnCatSendSmsResult(Handler h, int what, Object obj) {
+    }
+
+    @Override
+    public void unSetOnCatSendSmsResult(Handler h) {
+    }
 }
diff --git a/tools/aapt/Android.mk b/tools/aapt/Android.mk
index cb55a9c..e3d4970 100644
--- a/tools/aapt/Android.mk
+++ b/tools/aapt/Android.mk
@@ -28,7 +28,7 @@ LOCAL_SRC_FILES := \
     ZipFile.cpp
 
 
-LOCAL_CFLAGS += -Wno-format-y2k
+LOCAL_CFLAGS += -Wno-format-y2k -fpermissive
 
 LOCAL_C_INCLUDES += external/expat/lib
 LOCAL_C_INCLUDES += external/libpng
diff --git a/voip/jni/rtp/AudioGroup.cpp b/voip/jni/rtp/AudioGroup.cpp
index 459756d..bd8c1c4 100644
--- a/voip/jni/rtp/AudioGroup.cpp
+++ b/voip/jni/rtp/AudioGroup.cpp
@@ -870,8 +870,11 @@ bool AudioGroup::DeviceThread::threadLoop()
         int16_t input[sampleCount];
         int toWrite = sampleCount;
         int toRead = (mode == MUTED) ? 0 : sampleCount;
+#ifdef QCOM_HARDWARE
+        int chances = 10000;
+#else
         int chances = 100;
-
+#endif
         while (--chances > 0 && (toWrite > 0 || toRead > 0)) {
             if (toWrite > 0) {
                 AudioTrack::Buffer buffer;
@@ -985,7 +988,11 @@ void add(JNIEnv *env, jobject thiz, jint mode,
     if (!group) {
         int mode = env->GetIntField(thiz, gMode);
         group = new AudioGroup;
+#ifdef QCOM_HARDWARE
+        if (!group->set(sampleRate, sampleCount) || !group->setMode(mode)) {
+#else
         if (!group->set(8000, 256) || !group->setMode(mode)) {
+#endif
             jniThrowException(env, "java/lang/IllegalStateException",
                 "cannot initialize audio group");
             goto error;
diff --git a/wifi/java/android/net/wifi/WifiConfigStore.java b/wifi/java/android/net/wifi/WifiConfigStore.java
index 568a485..54b760f 100644
--- a/wifi/java/android/net/wifi/WifiConfigStore.java
+++ b/wifi/java/android/net/wifi/WifiConfigStore.java
@@ -1025,6 +1025,32 @@ class WifiConfigStore {
                 break setVariables;
             }
 
+            // Android sometimes call this function with infrastructure
+            // configuration for ad-hoc networks (from selectNetwork),
+            // so we only set the variable if the mode is ad-hoc.
+            // (Infrastructure is default and does not have to be set.)
+            if (config.mode == WifiConfiguration.Mode.ADHOC) {
+                if (!WifiNative.setNetworkVariableCommand(
+                            netId,
+                            WifiConfiguration.Mode.varName,
+                            Integer.toString(config.mode))) {
+                    loge(config.SSID + ": failed to set mode: "
+                            +config.mode);
+                    break setVariables;
+                }
+
+                // Some drivers/wpa_supplicant require the frequency
+                // to be set for ad-hoc networks, even though it will
+                // not actually be used. Set it to Channel 11.
+                if (!WifiNative.setNetworkVariableCommand(
+                            netId,
+                            "frequency",
+                            "2462")) {
+                    loge(config.SSID + ": failed to set frequency: 2462");
+                    break setVariables;
+                }
+            }
+
             for (WifiConfiguration.EnterpriseField field
                     : config.enterpriseFields) {
                 String varName = field.varName();
@@ -1246,6 +1272,15 @@ class WifiConfigStore {
             }
         }
 
+        value = WifiNative.getNetworkVariableCommand(netId, WifiConfiguration.Mode.varName);
+        config.mode = WifiConfiguration.Mode.INFRASTRUCTURE;
+        if (!TextUtils.isEmpty(value)) {
+            try {
+                config.mode = Integer.parseInt(value);
+            } catch (NumberFormatException ignore) {
+            }
+        }
+
         value = WifiNative.getNetworkVariableCommand(netId, WifiConfiguration.wepTxKeyIdxVarName);
         config.wepTxKeyIndex = -1;
         if (!TextUtils.isEmpty(value)) {
diff --git a/wifi/java/android/net/wifi/WifiConfiguration.java b/wifi/java/android/net/wifi/WifiConfiguration.java
index 85a6f27..14be10d 100644
--- a/wifi/java/android/net/wifi/WifiConfiguration.java
+++ b/wifi/java/android/net/wifi/WifiConfiguration.java
@@ -211,6 +211,19 @@ public class WifiConfiguration implements Parcelable {
         public static final String[] strings = { "current", "disabled", "enabled" };
     }
 
+    public static class Mode {
+        private Mode() { }
+
+        /** this is an infrastructure network */
+        public static final int INFRASTRUCTURE = 0;
+        /** this is an ad-hoc network */
+        public static final int ADHOC = 1;
+
+        public static final String varName = "mode";
+
+        public static final String[] strings = { "infrastructure", "ad-hoc" };
+    }
+
     /** @hide */
     public static final int DISABLED_UNKNOWN_REASON                         = 0;
     /** @hide */
@@ -291,6 +304,12 @@ public class WifiConfiguration implements Parcelable {
     public boolean hiddenSSID;
 
     /**
+     * The mode this access point operates on (infrastructure or ad-hoc)
+     * @hide
+     */
+    public int mode;
+
+    /**
      * The set of key management protocols supported by this configuration.
      * See {@link KeyMgmt} for descriptions of the values.
      * Defaults to WPA-PSK WPA-EAP.
@@ -368,6 +387,7 @@ public class WifiConfiguration implements Parcelable {
         BSSID = null;
         priority = 0;
         hiddenSSID = false;
+        mode = Mode.INFRASTRUCTURE;
         disableReason = DISABLED_UNKNOWN_REASON;
         allowedKeyManagement = new BitSet();
         allowedProtocols = new BitSet();
@@ -542,6 +562,7 @@ public class WifiConfiguration implements Parcelable {
             wepTxKeyIndex = source.wepTxKeyIndex;
             priority = source.priority;
             hiddenSSID = source.hiddenSSID;
+            mode = source.mode;
             allowedKeyManagement   = (BitSet) source.allowedKeyManagement.clone();
             allowedProtocols       = (BitSet) source.allowedProtocols.clone();
             allowedAuthAlgorithms  = (BitSet) source.allowedAuthAlgorithms.clone();
@@ -570,6 +591,7 @@ public class WifiConfiguration implements Parcelable {
         dest.writeInt(wepTxKeyIndex);
         dest.writeInt(priority);
         dest.writeInt(hiddenSSID ? 1 : 0);
+        dest.writeInt(mode);
 
         writeBitSet(dest, allowedKeyManagement);
         writeBitSet(dest, allowedProtocols);
@@ -601,6 +623,7 @@ public class WifiConfiguration implements Parcelable {
                 config.wepTxKeyIndex = in.readInt();
                 config.priority = in.readInt();
                 config.hiddenSSID = in.readInt() != 0;
+                config.mode = in.readInt();
                 config.allowedKeyManagement   = readBitSet(in);
                 config.allowedProtocols       = readBitSet(in);
                 config.allowedAuthAlgorithms  = readBitSet(in);
diff --git a/wifi/java/android/net/wifi/WifiNative.java b/wifi/java/android/net/wifi/WifiNative.java
index 6ff1bc2..f4389ad 100644
--- a/wifi/java/android/net/wifi/WifiNative.java
+++ b/wifi/java/android/net/wifi/WifiNative.java
@@ -58,6 +58,12 @@ public class WifiNative {
 
     public native static boolean unloadDriver();
 
+    public native static boolean loadHotspotDriver();
+
+    public native static boolean isHotspotDriverLoaded();
+
+    public native static boolean unloadHotspotDriver();
+
     public native static boolean startSupplicant();
 
     public native static boolean startP2pSupplicant();
diff --git a/wifi/java/android/net/wifi/WifiStateMachine.java b/wifi/java/android/net/wifi/WifiStateMachine.java
index 82abe3a..f3b8f29 100644
--- a/wifi/java/android/net/wifi/WifiStateMachine.java
+++ b/wifi/java/android/net/wifi/WifiStateMachine.java
@@ -110,7 +110,7 @@ public class WifiStateMachine extends StateMachine {
     private static final boolean DBG = false;
 
     /* TODO: This is no more used with the hostapd code. Clean up */
-    private static final String SOFTAP_IFACE = "wl0.1";
+    private String mSoftApIface;
 
     private WifiMonitor mWifiMonitor;
     private INetworkManagementService mNwService;
@@ -583,6 +583,8 @@ public class WifiStateMachine extends StateMachine {
         mDefaultSupplicantScanIntervalMs = mContext.getResources().getInteger(
                 com.android.internal.R.integer.config_wifi_supplicant_scan_interval);
 
+        mSoftApIface = SystemProperties.get("wifi.ap.interface", "wl0.1");
+
         mContext.registerReceiver(
             new BroadcastReceiver() {
                 @Override
@@ -1178,14 +1180,14 @@ public class WifiStateMachine extends StateMachine {
            ip settings */
         InterfaceConfiguration ifcg = null;
         try {
-            ifcg = mNwService.getInterfaceConfig(mInterfaceName);
+            ifcg = mNwService.getInterfaceConfig(mTetherInterfaceName);
             if (ifcg != null) {
                 ifcg.addr = new LinkAddress(NetworkUtils.numericToInetAddress(
                             "0.0.0.0"), 0);
-                mNwService.setInterfaceConfig(mInterfaceName, ifcg);
+                mNwService.setInterfaceConfig(mTetherInterfaceName, ifcg);
             }
         } catch (Exception e) {
-            loge("Error resetting interface " + mInterfaceName + ", :" + e);
+            loge("Error resetting interface " + mTetherInterfaceName + ", :" + e);
         }
 
         if (mCm.untether(mTetherInterfaceName) != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
@@ -1768,12 +1770,12 @@ public class WifiStateMachine extends StateMachine {
         new Thread(new Runnable() {
             public void run() {
                 try {
-                    mNwService.startAccessPoint(config, mInterfaceName, SOFTAP_IFACE);
+                    mNwService.startAccessPoint(config, mInterfaceName, mSoftApIface);
                 } catch (Exception e) {
                     loge("Exception in softap start " + e);
                     try {
                         mNwService.stopAccessPoint(mInterfaceName);
-                        mNwService.startAccessPoint(config, mInterfaceName, SOFTAP_IFACE);
+                        mNwService.startAccessPoint(config, mInterfaceName, mSoftApIface);
                     } catch (Exception e1) {
                         loge("Exception in softap re-start " + e1);
                         sendMessage(CMD_START_AP_FAILURE);
@@ -1952,27 +1954,27 @@ public class WifiStateMachine extends StateMachine {
                     switch(message.arg1) {
                         case WIFI_STATE_ENABLING:
                             setWifiState(WIFI_STATE_ENABLING);
+                            if(WifiNative.loadDriver()) {
+                                if (DBG) log("Driver load successful");
+                                sendMessage(CMD_LOAD_DRIVER_SUCCESS);
+                            } else {
+                                if (DBG) log("Failed to load driver!");
+                                setWifiState(WIFI_STATE_UNKNOWN);
+                                sendMessage(CMD_LOAD_DRIVER_FAILURE);
+                            }
                             break;
                         case WIFI_AP_STATE_ENABLING:
                             setWifiApState(WIFI_AP_STATE_ENABLING);
+                            if(WifiNative.loadHotspotDriver()) {
+                                if (DBG) log("Hotspot driver load successful");
+                                sendMessage(CMD_LOAD_DRIVER_SUCCESS);
+                            } else {
+                                if (DBG) log("Failed to load Hotspot driver!");
+                                setWifiState(WIFI_AP_STATE_FAILED);
+                                sendMessage(CMD_LOAD_DRIVER_FAILURE);
+                            }
                             break;
                     }
-
-                    if(WifiNative.loadDriver()) {
-                        if (DBG) log("Driver load successful");
-                        sendMessage(CMD_LOAD_DRIVER_SUCCESS);
-                    } else {
-                        loge("Failed to load driver!");
-                        switch(message.arg1) {
-                            case WIFI_STATE_ENABLING:
-                                setWifiState(WIFI_STATE_UNKNOWN);
-                                break;
-                            case WIFI_AP_STATE_ENABLING:
-                                setWifiApState(WIFI_AP_STATE_FAILED);
-                                break;
-                        }
-                        sendMessage(CMD_LOAD_DRIVER_FAILURE);
-                    }
                     mWakeLock.release();
                 }
             }).start();
@@ -2078,34 +2080,33 @@ public class WifiStateMachine extends StateMachine {
                 public void run() {
                     if (DBG) log(getName() + message.toString() + "\n");
                     mWakeLock.acquire();
-                    if(WifiNative.unloadDriver()) {
-                        if (DBG) log("Driver unload successful");
-                        sendMessage(CMD_UNLOAD_DRIVER_SUCCESS);
-
-                        switch(message.arg1) {
-                            case WIFI_STATE_DISABLED:
-                            case WIFI_STATE_UNKNOWN:
+                    switch(message.arg1) {
+                        case WIFI_STATE_DISABLED:
+                        case WIFI_STATE_UNKNOWN:
+                            if(WifiNative.unloadDriver()) {
+                                if (DBG) log("Driver unload successful");
+                                sendMessage(CMD_UNLOAD_DRIVER_SUCCESS);
                                 setWifiState(message.arg1);
-                                break;
-                            case WIFI_AP_STATE_DISABLED:
-                            case WIFI_AP_STATE_FAILED:
-                                setWifiApState(message.arg1);
-                                break;
-                        }
-                    } else {
-                        loge("Failed to unload driver!");
-                        sendMessage(CMD_UNLOAD_DRIVER_FAILURE);
-
-                        switch(message.arg1) {
-                            case WIFI_STATE_DISABLED:
-                            case WIFI_STATE_UNKNOWN:
+                            } else {
+                                loge("Failed to unload driver!");
+                                sendMessage(CMD_UNLOAD_DRIVER_FAILURE);
                                 setWifiState(WIFI_STATE_UNKNOWN);
-                                break;
-                            case WIFI_AP_STATE_DISABLED:
-                            case WIFI_AP_STATE_FAILED:
+                            }
+
+                            setWifiState(message.arg1);
+                            break;
+                        case WIFI_AP_STATE_DISABLED:
+                        case WIFI_AP_STATE_FAILED:
+                            if(WifiNative.unloadHotspotDriver()) {
+                                if (DBG) log("Hotspot driver unload successful");
+                                sendMessage(CMD_UNLOAD_DRIVER_SUCCESS);
+                                setWifiApState(message.arg1);
+                            } else {
+                                loge("Failed to unload hotspot driver!");
+                                sendMessage(CMD_UNLOAD_DRIVER_FAILURE);
                                 setWifiApState(WIFI_AP_STATE_FAILED);
-                                break;
-                        }
+                            }
+                            break;
                     }
                     mWakeLock.release();
                 }
-- 
1.8.3.2

