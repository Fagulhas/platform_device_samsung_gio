From 6a886f1d7e4656357c946d31789f7b3c69764353 Mon Sep 17 00:00:00 2001
From: streambinder <davidepucci@hiddenhost.org>
Date: Wed, 25 Jun 2014 16:46:49 +0200
Subject: [PATCH] Unified patch: [*]Audio hacks and optimizations [*]Cleanments
 [*]Add FM-Radio support [*]Updated RIL [*]Fixed Mobile Data

---
 core/java/android/bluetooth/BluetoothAdapter.java  |   22 +
 core/java/android/hardware/fmradio/FmConfig.java   |  188 +
 core/java/android/hardware/fmradio/FmReceiver.java | 1704 +++++++++
 .../android/hardware/fmradio/FmReceiverJNI.java    |  176 +
 .../android/hardware/fmradio/FmRxControls.java     |  313 ++
 .../android/hardware/fmradio/FmRxEvCallbacks.java  |   46 +
 .../hardware/fmradio/FmRxEvCallbacksAdaptor.java   |   52 +
 .../android/hardware/fmradio/FmRxEventListner.java |  153 +
 .../java/android/hardware/fmradio/FmRxRdsData.java |  204 +
 .../android/hardware/fmradio/FmTransceiver.java    |  447 +++
 .../android/hardware/fmradio/FmTransmitter.java    |  584 +++
 core/java/android/net/MobileDataStateTracker.java  |   23 +-
 core/java/android/provider/Settings.java           |    6 +
 core/java/android/util/TimeUtils.java              |   46 +
 core/jni/Android.mk                                |   46 +
 core/jni/AndroidRuntime.cpp                        |    7 +
 core/jni/android_hardware_fm_bcm4325.cpp           |  518 +++
 core/res/res/values/config.xml                     |   13 +
 data/sounds/OriginalAudio.mk                       |    5 +
 include/media/AudioRecord.h                        |    6 +-
 include/media/AudioSystem.h                        |   59 +-
 include/media/IAudioFlinger.h                      |   11 +-
 include/media/IMediaPlayer.h                       |    3 +
 include/media/IMediaPlayerService.h                |    6 +
 include/media/IMediaRecorder.h                     |    1 +
 include/media/IOMX.h                               |   42 +
 include/media/MediaPlayerInterface.h               |    6 +-
 include/media/MediaProfiles.h                      |    8 +-
 include/media/MediaRecorderBase.h                  |    1 +
 include/media/OverlayRenderer.h                    |  127 +
 include/media/PVMediaRecorder.h                    |    1 +
 include/media/mediaplayer.h                        |    3 +
 include/media/mediarecorder.h                      |   13 +-
 include/media/stagefright/AudioPlayer.h            |    8 +-
 include/media/stagefright/AudioSource.h            |    2 +-
 include/media/stagefright/CameraSource.h           |   13 +
 include/media/stagefright/ColorConverter.h         |   36 +
 include/media/stagefright/HardwareAPI.h            |   18 +
 include/media/stagefright/MediaBuffer.h            |    1 +
 include/media/stagefright/MediaDefs.h              |    8 +
 include/media/stagefright/MediaErrors.h            |    3 +
 include/media/stagefright/MediaExtractor.h         |   16 +-
 include/media/stagefright/MediaSource.h            |   27 +
 include/media/stagefright/MetaData.h               |   19 +
 include/media/stagefright/OMXCodec.h               |  117 +-
 include/media/stagefright/Utils.h                  |   38 +
 include/media/stagefright/VideoRenderer.h          |   23 +
 include/media/stagefright/openmax/OMX_Index.h      |    1 -
 include/ui/Overlay.h                               |    1 +
 libs/ui/Overlay.cpp                                |    6 +
 libs/utils/Android.mk                              |    2 +-
 media/libmedia/Android.mk                          |   16 +
 media/libmedia/AudioRecord.cpp                     |   66 +
 media/libmedia/AudioSystem.cpp                     |   32 +
 media/libmedia/AudioTrack.cpp                      |   76 +-
 media/libmedia/IAudioFlinger.cpp                   |   45 +-
 media/libmedia/IMediaPlayer.cpp                    |   23 +-
 media/libmedia/IMediaPlayerService.cpp             |   27 +-
 media/libmedia/IMediaRecorder.cpp                  |   17 +
 media/libmedia/IOMX.cpp                            |  155 +
 media/libmedia/MediaProfiles.cpp                   |    8 +-
 media/libmedia/MediaScanner.cpp                    |   54 +-
 media/libmedia/MediaScannerClient.cpp              |   43 +-
 media/libmedia/OverlayRenderer.cpp                 |  608 +++
 media/libmedia/mediaplayer.cpp                     |   32 +-
 media/libmedia/mediarecorder.cpp                   |   22 +
 media/libmediaplayerservice/Android.mk             |   26 +
 media/libmediaplayerservice/FLACPlayer.cpp         |  578 +++
 media/libmediaplayerservice/FLACPlayer.h           |  101 +
 media/libmediaplayerservice/MediaPlayerService.cpp |   65 +
 media/libmediaplayerservice/MediaPlayerService.h   |   13 +-
 .../libmediaplayerservice/MediaRecorderClient.cpp  |   22 +-
 media/libmediaplayerservice/MediaRecorderClient.h  |    2 +
 .../MetadataRetrieverClient.cpp                    |   14 +
 media/libmediaplayerservice/StagefrightPlayer.cpp  |    6 +
 media/libmediaplayerservice/StagefrightPlayer.h    |    3 +
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  122 +-
 media/libmediaplayerservice/StagefrightRecorder.h  |    1 +
 media/libstagefright/AMRExtractor.cpp              |  190 +-
 media/libstagefright/ASFExtractor.cpp              |  179 +
 media/libstagefright/Android.mk                    |   60 +-
 media/libstagefright/AudioPlayer.cpp               |   72 +-
 media/libstagefright/AudioSource.cpp               |    2 +-
 media/libstagefright/AwesomePlayer.cpp             |  756 +++-
 media/libstagefright/CameraSource.cpp              |  161 +-
 media/libstagefright/DataSource.cpp                |    9 +
 media/libstagefright/MPEG4Extractor.cpp            |  707 +++-
 media/libstagefright/MPEG4Writer.cpp               |  342 +-
 media/libstagefright/MediaBuffer.cpp               |   19 +
 media/libstagefright/MediaDefs.cpp                 |    9 +
 media/libstagefright/MediaExtractor.cpp            |   14 +
 media/libstagefright/MediaSource.cpp               |   20 +
 media/libstagefright/NOTICE.cm                     |  192 +
 media/libstagefright/NuCachedSource2.cpp           |   19 +-
 media/libstagefright/NuHTTPDataSource.cpp          |    2 +-
 media/libstagefright/OMXCodec.cpp                  | 2245 ++++++++++-
 media/libstagefright/SampleTable.cpp               |   74 +
 media/libstagefright/StagefrightMediaScanner.cpp   |   79 +-
 .../StagefrightMetadataRetriever.cpp               |  115 +-
 media/libstagefright/TISEIMessagesParser.cpp       |  560 +++
 media/libstagefright/TIVideoConfigParser.cpp       |  596 +++
 media/libstagefright/WAVExtractor.cpp              |   18 +-
 .../codecs/aacdec/get_prog_config.cpp              |    2 +-
 .../codecs/aacdec/pvmp4audiodecoderframe.cpp       |   11 +-
 media/libstagefright/codecs/aacenc/AACEncoder.cpp  |   14 +-
 media/libstagefright/codecs/aacenc/Android.mk      |    2 +-
 .../codecs/aacenc/SampleCode/AAC_E_SAMPLES.c       |  566 +--
 .../codecs/aacenc/SampleCode/Android.mk            |    8 +-
 .../codecs/aacenc/SampleCode/eclair/Makefile       |  110 +-
 .../libstagefright/codecs/aacenc/SampleCode/ms.mk  |   46 +-
 media/libstagefright/codecs/aacenc/Tools/doit.mk   |    8 +-
 media/libstagefright/codecs/aacenc/Tools/eclair.mk |   20 +-
 .../codecs/aacenc/basic_op/basic_op.h              | 2308 ++++++------
 .../codecs/aacenc/basic_op/basicop2.c              | 3240 ++++++++--------
 .../codecs/aacenc/basic_op/oper_32b.c              |  358 +-
 .../codecs/aacenc/basic_op/oper_32b.h              |  138 +-
 .../codecs/aacenc/basic_op/typedef.h               |   44 +-
 .../codecs/aacenc/basic_op/typedefs.h              |  264 +-
 .../codecs/aacenc/build/eclair/ARMV5E/Makefile     |  110 +-
 .../codecs/aacenc/build/eclair/ARMV7/Makefile      |  110 +-
 .../codecs/aacenc/build/eclair/makefile            |    2 +-
 media/libstagefright/codecs/aacenc/build/ms.mk     |   84 +-
 media/libstagefright/codecs/aacenc/inc/aac_rom.h   |   94 +-
 .../libstagefright/codecs/aacenc/inc/aacenc_core.h |  124 +-
 media/libstagefright/codecs/aacenc/inc/adj_thr.h   |   42 +-
 .../codecs/aacenc/inc/adj_thr_data.h               |   42 +-
 media/libstagefright/codecs/aacenc/inc/band_nrg.h  |   40 +-
 media/libstagefright/codecs/aacenc/inc/bit_cnt.h   |   42 +-
 media/libstagefright/codecs/aacenc/inc/bitbuffer.h |   40 +-
 media/libstagefright/codecs/aacenc/inc/bitenc.h    |   46 +-
 .../codecs/aacenc/inc/block_switch.h               |   40 +-
 .../libstagefright/codecs/aacenc/inc/channel_map.h |   40 +-
 media/libstagefright/codecs/aacenc/inc/config.h    |   68 +-
 media/libstagefright/codecs/aacenc/inc/dyn_bits.h  |   40 +-
 media/libstagefright/codecs/aacenc/inc/grp_data.h  |   40 +-
 media/libstagefright/codecs/aacenc/inc/interface.h |   50 +-
 media/libstagefright/codecs/aacenc/inc/line_pe.h   |   46 +-
 media/libstagefright/codecs/aacenc/inc/memalign.h  |   70 +-
 media/libstagefright/codecs/aacenc/inc/ms_stereo.h |   40 +-
 .../codecs/aacenc/inc/pre_echo_control.h           |   40 +-
 .../codecs/aacenc/inc/psy_configuration.h          |   54 +-
 media/libstagefright/codecs/aacenc/inc/psy_const.h |   50 +-
 media/libstagefright/codecs/aacenc/inc/psy_data.h  |   40 +-
 media/libstagefright/codecs/aacenc/inc/psy_main.h  |   46 +-
 media/libstagefright/codecs/aacenc/inc/qc_data.h   |   42 +-
 media/libstagefright/codecs/aacenc/inc/qc_main.h   |   42 +-
 media/libstagefright/codecs/aacenc/inc/quantize.h  |   42 +-
 media/libstagefright/codecs/aacenc/inc/sf_estim.h  |   42 +-
 media/libstagefright/codecs/aacenc/inc/spreading.h |   42 +-
 media/libstagefright/codecs/aacenc/inc/stat_bits.h |   42 +-
 media/libstagefright/codecs/aacenc/inc/tns.h       |   42 +-
 media/libstagefright/codecs/aacenc/inc/tns_func.h  |   42 +-
 media/libstagefright/codecs/aacenc/inc/tns_param.h |   42 +-
 media/libstagefright/codecs/aacenc/inc/transform.h |   42 +-
 media/libstagefright/codecs/aacenc/src/aac_rom.c   | 2880 +++++++--------
 media/libstagefright/codecs/aacenc/src/aacenc.c    |  944 ++---
 .../libstagefright/codecs/aacenc/src/aacenc_core.c |   96 +-
 media/libstagefright/codecs/aacenc/src/adj_thr.c   |  506 +--
 .../aacenc/src/asm/ARMV5E/AutoCorrelation_v5.s     |  334 +-
 .../aacenc/src/asm/ARMV5E/CalcWindowEnergy_v5.s    |  224 +-
 .../codecs/aacenc/src/asm/ARMV5E/PrePostMDCT_v5.s  |  260 +-
 .../codecs/aacenc/src/asm/ARMV5E/R4R8First_v5.s    |  502 +--
 .../codecs/aacenc/src/asm/ARMV5E/Radix4FFT_v5.s    |  336 +-
 .../codecs/aacenc/src/asm/ARMV5E/band_nrg_v5.s     |  408 +-
 .../codecs/aacenc/src/asm/ARMV7/PrePostMDCT_v7.s   |  268 +-
 .../codecs/aacenc/src/asm/ARMV7/R4R8First_v7.s     |  290 +-
 .../codecs/aacenc/src/asm/ARMV7/Radix4FFT_v7.s     |  284 +-
 media/libstagefright/codecs/aacenc/src/band_nrg.c  |   84 +-
 media/libstagefright/codecs/aacenc/src/bit_cnt.c   | 1246 +++----
 media/libstagefright/codecs/aacenc/src/bitbuffer.c |  106 +-
 media/libstagefright/codecs/aacenc/src/bitenc.c    |  204 +-
 .../codecs/aacenc/src/block_switch.c               |  234 +-
 .../libstagefright/codecs/aacenc/src/channel_map.c |   86 +-
 media/libstagefright/codecs/aacenc/src/dyn_bits.c  |  208 +-
 media/libstagefright/codecs/aacenc/src/grp_data.c  |  114 +-
 media/libstagefright/codecs/aacenc/src/interface.c |   86 +-
 media/libstagefright/codecs/aacenc/src/line_pe.c   |  110 +-
 media/libstagefright/codecs/aacenc/src/memalign.c  |   11 +-
 media/libstagefright/codecs/aacenc/src/ms_stereo.c |  110 +-
 .../codecs/aacenc/src/pre_echo_control.c           |   70 +-
 .../codecs/aacenc/src/psy_configuration.c          |  232 +-
 media/libstagefright/codecs/aacenc/src/psy_main.c  |  292 +-
 media/libstagefright/codecs/aacenc/src/qc_main.c   |  252 +-
 media/libstagefright/codecs/aacenc/src/quantize.c  |  458 +--
 media/libstagefright/codecs/aacenc/src/sf_estim.c  |  616 ++--
 media/libstagefright/codecs/aacenc/src/spreading.c |   90 +-
 media/libstagefright/codecs/aacenc/src/stat_bits.c |  108 +-
 media/libstagefright/codecs/aacenc/src/tns.c       |  390 +-
 media/libstagefright/codecs/aacenc/src/transform.c |  812 ++--
 .../codecs/amrnb/dec/AMRNBDecoder.cpp              |    8 +-
 media/libstagefright/codecs/amrwb/AMRWBDecoder.cpp |   21 +-
 media/libstagefright/codecs/amrwbenc/Android.mk    |    4 +-
 .../codecs/amrwbenc/SampleCode/AMRWB_E_SAMPLE.c    |  728 ++--
 .../codecs/amrwbenc/SampleCode/Android.mk          |    8 +-
 .../codecs/amrwbenc/SampleCode/eclair/Makefile     |  112 +-
 .../codecs/amrwbenc/SampleCode/ms.mk               |   48 +-
 .../codecs/amrwbenc/build/eclair/ARMV5E/Makefile   |  106 +-
 .../codecs/amrwbenc/build/eclair/ARMV7/Makefile    |  106 +-
 .../codecs/amrwbenc/build/eclair/makefile          |    2 +-
 .../codecs/amrwbenc/build/eclair/ms.mk             |   86 +-
 media/libstagefright/codecs/amrwbenc/inc/acelp.h   | 1042 +++---
 .../libstagefright/codecs/amrwbenc/inc/basic_op.h  | 2188 +++++------
 media/libstagefright/codecs/amrwbenc/inc/bits.h    |  184 +-
 media/libstagefright/codecs/amrwbenc/inc/cnst.h    |  162 +-
 .../libstagefright/codecs/amrwbenc/inc/cod_main.h  |  206 +-
 media/libstagefright/codecs/amrwbenc/inc/dtx.h     |  230 +-
 .../libstagefright/codecs/amrwbenc/inc/grid100.tab |  106 +-
 .../codecs/amrwbenc/inc/ham_wind.tab               |  146 +-
 .../libstagefright/codecs/amrwbenc/inc/homing.tab  |  246 +-
 .../libstagefright/codecs/amrwbenc/inc/isp_isf.tab |  124 +-
 .../codecs/amrwbenc/inc/lag_wind.tab               |  162 +-
 media/libstagefright/codecs/amrwbenc/inc/log2.h    |  124 +-
 .../libstagefright/codecs/amrwbenc/inc/log2_tab.h  |   70 +-
 media/libstagefright/codecs/amrwbenc/inc/main.h    |   90 +-
 media/libstagefright/codecs/amrwbenc/inc/math_op.h |  110 +-
 .../libstagefright/codecs/amrwbenc/inc/mem_align.h |   70 +-
 .../libstagefright/codecs/amrwbenc/inc/mime_io.tab |  736 ++--
 .../libstagefright/codecs/amrwbenc/inc/oper_32b.h  |   62 +-
 media/libstagefright/codecs/amrwbenc/inc/p_med_o.h |  104 +-
 .../codecs/amrwbenc/inc/p_med_ol.tab               |   94 +-
 .../libstagefright/codecs/amrwbenc/inc/q_gain2.tab |  456 +--
 media/libstagefright/codecs/amrwbenc/inc/q_pulse.h |  132 +-
 .../libstagefright/codecs/amrwbenc/inc/qisf_ns.tab |  694 ++--
 .../codecs/amrwbenc/inc/qpisf_2s.tab               | 2720 +++++++-------
 media/libstagefright/codecs/amrwbenc/inc/stream.h  |   94 +-
 media/libstagefright/codecs/amrwbenc/inc/typedef.h |  130 +-
 .../libstagefright/codecs/amrwbenc/inc/typedefs.h  |  422 +--
 media/libstagefright/codecs/amrwbenc/inc/wb_vad.h  |  156 +-
 .../libstagefright/codecs/amrwbenc/inc/wb_vad_c.h  |  218 +-
 .../codecs/amrwbenc/src/asm/ARMV5E/Deemph_32_opt.s |  208 +-
 .../codecs/amrwbenc/src/asm/ARMV5E/Dot_p_opt.s     |  160 +-
 .../amrwbenc/src/asm/ARMV5E/Filt_6k_7k_opt.s       |  370 +-
 .../codecs/amrwbenc/src/asm/ARMV5E/Norm_Corr_opt.s |   50 +-
 .../amrwbenc/src/asm/ARMV5E/Syn_filt_32_opt.s      |  452 +--
 .../codecs/amrwbenc/src/asm/ARMV5E/convolve_opt.s  |   56 +-
 .../codecs/amrwbenc/src/asm/ARMV5E/cor_h_vec_opt.s |  302 +-
 .../amrwbenc/src/asm/ARMV5E/pred_lt4_1_opt.s       |  920 ++---
 .../amrwbenc/src/asm/ARMV5E/residu_asm_opt.s       |  456 +--
 .../codecs/amrwbenc/src/asm/ARMV5E/scale_sig_opt.s |  150 +-
 .../codecs/amrwbenc/src/asm/ARMV5E/syn_filt_opt.s  |  476 +--
 .../codecs/amrwbenc/src/asm/ARMV7/Deemph_32_neon.s |  204 +-
 .../codecs/amrwbenc/src/asm/ARMV7/Dot_p_neon.s     |  254 +-
 .../amrwbenc/src/asm/ARMV7/Filt_6k_7k_neon.s       |  456 +--
 .../codecs/amrwbenc/src/asm/ARMV7/Norm_Corr_neon.s |   56 +-
 .../amrwbenc/src/asm/ARMV7/Syn_filt_32_neon.s      |  266 +-
 .../codecs/amrwbenc/src/asm/ARMV7/convolve_neon.s  |   70 +-
 .../codecs/amrwbenc/src/asm/ARMV7/cor_h_vec_neon.s |  302 +-
 .../amrwbenc/src/asm/ARMV7/pred_lt4_1_neon.s       |  200 +-
 .../amrwbenc/src/asm/ARMV7/residu_asm_neon.s       |   52 +-
 .../codecs/amrwbenc/src/asm/ARMV7/scale_sig_neon.s |  276 +-
 .../codecs/amrwbenc/src/asm/ARMV7/syn_filt_neon.s  |  212 +-
 .../libstagefright/codecs/amrwbenc/src/autocorr.c  |  254 +-
 media/libstagefright/codecs/amrwbenc/src/az_isp.c  |  536 +--
 media/libstagefright/codecs/amrwbenc/src/bits.c    |  420 +--
 media/libstagefright/codecs/amrwbenc/src/c2t64fx.c |  594 +--
 media/libstagefright/codecs/amrwbenc/src/c4t64fx.c | 2086 +++++------
 .../libstagefright/codecs/amrwbenc/src/convolve.c  |  218 +-
 media/libstagefright/codecs/amrwbenc/src/cor_h_x.c |  254 +-
 media/libstagefright/codecs/amrwbenc/src/decim54.c |  292 +-
 media/libstagefright/codecs/amrwbenc/src/deemph.c  |  234 +-
 media/libstagefright/codecs/amrwbenc/src/dtx.c     | 1210 +++---
 media/libstagefright/codecs/amrwbenc/src/g_pitch.c |  158 +-
 media/libstagefright/codecs/amrwbenc/src/gpclip.c  |  220 +-
 media/libstagefright/codecs/amrwbenc/src/homing.c  |   92 +-
 media/libstagefright/codecs/amrwbenc/src/hp400.c   |  212 +-
 media/libstagefright/codecs/amrwbenc/src/hp50.c    |  212 +-
 media/libstagefright/codecs/amrwbenc/src/hp6k.c    |  186 +-
 media/libstagefright/codecs/amrwbenc/src/hp_wsp.c  |  296 +-
 media/libstagefright/codecs/amrwbenc/src/int_lpc.c |  132 +-
 media/libstagefright/codecs/amrwbenc/src/isp_az.c  |  494 +--
 media/libstagefright/codecs/amrwbenc/src/isp_isf.c |  182 +-
 .../libstagefright/codecs/amrwbenc/src/lag_wind.c  |   98 +-
 .../libstagefright/codecs/amrwbenc/src/levinson.c  |  500 +--
 media/libstagefright/codecs/amrwbenc/src/log2.c    |  222 +-
 media/libstagefright/codecs/amrwbenc/src/lp_dec2.c |  140 +-
 media/libstagefright/codecs/amrwbenc/src/math_op.c |  438 +--
 .../libstagefright/codecs/amrwbenc/src/mem_align.c |    2 +-
 .../libstagefright/codecs/amrwbenc/src/oper_32b.c  |  446 +--
 .../libstagefright/codecs/amrwbenc/src/p_med_ol.c  |  512 +--
 .../libstagefright/codecs/amrwbenc/src/pit_shrp.c  |   98 +-
 .../libstagefright/codecs/amrwbenc/src/pitch_f4.c  |  648 ++--
 .../libstagefright/codecs/amrwbenc/src/pred_lt4.c  |  240 +-
 media/libstagefright/codecs/amrwbenc/src/preemph.c |  176 +-
 media/libstagefright/codecs/amrwbenc/src/q_gain2.c |  692 ++--
 media/libstagefright/codecs/amrwbenc/src/q_pulse.c |  800 ++--
 media/libstagefright/codecs/amrwbenc/src/qisf_ns.c |  222 +-
 .../libstagefright/codecs/amrwbenc/src/qpisf_2s.c  | 1084 +++---
 media/libstagefright/codecs/amrwbenc/src/random.c  |   66 +-
 media/libstagefright/codecs/amrwbenc/src/residu.c  |  134 +-
 media/libstagefright/codecs/amrwbenc/src/scale.c   |  114 +-
 media/libstagefright/codecs/amrwbenc/src/stream.c  |  116 +-
 .../libstagefright/codecs/amrwbenc/src/syn_filt.c  |  320 +-
 .../libstagefright/codecs/amrwbenc/src/updt_tar.c  |   98 +-
 media/libstagefright/codecs/amrwbenc/src/util.c    |  148 +-
 .../codecs/amrwbenc/src/voAMRWBEnc.c               | 3882 ++++++++++----------
 .../libstagefright/codecs/amrwbenc/src/voicefac.c  |  184 +-
 media/libstagefright/codecs/amrwbenc/src/wb_vad.c  | 1616 ++++----
 .../libstagefright/codecs/amrwbenc/src/weight_a.c  |   96 +-
 media/libstagefright/codecs/avc/common/src/dpb.cpp |   12 +-
 media/libstagefright/codecs/avc/dec/AVCDecoder.cpp |    5 +-
 media/libstagefright/codecs/common/Config.mk       |   48 +-
 media/libstagefright/codecs/common/cmnMemory.c     |  144 +-
 .../codecs/common/include/cmnMemory.h              |  212 +-
 media/libstagefright/codecs/common/include/voAAC.h |  148 +-
 .../libstagefright/codecs/common/include/voAMRWB.h |  174 +-
 .../libstagefright/codecs/common/include/voAudio.h |  346 +-
 .../libstagefright/codecs/common/include/voIndex.h |  386 +-
 .../libstagefright/codecs/common/include/voType.h  |  442 +--
 .../libstagefright/codecs/m4v_h263/dec/Android.mk  |    4 +
 .../codecs/m4v_h263/dec/M4vH263Decoder.cpp         |    8 +-
 media/libstagefright/codecs/mp3dec/Android.mk      |    5 +
 media/libstagefright/codecs/mp3dec/MP3Decoder.cpp  |  388 +-
 .../codecs/mp3dec/src/pvmp3_decode_header.cpp      |    2 +-
 media/libstagefright/colorconversion/Android.mk    |    8 +
 .../colorconversion/ColorConverter.cpp             |  324 ++
 .../colorconversion/SoftwareRenderer.cpp           |    8 +
 media/libstagefright/httplive/M3UParser.cpp        |    2 +-
 media/libstagefright/id3/Android.mk                |    3 +
 media/libstagefright/include/AACEncoder.h          |    2 +-
 media/libstagefright/include/AMRExtractor.h        |   16 +-
 media/libstagefright/include/ASFExtractor.h        |   93 +
 media/libstagefright/include/AwesomePlayer.h       |   54 +-
 media/libstagefright/include/MP3Decoder.h          |    3 +
 media/libstagefright/include/NuCachedSource2.h     |    5 +
 media/libstagefright/include/OMX.h                 |   45 +
 media/libstagefright/include/OMXNodeInstance.h     |    9 +
 media/libstagefright/include/SampleTable.h         |   14 +-
 media/libstagefright/include/SoftwareRenderer.h    |    5 +
 media/libstagefright/include/TISEIMessagesParser.h |   88 +
 .../libstagefright/matroska/MatroskaExtractor.cpp  |    1 +
 media/libstagefright/mpeg2ts/ESQueue.cpp           |    7 +-
 media/libstagefright/omx/Android.mk                |   13 +
 media/libstagefright/omx/OMX.cpp                   |  171 +-
 media/libstagefright/omx/OMXMaster.cpp             |    3 +
 media/libstagefright/omx/OMXNodeInstance.cpp       |  105 +-
 media/libstagefright/omx/OMXRenderer.h             |    8 +
 media/libstagefright/omx/tests/OMXHarness.cpp      |    2 +
 media/libstagefright/omx/tests/OMXHarness.h        |    1 +
 media/libstagefright/rtsp/ASessionDescription.cpp  |    2 +-
 media/libstagefright/rtsp/MyHandler.h              |   98 +-
 obex/javax/obex/ClientOperation.java               |   59 +-
 obex/javax/obex/ClientSession.java                 |  111 +-
 obex/javax/obex/HeaderSet.java                     |    2 +-
 obex/javax/obex/ObexByteBuffer.java                |  326 ++
 obex/javax/obex/ObexHelper.java                    |   64 +-
 obex/javax/obex/ObexSession.java                   |    2 +-
 obex/javax/obex/Operation.java                     |    4 +-
 obex/javax/obex/PrivateInputStream.java            |   42 +-
 obex/javax/obex/PrivateOutputStream.java           |   41 +-
 obex/javax/obex/ServerOperation.java               |  108 +-
 obex/javax/obex/ServerSession.java                 |   96 +-
 opengl/include/EGL/eglext.h                        |    8 +
 opengl/java/android/opengl/GLSurfaceView.java      |    8 +-
 opengl/libagl/Android.mk                           |   12 +-
 opengl/libagl/TextureObjectManager.cpp             |    3 +
 opengl/libagl/TextureObjectManager.h               |    3 +
 opengl/libagl/array.cpp                            |    9 +
 opengl/libagl/copybit.cpp                          |  618 ++++
 opengl/libagl/copybit.h                            |   75 +
 opengl/libagl/egl.cpp                              |   69 +-
 opengl/libagl/state.cpp                            |   38 +
 opengl/libagl/texture.cpp                          |   27 +-
 opengl/libs/Android.mk                             |   22 +
 opengl/libs/EGL/Loader.cpp                         |   43 +
 opengl/libs/EGL/egl.cpp                            |   81 +
 opengl/libs/GLES2/gl2.cpp                          |   11 +-
 opengl/libs/GLES_CM/gl.cpp                         |   11 +-
 opengl/tests/gl_jni/jni/gl_code.cpp                |    1 -
 services/audioflinger/A2dpAudioInterface.cpp       |    7 +
 services/audioflinger/A2dpAudioInterface.h         |    3 +
 services/audioflinger/AudioDumpInterface.h         |    5 +-
 services/audioflinger/AudioFlinger.cpp             |   92 +
 services/audioflinger/AudioFlinger.h               |   10 +
 services/audioflinger/AudioHardwareGeneric.cpp     |    8 +
 services/audioflinger/AudioHardwareGeneric.h       |    3 +
 services/audioflinger/AudioHardwareStub.cpp        |    7 +
 services/audioflinger/AudioHardwareStub.h          |    3 +
 services/audioflinger/AudioPolicyManagerBase.cpp   |   48 +
 services/audioflinger/AudioPolicyService.cpp       |   52 +
 services/audioflinger/AudioPolicyService.h         |   18 +-
 .../android/telephony/NeighboringCellInfo.java     |    2 +
 .../java/android/telephony/PhoneNumberUtils.java   |   35 +-
 telephony/java/android/telephony/ServiceState.java |   16 +
 .../java/android/telephony/TelephonyManager.java   |   25 +
 .../com/android/internal/telephony/AdnRecord.java  |    2 +-
 .../android/internal/telephony/AdnRecordCache.java |   19 +-
 .../android/internal/telephony/CallManager.java    |   81 +-
 .../android/internal/telephony/DataConnection.java |   24 +-
 .../com/android/internal/telephony/HTCRIL.java     |   68 +
 .../com/android/internal/telephony/IccCard.java    |   23 +-
 .../internal/telephony/IccCardApplication.java     |    1 +
 .../android/internal/telephony/IccConstants.java   |    1 +
 .../android/internal/telephony/IccFileHandler.java |  213 +-
 .../telephony/IccPhoneBookInterfaceManager.java    |   58 +-
 .../com/android/internal/telephony/IccUtils.java   |   49 +-
 .../android/internal/telephony/LGEQualcommRIL.java |  417 +++
 .../com/android/internal/telephony/LGEStarRIL.java | 1170 ++++++
 .../com/android/internal/telephony/MccTable.java   |  190 +-
 .../android/internal/telephony/MotoTegraRIL.java   |   85 +
 .../internal/telephony/MotoTegraWorldRIL.java      |   49 +
 .../internal/telephony/MotoWrigley3GRIL.java       |  165 +
 .../java/com/android/internal/telephony/Phone.java |   11 +
 .../com/android/internal/telephony/PhoneBase.java  |   20 +
 .../android/internal/telephony/PhoneFactory.java   |   34 +-
 .../com/android/internal/telephony/PhoneProxy.java |   14 +
 .../internal/telephony/QualcommNoSimReadyRIL.java  |  767 ++++
 .../java/com/android/internal/telephony/RIL.java   |  163 +-
 .../com/android/internal/telephony/SamsungRIL.java | 1058 ++++++
 .../com/android/internal/telephony/SemcRIL.java    |  453 +++
 .../internal/telephony/ServiceStateTracker.java    |    3 +
 .../android/internal/telephony/SimRegionCache.java |   51 +
 .../android/internal/telephony/WapPushOverSms.java |    5 +
 .../android/internal/telephony/WspTypeDecoder.java |    2 +
 .../android/internal/telephony/cdma/CDMAPhone.java |   25 +-
 .../telephony/cdma/CdmaDataConnectionTracker.java  |    4 +
 .../internal/telephony/cdma/CdmaSMSDispatcher.java |   72 +-
 .../telephony/cdma/CdmaServiceStateTracker.java    |  160 +-
 .../cdma/RuimPhoneBookInterfaceManager.java        |   11 +-
 .../internal/telephony/cdma/RuimRecords.java       |   44 +
 .../internal/telephony/cdma/SmsMessage.java        |  177 +-
 .../internal/telephony/cdma/sms/BearerData.java    |   20 +-
 .../telephony/cdma/sms/CdmaSmsSubaddress.java      |   27 +
 .../internal/telephony/cdma/sms/SmsEnvelope.java   |   12 +-
 .../android/internal/telephony/gsm/GSMPhone.java   |    8 +-
 .../telephony/gsm/GsmDataConnectionTracker.java    |    5 +-
 .../telephony/gsm/GsmServiceStateTracker.java      |   53 +-
 .../internal/telephony/gsm/SIMFileHandler.java     |    1 +
 .../android/internal/telephony/gsm/SIMRecords.java |  135 +-
 .../gsm/SimPhoneBookInterfaceManager.java          |   11 +-
 .../android/internal/telephony/gsm/SmsMessage.java |   50 +-
 .../internal/telephony/gsm/SpnOverride.java        |   54 +-
 .../telephony/gsm/SuppServiceNotification.java     |    3 +
 .../telephony/gsm/UsimPhoneBookManager.java        |   25 +-
 .../internal/telephony/gsm/stk/CommandDetails.java |    5 +-
 .../android/internal/telephony/sip/SipPhone.java   |    5 +-
 .../android/internal/telephony/AdnRecordTest.java  |   12 +
 .../internal/telephony/SMSDispatcherTest.java      |   21 +
 .../android/internal/telephony/SimUtilsTest.java   |   24 +
 tools/aapt/Android.mk                              |    2 +-
 439 files changed, 54825 insertions(+), 32854 deletions(-)
 create mode 100644 core/java/android/hardware/fmradio/FmConfig.java
 create mode 100644 core/java/android/hardware/fmradio/FmReceiver.java
 create mode 100644 core/java/android/hardware/fmradio/FmReceiverJNI.java
 create mode 100644 core/java/android/hardware/fmradio/FmRxControls.java
 create mode 100644 core/java/android/hardware/fmradio/FmRxEvCallbacks.java
 create mode 100644 core/java/android/hardware/fmradio/FmRxEvCallbacksAdaptor.java
 create mode 100644 core/java/android/hardware/fmradio/FmRxEventListner.java
 create mode 100644 core/java/android/hardware/fmradio/FmRxRdsData.java
 create mode 100644 core/java/android/hardware/fmradio/FmTransceiver.java
 create mode 100644 core/java/android/hardware/fmradio/FmTransmitter.java
 create mode 100644 core/jni/android_hardware_fm_bcm4325.cpp
 create mode 100644 include/media/OverlayRenderer.h
 create mode 100644 media/libmedia/OverlayRenderer.cpp
 create mode 100644 media/libmediaplayerservice/FLACPlayer.cpp
 create mode 100644 media/libmediaplayerservice/FLACPlayer.h
 mode change 100644 => 100755 media/libmediaplayerservice/StagefrightRecorder.cpp
 create mode 100644 media/libstagefright/ASFExtractor.cpp
 mode change 100644 => 100755 media/libstagefright/MPEG4Writer.cpp
 create mode 100644 media/libstagefright/NOTICE.cm
 mode change 100644 => 100755 media/libstagefright/NuCachedSource2.cpp
 create mode 100644 media/libstagefright/TISEIMessagesParser.cpp
 create mode 100644 media/libstagefright/TIVideoConfigParser.cpp
 mode change 100644 => 100755 media/libstagefright/codecs/aacenc/AACEncoder.cpp
 create mode 100644 media/libstagefright/include/ASFExtractor.h
 create mode 100644 media/libstagefright/include/TISEIMessagesParser.h
 create mode 100644 obex/javax/obex/ObexByteBuffer.java
 create mode 100644 opengl/libagl/copybit.cpp
 create mode 100644 opengl/libagl/copybit.h
 create mode 100644 telephony/java/com/android/internal/telephony/HTCRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/LGEQualcommRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/LGEStarRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/MotoTegraRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/MotoTegraWorldRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/QualcommNoSimReadyRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SamsungRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SemcRIL.java
 create mode 100644 telephony/java/com/android/internal/telephony/SimRegionCache.java
 mode change 100644 => 100755 telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
 mode change 100644 => 100755 telephony/java/com/android/internal/telephony/cdma/RuimRecords.java
 mode change 100755 => 100644 telephony/java/com/android/internal/telephony/cdma/SmsMessage.java
 create mode 100644 telephony/java/com/android/internal/telephony/cdma/sms/CdmaSmsSubaddress.java
 mode change 100644 => 100755 telephony/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
 mode change 100755 => 100644 telephony/java/com/android/internal/telephony/sip/SipPhone.java

diff --git a/core/java/android/bluetooth/BluetoothAdapter.java b/core/java/android/bluetooth/BluetoothAdapter.java
index a7175e3..6ec4bdc 100644
--- a/core/java/android/bluetooth/BluetoothAdapter.java
+++ b/core/java/android/bluetooth/BluetoothAdapter.java
@@ -898,6 +898,28 @@ public final class BluetoothAdapter {
         return socket;
     }
 
+     /**
+     * Construct an encrypted, RFCOMM server socket.
+     * Call #accept to retrieve connections to this socket.
+     * @return An RFCOMM BluetoothServerSocket
+     * @throws IOException On error, for example Bluetooth not available, or
+     *                     insufficient permissions.
+     * @hide
+     */
+    public BluetoothServerSocket listenUsingEncryptedRfcommOn(int port)
+            throws IOException {
+        BluetoothServerSocket socket = new BluetoothServerSocket(
+                BluetoothSocket.TYPE_RFCOMM, false, true, port);
+        int errno = socket.mSocket.bindListen();
+        if (errno != 0) {
+            try {
+                socket.close();
+            } catch (IOException e) {}
+            socket.mSocket.throwErrnoNative(errno);
+        }
+        return socket;
+    }
+
     /**
      * Construct a SCO server socket.
      * Call #accept to retrieve connections to this socket.
diff --git a/core/java/android/hardware/fmradio/FmConfig.java b/core/java/android/hardware/fmradio/FmConfig.java
new file mode 100644
index 0000000..c96e64c
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmConfig.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+import android.util.Log;
+
+
+/**
+ *
+ * Class to be used when changing radio settings
+ * @hide
+ */
+public class FmConfig {
+
+
+    /**
+     * FMConfigure FM Radio band setting for US/Europe
+     */
+     private static final int FM_US_BAND        =0;
+    /**
+     * FMConfigure FM Radio band setting for US/Europe
+     */
+     private static final int FM_EU_BAND        =1;
+   /**
+     * FMConfigure FM Radio band setting for Japan
+     */
+     private static final int FM_JAPAN_WIDE_BAND       =2;
+   /**
+     * FMConfigure FM Radio band setting for Japan-Wideband
+     */
+     private static final int FM_JAPAN_STANDARD_BAND   =3;
+   /**
+     * FMConfigure FM Radio band setting for "User defined" band
+     */
+     private static final int FM_USER_DEFINED_BAND     =4;
+
+     private static final int V4L2_CID_PRIVATE_BASE                 =0x8000000;
+     private static final int V4L2_CID_PRIVATE_TAVARUA_REGION       =V4L2_CID_PRIVATE_BASE + 7;
+     private static final int V4L2_CID_PRIVATE_TAVARUA_EMPHASIS     =V4L2_CID_PRIVATE_BASE + 12;
+     private static final int V4L2_CID_PRIVATE_TAVARUA_RDS_STD      =V4L2_CID_PRIVATE_BASE + 13;
+     private static final int V4L2_CID_PRIVATE_TAVARUA_SPACING      =V4L2_CID_PRIVATE_BASE + 14;
+
+     private static final String TAG = "FmConfig";
+
+
+
+    private int mRadioBand;
+    /**
+     * FM pre-emphasis/de-emphasis
+     *
+     * Possible Values:
+     *
+     * FmTransceiver.FM_DE_EMP75,
+     * FmTransceiver.FM_DE_EMP50
+     */
+    private int mEmphasis;
+    /**
+     * Channel spacing
+     *
+     * Possible Values:
+     *
+     * FmTransceiver.FM_CHSPACE_200_KHZ,
+     * FmTransceiver.FM_CHSPACE_100_KHZ,
+     * FmTransceiver.FM_CHSPACE_50_KHZ
+     */
+    private int mChSpacing;
+
+    /**
+     * RDS standard type
+     *
+     * Possible Values:
+     *
+     * FmTransceiver.FM_RDS_STD_RBDS,
+     * FmTransceiver.FM_RDS_STD_RDS,
+     * FmTransceiver.FM_RDS_STD_NONE
+     */
+    private int mRdsStd;
+
+    /**
+     * FM Frequency Band Lower Limit in KHz
+     */
+    private int mBandLowerLimit;
+    /**
+     * FM Frequency Band Upper Limit in KHz
+     */
+    private int mBandUpperLimit;
+
+    public int getRadioBand(){
+        return mRadioBand;
+    }
+
+    public void setRadioBand (int band){
+        mRadioBand = band;
+    }
+
+    public int getEmphasis(){
+        return mEmphasis;
+    }
+
+    public void setEmphasis (int emp){
+        mEmphasis = emp;
+    }
+
+    public int getChSpacing (){
+        return mChSpacing;
+    }
+
+    public void setChSpacing(int spacing) {
+        mChSpacing = spacing;
+    }
+
+    public int getRdsStd () {
+        return mRdsStd;
+    }
+
+    public void setRdsStd (int rdsStandard) {
+        mRdsStd = rdsStandard;
+    }
+
+    public int getLowerLimit(){
+        return mBandLowerLimit;
+    }
+
+    public void setLowerLimit(int lowLimit){
+        mBandLowerLimit = lowLimit;
+    }
+
+    public int getUpperLimit(){
+        return mBandUpperLimit;
+    }
+
+    public void setUpperLimit(int upLimit){
+        mBandUpperLimit = upLimit;
+    }
+
+    /*
+     * fmConfigure()
+     * This method call v4l2 private controls to set regional settings for the
+     * FM core
+     */
+    protected static boolean fmConfigure (int fd, FmConfig configSettings) {
+
+        int re;
+
+        Log.d (TAG, "In fmConfigure");
+
+        re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_EMPHASIS, configSettings.getEmphasis());
+        re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_RDS_STD, configSettings.getRdsStd() );
+        re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SPACING, configSettings.getChSpacing() );
+        re = FmReceiverJNI.setBandNative    (fd, configSettings.getLowerLimit(), configSettings.getUpperLimit() );
+
+        re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_REGION, FM_USER_DEFINED_BAND );
+
+        // setControlNative for V4L2_CID_PRIVATE_TAVARUA_REGION triggers the
+        // config change.
+        if (re < 0)
+          return false;
+
+        return true;
+    }
+
+}
diff --git a/core/java/android/hardware/fmradio/FmReceiver.java b/core/java/android/hardware/fmradio/FmReceiver.java
new file mode 100644
index 0000000..3758ae8
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmReceiver.java
@@ -0,0 +1,1704 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+import android.util.Log;
+
+/**
+ * This class contains all interfaces and types needed to
+ * Control the FM receiver.
+ *    @hide
+ */
+public class FmReceiver extends FmTransceiver
+{
+
+   private static final String TAG = "FMRadio";
+
+   /**
+   * Search (seek/scan/searchlist) by decrementing the frequency
+   *
+   * @see #FM_RX_SEARCHDIR_UP
+   * @see #searchStations(int, int, int)
+   * @see #searchStations(int, int, int, int, int)
+   * @see #searchStationList
+   */
+   public static final int FM_RX_SEARCHDIR_DOWN=0;
+   /**
+   * Search (seek/scan/searchlist) by inrementing the frequency
+   *
+   * @see #FM_RX_SEARCHDIR_DOWN
+   * @see #searchStations(int, int, int)
+   * @see #searchStations(int, int, int, int, int)
+   * @see #searchStationList
+   */
+   public static final int FM_RX_SEARCHDIR_UP=1;
+
+   /**
+   * Scan dwell (Preview) duration = 1 second
+   *
+   * @see #searchStations(int, int, int)
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_DWELL_PERIOD_1S=0;
+   /**
+   * Scan dwell (Preview) duration = 2 seconds
+   *
+   * @see #searchStations(int, int, int)
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_DWELL_PERIOD_2S=1;
+   /**
+   * Scan dwell (Preview) duration = 3 seconds
+   *
+   * @see #searchStations(int, int, int)
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_DWELL_PERIOD_3S=2;
+   /**
+   * Scan dwell (Preview) duration = 4 seconds
+   *
+   * @see #searchStations(int, int, int)
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_DWELL_PERIOD_4S=3;
+   /**
+    * Scan dwell (Preview) duration = 5 seconds
+    *
+    * @see #searchStations(int, int, int)
+    * @see #searchStations(int, int, int, int, int)
+    */
+   public static final int FM_RX_DWELL_PERIOD_5S=4;
+   /**
+    * Scan dwell (Preview) duration = 6 seconds
+    *
+    * @see #searchStations(int, int, int)
+    * @see #searchStations(int, int, int, int, int)
+    */
+   public static final int FM_RX_DWELL_PERIOD_6S=5;
+   /**
+    * Scan dwell (Preview) duration = 7 second
+    *
+    * @see #searchStations(int, int, int)
+    * @see #searchStations(int, int, int, int, int)
+    */
+   public static final int FM_RX_DWELL_PERIOD_7S=6;
+
+
+   /**
+   * Basic Seek Mode Option
+   *
+   * @see #searchStations(int, int, int)
+   */
+   public static final int FM_RX_SRCH_MODE_SEEK        =0;
+   /**
+   * Basic Scan Mode Option
+   *
+   * @see #searchStations(int, int, int)
+   */
+   public static final int FM_RX_SRCH_MODE_SCAN        =1;
+
+   /**
+   * Search list mode Options to search for Strong stations
+   *
+   * @see #searchStationList
+   */
+   public static final int FM_RX_SRCHLIST_MODE_STRONG  =2;
+   /**
+   * Search list mode Options to search for Weak stations
+   *
+   * @see #searchStationList
+   */
+   public static final int FM_RX_SRCHLIST_MODE_WEAK    =3;
+
+   /**
+   * Seek by Program Type
+   *
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_SRCHRDS_MODE_SEEK_PTY =4;
+   /**
+   * Scan by Program Type
+   *
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_SRCHRDS_MODE_SCAN_PTY =5;
+   /**
+   * Seek by Program identification
+   *
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_SRCHRDS_MODE_SEEK_PI  =6;
+   /**
+   * Seek Alternate Frequency for the same station
+   *
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_SRCHRDS_MODE_SEEK_AF  =7;
+   /**
+   * Search list mode Options to search for Strongest stations
+   *
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_SRCHLIST_MODE_STRONGEST  =8;
+   /**
+   * Search list mode Options to search for Weakest stations
+   *
+   * @see #searchStations(int, int, int, int, int)
+   */
+   public static final int FM_RX_SRCHLIST_MODE_WEAKEST  =9;
+
+   /**
+   * Maximum number of stations the SearchStationList can
+   * support
+   *
+   * @see #searchStationList
+   */
+   public static final int FM_RX_SRCHLIST_MAX_STATIONS =12;
+
+   /**
+    *  Argument option for setMuteMode to unmute FM
+    *
+    *  @see #setMuteMode
+    */
+   public static final int FM_RX_UNMUTE     =0;
+   /**
+    *  Argument option for setMuteMode to Mute FM
+    *
+    *  @see #setMuteMode
+    */
+   public static final int FM_RX_MUTE       =1;
+
+   /**
+    *  Argument option for setStereoMode to set FM to Stereo
+    *  Mode.
+    *
+    *  @see #setStereoMode
+    */
+   public static final int FM_RX_AUDIO_MODE_STEREO    =0;
+   /**
+    *  Argument option for setStereoMode to set FM to "Force
+    *  Mono" Mode.
+    *
+    *  @see #setStereoMode
+    */
+   public static final int FM_RX_AUDIO_MODE_MONO      =1;
+
+   /**
+    *  Signal Strength
+    *
+    *  @see #setSignalThreshold
+    *  @see #getSignalThreshold
+    */
+   public static final int FM_RX_SIGNAL_STRENGTH_VERY_WEAK  =-141;
+   public static final int FM_RX_SIGNAL_STRENGTH_WEAK       =-126;
+   public static final int FM_RX_SIGNAL_STRENGTH_STRONG     =-111;
+   public static final int FM_RX_SIGNAL_STRENGTH_VERY_STRONG=-96;
+
+   /**
+    * Power settings
+    *
+    * @see #setPowerMode
+    * @see #getPowerMode
+    */
+   public static final int FM_RX_NORMAL_POWER_MODE   =0;
+   public static final int FM_RX_LOW_POWER_MODE      =1;
+
+
+
+   /**
+    * RDS Processing Options
+    *
+    * @see #registerRdsGroupProcessing
+    * @see #getPSInfo
+    * @see #getRTInfo
+    * @see #getAFInfo
+    */
+   public static final int FM_RX_RDS_GRP_RT_EBL         =1;
+   public static final int FM_RX_RDS_GRP_PS_EBL         =2;
+   public static final int FM_RX_RDS_GRP_AF_EBL         =4;
+   public static final int FM_RX_RDS_GRP_PS_SIMPLE_EBL  =16;
+
+
+   private static final int V4L2_CID_PRIVATE_BASE = 0x8000000;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SIGNAL_TH = V4L2_CID_PRIVATE_BASE + 8;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_ANTENNA   = V4L2_CID_PRIVATE_BASE + 18;
+
+   private static final int TAVARUA_BUF_SRCH_LIST=0;
+   private static final int TAVARUA_BUF_EVENTS=1;
+   private static final int TAVARUA_BUF_RT_RDS=2;
+   private static final int TAVARUA_BUF_PS_RDS=3;
+   private static final int TAVARUA_BUF_RAW_RDS=4;
+   private static final int TAVARUA_BUF_AF_LIST=5;
+   private static final int TAVARUA_BUF_MAX=6;
+
+
+
+
+   /**
+    * Constructor for the receiver Object
+    */
+   public FmReceiver(){
+      mControl = new FmRxControls();
+      mRdsData = new FmRxRdsData (sFd);
+      mRxEvents = new FmRxEventListner();
+   }
+
+   /**
+   *    Constructor for the receiver Object that takes path to
+   *    radio and event callbacks.
+   *    <p>
+   *    @param devicePath FM Device path String.
+   *    @param callback the callbacks to handle the events
+   *                               events from the FM receiver.
+   *
+   */
+   public FmReceiver(String devicePath,
+                     FmRxEvCallbacksAdaptor callback){
+      mControl = new FmRxControls();
+      mRxEvents = new FmRxEventListner();
+      acquire(devicePath);
+      registerClient(callback);
+      mRdsData = new FmRxRdsData(sFd);
+   }
+
+
+   /*==============================================================
+   FUNCTION:  registerClient
+   ==============================================================*/
+   /**
+   *    Registers a callback for FM receiver event
+   *           notifications.
+   *    <p>
+   *    This is a synchronous command used to register for event
+   *    notifications from the FM receiver driver. Since the FM
+   *    driver performs some tasks asynchronously, this function
+   *    allows the client to receive information asynchronously.
+   *    <p>
+   *    When calling this function, the client must pass a callback
+   *    function which will be used to deliver asynchronous events.
+   *    The argument callback must be a non-NULL value.  If a NULL
+   *    value is passed to this function, the registration will
+   *    fail.
+   *    <p>
+   *    The client can choose which events will be sent from the
+   *    receiver driver by simply implementing functions for events
+   *    it wishes to receive.
+   *    <p>
+   *    @param callback the callbacks to handle the events
+   *                               events from the FM receiver.
+   *    @return true if Callback registered, false if Callback
+   *            registration failed.
+   *    <p>
+   *    @see #acquire
+   *    @see #unregisterClient
+   *
+   */
+   public boolean registerClient(FmRxEvCallbacks callback){
+      boolean status;
+      status = super.registerClient(callback);
+      /* Do Receiver Specific Stuff here.*/
+
+      return status;
+   }
+
+   /*==============================================================
+   FUNCTION:  unregisterClient
+   ==============================================================*/
+   /**
+   *    UnRegisters a client's event notification callback.
+   *
+   *    This is a synchronous command used to unregister a client's
+   *    event callback.
+   *    <p>
+   *    @return true Always returns true.
+   *    <p>
+   *    @see #acquire
+   *    @see #release
+   *    @see #registerClient
+   *
+   */
+   public boolean unregisterClient () {
+      boolean status;
+
+      status = super.unregisterClient();
+
+      /* Do Receiver Specific Stuff here.*/
+      return status;
+   }
+
+   /*==============================================================
+   FUNCTION:  enable
+   ==============================================================*/
+   /**
+   *    Enables the FM device in Receiver Mode.
+   *    <p>
+   *    This is a synchronous method used to initialize the FM
+   *    receiver. If already initialized this function will
+   *    intialize the receiver with default settings. Only after
+   *    successfully calling this function can many of the FM device
+   *    interfaces be used.
+   *    <p>
+   *    When enabling the receiver, the client must also provide
+   *    the regional settings in which the receiver will operate.
+   *    These settings (included in argument configSettings) are
+   *    typically used for setting up the FM receiver for operating
+   *    in a particular geographical region. These settings can be
+   *    changed after the FM driver is enabled through the use of
+   *    the function {@link #configure}.
+   *    <p>
+   *    This command can only be issued by the owner of an FM
+   *    receiver.  To issue this command, the client must first
+   *    successfully call {@link #acquire}.
+   *    <p>
+   *    @param configSettings  the settings to be applied when
+   *                             turning on the radio
+   *    @return true if Initialization succeeded, false if
+   *            Initialization failed.
+   *    <p>
+   *    @see #enable
+   *    @see #registerClient
+   *    @see #disable
+   *
+   */
+   public boolean enable (FmConfig configSettings){
+      boolean status;
+
+      /* Enable the Transceiver common for both
+         receiver and transmitter
+         */
+      status = super.enable(configSettings, FmTransceiver.FM_RX);
+
+      /* Do Receiver Specific Enable Stuff here.*/
+
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  disable
+   ==============================================================*/
+   /**
+   *    Disables the FM Device.
+   *    <p>
+   *    This is a synchronous command used to disable the FM
+   *    device. This function is expected to be used when the
+   *    client no longer requires use of the FM device. Once
+   *    called, most functionality offered by the FM device will be
+   *    disabled until the client re-enables the device again via
+   *    {@link #enable}.
+   *    <p>
+   *    @return true if disabling succeeded, false if disabling
+   *            failed.
+   *    @see #enable
+   *    @see #registerClient
+   */
+   public boolean disable(){
+      boolean status;
+      status = super.disable();
+
+      return true;
+   }
+
+  /*==============================================================
+   FUNCTION:  release
+   ==============================================================*/
+   /**
+   *    Close the FM device file descriptor.
+   *    <p>
+   *    @return true if release succeeded, false if release
+   *            failed.
+
+   *    {@see #acquire}.
+   *    {@see #enable}.
+   *    {@see #disable}.
+   */
+   public boolean release(){
+      boolean status;
+      status = super.release("");
+
+      return status;
+   }
+
+   /*==============================================================
+   FUNCTION:  searchStations
+   ==============================================================*/
+   /**
+   *   Initiates basic seek and scan operations.
+   *    <p>
+   *    This command is used to invoke a basic seek/scan of the FM
+   *    radio band.
+   *    <p>
+   *    <ul>
+   *    This API is used to:
+   *    <li> Invoke basic seek operations ({@link
+   *    #FM_RX_SRCH_MODE_SEEK})
+   *    <li> Invoke basic scan operations ({@link
+   *    #FM_RX_SRCH_MODE_SCAN})
+   *    </ul>
+   *    <p>
+   *    The most basic operation performed by this function
+   *    is a {@link #FM_RX_SRCH_MODE_SEEK} command. The seek
+   *    process is handled incrementing or decrementing the
+   *    frequency in pre-defined channel steps (defined by the
+   *    channel spacing) and measuring the resulting signal level.
+   *    Once a station is successfully tuned and found to meet or
+   *    exceed this signal level, the seek operation will be
+   *    completed and a FmRxEvSearchComplete event will be returned
+   *    to the client. If no stations are found to match the search
+   *    criteria, the frequency will be returned to the originally
+   *    tuned station.
+   *    <p>
+   *    Since seek always results in a frequency being tuned, each
+   *    seek operation will also return a single
+   *    FmRxEvRadioTuneStatus event to the client/application
+   *    layer.
+   *    <p>
+   *    Much like {@link #FM_RX_SRCH_MODE_SEEK}, a {@link
+   *    #FM_RX_SRCH_MODE_SCAN} command can be likened to many back
+   *    to back seeks with a dwell period after each successful
+   *    seek. Once issued, a scan will either increment or
+   *    decrement frequencies by the defined channel spacing until
+   *    a station is found to meet or exceed the set search
+   *    threshold. Once this station is found, and is successfully
+   *    tuned, an FmRxEvRadioTuneStatus event will be returned to
+   *    the client and the station will remain tuned for the
+   *    specific period of time indicated by argument dwellPeriod.
+   *    After that time expires, an FmRxEvSearchInProgress event
+   *    will be sent to the client and a new search will begin for
+   *    the next station that meets the search threshold. After
+   *    scanning the entire band, or after a cancel search has been
+   *    initiated by the client, an FmRxEvRadioTuneStatus event
+   *    will be sent to the client. Similar to a seek command, each
+   *    scan will result in at least one station being tuned, even
+   *    if this is the starting frequency.
+   *    <p>
+   *    Each time the driver initiates a search (seek or scan) the client
+   *    will be notified via an FmRxEvSearchInProgress event.
+   *    Similarly, each time a search completes, the client will be notified via an
+   *    FmRxEvRadioTuneStatus event.
+   *    <p>
+   *    Once issuing a search command, several commands from the client
+   *    may be disallowed until the search is completed or cancelled.
+   *    <p>
+   *    The search can be canceled at any time by using API
+   *    cancelSearch (). Once cancelled, each search will tune to the
+   *    last tuned station and generate both FmRxEvSearchComplete and
+   *    FmRxEvRadioTuneStatus events.
+   *    Valid Values for argument 'mode':
+   *    <ul>
+   *    <li>{@link #FM_RX_SRCH_MODE_SEEK}
+   *    <li>{@link #FM_RX_SRCH_MODE_SCAN}
+   *    </ul>
+   *    <p>
+   *    Valid Values for argument 'dwellPeriod' :
+   *    <ul>
+   *    <li>{@link #FM_RX_DWELL_PERIOD_1S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_2S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_3S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_4S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_5S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_6S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_7S}
+   *    </ul>
+   *    <p>
+   *    Valid Values for argument 'direction' :
+   *    <ul>
+   *    <li>{@link #FM_RX_SEARCHDIR_DOWN}
+   *    <li>{@link #FM_RX_SEARCHDIR_UP}
+   *    </ul>
+   *    <p>
+   *
+   *    <p>
+   *    @param mode the FM search mode.
+   *    @param dwellPeriod the FM scan dwell time. Used only when
+   *    mode={@link #FM_RX_SRCH_MODE_SCAN}
+   *    @param direction the Search Direction.
+   *   <p>
+   *    @return true if Search Initiate succeeded, false if
+   *            Search Initiate  failed.
+   *
+   *   @see #searchStations(int, int, int, int, int)
+   *   @see #searchStationList
+   */
+   public boolean searchStations (int mode,
+                                  int dwellPeriod,
+                                  int direction){
+      boolean bStatus = true;
+
+      Log.d (TAG, "Basic search...");
+
+      /* Validate the arguments */
+      if ( (mode != FM_RX_SRCH_MODE_SEEK) &&
+           (mode != FM_RX_SRCH_MODE_SCAN))
+      {
+         Log.d (TAG, "Invalid search mode: " + mode );
+         bStatus = false;
+      }
+      if ( (dwellPeriod < FM_RX_DWELL_PERIOD_1S) ||
+           (dwellPeriod > FM_RX_DWELL_PERIOD_7S))
+      {
+         Log.d (TAG, "Invalid dwelling time: " + dwellPeriod);
+         bStatus = false;
+      }
+      if ( (direction != FM_RX_SEARCHDIR_DOWN) &&
+           (direction != FM_RX_SEARCHDIR_UP))
+      {
+         Log.d (TAG, "Invalid search direction: " + direction);
+         bStatus = false;
+      }
+
+      if (bStatus)
+      {
+         Log.d (TAG, "searchStations: mode " + mode + "direction:  " + direction);
+         mControl.searchStations(sFd, mode, dwellPeriod, direction, 0, 0);
+      }
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  searchStations
+   ==============================================================*/
+   /**
+   *    Initiates RDS based seek and scan operations.
+   *
+   *    <p>
+   *    This command allows the client to issue seeks and scans similar
+   *    to commands found in basic searchStations(mode, scanTime,
+   *    direction). However, each command has an additional RDS/RBDS
+   *    component which must be satisfied before a station is
+   *    successfully tuned. Please see searchStations(mode,
+   *    scanTime, direction) for an understanding of how seeks and
+   *    scans work.
+   *
+   *    <p>
+   *    <ul>
+   *    This API is used to search stations using RDS:
+   *    <li> Invokes seek based on program type ({@link
+   *    #FM_RX_SRCHRDS_MODE_SEEK_PTY})
+   *    <li> Invokes scan based on program type with specified dwell period
+   *    ({@link #FM_RX_SRCHRDS_MODE_SCAN_PTY})
+   *    <li> Invokes seek based on program identification ({@link
+   *    #FM_RX_SRCHRDS_MODE_SEEK_PI})
+   *    <li> Invokes seek for alternate frequency ({@link
+   *    #FM_RX_SRCHRDS_MODE_SEEK_AF})
+   *    </ul>
+   *
+   *    <p>
+   *    Much like {@link #FM_RX_SRCH_MODE_SEEK} in searchStations,
+   *    {@link #FM_RX_SRCHRDS_MODE_SEEK_PTY} allows the client to
+   *    seek to stations which are broadcasting RDS/RBDS groups
+   *    with a particular Program Type that matches the supplied
+   *    Program Type (PTY). The behavior and events generated for a
+   *    {@link #FM_RX_SRCHRDS_MODE_SEEK_PTY} are very similar to
+   *    that of {@link #FM_RX_SRCH_MODE_SEEK}, however only
+   *    stations meeting the set search signal threshold and are
+   *    also broadcasting the specified RDS Program Type (PTY) will
+   *    be tuned. If no matching stations can be found, the
+   *    original station will be re-tuned.
+   *
+   *    <p>
+   *    Just as {@link #FM_RX_SRCHRDS_MODE_SEEK_PTY}'s
+   *    functionality matches {@link #FM_RX_SRCH_MODE_SEEK}, so
+   *    does {@link #FM_RX_SRCHRDS_MODE_SCAN_PTY} match {@link
+   *    #FM_RX_SRCH_MODE_SCAN}. The one of the differences between
+   *    the two is that only stations meeting the set search
+   *    threshold and are also broadcasting a RDS Program Type
+   *    (PTY) matching tucRdsSrchPty are found and tuned. If no
+   *    station is found to have the PTY as specified by argument
+   *    "pty", then the original station will be re-tuned.
+   *
+   *    <p> {@link #FM_RX_SRCHRDS_MODE_SEEK_PI} is used the same
+   *    way as {@link #FM_RX_SRCHRDS_MODE_SEEK_PTY}, but only
+   *    stations which meet the set search threshold and are also
+   *    broadcasting the Program Identification matching the
+   *    argument "pi" are tuned.
+   *
+   *    <p>
+   *    Lastly, {@link #FM_RX_SRCHRDS_MODE_SEEK_AF} functionality
+   *    differs slightly compared to the other commands in this
+   *    function. This command only seeks to stations which are
+   *    known ahead of time to be Alternative Frequencies for the
+   *    currently tune station. If no alternate frequencies are
+   *    known, or if the Alternative Frequencies have weaker signal
+   *    strength than the original frequency, the original
+   *    frequency will be re-tuned.
+   *
+   *    <p>
+   *    Each time the driver initiates an RDS-based search, the client will be
+   *    notified via a FmRxEvSearchInProgress event. Similarly, each
+   *    time an RDS-based search completes, the client will be notified via a
+   *    FmRxEvSearchComplete event.
+   *
+   *    <p>
+   *    Once issuing a search command, several commands from the client may be
+   *    disallowed until the search is completed or canceled.
+   *
+   *    <p>
+   *    The search can be canceled at any time by using API
+   *    cancelSearch (). Once canceled, each search will tune to the
+   *    last tuned station and generate both
+   *    FmRxEvSearchComplete and FmRxEvRadioTuneStatus events.
+   *
+   *    Valid Values for argument 'mode':
+   *    <ul>
+   *    <li>{@link #FM_RX_SRCHRDS_MODE_SEEK_PTY}
+   *    <li>{@link #FM_RX_SRCHRDS_MODE_SCAN_PTY}
+   *    <li>{@link #FM_RX_SRCHRDS_MODE_SEEK_PI}
+   *    <li>{@link #FM_RX_SRCHRDS_MODE_SEEK_AF}
+   *    </ul>
+   *    <p>
+   *    Valid Values for argument 'dwellPeriod' :
+   *    <ul>
+   *    <li>{@link #FM_RX_DWELL_PERIOD_1S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_2S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_3S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_4S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_5S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_6S}
+   *    <li>{@link #FM_RX_DWELL_PERIOD_7S}
+   *    </ul>
+   *    <p>
+   *    Valid Values for argument 'direction' :
+   *    <ul>
+   *    <li>{@link #FM_RX_SEARCHDIR_DOWN}
+   *    <li>{@link #FM_RX_SEARCHDIR_UP}
+   *    </ul>
+   *    <p>
+   *    @param mode the FM search mode.
+   *    @param dwellPeriod the FM scan dwell time. Used only when
+   *    mode={@link #FM_RX_SRCHRDS_MODE_SCAN_PTY}
+   *    @param direction the Search Direction.
+   *    @param pty the FM RDS search Program Type
+   *    @param pi the FM RDS search Program Identification Code
+   *    <p>
+   *    @return true if Search Initiate succeeded, false if
+   *            Search Initiate  failed.
+   *
+   *   @see #searchStations(int, int, int)
+   *   @see #searchStationList
+   */
+   public boolean searchStations (int mode,
+                                  int dwellPeriod,
+                                  int direction,
+                                  int pty,
+                                  int pi) {
+      boolean bStatus = true;
+
+      Log.d (TAG, "RDS search...");
+
+      /* Validate the arguments */
+      if ( (mode != FM_RX_SRCHRDS_MODE_SEEK_PTY)
+           && (mode != FM_RX_SRCHRDS_MODE_SCAN_PTY)
+           && (mode != FM_RX_SRCHRDS_MODE_SEEK_PI)
+           && (mode != FM_RX_SRCHRDS_MODE_SEEK_AF)
+         )
+      {
+         Log.d (TAG, "Invalid search mode: " + mode );
+         bStatus = false;
+      }
+      if ( (dwellPeriod < FM_RX_DWELL_PERIOD_1S) ||
+           (dwellPeriod > FM_RX_DWELL_PERIOD_7S))
+      {
+         Log.d (TAG, "Invalid dwelling time: " + dwellPeriod);
+         bStatus = false;
+      }
+      if ( (direction != FM_RX_SEARCHDIR_DOWN) &&
+           (direction != FM_RX_SEARCHDIR_UP))
+      {
+         Log.d (TAG, "Invalid search direction: " + direction);
+         bStatus = false;
+      }
+
+      if (bStatus)
+      {
+         Log.d (TAG, "searchStations: mode " + mode);
+         Log.d (TAG, "searchStations: dwellPeriod " + dwellPeriod);
+         Log.d (TAG, "searchStations: direction " + direction);
+         Log.d (TAG, "searchStations: pty " + pty);
+         Log.d (TAG, "searchStations: pi " + pi);
+         mControl.searchStations(sFd, mode, dwellPeriod, direction, pty, pi);
+      }
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  searchStationList
+   ==============================================================*/
+   /** Initiates station list search operations.
+   *    <p> This method will initate a search that will generate
+   *    frequency lists based on strong and weak stations found in
+   *    the FM band.
+   *    <p>
+   *    <ul>
+   *    This API is used to generate station lists which consist of:
+   *    <li>strong stations (FM_RX_SRCHLIST_MODE_STRONG,FM_RX_SRCHLIST_MODE_STRONGEST)
+   *    <li>weak stations   (FM_RX_SRCHLIST_MODE_WEAK, FM_RX_SRCHLIST_MODE_WEAKEST)
+   *    </ul>
+   *    <p>
+   *    The range of frequencies scanned depends on the currently set band.
+   *    The driver searches for all valid stations in the band and when complete,
+   *    returns a channel list based on the client's selection. The client can
+   *    choose to search for a list of the strongest stations in the band, the
+   *    weakest stations in the band, or the first N strong or weak
+   *    stations. By setting the maximumStations argument, the
+   *    client can constrain the number of frequencies returned in
+   *    the list. If user specifies argument maximumStations to be
+   *    0, the search will generate the maximum number of stations
+   *    possible.
+   *    <p>
+   *    Each time the driver initiates a list-based search, the client will be
+   *    notified via an FmRxEvSearchInProgress event. Similarly, each
+   *    time a list-based search completes, the client will be
+   *    notified via an FmRxEvSearchListComplete event.
+   *    <p>
+   *    On completion or cancellation of the search, the originally tuned station
+   *    will be tuned and the following events will be generated:
+   *    FmRxEvSearchListComplete - The search has completed.
+   *    FmRxEvRadioTuneStatus - The original frequency has been
+   *    re-tuned.
+   *    <p>
+   *    Once issuing a search command, several commands from the client may be
+   *    disallowed until the search is completed or cancelled.
+   *    <p>
+   *    The search can be canceled at any time by using API
+   *    cancelSearch (). A cancelled search is treated as a completed
+   *    search and the same events will be generated. However, the
+   *    search list generated may only contain a partial list.
+   *    <p>
+   *    Valid Values for argument 'mode':
+   *    <ul>
+   *    <li>{@link #FM_RX_SRCHLIST_MODE_STRONG}
+   *    <li>{@link #FM_RX_SRCHLIST_MODE_WEAK}
+   *    <li>{@link #FM_RX_SRCHLIST_MODE_STRONGEST}
+   *    <li>{@link #FM_RX_SRCHLIST_MODE_WEAKEST}
+   *    <li>FM_RX_SRCHLIST_MODE_PTY (Will be implemented in the
+   *    future)
+   *    </ul>
+   *    <p>
+   *    Valid Values for argument 'direction' :
+   *    <ul>
+   *    <li>{@link #FM_RX_SEARCHDIR_DOWN}
+   *    <li>{@link #FM_RX_SEARCHDIR_UP}
+   *    </ul>
+   *    <p>
+   *    Valid Values for argument 'maximumStations' : 1-12
+   *    <p>
+   *    @param mode the FM search mode.
+   *    @param direction the Search Direction.
+   *    @param maximumStations the maximum number of stations that
+   *                           can be returned from a search. This parameter is
+   *                           ignored and 12 stations are returned if the
+   *                           search mode is either FM_RX_SRCHLIST_MODE_STRONGEST or
+   *                           FM_RX_SRCHLIST_MODE_WEAKEST
+   *
+   *    @param pty the FM RDS search Program Type (Not used
+   *               currently)
+   *   <p>
+   *    @return true if Search Initiate succeeded, false if
+   *            Search Initiate  failed.
+   *
+   *   @see #searchStations(int, int, int)
+   *   @see #searchStations(int, int, int, int, int)
+   */
+   public boolean searchStationList (int mode,
+                                     int direction,
+                                     int maximumStations,
+                                     int pty){
+
+      boolean bStatus = true;
+      int re=0;
+
+      Log.d (TAG, "searchStations: mode " + mode);
+      Log.d (TAG, "searchStations: direction " + direction);
+      Log.d (TAG, "searchStations: maximumStations " + maximumStations);
+      Log.d (TAG, "searchStations: pty " + pty);
+
+      /* Validate the arguments */
+      if ( (mode != FM_RX_SRCHLIST_MODE_STRONG)
+           && (mode != FM_RX_SRCHLIST_MODE_WEAK )
+           && (mode != FM_RX_SRCHLIST_MODE_STRONGEST )
+           && (mode != FM_RX_SRCHLIST_MODE_WEAKEST )
+         )
+      {
+         bStatus = false;
+      }
+      if ( (maximumStations < 0) ||
+           (maximumStations > FM_RX_SRCHLIST_MAX_STATIONS))
+      {
+         bStatus = false;
+      }
+      if ( (direction != FM_RX_SEARCHDIR_DOWN) &&
+           (direction != FM_RX_SEARCHDIR_UP))
+      {
+         bStatus = false;
+      }
+
+      if (bStatus)
+      {
+         if ( (mode == FM_RX_SRCHLIST_MODE_STRONGEST) || (mode == FM_RX_SRCHLIST_MODE_WEAKEST) )
+           re = mControl.searchStationList(sFd, mode, 0, direction, pty);
+	 else
+           re = mControl.searchStationList(sFd, mode, maximumStations, direction, pty);
+      }
+
+      if (re == 0)
+        return true;
+
+      return false;
+   }
+
+
+
+   /*==============================================================
+   FUNCTION:  cancelSearch
+   ==============================================================*/
+   /**
+   *  Cancels an ongoing search operation
+   *  (seek, scan, searchlist, etc).
+   * <p>
+   * This method should be used to cancel a previously initiated
+   * search (e.g. Basic Seek/Scan, RDS Seek/Scans, Search list,
+   * etc...).
+   * <p>
+   * Once completed, this command will generate an
+   * FmRxEvSearchCancelledtr event to all registered clients.
+   * Following this event, the client may also receive search events related
+   * to the ongoing search now being complete.
+   *
+   *   <p>
+   *    @return true if Cancel Search initiate succeeded, false if
+   *            Cancel Search initiate failed.
+   *   @see #searchStations(int, int, int)
+   *   @see #searchStations(int, int, int)
+   *   @see #searchStationList
+   */
+   public boolean cancelSearch () {
+      mControl.cancelSearch(sFd);
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  setMuteMode
+   ==============================================================*/
+   /**
+   *    Allows the muting and un-muting of the audio coming
+   *    from the FM receiver.
+   *    <p>
+   *    This is a synchronous command used to mute or un-mute the
+   *    FM audio. This command mutes the audio coming from the FM
+   *    device. It is important to note that this only affects the
+   *    FM audio and not any other audio system being used.
+   *    <p>
+   *    @param mode the mute Mode setting to apply
+   *    <p>
+   *    @return true if setMuteMode call was placed successfully,
+   *           false if setMuteMode failed.
+   *
+   *    @see #enable
+   *    @see #registerClient
+   *
+   */
+   public boolean setMuteMode (int mode) {
+      switch (mode)
+      {
+      case FM_RX_UNMUTE:
+         mControl.muteControl(sFd, false);
+         break;
+      case FM_RX_MUTE:
+         mControl.muteControl(sFd, true);
+         break;
+      default:
+         break;
+      }
+
+      return true;
+
+   }
+
+   /*==============================================================
+   FUNCTION:  setStereoMode
+   ==============================================================*/
+   /**
+   *    Sets the mono/stereo mode of the FM device.
+   *
+   *    <p>
+   *    This command allows the user to set the mono/stereo mode
+   *    of the FM device. Using this function,
+   *    the user can allow mono/stereo mixing or force the reception
+   *    of mono audio only.
+   *
+   *    @param stereoEnable true: Enable Stereo, false: Force Mono
+   *
+   *   @return true if setStereoMode call was placed successfully,
+   *           false if setStereoMode failed.
+   */
+   public boolean setStereoMode (boolean stereoEnable) {
+      int re = mControl.stereoControl(sFd, stereoEnable);
+
+      if (re == 0)
+        return true;
+      return false;
+   }
+
+   /*==============================================================
+   FUNCTION:  setSignalThreshold
+   ==============================================================*/
+   /**
+   *    This function sets the threshold which the FM driver
+   *    uses to determine which stations have service available.
+   *
+   *    <p>
+   *    This information is used to determine which stations are
+   *    tuned during searches and Alternative Frequency jumps, as
+   *    well as at what threshold FmRxEvServiceAvailable event
+   *    callback are generated.
+   *    <p>
+   *    This is a command used to set the threshold used by the FM driver
+   *    and/or hardware to determine which stations are "good" stations.
+   *    Using this function, the client can allow very weak stations,
+   *    relatively weak stations, relatively strong stations, or very.
+   *    strong stations to be found during searches. Additionally,
+   *    this threshold will be used to determine at what threshold a
+   *    FmRxEvServiceAvailable event callback is generated.
+   *    <p>
+   *    @param threshold the new signal threshold.
+   *    @return true if setSignalThreshold call was placed
+   *           successfully, false if setSignalThreshold failed.
+   */
+   public boolean setSignalThreshold (int threshold) {
+
+      boolean bStatus = true;
+      int re;
+
+      if ( (threshold != FM_RX_SIGNAL_STRENGTH_VERY_WEAK) &&
+           (threshold != FM_RX_SIGNAL_STRENGTH_WEAK) &&
+           (threshold != FM_RX_SIGNAL_STRENGTH_VERY_STRONG) &&
+           (threshold != FM_RX_SIGNAL_STRENGTH_STRONG)  ) {
+
+           bStatus = false;
+            Log.d (TAG, "Invalid threshol: " + threshold );
+
+      }
+
+      if (bStatus) {
+        re=FmReceiverJNI.setControlNative (sFd, V4L2_CID_PRIVATE_TAVARUA_SIGNAL_TH, threshold);
+
+        if (re !=0)
+          bStatus = false;
+      }
+
+      return bStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  getStationParameters
+   ==============================================================*
+   /**
+   *     Returns various Paramaters related to the currently
+   *    tuned station.
+   *
+   *    <p>
+   *    This is method retreives various parameters and statistics
+   *    related to the currently tuned station. Included in these
+   *    statistics are the currently tuned frequency, the RDS/RBDS
+   *    sync status, the RSSI level, current mute settings and the
+   *    stereo/mono status.
+   *
+   *    <p>
+   *    Once completed, this command will generate an asynchronous
+   *    FmRxEvStationParameters event to the registered client.
+   *    This event will contain the station parameters.
+   *
+   *    <p>
+   *    @return      FmStationParameters: Object that contains
+   *                    all the station parameters
+   public FmStationParameters getStationParameters () {
+      return mStationParameters;
+   }
+
+   */
+
+   /*==============================================================
+   FUNCTION:  getTunedFrequency
+   ==============================================================*/
+   /**
+   *    Get the Frequency of the Tuned Station
+   *
+   *    @return frequencyKHz: Tuned Station Frequency (in kHz)
+   *                       (Example: 96500 = 96.5Mhz)
+   */
+   public int getTunedFrequency () {
+
+      int frequency = FmReceiverJNI.getFreqNative(sFd);
+
+      Log.d(TAG, "getFrequency: "+frequency);
+
+      return frequency;
+   }
+
+   /*==============================================================
+   FUNCTION:  getPSInfo
+   ==============================================================*/
+   /**
+   *    Returns the current RDS/RBDS Program Service
+   *            Information.
+   *    <p>
+   *    This is a command which returns the last complete RDS/RBDS
+   *    Program Service information for the currently tuned station.
+   *    To use this command, the client must first register for
+   *    Program Service info by receiving either the
+   *    FM_RX_RDS_GRP_PS_EBL or FM_RX_RDS_GRP_PS_SIMPLE_EBL event.
+   *    Under normal operating mode, this information will
+   *    automatically be sent to the client. However, if the client
+   *    requires this information be sent again, this function can be
+   *    used.
+   *
+   *    Typicaly this method needs to be called when "FmRxEvRdsPsInfo"
+   *    callback is invoked.
+   *
+   *    <p>
+   *    @return  the RDS data including the Program Service
+   *             Information
+   *
+   */
+   public FmRxRdsData  getPSInfo() {
+
+      byte [] buff = new byte[64];
+      int piLower = 0;
+      int piHigher = 0;
+
+      FmReceiverJNI.getBufferNative(sFd, buff, 3);
+
+      FmRxRdsData rdsData = new FmRxRdsData(sFd);
+
+      String rdsStr = new String(buff);
+
+
+      /* byte is signed ;(
+      *  knock down signed bits
+      */
+      piLower = buff[3] & 0xFF;
+      piHigher = buff[2] & 0xFF;
+
+      Log.d (TAG, "lowerByte " + piLower);
+      Log.d (TAG, "higherByte " + piHigher);
+
+      int pi = ((piHigher << 8) | piLower);
+
+      Log.d (TAG, "pi " + pi);
+
+
+      rdsData.setPrgmId (pi);
+      rdsData.setPrgmType ( (int)( buff[1] & 0x1F));
+
+      int numOfPs = (int)(buff[0] & 0x0F);
+
+      try
+      {
+         rdsStr = rdsStr.substring(5, (int )((numOfPs*8) + 5) );
+         rdsData.setPrgmServices (rdsStr);
+
+      } catch (StringIndexOutOfBoundsException x)
+      {
+         Log.d (TAG, "Number of PS names " + numOfPs);
+      }
+
+      return rdsData;
+
+   }
+
+   /*==============================================================
+   FUNCTION:  getRTInfo
+   ==============================================================*/
+   /**
+   *    Returns the current RDS/RBDS RadioText Information.
+   *
+   *    <p>
+   *    This is a command which returns the last complete RadioText information
+   *    for the currently tuned station. For this command to return meaningful
+   *    information, the client must first register for RadioText events by registerring
+   *    the FM_RX_RDS_GRP_RT_EBL callback function. Under normal operating mode, this information
+   *    will automatically be sent to the client. However, if the client requires
+   *    this information be sent again, this function can be used.
+   *
+   *    <p>
+   *    Typicaly this method needs to be called when
+   *    "FmRxEvRdsRtInfo" callback is invoked.
+   *
+   *    <p>
+   *    @return  the RDS data including the Radio Text Information
+   */
+   public FmRxRdsData getRTInfo () {
+
+      byte [] buff = new byte[120];
+      int piLower = 0;
+      int piHigher = 0;
+      FmReceiverJNI.getBufferNative(sFd, buff, 2);
+
+      FmRxRdsData rdsData = new FmRxRdsData(sFd);
+
+      String rdsStr = new String(buff);
+
+      /* byte is signed ;(
+      *  knock down signed bit
+      */
+      piLower = buff[3] & 0xFF;
+      piHigher = buff[2] & 0xFF;
+
+      Log.d (TAG, "lowerByte " + piLower);
+      Log.d (TAG, "higherByte " + piHigher);
+
+      int pi = ((piHigher << 8) | piLower);
+
+      Log.d (TAG, "pi " + pi);
+
+
+      rdsData.setPrgmId (pi);
+      rdsData.setPrgmType ( (int)( buff[1] & 0x1F));
+
+      try
+      {
+         rdsStr = rdsStr.substring(5, (int) buff[0]+ 5);
+         rdsData.setRadioText (rdsStr);
+
+      } catch (StringIndexOutOfBoundsException x)
+      {
+         Log.d (TAG, "StringIndexOutOfBoundsException ...");
+      }
+
+      return rdsData;
+
+   }
+
+   /*==============================================================
+   FUNCTION:  getAFInfo
+   ==============================================================*/
+   /**
+   *   Returns the current RDS/RBDS Alternative Frequency
+   *          Information.
+   *
+   *    <p>
+   *    This is a command which returns the last known Alternative Frequency
+   *    information for the currently tuned station. For this command to return
+   *    meaningful information, the client must first register for Alternative
+   *    Frequency events by registering an FM_RX_RDS_GRP_AF_EBL call back function.
+   *    Under normal operating mode, this information will automatically be
+   *    sent to the client. However, if the client requires this information
+   *    be sent again, this function can be used.
+   *
+   *    <p>
+   *    Typicaly this method needs to be called when
+   *    "FmRxEvRdsAfInfo" callback is invoked.
+   *
+   *    @return  the RDS data including the AF Information
+   */
+   public int[] getAFInfo() {
+
+      byte [] buff = new byte[40];
+      int  [] AfList = new int [40];
+      int lowerBand;
+
+      FmReceiverJNI.getBufferNative(sFd, buff, TAVARUA_BUF_AF_LIST);
+
+      if ((buff[4] <= 0) || (buff[4] > 25))
+        return null;
+
+      lowerBand = FmReceiverJNI.getLowerBandNative(sFd);
+      Log.d (TAG, "Low band " + lowerBand);
+
+      Log.d (TAG, "AF_buff 0: " + (buff[0] & 0xff));
+      Log.d (TAG, "AF_buff 1: " + (buff[1] & 0xff));
+      Log.d (TAG, "AF_buff 2: " + (buff[2] & 0xff));
+      Log.d (TAG, "AF_buff 3: " + (buff[3] & 0xff));
+      Log.d (TAG, "AF_buff 4: " + (buff[4] & 0xff));
+
+      for (int i=0; i<buff[4]; i++) {
+        AfList[i] = ((buff[i+4] & 0xFF) * 1000) + lowerBand;
+        Log.d (TAG, "AF : " + AfList[i]);
+      }
+
+      return AfList;
+
+   }
+
+   /*==============================================================
+   FUNCTION:  setPowerMode
+   ==============================================================*/
+   /**
+   *    Puts the driver into or out of low power mode.
+   *
+   *    <p>
+   *    This is an synchronous command which can put the FM
+   *    device and driver into and out of low power mode. Low power mode
+   *    should be used when the receiver is tuned to a station and only
+   *    the FM audio is required. The typical scenario for low power mode
+   *    is when the FM application is no longer visible.
+   *
+   *    <p>
+   *    While in low power mode, all normal FM and RDS indications from
+   *    the FM driver will be suppressed. By disabling these indications,
+   *    low power mode can result in fewer interruptions and this may lead
+   *    to a power savings.
+   *
+   *    <p>
+   *    @param powerMode the new driver operating mode.
+   *
+   *    @return true if setPowerMode succeeded, false if
+   *            setPowerMode failed.
+   */
+   public boolean setPowerMode(int powerMode){
+
+      int re;
+
+      if (powerMode == FM_RX_LOW_POWER_MODE) {
+        re = mControl.setLowPwrMode (sFd, true);
+      }
+      else {
+        re = mControl.setLowPwrMode (sFd, false);
+      }
+
+      if (re == 0)
+         return true;
+      return false;
+   }
+
+   /*==============================================================
+  FUNCTION:  getPowerMode
+  ==============================================================*/
+   /**
+   *    Get FM device low power mode.
+   *    <p>
+   *    This is an synchronous method that will read the power mode
+   *    of the FM device and driver.
+   *    <p>
+   *       @return true if the FM Device is in Low power mode and
+   *               false if the FM Device in Normal power mode.
+   *
+   *    @see #setPowerMode
+   */
+   public int getPowerMode(){
+
+      return  mControl.getPwrMode (sFd);
+
+   }
+
+   /*==============================================================
+   FUNCTION:  getRssiLimit
+   ==============================================================*/
+   /**
+   *    Returns the RSSI thresholds for the FM driver.
+   *
+   *    <p>
+   *    This method returns the RSSI thresholds for the FM driver.
+   *    This function returns a structure containing the minimum RSSI needed
+   *    for reception and the minimum RSSI value where reception is perfect.
+   *    The minimum RSSI value for reception is the recommended threshold where
+   *    an average user would consider the station listenable. Similarly,
+   *    the minimum RSSI threshold for perfect reception is the point where
+   *    reception quality will improve only marginally even if the RSSI level
+   *    improves greatly.
+   *
+   *    <p>
+   *    These settings should only be used as a guide for describing
+   *    the RSSI values returned by the FM driver. Used in conjunction
+   *    with getRssiInfo, the client can use the values from this
+   *    function to give meaning to the RSSI levels returned by the driver.
+   *
+   *    <p>
+   *       @return the RSSI level
+   */
+   public int[] getRssiLimit () {
+
+      int[] rssiLimits = {0, 100};
+
+      return rssiLimits;
+   }
+
+   /*==============================================================
+   FUNCTION:  getSignalThreshold
+   ==============================================================*/
+   /**
+   *   This function returns the currently set signal
+   *          threshold.
+   *
+   *    <p>
+   *    This value used by the FM driver/hardware to determine which
+   *    stations are tuned during searches and Alternative Frequency jumps.
+   *    Additionally, this level is used to determine at what
+   *    threshold FmRxEvServiceAvailable are generated.
+   *
+   *    <p>
+   *    This is a command used to return the currently set signal
+   *    threshold used by the FM driver and/or hardware. This
+   *    value is used to determine. which stations are tuned
+   *    during searches and Alternative Frequency jumps as well as
+   *    when Service available events are generated.
+   *
+   *    <p>
+   *    Once completed, this command will generate an asynchronous
+   *    FmRxEvGetSignalThreshold event to the registered client.
+   *    This event will contain the current signal threshold
+   *    level.
+   *
+   *    <p>
+   *    @return the signal threshold
+   */
+   public int getSignalThreshold () {
+
+      return FmReceiverJNI.getControlNative (sFd, V4L2_CID_PRIVATE_TAVARUA_SIGNAL_TH);
+   }
+
+
+   /*==============================================================
+   FUNCTION:  setRdsGroupOptions
+   ==============================================================*/
+   /**
+   *
+   *    This function enables or disables various RDS/RBDS
+   *    group filtering and buffering features.
+   *
+   *    <p>
+   *    Included in these features are the RDS group enable mask, RDS/RBDS group
+   *    change filter, and the RDS/RBDS group buffer size.
+   *    <p>
+   *    This is a function used to set or unset various Rx RDS/RBDS group filtering
+   *    and buffering options in the FM driver.
+   *    <p>
+   *    Included in these options is the ability for the client to select
+   *    which RDS/RBDS groups should be sent to the client. By default, all
+   *    RDS/RBDS groups are filtered out before reaching the client. To allow one
+   *    or more specific groups to be received, the client must set one or mors bits
+   *    within the argument enRdsGrpsMask bitmask. Each bit in this
+   *    mask corresponds to a specific RDS/RBDS group type. Once a
+   *    group is enabled, and when a buffer holding those groups
+   *    reaches the threshold defined by argument rdsBuffSize, the
+   *    group or groups will be sent to the client as a
+   *    FmRxEvRdsGroupData callback.
+   *
+   *    <p>
+   *    Additionally, this function also allows the client to enable or
+   *    disable the RDS/RBDS group change filter. This filter allows the client
+   *    to prevent duplicate groups of the same group type from being received.
+   *    This filter only applies to consecutive groups, so
+   *    identical groups received in different order will not be
+   *    filtered out.
+   *
+   *    <p>
+   *    @param enRdsGrpsMask the bitMask that enables the RT/PS/AF.
+   *
+   *    @param rdsBuffSize the number of RDS/RBDS groups the FM
+   *                        driver should buffer  before sending to
+   *                        the client.
+   *
+   *    @param enRdsChangeFilter the Flag used to determine whether
+   *                              the RDS/RBDS change filter
+   *                              should be enabled.
+   *
+   *    @return true if the command was placed successfully, false
+   *            if command failed.
+   *
+   */
+   public boolean setRdsGroupOptions (int enRdsGrpsMask,
+                                      int rdsBuffSize,
+                                      boolean enRdsChangeFilter)
+   {
+
+      // Enable RDS
+      int re = mRdsData.rdsOn(true);
+
+      if (re != 0)
+        return false;
+
+      re = mRdsData.rdsGrpOptions (enRdsGrpsMask, rdsBuffSize, enRdsChangeFilter);
+
+      if (re ==0)
+        return true;
+
+      return false;
+
+   }
+
+   /*==============================================================
+   FUNCTION:  registerRdsGroupProcessing
+   ==============================================================*/
+   /**
+   *
+   *    This function enables or disables RDS/RBDS group processing features.
+   *
+   *    <p>
+   *    Included in these features is the ability for the FM driver
+   *    to return Program Service, RadioText, and Alternative
+   *    Frequency information.
+   *
+   *    <p>
+   *    These options free the client from the burden of collecting a continuous
+   *    stream of RDS/RBDS groups and processing them. By setting the
+   *    FM_RX_RDS_GRP_RT_EBL bit in argument fmGrpsToProc, the FM
+   *    hardware or driver will collect RDS/RBDS 2A/2B groups and
+   *    return complete RadioText strings and information in the
+   *    form of a FmRxEvRdsRtInfo event. This event will be
+   *    generated only when the RadioText information changes.
+   *
+   *    <p>
+   *    Similarly, by setting either the FM_RX_RDS_GRP_PS_EBL or
+   *    FM_RX_RDS_GRP_PS_SIMPLE_EBL bit in argument fmGrpsToProc,
+   *    the FM hardware or driver will collect RDS/RBDS 0A/0B
+   *    groups and return Program Service information in the form
+   *    of a FmRxEvRdsPsInfo event. This event will be generated
+   *    whenever the Program Service information changes. This
+   *    event will include one or more collected Program Service
+   *    strings which can be continuously displayed by the client.
+   *
+   *    <p>
+   *    Additionally, by setting the FM_RX_RDS_GRP_AF_EBL bit in
+   *    argument FmGrpsToProc, the FM hardware or driver will
+   *    collect RDS/RBDS 0A/0B groups and return Alternative
+   *    Frequency information in the form of a FmRxEvRdsAfInfo
+   *    event. This event will be generated when the Alternative
+   *    Frequency information changes and will include an up to
+   *    date list of all known Alternative Frequencies.
+   *
+   *    <p>
+   *    Lastly, by setting the FM_RX_RDS_GRP_AF_JUMP_EBL bit in
+   *    argument FmGrpsToProc, the FM hardware or driver will
+   *    collect RDS/RBDS 0A/0B groups and automatically tune to a
+   *    stronger alternative frequency when the signal level falls
+   *    below the search threshold.
+   *
+   *    @param fmGrpsToProc the bitMask that enables the RT/PS/AF.
+   *
+   *    @return true if the command was placed successfully, false
+   *            if command failed.
+   *
+   */
+   public boolean registerRdsGroupProcessing (int fmGrpsToProc){
+
+      // Enable RDS
+      int re = mRdsData.rdsOn(true);
+
+      if (re != 0)
+        return false;
+
+      re = mRdsData.rdsOptions (fmGrpsToProc);
+
+      if (re ==0)
+        return true;
+
+      return false;
+   }
+
+
+   /*==============================================================
+   FUNCTION:  enableAFjump
+   ==============================================================*/
+   /**
+   *    Enables automatic jump to alternative frequency
+   *
+   *    <p>
+   *    This method enables automatic seeking to stations which are
+   *    known ahead of time to be Alternative Frequencies for the
+   *    currently tuned station. If no alternate frequencies are
+   *    known, or if the Alternative Frequencies have weaker signal
+   *    strength than the original frequency, the original frequency
+   *    will be re-tuned.
+   *
+   *    <p>
+   *    @return     true if successful false otherwise.
+   */
+   public boolean enableAFjump (boolean enable) {
+
+      // Enable RDS
+      int re = mRdsData.rdsOn(true);
+
+      if (re != 0)
+        return false;
+
+      re = mRdsData.enableAFjump(enable);
+
+      if (re == 0)
+        return true;
+
+      return false;
+   }
+
+   /*==============================================================
+   FUNCTION:  getStationList
+   ==============================================================*/
+   /**
+   *    Returns a frequency List of the searched stations.
+   *
+   *    <p>
+   *    This method retreives the results of the {@link
+   *    #searchStationList}. This method should be called when the
+   *    FmRxEvSearchListComplete is invoked.
+   *
+   *    <p>
+   *    @return      An array of integers that corresponds to the
+   *                    frequency of the searched Stations
+   *    @see #searchStationList
+   */
+   public int[] getStationList ()
+   {
+      int[] stnList = new int [100];
+
+      stnList = mControl.stationList (sFd);
+
+      return stnList;
+
+   }
+
+
+   /*==============================================================
+   FUNCTION:  getRssi
+   ==============================================================*/
+   /**
+   *    Returns the signal strength of the currently tuned station
+   *
+   *    <p>
+   *    This method returns the signal strength of the currently
+   *    tuned station.
+   *
+   *    <p>
+   *    @return    RSSI of currently tuned station
+   */
+   public int getRssi()
+   {
+
+       int rssi = FmReceiverJNI.getRSSINative (sFd);
+
+       rssi = rssi + 120;
+
+       if (rssi > 100)
+         return 100;
+
+       return rssi;
+   }
+
+   /*==============================================================
+   FUNCTION:  getInternalAntenna
+   ==============================================================*/
+   /**
+   *    Returns true if internal FM antenna is available
+   *
+   *    <p>
+   *    This method returns true is internal FM antenna is
+   *    available, false otherwise
+   *
+   *    <p>
+   *    @return    true/false
+   */
+   public boolean getInternalAntenna()
+   {
+
+       int re = FmReceiverJNI.getControlNative (sFd, V4L2_CID_PRIVATE_TAVARUA_ANTENNA);
+
+       if (re == 1)
+         return true;
+
+       return false;
+   }
+
+   /*==============================================================
+   FUNCTION:  setInternalAntenna
+   ==============================================================*/
+   /**
+   *    Returns true if successful, false otherwise
+   *
+   *    <p>
+   *    This method sets internal antenna type to true/false
+   *
+   *    @param intAntenna true is Internal antenna is present
+   *
+   *    <p>
+   *    @return    true/false
+   */
+   public boolean setInternalAntenna(boolean intAnt)
+   {
+
+       int iAntenna ;
+
+       if (intAnt)
+          iAntenna = 1;
+       else
+          iAntenna = 0;
+
+
+       int re = FmReceiverJNI.setControlNative (sFd, V4L2_CID_PRIVATE_TAVARUA_ANTENNA, iAntenna);
+
+       if (re == 0)
+         return true;
+
+       return false;
+   }
+
+   /*==============================================================
+   FUNCTION:  getRawRDS
+   ==============================================================*/
+   /**
+   *    Returns array of Raw RDS data
+   *
+   *    <p>
+   *    This is a non-blocking call and it returns raw RDS data.
+   *    The data is packed in groups of three bytes. The lsb and
+   *    msb bytes contain RDS block while the third byte contains
+   *    Block description. This call is wrapper around V4L2 read
+   *    system call. The FM driver collects RDS/RBDS groups to meet
+   *    the threshold described by setRdsGroupOptions() method.
+   *    The call returns when one or more groups have been enabled
+   *    by setRdsGroupOptions() method.
+   *
+   *    @param numBlocks Number of blocks of RDS data
+   *
+   *    <p>
+   *    @return    byte[]
+   */
+
+   public byte[] getRawRDS (int numBlocks)
+   {
+
+        byte[] rawRds = new byte [numBlocks*3];
+        int re;
+
+        re = FmReceiverJNI.getRawRdsNative (sFd, rawRds, numBlocks*3);
+
+        if (re == (numBlocks*3))
+            return rawRds;
+
+        if (re <= 0)
+          return null;
+
+        byte[] buff = new byte [re];
+
+        System.arraycopy (rawRds, 0, buff, 0 , re);
+
+        return buff;
+
+   }
+
+
+}
diff --git a/core/java/android/hardware/fmradio/FmReceiverJNI.java b/core/java/android/hardware/fmradio/FmReceiverJNI.java
new file mode 100644
index 0000000..3707785
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmReceiverJNI.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+
+class FmReceiverJNI {
+    /**
+     * General success
+     */
+    static final int FM_JNI_SUCCESS = 0;
+
+    /**
+     * General failure
+     */
+    static final int FM_JNI_FAILURE = -1;
+
+    /**
+     * native method: Open device
+     * @return The file descriptor of the device
+     *
+     */
+    static native int acquireFdNative(String path);
+
+
+    /**
+     * native method:
+     * @param fd
+     * @param control
+     * @param field
+     * @return
+     */
+    static native int audioControlNative(int fd, int control, int field);
+
+    /**
+     * native method: cancels search
+     * @param fd file descriptor of device
+     * @return May return
+     *             {@link #FM_JNI_SUCCESS}
+     *             {@link #FM_JNI_FAILURE}
+     */
+    static native int cancelSearchNative(int fd);
+
+    /**
+     * native method: release control of device
+     * @param fd file descriptor of device
+     * @return May return
+     *             {@link #FM_JNI_SUCCESS}
+     *             {@link #FM_JNI_FAILURE}
+     */
+    static native int closeFdNative(int fd);
+
+    /**
+     * native method: get frequency
+     * @param fd file descriptor of device
+     * @return Returns frequency in int form
+     */
+    static native int getFreqNative(int fd);
+
+    /**
+     * native method: set frequency
+     * @param fd file descriptor of device
+     * @param freq freq to be set in int form
+     * @return {@link #FM_JNI_SUCCESS}
+     *         {@link #FM_JNI_FAILURE}
+     *
+     */
+    static native int setFreqNative(int fd, int freq);
+
+    /**
+     * native method: get v4l2 control
+     * @param fd file descriptor of device
+     * @param id v4l2 id to be retrieved
+     * @return Returns current value of the
+     *         v4l2 control
+     */
+    static native int getControlNative (int fd, int id);
+
+    /**
+     * native method: set v4l2 control
+     * @param fd file descriptor of device
+     * @param id v4l2 control to be set
+     * @param value value to be set
+     * @return {@link #FM_JNI_SUCCESS}
+     *         {@link #FM_JNI_FAILURE}
+     */
+    static native int setControlNative (int fd, int id, int value);
+
+    /**
+     * native method: start search
+     * @param fd file descriptor of device
+     * @param dir search direction
+     * @return {@link #FM_JNI_SUCCESS}
+     *         {@link #FM_JNI_FAILURE}
+     */
+    static native int startSearchNative (int fd, int dir);
+
+    /**
+     * native method: get buffer
+     * @param fd file descriptor of device
+     * @param buff[] buffer
+     * @param index index of the buffer to be retrieved
+     * @return {@link #FM_JNI_SUCCESS}
+     *         {@link #FM_JNI_FAILURE}
+     */
+    static native int getBufferNative (int fd, byte  buff[], int index);
+
+    /**
+     * native method: get RSSI value of the
+     *                received signal
+     * @param fd file descriptor of device
+     * @return Returns signal strength in int form
+     *         Signal value range from -120 to 10
+     */
+    static native int getRSSINative (int fd);
+
+    /**
+     * native method: set FM band
+     * @param fd file descriptor of device
+     * @param low lower band
+     * @param high higher band
+     * @return {@link #FM_JNI_SUCCESS}
+     *         {@link #FM_JNI_FAILURE}
+     */
+    static native int setBandNative (int fd, int low, int high);
+
+    /**
+     * native method: get lower band
+     * @param fd file descriptor of device
+     * @return Returns lower band in int form
+     */
+    static native int getLowerBandNative (int fd);
+
+    /**
+     * native method: force Mono/Stereo mode
+     * @param fd file descriptor of device
+     * @param val force mono/stereo indicator
+     * @return {@link #FM_JNI_SUCCESS}
+     *         {@link #FM_JNI_FAILURE}
+     */
+    static native int setMonoStereoNative (int fd, int val);
+
+    /**
+     * native method: get Raw RDS data
+     * @param fd file descriptor of device
+     * @param buff[] buffer
+     * @param count number of bytes to be read
+     * @return Returns number of bytes read
+     */
+    static native int getRawRdsNative (int fd, byte  buff[], int count);
+}
diff --git a/core/java/android/hardware/fmradio/FmRxControls.java b/core/java/android/hardware/fmradio/FmRxControls.java
new file mode 100644
index 0000000..b71aa57
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmRxControls.java
@@ -0,0 +1,313 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+import android.util.Log;
+
+
+class FmRxControls
+{
+
+   private boolean mStateStereo;
+   private boolean mStateMute;
+   private int mFreq;
+
+   static final int SEEK_FORWARD = 0;
+   static final int SEEK_BACKWARD = 1;
+   static final int SCAN_FORWARD = 2;
+   static final int SCAN_BACKWARD = 3;
+   private int mSrchMode;
+   private int mScanTime;
+   private int mSrchDir;
+   private int mSrchListMode;
+   private int mPrgmType;
+   private int mPrgmId;
+   private static final String TAG = "FmRxControls";
+
+
+   /* V4l2 Controls */
+   private static final int V4L2_CID_PRIVATE_BASE = 0x8000000;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SRCHMODE = V4L2_CID_PRIVATE_BASE + 1;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SCANDWELL = V4L2_CID_PRIVATE_BASE + 2;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SRCHON = V4L2_CID_PRIVATE_BASE + 3;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_STATE = V4L2_CID_PRIVATE_BASE + 4;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_TRANSMIT_MODE = V4L2_CID_PRIVATE_BASE + 5;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_MASK = V4L2_CID_PRIVATE_BASE + 6;;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_REGION = V4L2_CID_PRIVATE_BASE + 7;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SIGNAL_TH = V4L2_CID_PRIVATE_BASE + 8;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SRCH_PTY = V4L2_CID_PRIVATE_BASE + 9;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SRCH_PI = V4L2_CID_PRIVATE_BASE + 10;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SRCH_CNT = V4L2_CID_PRIVATE_BASE + 11;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_EMPHASIS = V4L2_CID_PRIVATE_BASE + 12;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_RDS_STD = V4L2_CID_PRIVATE_BASE + 13;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_SPACING = V4L2_CID_PRIVATE_BASE + 14;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_RDSON = V4L2_CID_PRIVATE_BASE + 15;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC = V4L2_CID_PRIVATE_BASE + 16;
+   private static final int V4L2_CID_PRIVATE_TAVARUA_LP_MODE = V4L2_CID_PRIVATE_BASE + 17;
+
+   private static final int V4L2_CTRL_CLASS_USER = 0x980000;
+   private static final int V4L2_CID_BASE = V4L2_CTRL_CLASS_USER | 0x900;
+
+   private static final int V4L2_CID_AUDIO_MUTE = V4L2_CID_BASE + 9;
+
+
+
+   /*
+    * Turn on FM Rx/Tx.
+    * Rx = 1 and Tx = 2
+    */
+   public void fmOn(int fd, int device) {
+      FmReceiverJNI.setControlNative(fd, V4L2_CID_PRIVATE_TAVARUA_STATE, 1 );
+   }
+
+   /*
+    * Turn off FM Rx/Tx
+    */
+   public void fmOff(int fd){
+      FmReceiverJNI.setControlNative(fd, V4L2_CID_PRIVATE_TAVARUA_STATE, 2 );
+   }
+
+   /*
+    * set mute control
+    */
+   public void muteControl(int fd, boolean on) {
+      if (on)
+      {
+         int err = FmReceiverJNI.setControlNative(fd, V4L2_CID_AUDIO_MUTE, 3 );
+      } else
+      {
+         int err = FmReceiverJNI.setControlNative(fd, V4L2_CID_AUDIO_MUTE, 4 );
+      }
+   }
+
+   /*
+    * Tune FM core to specified freq.
+    */
+   public void setStation(int fd) {
+      Log.d(TAG, "** Tune Using: "+fd);
+      int ret = FmReceiverJNI.setFreqNative(fd, mFreq);
+      Log.d(TAG, "** Returned: "+ret);
+   }
+
+  /*
+   * Get currently tuned freq
+   */
+   public int getTunedFrequency(int fd) {
+      int frequency = FmReceiverJNI.getFreqNative(fd);
+      Log.d(TAG, "getTunedFrequency: "+frequency);
+      return frequency;
+   }
+
+   public int getFreq (){
+      return mFreq;
+   }
+
+   public void setFreq (int f){
+      mFreq = f;
+   }
+
+   /*
+    * Start search list for auto presets
+    */
+   public int searchStationList (int fd, int mode, int preset_num,
+                                   int dir, int pty )
+   {
+      int re;
+
+
+     /* set search mode. */
+      re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SRCHMODE, mode);
+      if (re != 0) {
+         return re;
+      }
+
+      /* set number of stations to be returned in the list */
+      re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SRCH_CNT, preset_num);
+      if (re != 0) {
+         return re;
+      }
+
+      // RDS search list?
+      if (pty > 0 ){
+        re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SRCH_PTY, pty);
+      }
+      if (re != 0) {
+         return re;
+      }
+
+      /* This triigers the search and once completed the FM core generates
+       * searchListComplete event */
+      re = FmReceiverJNI.startSearchNative (fd, dir );
+      if (re != 0) {
+         return re;
+      }
+      else {
+         return 0;
+      }
+
+   }
+
+   /* Read search list from buffer */
+   public int[] stationList (int fd)
+   {
+         int freq = 0;
+         int i=0;
+         int station_num;
+         float real_freq = 0;
+         int [] stationList;
+         byte [] sList = new byte[100];
+         int tmpFreqByte1=0;
+         int tmpFreqByte2=0;
+         float lowBand;
+
+
+         lowBand = (float) (FmReceiverJNI.getLowerBandNative(fd) / 1000.00);
+         Log.d(TAG, "lowBand: " + lowBand);
+         FmReceiverJNI.getBufferNative(fd, sList, 0);
+
+         station_num = (int)sList[0];
+         stationList = new int[station_num+1];
+         Log.d(TAG, "station_num: " + station_num);
+
+         for (i=0;i<station_num;i++) {
+            freq = 0;
+            Log.d(TAG, " Byte1 = " + sList[i*2+1]);
+            Log.d(TAG, " Byte2 = " + sList[i*2+2]);
+            tmpFreqByte1 = sList[i*2+1] & 0xFF;
+            tmpFreqByte2 = sList[i*2+2] & 0xFF;
+            Log.d(TAG, " tmpFreqByte1 = " + tmpFreqByte1);
+            Log.d(TAG, " tmpFreqByte2 = " + tmpFreqByte2);
+            freq = (tmpFreqByte1 & 0x03) << 8;
+            freq |= tmpFreqByte2;
+            Log.d(TAG, " freq: " + freq);
+            real_freq  = (float)(freq * 0.05) + lowBand;//tuner.rangelow / FREQ_MUL;
+            Log.d(TAG, " real_freq: " + real_freq);
+            stationList[i] = (int)(real_freq*1000);
+            Log.d(TAG, " stationList: " + stationList[i]);
+        }
+
+        try {
+          // mark end of list
+           stationList[station_num] = 0;
+        }
+        catch (ArrayIndexOutOfBoundsException e) {
+           Log.d(TAG, "ArrayIndexOutOfBoundsException !!");
+        }
+
+        return stationList;
+
+   }
+
+
+   /* configure various search parameters and start search */
+   public void searchStations (int fd, int mode, int dwell,
+                               int dir, int pty, int pi){
+      int re = 0;
+
+
+      Log.d(TAG, "Mode is " + mode + " Dwell is " + dwell);
+      Log.d(TAG, "dir is "  + dir + " PTY is " + pty);
+      Log.d(TAG, "pi is " + pi + " id " +  V4L2_CID_PRIVATE_TAVARUA_SRCHMODE);
+
+
+
+      re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SRCHMODE, mode);
+
+      re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SCANDWELL, dwell);
+
+      if (pty != 0)
+      {
+         re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SRCH_PTY, pty);
+      }
+
+      if (pi != 0)
+      {
+         re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_SRCH_PI, pi);
+      }
+
+      re = FmReceiverJNI.startSearchNative (fd, dir );
+
+   }
+
+   /* force mono/stereo mode */
+   public int stereoControl(int fd, boolean stereo) {
+
+     if (stereo){
+       return  FmReceiverJNI.setMonoStereoNative (fd, 1);
+     }
+     else {
+       return  FmReceiverJNI.setMonoStereoNative (fd, 0);
+     }
+
+
+   }
+
+
+   public void searchRdsStations(int mode,int dwelling,
+                                 int direction, int RdsSrchPty, int RdsSrchPI){
+   }
+
+   /*   public void searchStationList(int listMode,int direction,
+                                 int listMax,int pgmType) {
+   }
+   */
+
+   /* cancel search in progress */
+   public void cancelSearch (int fd){
+      FmReceiverJNI.cancelSearchNative(fd);
+   }
+
+   /* Set LPM. This disables all FM core interrupts */
+   public int setLowPwrMode (int fd, boolean lpmOn){
+
+      int re=0;
+
+      if (lpmOn){
+        re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_LP_MODE, 1);
+      }
+      else {
+        re = FmReceiverJNI.setControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_LP_MODE, 0);
+      }
+
+      return re;
+
+   }
+
+   /* get current powermode of the FM core. 1 for LPM and 0 Normal mode */
+   public int getPwrMode (int fd) {
+
+      int re=0;
+
+      re = FmReceiverJNI.getControlNative (fd, V4L2_CID_PRIVATE_TAVARUA_LP_MODE);
+
+      return re;
+
+   }
+
+}
diff --git a/core/java/android/hardware/fmradio/FmRxEvCallbacks.java b/core/java/android/hardware/fmradio/FmRxEvCallbacks.java
new file mode 100644
index 0000000..d2b6ffc
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmRxEvCallbacks.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+interface FmRxEvCallbacks {
+
+    public void FmRxEvEnableReceiver();
+    public void FmRxEvDisableReceiver();
+    public void FmRxEvRadioTuneStatus(int freq);
+    public void FmRxEvRdsLockStatus(boolean rdsAvail);
+    public void FmRxEvStereoStatus(boolean stereo);
+    public void FmRxEvServiceAvailable(boolean service);
+    public void FmRxEvSearchInProgress();
+    public void FmRxEvSearchComplete(int freq);
+    public void FmRxEvSearchListComplete();
+    public void FmRxEvRdsGroupData();
+    public void FmRxEvRdsPsInfo();
+    public void FmRxEvRdsRtInfo();
+    public void FmRxEvRdsAfInfo();
+
+}
diff --git a/core/java/android/hardware/fmradio/FmRxEvCallbacksAdaptor.java b/core/java/android/hardware/fmradio/FmRxEvCallbacksAdaptor.java
new file mode 100644
index 0000000..11ddded
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmRxEvCallbacksAdaptor.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+/**
+ *
+ * Class to be implemented for event callbacks
+ * @hide
+ */
+
+public class FmRxEvCallbacksAdaptor implements FmRxEvCallbacks {
+    public void FmRxEvEnableReceiver() {};
+    public void FmRxEvDisableReceiver() {};
+    public void FmRxEvRadioTuneStatus(int freq) {};
+    public void FmRxEvRdsLockStatus(boolean rdsAvail) {};
+    public void FmRxEvStereoStatus(boolean stereo) {};
+    public void FmRxEvServiceAvailable(boolean service) {};
+    public void FmRxEvSearchInProgress() {};
+    public void FmRxEvSearchComplete(int freq) {};
+    public void FmRxEvSearchListComplete() {};
+    public void FmRxEvRdsGroupData() {};
+    public void FmRxEvRdsPsInfo() {};
+    public void FmRxEvRdsRtInfo() {};
+    public void FmRxEvRdsAfInfo() {};
+}
+
diff --git a/core/java/android/hardware/fmradio/FmRxEventListner.java b/core/java/android/hardware/fmradio/FmRxEventListner.java
new file mode 100644
index 0000000..7453fae
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmRxEventListner.java
@@ -0,0 +1,153 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+import android.util.Log;
+
+
+class FmRxEventListner {
+
+
+    private final int EVENT_LISTEN = 1;
+
+    private enum FmRxEvents {
+      READY_EVENT,
+      TUNE_EVENT,
+      SEEK_COMPLETE_EVENT,
+      SCAN_NEXT_EVENT,
+      RAW_RDS_EVENT,
+      RT_EVENT,
+      PS_EVENT,
+      ERROR_EVENT,
+      BELOW_TH_EVENT,
+      ABOVE_TH_EVENT,
+      STEREO_EVENT,
+      MONO_EVENT,
+      RDS_AVAL_EVENT,
+      RDS_NOT_AVAL_EVENT,
+      TAVARUA_EVT_NEW_SRCH_LIST,
+      TAVARUA_EVT_NEW_AF_LIST
+    }
+
+    private Thread mThread;
+    private static final String TAG = "FMRadio";
+
+    public void startListner (final int fd, final FmRxEvCallbacks cb) {
+        /* start a thread and listen for messages */
+        mThread = new Thread(){
+            public void run(){
+
+                Log.d(TAG, "Starting listener " + fd);
+
+                while (true) {
+
+                    byte []buff = new byte[128];
+                    int i = FmReceiverJNI.getBufferNative (fd, buff, EVENT_LISTEN);
+                    Log.d(TAG, "Received <" +buff[0]+ "> event. Int: " + i);
+
+                    switch(buff[0]){
+
+                    case 0:
+                        Log.d(TAG, "Got READY_EVENT");
+                        cb.FmRxEvEnableReceiver();
+                        break;
+                    case 1:
+                        Log.d(TAG, "Got TUNE_EVENT");
+                        cb.FmRxEvRadioTuneStatus(FmReceiverJNI.getFreqNative(fd));
+                        break;
+                    case 2:
+                        Log.d(TAG, "Got SEEK_COMPLETE_EVENT");
+                        cb.FmRxEvSearchComplete(FmReceiverJNI.getFreqNative(fd));
+                        break;
+                    case 3:
+                        Log.d(TAG, "Got SCAN_NEXT_EVENT");
+                        cb.FmRxEvSearchInProgress();
+                        break;
+                    case 4:
+                        Log.d(TAG, "Got RAW_RDS_EVENT");
+                        cb.FmRxEvRdsGroupData();
+                        break;
+                    case 5:
+                        Log.d(TAG, "Got RT_EVENT");
+                        cb.FmRxEvRdsRtInfo();
+                        break;
+                    case 6:
+                        Log.d(TAG, "Got PS_EVENT");
+                        cb.FmRxEvRdsPsInfo();
+                        break;
+                    case 7:
+                        Log.d(TAG, "Got ERROR_EVENT");
+                        break;
+                    case 8:
+                        Log.d(TAG, "Got BELOW_TH_EVENT");
+                        cb.FmRxEvServiceAvailable (false);
+                        break;
+                    case 9:
+                        Log.d(TAG, "Got ABOVE_TH_EVENT");
+                        cb.FmRxEvServiceAvailable(true);
+                        break;
+                    case 10:
+                        Log.d(TAG, "Got STEREO_EVENT");
+                        cb.FmRxEvStereoStatus (true);
+                        break;
+                    case 11:
+                        Log.d(TAG, "Got MONO_EVENT");
+                        cb.FmRxEvStereoStatus (false);
+                        break;
+                    case 12:
+                        Log.d(TAG, "Got RDS_AVAL_EVENT");
+                        cb.FmRxEvRdsLockStatus (true);
+                        break;
+                    case 13:
+                        Log.d(TAG, "Got RDS_NOT_AVAL_EVENT");
+                        cb.FmRxEvRdsLockStatus (false);
+                        break;
+                    case 14:
+                        Log.d(TAG, "Got NEW_SRCH_LIST");
+                        cb.FmRxEvSearchListComplete ();
+                        break;
+                    case 15:
+                        Log.d(TAG, "Got NEW_AF_LIST");
+                        cb.FmRxEvRdsAfInfo();
+                        break;
+                    default:
+                        Log.d(TAG, "Unknown event");
+                        break;
+                    }
+                }
+            }
+        };
+        mThread.start();
+    }
+
+    public void stopListener(){
+        mThread.stop();
+    }
+
+}
diff --git a/core/java/android/hardware/fmradio/FmRxRdsData.java b/core/java/android/hardware/fmradio/FmRxRdsData.java
new file mode 100644
index 0000000..210cee0
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmRxRdsData.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+import android.util.Log;
+
+/** @hide */
+public class FmRxRdsData {
+
+
+    private String mRadioText;
+    private String mPrgmServices;
+    private int mPrgmId;
+    private int mPrgmType;
+    private int mFd;
+
+    /* V4L2 controls */
+    private static final int V4L2_CID_PRIVATE_BASE = 0x8000000;
+    private static final int V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_MASK = V4L2_CID_PRIVATE_BASE + 6;
+    private static final int V4L2_CID_PRIVATE_TAVARUA_RDSON = V4L2_CID_PRIVATE_BASE + 15;
+    private static final int V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC = V4L2_CID_PRIVATE_BASE + 16;
+    private static final int V4L2_CID_PRIVATE_TAVARUA_RDSD_BUF = V4L2_CID_PRIVATE_BASE + 19;
+    private static final int V4L2_CID_PRIVATE_TAVARUA_PSALL = V4L2_CID_PRIVATE_BASE + 20;
+
+
+    private static final int RDS_GROUP_RT = 0x1;
+    private static final int RDS_GROUP_PS = 1 << 1;
+    private static final int RDS_GROUP_AF = 1 << 2;
+    private static final int RDS_AF_AUTO  = 1 << 3;
+    private static final int RDS_PS_ALL   = 1 << 4;
+    private static final String LOGTAG="FmRxRdsData";
+
+
+    public FmRxRdsData (int fd)
+    {
+      mFd = fd;
+    }
+
+    /* turn on/off RDS processing */
+    public int rdsOn (boolean on)
+    {
+
+      int ret;
+
+      Log.d(LOGTAG, "In rdsOn: RDS is " + on);
+
+      if (on) {
+        ret = FmReceiverJNI.setControlNative (mFd, V4L2_CID_PRIVATE_TAVARUA_RDSON, 1);
+      }
+      else {
+        ret = FmReceiverJNI.setControlNative (mFd, V4L2_CID_PRIVATE_TAVARUA_RDSON, 0);
+      }
+
+
+      return ret;
+
+
+    }
+
+    /* process raw RDS group filtering */
+    public int rdsGrpOptions (int grpMask, int buffSize, boolean rdsFilter)
+    {
+
+        int rdsFilt;
+        int re;
+
+        byte rds_group_mask = (byte)FmReceiverJNI.getControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC);
+
+        rds_group_mask &= 0xFE;
+
+
+        if (rdsFilter)
+          rdsFilt = 1;
+        else
+          rdsFilt = 0;
+
+        rds_group_mask |= rdsFilt;
+
+        re = FmReceiverJNI.setControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC, rds_group_mask);
+
+        if (re != 0)
+          return re;
+
+        re = FmReceiverJNI.setControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSD_BUF, buffSize);
+
+        if (re != 0)
+          return re;
+
+
+        re = FmReceiverJNI.setControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_MASK, grpMask);
+
+        return re;
+
+
+    }
+
+    /* configure RT/PS/AF RDS processing */
+    public int rdsOptions (int rdsMask)
+    {
+
+        int re=0;
+
+        byte rds_group_mask = (byte)FmReceiverJNI.getControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC);
+        byte rdsFilt = 0;
+        int  psAllVal=rdsMask & RDS_PS_ALL;
+
+        Log.d(LOGTAG, "In rdsOptions: rdsMask: " + rdsMask);
+
+
+        rds_group_mask &= 0xC7;
+
+
+        rds_group_mask  |= ((rdsMask & 0x07) << 3);
+
+
+        re = FmReceiverJNI.setControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC, rds_group_mask);
+
+        re = FmReceiverJNI.setControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_PSALL, psAllVal >> 4 );
+
+        return re;
+
+    }
+
+    /* Enable auto seek to alternate frequency */
+    public int enableAFjump(boolean AFenable)
+    {
+
+      Log.d(LOGTAG, "In enableAFjump: AFenable: " + AFenable);
+
+      int rds_group_mask = FmReceiverJNI.getControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC);
+
+      Log.d(LOGTAG, "In enableAFjump: rds_group_mask: " + rds_group_mask);
+
+      if (AFenable) {
+        FmReceiverJNI.setControlNative(mFd ,V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC,
+                                         rds_group_mask | RDS_AF_AUTO);
+      }
+      else {
+        FmReceiverJNI.setControlNative(mFd, V4L2_CID_PRIVATE_TAVARUA_RDSGROUP_PROC,
+                                         rds_group_mask & ~RDS_GROUP_AF);
+      }
+      return 1;
+    }
+
+
+    public String getRadioText () {
+        return mRadioText;
+    }
+
+    public void setRadioText (String x) {
+
+        mRadioText = x;
+    }
+
+
+    public String getPrgmServices () {
+        return mPrgmServices;
+    }
+    public void setPrgmServices (String x) {
+        mPrgmServices = x;
+    }
+
+
+    public int getPrgmId () {
+        return mPrgmId;
+    }
+    public void setPrgmId (int x) {
+        mPrgmId = x;
+    }
+
+    public int getPrgmType () {
+        return mPrgmType;
+    }
+    public void setPrgmType (int x) {
+         mPrgmType = x;
+    }
+
+}
diff --git a/core/java/android/hardware/fmradio/FmTransceiver.java b/core/java/android/hardware/fmradio/FmTransceiver.java
new file mode 100644
index 0000000..8c95f27
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmTransceiver.java
@@ -0,0 +1,447 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+
+import android.util.Log;
+
+/** <code>FmTransceiver</code> is the superclass of classes
+ * <code>FmReceiver</code> and <code>FmTransmitter</code>
+ * @hide
+ */
+public class FmTransceiver
+{
+
+   /**
+    * FMConfigure FM Radio band setting for US/Europe
+    */
+   public static final int FM_US_BAND        =0;
+   /**
+    * FMConfigure FM Radio band setting for US/Europe
+    */
+   public static final int FM_EU_BAND        =1;
+   /**
+    * FMConfigure FM Radio band setting for Japan
+    */
+   public static final int FM_JAPAN_WIDE_BAND       =2;
+   /**
+    * FMConfigure FM Radio band setting for Japan-Wideband
+    */
+   public static final int FM_JAPAN_STANDARD_BAND   =3;
+   /**
+    * FMConfigure FM Radio band setting for "User defined" band
+    */
+   public static final int FM_USER_DEFINED_BAND     =4;
+
+   /**
+    * FM channel spacing settings = 200KHz
+    */
+   public static final int FM_CHSPACE_200_KHZ  =0;
+   /**
+    * FM channel spacing settings = 100KHz
+    */
+   public static final int FM_CHSPACE_100_KHZ  =1;
+   /**
+    * FM channel spacing settings = 50KHz
+    */
+   public static final int FM_CHSPACE_50_KHZ   =2;
+
+   /**
+    * FM de-emphasis/pre-emphasis settings = 75KHz
+    */
+   public static final int FM_DE_EMP75 = 0;
+   /**
+    * FM de-emphasis/pre-emphasis settings = 50KHz
+    */
+   public static final int FM_DE_EMP50 = 1;
+
+   /**
+    * RDS standard type: RBDS (North America)
+    */
+   public static final int FM_RDS_STD_RBDS    =0;
+   /**
+    * RDS standard type: RDS (Rest of the world)
+    */
+   public static final int FM_RDS_STD_RDS     =1;
+   /**
+    * RDS standard type: No RDS
+    */
+   public static final int FM_RDS_STD_NONE    =2;
+
+   protected static final int FM_RX    =1;
+   protected static final int FM_TX    =2;
+
+   private final int READY_EVENT = 0x01;
+   private final int TUNE_EVENT = 0x02;
+   private final int RDS_EVENT = 0x08;
+   private final int MUTE_EVENT = 0x04;
+   private final int SEEK_COMPLETE_EVENT = 0x03;
+
+   private final String TAG = "FmTransceiver";
+
+   protected static int sFd;
+   protected FmRxControls mControl;
+   protected int mPowerMode;
+   protected FmRxEventListner mRxEvents;
+   protected FmRxRdsData mRdsData;
+
+   /*==============================================================
+   FUNCTION:  acquire
+   ==============================================================*/
+   /**
+   *    Allows access to the V4L2 FM device.
+   *
+   *    This synchronous call allows a client to use the V4L2 FM
+   *    device. This must be the first call issued by the client
+   *    before any receiver interfaces can be used.
+   *
+   *    This call also powers up the FM Module.
+   *
+   *    @param device String that is path to radio device
+   *
+   *    @return true if V4L2 FM device acquired, false if V4L2 FM
+   *            device could not be acquired, possibly acquired by
+   *            other client
+   *    @see   #release
+   *
+   */
+   protected boolean acquire(String device){
+      boolean bStatus;
+      if (sFd == 0)
+      {
+         sFd = FmReceiverJNI.acquireFdNative("/dev/radio0");
+         Log.d(TAG, "** Opened "+ sFd);
+      } else
+      {
+         Log.d(TAG, "Already opened");
+      }
+      if(sFd != 0)
+      {
+         bStatus = true;
+      }
+      else
+      {
+         bStatus = false;
+      }
+      return (bStatus);
+   }
+
+   /*==============================================================
+   FUNCTION:  release
+   ==============================================================*/
+   /**
+   *    Releases access to the V4L2 FM device.
+   *    <p>
+   *    This synchronous call allows a client to release control of
+   *    V4L2 FM device.  This function should be called when the FM
+   *    device is no longer needed. This should be the last call
+   *    issued by the FM client. Once called, the client must call
+   *    #acquire to re-aquire the V4L2 device control before the
+   *    FM device can be used again.
+   *    <p>
+   *    Before the client can release control of the FM receiver
+   *    interface, it must disable the FM receiver, if the client
+   *    enabled it, and unregister any registered callback.  If the
+   *    client has ownership of the receiver, it will automatically
+   *    be returned to the system.
+   *    <p>
+   *    This call also powers down the FM Module.
+   *    <p>
+   *    @param device String that is path to radio device
+   *    @return true if V4L2 FM device released, false if V4L2 FM
+   *            device could not be released
+   *    @see   #acquire
+   */
+   protected boolean release(String device) {
+      if (sFd!=0)
+      {
+         FmReceiverJNI.closeFdNative(sFd);
+         Log.d(TAG, "Turned off: " + sFd);
+         sFd =0;
+      } else
+      {
+         Log.d(TAG, "Error turning off");
+         return false;
+      }
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  registerClient
+   ==============================================================*/
+   /**
+   *    Registers a callback for FM receiver event notifications.
+   *    <p>
+   *    This is a synchronous call used to register for event
+   *    notifications from the FM receiver driver. Since the FM
+   *    driver performs some tasks asynchronously, this function
+   *    allows the client to receive information asynchronously.
+   *    <p>
+   *    When calling this function, the client must pass a callback
+   *    function which will be used to deliver asynchronous events.
+   *    The argument callback must be a non-NULL value.  If a NULL
+   *    value is passed to this function, the registration will
+   *    fail.
+   *    <p>
+   *    The client can choose which events will be sent from the
+   *    receiver driver by simply implementing functions for events
+   *    it wishes to receive.
+   *    <p>
+   *
+   *    @param callback the callback to handle the events events
+   *                    from the FM receiver.
+   *    @return true if Callback registered, false if Callback
+   *            registration failed.
+   *
+   *    @see #acquire
+   *    @see #unregisterClient
+   *
+   */
+   public boolean registerClient(FmRxEvCallbacks callback){
+      boolean bReturnStatus = false;
+      if (callback!=null)
+      {
+         mRxEvents.startListner(sFd, callback);
+         bReturnStatus = true;
+      } else
+      {
+         Log.d(TAG, "Null, do nothing");
+      }
+      return bReturnStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  unregisterClient
+   ==============================================================*/
+   /**
+   *    Unregisters a client's event notification callback.
+   *    <p>
+   *    This is a synchronous call used to unregister a client's
+   *    event callback.
+   *    <p>
+   *    @return true always.
+   *
+   *    @see  #acquire
+   *    @see  #release
+   *    @see  #registerClient
+   *
+   */
+   public boolean unregisterClient () {
+      mRxEvents.stopListener();
+      return true;
+   }
+
+
+   /*==============================================================
+   FUNCTION:  registerTransmitClient
+   ==============================================================*/
+   /**
+   *    Registers a callback for FM Transmitter event
+   *    notifications.
+   *    <p>
+   *    This is a synchronous call used to register for event
+   *    notifications from the FM Transmitter driver. Since the FM
+   *    driver performs some tasks asynchronously, this function
+   *    allows the client to receive information asynchronously.
+   *    <p>
+   *    When calling this function, the client must pass a callback
+   *    function which will be used to deliver asynchronous events.
+   *    The argument callback must be a non-NULL value.  If a NULL
+   *    value is passed to this function, the registration will
+   *    fail.
+   *    <p>
+   *    The client can choose which events will be sent from the
+   *    receiver driver by simply implementing functions for events
+   *    it wishes to receive.
+   *    <p>
+   *
+   *    @param callback the callback to handle the events events
+   *                    from the FM Transmitter.
+   *    @return true if Callback registered, false if Callback
+   *            registration failed.
+   *
+   *    @see #acquire
+   *    @see #unregisterTransmitClient
+   *
+   */
+   public boolean registerTransmitClient(FmRxEvCallbacks callback){
+      boolean bReturnStatus = false;
+      if (callback!=null)
+      {
+         //mRxEvents.startListner(sFd, callback);
+         bReturnStatus = true;
+      } else
+      {
+         Log.d(TAG, "Null, do nothing");
+      }
+      return bReturnStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  unregisterTransmitClient
+   ==============================================================*/
+   /**
+   *    Unregisters Transmitter event notification callback.
+   *    <p>
+   *    This is a synchronous call used to unregister a Transmitter
+   *    client's event callback.
+   *    <p>
+   *    @return true always.
+   *
+   *    @see  #acquire
+   *    @see  #release
+   *    @see  #registerTransmitClient
+   *
+   */
+   public boolean unregisterTransmitClient () {
+      //mRxEvents.stopListener();
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  enable
+   ==============================================================*/
+   /**
+   *    Initializes the FM device.
+   *    <p>
+   *    This is a synchronous call is used to initialize the FM
+   *    tranceiver. If already initialized this function will
+   *    intialize the tranceiver with default settings. Only after
+   *    successfully calling this function can many of the FM device
+   *    interfaces be used.
+   *    <p>
+   *    When enabling the receiver, the client must also provide
+   *    the regional settings in which the receiver will operate.
+   *    These settings (included in configSettings) are typically
+   *    used for setting up the FM receiver for operating in a
+   *    particular geographical region. These settings can be
+   *    changed after the FM driver is enabled through the use of
+   *    the function #configure.
+   *    <p>
+   *    This call can only be issued by the owner of an FM
+   *    receiver.  To issue this call, the client must first
+   *    successfully call #acquire.
+   *    <p>
+   *    @param configSettings  the settings to be applied when
+   *                             turning on the radio
+   *    @return true if Initialization succeeded, false if
+   *            Initialization failed.
+   *    @see   #registerClient
+   *    @see   #disable
+   *
+   */
+   public boolean enable (FmConfig configSettings, int device){
+
+
+      Log.d(TAG, "turning on %d" + device);
+      mControl.fmOn(sFd, device);
+
+      Log.d(TAG, "Calling fmConfigure");
+      return FmConfig.fmConfigure (sFd, configSettings);
+
+   }
+
+   /*==============================================================
+   FUNCTION:  disable
+   ==============================================================*/
+   /**
+   *    Disables the FM Device.
+   *    <p>
+   *    This is a synchronous call used to disable the FM
+   *    device. This function is expected to be used when the
+   *    client no longer requires use of the FM device. Once
+   *    called, most functionality offered by the FM device will be
+   *    disabled until the client re-enables the device again via
+   *    #enable.
+   *    <p>
+   *    @return true if disabling succeeded, false if disabling
+   *            failed.
+   *    <p>
+   *    @see   #enable
+   *    @see   #registerClient
+   */
+   public boolean disable(){
+      mControl.fmOff(sFd);
+
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  configure
+   ==============================================================*/
+   /**
+   *     Reconfigures the device's regional settings
+   *    (FM Band, De-Emphasis, Channel Spacing, RDS/RBDS mode).
+   *    <p>
+   *    This is a synchronous call used to reconfigure settings on
+   *    the FM device. Included in the passed structure are
+   *    settings which typically differ from one geographical
+   *    region to another.
+   *    <p>
+   *    @param configSettings    Contains settings for the FM radio
+   *                             (FM band, De-emphasis, channel
+   *                             spacing, RDS/RBDS mode)
+   *    <p>
+   *    @return      true if configure succeeded, false if
+   *                 configure failed.
+   */
+   public boolean configure(FmConfig configSettings){
+
+      Log.d(TAG, "fmConfigure");
+
+      return  FmConfig.fmConfigure (sFd, configSettings);
+
+   }
+
+   /*==============================================================
+   FUNCTION:  setStation
+   ==============================================================*/
+   /**
+    *    Tunes the FM device to the specified FM frequency.
+    *    <p>
+    *    This method tunes the FM device to a station specified by the
+    *    provided frequency. Only valid frequencies within the band
+    *    set by enable or configure can be tuned by this function.
+    *    Attempting to tune to frequencies outside of the set band
+    *    will result in an error.
+    *    <p>
+    *    Once tuning to the specified frequency is completed, the
+    *    event callback FmRxEvRadioTuneStatus will be called.
+    *
+    *    @param frequencyKHz  Frequency (in kHz) to be tuned
+    *                         (Example: 96500 = 96.5Mhz)
+    *   @return true if setStation call was placed successfully,
+    *           false if setStation failed.
+    */
+   public boolean setStation (int frequencyKHz) {
+      mControl.setFreq(frequencyKHz);
+      mControl.setStation(sFd);
+
+      return true;
+   }
+}
diff --git a/core/java/android/hardware/fmradio/FmTransmitter.java b/core/java/android/hardware/fmradio/FmTransmitter.java
new file mode 100644
index 0000000..f1cddfd
--- /dev/null
+++ b/core/java/android/hardware/fmradio/FmTransmitter.java
@@ -0,0 +1,584 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package android.hardware.fmradio;
+/**
+ * This class contains all interfaces and types needed to control the FM transmitter.
+ * @hide
+ */
+public class FmTransmitter extends FmTransceiver
+{
+   /**
+    *  RAW RDS Groups Transmit Control : PAUSE
+    *
+    *  @see #RDS_GRPS_TX_RESUME
+    *  @see #RDS_GRPS_TX_STOP
+    *  @see #transmitRdsGroupControl
+    */
+   public static final int RDS_GRPS_TX_PAUSE=0;
+
+   /**
+    *  RAW RDS Groups Transmit Control : RESUME
+    *
+    *  @see #RDS_GRPS_TX_RESUME
+    *  @see #RDS_GRPS_TX_STOP
+    *  @see #transmitRdsGroupControl
+    */
+   public static final int RDS_GRPS_TX_RESUME=1;
+
+   /**
+    *  RAW RDS Groups Transmit Control : STOP Stop will also clear
+    *  the buffer in the driver.
+    *
+    *  @see #RDS_GRPS_TX_RESUME
+    *  @see #RDS_GRPS_TX_STOP
+    *  @see #transmitRdsGroupControl
+    */
+   public static final int RDS_GRPS_TX_STOP=2;
+
+   /**
+    *  Creates a transmitter object
+    */
+   public FmTransmitter(){
+      mControl = new FmRxControls();
+      mRdsData = new FmRxRdsData(sFd);
+      mRxEvents = new FmRxEventListner();
+   }
+
+   /**
+    *  Constructor for the transmitter class that takes path to
+    *  radio and event callback adapter
+    */
+   public FmTransmitter(String path, FmRxEvCallbacksAdaptor callbacks){
+   //TODO: Replace this prototype with the correct "Adaptor" when implemented.
+   //  public FmTransmitter(String path, FMTransmitterCallbacksAdaptor adaptor){
+      acquire(path);
+      registerTransmitClient(callbacks);
+      mControl = new FmRxControls();
+      mRdsData = new FmRxRdsData(sFd);
+      mRxEvents = new FmRxEventListner();
+   }
+
+   /*==============================================================
+   FUNCTION:  enable
+   ==============================================================*/
+   /**
+    *  Enables the FM device in Transmit Mode.
+    *  <p>
+    *  This is a synchronous method used to initialize the FM
+    *  receiver. If already initialized this function will
+    *  intialize the receiver with default settings. Only after
+    *  successfully calling this function can many of the FM device
+    *  interfaces be used.
+    *  <p>
+    *  When enabling the receiver, the application must also
+    *  provide the regional settings in which the transmitter will
+    *  operate. These settings (included in argument
+    *  configSettings) are typically used for setting up the FM
+    *  Transmitter for operating in a particular geographical
+    *  region. These settings can be changed after the FM driver
+    *  is enabled through the use of the function {@link
+    *  #configure}.
+    *  <p>
+    *  This command can only be issued by the owner of an FM
+    *  receiver.  To issue this command, the application must
+    *  first successfully call {@link #acquire}.
+    *  <p>
+    *  @param configSettings  the settings to be applied when
+    *                           turning on the radio
+    *  @return true if Initialization succeeded, false if
+    *          Initialization failed.
+    *  <p>
+    *  @see #enable
+    *  @see #registerTransmitClient
+    *  @see #disable
+    *
+    */
+   public boolean enable (FmConfig configSettings){
+      boolean status;
+
+      /* Enable the Transceiver common for both
+         receiver and transmitter
+         */
+      status = super.enable(configSettings, FmTransceiver.FM_TX);
+
+      /* Do transmitter Specific Enable Stuff here.*/
+
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  disable
+   ==============================================================*/
+   /**
+    *  Disables the FM Transmitter Device.
+    *  <p>
+    *  This is a synchronous command used to disable the FM
+    *  device. This function is expected to be used when the
+    *  application no longer requires use of the FM device. Once
+    *  called, most functionality offered by the FM device will be
+    *  disabled until the application re-enables the device again
+    *  via {@link #enable}.
+    *
+    *  <p>
+    *  @return true if disabling succeeded, false if disabling
+    *          failed.
+    *
+    *  @see #enable
+    *  @see #registerTransmitClient
+    */
+   public boolean disable(){
+      boolean status;
+      status = super.disable();
+      return true;
+   }
+
+   /*==============================================================
+   FUNCTION:  getPSFeatures
+   ==============================================================*/
+   /**
+    *  This function returns the features supported by the FM
+    *  driver when using {@link #setPSInfo}.
+    *  <p>
+    *  This function is used to get the features the FM driver
+    *  supports when transmitting Program Service information.
+    *  Included in the returned features is the number of Program
+    *  Service (PS) characters which can be transmitted using
+    *  {@link #setPSInfo}. If the driver supports continuous
+    *  transmission of Program Service Information, this function
+    *  will return a value greater than 0 for
+    *  FmPSFeatures.maxPSCharacters. Although the RDS/RBDS
+    *  standard defines each Program Service (PS) string as eight
+    *  characters in length, the FM driver may have the ability to
+    *  accept a string that is greater than eight character. This
+    *  extended string will thenbe broken up into multiple strings
+    *  of length eight and transmitted continuously.
+    *  <p>
+    *  When transmitting more than one string, the application may
+    *  want to control the timing of how long each string is
+    *  transmitted. Included in the features returned from this
+    *  function is the maximum Program Service string repeat count
+    *  (FmPSFeatures.maxPSStringRepeatCount). When using the
+    *  function {@link #setPSInfo}, the application can specify how
+    *  many times each string is repeated before the next string is
+    *  transmitted.
+    *
+    *  @return the Program service maximum characters and repeat
+    *          count
+    *
+    *  @see #setPSInfo
+    *
+    */
+   public FmPSFeatures getPSFeatures(){
+      FmPSFeatures psFeatures = new FmPSFeatures();
+      psFeatures.maxPSCharacters = 0;
+      psFeatures.maxPSStringRepeatCount = 0;
+      return psFeatures;
+   }
+
+   /*==============================================================
+   FUNCTION:  setPSInfo
+   ==============================================================*/
+   /**
+    *  Continuously transmit RDS/RBDS Program Service information
+    *  over an already tuned station.
+    *  <p>
+    *  This is a function used to continuously transmit Program
+    *  Service information over an already tuned station. While
+    *  Program Service information can be transmitted using {@link
+    *  #transmitRdsGroups} and 0A/0B groups, this function makes
+    *  the same output possible with limited input needed from the
+    *  application.
+    *  <p>
+    *  Included in the Program Service information is an RDS/RBDS
+    *  program type (PTY), and one or more Program Service
+    *  strings. The program type (PTY) is used to describe the
+    *  content being transmitted and follows the RDS/RBDS program
+    *  types described in the RDS/RBDS specifications.
+    *  <p>
+    *  Program Service information also includes an eight
+    *  character string. This string can be used to display any
+    *  information, but is typically used to display information
+    *  about the audio being transmitted. Although the RDS/RBDS
+    *  standard defines a Program Service (PS) string as eight
+    *  characters in length, the FM driver may have the ability to
+    *  accept a string that is greater than eight characters. This
+    *  extended string will then be broken up into multiple eight
+    *  character strings which will be transmitted continuously.
+    *  All strings passed to this function must be terminated by a
+    *  null character (0x00).
+    *  <p>
+    *  When transmitting more than one string, the application may
+    *  want to control the timing of how long each string is
+    *  transmitted. To control this timing and to ensure that the FM
+    *  receiver receives each string, the application can specify
+    *  how many times each string is repeated before the next string
+    *  is transmitted. This command can only be issued by the owner
+    *  of an FM transmitter.
+    *
+    *  <p>
+    *  Use {@link #setPSRTProgramType} to update the ProgramType to
+    *  be used as part of the PS Information.
+    *
+    *  Note: psStr should contain strings each of 8 characters or
+    *        less. If the string is greater than 8 characters, the
+    *        string will be truncated.
+    *
+    *  @param psStr the program service strings to transmit
+    *  @param pty the program type to use in the program Service
+    *             information.
+    *  @param repeatCount the number of times each 8 char string is
+    *                     repeated before next string
+    *
+    *  @return true if PS information was successfully sent to the
+    *             driver, false if PS information could not be sent
+    *             to the driver.
+    *
+    *  @see #getPSFeatures
+    *  @see #setPSRTProgramType
+    *  @see #stopPSInfo
+    */
+   public boolean setPSInfo(String[] psStr, int pty, long repeatCount){
+       boolean bStatus = false;
+
+       return bStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  stopPSInfo
+   ==============================================================*/
+   /**
+    *  Stop an active Program Service transmission.
+    *
+    *  <p>
+    *  This is a function used to stop an active Program Service transmission
+    *  started by {@link #setPSInfo}.
+    *
+    *  @return true if Stop PS information was successfully sent to
+    *             the driver, false if Stop PS information could not
+    *             be sent to the driver.
+    *
+    *  @see #getPSFeatures
+    *  @see #setPSInfo
+    *
+    */
+   public boolean stopPSInfo(){
+      boolean bStatus = false;
+
+      return bStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  setPSInfo
+   ==============================================================*/
+   /**
+    *  Continuously transmit RDS/RBDS RadioText information over an
+    *  already tuned station.
+    *
+    *  <p>
+    *  This is a function used to continuously transmit RadioText
+    *  information over an already tuned station. While RadioText
+    *  information can be transmitted using
+    *  {@link #transmitRdsGroups} and 2A/2B groups, this function
+    *  makes the same output possible with limited input needed from
+    *  the application.
+    *  <p>
+    *  Included in the RadioText information is an RDS/RBDS program type (PTY),
+    *  and a single string of up to 64 characters. The program type (PTY) is used
+    *  to describe the content being transmitted and follows the RDS/RBDS program
+    *  types described in the RDS/RBDS specifications.
+    *  <p>
+    *  RadioText information also includes a string that consists of up to 64
+    *  characters. This string can be used to display any information, but is
+    *  typically used to display information about the audio being transmitted.
+    *  This RadioText string is expected to be at 64 characters in length, or less
+    *  than 64 characters and terminated by a return carriage (0x0D). All strings
+    *  passed to this function must be terminated by a null character (0x00).
+    *  <p>
+    *  Use {@link #setPSRTProgramType} to update the ProgramType to
+    *  be used as part of the RT Information.
+    *
+    *  Note: rtStr should contain a maximum of 64 characters.
+    *        If the string is greater than 64 characters, the string
+    *        will be truncated to 64 characters.
+    *
+    *  @param rtStr the Radio Text string to transmit
+    *
+    *  @return true if RT information String was successfully sent
+    *             to the driver, false if RT information string
+    *             could not be sent to the driver.
+    *
+    *  @see #setPSRTProgramType
+    *  @see #stopRTInfo
+    */
+   public boolean setRTInfo(String rtStr){
+      boolean bStatus = false;
+
+      return bStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  stopRTInfo
+   ==============================================================*/
+   /**
+    *  Stop an active Radio Text information transmission.
+    *
+    *  <p>
+    *  This is a function used to stop an active Radio Text
+    *  transmission started by {@link #setRTInfo}.
+    *
+    *  @return true if Stop RT information was successfully sent to
+    *             the driver, false if Stop RT information could not
+    *             be sent to the driver.
+    *
+    *  @see #setRTInfo
+    *
+    */
+   public boolean stopRTInfo(){
+      boolean bStatus = false;
+
+      return bStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  setPSRTProgramType
+   ==============================================================*/
+   /**
+    *  Set the Program Type to be used for Continuously transmit
+    *  RDS/RBDS Program Service information and RDS/RBDS RadioText
+    *  information.
+    *  <p>
+    *  This is a function to set the Program Type to be used while
+    *  transmitting Program Service and Radio Text Information.
+    *  <p>
+    *  Included in the Program Service information is an RDS/RBDS program type (PTY), and
+    *  one or more Program Service strings. The program type (PTY)
+    *  is used to describe the content being transmitted and follows
+    *  the RDS/RBDS program types described in the RDS/RBDS
+    *  specifications.
+    *  <p>
+    *  Included in the RadioText information is an RDS/RBDS program type (PTY),
+    *  and a single string of up to 64 characters. The program type (PTY) is used
+    *  to describe the content being transmitted and follows the RDS/RBDS program
+    *  types described in the RDS/RBDS specifications.
+    *
+    *  Note: If the PS or RT transmission is currently active, the
+    *  PTY change will take effect when the current transmission is
+    *  complete. Typically  setPSRTProgramType should be called
+    *  before {@link #setPSInfo} or {@link #setRTInfo} is started.
+    *
+    *  @param pty the program type to use in the program Service
+    *             information and Radio Text information.
+    *
+    *  @return true if the driver was updated to use the new
+    *             Program Type, false if the driver could not be
+    *             updated.
+    *
+    *  @see #setPSInfo
+    *  @see #setRTInfo
+    *
+    */
+   public boolean setPSRTProgramType(int pty){
+      boolean bStatus = false;
+
+      return bStatus;
+   }
+
+
+   /*==============================================================
+   FUNCTION:  getRdsGroupBufSize
+   ==============================================================*/
+   /**
+    *  Get the maximum number of RDS/RBDS groups which can be passed
+    *  to the FM driver.
+    *  <p>
+    *  This is a function used to determine the maximum RDS/RBDS
+    *  buffer size for use when calling {@link #transmitRdsGroups}
+    *
+    *  @return the maximum number of RDS/RBDS groups which can be
+    *  passed to the FM driver at any one time.
+    *
+    */
+   public int getRdsGroupBufSize(){
+      return 0;
+   }
+
+
+   /*==============================================================
+   FUNCTION:  transmitRdsGroups
+   ==============================================================*/
+   /**
+    *  This function will transmit RDS/RBDS groups over an already tuned station.
+    *  <p>
+    *  This function accepts a buffer (rdsGroups) containing one or
+    *  more RDS groups. When sending this buffer, the application
+    *  must also indicate how many groups should be taken from this
+    *  buffer (numGroupsToTransmit). It may be possible that the FM
+    *  driver can not accept the number of group contained in the
+    *  buffer and will indicate how many group were actually
+    *  accepted through the return value.
+    *
+    *  <p>
+    *  The FM driver will indicate to the application when it is
+    *  ready to accept more data via both the
+    *  "onRDSGroupsAvailable()" and "onRDSGroupsComplete()" events
+    *  callbacks. The "onRDSGroupsAvailable()" callback will
+    *  indicate to the application that the FM driver can accept
+    *  additional groups even thoughall groups may not have been
+    *  passed to the FM transmitter. The onRDSGroupsComplete()
+    *  callback will indicate when the FM driver has a complete
+    *  buffer to transmit RDS data. In many cases all data passed to
+    *  the FM driver will be passed to the FM hardware and only a
+    *  onRDSGroupsComplete() event will be generated by the
+    *  FM driver.
+    *  <p> If the application attempts to send more groups than the
+    *  FM driver can handle, the application must wait until it
+    *  receives a onRDSGroupsAvailable or a onRDSGroupsComplete
+    *  event before attempting to transmit more groups. Failure to
+    *  do so may result in no group being consumed by the FM driver.
+    *  <p> It is important to note that switching between continuous
+    *  and non-continuous transmission of RDS groups can only happen
+    *  when no RDS/RBDS group transmission is underway. If an
+    *  RDS/RBDS group transmission is already underway, the
+    *  application must wait for a onRDSGroupsComplete. If the application
+    *  wishes to switch from continuous to non-continuous (or
+    *  vice-versa) without waiting for the current transmission to
+    *  complete, the application can clear all remaining groups
+    *  using the {@link #transmitRdsGroupControl} command.
+    *  <p>
+    *  Once completed, this command will generate a
+    *  onRDSGroupsComplete event to all registered applications.
+    *
+    *  @param rdsGroups The RDS/RBDS groups buffer to transmit.
+    *  @param numGroupsToTransmit The number of groups in the buffer
+    *                             to transmit.
+    *
+    *  @return The number of groups the FM driver actually accepted.
+    *          A value >0 indicates the command was successfully
+    *          accepted and a return value of "-1" indicates error.
+    *
+    *  @see #transmitRdsGroupControl
+    */
+
+   public int transmitRdsGroups(byte[] rdsGroups, long numGroupsToTransmit){
+      return -1;
+   }
+
+   /*==============================================================
+   FUNCTION:  transmitRdsGroupControl
+   ==============================================================*/
+   /**
+    *  Pause/Resume RDS/RBDS group transmission, or stop and clear
+    *  all RDS groups.
+    *  <p>
+    *  This is a function used to used to pause/resume RDS/RBDS
+    *  group transmission, or stop and clear all RDS groups. This
+    *  function can be used with to control continuous and
+    *  non-continuous RDS/RBDS group transmissions.
+    *  <p>
+    *  @param ctrlCmd The Tx RDS group control.
+    *
+    *  @return true if RDS Group Control command was
+    *             successfully sent to the driver, false if RDS
+    *             Group Control command could not be sent to the
+    *             driver.
+    *
+    *  @see #transmitRdsGroups
+    */
+   public boolean transmitRdsGroupControl(int ctrlCmd){
+      boolean bStatus = false;
+
+      return bStatus;
+   }
+
+   /*==============================================================
+   FUNCTION:  isAntennaAvailable
+   ==============================================================*/
+   /**
+    *  Read if an internal Antenna is available for the FM
+    *  device.
+    *  <p>
+    *
+    *  This method is available to find that if an internal
+    *  Antenna is present or not
+    *
+    *
+    *  @return true if an internal Antenna is available, false if
+    *          if an internal antenna is not available and an
+    *          external Antenna has to be used.
+    *
+    */
+   boolean isAntennaAvailable()
+   {
+      return true;
+   }
+
+
+   /**
+    *  An object that contains the PS Features as configured using
+    *  {@link #setPSInfo}.
+    *
+    *  @see #setPSInfo
+    *  @see #getPSFeatures
+    */
+   public class FmPSFeatures
+   {
+      public int maxPSCharacters;
+      public int maxPSStringRepeatCount;
+   };
+
+   /**
+    *  The interface that provides the applications to get callback
+    *  for asynchronous events.
+    *  An Adapter that implements this interface needs to be used to
+    *  register to receive the callbacks using {@link
+    *  #registerTransmitClient}
+    *
+    *  @see #registerTransmitClient
+    */
+   public interface TransmitterCallbacks
+   {
+      /**
+       *  The callback indicates that the transmitter is tuned to a
+       *  new frequency Typically received after setStation.
+       */
+      public void onTuneFrequencyChange(int freq);
+
+      /**
+       * The callback to indicate to the application that the FM
+       * driver can accept additional groups even though all groups
+       * may not have been passed to the FM transmitter.
+       */
+      public void onRDSGroupsAvailable();
+      /**
+       *  The callback will indicate when the FM driver has a complete
+       *  buffer to transmit RDS data.
+       */
+      public void onRDSGroupsComplete();
+   };
+}
diff --git a/core/java/android/net/MobileDataStateTracker.java b/core/java/android/net/MobileDataStateTracker.java
index 4d89df3..afe8488 100644
--- a/core/java/android/net/MobileDataStateTracker.java
+++ b/core/java/android/net/MobileDataStateTracker.java
@@ -87,20 +87,17 @@ public class MobileDataStateTracker extends NetworkStateTracker {
             mEnabled = false;
         }
 
-        mDnsPropNames = new String[] {
-                "net.rmnet0.dns1",
-                "net.rmnet0.dns2",
-                "net.eth0.dns1",
-                "net.eth0.dns2",
-                "net.eth0.dns3",
-                "net.eth0.dns4",
-                "net.gprs.dns1",
-                "net.gprs.dns2",
-                "net.ppp0.dns1",
-                "net.ppp0.dns2"};
-
+        String[] ifNames = SystemProperties.get(
+            "mobiledata.interfaces",
+            "rmnet0,eth0,gprs,ppp0"
+        ).split(",");
+
+        mDnsPropNames = new String[2 * ifNames.length];
+        for (int i = 0; i < ifNames.length; ++i) {
+            mDnsPropNames[2*i+0] = "net." + ifNames[i] + ".dns1";
+            mDnsPropNames[2*i+1] = "net." + ifNames[i] + ".dns2";
+        }
     }
-
     /**
      * Begin monitoring mobile data connectivity.
      */
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 741dddd..be65499 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -3466,6 +3466,12 @@ public final class Settings {
                 "inet_condition_debounce_down_delay";
 
         /**
+         * Virtual network roaming
+         * @hide
+         */
+        public static final String MVNO_ROAMING = "button_mvno_roaming_key";
+
+        /**
          * @hide
          */
         public static final String[] SETTINGS_TO_BACKUP = {
diff --git a/core/java/android/util/TimeUtils.java b/core/java/android/util/TimeUtils.java
index 85ce5e1..b1e5362 100644
--- a/core/java/android/util/TimeUtils.java
+++ b/core/java/android/util/TimeUtils.java
@@ -110,6 +110,52 @@ public class TimeUtils {
 
         return best;
     }
+    
+    /**
+     * Returns the ID of the specified country's primary time zone.
+     * Returns null if no suitable zone could be found.
+     * @hide
+     */
+    public static String getPrimaryTimeZoneID(String country) {
+        if (country == null) {
+            return null;
+        }
+
+        String id = null;
+
+        Resources r = Resources.getSystem();
+        XmlResourceParser parser = r.getXml(com.android.internal.R.xml.time_zones_by_country);
+
+        try {
+            XmlUtils.beginDocument(parser, "timezones");
+
+            while (true) {
+                XmlUtils.nextElement(parser);
+
+                String element = parser.getName();
+                if (element == null || !(element.equals("timezone"))) {
+                    break;
+                }
+
+                String code = parser.getAttributeValue(null, "code");
+
+                if (country.equals(code)) {
+                    if (parser.next() == XmlPullParser.TEXT) {
+                        id = parser.getText();
+                        break;
+                    }
+                }
+            }
+        } catch (XmlPullParserException e) {
+            Log.e(TAG, "Got exception while getting preferred time zone.", e);
+        } catch (IOException e) {
+            Log.e(TAG, "Got exception while getting preferred time zone.", e);
+        } finally {
+            parser.close();
+        }
+
+        return id;
+    }
 
     /**
      * Returns a String indicating the version of the time zone database currently
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index 12b9ca5..0dfbe05 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -142,6 +142,52 @@ LOCAL_SRC_FILES:= \
 	android_content_res_ObbScanner.cpp \
     android_content_res_Configuration.cpp
 
+ifeq ($(BOARD_HAVE_FM_RADIO),true)
+    ## There's a difference. BOARD_HAVE_FM_RADIO enabled the runtime
+    ## without modifying the audiosystem (which HAVE_FM_RADIO does)
+    LOCAL_CFLAGS += -DBOARD_HAVE_FM_RADIO
+    ifeq ($(BOARD_FM_DEVICE),)
+        BOARD_FM_DEVICE := $(BOARD_WLAN_DEVICE)
+    endif
+
+    ifeq ($(BOARD_FM_DEVICE),si4709)
+        LOCAL_SRC_FILES += android_hardware_fm_si4709.cpp
+    endif
+    ifeq ($(BOARD_FM_DEVICE),si4708)
+        LOCAL_SRC_FILES += android_hardware_fm_si4708.cpp
+    endif
+    ifeq ($(BOARD_FM_DEVICE),bcm2049)
+	LOCAL_CFLAGS += -DHAS_BCM20780
+        LOCAL_SRC_FILES += android_hardware_fm_bcm4325.cpp
+    endif
+    ifeq ($(BOARD_FM_DEVICE),bcm4329)
+        LOCAL_SRC_FILES += android_hardware_fm_bcm4325.cpp
+    endif
+    ifeq ($(BOARD_FM_DEVICE),bcm4325)
+        LOCAL_SRC_FILES += android_hardware_fm_bcm4325.cpp
+    endif
+    ifeq ($(BOARD_FM_DEVICE),wl1251)
+        LOCAL_SRC_FILES += android_hardware_fm_wl1271.cpp
+    endif
+    ifeq ($(BOARD_FM_DEVICE),wl1271)
+        LOCAL_SRC_FILES += android_hardware_fm_wl1271.cpp
+    endif
+    ifeq ($(BOARD_FM_DEVICE),ti-st)
+        LOCAL_SRC_FILES += android_hardware_fm_ti-st.cpp
+        LOCAL_SHARED_LIBRARIES += libfmstack libmcphal
+        FMSTACK := hardware/ti/wpan/fmradio/fm_stack
+        LOCAL_C_INCLUDES += $(FMSTACK)/HSW_FMStack/stack/inc/ \
+                            $(FMSTACK)/MCP_Common/Platform/fmhal/LINUX/common/inc/ \
+                            $(FMSTACK)/MCP_Common/Platform/os/LINUX/common/inc \
+                            $(FMSTACK)/MCP_Common/inc/ \
+                            $(FMSTACK)/MCP_Common/Platform/inc/ \
+                            $(FMSTACK)/MCP_Common/Platform/os/LINUX/android_zoom2/inc/ \
+                            $(FMSTACK)/MCP_Common/Platform/fmhal/inc/int/ \
+                            $(FMSTACK)/MCP_Common/Platform/fmhal/inc \
+                            $(FMSTACK)/HSW_FMStack/stack/inc/int/
+    endif
+endif
+
 LOCAL_C_INCLUDES += \
 	$(JNI_H_INCLUDE) \
 	$(LOCAL_PATH)/android/graphics \
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index d9759bf..70201af 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -89,6 +89,10 @@ extern int register_android_message_digest_sha1(JNIEnv *env);
 
 extern int register_android_util_FloatMath(JNIEnv* env);
 
+#if defined(HAVE_FM_RADIO) || defined (BOARD_HAVE_FM_RADIO)
+extern int register_android_hardware_fm_fmradio(JNIEnv* env);
+#endif
+
 namespace android {
 
 /*
@@ -1260,6 +1264,9 @@ static const RegJNIRec gRegJNI[] = {
     REG_JNI(register_android_os_MemoryFile),
     REG_JNI(register_com_android_internal_os_ZygoteInit),
     REG_JNI(register_android_hardware_Camera),
+#if defined(HAVE_FM_RADIO) || defined (BOARD_HAVE_FM_RADIO)
+    REG_JNI(register_android_hardware_fm_fmradio),
+#endif
     REG_JNI(register_android_hardware_SensorManager),
     REG_JNI(register_android_media_AudioRecord),
     REG_JNI(register_android_media_AudioSystem),
diff --git a/core/jni/android_hardware_fm_bcm4325.cpp b/core/jni/android_hardware_fm_bcm4325.cpp
new file mode 100644
index 0000000..1e010bf
--- /dev/null
+++ b/core/jni/android_hardware_fm_bcm4325.cpp
@@ -0,0 +1,518 @@
+/*
+ * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *        * Redistributions of source code must retain the above copyright
+ *            notice, this list of conditions and the following disclaimer.
+ *        * Redistributions in binary form must reproduce the above copyright
+ *            notice, this list of conditions and the following disclaimer in the
+ *            documentation and/or other materials provided with the distribution.
+ *        * Neither the name of Code Aurora nor
+ *            the names of its contributors may be used to endorse or promote
+ *            products derived from this software without specific prior written
+ *            permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.    IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOGI printf
+#define LOG_TAG "fmradio"
+
+#include "jni.h"
+#include "nativehelper/JNIHelp.h"
+#include "utils/Log.h"
+#include "utils/misc.h"
+#include "android_runtime/AndroidRuntime.h"
+#include <cutils/properties.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/videodev2.h>
+#include <math.h>
+
+#define FM_JNI_SUCCESS 0L
+#define FM_JNI_FAILURE -1L
+#define SEARCH_DOWN 0
+#define SEARCH_UP 1
+#define TUNE_MULT 16000
+enum search_dir_t {
+    SEEK_UP,
+    SEEK_DN,
+    SCAN_UP,
+    SCAN_DN
+};
+enum BCM_FM_CMD
+{
+    BCM4325_I2C_FM_RDS_SYSTEM = 0x00,                /*0x00  FM enable, RDS enable*/
+    BCM4325_I2C_FM_CTRL,                             /*0x01  Band select, mono/stereo blend, mono/stearo select*/
+    BCM4325_I2C_RDS_CTRL0,                           /*0x02  RDS/RDBS, flush FIFO*/
+    BCM4325_I2C_RDS_CTRL1,                           /*0x03  Not used*/
+    BCM4325_I2C_FM_AUDIO_PAUSE,                      /*0x04  Pause level and time constant*/
+    BCM4325_I2C_FM_AUDIO_CTRL0,                      /*0x05  Mute, volume, de-emphasis, route parameters, BW select*/
+    BCM4325_I2C_FM_AUDIO_CTRL1,                      /*0x06  Mute, volume, de-emphasis, route parameters, BW select*/
+    BCM4325_I2C_FM_SEARCH_CTRL0,                     /*0x07  Search parameters such as stop level, up/down*/
+    BCM4325_I2C_FM_SEARCH_CTRL1,                     /*0x08  Not used*/
+    BCM4325_I2C_FM_SEARCH_TUNE_MODE,                 /*0x09  Search/tune mode and stop*/
+    BCM4325_I2C_FM_FREQ0,                            /*0x0a  Set and get frequency*/
+    BCM4325_I2C_FM_FREQ1,                            /*0x0b  Set and get frequency*/
+    BCM4325_I2C_FM_AF_FREQ0,                         /*0x0c  Set alternate jump frequency*/
+    BCM4325_I2C_FM_AF_FREQ1,                         /*0x0d  Set alternate jump frequency*/
+    BCM4325_I2C_FM_CARRIER,                          /*0x0e  IF frequency error*/
+    BCM4325_I2C_FM_RSSI,                             /*0x0f  Recived signal strength*/
+    BCM4325_I2C_FM_RDS_MASK0,                        /*0x10  FM and RDS IRQ mask register*/
+    BCM4325_I2C_FM_RDS_MASK1,                        /*0x11  FM and RDS IRQ mask register*/
+    BCM4325_I2C_FM_RDS_FLAG0,                        /*0x12  FM and RDS flag register*/
+    BCM4325_I2C_FM_RDS_FLAG1,                        /*0x13  FM and RDS flag register*/
+    BCM4325_I2C_RDS_WLINE,                           /*0x14  FIFO water line set level*/
+    BCM4325_I2C_RDS_BLKB_MATCH0,                     /*0x16  Block B match pattern*/
+    BCM4325_I2C_RDS_BLKB_MATCH1,                     /*0x17  Block B match pattern*/
+    BCM4325_I2C_RDS_BLKB_MASK0,                      /*0x18  Block B mask pattern*/
+    BCM4325_I2C_RDS_BLKB_MASK1,                      /*0x19  Block B mask pattern*/
+    BCM4325_I2C_RDS_PI_MATCH0,                       /*0x1a  PI match pattern*/
+    BCM4325_I2C_RDS_PI_MATCH1,                       /*0x1b  PI match pattern*/
+    BCM4325_I2C_RDS_PI_MASK0,                        /*0x1c  PI mask pattern*/
+    BCM4325_I2C_RDS_PI_MASK1,                        /*0x1d  PI mask pattern*/
+    BCM4325_I2C_FM_RDS_BOOT,                         /*0x1e  FM_RDS_BOOT register*/
+    BCM4325_I2C_FM_RDS_TEST,                         /*0x1f  FM_RDS_TEST register*/
+    BCM4325_I2C_SPARE0,                              /*0x20  Spare register #0*/
+    BCM4325_I2C_SPARE1,                              /*0x21  Spare register #1*/
+    /*0x21-0x26 Reserved*/
+    BCM4325_I2C_FM_RDS_REV_ID = 0x28,                /*0x28  Revision ID of the FM demodulation core*/
+    BCM4325_I2C_SLAVE_CONFIGURATION,                 /*0x29  Enable/disable I2C slave. Configure I2C slave address*/
+    /*0x2a-0x7f Reserved*/
+    BCM4325_I2C_FM_PCM_ROUTE = 0x4d,                 /*0x4d  Controls routing of FM audio output to either PM or Bluetooth SCO*/
+
+    BCM4325_I2C_RDS_DATA = 0x80,                     /*0x80  Read RDS tuples(3 bytes each)*/
+
+    BCM4325_I2C_FM_BEST_TUNE = 0x90,                 /*0x90  Best tune mode enable/disable for AF jump*/
+    /*0x91-0xfb Reserved*/
+    BCM4325_I2C_FM_SEARCH_METHOD = 0xfc,             /*0xfc  Select search methods: normal, preset, RSSI monitoring*/
+    BCM4325_I2C_FM_SEARCH_STEPS,                     /*0xfd  Adjust search steps in units of 1kHz to 100kHz*/
+    BCM4325_I2C_FM_MAX_PRESET,                       /*0xfe  Sets the maximum number of preset channels found for FM scan command*/
+    BCM4325_I2C_FM_PRESET_STATION,                   /*0xff  Read the number of preset stations returned after a FM scan command*/
+};
+
+
+/*! @brief Size of writes to BCM4325: 1 byte for opcode/register and 1 bytes for data */
+#define BCM4325_WRITE_CMD_SIZE                   2
+
+/* Defines for read/write sizes to the BCM4325 */
+#define BCM4325_REG_SIZE                         1
+#define BCM4325_RDS_SIZE                         3
+#define BCM4325_MAX_READ_SIZE                    3
+
+/* Defines for the FM_RDS_SYSTEM register */
+#define BCM4325_FM_RDS_SYSTEM_OFF                0x00
+#define BCM4325_FM_RDS_SYSTEM_FM                 0x01
+#define BCM4325_FM_RDS_SYSTEM_RDS                0x02
+
+#define BCM4325_FM_CTRL_BAND_EUROPE_US           0x00
+#define BCM4325_FM_CTRL_BAND_JAPAN               0x01
+#define BCM4325_FM_CTRL_AUTO                     0x02
+#define BCM4325_FM_CTRL_MANUAL                   0x00
+#define BCM4325_FM_CTRL_STEREO                   0x04
+#define BCM4325_FM_CTRL_MONO                     0x00
+#define BCM4325_FM_CTRL_SWITCH                   0x08
+#define BCM4325_FM_CTRL_BLEND                    0x00
+
+#define BCM4325_FM_AUDIO_CTRL0_RF_MUTE_ENABLE    0x01
+#define BCM4325_FM_AUDIO_CTRL0_RF_MUTE_DISABLE   0x00
+#define BCM4325_FM_AUDIO_CTRL0_MANUAL_MUTE_ON    0x02
+#define BCM4325_FM_AUDIO_CTRL0_MANUAL_MUTE_OFF   0x00
+#define BCM4325_FM_AUDIO_CTRL0_DAC_OUT_LEFT_ON   0x04
+#define BCM4325_FM_AUDIO_CTRL0_DAC_OUT_LEFT_OFF  0x00
+#define BCM4325_FM_AUDIO_CTRL0_DAC_OUT_RIGHT_ON  0x08
+#define BCM4325_FM_AUDIO_CTRL0_DAC_OUT_RIGHT_OFF 0x00
+#define BCM4325_FM_AUDIO_CTRL0_ROUTE_DAC_ENABLE  0x10
+#define BCM4325_FM_AUDIO_CTRL0_ROUTE_DAC_DISABLE 0x00
+#define BCM4325_FM_AUDIO_CTRL0_ROUTE_I2S_ENABLE  0x20
+#define BCM4325_FM_AUDIO_CTRL0_ROUTE_I2S_DISABLE 0x00
+#define BCM4325_FM_AUDIO_CTRL0_DEMPH_75US        0x40
+#define BCM4325_FM_AUDIO_CTRL0_DEMPH_50US        0x00
+/* Defines for the SEARCH_CTRL0 register */
+/*Bit 7: Search up/down*/
+#define BCM4325_FM_SEARCH_CTRL0_UP               0x80
+#define BCM4325_FM_SEARCH_CTRL0_DOWN             0x00
+
+/* Defines for FM_SEARCH_TUNE_MODE register */
+#define BCM4325_FM_TERMINATE_SEARCH_TUNE_MODE    0x00
+#define BCM4325_FM_PRE_SET_MODE                  0x01
+#define BCM4325_FM_AUTO_SEARCH_MODE              0x02
+#define BCM4325_FM_AF_JUMP_MODE                  0x03
+
+#define BCM4325_FM_FLAG_SEARCH_TUNE_FINISHED     0x01
+#define BCM4325_FM_FLAG_SEARCH_TUNE_FAIL         0x02
+#define BCM4325_FM_FLAG_RSSI_LOW                 0x04
+#define BCM4325_FM_FLAG_CARRIER_ERROR_HIGH       0x08
+#define BCM4325_FM_FLAG_AUDIO_PAUSE_INDICATION   0x10
+#define BCM4325_FLAG_STEREO_DETECTION            0x20
+#define BCM4325_FLAG_STEREO_ACTIVE               0x40
+
+#define BCM4325_RDS_FLAG_FIFO_WLINE              0x02
+#define BCM4325_RDS_FLAG_B_BLOCK_MATCH           0x08
+#define BCM4325_RDS_FLAG_SYNC_LOST               0x10
+#define BCM4325_RDS_FLAG_PI_MATCH                0x20
+
+#define BCM4325_SEARCH_NORMAL                    0x00
+#define BCM4325_SEARCH_PRESET                    0x01
+#define BCM4325_SEARCH_RSSI                      0x02
+
+#define BCM4325_FREQ_64MHZ                       64000
+
+#define BCM4325_SEARCH_RSSI_60DB                 94
+
+int hci_w(int reg, int val)
+{
+    int returnval = 0;
+
+    char s1[100] = "hcitool cmd 0x3f 0x15 ";
+    char stemp[10] = "";
+    char starget[100] = "";
+    char *pstarget = starget;
+
+    sprintf(stemp, "0x%x ", reg);
+    pstarget = strcat(s1, stemp);
+
+    sprintf(stemp, "0x%x ", 0);
+    pstarget = strcat(pstarget, stemp);
+
+    sprintf(stemp, "0x%x ", val);
+    pstarget = strcat(pstarget, stemp);
+    returnval = system(pstarget);
+    return returnval;
+}
+
+int hci_w16(int reg, int val1, int val2)
+{
+    int returnval = 0;
+
+    char s1[100] = "hcitool cmd 0x3f 0x15 ";
+    char stemp[10] = "";
+    char starget[100] = "";
+    char *pstarget = starget;
+
+    sprintf(stemp, "0x%x ", reg);
+    pstarget = strcat(s1, stemp);
+
+    sprintf(stemp, "0x%x ", 0);
+    pstarget = strcat(pstarget, stemp);
+
+    sprintf(stemp, "0x%x ", val1);
+    pstarget = strcat(pstarget, stemp);
+
+    sprintf(stemp, "0x%x ", val2);
+    pstarget = strcat(pstarget, stemp);
+
+    returnval = system(pstarget);
+    return returnval;
+}
+
+int hci_r(int reg)
+{
+    FILE* returnval;
+    int ulval;
+    char s1[100] = "hcitool cmd 0x3f 0x15 ";
+    char stemp[10] = "";
+    char starget[100] = "";
+    char reading[200] = "";
+    char *pstarget = starget;
+    char *returnv;
+
+    sprintf(stemp, "0x%x ", reg);
+    pstarget=strcat(s1, stemp);
+
+    sprintf(stemp, "0x%x ", 1);
+    pstarget=strcat(pstarget, stemp);
+
+    sprintf(stemp, "0x%x ", 1);
+    pstarget = strcat(pstarget, stemp);
+
+    returnval = popen(pstarget,"r");
+
+    if(!returnval){
+      LOGE("Could not open pipe for output.\n");
+      return 0;
+    }
+
+    // Grab data from process execution
+    // Skip the first 3 lines
+    fgets(reading, 200 , returnval);
+    fgets(reading, 200 , returnval);
+    fgets(reading, 200 , returnval);
+    fgets(reading, 200 , returnval);
+
+    if (pclose(returnval) != 0)
+        fprintf(stderr," Error: Failed to close command stream \n");
+
+    returnv = strndup(reading + (strlen(reading)-4), 2);
+    ulval= strtoul(returnv, NULL, 16);
+    LOGD("hci_r 0x%x \n", ulval);
+    return ulval;
+}
+
+using namespace android;
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_acquireFdNative
+(JNIEnv* env, jobject thiz, jstring path)
+{
+    int fd;
+    int i;
+    char value = 0;
+    int init_success = 0;
+    LOGD("Radio starting\n");
+
+    hci_w(BCM4325_I2C_FM_RDS_SYSTEM, BCM4325_FM_RDS_SYSTEM_FM);
+
+    /* Write the POWER register again.  If this fails, then we're screwed. */
+    if (hci_w(BCM4325_I2C_FM_RDS_SYSTEM,BCM4325_FM_RDS_SYSTEM_FM) < 0){
+        return FM_JNI_FAILURE;
+    }
+
+    /* Write the band setting, mno/stereo blend setting */
+    if(hci_w(BCM4325_I2C_FM_CTRL, BCM4325_FM_CTRL_MANUAL |BCM4325_FM_CTRL_STEREO) < 0){
+        return FM_JNI_FAILURE;
+    }
+#ifdef HAS_BCM20780
+    if (hci_w16(BCM4325_I2C_FM_AUDIO_CTRL0,
+        BCM4325_FM_AUDIO_CTRL0_RF_MUTE_ENABLE |
+        BCM4325_FM_AUDIO_CTRL0_DAC_OUT_LEFT_ON | BCM4325_FM_AUDIO_CTRL0_DAC_OUT_RIGHT_ON |
+        BCM4325_FM_AUDIO_CTRL0_ROUTE_DAC_ENABLE | BCM4325_FM_AUDIO_CTRL0_DEMPH_75US, 0) < 0) {
+        return FM_JNI_FAILURE;
+    }
+#else
+    if (hci_w(BCM4325_I2C_FM_AUDIO_CTRL0,
+        BCM4325_FM_AUDIO_CTRL0_DAC_OUT_LEFT_ON | BCM4325_FM_AUDIO_CTRL0_DAC_OUT_RIGHT_ON |
+        BCM4325_FM_AUDIO_CTRL0_ROUTE_DAC_ENABLE | BCM4325_FM_AUDIO_CTRL0_DEMPH_75US) < 0) {
+        return FM_JNI_FAILURE;
+    }
+#endif
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_closeFdNative
+    (JNIEnv * env, jobject thiz, jint fd)
+{
+    LOGD("Radio close\n");
+    
+    if (hci_w(BCM4325_I2C_FM_RDS_SYSTEM,BCM4325_FM_RDS_SYSTEM_OFF) < 0){
+        return FM_JNI_FAILURE;
+    }
+    return FM_JNI_SUCCESS;
+}
+
+/********************************************************************
+ * Current JNI
+ *******************************************************************/
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_getFreqNative
+    (JNIEnv * env, jobject thiz, jint fd)
+{
+    int retval;
+    int freq = 0;
+
+    retval = hci_r(BCM4325_I2C_FM_FREQ1);
+    freq = retval << 8;
+    retval = hci_r(BCM4325_I2C_FM_FREQ0);
+    freq += (retval + BCM4325_FREQ_64MHZ);
+
+    return freq;
+}
+
+/*native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_setFreqNative
+    (JNIEnv * env, jobject thiz, jint fd, jint freq)
+{
+    /* Adjust frequency to be an offset from 64MHz */
+    freq -= BCM4325_FREQ_64MHZ;
+
+    /* Write the FREQ0 register */
+    hci_w(BCM4325_I2C_FM_FREQ0, freq & 0xFF);
+
+    /* Write the FREQ1 register */
+    hci_w(BCM4325_I2C_FM_FREQ1, freq >> 8);
+
+    /* Write the TUNER_MODE register to PRESET to actually start tuning */
+    if ( hci_w(BCM4325_I2C_FM_SEARCH_TUNE_MODE, BCM4325_FM_PRE_SET_MODE) < 0){
+        LOGE("fail \n");
+    }
+
+    return 0;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_setControlNative
+    (JNIEnv * env, jobject thiz, jint fd, jint id, jint value)
+{
+    if (value == 1) {
+        LOGD("Radio ON \n");
+    }
+    if (value == 2) {
+        LOGD("Radio OFF\n");
+        if (hci_w(BCM4325_I2C_FM_RDS_SYSTEM,BCM4325_FM_RDS_SYSTEM_OFF) < 0){
+            return FM_JNI_FAILURE;
+        }
+    }
+    if (value == 3) {
+        LOGD("MUTE off \n");
+    }
+    if (value == 4) {
+        LOGD("MUTE on \n");
+    }
+
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_getControlNative
+    (JNIEnv * env, jobject thiz, jint fd, jint id)
+{
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_startSearchNative
+    (JNIEnv * env, jobject thiz, jint fd, jint dir)
+{
+    int oldFreq = android_hardware_fmradio_FmReceiverJNI_getFreqNative(NULL,NULL,NULL) ;
+
+    if ((oldFreq-100 <= 87500 && !dir) || (oldFreq+100 >= 108000 && dir)) {
+        LOGD("Can't seek %s. Already at end of band.",dir?"up":"down");
+        return FM_JNI_FAILURE;
+    }
+    else {
+        if ( hci_w(BCM4325_I2C_FM_SEARCH_METHOD, BCM4325_SEARCH_NORMAL) < 0){
+            LOGE("fail search method\n");
+            return FM_JNI_FAILURE;
+        }
+        if ( hci_w(BCM4325_I2C_FM_SEARCH_CTRL1, BCM4325_I2C_FM_AF_FREQ0) < 0){
+            LOGE("fail search set SEARCH_CTRL1 reg\n");
+            return FM_JNI_FAILURE;
+        }
+        if ( hci_w(BCM4325_I2C_FM_MAX_PRESET, 0) < 0 ){
+            LOGE("fail search set MAX_PRESET reg\n");
+            return FM_JNI_FAILURE;
+        }
+        if ( hci_w(BCM4325_I2C_FM_SEARCH_CTRL0, (dir ? BCM4325_FM_SEARCH_CTRL0_UP : BCM4325_FM_SEARCH_CTRL0_DOWN )  | BCM4325_FLAG_STEREO_ACTIVE  |  BCM4325_FLAG_STEREO_DETECTION ) < 0){
+            LOGE("fail search set SEARCH_CTRL0 reg\n");
+            return FM_JNI_FAILURE;
+        }
+        android_hardware_fmradio_FmReceiverJNI_setFreqNative(NULL,NULL,NULL,oldFreq+(dir?100:-100));
+        if ( hci_w(BCM4325_I2C_FM_SEARCH_TUNE_MODE, BCM4325_FM_AUTO_SEARCH_MODE) < 0){
+            LOGE("fail tuning\n");
+            return FM_JNI_FAILURE;
+        }
+    }
+    // before returning wait for tuning to finish and seek to start.
+    // I have seen this go into an infinite loop once, so limit it to 20 iterations (usually takes 1-4).
+    for (int i=0; i < 20 && android_hardware_fmradio_FmReceiverJNI_getFreqNative(NULL,NULL,NULL) == oldFreq+(dir?100:-100); i++){
+        LOGD("waiting for seek to start");
+        usleep(100);
+    }
+
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_cancelSearchNative
+    (JNIEnv * env, jobject thiz, jint fd)
+{
+    if ( hci_w(BCM4325_I2C_FM_SEARCH_TUNE_MODE, BCM4325_FM_TERMINATE_SEARCH_TUNE_MODE) < 0){
+        LOGE("fail cancel search\n");
+    }
+
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_getRSSINative
+    (JNIEnv * env, jobject thiz, jint fd)
+{
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_setBandNative
+    (JNIEnv * env, jobject thiz, jint fd, jint low, jint high)
+{
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_getLowerBandNative
+    (JNIEnv * env, jobject thiz, jint fd)
+{
+    return FM_JNI_SUCCESS;
+}
+
+static jint android_hardware_fmradio_FmReceiverJNI_setMonoStereoNative
+    (JNIEnv * env, jobject thiz, jint fd, jint val)
+{
+    return FM_JNI_SUCCESS;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_getBufferNative
+ (JNIEnv * env, jobject thiz, jint fd, jbooleanArray buff, jint index)
+{
+    return index;
+}
+
+/* native interface */
+static jint android_hardware_fmradio_FmReceiverJNI_getRawRdsNative
+ (JNIEnv * env, jobject thiz, jint fd, jbooleanArray buff, jint count)
+{
+    return FM_JNI_SUCCESS;
+}
+
+/*
+ * JNI registration.
+ */
+static JNINativeMethod gMethods[] = {
+        /* name, signature, funcPtr */
+        { "acquireFdNative", "(Ljava/lang/String;)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_acquireFdNative},
+        { "closeFdNative", "(I)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_closeFdNative},
+        { "getFreqNative", "(I)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_getFreqNative},
+        { "setFreqNative", "(II)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_setFreqNative},
+        { "getControlNative", "(II)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_getControlNative},
+        { "setControlNative", "(III)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_setControlNative},
+        { "startSearchNative", "(II)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_startSearchNative},
+        { "cancelSearchNative", "(I)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_cancelSearchNative},
+        { "getRSSINative", "(I)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_getRSSINative},
+        { "setBandNative", "(III)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_setBandNative},
+        { "getLowerBandNative", "(I)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_getLowerBandNative},
+        { "getBufferNative", "(I[BI)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_getBufferNative},
+        { "setMonoStereoNative", "(II)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_setMonoStereoNative},
+        { "getRawRdsNative", "(I[BI)I",
+            (void*)android_hardware_fmradio_FmReceiverJNI_getRawRdsNative},
+};
+
+int register_android_hardware_fm_fmradio(JNIEnv* env)
+{
+        return jniRegisterNativeMethods(env, "android/hardware/fmradio/FmReceiverJNI", gMethods, NELEM(gMethods));
+}
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 779028e..4b03d1a 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -468,4 +468,17 @@
              -SourcePortDestPort-SourcePortDestPort-OMADM PDU
          If false, not supported. -->
     <bool name="config_duplicate_port_omadm_wappush">false</bool>
+
+    <!-- ************************************************
+         *                                              *
+         *    GLOBAL DEFAULT VALUES FOR CM SETTINGS     *
+         *                                              *
+         ************************************************
+
+         if you wanna change a behavior for your device,
+         just copy that value to your overlay file and
+         set it as you like -->
+
+    <!-- Set this to true to get data working on some Motorola phones -->
+    <bool name="config_rilNeedsNullPath">false</bool>
 </resources>
diff --git a/data/sounds/OriginalAudio.mk b/data/sounds/OriginalAudio.mk
index 291f0b6..d41fe61 100644
--- a/data/sounds/OriginalAudio.mk
+++ b/data/sounds/OriginalAudio.mk
@@ -59,11 +59,16 @@ PRODUCT_COPY_FILES += \
 	$(LOCAL_PATH)/notifications/Heaven.ogg:system/media/audio/notifications/Heaven.ogg \
 	$(LOCAL_PATH)/notifications/TaDa.ogg:system/media/audio/notifications/TaDa.ogg \
 	$(LOCAL_PATH)/notifications/Tinkerbell.ogg:system/media/audio/notifications/Tinkerbell.ogg \
+	$(LOCAL_PATH)/effects/Dock.ogg:system/media/audio/ui/Dock.ogg \
 	$(LOCAL_PATH)/effects/Effect_Tick.ogg:system/media/audio/ui/Effect_Tick.ogg \
 	$(LOCAL_PATH)/effects/KeypressStandard.ogg:system/media/audio/ui/KeypressStandard.ogg \
 	$(LOCAL_PATH)/effects/KeypressSpacebar.ogg:system/media/audio/ui/KeypressSpacebar.ogg \
 	$(LOCAL_PATH)/effects/KeypressDelete.ogg:system/media/audio/ui/KeypressDelete.ogg \
 	$(LOCAL_PATH)/effects/KeypressReturn.ogg:system/media/audio/ui/KeypressReturn.ogg \
+	$(LOCAL_PATH)/effects/Lock.ogg:system/media/audio/ui/Lock.ogg \
+	$(LOCAL_PATH)/effects/LowBattery.ogg:system/media/audio/ui/LowBattery.ogg \
+	$(LOCAL_PATH)/effects/Undock.ogg:system/media/audio/ui/Undock.ogg \
+	$(LOCAL_PATH)/effects/Unlock.ogg:system/media/audio/ui/Unlock.ogg \
 	$(LOCAL_PATH)/effects/VideoRecord.ogg:system/media/audio/ui/VideoRecord.ogg \
 	$(LOCAL_PATH)/effects/camera_click.ogg:system/media/audio/ui/camera_click.ogg \
 	$(LOCAL_PATH)/newwavelabs/CrazyDream.ogg:system/media/audio/ringtones/CrazyDream.ogg \
diff --git a/include/media/AudioRecord.h b/include/media/AudioRecord.h
index 38e3d44..b04c83d 100644
--- a/include/media/AudioRecord.h
+++ b/include/media/AudioRecord.h
@@ -142,9 +142,9 @@ public:
      */
 
      enum record_flags {
-         RECORD_AGC_ENABLE = AudioSystem::AGC_ENABLE,
-         RECORD_NS_ENABLE  = AudioSystem::NS_ENABLE,
-         RECORD_IIR_ENABLE = AudioSystem::TX_IIR_ENABLE
+         RECORD_AGC_ENABLE = 0x0001, //AudioSystem::AGC_ENABLE,
+         RECORD_NS_ENABLE  = 0x0002, //AudioSystem::NS_ENABLE,
+         RECORD_IIR_ENABLE = 0x0004, //AudioSystem::TX_IIR_ENABLE
      };
 
                         AudioRecord(int inputSource,
diff --git a/include/media/AudioSystem.h b/include/media/AudioSystem.h
index e881747..c4630d1 100644
--- a/include/media/AudioSystem.h
+++ b/include/media/AudioSystem.h
@@ -45,6 +45,9 @@ public:
         ENFORCED_AUDIBLE = 7, // Sounds that cannot be muted by user and must be routed to speaker
         DTMF             = 8,
         TTS              = 9,
+#ifdef HAVE_FM_RADIO
+        FM              = 10,
+#endif
         NUM_STREAM_TYPES
     };
 
@@ -142,12 +145,19 @@ public:
         CHANNEL_IN_Z_AXIS = 0x2000,
         CHANNEL_IN_VOICE_UPLINK = 0x4000,
         CHANNEL_IN_VOICE_DNLINK = 0x8000,
+#ifdef OMAP_ENHANCEMENT
+        CHANNEL_IN_VOICE_UPLINK_DNLINK = 0x10000,
+#endif
         CHANNEL_IN_MONO = CHANNEL_IN_FRONT,
         CHANNEL_IN_STEREO = (CHANNEL_IN_LEFT | CHANNEL_IN_RIGHT),
         CHANNEL_IN_ALL = (CHANNEL_IN_LEFT | CHANNEL_IN_RIGHT | CHANNEL_IN_FRONT | CHANNEL_IN_BACK|
                 CHANNEL_IN_LEFT_PROCESSED | CHANNEL_IN_RIGHT_PROCESSED | CHANNEL_IN_FRONT_PROCESSED | CHANNEL_IN_BACK_PROCESSED|
                 CHANNEL_IN_PRESSURE | CHANNEL_IN_X_AXIS | CHANNEL_IN_Y_AXIS | CHANNEL_IN_Z_AXIS |
-                CHANNEL_IN_VOICE_UPLINK | CHANNEL_IN_VOICE_DNLINK)
+#ifdef OMAP_ENHANCEMENT
+                CHANNEL_IN_VOICE_UPLINK | CHANNEL_IN_VOICE_DNLINK | CHANNEL_IN_VOICE_UPLINK_DNLINK)
+#else
+                CHANNEL_IN_VOICE_UPLINK | CHANNEL_IN_VOICE_DNLINK )
+#endif
     };
 
     enum audio_mode {
@@ -231,6 +241,9 @@ public:
         size_t* buffSize);
 
     static status_t setVoiceVolume(float volume);
+#ifdef HAVE_FM_RADIO
+    static status_t setFmVolume(float volume);
+#endif
 
     // return the number of audio frames written by AudioFlinger to audio HAL and
     // audio dsp to DAC since the output on which the specificed stream is playing
@@ -263,11 +276,29 @@ public:
         DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES = 0x100,
         DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER = 0x200,
         DEVICE_OUT_AUX_DIGITAL = 0x400,
+#ifdef HAVE_FM_RADIO
+        DEVICE_OUT_FM = 0x800,
+        DEVICE_OUT_FM_SPEAKER = 0x1000,
+        DEVICE_OUT_FM_ALL = (DEVICE_OUT_FM | DEVICE_OUT_FM_SPEAKER),
+#elif defined(OMAP_ENHANCEMENT)
+        DEVICE_OUT_FM_TRANSMIT = 0x800,
+        DEVICE_OUT_LOW_POWER = 0x1000,
+#endif
+        DEVICE_OUT_HDMI = 0x2000,
         DEVICE_OUT_DEFAULT = 0x8000,
         DEVICE_OUT_ALL = (DEVICE_OUT_EARPIECE | DEVICE_OUT_SPEAKER | DEVICE_OUT_WIRED_HEADSET |
+#ifdef HAVE_FM_RADIO
+                DEVICE_OUT_WIRED_HEADPHONE | DEVICE_OUT_FM | DEVICE_OUT_FM_SPEAKER | DEVICE_OUT_BLUETOOTH_SCO | DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
+#else
                 DEVICE_OUT_WIRED_HEADPHONE | DEVICE_OUT_BLUETOOTH_SCO | DEVICE_OUT_BLUETOOTH_SCO_HEADSET |
+#endif
                 DEVICE_OUT_BLUETOOTH_SCO_CARKIT | DEVICE_OUT_BLUETOOTH_A2DP | DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
-                DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER | DEVICE_OUT_AUX_DIGITAL | DEVICE_OUT_DEFAULT),
+#if defined(OMAP_ENHANCEMENT) && !defined(HAVE_FM_RADIO)
+                DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER | DEVICE_OUT_AUX_DIGITAL | DEVICE_OUT_LOW_POWER |
+                DEVICE_OUT_FM_TRANSMIT | DEVICE_OUT_DEFAULT),
+#else
+                DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER | DEVICE_OUT_AUX_DIGITAL | DEVICE_OUT_HDMI | DEVICE_OUT_DEFAULT),
+#endif
         DEVICE_OUT_ALL_A2DP = (DEVICE_OUT_BLUETOOTH_A2DP | DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES |
                 DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER),
 
@@ -280,11 +311,25 @@ public:
         DEVICE_IN_AUX_DIGITAL = 0x200000,
         DEVICE_IN_VOICE_CALL = 0x400000,
         DEVICE_IN_BACK_MIC = 0x800000,
+#ifdef HAVE_FM_RADIO
+        DEVICE_IN_FM_RX = 0x1000000,
+        DEVICE_IN_FM_RX_A2DP = 0x2000000,
+#endif
+#ifdef OMAP_ENHANCEMENT
+        DEVICE_IN_FM_ANALOG = 0x1000000,
+#endif
         DEVICE_IN_DEFAULT = 0x80000000,
 
         DEVICE_IN_ALL = (DEVICE_IN_COMMUNICATION | DEVICE_IN_AMBIENT | DEVICE_IN_BUILTIN_MIC |
                 DEVICE_IN_BLUETOOTH_SCO_HEADSET | DEVICE_IN_WIRED_HEADSET | DEVICE_IN_AUX_DIGITAL |
+#ifdef HAVE_FM_RADIO
+                DEVICE_IN_VOICE_CALL | DEVICE_IN_BACK_MIC | DEVICE_IN_FM_RX | DEVICE_IN_FM_RX_A2DP | DEVICE_IN_DEFAULT)
+#elif OMAP_ENHANCEMENT
+                DEVICE_IN_VOICE_CALL | DEVICE_IN_BACK_MIC  | DEVICE_IN_FM_ANALOG | DEVICE_IN_DEFAULT)
+#else
                 DEVICE_IN_VOICE_CALL | DEVICE_IN_BACK_MIC | DEVICE_IN_DEFAULT)
+#endif
+
     };
 
     // device connection states used for setDeviceConnectionState()
@@ -402,12 +447,18 @@ public:
     static bool isOutputDevice(audio_devices device);
     static bool isInputDevice(audio_devices device);
     static bool isA2dpDevice(audio_devices device);
+#ifdef HAVE_FM_RADIO
+    static bool isFmDevice(audio_devices device);
+#endif
     static bool isBluetoothScoDevice(audio_devices device);
     static bool isLowVisibility(stream_type stream);
     static bool isOutputChannel(uint32_t channel);
     static bool isInputChannel(uint32_t channel);
     static bool isValidFormat(uint32_t format);
     static bool isLinearPCM(uint32_t format);
+#ifdef USES_SAMSUNG_SEPARATED_STREAM
+    static bool isSeperatedStream(stream_type stream);
+#endif
 
 private:
 
@@ -482,6 +533,10 @@ public:
     static const char *keyFormat;
     static const char *keyChannels;
     static const char *keyFrameCount;
+#ifdef HAVE_FM_RADIO
+    static const char *keyFmOn;
+    static const char *keyFmOff;
+#endif
     static const char *keyInputSource;
 
     String8 toString();
diff --git a/include/media/IAudioFlinger.h b/include/media/IAudioFlinger.h
index 70e505e..d63343f 100644
--- a/include/media/IAudioFlinger.h
+++ b/include/media/IAudioFlinger.h
@@ -91,7 +91,12 @@ public:
      */
     virtual     status_t    setStreamVolume(int stream, float value, int output) = 0;
     virtual     status_t    setStreamMute(int stream, bool muted) = 0;
-
+#ifdef OMAP_ENHANCEMENT
+    /* This will tell playback thread that FM Rx is active
+     * and device will not go to standby
+     */
+    virtual     status_t    setFMRxActive(bool state)=0;
+#endif
     virtual     float       streamVolume(int stream, int output) const = 0;
     virtual     bool        streamMute(int stream) const = 0;
 
@@ -163,6 +168,10 @@ public:
                                     int *enabled) = 0;
 
     virtual status_t moveEffects(int session, int srcOutput, int dstOutput) = 0;
+
+#ifdef HAVE_FM_RADIO
+    virtual status_t setFmVolume(float volume) = 0;
+#endif
 };
 
 
diff --git a/include/media/IMediaPlayer.h b/include/media/IMediaPlayer.h
index af9a7ed..7c81dc8 100644
--- a/include/media/IMediaPlayer.h
+++ b/include/media/IMediaPlayer.h
@@ -51,6 +51,9 @@ public:
     virtual status_t        setAuxEffectSendLevel(float level) = 0;
     virtual status_t        attachAuxEffect(int effectId) = 0;
 
+#ifdef OMAP_ENHANCEMENT
+    virtual status_t        requestVideoCloneMode(bool enable) = 0;
+#endif
     // Invoke a generic method on the player by using opaque parcels
     // for the request and reply.
     // @param request Parcel that must start with the media player
diff --git a/include/media/IMediaPlayerService.h b/include/media/IMediaPlayerService.h
index 9416ca1..d5bd341 100644
--- a/include/media/IMediaPlayerService.h
+++ b/include/media/IMediaPlayerService.h
@@ -32,6 +32,9 @@ namespace android {
 
 class IMediaRecorder;
 class IOMX;
+#ifdef OMAP_ENHANCEMENT
+class IOverlayRenderer;
+#endif
 
 class IMediaPlayerService: public IInterface
 {
@@ -48,6 +51,9 @@ public:
     virtual sp<IMemory>         decode(const char* url, uint32_t *pSampleRate, int* pNumChannels, int* pFormat) = 0;
     virtual sp<IMemory>         decode(int fd, int64_t offset, int64_t length, uint32_t *pSampleRate, int* pNumChannels, int* pFormat) = 0;
     virtual sp<IOMX>            getOMX() = 0;
+#ifdef OMAP_ENHANCEMENT
+    virtual sp<IOverlayRenderer>  getOverlayRenderer()=0;
+#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/media/IMediaRecorder.h b/include/media/IMediaRecorder.h
index 54adca8..609b574 100644
--- a/include/media/IMediaRecorder.h
+++ b/include/media/IMediaRecorder.h
@@ -52,6 +52,7 @@ public:
     virtual status_t        init() = 0;
     virtual status_t        close() = 0;
     virtual	status_t		release() = 0;
+    virtual     status_t                setCameraParameters(const String8& params) = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/media/IOMX.h b/include/media/IOMX.h
index f794766..604f7bb 100644
--- a/include/media/IOMX.h
+++ b/include/media/IOMX.h
@@ -19,6 +19,7 @@
 #define ANDROID_IOMX_H_
 
 #include <binder/IInterface.h>
+#include <binder/MemoryHeapBase.h>
 #include <utils/List.h>
 #include <utils/String8.h>
 
@@ -136,6 +137,29 @@ public:
             size_t encodedWidth, size_t encodedHeight,
             size_t displayWidth, size_t displayHeight,
             int32_t rotationDegrees);
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemory> &params,
+            buffer_id *buffer, size_t size) = 0;
+#endif
+
+#ifdef OMAP_ENHANCEMENT
+    sp<IOMXRenderer> createRenderer(
+            const sp<Surface> &surface,
+            const char *componentName,
+            OMX_COLOR_FORMATTYPE colorFormat,
+            size_t encodedWidth, size_t encodedHeight,
+            size_t displayWidth, size_t displayHeight, int32_t rotation, int isS3D, int numOfOpBuffers = -1);
+
+        virtual sp<IOMXRenderer> createRenderer(
+            const sp<ISurface> &surface,
+            const char *componentName,
+            OMX_COLOR_FORMATTYPE colorFormat,
+            size_t encodedWidth, size_t encodedHeight,
+            size_t displayWidth, size_t displayHeight, int32_t rotation, int isS3D, int numOfOpBuffers = -1) = 0;
+
+#endif
 };
 
 struct omx_message {
@@ -143,6 +167,9 @@ struct omx_message {
         EVENT,
         EMPTY_BUFFER_DONE,
         FILL_BUFFER_DONE,
+#ifndef OMAP_ENHANCEMENT
+        REGISTER_BUFFERS
+#endif
 
     } type;
 
@@ -170,6 +197,7 @@ struct omx_message {
             OMX_TICKS timestamp;
             OMX_PTR platform_private;
             OMX_PTR data_ptr;
+            OMX_U32 pmem_offset;
         } extended_buffer_data;
 
     } u;
@@ -180,13 +208,27 @@ public:
     DECLARE_META_INTERFACE(OMXObserver);
 
     virtual void onMessage(const omx_message &msg) = 0;
+#ifndef OMAP_ENHANCEMENT
+    virtual void registerBuffers(const sp<IMemoryHeap> &mem) = 0;
+#endif
 };
 
+#ifdef OMAP_ENHANCEMENT
+typedef void (*release_rendered_buffer_callback)(const sp<IMemory>& mem, void* cookie);
+#endif
+
 class IOMXRenderer : public IInterface {
 public:
     DECLARE_META_INTERFACE(OMXRenderer);
 
     virtual void render(IOMX::buffer_id buffer) = 0;
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers() = 0;
+    virtual bool setCallback(release_rendered_buffer_callback cb, void *cookie) = 0;
+    virtual void set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling) =0;
+    virtual void resizeRenderer(void* resize_params) = 0;
+    virtual void requestRendererClone(bool enable) = 0;
+#endif
 };
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index 0521709..72cf087 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -44,6 +44,8 @@ enum player_type {
     // The shared library with the test player is passed passed as an
     // argument to the 'test:' url in the setDataSource call.
     TEST_PLAYER = 5,
+    FLAC_PLAYER = 6,
+    BOARD_HW_PLAYER = 7,
 };
 
 
@@ -120,7 +122,9 @@ public:
     virtual player_type playerType() = 0;
     virtual status_t    suspend() { return INVALID_OPERATION; }
     virtual status_t    resume() { return INVALID_OPERATION; }
-
+#ifdef OMAP_ENHANCEMENT
+    virtual status_t    requestVideoCloneMode(bool enable) { return INVALID_OPERATION; }
+#endif
     virtual void        setNotifyCallback(void* cookie, notify_callback_f notifyFunc) {
                             mCookie = cookie; mNotify = notifyFunc; }
     // Invoke a generic method on the player by using opaque parcels
diff --git a/include/media/MediaProfiles.h b/include/media/MediaProfiles.h
index c3cd361..1679b62 100644
--- a/include/media/MediaProfiles.h
+++ b/include/media/MediaProfiles.h
@@ -25,11 +25,17 @@ namespace android {
 
 enum camcorder_quality {
     CAMCORDER_QUALITY_LOW  = 0,
-    CAMCORDER_QUALITY_HIGH = 1
+    CAMCORDER_QUALITY_HIGH = 1,
+    CAMCORDER_QUALITY_HD = 2,
+    CAMCORDER_QUALITY_WIDE = 3
 };
 
 enum video_decoder {
     VIDEO_DECODER_WMV,
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    VIDEO_DECODER_VP6,
+    VIDEO_DECODER_VP7,
+#endif
 };
 
 enum audio_decoder {
diff --git a/include/media/MediaRecorderBase.h b/include/media/MediaRecorderBase.h
index 5e9e368..5f0c79a 100644
--- a/include/media/MediaRecorderBase.h
+++ b/include/media/MediaRecorderBase.h
@@ -49,6 +49,7 @@ struct MediaRecorderBase {
     virtual status_t reset() = 0;
     virtual status_t getMaxAmplitude(int *max) = 0;
     virtual status_t dump(int fd, const Vector<String16>& args) const = 0;
+    virtual status_t setCameraParameters(const String8& params) = 0;
 
 private:
     MediaRecorderBase(const MediaRecorderBase &);
diff --git a/include/media/OverlayRenderer.h b/include/media/OverlayRenderer.h
new file mode 100644
index 0000000..0ae1371
--- /dev/null
+++ b/include/media/OverlayRenderer.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) Texas Instruments - http://www.ti.com/
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef OVERLAY_RENDERER_H_
+#define OVERLAY_RENDERER_H_
+
+#include <utils/Log.h>
+#include <OMX_Component.h>
+#include <overlay_common.h>
+#include <media/stagefright/MediaDebug.h>
+
+#include <binder/Parcel.h>
+#include <binder/IMemory.h>
+#include <binder/IInterface.h>
+#include <binder/MemoryBase.h>
+#include <binder/MemoryHeapBase.h>
+
+#include <ui/Overlay.h>
+#include <surfaceflinger/Surface.h>
+#include <surfaceflinger/ISurface.h>
+#include <surfaceflinger/ISurfaceComposer.h>
+#include <surfaceflinger/SurfaceComposerClient.h>
+
+namespace android {
+
+class IOverlayRenderer : public IInterface {
+public:
+    DECLARE_META_INTERFACE(OverlayRenderer);
+    virtual int32_t createOverlayRenderer(uint32_t bufferCount,
+                                int32_t displayWidth,
+                                int32_t displayHeight,
+                                uint32_t colorFormat,
+                                int32_t decodedWidth,
+                                int32_t decodedHeight,
+                                int infoType,
+                                void* info)=0;
+
+    virtual void releaseMe()=0;
+    virtual uint32_t getBufferCount()=0;
+    virtual sp<IMemory> getBuffer(uint32_t index) = 0;
+    virtual int32_t dequeueBuffer(uint32_t *index)=0;
+    virtual int32_t queueBuffer(uint32_t index)=0;
+    virtual int32_t setPosition(int32_t x, int32_t y)=0;
+    virtual int32_t setSize(uint32_t w, uint32_t h)=0;
+    virtual int32_t setOrientation(int32_t orientation, uint32_t flags)=0;
+    virtual int32_t setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h)=0;
+};
+
+
+class BnOverlayRenderer : public BnInterface<IOverlayRenderer> {
+public:
+    virtual status_t onTransact(uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags = 0);
+};
+
+
+class OverlayRenderer : public BnOverlayRenderer{
+
+public:
+
+    OverlayRenderer();
+    ~OverlayRenderer();
+    int32_t createOverlayRenderer(uint32_t bufferCount,
+                                int32_t displayWidth,
+                                int32_t displayHeight,
+                                uint32_t colorFormat,
+                                int32_t decodedWidth,
+                                int32_t decodedHeight,
+                                int infoType,
+                                void* info);
+    void releaseMe();
+    uint32_t getBufferCount() { return mBufferCount; }
+    sp<IMemory> getBuffer(uint32_t index);
+    int32_t dequeueBuffer(uint32_t *index);
+    int32_t queueBuffer(uint32_t index);
+    int32_t setPosition(int32_t x, int32_t y) ;
+    int32_t setSize(uint32_t w, uint32_t h) ;
+    int32_t setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h);
+    int32_t setOrientation(int32_t orientation, uint32_t flags);
+
+private:
+
+    int32_t createSurface();
+    int32_t createBuffers();
+
+    int32_t mInitCheck;
+    int32_t mDisplayWidth, mDisplayHeight;
+    int32_t mDecodedWidth, mDecodedHeight;
+    uint32_t mColorFormat;
+    uint32_t mBufferCount;
+    unsigned int mInfoType;
+
+    /* Surface details */
+    sp<Overlay> mOverlay;
+    sp<SurfaceComposerClient> mSurfaceClient;
+    sp<SurfaceControl> mSurfaceControl;
+    sp<ISurface> mISurface;
+
+    sp<MemoryHeapBase> mVideoHeaps[NUM_OVERLAY_BUFFERS_MAX];
+    Vector< sp<IMemory> > mOverlayAddresses;
+
+    /* copy of previously set window values */
+    int32_t win_x;
+    int32_t win_y;
+
+};
+
+}
+
+#endif
+
diff --git a/include/media/PVMediaRecorder.h b/include/media/PVMediaRecorder.h
index c091c39..c1df7a9 100644
--- a/include/media/PVMediaRecorder.h
+++ b/include/media/PVMediaRecorder.h
@@ -53,6 +53,7 @@ public:
     virtual status_t reset();
     virtual status_t getMaxAmplitude(int *max);
     virtual status_t dump(int fd, const Vector<String16>& args) const;
+    virtual status_t setCameraParameters(const String8& params);
 
 private:
     status_t doStop();
diff --git a/include/media/mediaplayer.h b/include/media/mediaplayer.h
index 207191d..62da46f 100644
--- a/include/media/mediaplayer.h
+++ b/include/media/mediaplayer.h
@@ -175,6 +175,9 @@ public:
             int             getAudioSessionId();
             status_t        setAuxEffectSendLevel(float level);
             status_t        attachAuxEffect(int effectId);
+#ifdef OMAP_ENHANCEMENT
+            status_t        requestVideoCloneMode(bool enable);
+#endif
 private:
             void            clear_l();
             status_t        seekTo_l(int msec);
diff --git a/include/media/mediarecorder.h b/include/media/mediarecorder.h
index 9a76393..6317e6a 100644
--- a/include/media/mediarecorder.h
+++ b/include/media/mediarecorder.h
@@ -45,8 +45,18 @@ enum audio_source {
     AUDIO_SOURCE_CAMCORDER = 5,
     AUDIO_SOURCE_VOICE_RECOGNITION = 6,
     AUDIO_SOURCE_VOICE_COMMUNICATION = 7,
+#ifdef OMAP_ENHANCEMENT
+    AUDIO_SOURCE_FM_ANALOG = 8,
+    AUDIO_SOURCE_MAX = AUDIO_SOURCE_FM_ANALOG,
+#else
+#ifdef HAVE_FM_RADIO
+    AUDIO_SOURCE_FM_RX = 8,
+    AUDIO_SOURCE_FM_RX_A2DP = 9,
+    AUDIO_SOURCE_MAX = AUDIO_SOURCE_FM_RX_A2DP,
+#else
     AUDIO_SOURCE_MAX = AUDIO_SOURCE_VOICE_COMMUNICATION,
-
+#endif
+#endif
     AUDIO_SOURCE_LIST_END  // must be last - used to validate audio source type
 };
 
@@ -187,6 +197,7 @@ public:
     status_t    close();
     status_t    release();
     void        notify(int msg, int ext1, int ext2);
+    status_t    setCameraParameters(const String8& params);
 
 private:
     void                    doCleanUp();
diff --git a/include/media/stagefright/AudioPlayer.h b/include/media/stagefright/AudioPlayer.h
index 37af032..1425d9e 100644
--- a/include/media/stagefright/AudioPlayer.h
+++ b/include/media/stagefright/AudioPlayer.h
@@ -51,7 +51,9 @@ public:
 
     void pause(bool playPendingSamples = false);
     void resume();
-
+#ifdef OMAP_ENHANCEMENT
+    void flush();
+#endif
     // Returns the timestamp of the last buffer played (in us).
     int64_t getMediaTimeUs();
 
@@ -109,6 +111,10 @@ private:
 
     AudioPlayer(const AudioPlayer &);
     AudioPlayer &operator=(const AudioPlayer &);
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    int64_t mRealTimeInterpolation;
+    int64_t GetSystemTimeuSec();
+#endif
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/AudioSource.h b/include/media/stagefright/AudioSource.h
index d484d60..a7a8663 100644
--- a/include/media/stagefright/AudioSource.h
+++ b/include/media/stagefright/AudioSource.h
@@ -50,7 +50,7 @@ protected:
 
 private:
     enum {
-        kMaxBufferSize = 2048,
+        kMaxBufferSize = 4096,
 
         // After the initial mute, we raise the volume linearly
         // over kAutoRampDurationUs.
diff --git a/include/media/stagefright/CameraSource.h b/include/media/stagefright/CameraSource.h
index 3192d03..f1ce0ee 100644
--- a/include/media/stagefright/CameraSource.h
+++ b/include/media/stagefright/CameraSource.h
@@ -47,6 +47,10 @@ public:
 
     virtual void signalBufferReturned(MediaBuffer* buffer);
 
+#ifdef USE_GETBUFFERINFO
+    virtual status_t getBufferInfo(sp<IMemory>& Frame, size_t *alignedSize);
+#endif
+
 private:
     friend class CameraSourceListener;
 
@@ -59,6 +63,9 @@ private:
     List<sp<IMemory> > mFramesReceived;
     List<sp<IMemory> > mFramesBeingEncoded;
     List<int64_t> mFrameTimes;
+#if defined(OMAP_ENHANCEMENT) && (TARGET_OMAP4)
+    List<uint32_t> mFrameOffset;
+#endif
 
     int64_t mStartTimeUs;
     int64_t mFirstFrameTimeUs;
@@ -73,8 +80,14 @@ private:
 
     CameraSource(const sp<Camera> &camera);
 
+#ifdef OMAP_ENHANCEMENT
+    void dataCallbackTimestamp(
+            int64_t timestampUs, int32_t msgType, const sp<IMemory> &data,
+            uint32_t offset=0, uint32_t stride=0);
+#else
     void dataCallbackTimestamp(
             int64_t timestampUs, int32_t msgType, const sp<IMemory> &data);
+#endif
 
     void releaseQueuedFrames();
     void releaseOneRecordingFrame(const sp<IMemory>& frame);
diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index bc3f464..bff4876 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2010, Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,10 +33,18 @@ struct ColorConverter {
 
     bool isValid() const;
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    void convert(
+            size_t width, size_t height,
+            const void *srcBits, size_t srcSkip,
+            void *dstBits, size_t dstSkip,
+            size_t displaywidth=0, size_t displayheight=0,size_t offset=0,bool interlaced=false);
+#else
     void convert(
             size_t width, size_t height,
             const void *srcBits, size_t srcSkip,
             void *dstBits, size_t dstSkip);
+#endif
 
 private:
     OMX_COLOR_FORMATTYPE mSrcFormat, mDstFormat;
@@ -63,6 +72,33 @@ private:
             const void *srcBits, size_t srcSkip,
             void *dstBits, size_t dstSkip);
 
+    void convertNV12Tile(
+        size_t width, size_t height,
+        const void *srcBits, size_t srcSkip,
+        void *dstBits, size_t dstSkip);
+
+    size_t nv12TileGetTiledMemBlockNum(
+        size_t bx, size_t by,
+        size_t nbx, size_t nby);
+
+    void nv12TileComputeRGB(
+        uint8_t **dstPtr,const uint8_t *blockUV,
+        const uint8_t *blockY, size_t blockWidth,
+        size_t dstSkip);
+
+    void nv12TileTraverseBlock(
+        uint8_t **dstPtr, const uint8_t *blockY,
+        const uint8_t *blockUV, size_t blockWidth,
+        size_t blockHeight, size_t dstSkip);
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    void convertYUV420PackedSemiPlanar(
+            size_t width, size_t height,
+            size_t displaywidth, size_t displayheight, size_t offset,
+            const void *srcBits, size_t srcSkip,
+            void *dstBits, size_t dstSkip, bool interlaced);
+#endif
+
     ColorConverter(const ColorConverter &);
     ColorConverter &operator=(const ColorConverter &);
 };
diff --git a/include/media/stagefright/HardwareAPI.h b/include/media/stagefright/HardwareAPI.h
index 63f11d1..78b4767 100644
--- a/include/media/stagefright/HardwareAPI.h
+++ b/include/media/stagefright/HardwareAPI.h
@@ -40,6 +40,24 @@ extern android::VideoRenderer *createRendererWithRotation(
         size_t decodedWidth, size_t decodedHeight,
         int32_t rotationDegrees);
 
+#ifdef OMAP_ENHANCEMENT
+extern android::VideoRenderer *createRenderer(
+        const android::sp<android::ISurface> &surface,
+        const char *componentName,
+        OMX_COLOR_FORMATTYPE colorFormat,
+        size_t displayWidth, size_t displayHeight,
+        size_t decodedWidth, size_t decodedHeight,
+        int isS3D, int numOfOpBuffers);
+
+extern android::VideoRenderer *createRendererWithRotation(
+        const android::sp<android::ISurface> &surface,
+        const char *componentName,
+        OMX_COLOR_FORMATTYPE colorFormat,
+        size_t displayWidth, size_t displayHeight,
+        size_t decodedWidth, size_t decodedHeight,
+        int32_t rotationDegrees,
+        int isS3D, int numOfOpBuffers);
+#endif
 extern android::OMXPluginBase *createOMXPlugin();
 
 #endif  // HARDWARE_API_H_
diff --git a/include/media/stagefright/MediaBuffer.h b/include/media/stagefright/MediaBuffer.h
index 339e6fb..4359c36 100644
--- a/include/media/stagefright/MediaBuffer.h
+++ b/include/media/stagefright/MediaBuffer.h
@@ -55,6 +55,7 @@ public:
     // Increments the reference count.
     void add_ref();
 
+    void setData(void *);
     void *data() const;
     size_t size() const;
 
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 92ce068..e6da1e2 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -27,6 +27,9 @@ extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4;
 extern const char *MEDIA_MIMETYPE_VIDEO_H263;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
+extern const char *MEDIA_MIMETYPE_VIDEO_VP6;
+extern const char *MEDIA_MIMETYPE_VIDEO_VP7;
 
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
@@ -37,12 +40,17 @@ extern const char *MEDIA_MIMETYPE_AUDIO_VORBIS;
 extern const char *MEDIA_MIMETYPE_AUDIO_G711_ALAW;
 extern const char *MEDIA_MIMETYPE_AUDIO_G711_MLAW;
 extern const char *MEDIA_MIMETYPE_AUDIO_RAW;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMAPRO;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMALSL;
 
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG4;
 extern const char *MEDIA_MIMETYPE_CONTAINER_WAV;
 extern const char *MEDIA_MIMETYPE_CONTAINER_OGG;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MATROSKA;
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2TS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_ASF;
+extern const char *MEDIA_MIMETYPE_CONTAINER_AVI;
 
 }  // namespace android
 
diff --git a/include/media/stagefright/MediaErrors.h b/include/media/stagefright/MediaErrors.h
index e44122d..c72b7a8 100644
--- a/include/media/stagefright/MediaErrors.h
+++ b/include/media/stagefright/MediaErrors.h
@@ -40,6 +40,9 @@ enum {
     // Not technically an error.
     INFO_FORMAT_CHANGED    = MEDIA_ERROR_BASE - 12,
     INFO_DISCONTINUITY     = MEDIA_ERROR_BASE - 13,
+#ifdef OMAP_ENHANCEMENT
+    ERROR_OUT_OF_MEM       = MEDIA_ERROR_BASE - 14
+#endif
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/MediaExtractor.h b/include/media/stagefright/MediaExtractor.h
index 16b0a4c..7c19c5b 100644
--- a/include/media/stagefright/MediaExtractor.h
+++ b/include/media/stagefright/MediaExtractor.h
@@ -17,9 +17,10 @@
 #ifndef MEDIA_EXTRACTOR_H_
 
 #define MEDIA_EXTRACTOR_H_
-
 #include <utils/RefBase.h>
 
+#include <utils/String8.h>
+
 namespace android {
 
 class DataSource;
@@ -33,10 +34,16 @@ public:
 
     virtual size_t countTracks() = 0;
     virtual sp<MediaSource> getTrack(size_t index) = 0;
-
+#ifdef OMAP_ENHANCEMENT
     enum GetTrackMetaDataFlags {
-        kIncludeExtensiveMetaData = 1
+        kIncludeExtensiveMetaData = 1,
+        kSelectFirstSample = 2
     };
+#else
+    enum GetTrackMetaDataFlags {
+        kIncludeExtensiveMetaData = 1
+     };
+#endif
     virtual sp<MetaData> getTrackMetaData(
             size_t index, uint32_t flags = 0) = 0;
 
@@ -64,6 +71,9 @@ private:
     MediaExtractor &operator=(const MediaExtractor &);
 };
 
+bool SniffMPEG4(
+        const sp<DataSource> &source, String8 *mimeType, float *confidence);
+
 }  // namespace android
 
 #endif  // MEDIA_EXTRACTOR_H_
diff --git a/include/media/stagefright/MediaSource.h b/include/media/stagefright/MediaSource.h
index dafc621..e75f71e 100644
--- a/include/media/stagefright/MediaSource.h
+++ b/include/media/stagefright/MediaSource.h
@@ -22,12 +22,23 @@
 
 #include <media/stagefright/MediaErrors.h>
 #include <utils/RefBase.h>
+#ifdef USE_GETBUFFERINFO
+#include <binder/IMemory.h>
+#endif
+#ifdef OMAP_ENHANCEMENT
+#include <utils/Vector.h>
+#include "binder/IMemory.h"
+#endif
 
 namespace android {
 
 class MediaBuffer;
 class MetaData;
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+struct S3D_params;
+#endif
+
 struct MediaSource : public RefBase {
     MediaSource();
 
@@ -112,12 +123,28 @@ struct MediaSource : public RefBase {
         return ERROR_UNSUPPORTED;
     }
 
+#ifdef USE_GETBUFFERINFO
+    virtual status_t getBufferInfo(sp<IMemory>& Frame, size_t *alignedSize);
+#endif
+
 protected:
     virtual ~MediaSource();
 
 private:
     MediaSource(const MediaSource &);
     MediaSource &operator=(const MediaSource &);
+
+public:
+#ifdef OMAP_ENHANCEMENT
+    // Method to share externally allocated buffers with the Codec.
+    virtual void setBuffers(Vector< sp<IMemory> > mBufferAddresse, bool portReconfig = false) {}
+    // Method used to reset read position without consuming the buffer
+    virtual int64_t setSeekTo(const ReadOptions *options) { return 0; }
+    virtual int getNumofOutputBuffers() {return -1; }
+#if defined(TARGET_OMAP4)
+    virtual void parseSEIMessages(S3D_params &mS3Dparams) {}
+#endif
+#endif
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
index bffb9e0..aa95cf1 100644
--- a/include/media/stagefright/MetaData.h
+++ b/include/media/stagefright/MetaData.h
@@ -41,6 +41,10 @@ enum {
     kKeyBitRate           = 'brte',  // int32_t (bps)
     kKeyESDS              = 'esds',  // raw data
     kKeyAVCC              = 'avcc',  // raw data
+#ifdef OMAP_ENHANCEMENT
+    kKeyStreamSpecificData= 'scsd',  // raw data
+    kKeyHdr               = 'hdrd',  // raw data
+#endif
     kKeyVorbisInfo        = 'vinf',  // raw data
     kKeyVorbisBooks       = 'vboo',  // raw data
     kKeyWantsNALFragments = 'NALf',
@@ -79,6 +83,11 @@ enum {
     // video profile and level
     kKeyVideoProfile      = 'vprf',  // int32_t
     kKeyVideoLevel        = 'vlev',  // int32_t
+#ifdef OMAP_ENHANCEMENT
+    kKeyNumRefFrames      = 'vnrf',  // int32_t
+    kKeyVideoFPS          = 'vfps',  // int32_t
+    kKeyVideoInterlaced   = 'vint',  // int32_t (bool)
+#endif
 
     // Set this key to enable authoring files in 64-bit offset
     kKey64BitFileOffset   = 'fobt',  // int32_t (bool)
@@ -102,6 +111,16 @@ enum {
     kKeyValidSamples      = 'valD',  // int32_t
 
     kKeyIsUnreadable      = 'unre',  // bool (int32_t)
+
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    kKeyPaddedWidth       = 'pwid',   // int32_t
+    kKeyPaddedHeight      = 'phei',   // int32_t
+    kKeyOffset            = 'offs',   // int32_t
+    kKeyIsExtraData     = 'xdta',     // int32_t (bool)
+    kKeyS3dSupported     ='s3ds',    // int32_t (bool)
+    kKeySEIEncodingType  ='seit',    // int32_t
+    kKeyFrameLayout      ='frml',    // cstring
+#endif
 };
 
 enum {
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index 8274dfb..d82792b 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -38,6 +38,13 @@ struct OMXCodec : public MediaSource,
         // The client wants to access the output buffer's video
         // data for example for thumbnail extraction.
         kClientNeedsFramebuffer  = 4,
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+        kPreferThumbnailMode               = 0x8,
+        kPreferInterlacedOutputContent     = 0x10,
+        MAX_RESOLUTION = 414720, // video resolution for TI Vid Dec
+        MAX_RESOLUTION_WIDTH = 864, // video width for TI Vid Dec
+        MAX_RESOLUTION_HEIGHT = 864, // video height for TI Vid Dec
+#endif
     };
     static sp<MediaSource> Create(
             const sp<IOMX> &omx,
@@ -46,6 +53,16 @@ struct OMXCodec : public MediaSource,
             const char *matchComponentName = NULL,
             uint32_t flags = 0);
 
+#ifdef OMAP_ENHANCEMENT
+    static sp<MediaSource> Create(
+            const sp<IOMX> &omx,
+            const sp<MetaData> &meta, bool createEncoder,
+            const sp<MediaSource> &source,
+            IOMX::node_id &nodeId,
+            const char *matchComponentName = NULL,
+            uint32_t flags = 0);
+#endif
+
     static void setComponentRole(
             const sp<IOMX> &omx, IOMX::node_id node, bool isEncoder,
             const char *mime);
@@ -54,19 +71,26 @@ struct OMXCodec : public MediaSource,
     virtual status_t stop();
 
     virtual sp<MetaData> getFormat();
-
+#ifdef OMAP_ENHANCEMENT
+    virtual void setBuffers(Vector< sp<IMemory> > mBufferAddresses, bool portReconfig = false);
+    virtual int getNumofOutputBuffers();
+#endif
     virtual status_t read(
             MediaBuffer **buffer, const ReadOptions *options = NULL);
 
     virtual status_t pause();
 
+    void registerBuffers(const sp<IMemoryHeap> &mem);
+
     // from MediaBufferObserver
     virtual void signalBufferReturned(MediaBuffer *buffer);
 
 protected:
     virtual ~OMXCodec();
 
+#ifndef OMAP_ENHANCEMENT
 private:
+#endif
 
     // Make sure mLock is accessible to OMXCodecObserver
     friend class OMXCodecObserver;
@@ -115,15 +139,28 @@ private:
         kRequiresLargerEncoderOutputBuffer    = 4096,
         kOutputBuffersAreUnreadable           = 8192,
         kStoreMetaDataInInputVideoBuffers     = 16384,
+        kCanNotSetVideoParameters             = 32768,
+        kDoesNotRequireMemcpyOnOutputPort     = 65536,
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+        kDecoderNeedsPortReconfiguration      = 131072,
+        kDecoderCantRenderSmallClips          = 262144,
+        kInterlacedOutputContent              = 524288,
+        kThumbnailMode                        = 1048576,
+#endif
     };
 
     struct BufferInfo {
         IOMX::buffer_id mBuffer;
         bool mOwnedByComponent;
+#ifdef OMAP_ENHANCEMENT
+        bool mOwnedByPlayer;
+#endif
         sp<IMemory> mMem;
         size_t mSize;
         void *mData;
         MediaBuffer *mMediaBuffer;
+        OMX_U8 *mAllocatedBuffer;
+        size_t mAllocatedSize;
     };
 
     struct CodecSpecificData {
@@ -142,10 +179,15 @@ private:
     sp<MediaSource> mSource;
     Vector<CodecSpecificData *> mCodecSpecificData;
     size_t mCodecSpecificDataIndex;
-
+    sp<IMemoryHeap> mPmemInfo;
     sp<MemoryDealer> mDealer[2];
 
     State mState;
+#ifdef OMAP_ENHANCEMENT
+    Vector< sp<IMemory> > mExtBufferAddresses;
+    uint32_t mStride;
+    nsecs_t mNSecsToWait;
+#endif
     Vector<BufferInfo> mPortBuffers[2];
     PortStatus mPortStatus[2];
     bool mInitialBufferSubmit;
@@ -189,6 +231,11 @@ private:
     void setVideoInputFormat(
             const char *mime, const sp<MetaData>& meta);
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+    status_t setupEncoderPresetParams(int32_t isS3DEnabled);
+    status_t setupEncoderFrameDataContentParams(const sp<MetaData>& meta);
+#endif
+
     status_t setupBitRate(int32_t bitRate);
     status_t setupErrorCorrectionParameters();
     status_t setupH263EncoderParameters(const sp<MetaData>& meta);
@@ -223,6 +270,8 @@ private:
     status_t allocateBuffers();
     status_t allocateBuffersOnPort(OMX_U32 portIndex);
 
+    status_t freeBuffer(
+            OMX_U32 portIndex, BufferInfo *info);
     status_t freeBuffersOnPort(
             OMX_U32 portIndex, bool onlyThoseWeOwn = false);
 
@@ -259,11 +308,22 @@ private:
 
     void dumpPortStatus(OMX_U32 portIndex);
 
+#ifdef OMAP_ENHANCEMENT
+public:
+#endif
     status_t configureCodec(const sp<MetaData> &meta, uint32_t flags);
 
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+protected:
+    static uint32_t getComponentQuirks(const char *componentName, bool isEncoder, uint32_t flags = 0);
+    int32_t mVideoFPS;
+#if defined(TARGET_OMAP4)
+    void setS3DMetaDataConfig(int32_t frameContentType);
+#endif
+#else
     static uint32_t getComponentQuirks(
             const char *componentName, bool isEncoder);
-
+#endif
     static void findMatchingCodecs(
             const char *mime,
             bool createEncoder, const char *matchComponentName,
@@ -272,8 +332,59 @@ private:
 
     OMXCodec(const OMXCodec &);
     OMXCodec &operator=(const OMXCodec &);
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4) && defined (NPA_BUFFERS)
+    uint32_t mNumberOfNPABuffersSent;
+	uint32_t mThumbnailEOSSent;
+#endif
+};
+
+#if defined(OMAP_ENHANCEMENT)
+struct OMXCodecObserver : public BnOMXObserver {
+    OMXCodecObserver() {
+    }
+
+    void setCodec(const sp<OMXCodec> &target) {
+        mTarget = target;
+    }
+
+    // from IOMXObserver
+    virtual void onMessage(const omx_message &msg) {
+         sp<OMXCodec> codec = mTarget.promote();
+
+        if (codec.get() != NULL) {
+            Mutex::Autolock autoLock(codec->mLock);
+            codec->on_message(msg);
+            codec.clear();
+        }
+    }
+
+protected:
+    virtual ~OMXCodecObserver() {}
+
+private:
+    wp<OMXCodec> mTarget;
+
+    OMXCodecObserver(const OMXCodecObserver &);
+    OMXCodecObserver &operator=(const OMXCodecObserver &);
 };
 
+template<class T>
+static void InitOMXParams(T *params) {
+    params->nSize = sizeof(T);
+    params->nVersion.s.nVersionMajor = 1;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    //Ducati strict OMX Version check
+    params->nVersion.s.nVersionMinor = 1;
+#else
+    params->nVersion.s.nVersionMinor = 0;
+#endif
+    params->nVersion.s.nRevision = 0;
+    params->nVersion.s.nStep = 0;
+}
+
+#endif
+
 struct CodecProfileLevel {
     OMX_U32 mProfile;
     OMX_U32 mLevel;
diff --git a/include/media/stagefright/Utils.h b/include/media/stagefright/Utils.h
index 498b525..19d1328 100644
--- a/include/media/stagefright/Utils.h
+++ b/include/media/stagefright/Utils.h
@@ -19,11 +19,49 @@
 #define UTILS_H_
 
 #include <stdint.h>
+#ifdef OMAP_ENHANCEMENT
+#include <media/stagefright/openmax/OMX_Types.h>
+#include <media/stagefright/openmax/OMX_Index.h>
+#endif
 
 namespace android {
 
 #define FOURCC(c1, c2, c3, c4) \
     (c1 << 24 | c2 << 16 | c3 << 8 | c4)
+#ifdef OMAP_ENHANCEMENT
+#ifndef MAKEFOURCC_WMC
+#define MAKEFOURCC_WMC(ch0, ch1, ch2, ch3) \
+        ((OMX_U32)(OMX_U8)(ch0) | ((OMX_U32)(OMX_U8)(ch1) << 8) |   \
+        ((OMX_U32)(OMX_U8)(ch2) << 16) | ((OMX_U32)(OMX_U8)(ch3) << 24 ))
+
+#define mmioFOURCC_WMC(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMC(ch0, ch1, ch2, ch3)
+#endif
+
+#define FOURCC_WMV3     mmioFOURCC_WMC('W','M','V','3')
+#define FOURCC_WMV2     mmioFOURCC_WMC('W','M','V','2')
+#define FOURCC_WMV1     mmioFOURCC_WMC('W','M','V','1')
+#define FOURCC_WMVA     mmioFOURCC_WMC('W','M','V','A')
+#define FOURCC_WVC1     mmioFOURCC_WMC('W','V','C','1')
+
+#define VIDDEC_WMV_ELEMSTREAM                           0
+#define VIDDEC_WMV_RCVSTREAM                            1
+
+typedef enum VIDDEC_CUSTOM_PARAM_INDEX
+{
+    VideoDecodeCustomParamProcessMode = (OMX_IndexVendorStartUnused + 1),
+    VideoDecodeCustomParamH264BitStreamFormat,
+    VideoDecodeCustomParamWMVProfile,
+    VideoDecodeCustomParamWMVFileType,
+    VideoDecodeCustomParamParserEnabled,
+
+} VIDDEC_CUSTOM_PARAM_INDEX;
+
+typedef struct OMX_PARAM_WMVFILETYPE {
+    OMX_U32 nSize;
+    OMX_VERSIONTYPE nVersion;
+    OMX_U32 nWmvFileType;
+} OMX_PARAM_WMVFILETYPE;
+#endif
 
 uint16_t U16_AT(const uint8_t *ptr);
 uint32_t U32_AT(const uint8_t *ptr);
diff --git a/include/media/stagefright/VideoRenderer.h b/include/media/stagefright/VideoRenderer.h
index f80b277..b53fb0f 100644
--- a/include/media/stagefright/VideoRenderer.h
+++ b/include/media/stagefright/VideoRenderer.h
@@ -19,9 +19,24 @@
 #define VIDEO_RENDERER_H_
 
 #include <sys/types.h>
+#ifdef OMAP_ENHANCEMENT
+#include "binder/IMemory.h"
+#include <utils/Vector.h>
+#endif
 
 namespace android {
 
+#ifdef OMAP_ENHANCEMENT
+typedef void (*release_rendered_buffer_callback)(const sp<IMemory>& mem, void *cookie);
+typedef struct {
+    uint32_t decoded_width;
+    uint32_t decoded_height;
+    uint32_t buffercount;
+    uint32_t display_width;
+    uint32_t display_height;
+    }render_resize_params;
+#endif
+
 class VideoRenderer {
 public:
     virtual ~VideoRenderer() {}
@@ -29,6 +44,14 @@ public:
     virtual void render(
             const void *data, size_t size, void *platformPrivate) = 0;
 
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers() = 0;
+    virtual bool setCallback(release_rendered_buffer_callback cb, void *cookie) {return false;}
+    virtual void set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling) {}
+    virtual void resizeRenderer(void* resize_params) = 0;
+    virtual void requestRendererClone(bool enable) = 0;
+#endif
+
 protected:
     VideoRenderer() {}
 
diff --git a/include/media/stagefright/openmax/OMX_Index.h b/include/media/stagefright/openmax/OMX_Index.h
index c0b8d92..579a9d6 100644
--- a/include/media/stagefright/openmax/OMX_Index.h
+++ b/include/media/stagefright/openmax/OMX_Index.h
@@ -58,7 +58,6 @@ extern "C" {
  */
 #include <OMX_Types.h>
 
-
 /** The OMX_INDEXTYPE enumeration is used to select a structure when either
  *  getting or setting parameters and/or configuration data.  Each entry in 
  *  this enumeration maps to an OMX specified structure.  When the 
diff --git a/include/ui/Overlay.h b/include/ui/Overlay.h
index a9ae1c4..3929790 100644
--- a/include/ui/Overlay.h
+++ b/include/ui/Overlay.h
@@ -91,6 +91,7 @@ public:
 
     /* set the buffer attributes */
     status_t setParameter(int param, int value);
+    status_t setFd(int fd);
 
     /* returns the address of a given buffer if supported, NULL otherwise. */
     void* getBufferAddress(overlay_buffer_t buffer);
diff --git a/libs/ui/Overlay.cpp b/libs/ui/Overlay.cpp
index 3aa8950..3e9c583 100644
--- a/libs/ui/Overlay.cpp
+++ b/libs/ui/Overlay.cpp
@@ -83,6 +83,12 @@ status_t Overlay::getCrop(uint32_t* x, uint32_t* y, uint32_t* w, uint32_t* h)
     return mOverlayData->getCrop(mOverlayData, x, y, w, h);
 }
 
+status_t Overlay::setFd(int fd)
+{
+    if (mStatus != NO_ERROR) return mStatus;
+    return mOverlayData->setFd(mOverlayData, fd);
+}
+
 int32_t Overlay::getBufferCount() const
 {
     if (mStatus != NO_ERROR) return mStatus;
diff --git a/libs/utils/Android.mk b/libs/utils/Android.mk
index eb75ed8..af2ede9 100644
--- a/libs/utils/Android.mk
+++ b/libs/utils/Android.mk
@@ -57,7 +57,7 @@ LOCAL_SRC_FILES:= $(commonSources)
 
 LOCAL_MODULE:= libutils
 
-LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1 $(TOOL_CFLAGS)
+LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1 $(TOOL_CFLAGS)  -fpermissive
 LOCAL_C_INCLUDES += external/zlib
 
 ifeq ($(HOST_OS),windows)
diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index 2e5cbe3..95f7a2a 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -47,6 +47,14 @@ ifneq ($(TARGET_SIMULATOR),true)
 LOCAL_SHARED_LIBRARIES += libdl
 endif
 
+ifeq ($(BOARD_USE_KINETO_COMPATIBILITY),true)
+LOCAL_CFLAGS += -DUSE_KINETO_COMPATIBILITY
+endif
+
+ifeq ($(BOARD_USES_SAMSUNG_SEPARATED_STREAM),true)
+LOCAL_CFLAGS += -DUSES_SAMSUNG_SEPARATED_STREAM
+endif
+
 LOCAL_C_INCLUDES := \
     $(JNI_H_INCLUDE) \
     $(call include-path-for, graphics corecg) \
@@ -54,4 +62,12 @@ LOCAL_C_INCLUDES := \
     external/icu4c/common \
     external/expat/lib
 
+ifeq ($(OMAP_ENHANCEMENT),true)
+
+LOCAL_SRC_FILES += OverlayRenderer.cpp
+
+LOCAL_C_INCLUDES += $(TOP)/hardware/ti/omap3/liboverlay
+
+endif
+
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libmedia/AudioRecord.cpp b/media/libmedia/AudioRecord.cpp
index a6c515c..c0ee5b0 100644
--- a/media/libmedia/AudioRecord.cpp
+++ b/media/libmedia/AudioRecord.cpp
@@ -98,6 +98,38 @@ AudioRecord::AudioRecord(
             frameCount, flags, cbf, user, notificationFrames, sessionId);
 }
 
+#ifdef USE_KINETO_COMPATIBILITY
+// Really dirty hack to give a Froyo-compatible constructor
+extern "C" AudioRecord *_ZN7android11AudioRecordC1EijijijPFviPvS1_ES1_ii(
+        AudioRecord *This,
+        int inputSource,
+        uint32_t sampleRate,
+        int format,
+        uint32_t channels,
+        int frameCount,
+        uint32_t flags,
+        AudioRecord::callback_t cbf,
+        void* user,
+        int notificationFrames,
+        int sessionId);
+extern "C" AudioRecord *_ZN7android11AudioRecordC1EijijijPFviPvS1_ES1_i(
+        AudioRecord *This,
+        int inputSource,
+        uint32_t sampleRate,
+        int format,
+        uint32_t channels,
+        int frameCount,
+        uint32_t flags,
+        AudioRecord::callback_t cbf,
+        void* user,
+        int notificationFrames)
+{
+    return _ZN7android11AudioRecordC1EijijijPFviPvS1_ES1_ii(This,
+        inputSource, sampleRate, format, channels,
+        frameCount, flags, cbf, user, notificationFrames, 0);
+}
+#endif
+
 AudioRecord::~AudioRecord()
 {
     if (mStatus == NO_ERROR) {
@@ -114,6 +146,40 @@ AudioRecord::~AudioRecord()
     }
 }
 
+#ifdef USE_KINETO_COMPATIBILITY
+// another hack, this time for a Froyo-compatible AudioRecord::set method
+extern "C" status_t _ZN7android11AudioRecord3setEijijijPFviPvS1_ES1_ibi(
+        AudioRecord *This,
+        int inputSource,
+        uint32_t sampleRate,
+        int format,
+        uint32_t channels,
+        int frameCount,
+        uint32_t flags,
+        AudioRecord::callback_t,
+        void* user,
+        int notificationFrames,
+        bool threadCanCallJava,
+        int sessionId);
+extern "C" status_t _ZN7android11AudioRecord3setEijijijPFviPvS1_ES1_ib(
+        AudioRecord *This,
+        int inputSource,
+        uint32_t sampleRate,
+        int format,
+        uint32_t channels,
+        int frameCount,
+        uint32_t flags,
+        AudioRecord::callback_t cbf,
+        void* user,
+        int notificationFrames,
+        bool threadCanCallJava)
+{
+    return _ZN7android11AudioRecord3setEijijijPFviPvS1_ES1_ibi(
+        This, inputSource, sampleRate, format, channels, frameCount,
+        flags, cbf, user, notificationFrames, threadCanCallJava, 0);
+}
+#endif
+
 status_t AudioRecord::set(
         int inputSource,
         uint32_t sampleRate,
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index 1a3fcd6..5dcf00e 100644
--- a/media/libmedia/AudioSystem.cpp
+++ b/media/libmedia/AudioSystem.cpp
@@ -370,6 +370,15 @@ int AudioSystem::newAudioSessionId() {
     return af->newAudioSessionId();
 }
 
+#ifdef HAVE_FM_RADIO
+status_t AudioSystem::setFmVolume(float value)
+{
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->setFmVolume(value);
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 void AudioSystem::AudioFlingerClient::binderDied(const wp<IBinder>& who) {
@@ -746,6 +755,18 @@ bool AudioSystem::isInputDevice(audio_devices device)
     }
 }
 
+#ifdef HAVE_FM_RADIO
+bool AudioSystem::isFmDevice(audio_devices device)
+{
+    if ((popCount(device) == 1 ) &&
+        ((device & ~AudioSystem::DEVICE_OUT_FM_ALL) == 0)) {
+        return true;
+    } else {
+        return false;
+    }
+}
+#endif
+
 bool AudioSystem::isA2dpDevice(audio_devices device)
 {
     if ((popCount(device) == 1 ) &&
@@ -828,6 +849,13 @@ bool AudioSystem::isLinearPCM(uint32_t format)
     }
 }
 
+#ifdef USES_SAMSUNG_SEPARATED_STREAM
+bool AudioSystem::isSeperatedStream(stream_type stream)
+{
+    return false;
+}
+#endif
+
 //------------------------- AudioParameter class implementation ---------------
 
 const char *AudioParameter::keyRouting = "routing";
@@ -835,6 +863,10 @@ const char *AudioParameter::keySamplingRate = "sampling_rate";
 const char *AudioParameter::keyFormat = "format";
 const char *AudioParameter::keyChannels = "channels";
 const char *AudioParameter::keyFrameCount = "frame_count";
+#ifdef HAVE_FM_RADIO
+const char *AudioParameter::keyFmOn = "fm_on";
+const char *AudioParameter::keyFmOff = "fm_off";
+#endif
 const char *AudioParameter::keyInputSource = "input_source";
 
 AudioParameter::AudioParameter(const String8& keyValuePairs)
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 587c8ff..1c4a8d3 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -96,6 +96,38 @@ AudioTrack::AudioTrack(
             0, false, sessionId);
 }
 
+#ifdef USE_KINETO_COMPATIBILITY
+// Really dirty hack to give a Froyo-compatible constructor
+extern "C" AudioTrack *_ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_ii(
+        AudioTrack *This,
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        int frameCount,
+        uint32_t flags,
+        AudioTrack::callback_t cbf,
+        void* user,
+        int notificationFrames,
+        int sessionId);
+extern "C" AudioTrack *_ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_i(
+        AudioTrack *This,
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        int frameCount,
+        uint32_t flags,
+        AudioTrack::callback_t cbf,
+        void* user,
+        int notificationFrames)
+{
+    return _ZN7android10AudioTrackC1EijiiijPFviPvS1_ES1_ii(This,
+        streamType, sampleRate, format, channels,
+        frameCount, flags, cbf, user, notificationFrames, 0);
+}
+#endif
+
 AudioTrack::AudioTrack(
         int streamType,
         uint32_t sampleRate,
@@ -132,6 +164,42 @@ AudioTrack::~AudioTrack()
     }
 }
 
+#ifdef USE_KINETO_COMPATIBILITY
+// another hack, this time for a Froyo-compatible AudioTrack::set method
+extern "C" status_t _ZN7android10AudioTrack3setEijiiijPFviPvS1_ES1_iRKNS_2spINS_7IMemoryEEEbi(
+        AudioTrack *This,
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        int frameCount,
+        uint32_t flags,
+        AudioTrack::callback_t cbf,
+        void* user,
+        int notificationFrames,
+        const sp<IMemory>& sharedBuffer,
+        bool threadCanCallJava,
+        int sessionId);
+extern "C" status_t _ZN7android10AudioTrack3setEijiiijPFviPvS1_ES1_iRKNS_2spINS_7IMemoryEEEb(
+        AudioTrack *This,
+        int streamType,
+        uint32_t sampleRate,
+        int format,
+        int channels,
+        int frameCount,
+        uint32_t flags,
+        AudioTrack::callback_t cbf,
+        void* user,
+        int notificationFrames,
+        const sp<IMemory>& sharedBuffer,
+        bool threadCanCallJava)
+{
+    return _ZN7android10AudioTrack3setEijiiijPFviPvS1_ES1_iRKNS_2spINS_7IMemoryEEEbi(
+        This, streamType, sampleRate, format, channels, frameCount, flags, cbf,
+        user, notificationFrames, sharedBuffer, threadCanCallJava, 0);
+}
+#endif
+
 status_t AudioTrack::set(
         int streamType,
         uint32_t sampleRate,
@@ -324,7 +392,7 @@ void AudioTrack::start()
         }
 
         if (mCblk->flags & CBLK_INVALID_MSK) {
-            LOGW("start() track %p invalidated, creating a new one", this);
+            LOGE("start() track %p invalidated, creating a new one", this);
             // no need to clear the invalid flag as this cblk will not be used anymore
             // force new track creation
             status = DEAD_OBJECT;
@@ -332,7 +400,8 @@ void AudioTrack::start()
             status = mAudioTrack->start();
         }
         if (status == DEAD_OBJECT) {
-            LOGV("start() dead IAudioTrack: creating a new one");
+            LOGE("start() dead IAudioTrack: creating a new one");
+            mSessionId = 0;
             status = createTrack(mStreamType, mCblk->sampleRate, mFormat, mChannelCount,
                                  mFrameCount, mFlags, mSharedBuffer, getOutput(), false);
             if (status == NO_ERROR) {
@@ -816,8 +885,9 @@ status_t AudioTrack::obtainBuffer(Buffer* audioBuffer, int32_t waitCount)
                         cblk->lock.unlock();
                         result = mAudioTrack->start();
                         if (result == DEAD_OBJECT) {
-                            LOGW("obtainBuffer() dead IAudioTrack: creating a new one");
+                            LOGE("obtainBuffer() dead IAudioTrack: creating a new one");
 create_new_track:
+                            mSessionId = 0;
                             result = createTrack(mStreamType, cblk->sampleRate, mFormat, mChannelCount,
                                                  mFrameCount, mFlags, mSharedBuffer, getOutput(), false);
                             if (result == NO_ERROR) {
diff --git a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
index 3a89e25..d247c1a 100644
--- a/media/libmedia/IAudioFlinger.cpp
+++ b/media/libmedia/IAudioFlinger.cpp
@@ -70,7 +70,13 @@ enum {
     QUERY_EFFECT,
     GET_EFFECT_DESCRIPTOR,
     CREATE_EFFECT,
-    MOVE_EFFECTS
+    MOVE_EFFECTS,
+#ifdef HAVE_FM_RADIO
+    SET_FM_VOLUME,
+#endif
+#ifdef OMAP_ENHANCEMENT
+    SET_FMRX_ACTIVE
+#endif
 };
 
 class BpAudioFlinger : public BpInterface<IAudioFlinger>
@@ -270,7 +276,16 @@ public:
         remote()->transact(SET_STREAM_MUTE, data, &reply);
         return reply.readInt32();
     }
-
+#ifdef OMAP_ENHANCEMENT
+    virtual status_t setFMRxActive( bool state)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(state);
+        remote()->transact(SET_FMRX_ACTIVE, data, &reply);
+        return reply.readInt32();
+    }
+#endif
     virtual float streamVolume(int stream, int output) const
     {
         Parcel data, reply;
@@ -688,6 +703,17 @@ public:
         remote()->transact(MOVE_EFFECTS, data, &reply);
         return reply.readInt32();
     }
+
+#ifdef HAVE_FM_RADIO
+    virtual status_t setFmVolume(float volume)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeFloat(volume);
+        remote()->transact(SET_FM_VOLUME, data, &reply);
+        return reply.readInt32();
+    }
+#endif
 };
 
 IMPLEMENT_META_INTERFACE(AudioFlinger, "android.media.IAudioFlinger");
@@ -796,6 +822,13 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32( setStreamMute(stream, data.readInt32()) );
             return NO_ERROR;
         } break;
+#ifdef OMAP_ENHANCEMENT
+        case SET_FMRX_ACTIVE: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            reply->writeInt32( setFMRxActive(data.readInt32()) );
+            return NO_ERROR;
+        } break;
+#endif
         case STREAM_VOLUME: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             int stream = data.readInt32();
@@ -1044,6 +1077,14 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(moveEffects(session, srcOutput, dstOutput));
             return NO_ERROR;
         } break;
+#ifdef HAVE_FM_RADIO
+        case SET_FM_VOLUME: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            float volume = data.readFloat();
+            reply->writeInt32( setFmVolume(volume) );
+            return NO_ERROR;
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IMediaPlayer.cpp b/media/libmedia/IMediaPlayer.cpp
index 0f55b19d..ce06eb5 100644
--- a/media/libmedia/IMediaPlayer.cpp
+++ b/media/libmedia/IMediaPlayer.cpp
@@ -46,7 +46,10 @@ enum {
     SUSPEND,
     RESUME,
     SET_AUX_EFFECT_SEND_LEVEL,
-    ATTACH_AUX_EFFECT
+    ATTACH_AUX_EFFECT,
+#ifdef OMAP_ENHANCEMENT
+    REQUEST_CLONE_MODE
+#endif
 };
 
 class BpMediaPlayer: public BpInterface<IMediaPlayer>
@@ -241,6 +244,17 @@ public:
         remote()->transact(ATTACH_AUX_EFFECT, data, &reply);
         return reply.readInt32();
     }
+
+#ifdef OMAP_ENHANCEMENT
+    status_t requestVideoCloneMode(bool enable) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IMediaPlayer::getInterfaceDescriptor());
+        data.writeInt32((int)enable);
+        remote()->transact(REQUEST_CLONE_MODE, data, &reply);
+        return reply.readInt32();
+    }
+
+#endif
 };
 
 IMPLEMENT_META_INTERFACE(MediaPlayer, "android.media.IMediaPlayer");
@@ -369,6 +383,13 @@ status_t BnMediaPlayer::onTransact(
             reply->writeInt32(attachAuxEffect(data.readInt32()));
             return NO_ERROR;
         } break;
+#ifdef OMAP_ENHANCEMENT
+        case REQUEST_CLONE_MODE: {
+            CHECK_INTERFACE(IMediaPlayer, data, reply);
+            reply->writeInt32(requestVideoCloneMode(data.readInt32()));
+            return NO_ERROR;
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IMediaPlayerService.cpp b/media/libmedia/IMediaPlayerService.cpp
index 4abfa75..e076180 100644
--- a/media/libmedia/IMediaPlayerService.cpp
+++ b/media/libmedia/IMediaPlayerService.cpp
@@ -23,9 +23,12 @@
 #include <media/IMediaPlayerService.h>
 #include <media/IMediaRecorder.h>
 #include <media/IOMX.h>
-
 #include <utils/Errors.h>  // for status_t
 
+#ifdef OMAP_ENHANCEMENT
+#include <media/OverlayRenderer.h>
+#endif
+
 namespace android {
 
 enum {
@@ -35,7 +38,10 @@ enum {
     DECODE_FD,
     CREATE_MEDIA_RECORDER,
     CREATE_METADATA_RETRIEVER,
-    GET_OMX
+    GET_OMX,
+#ifdef OMAP_ENHANCEMENT
+    GET_OVERLAY_RENDERER,
+#endif
 };
 
 class BpMediaPlayerService: public BpInterface<IMediaPlayerService>
@@ -139,6 +145,15 @@ public:
         remote()->transact(GET_OMX, data, &reply);
         return interface_cast<IOMX>(reply.readStrongBinder());
     }
+
+#ifdef OMAP_ENHANCEMENT
+    virtual sp<IOverlayRenderer> getOverlayRenderer() {
+        Parcel data, reply;
+        data.writeInterfaceToken(IMediaPlayerService::getInterfaceDescriptor());
+        remote()->transact(GET_OVERLAY_RENDERER, data, &reply);
+        return interface_cast<IOverlayRenderer>(reply.readStrongBinder());
+    }
+#endif
 };
 
 IMPLEMENT_META_INTERFACE(MediaPlayerService, "android.media.IMediaPlayerService");
@@ -232,6 +247,14 @@ status_t BnMediaPlayerService::onTransact(
             reply->writeStrongBinder(omx->asBinder());
             return NO_ERROR;
         } break;
+#ifdef OMAP_ENHANCEMENT
+        case GET_OVERLAY_RENDERER: {
+            CHECK_INTERFACE(IMediaPlayerService, data, reply);
+            sp<IOverlayRenderer> renderer = getOverlayRenderer();
+            reply->writeStrongBinder(renderer->asBinder());
+            return NO_ERROR;
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IMediaRecorder.cpp b/media/libmedia/IMediaRecorder.cpp
index 947ff34..7ac722c 100644
--- a/media/libmedia/IMediaRecorder.cpp
+++ b/media/libmedia/IMediaRecorder.cpp
@@ -46,6 +46,7 @@ enum {
     SET_VIDEO_SIZE,
     SET_VIDEO_FRAMERATE,
     SET_PARAMETERS,
+    SET_CAMERA_PARAMETERS,
     SET_PREVIEW_SURFACE,
     SET_CAMERA,
     SET_LISTENER
@@ -190,6 +191,16 @@ public:
         return reply.readInt32();
     }
 
+    status_t setCameraParameters(const String8& params)
+    {
+        LOGV("setCameraParameter(%s)", params.string());
+        Parcel data, reply;
+        data.writeInterfaceToken(IMediaRecorder::getInterfaceDescriptor());
+        data.writeString8(params);
+        remote()->transact(SET_CAMERA_PARAMETERS, data, &reply);
+        return reply.readInt32();
+    }
+
     status_t setListener(const sp<IMediaRecorderClient>& listener)
     {
         LOGV("setListener(%p)", listener.get());
@@ -398,6 +409,12 @@ status_t BnMediaRecorder::onTransact(
             reply->writeInt32(setParameters(data.readString8()));
             return NO_ERROR;
         } break;
+        case SET_CAMERA_PARAMETERS: {
+            LOGV("SET_CAMERA_PARAMETER");
+            CHECK_INTERFACE(IMediaRecorder, data, reply);
+            reply->writeInt32(setCameraParameters(data.readString8()));
+            return NO_ERROR;
+        } break;
         case SET_LISTENER: {
             LOGV("SET_LISTENER");
             CHECK_INTERFACE(IMediaRecorder, data, reply);
diff --git a/media/libmedia/IOMX.cpp b/media/libmedia/IOMX.cpp
index ae6c2bf..7c6469d 100644
--- a/media/libmedia/IOMX.cpp
+++ b/media/libmedia/IOMX.cpp
@@ -29,8 +29,15 @@ enum {
     EMPTY_BUFFER,
     GET_EXTENSION_INDEX,
     CREATE_RENDERER,
+#ifdef OMAP_ENHANCEMENT
+    CREATE_RENDERER_S3D,
+#endif
     OBSERVER_ON_MSG,
     RENDERER_RENDER,
+    REGISTER_BUFFERS,
+#ifdef OMAP_ENHANCEMENT
+    GET_BUFFERS,
+#endif
 };
 
 sp<IOMXRenderer> IOMX::createRenderer(
@@ -47,6 +54,20 @@ sp<IOMXRenderer> IOMX::createRenderer(
             rotationDegrees);
 }
 
+#ifdef OMAP_ENHANCEMENT
+sp<IOMXRenderer> IOMX::createRenderer(
+        const sp<Surface> &surface,
+        const char *componentName,
+        OMX_COLOR_FORMATTYPE colorFormat,
+        size_t encodedWidth, size_t encodedHeight,
+        size_t displayWidth, size_t displayHeight, int32_t rotate, int isS3D, int numOfOpBuffers) {
+    return createRenderer(
+            surface->getISurface(),
+            componentName, colorFormat, encodedWidth, encodedHeight,
+            displayWidth, displayHeight, rotate, isS3D, numOfOpBuffers);
+}
+#endif
+
 sp<IOMXRenderer> IOMX::createRendererFromJavaSurface(
         JNIEnv *env, jobject javaSurface,
         const char *componentName,
@@ -220,14 +241,31 @@ public:
         return reply.readInt32();
     }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemory> &params,
+            buffer_id *buffer) {
+        return useBuffer(node, port_index, params, buffer, 0);
+    }
+#endif
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemory> &params,
+            buffer_id *buffer, size_t size) {
+#else
     virtual status_t useBuffer(
             node_id node, OMX_U32 port_index, const sp<IMemory> &params,
             buffer_id *buffer) {
+#endif
         Parcel data, reply;
         data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
         data.writeIntPtr((intptr_t)node);
         data.writeInt32(port_index);
         data.writeStrongBinder(params->asBinder());
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        data.writeInt32(size);
+#endif
         remote()->transact(USE_BUFFER, data, &reply);
 
         status_t err = reply.readInt32();
@@ -371,6 +409,33 @@ public:
 
         return interface_cast<IOMXRenderer>(reply.readStrongBinder());
     }
+
+#ifdef OMAP_ENHANCEMENT
+    virtual sp<IOMXRenderer> createRenderer(
+            const sp<ISurface> &surface,
+            const char *componentName,
+            OMX_COLOR_FORMATTYPE colorFormat,
+            size_t encodedWidth, size_t encodedHeight,
+            size_t displayWidth, size_t displayHeight, int32_t rotationDegrees, int isS3D, int numOfOpBuffers) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
+        data.writeStrongBinder(surface->asBinder());
+        data.writeCString(componentName);
+        data.writeInt32(colorFormat);
+        data.writeInt32(encodedWidth);
+        data.writeInt32(encodedHeight);
+        data.writeInt32(displayWidth);
+        data.writeInt32(displayHeight);
+        data.writeInt32(rotationDegrees);
+	data.writeInt32(isS3D);
+        data.writeInt32(numOfOpBuffers);
+
+        remote()->transact(CREATE_RENDERER_S3D, data, &reply);
+
+        return interface_cast<IOMXRenderer>(reply.readStrongBinder());
+    }
+#endif
+
 };
 
 IMPLEMENT_META_INTERFACE(OMX, "android.hardware.IOMX");
@@ -557,7 +622,12 @@ status_t BnOMX::onTransact(
                 interface_cast<IMemory>(data.readStrongBinder());
 
             buffer_id buffer;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+            OMX_U32 size = data.readInt32();
+            status_t err = useBuffer(node, port_index, params, &buffer, size);
+#else
             status_t err = useBuffer(node, port_index, params, &buffer);
+#endif
             reply->writeInt32(err);
 
             if (err == OK) {
@@ -701,6 +771,37 @@ status_t BnOMX::onTransact(
             return OK;
         }
 
+#ifdef OMAP_ENHANCEMENT
+	case CREATE_RENDERER_S3D:
+        {
+            CHECK_INTERFACE(IOMX, data, reply);
+
+            sp<ISurface> isurface =
+                interface_cast<ISurface>(data.readStrongBinder());
+
+            const char *componentName = data.readCString();
+
+            OMX_COLOR_FORMATTYPE colorFormat =
+                static_cast<OMX_COLOR_FORMATTYPE>(data.readInt32());
+
+            size_t encodedWidth = (size_t)data.readInt32();
+            size_t encodedHeight = (size_t)data.readInt32();
+            size_t displayWidth = (size_t)data.readInt32();
+            size_t displayHeight = (size_t)data.readInt32();
+            int32_t rotationDegrees = data.readInt32();
+            size_t isS3D = (size_t)data.readInt32();
+            int numOfOpBuffers = (int)data.readInt32();
+
+            sp<IOMXRenderer> renderer =
+                createRenderer(isurface, componentName, colorFormat,
+                               encodedWidth, encodedHeight,
+                               displayWidth, displayHeight, rotationDegrees, isS3D, numOfOpBuffers);
+            reply->writeStrongBinder(renderer->asBinder());
+
+            return OK;
+        }
+#endif
+
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
@@ -721,6 +822,13 @@ public:
 
         remote()->transact(OBSERVER_ON_MSG, data, &reply, IBinder::FLAG_ONEWAY);
     }
+
+    virtual void registerBuffers(const sp<IMemoryHeap> &mem) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMXObserver::getInterfaceDescriptor());
+        data.writeStrongBinder(mem->asBinder());
+        remote()->transact(REGISTER_BUFFERS, data, &reply);
+    }
 };
 
 IMPLEMENT_META_INTERFACE(OMXObserver, "android.hardware.IOMXObserver");
@@ -740,6 +848,15 @@ status_t BnOMXObserver::onTransact(
 
             return NO_ERROR;
         }
+#ifndef OMAP_ENHANCEMENT
+        case REGISTER_BUFFERS:
+        {
+            CHECK_INTERFACE(IOMXObserver, data, reply);
+            sp<IMemoryHeap> mem =
+               interface_cast<IMemoryHeap>(data.readStrongBinder());
+            registerBuffers(mem);
+        }
+#endif
 
         default:
             return BBinder::onTransact(code, data, reply, flags);
@@ -763,6 +880,30 @@ public:
         // so that the caller knows when to recycle the buffer.
         remote()->transact(RENDERER_RENDER, data, &reply);
     }
+
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers(){
+        int n = 0;
+        Vector< sp<IMemory> > mMem;
+        Parcel data, reply;
+        data.writeInterfaceToken(IOMXRenderer::getInterfaceDescriptor());
+
+        status_t err = remote()->transact(GET_BUFFERS, data, &reply);
+        n = reply.readInt32();
+        for (int i=0;i < n; i++) {
+            sp<IMemory> mem = interface_cast<IMemory>(reply.readStrongBinder());
+            mMem.add(mem);
+        }
+        return mMem;
+    }
+
+    virtual bool setCallback(release_rendered_buffer_callback cb, void *cookie) {return false;}
+
+    virtual void set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling) {}
+    virtual void resizeRenderer(void* resize_params) {}
+    virtual void requestRendererClone(bool enable) {}
+#endif
+
 };
 
 IMPLEMENT_META_INTERFACE(OMXRenderer, "android.hardware.IOMXRenderer");
@@ -781,6 +922,20 @@ status_t BnOMXRenderer::onTransact(
             return NO_ERROR;
         }
 
+#ifdef OMAP_ENHANCEMENT
+        case GET_BUFFERS:
+        {
+            LOGV("<<<<< onTransact GET_BUFFERS");
+            CHECK_INTERFACE(IOMXRenderer, data, reply);
+            Vector< sp<IMemory> > mMem = getBuffers();
+            const size_t N = mMem.size();
+            reply->writeInt32(N);
+            for (size_t i=0; i<N; i++) {
+                reply->writeStrongBinder(mMem[i]->asBinder());
+            }
+            return NO_ERROR;
+        }
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cpp
index 3869389..e6bb1b5 100644
--- a/media/libmedia/MediaProfiles.cpp
+++ b/media/libmedia/MediaProfiles.cpp
@@ -52,6 +52,10 @@ const MediaProfiles::NameToTagMap MediaProfiles::sFileFormatMap[] = {
 
 const MediaProfiles::NameToTagMap MediaProfiles::sVideoDecoderNameMap[] = {
     {"wmv", VIDEO_DECODER_WMV}
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    , {"vp6", VIDEO_DECODER_VP6}
+    , {"vp7", VIDEO_DECODER_VP7}
+#endif
 };
 
 const MediaProfiles::NameToTagMap MediaProfiles::sAudioDecoderNameMap[] = {
@@ -60,7 +64,9 @@ const MediaProfiles::NameToTagMap MediaProfiles::sAudioDecoderNameMap[] = {
 
 const MediaProfiles::NameToTagMap MediaProfiles::sCamcorderQualityNameMap[] = {
     {"high", CAMCORDER_QUALITY_HIGH},
-    {"low",  CAMCORDER_QUALITY_LOW}
+    {"low",  CAMCORDER_QUALITY_LOW},
+    {"hd",   CAMCORDER_QUALITY_HD},
+    {"wide", CAMCORDER_QUALITY_WIDE}
 };
 
 /*static*/ void
diff --git a/media/libmedia/MediaScanner.cpp b/media/libmedia/MediaScanner.cpp
index 6f581d3..34f5d93 100644
--- a/media/libmedia/MediaScanner.cpp
+++ b/media/libmedia/MediaScanner.cpp
@@ -127,12 +127,21 @@ status_t MediaScanner::doProcessDirectory(
 
     while ((entry = readdir(dir))) {
         const char* name = entry->d_name;
+        int nameLength = strlen(name);
 
         // ignore "." and ".."
         if (name[0] == '.' && (name[1] == 0 || (name[1] == '.' && name[2] == 0))) {
             continue;
         }
 
+        /* also keep space for '/' in case it's a directory */
+        if (nameLength + 1 > pathRemaining) {
+            // path too long!
+            continue;
+        }
+
+        strcpy(fileSpot, name);
+
         int type = entry->d_type;
         if (type == DT_UNKNOWN) {
             // If the type is unknown, stat() the file instead.
@@ -149,37 +158,26 @@ status_t MediaScanner::doProcessDirectory(
                 LOGD("stat() failed for %s: %s", path, strerror(errno) );
             }
         }
-        if (type == DT_REG || type == DT_DIR) {
-            int nameLength = strlen(name);
-            bool isDirectory = (type == DT_DIR);
-
-            if (nameLength > pathRemaining || (isDirectory && nameLength + 1 > pathRemaining)) {
-                // path too long!
+        if (type == DT_DIR) {
+            // ignore directories with a name that starts with '.'
+            // for example, the Mac ".Trashes" directory
+            if (name[0] == '.') continue;
+
+            strcat(fileSpot, "/");
+            int err = doProcessDirectory(path, pathRemaining - nameLength - 1, extensions, client, exceptionCheck, exceptionEnv);
+            if (err) {
+                // pass exceptions up - ignore other errors
+                if (exceptionCheck && exceptionCheck(exceptionEnv)) goto failure;
+                LOGE("Error processing '%s' - skipping\n", path);
                 continue;
             }
-
-            strcpy(fileSpot, name);
-            if (isDirectory) {
-                // ignore directories with a name that starts with '.'
-                // for example, the Mac ".Trashes" directory
-                if (name[0] == '.') continue;
-
-                strcat(fileSpot, "/");
-                int err = doProcessDirectory(path, pathRemaining - nameLength - 1, extensions, client, exceptionCheck, exceptionEnv);
-                if (err) {
-                    // pass exceptions up - ignore other errors
-                    if (exceptionCheck && exceptionCheck(exceptionEnv)) goto failure;
-                    LOGE("Error processing '%s' - skipping\n", path);
-                    continue;
-                }
-            } else if (fileMatchesExtension(path, extensions)) {
-                struct stat statbuf;
-                stat(path, &statbuf);
-                if (statbuf.st_size > 0) {
-                    client.scanFile(path, statbuf.st_mtime, statbuf.st_size);
-                }
-                if (exceptionCheck && exceptionCheck(exceptionEnv)) goto failure;
+        } else if (type == DT_REG && fileMatchesExtension(path, extensions)) {
+            struct stat statbuf;
+            stat(path, &statbuf);
+            if (statbuf.st_size > 0) {
+                client.scanFile(path, statbuf.st_mtime, statbuf.st_size);
             }
+            if (exceptionCheck && exceptionCheck(exceptionEnv)) goto failure;
         }
     }
 
diff --git a/media/libmedia/MediaScannerClient.cpp b/media/libmedia/MediaScannerClient.cpp
index bd3596e..e54db20 100644
--- a/media/libmedia/MediaScannerClient.cpp
+++ b/media/libmedia/MediaScannerClient.cpp
@@ -200,20 +200,39 @@ void MediaScannerClient::endFile()
 {
     if (mLocaleEncoding != kEncodingNone) {
         int size = mNames->size();
-        uint32_t encoding = kEncodingAll;
-
-        // compute a bit mask containing all possible encodings
-        for (int i = 0; i < mNames->size(); i++)
-            encoding &= possibleEncodings(mValues->getEntry(i));
+        uint32_t tmpEnc;
+        uint32_t encodings = kEncodingAll;
+
+        // guess proper encoding for non-ASCII values
+        int i = 0;
+        while (mNames->getEntry(i) != NULL) {
+            tmpEnc = possibleEncodings(mValues->getEntry(i));
+
+            if (mLocaleEncoding == kEncodingEUCKR && tmpEnc == kEncodingNone) {
+                // there are some Korean mp3s which use EUC-KR and utf-8 together in their tag
+                // this case means the value's encoding is utf-8. so, don't count them
+                if (!handleStringTag(mNames->getEntry(i), mValues->getEntry(i)))
+                    break;
+                mNames->erase(i);
+                mValues->erase(i);
+            } else {
+                // to find more accurate encoding,
+                // compute a bit mask containing all possible encodings
+                encodings &= tmpEnc;
+                i += 1;
+            }
+        }
 
-        // if the locale encoding matches, then assume we have a native encoding.
-        if (encoding & mLocaleEncoding)
-            convertValues(mLocaleEncoding);
+        if (mNames->size() > 0) {
+            // if the locale encoding matches, then assume we have a native encoding
+            if (encodings & mLocaleEncoding)
+                convertValues(mLocaleEncoding);
 
-        // finally, push all name/value pairs to the client
-        for (int i = 0; i < mNames->size(); i++) {
-            if (!handleStringTag(mNames->getEntry(i), mValues->getEntry(i)))
-                break;
+            // finally, push all name/value pairs to the client
+            for (int i = 0; i < mNames->size(); i++) {
+                if (!handleStringTag(mNames->getEntry(i), mValues->getEntry(i)))
+                    break;
+            }
         }
     }
     // else addStringTag() has done all the work so we have nothing to do
diff --git a/media/libmedia/OverlayRenderer.cpp b/media/libmedia/OverlayRenderer.cpp
new file mode 100644
index 0000000..bfe7b4c
--- /dev/null
+++ b/media/libmedia/OverlayRenderer.cpp
@@ -0,0 +1,608 @@
+/*
+ * Copyright (C) Texas Instruments - http://www.ti.com/
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "OverlayRenderer"
+#include <media/OverlayRenderer.h>
+
+#define ARMPAGESIZE 4096
+#define BOOL_STR(val)  ( (val) ? "TRUE" : "FALSE")
+
+#define LOG_FUNCTION_NAME_ENTRY    LOGV(" ###### Calling %s() Line %d PID %d ++ ######",  __FUNCTION__, __LINE__, getpid());
+#define LOG_FUNCTION_NAME_EXIT    LOGV(" ###### Calling %s() -- ######",  __FUNCTION__);
+
+//#define __DUMP_TO_FILE__
+#ifdef __DUMP_TO_FILE__
+#define NUM_BUFFERS_TO_DUMP 46
+#define FIRST_FRAME_INDEX 23
+FILE *pOutFile;
+#endif
+
+using namespace android;
+
+namespace android{
+
+/*
+  * Test is a friend class of Surface Control, and hence has access
+  * getISurface() method.
+  * TODO: The test class is 'added' by TI as a friend. Need to add
+  * TIFlashRenderer as a 'friend' to get the ISurface.
+  */
+class Test {
+        public:
+            static const sp<ISurface>& getISurface(const sp<SurfaceControl>& s) {
+                return s->getISurface();
+            }
+    };
+
+#ifdef __DUMP_TO_FILE__
+
+void dumpBufferToFile(void* pSrc, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t s)
+{
+    //LOGD("framenumber = %u, pSrc = %p, x = %u, y = %u, w = %u, h = %u, s = %u", framenumber, pSrc, x, y, w, h, s);
+    /* Dumping only the Y component */
+    pSrc = pSrc + (y*s);
+    for (int i = 0; i < h; i++) {
+        fwrite(pSrc+x, 1, w, pOutFile);
+        fflush(pOutFile);
+        pSrc = pSrc + s;
+    }
+}
+
+#endif
+
+OverlayRenderer::OverlayRenderer()
+{
+    LOG_FUNCTION_NAME_ENTRY
+}
+
+OverlayRenderer::~OverlayRenderer()
+{
+    LOG_FUNCTION_NAME_ENTRY
+}
+
+int32_t OverlayRenderer::createOverlayRenderer(uint32_t bufferCount,
+                                int32_t displayWidth,
+                                int32_t displayHeight,
+                                uint32_t colorFormat,
+                                int32_t decodedWidth,
+                                int32_t decodedHeight,
+                                int infoType,
+                                void * info)
+{
+    LOG_FUNCTION_NAME_ENTRY
+
+    mBufferCount = bufferCount;
+    mDisplayWidth = displayWidth;
+    mDisplayHeight = displayHeight;
+    mColorFormat = colorFormat;
+    mDecodedWidth = decodedWidth;
+    mDecodedHeight = decodedHeight;
+    mInfoType = infoType;
+    //Keep in mind that info ptr is NOT passed across in BpOverlayRenderer
+
+    mInitCheck = NO_INIT;
+
+    /* Create required surfaces and overlay objects */
+    if(OK != createSurface()){
+        LOGE("Failed to create Surface");
+        goto EXIT;
+    }
+
+    /* creating buffers */
+    if(OK != createBuffers()) {
+        LOGE("Failed to create Buffers");
+        goto EXIT;
+    }
+
+    mInitCheck = OK;
+
+#ifdef __DUMP_TO_FILE__
+
+    char filename[100];
+    sprintf(filename, "/sdcard/framedump_%dx%d.yuv", mDisplayWidth, mDisplayHeight);
+    pOutFile = fopen(filename, "wb");
+    if(pOutFile == NULL)
+        LOGE("\n!!!!!!!!!!!!!!!!Error opening file %s !!!!!!!!!!!!!!!!!!!!", filename);
+
+#endif
+
+EXIT:
+
+    return mInitCheck;
+}
+
+void OverlayRenderer::releaseMe()
+{
+    //delete this;
+
+    LOG_FUNCTION_NAME_ENTRY
+
+    if ( NULL != mOverlay.get() ) {
+        mOverlay->destroy();
+        mOverlay.clear();
+    }
+
+    //if ( NULL != mOverlayRef.get() )
+    {
+        //mOverlayRef = 0;
+    }
+
+    if ( NULL != mISurface.get() ) {
+        mISurface.clear();
+    }
+
+    if ( NULL != mSurfaceControl.get() ) {
+        mSurfaceControl->clear();
+        mSurfaceControl.clear();
+    }
+
+    if ( NULL != mSurfaceClient.get() ) {
+        mSurfaceClient->dispose();
+        mSurfaceClient.clear();
+    }
+
+
+    /* TODO: make sure all other resources are released as well */
+
+#ifdef __DUMP_TO_FILE__
+        if (pOutFile) fclose(pOutFile);
+#endif
+
+}
+
+sp<IMemory> OverlayRenderer::getBuffer(uint32_t index)
+{
+    if (index >= mBufferCount) index = 0;
+    return mOverlayAddresses[index];
+}
+
+int32_t OverlayRenderer::createBuffers()
+{
+    LOG_FUNCTION_NAME_ENTRY
+
+    mapping_data_t *data;
+    sp<IMemory> mem;
+
+    /* check if the overlay created required number of buffers for decoder */
+    if (mBufferCount != (uint32_t)mOverlay->getBufferCount() ) {
+        mOverlay->setParameter(OVERLAY_NUM_BUFFERS, mBufferCount);
+        mOverlay->resizeInput(mDecodedWidth, mDecodedHeight);
+    }
+
+    /* TODO: Optimal buffer count now 2. Confirm?? */
+    mOverlay->setParameter(OPTIMAL_QBUF_CNT, 4);
+
+    for (size_t bCount = 0; bCount < mBufferCount; ++bCount) {
+        data = (mapping_data_t *)mOverlay->getBufferAddress((void *)bCount);
+        CHECK(data != NULL);
+
+        mVideoHeaps[bCount] = new MemoryHeapBase(data->fd,data->length, 0, data->offset);
+        mem = new MemoryBase(mVideoHeaps[bCount], 0, data->length);
+        CHECK(mem.get() != NULL);
+
+        LOGV("data->fd %d, data->length =%d, data->offset =%x, mem->pointer[%d] = %p", data->fd,data->length, data->offset, bCount, mem->pointer());
+
+        mOverlayAddresses.push(mem);
+    }
+
+    return OK;
+}
+
+
+int32_t OverlayRenderer::createSurface()
+{
+    LOG_FUNCTION_NAME_ENTRY
+
+    if(mOverlay.get() == NULL){
+
+        mSurfaceClient = new SurfaceComposerClient();
+
+        if ( NULL == mSurfaceClient.get() ) {
+            LOGE("Unable to establish connection to Surface Composer \n");
+            return UNKNOWN_ERROR;
+        }
+
+        mSurfaceControl = mSurfaceClient->createSurface(getpid(), 0, mDecodedWidth, mDecodedHeight,
+                           PIXEL_FORMAT_UNKNOWN, ISurfaceComposer::ePushBuffers);
+
+        if ( NULL == mSurfaceControl.get() ) {
+            LOGE("Unable to create Overlay control surface\n");
+            return UNKNOWN_ERROR;
+        }
+
+        mISurface = Test::getISurface(mSurfaceControl);
+        if ( NULL == mISurface.get() ) {
+            LOGE("Unable to get overlay ISurface interface\n");
+            return UNKNOWN_ERROR;
+        }
+
+        sp<OverlayRef> ref = mISurface->createOverlay(mDecodedWidth, mDecodedHeight, mColorFormat, 0);
+        if (ref.get() == NULL) {
+            LOGE("Unable to create Overlay Reference\n");
+            return UNKNOWN_ERROR;
+        }
+
+        //Create Overlay Object
+        mOverlay = new Overlay(ref);
+
+        if(mOverlay.get() == NULL) {
+            LOGE("Unable to create Overlay Object\n");
+            return UNKNOWN_ERROR;
+        }
+
+        /* Configuring the surface */
+        mSurfaceClient->openTransaction();
+        mSurfaceControl->setLayer(100000);
+        //mSurfaceControl->setLayer(0x40000000);set in BootAnimation.cpp
+        mSurfaceClient->closeTransaction();
+
+    }
+    return OK;
+
+}
+
+int32_t OverlayRenderer::dequeueBuffer(uint32_t *index)
+{
+    return mOverlay->dequeueBuffer((overlay_buffer_t*)index);
+}
+
+int32_t OverlayRenderer::queueBuffer(uint32_t index)
+{
+
+#ifdef __DUMP_TO_FILE__
+    static int displaycount = 0;
+    static int lastframetodump = FIRST_FRAME_INDEX+NUM_BUFFERS_TO_DUMP;
+
+    if ((displaycount >= FIRST_FRAME_INDEX)  && (displaycount < lastframetodump)){
+        //dumpBufferToFile(mediaBuf->data(), mCropX, mCropY, mDisplayWidth, mDisplayHeight, 4096);
+    }
+    displaycount++;
+
+#endif
+
+    return mOverlay->queueBuffer((void *)index);
+}
+
+int32_t OverlayRenderer::setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h)
+{
+    return mOverlay->setCrop(x, y, w, h);
+}
+
+int32_t OverlayRenderer::setPosition(int32_t x, int32_t y)
+{
+    win_x = x;
+    win_y = y;
+    mSurfaceClient->openTransaction();
+    mSurfaceControl->setPosition(win_x, win_y);
+    mSurfaceClient->closeTransaction();
+
+    return OK;
+}
+
+int32_t OverlayRenderer::setSize(uint32_t w, uint32_t h)
+{
+    mSurfaceClient->openTransaction();
+    mSurfaceControl->setSize(w, h);
+    mSurfaceClient->closeTransaction();
+
+    /* I am changing Position too bcos just a change in size is not recognized by surface flinger. */
+
+    /* In LayerBase::setPosition(), the sequence no. is incremented. But the same is not done
+        for LayerBase::setSize(). It is this change in sequence no. which triggers
+        LayerBuffer::OverlaySource::onTransaction() which triggers
+        LayerBuffer::OverlaySource::onVisibilityResolved() which triggers
+        overlay_dev->setPosition()
+    */
+
+    mSurfaceClient->openTransaction();
+    mSurfaceControl->setPosition(1, 1);
+    mSurfaceClient->closeTransaction();
+
+    mSurfaceClient->openTransaction();
+    mSurfaceControl->setPosition(win_x, win_y);
+    mSurfaceClient->closeTransaction();
+
+    return OK;
+}
+
+int32_t OverlayRenderer::setOrientation(int32_t orientation, uint32_t flags)
+{
+    mSurfaceClient->openTransaction();
+    switch(orientation)
+        {
+        case 0:
+            mSurfaceClient->setOrientation(0,ISurfaceComposer::eOrientationDefault,0);
+            break;
+        case 90:
+            mSurfaceClient->setOrientation(0,ISurfaceComposer::eOrientation90,0);
+            break;
+        case 180:
+            mSurfaceClient->setOrientation(0,ISurfaceComposer::eOrientation180,0);
+            break;
+        case 270:
+            mSurfaceClient->setOrientation(0,ISurfaceComposer::eOrientation270,0);
+            break;
+        default:
+            LOGD("Rotation not applied. Illegal Value");
+        };
+
+    mSurfaceClient->closeTransaction();
+    return OK;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+enum {
+    CREATE_OVERLAY_RENDERER,
+    RELEASE,
+    GET_BUFFER_COUNT,
+    GET_BUFFER,
+    DEQUEUE_BUFFER,
+    QUEUE_BUFFER,
+    SET_ORIENTATION,
+    SET_POSITION,
+    SET_SIZE,
+    SET_CROP
+};
+
+
+
+class BpOverlayRenderer : public BpInterface<IOverlayRenderer> {
+public:
+    BpOverlayRenderer(const sp<IBinder> &impl)
+        : BpInterface<IOverlayRenderer>(impl) {
+    }
+
+    virtual int32_t createOverlayRenderer(
+        uint32_t bufferCount, int32_t displayWidth,  int32_t displayHeight,
+        uint32_t colorFormat, int32_t decodedWidth, int32_t decodedHeight,
+        int infoType, void * info)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        data.writeInt32(bufferCount);
+        data.writeInt32(displayWidth);
+        data.writeInt32(displayHeight);
+        data.writeInt32(colorFormat);
+        data.writeInt32(decodedWidth);
+        data.writeInt32(decodedHeight);
+        data.writeInt32(infoType);
+        remote()->transact(CREATE_OVERLAY_RENDERER, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual void releaseMe()
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        remote()->transact(RELEASE, data, &reply);
+    }
+
+    virtual uint32_t getBufferCount()
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        remote()->transact(GET_BUFFER_COUNT, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual sp<IMemory> getBuffer(uint32_t index)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        data.writeInt32(index);
+        remote()->transact(GET_BUFFER, data, &reply);
+        sp<IMemory> params = interface_cast<IMemory>(reply.readStrongBinder());
+        return params;
+    }
+
+    virtual int32_t dequeueBuffer(uint32_t *index)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        remote()->transact(DEQUEUE_BUFFER, data, &reply);
+        int32_t err = reply.readInt32();
+        *index = reply.readInt32();
+        return err;
+    }
+
+    virtual int32_t queueBuffer(uint32_t index)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        data.writeInt32(index);
+        remote()->transact(QUEUE_BUFFER, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual int32_t setOrientation(int32_t orientation, uint32_t flags)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        data.writeInt32(orientation);
+        data.writeInt32(flags);
+        remote()->transact(SET_ORIENTATION, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual int32_t setPosition(int32_t x, int32_t y)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        data.writeInt32(x);
+        data.writeInt32(y);
+        remote()->transact(SET_POSITION, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual int32_t setSize(uint32_t w, uint32_t h)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        data.writeInt32(w);
+        data.writeInt32(h);
+        remote()->transact(SET_SIZE, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual int32_t setCrop(uint32_t x, uint32_t y, uint32_t w, uint32_t h)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IOverlayRenderer::getInterfaceDescriptor());
+        data.writeInt32(x);
+        data.writeInt32(y);
+        data.writeInt32(w);
+        data.writeInt32(h);
+        remote()->transact(SET_CROP, data, &reply);
+        return reply.readInt32();
+    }
+
+};
+
+IMPLEMENT_META_INTERFACE(OverlayRenderer, "android.media.IOverlayRenderer");
+
+status_t BnOverlayRenderer::onTransact(
+    uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
+
+    switch (code) {
+
+        case CREATE_OVERLAY_RENDERER:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+            uint32_t bufferCount = data.readInt32();
+            int32_t displayWidth = data.readInt32();
+            int32_t displayHeight = data.readInt32();
+            uint32_t colorFormat = data.readInt32();
+            int32_t decodedWidth = data.readInt32();
+            int32_t decodedHeight = data.readInt32();
+            int infoType = data.readInt32();
+            void *info;
+            reply->writeInt32(createOverlayRenderer(bufferCount, displayWidth, displayHeight, colorFormat, decodedWidth, decodedHeight, infoType, info));
+
+            return NO_ERROR;
+        }
+
+        case RELEASE:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+            releaseMe();
+            return NO_ERROR;
+        }
+
+        case GET_BUFFER_COUNT:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            uint32_t count = getBufferCount();
+            reply->writeInt32(count);
+
+            return NO_ERROR;
+        }
+
+        case GET_BUFFER:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            int32_t index = data.readInt32();
+
+            sp<IMemory> params  = getBuffer(index);
+            reply->writeStrongBinder(params->asBinder());
+
+            return NO_ERROR;
+        }
+
+        case DEQUEUE_BUFFER:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            uint32_t index;
+
+            int32_t err = dequeueBuffer(&index);
+            reply->writeInt32(err);
+            reply->writeInt32(index);
+            return NO_ERROR;
+        }
+
+        case QUEUE_BUFFER:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            int32_t index = data.readInt32();
+
+            reply->writeInt32(queueBuffer(index));
+            return NO_ERROR;
+        }
+
+        case SET_ORIENTATION:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            uint32_t orientation = data.readInt32();
+            uint32_t flags = data.readInt32();
+
+            reply->writeInt32(setOrientation(orientation, flags));
+            return NO_ERROR;
+        }
+
+        case SET_POSITION:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            uint32_t x = data.readInt32();
+            uint32_t y = data.readInt32();
+
+            reply->writeInt32(setPosition(x, y));
+            return NO_ERROR;
+        }
+
+        case SET_SIZE:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            uint32_t w = data.readInt32();
+            uint32_t h = data.readInt32();
+
+            reply->writeInt32(setSize(w, h));
+            return NO_ERROR;
+        }
+
+        case SET_CROP:
+        {
+            CHECK_INTERFACE(IOverlayRenderer, data, reply);
+
+            uint32_t x = data.readInt32();
+            uint32_t y = data.readInt32();
+            uint32_t w = data.readInt32();
+            uint32_t h = data.readInt32();
+
+            reply->writeInt32(setCrop(x, y, w, h));
+            return NO_ERROR;
+        }
+
+        default:
+            return BBinder::onTransact(code, data, reply, flags);
+    }
+}
+
+
+
+}
+
diff --git a/media/libmedia/mediaplayer.cpp b/media/libmedia/mediaplayer.cpp
index cc41e66..4527d6f 100644
--- a/media/libmedia/mediaplayer.cpp
+++ b/media/libmedia/mediaplayer.cpp
@@ -106,6 +106,9 @@ status_t MediaPlayer::setDataSource(const sp<IMediaPlayer>& player)
     { // scope for the lock
         Mutex::Autolock _l(mLock);
 
+        if (mCurrentState & MEDIA_PLAYER_PLAYBACK_COMPLETE)
+            return UNKNOWN_ERROR;
+
         if ( !( (mCurrentState & MEDIA_PLAYER_IDLE) ||
                 (mCurrentState == MEDIA_PLAYER_STATE_ERROR ) ) ) {
             LOGE("setDataSource called in state %d", mCurrentState);
@@ -174,12 +177,16 @@ status_t MediaPlayer::invoke(const Parcel& request, Parcel *reply)
 
 status_t MediaPlayer::suspend() {
     Mutex::Autolock _l(mLock);
-    return mPlayer->suspend();
+    status_t rv = mPlayer->suspend();
+    mCurrentState = (rv == OK ? MEDIA_PLAYER_PAUSED : MEDIA_PLAYER_STATE_ERROR);
+    return rv;
 }
 
 status_t MediaPlayer::resume() {
     Mutex::Autolock _l(mLock);
-    return mPlayer->resume();
+    status_t rv = mPlayer->resume();
+    mCurrentState = (rv == OK ? MEDIA_PLAYER_STARTED : MEDIA_PLAYER_STATE_ERROR);
+    return rv;
 }
 
 status_t MediaPlayer::setMetadataFilter(const Parcel& filter)
@@ -216,6 +223,9 @@ status_t MediaPlayer::setVideoSurface(const sp<Surface>& surface)
 // must call with lock held
 status_t MediaPlayer::prepareAsync_l()
 {
+    if (mCurrentState & MEDIA_PLAYER_PLAYBACK_COMPLETE)
+        return UNKNOWN_ERROR;
+
     if ( (mPlayer != 0) && ( mCurrentState & ( MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) {
         mPlayer->setAudioStreamType(mStreamType);
         mCurrentState = MEDIA_PLAYER_PREPARING;
@@ -336,6 +346,8 @@ bool MediaPlayer::isPlaying()
             LOGE("internal/external state mismatch corrected");
             mCurrentState = MEDIA_PLAYER_PAUSED;
         }
+        if ((mCurrentState & MEDIA_PLAYER_PAUSED) && temp)
+            mCurrentState = MEDIA_PLAYER_STARTED;
         return temp;
     }
     LOGV("isPlaying: no active player");
@@ -504,6 +516,18 @@ status_t MediaPlayer::setVolume(float leftVolume, float rightVolume)
     return OK;
 }
 
+#ifdef OMAP_ENHANCEMENT
+status_t MediaPlayer::requestVideoCloneMode(bool enable)
+{
+    Mutex::Autolock _l(mLock);
+    if (mPlayer != NULL) {
+        return mPlayer->requestVideoCloneMode(enable);
+    }
+    return OK;
+}
+
+#endif
+
 status_t MediaPlayer::setAudioSessionId(int sessionId)
 {
     LOGV("MediaPlayer::setAudioSessionId(%d)", sessionId);
@@ -603,6 +627,10 @@ void MediaPlayer::notify(int msg, int ext1, int ext2)
         // ext1: Media framework error code.
         // ext2: Implementation dependant error code.
         LOGE("error (%d, %d)", ext1, ext2);
+        if ( ext1 == MEDIA_ERROR_SERVER_DIED ) {
+            LOGE("Mediaserver died in %d state",mCurrentState);
+            mAudioSessionId = AudioSystem::newAudioSessionId();
+        }
         mCurrentState = MEDIA_PLAYER_STATE_ERROR;
         if (mPrepareSync)
         {
diff --git a/media/libmedia/mediarecorder.cpp b/media/libmedia/mediarecorder.cpp
index e20e3ba..d1c805b 100644
--- a/media/libmedia/mediarecorder.cpp
+++ b/media/libmedia/mediarecorder.cpp
@@ -385,6 +385,28 @@ status_t MediaRecorder::setParameters(const String8& params) {
     return ret;
 }
 
+status_t MediaRecorder::setCameraParameters(const String8& params) {
+    LOGV("setCameraParameters(%s)", params.string());
+    if(mMediaRecorder == NULL) {
+        LOGE("media recorder is not initialized yet");
+        return INVALID_OPERATION;
+    }
+
+    bool isInvalidState = (mCurrentState &
+                            MEDIA_RECORDER_ERROR);
+    if (isInvalidState) {
+        LOGE("setCameraParameters is called in an invalid state: %d", mCurrentState);
+        return INVALID_OPERATION;
+    }
+
+    status_t ret = mMediaRecorder->setCameraParameters(params);
+    if (OK != ret) {
+        LOGE("setCameraParameters(%s) failed: %d", params.string(), ret);
+    }
+
+    return ret;
+}
+
 status_t MediaRecorder::prepare()
 {
     LOGV("prepare");
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 55846be..1885851 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -11,6 +11,7 @@ LOCAL_SRC_FILES:=               \
     MediaPlayerService.cpp      \
     MetadataRetrieverClient.cpp \
     TestPlayerStub.cpp          \
+    FLACPlayer.cpp              \
     MidiMetadataRetriever.cpp   \
     MidiFile.cpp                \
     StagefrightPlayer.cpp       \
@@ -24,6 +25,7 @@ LOCAL_SHARED_LIBRARIES :=     		\
 	libcutils             			\
 	libutils              			\
 	libbinder             			\
+        libFLAC                                 \
 	libvorbisidec         			\
 	libsonivox            			\
 	libmedia              			\
@@ -46,6 +48,11 @@ else
 LOCAL_CFLAGS += -DNO_OPENCORE
 endif
 
+# CFLAGS for StagefrightRecorder includes
+ifeq ($(TARGET_USE_OMAP_COMPAT),true)
+	LOCAL_CFLAGS += -DOMAP_COMPAT
+endif
+
 ifneq ($(TARGET_SIMULATOR),true)
 LOCAL_SHARED_LIBRARIES += libdl
 endif
@@ -56,8 +63,27 @@ LOCAL_C_INCLUDES :=                                                 \
 	$(TOP)/frameworks/base/include/media/stagefright/openmax \
 	$(TOP)/frameworks/base/media/libstagefright/include             \
 	$(TOP)/frameworks/base/media/libstagefright/rtsp                \
+        $(TOP)/external/flac/include                                    \
         $(TOP)/external/tremolo/Tremolo
 
+ifeq ($(strip $(BOARD_USES_HW_MEDIARECORDER)),true)
+    LOCAL_SHARED_LIBRARIES += libhwmediarecorder
+    LOCAL_CFLAGS += -DUSE_BOARD_MEDIARECORDER
+endif
+
+ifeq ($(strip $(BOARD_USES_HW_MEDIAPLUGINS)),true)
+    LOCAL_SHARED_LIBRARIES += libhwmediaplugin
+    LOCAL_CFLAGS += -DUSE_BOARD_MEDIAPLUGIN
+endif
+
+ifeq ($(OMAP_ENHANCEMENT),true)
+
+LOCAL_C_INCLUDES += $(TOP)/hardware/ti/omap3/liboverlay
+
+LOCAL_SHARED_LIBRARIES += libui
+
+endif
+
 LOCAL_MODULE:= libmediaplayerservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libmediaplayerservice/FLACPlayer.cpp b/media/libmediaplayerservice/FLACPlayer.cpp
new file mode 100644
index 0000000..59a4645
--- /dev/null
+++ b/media/libmediaplayerservice/FLACPlayer.cpp
@@ -0,0 +1,578 @@
+/*
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "FLACPlayer"
+#include "utils/Log.h"
+
+#include <stdio.h>
+#include <assert.h>
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sched.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+
+#include "FLACPlayer.h"
+
+#ifdef HAVE_GETTID
+static pid_t myTid() { return gettid(); }
+#else
+static pid_t myTid() { return getpid(); }
+#endif
+
+// ----------------------------------------------------------------------------
+
+namespace android {
+
+// ----------------------------------------------------------------------------
+
+// TODO: Determine appropriate return codes
+static status_t ERROR_NOT_OPEN = -1;
+static status_t ERROR_OPEN_FAILED = -2;
+static status_t ERROR_ALLOCATE_FAILED = -4;
+static status_t ERROR_NOT_SUPPORTED = -8;
+static status_t ERROR_NOT_READY = -16;
+static status_t STATE_INIT = 0;
+static status_t STATE_ERROR = 1;
+static status_t STATE_OPEN = 2;
+
+
+FLACPlayer::FLACPlayer() :
+    mTotalSamples(-1), mCurrentSample(0), mBytesPerSample(-1),
+    mChannels(-1), mSampleRate(-1), mAudioBuffer(NULL),
+    mAudioBufferSize(0), mAudioBufferFilled(0),
+    mState(STATE_ERROR), mStreamType(AudioSystem::MUSIC),
+    mLoop(false), mAndroidLoop(false), mExit(false), mPaused(false),
+    mRender(false), mRenderTid(-1)
+{
+    LOGV("constructor");
+}
+
+void FLACPlayer::onFirstRef()
+{
+    LOGV("onFirstRef");
+    // create playback thread
+    Mutex::Autolock l(mMutex);
+    createThreadEtc(renderThread, this, "FLAC decoder", ANDROID_PRIORITY_AUDIO);
+    mCondition.wait(mMutex);
+    if (mRenderTid > 0) {
+        LOGV("render thread(%d) started", mRenderTid);
+        mState = STATE_INIT;
+    }
+}
+
+status_t FLACPlayer::initCheck()
+{
+    if (mState != STATE_ERROR) return NO_ERROR;
+    return ERROR_NOT_READY;
+}
+
+FLACPlayer::~FLACPlayer() {
+    LOGV("FLACPlayer destructor");
+    release();
+}
+
+status_t FLACPlayer::setDataSource(
+        const char *uri, const KeyedVector<String8, String8> *headers) {
+    return setdatasource(uri, -1, 0, 0x7ffffffffffffffLL); // intentionally less than LONG_MAX
+}
+
+status_t FLACPlayer::setDataSource(int fd, int64_t offset, int64_t length)
+{
+    return setdatasource(NULL, fd, offset, length);
+}
+
+status_t FLACPlayer::setdatasource(const char *path, int fd, int64_t offset, int64_t length)
+{
+    LOGV("setDataSource url=%s, fd=%d", path, fd);
+
+    // file still open?
+    Mutex::Autolock l(mMutex);
+    if (mState == STATE_OPEN) {
+        reset_nosync();
+    }
+
+    // open file and set paused state
+    if (path) {
+        mFile = fopen(path, "r");
+    } else {
+        mFile = fdopen(dup(fd), "r");
+    }
+    if (mFile == NULL) {
+        return ERROR_OPEN_FAILED;
+    }
+
+    struct stat sb;
+    int ret;
+    if (path) {
+        ret = stat(path, &sb);
+    } else {
+        ret = fstat(fd, &sb);
+    }
+    if (ret != 0) {
+        mState = STATE_ERROR;
+        fclose(mFile);
+        return ERROR_OPEN_FAILED;
+    }
+
+    fseek(mFile, offset, SEEK_SET);
+
+    mDecoder = FLAC__stream_decoder_new();
+    if (mDecoder == NULL) {
+        LOGE("failed to allocate decoder\n");
+        mState = STATE_ERROR;
+        fclose(mFile);
+        return ERROR_OPEN_FAILED;
+    }
+
+    FLAC__stream_decoder_set_md5_checking(mDecoder, false);
+    FLAC__stream_decoder_set_metadata_ignore_all(mDecoder);
+    FLAC__stream_decoder_set_metadata_respond(mDecoder, FLAC__METADATA_TYPE_STREAMINFO);
+    FLAC__stream_decoder_set_metadata_respond(mDecoder, FLAC__METADATA_TYPE_VORBIS_COMMENT);
+
+    FLAC__StreamDecoderInitStatus init_status;
+    init_status = FLAC__stream_decoder_init_FILE(mDecoder, mFile, vp_write, vp_metadata, vp_error, this);
+    if (init_status != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
+        LOGE("FLAC__stream_decoder_init_FILE failed: [%d]\n", (int)init_status);
+        mState = STATE_ERROR;
+        fclose(mFile);
+        return ERROR_OPEN_FAILED;
+    }
+
+    if (!FLAC__stream_decoder_process_until_end_of_metadata(mDecoder)) {
+        LOGE("FLAC__stream_decoder_process_until_end_of_metadata failed\n");
+        mState = STATE_ERROR;
+        fclose(mFile);
+        return ERROR_OPEN_FAILED;
+    }
+
+    mState = STATE_OPEN;
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::prepare()
+{
+    LOGV("prepare");
+    if (mState != STATE_OPEN ) {
+        return ERROR_NOT_OPEN;
+    }
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::prepareAsync() {
+    LOGV("prepareAsync");
+    // can't hold the lock here because of the callback
+    // it's safe because we don't change state
+    if (mState != STATE_OPEN) {
+        sendEvent(MEDIA_ERROR);
+        return NO_ERROR;
+    }
+    sendEvent(MEDIA_PREPARED);
+    return NO_ERROR;
+}
+
+void FLACPlayer::vp_metadata(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data) {
+    FLACPlayer *self = (FLACPlayer *)client_data;
+
+    if (metadata->type == FLAC__METADATA_TYPE_STREAMINFO) {
+        self->mTotalSamples = metadata->data.stream_info.total_samples;
+        self->mBytesPerSample = metadata->data.stream_info.bits_per_sample / 8;
+        self->mChannels = metadata->data.stream_info.channels;
+        self->mSampleRate = metadata->data.stream_info.sample_rate;
+
+        if (self->mBytesPerSample != 2) {
+            LOGE("Can only support 16 bits per sample; input is %d\n", self->mBytesPerSample * 8);
+            self->mState = STATE_ERROR;
+            return;
+        }
+
+        self->mLengthInMsec = self->mTotalSamples / self->mSampleRate * 1000 +
+                              self->mTotalSamples % self->mSampleRate / ( self->mSampleRate / 1000 );
+    } else if (metadata->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {
+        for (unsigned int i = 0; i < metadata->data.vorbis_comment.num_comments; i++) {
+            char *ptr = (char *)metadata->data.vorbis_comment.comments[i].entry;
+
+            // does the comment start with ANDROID_LOOP_TAG
+            if (strncmp(ptr, ANDROID_LOOP_TAG, strlen(ANDROID_LOOP_TAG)) == 0) {
+                // read the value of the tag
+                char *val = ptr + strlen(ANDROID_LOOP_TAG) + 1;
+                self->mAndroidLoop = (strncmp(val, "true", 4) == 0);
+            }
+
+            LOGV_IF(self->mAndroidLoop, "looped sound");
+        }
+    }
+}
+
+void FLACPlayer::vp_error(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data) {
+    LOGV("vp_error");
+    FLACPlayer *self = (FLACPlayer *)client_data;
+    self->sendEvent(MEDIA_ERROR);
+    self->mState = STATE_ERROR;
+}
+
+status_t FLACPlayer::start()
+{
+    LOGV("start\n");
+    Mutex::Autolock l(mMutex);
+    if (mState != STATE_OPEN) {
+        return ERROR_NOT_OPEN;
+    }
+
+    mPaused = false;
+    mRender = true;
+
+    // wake up render thread
+    LOGV("  wakeup render thread\n");
+    mCondition.signal();
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::stop()
+{
+    LOGV("stop\n");
+    Mutex::Autolock l(mMutex);
+    if (mState != STATE_OPEN) {
+        return ERROR_NOT_OPEN;
+    }
+    mPaused = true;
+    mRender = false;
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::seekTo(int msec)
+{
+    LOGV("seekTo %d\n", msec);
+    Mutex::Autolock l(mMutex);
+    if (mState != STATE_OPEN) {
+        return ERROR_NOT_OPEN;
+    }
+
+    FLAC__uint64 target_sample = mTotalSamples * msec / mLengthInMsec;
+
+    if (mTotalSamples > 0 && target_sample >= mTotalSamples && target_sample > 0)
+        target_sample = mTotalSamples - 1;
+
+    if (!FLAC__stream_decoder_seek_absolute(mDecoder, target_sample)) {
+        LOGE("FLAC__stream_decoder_seek_absolute failed\n");
+        if (FLAC__stream_decoder_get_state(mDecoder) == FLAC__STREAM_DECODER_SEEK_ERROR) {
+            FLAC__stream_decoder_flush(mDecoder);
+        }
+        return ERROR_NOT_SUPPORTED;
+    }
+
+    mCurrentSample = target_sample;
+
+    sendEvent(MEDIA_SEEK_COMPLETE);
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::pause()
+{
+    LOGV("pause\n");
+    Mutex::Autolock l(mMutex);
+    if (mState != STATE_OPEN) {
+        return ERROR_NOT_OPEN;
+    }
+    mPaused = true;
+    return NO_ERROR;
+}
+
+bool FLACPlayer::isPlaying()
+{
+    LOGV("isPlaying\n");
+    if (mState == STATE_OPEN) {
+        return mRender;
+    }
+    return false;
+}
+
+status_t FLACPlayer::getCurrentPosition(int* msec)
+{
+    LOGV("getCurrentPosition\n");
+    Mutex::Autolock l(mMutex);
+    if (mState != STATE_OPEN) {
+        LOGE("getCurrentPosition(): file not open");
+        return ERROR_NOT_OPEN;
+    }
+
+    *msec = (int)(mCurrentSample * 1000 / mSampleRate);
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::getDuration(int* duration)
+{
+    LOGV("getDuration\n");
+    if (mState != STATE_OPEN) {
+        return ERROR_NOT_OPEN;
+    }
+
+    *duration = mLengthInMsec;
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::release()
+{
+    LOGV("release\n");
+    Mutex::Autolock l(mMutex);
+    reset_nosync();
+
+    // TODO: timeout when thread won't exit
+    // wait for render thread to exit
+    if (mRenderTid > 0) {
+        mExit = true;
+        mCondition.signal();
+        mCondition.wait(mMutex);
+    }
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::reset()
+{
+    LOGV("reset\n");
+    Mutex::Autolock l(mMutex);
+    return reset_nosync();
+}
+
+// always call with lock held
+status_t FLACPlayer::reset_nosync()
+{
+    // close file
+    if (mFile != NULL) {
+        FLAC__stream_decoder_delete(mDecoder);
+        fclose(mFile);
+        mFile = NULL;
+    }
+    mState = STATE_ERROR;
+
+    mTotalSamples = -1;
+    mBytesPerSample = -1;
+    mChannels = -1;
+    mSampleRate = -1;
+    mLoop = false;
+    mAndroidLoop = false;
+    mPaused = false;
+    mRender = false;
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::setLooping(int loop)
+{
+    LOGV("setLooping\n");
+    Mutex::Autolock l(mMutex);
+    mLoop = (loop != 0);
+    return NO_ERROR;
+}
+
+status_t FLACPlayer::createOutputTrack() {
+    LOGV("Create AudioTrack object: rate=%ld, channels=%d\n",
+            mSampleRate, mChannels);
+    if (mAudioSink->open(mSampleRate, mChannels, AudioSystem::PCM_16_BIT, DEFAULT_AUDIOSINK_BUFFERCOUNT) != NO_ERROR) {
+        LOGE("mAudioSink open failed\n");
+        return ERROR_OPEN_FAILED;
+    }
+    return NO_ERROR;
+}
+
+FLAC__StreamDecoderWriteStatus FLACPlayer::vp_write(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data) {
+    FLACPlayer *self = (FLACPlayer *)client_data;
+
+    const uint32_t bytes_per_sample = self->mBytesPerSample;
+    const uint32_t incr = bytes_per_sample * self->mChannels;
+    const uint32_t wide_samples = frame->header.blocksize;
+    const uint32_t frame_size = incr * wide_samples;
+
+    self->mCurrentSample = frame->header.number.sample_number;
+
+    uint32_t sample, wide_sample, channel;
+
+    if (self->mAudioBufferSize < frame_size) {
+        if (self->mAudioBuffer != NULL) {
+            delete [] self->mAudioBuffer;
+        }
+        self->mAudioBuffer = new FLAC__int8[frame_size];
+        self->mAudioBufferSize = frame_size;
+    }
+
+    FLAC__int8 *s8buffer = self->mAudioBuffer;
+    FLAC__int16 *s16buffer = (FLAC__int16 *)s8buffer;
+
+    // Interleave channel data like PCM
+    if (self->mChannels == 2) {
+        for (sample = wide_sample = 0; wide_sample < wide_samples; wide_sample++) {
+            s16buffer[sample++] = (FLAC__int16)(buffer[0][wide_sample]);
+            s16buffer[sample++] = (FLAC__int16)(buffer[1][wide_sample]);
+        }
+    } else if (self->mChannels == 1) {
+        for (sample = wide_sample = 0; wide_sample < wide_samples; wide_sample++) {
+            s16buffer[sample++] = (FLAC__int16)(buffer[0][wide_sample]);
+        }
+    } else {
+        for (sample = wide_sample = 0; wide_sample < wide_samples; wide_sample++) {
+            for (channel = 0; channel < self->mChannels; channel++, sample++) {
+                s16buffer[sample] = (FLAC__int16)(buffer[channel][wide_sample]);
+            }
+        }
+    }
+    self->mAudioBufferFilled = frame_size;
+
+    return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
+}
+
+int FLACPlayer::renderThread(void* p) {
+    return ((FLACPlayer*)p)->render();
+}
+
+int FLACPlayer::render() {
+    int result = -1;
+    int temp;
+    int current_section = 0;
+    bool audioStarted = false;
+
+    LOGV("render\n");
+
+    // let main thread know we're ready
+    {
+        Mutex::Autolock l(mMutex);
+        mRenderTid = myTid();
+        mCondition.signal();
+    }
+
+    while (1) {
+        FLAC__bool status = true;
+        {
+            Mutex::Autolock l(mMutex);
+
+            // pausing?
+            if (mPaused) {
+                if (mAudioSink->ready()) mAudioSink->pause();
+                mRender = false;
+                audioStarted = false;
+            }
+
+            // nothing to render, wait for client thread to wake us up
+            if (!mExit && !mRender) {
+                LOGV("render - signal wait\n");
+                mCondition.wait(mMutex);
+                LOGV("render - signal rx'd\n");
+            }
+            if (mExit) break;
+
+            // We could end up here if start() is called, and before we get a
+            // chance to run, the app calls stop() or reset(). Re-check render
+            // flag so we don't try to render in stop or reset state.
+            if (!mRender) continue;
+
+            // create audio output track if necessary
+            if (!mAudioSink->ready()) {
+                LOGV("render - create output track\n");
+                if (createOutputTrack() != NO_ERROR)
+                    break;
+            }
+
+
+            // start audio output if necessary
+            if (!audioStarted && !mPaused && !mExit) {
+                LOGV("render - starting audio\n");
+                mAudioSink->start();
+                audioStarted = true;
+            }
+
+            if (FLAC__stream_decoder_get_state(mDecoder) != FLAC__STREAM_DECODER_END_OF_STREAM) {
+                status = FLAC__stream_decoder_process_single(mDecoder);
+            } else {
+                // end of file, do we need to loop?
+                // ...
+                if (mLoop || mAndroidLoop) {
+                    FLAC__stream_decoder_seek_absolute(mDecoder, 0);
+                    mCurrentSample = 0;
+                    status = FLAC__stream_decoder_process_single(mDecoder);
+                } else {
+                    mAudioSink->stop();
+                    audioStarted = false;
+                    mRender = false;
+                    mPaused = true;
+
+                    FLAC__uint64 endpos;
+                    if (!FLAC__stream_decoder_get_decode_position(mDecoder, &endpos)) {
+                        endpos = 0;
+                    }
+
+                    LOGV("send MEDIA_PLAYBACK_COMPLETE\n");
+                    sendEvent(MEDIA_PLAYBACK_COMPLETE);
+
+                    // wait until we're started again
+                    LOGV("playback complete - wait for signal\n");
+                    mCondition.wait(mMutex);
+                    LOGV("playback complete - signal rx'd\n");
+                    if (mExit) break;
+
+                    // if we're still at the end, restart from the beginning
+                    if (mState == STATE_OPEN) {
+                        FLAC__uint64 curpos;
+                        if (FLAC__stream_decoder_get_decode_position(mDecoder, &curpos)) {
+                            curpos = 0;
+                        }
+                        if (curpos == endpos) {
+                            FLAC__stream_decoder_seek_absolute(mDecoder, 0);
+                            mCurrentSample = 0;
+                        }
+                        status = FLAC__stream_decoder_process_single(mDecoder);
+                    }
+                }
+            }
+        }
+
+        if (!status) {
+            LOGE("Error in FLAC decoder: %s\n", FLAC__stream_decoder_get_resolved_state_string(mDecoder));
+            sendEvent(MEDIA_ERROR);
+            break;
+        }
+
+        if (mAudioBufferFilled > 0) {
+            /* Be sure to clear mAudioBufferFilled even if there's an error. */
+            uint32_t toPlay = mAudioBufferFilled;
+            mAudioBufferFilled = 0;
+
+            if (!mAudioSink->write(mAudioBuffer, toPlay)) {
+                LOGE("Error in FLAC decoder: %s\n", FLAC__stream_decoder_get_resolved_state_string(mDecoder));
+                sendEvent(MEDIA_ERROR);
+                break;
+            }
+        }
+    }
+
+threadExit:
+    mAudioSink.clear();
+    if (mAudioBuffer != NULL) {
+        delete [] mAudioBuffer;
+        mAudioBuffer = NULL;
+        mAudioBufferSize = 0;
+        mAudioBufferFilled = 0;
+    }
+
+    // tell main thread goodbye
+    Mutex::Autolock l(mMutex);
+    mRenderTid = -1;
+    mCondition.signal();
+    return result;
+}
+
+} // end namespace android
+
diff --git a/media/libmediaplayerservice/FLACPlayer.h b/media/libmediaplayerservice/FLACPlayer.h
new file mode 100644
index 0000000..b64465e
--- /dev/null
+++ b/media/libmediaplayerservice/FLACPlayer.h
@@ -0,0 +1,101 @@
+/*
+**
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef ANDROID_FLACPLAYER_H
+#define ANDROID_FLACPLAYER_H
+
+#include <utils/threads.h>
+
+#include <media/MediaPlayerInterface.h>
+#include <media/AudioTrack.h>
+
+#include "FLAC/all.h"
+
+#define ANDROID_LOOP_TAG "ANDROID_LOOP"
+
+namespace android {
+
+class FLACPlayer : public MediaPlayerInterface {
+public:
+                         FLACPlayer();
+                         ~FLACPlayer();
+
+    virtual void         onFirstRef();
+    virtual status_t     initCheck();
+
+    virtual status_t    setDataSource(
+            const char *uri, const KeyedVector<String8, String8> *headers);
+
+    virtual status_t     setDataSource(int fd, int64_t offset, int64_t length);
+    virtual status_t     setVideoSurface(const sp<ISurface>& surface) { return UNKNOWN_ERROR; }
+    virtual status_t     prepare();
+    virtual status_t     prepareAsync();
+    virtual status_t     start();
+    virtual status_t     stop();
+    virtual status_t     seekTo(int msec);
+    virtual status_t     pause();
+    virtual bool         isPlaying();
+    virtual status_t     getCurrentPosition(int* msec);
+    virtual status_t     getDuration(int* msec);
+    virtual status_t     release();
+    virtual status_t     reset();
+    virtual status_t     setLooping(int loop);
+    virtual player_type  playerType() { return FLAC_PLAYER; }
+    virtual status_t     invoke(const Parcel& request, Parcel *reply) {return INVALID_OPERATION;}
+
+private:
+            status_t     setdatasource(const char *path, int fd, int64_t offset, int64_t length);
+            status_t     reset_nosync();
+            status_t     createOutputTrack();
+    static  int          renderThread(void*);
+            int          render();
+
+    static  void         vp_metadata(const FLAC__StreamDecoder *, const FLAC__StreamMetadata *, void *);
+    static  void         vp_error(const FLAC__StreamDecoder *, const FLAC__StreamDecoderErrorStatus, void *);
+    static  FLAC__StreamDecoderWriteStatus
+                         vp_write(const FLAC__StreamDecoder *, const FLAC__Frame *, const FLAC__int32 * const[], void *);
+
+    FLAC__uint64         mTotalSamples;
+    FLAC__uint64         mCurrentSample;
+    uint32_t             mBytesPerSample;
+    uint32_t             mChannels;
+    uint32_t             mSampleRate;
+    uint32_t             mLengthInMsec;
+
+    FLAC__int8 *         mAudioBuffer;
+    uint32_t             mAudioBufferSize;
+    uint32_t             mAudioBufferFilled;
+
+    Mutex                mMutex;
+    Condition            mCondition;
+    FILE*                mFile;
+    FLAC__StreamDecoder* mDecoder;
+    status_t             mState;
+    int                  mStreamType;
+    bool                 mLoop;
+    bool                 mAndroidLoop;
+    volatile bool        mExit;
+    bool                 mPaused;
+    volatile bool        mRender;
+    pid_t                mRenderTid;
+};
+
+}; // namespace android
+
+#endif // ANDROID_FLACPLAYER_H
+
+
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index c43e9bb..ca36b3f 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -56,11 +56,21 @@
 #include "MetadataRetrieverClient.h"
 
 #include "MidiFile.h"
+#include "FLACPlayer.h"
 #include <media/PVPlayer.h>
 #include "TestPlayerStub.h"
 #include "StagefrightPlayer.h"
 
 #include <OMX.h>
+#ifdef OMAP_ENHANCEMENT
+#include <media/OverlayRenderer.h>
+#endif
+
+#ifdef USE_BOARD_MEDIAPLUGIN
+#define NO_OPENCORE 1
+#include <hardware_legacy/MediaPlayerHardwareInterface.h>
+#endif
+
 
 /* desktop Linux needs a little help with gettid() */
 #if defined(HAVE_GETTID) && !defined(HAVE_ANDROID_OS)
@@ -196,11 +206,21 @@ extmap FILE_EXTS [] =  {
         {".rtttl", SONIVOX_PLAYER},
         {".rtx", SONIVOX_PLAYER},
         {".ota", SONIVOX_PLAYER},
+#ifdef OMAP_ENHANCEMENT
+        {".wma", STAGEFRIGHT_PLAYER},
+        {".wmv", STAGEFRIGHT_PLAYER},
+        {".asf", STAGEFRIGHT_PLAYER},
+#else
+#ifdef USE_BOARD_MEDIAPLUGIN
+        {".ogg", STAGEFRIGHT_PLAYER},
+#endif
 #ifndef NO_OPENCORE
         {".wma", PV_PLAYER},
         {".wmv", PV_PLAYER},
         {".asf", PV_PLAYER},
 #endif
+#endif
+        {".flac", FLAC_PLAYER},
 };
 
 // TODO: Find real cause of Audio/Video delay in PV framework and remove this workaround
@@ -294,6 +314,18 @@ sp<IOMX> MediaPlayerService::getOMX() {
     return mOMX;
 }
 
+#ifdef OMAP_ENHANCEMENT
+sp<IOverlayRenderer> MediaPlayerService::getOverlayRenderer() {
+    Mutex::Autolock autoLock(mLock);
+
+    if (mOverlayRenderer.get() == NULL) {
+        mOverlayRenderer = new OverlayRenderer;
+    }
+
+    return mOverlayRenderer;
+}
+#endif
+
 status_t MediaPlayerService::AudioCache::dump(int fd, const Vector<String16>& args) const
 {
     const size_t SIZE = 256;
@@ -675,6 +707,9 @@ void MediaPlayerService::Client::disconnect()
 }
 
 static player_type getDefaultPlayerType() {
+#ifdef USE_BOARD_MEDIAPLUGIN
+    return BOARD_HW_PLAYER;
+#endif
     return STAGEFRIGHT_PLAYER;
 }
 
@@ -691,6 +726,13 @@ player_type getPlayerType(int fd, int64_t offset, int64_t length)
     if (ident == 0x5367674f) // 'OggS'
         return STAGEFRIGHT_PLAYER;
 
+#ifdef OMAP_ENHANCEMENT
+    if (ident == 0x75b22630) {
+        LOGV("The magic number for .asf files, i.e. wmv and wma content");
+        LOGV("These will be supported through stagefright.");
+        return STAGEFRIGHT_PLAYER;
+    }
+#else
 #ifndef NO_OPENCORE
     if (ident == 0x75b22630) {
         // The magic number for .asf files, i.e. wmv and wma content.
@@ -699,6 +741,9 @@ player_type getPlayerType(int fd, int64_t offset, int64_t length)
     }
 #endif
 
+#endif
+    if (ident == 0x43614c66) // 'fLaC'
+        return FLAC_PLAYER;
     // Some kind of MIDI?
     EAS_DATA_HANDLE easdata;
     if (EAS_Init(&easdata) == EAS_SUCCESS) {
@@ -773,6 +818,16 @@ static sp<MediaPlayerBase> createPlayer(player_type playerType, void* cookie,
             LOGV("Create Test Player stub");
             p = new TestPlayerStub();
             break;
+        case FLAC_PLAYER:
+            LOGV(" create FLACPlayer");
+            p = new FLACPlayer();
+            break;
+#ifdef USE_BOARD_MEDIAPLUGIN
+        case BOARD_HW_PLAYER:
+            LOGE(" create BoardHWPlayer");
+            p = createMediaPlayerHardware();
+            break;
+#endif
     }
     if (p != NULL) {
         if (p->initCheck() == NO_ERROR) {
@@ -980,6 +1035,16 @@ status_t MediaPlayerService::Client::resume() {
     return p->resume();
 }
 
+#ifdef OMAP_ENHANCEMENT
+status_t MediaPlayerService::Client::requestVideoCloneMode(bool enable) {
+    sp<MediaPlayerBase> p = getPlayer();
+    if (p == 0) return UNKNOWN_ERROR;
+
+    return p->requestVideoCloneMode(enable);
+}
+
+#endif
+
 status_t MediaPlayerService::Client::prepareAsync()
 {
     LOGV("[%d] prepareAsync", mConnId);
diff --git a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
index 4492e20..d9c2c1d 100644
--- a/media/libmediaplayerservice/MediaPlayerService.h
+++ b/media/libmediaplayerservice/MediaPlayerService.h
@@ -36,6 +36,9 @@ class IMediaRecorder;
 class IMediaMetadataRetriever;
 class IOMX;
 class MediaRecorderClient;
+#ifdef OMAP_ENHANCEMENT
+class IOverlayRenderer;
+#endif
 
 #define CALLBACK_ANTAGONIZER 0
 #if CALLBACK_ANTAGONIZER
@@ -194,7 +197,9 @@ public:
     virtual sp<IMemory>         decode(const char* url, uint32_t *pSampleRate, int* pNumChannels, int* pFormat);
     virtual sp<IMemory>         decode(int fd, int64_t offset, int64_t length, uint32_t *pSampleRate, int* pNumChannels, int* pFormat);
     virtual sp<IOMX>            getOMX();
-
+#ifdef OMAP_ENHANCEMENT
+    virtual sp<IOverlayRenderer>  getOverlayRenderer();
+#endif
     virtual status_t            dump(int fd, const Vector<String16>& args);
 
             void                removeClient(wp<Client> client);
@@ -228,6 +233,9 @@ private:
         virtual status_t        resume();
         virtual status_t        setAuxEffectSendLevel(float level);
         virtual status_t        attachAuxEffect(int effectId);
+#ifdef OMAP_ENHANCEMENT
+        virtual status_t        requestVideoCloneMode(bool enable);
+#endif
 
         sp<MediaPlayerBase>     createPlayer(player_type playerType);
 
@@ -305,6 +313,9 @@ private:
                 SortedVector< wp<MediaRecorderClient> > mMediaRecorderClients;
                 int32_t                     mNextConnId;
                 sp<IOMX>                    mOMX;
+#ifdef OMAP_ENHANCEMENT
+                sp<IOverlayRenderer> mOverlayRenderer;
+#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/media/libmediaplayerservice/MediaRecorderClient.cpp b/media/libmediaplayerservice/MediaRecorderClient.cpp
index 19915f1..429c81a 100644
--- a/media/libmediaplayerservice/MediaRecorderClient.cpp
+++ b/media/libmediaplayerservice/MediaRecorderClient.cpp
@@ -43,7 +43,9 @@
 #include "MediaPlayerService.h"
 
 #include "StagefrightRecorder.h"
-
+#ifdef  USE_BOARD_MEDIARECORDER
+#include <hardware_legacy/MediaRecorderHardwareInterface.h>
+#endif
 namespace android {
 
 const char* cameraPermission = "android.permission.CAMERA";
@@ -196,6 +198,16 @@ status_t MediaRecorderClient::setParameters(const String8& params) {
     return mRecorder->setParameters(params);
 }
 
+status_t MediaRecorderClient::setCameraParameters(const String8& params) {
+    LOGV("setCameraParameters(%s)", params.string());
+    Mutex::Autolock lock(mLock);
+    if (mRecorder == NULL) {
+        LOGE("recorder is not initialized");
+        return NO_INIT;
+    }
+    return mRecorder->setCameraParameters(params);
+}
+
 status_t MediaRecorderClient::prepare()
 {
     LOGV("prepare");
@@ -293,7 +305,11 @@ MediaRecorderClient::MediaRecorderClient(const sp<MediaPlayerService>& service,
 {
     LOGV("Client constructor");
     mPid = pid;
-
+#ifdef USE_BOARD_MEDIARECORDER
+    {
+        mRecorder = createMediaRecorderHardware();
+    }
+#else
     char value[PROPERTY_VALUE_MAX];
     if (!property_get("media.stagefright.enable-record", value, NULL)
         || !strcmp(value, "1") || !strcasecmp(value, "true")) {
@@ -308,7 +324,7 @@ MediaRecorderClient::MediaRecorderClient(const sp<MediaPlayerService>& service,
         mRecorder = NULL;
     }
 #endif
-
+#endif
     mMediaPlayerService = service;
 }
 
diff --git a/media/libmediaplayerservice/MediaRecorderClient.h b/media/libmediaplayerservice/MediaRecorderClient.h
index 1d1913d..d40b874 100644
--- a/media/libmediaplayerservice/MediaRecorderClient.h
+++ b/media/libmediaplayerservice/MediaRecorderClient.h
@@ -51,6 +51,8 @@ public:
     virtual     status_t        release();
 
     virtual     status_t        dump(int fd, const Vector<String16>& args) const;
+
+    virtual     status_t        setCameraParameters(const String8& params);
 private:
     friend class                MediaPlayerService;  // for accessing private constructor
 
diff --git a/media/libmediaplayerservice/MetadataRetrieverClient.cpp b/media/libmediaplayerservice/MetadataRetrieverClient.cpp
index 713e441..449b7bb 100644
--- a/media/libmediaplayerservice/MetadataRetrieverClient.cpp
+++ b/media/libmediaplayerservice/MetadataRetrieverClient.cpp
@@ -53,6 +53,10 @@ pid_t gettid() { return syscall(__NR_gettid);}
 #undef __KERNEL__
 #endif
 
+#ifdef USE_BOARD_MEDIAPLUGIN
+#include <hardware_legacy/MediaPlayerHardwareInterface.h>
+#endif
+
 namespace android {
 
 extern player_type getPlayerType(const char* url);
@@ -100,7 +104,11 @@ static sp<MediaMetadataRetrieverBase> createRetriever(player_type playerType)
 {
     sp<MediaMetadataRetrieverBase> p;
     switch (playerType) {
+#ifdef USE_BOARD_MEDIAPLUGIN
+        case BOARD_HW_PLAYER:
+#endif
         case STAGEFRIGHT_PLAYER:
+        case FLAC_PLAYER:
         {
             p = new StagefrightMetadataRetriever;
             break;
@@ -115,6 +123,12 @@ static sp<MediaMetadataRetrieverBase> createRetriever(player_type playerType)
             LOGV("create midi metadata retriever");
             p = new MidiMetadataRetriever();
             break;
+#ifdef USE_BOARD_MEDIAPLUGIN_BROKEN
+        case BOARD_HW_PLAYER:
+            LOGV("create BoardHW metadata retriever");
+            p = createMetadataRetrieverHardware();
+            break;
+#endif
         default:
             // TODO:
             // support for TEST_PLAYER
diff --git a/media/libmediaplayerservice/StagefrightPlayer.cpp b/media/libmediaplayerservice/StagefrightPlayer.cpp
index 6bded09..26ea8f7 100644
--- a/media/libmediaplayerservice/StagefrightPlayer.cpp
+++ b/media/libmediaplayerservice/StagefrightPlayer.cpp
@@ -150,6 +150,12 @@ status_t StagefrightPlayer::resume() {
     return mPlayer->resume();
 }
 
+#ifdef OMAP_ENHANCEMENT
+status_t StagefrightPlayer::requestVideoCloneMode(bool enable) {
+    return mPlayer->requestVideoCloneMode(enable);
+}
+#endif
+
 status_t StagefrightPlayer::invoke(const Parcel &request, Parcel *reply) {
     return INVALID_OPERATION;
 }
diff --git a/media/libmediaplayerservice/StagefrightPlayer.h b/media/libmediaplayerservice/StagefrightPlayer.h
index 781eb44..6afb4e5 100644
--- a/media/libmediaplayerservice/StagefrightPlayer.h
+++ b/media/libmediaplayerservice/StagefrightPlayer.h
@@ -52,6 +52,9 @@ public:
     virtual void setAudioSink(const sp<AudioSink> &audioSink);
     virtual status_t suspend();
     virtual status_t resume();
+#ifdef OMAP_ENHANCEMENT
+    virtual status_t requestVideoCloneMode(bool enable);
+#endif
 
     virtual status_t getMetadata(
             const media::Metadata::Filter& ids, Parcel *records);
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
old mode 100644
new mode 100755
index 3261fe6..e0ba290
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -628,6 +628,17 @@ status_t StagefrightRecorder::setListener(const sp<IMediaRecorderClient> &listen
     return OK;
 }
 
+status_t StagefrightRecorder::setCameraParameters(const String8 &params) {
+
+    CameraParameters cp(params);
+   
+    int64_t token = IPCThreadState::self()->clearCallingIdentity();
+    mCamera->setParameters( cp.flatten( ) );
+    IPCThreadState::self()->restoreCallingIdentity(token);
+    return OK;
+}
+
+
 status_t StagefrightRecorder::prepare() {
     return OK;
 }
@@ -714,9 +725,24 @@ sp<MediaSource> StagefrightRecorder::createAudioSource() {
     OMXClient client;
     CHECK_EQ(client.connect(), OK);
 
-    sp<MediaSource> audioEncoder =
+    sp<MediaSource> audioEncoder;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3)
+#define MAX_RESOLUTION 414720
+    if ((mAudioEncoder == AUDIO_ENCODER_AAC) &&
+        (mVideoWidth*mVideoHeight > MAX_RESOLUTION)) {
+        audioEncoder =
+            OMXCodec::Create(client.interface(), encMeta,
+                             true /* createEncoder */, audioSource,
+                             "OMX.ITTIAM.AAC.encode");
+
+    } else {
+#endif
+    audioEncoder =
         OMXCodec::Create(client.interface(), encMeta,
                          true /* createEncoder */, audioSource);
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3)
+    }
+#endif
     mAudioSourceNode = audioSource;
 
     return audioEncoder;
@@ -890,12 +916,63 @@ void StagefrightRecorder::clipVideoFrameRate() {
     }
 }
 
+/* Needs to be check max-bitrate in here to make sure that encoding with right parameters */
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3)
+
+#define ARRAY_SIZE(array) (sizeof array / sizeof array[0])
+
+typedef struct {
+    size_t level;
+    size_t maxBitRate;
+    size_t maxFrameSizeinMbs;
+    size_t maxMbsPerSecond;
+} omap3_dsp_h264_supported;
+
+/* Below table synced with inside codec's */
+const omap3_dsp_h264_supported _h264_supported[] = {
+                            {10, 64000, 99, 1485},
+                            {11, 192000, 396, 3000},
+                            {12, 384000, 396, 6000},
+                            {20, 2000000, 396, 11880},
+                            {21, 4000000, 792, 19800},
+                            {22, 4000000, 1620, 20250},
+                            {30, 10000000, 1620, 40500}};
+
+static int _get_maxrate_in_mbs(int width, int height, int fps) {
+    int mps = (width / 16) * (height / 16) * fps; /* Max macroblocks per second */
+    int i;
+    int maxrate = -1;
+
+    for (i = 0; i < ARRAY_SIZE(_h264_supported); i++) {
+        if (mps < _h264_supported[i].maxMbsPerSecond) {
+            maxrate = _h264_supported[i].maxBitRate;
+            break;
+        }
+    }
+
+    // not found, set max.
+    if (maxrate == -1) maxrate = _h264_supported[ARRAY_SIZE(_h264_supported)-1].maxBitRate;
+
+    return maxrate;
+}
+#endif /* defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3) */
+
 void StagefrightRecorder::clipVideoBitRate() {
     LOGV("clipVideoBitRate: encoder %d", mVideoEncoder);
-    int minBitRate = mEncoderProfiles->getVideoEncoderParamByName(
-                        "enc.vid.bps.min", mVideoEncoder);
-    int maxBitRate = mEncoderProfiles->getVideoEncoderParamByName(
-                        "enc.vid.bps.max", mVideoEncoder);
+    int minBitRate;
+    int maxBitRate;
+
+    minBitRate = mEncoderProfiles->getVideoEncoderParamByName(
+        "enc.vid.bps.min", mVideoEncoder);
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3)
+    if (mVideoEncoder == 2) /* H.264 */
+        maxBitRate = _get_maxrate_in_mbs(mVideoWidth, mVideoHeight, mFrameRate);
+    else
+#endif
+        maxBitRate = mEncoderProfiles->getVideoEncoderParamByName(
+            "enc.vid.bps.max", mVideoEncoder);
+
     if (mVideoBitRate < minBitRate) {
         LOGW("Intended video encoding bit rate (%d bps) is too small"
              " and will be set to (%d bps)", mVideoBitRate, minBitRate);
@@ -1034,6 +1111,18 @@ status_t StagefrightRecorder::setupVideoEncoder(sp<MediaSource> *source) {
     CHECK(meta->findInt32(kKeyStride, &stride));
     CHECK(meta->findInt32(kKeySliceHeight, &sliceHeight));
     CHECK(meta->findInt32(kKeyColorFormat, &colorFormat));
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    int32_t paddedWidth, paddedHeight, seiEncodingType, mS3DCamera;
+    const char *frameLayoutStr;
+    CHECK(meta->findInt32(kKeyPaddedWidth, &paddedWidth));
+    CHECK(meta->findInt32(kKeyPaddedHeight, &paddedHeight));
+    CHECK(meta->findInt32(kKeyS3dSupported, &mS3DCamera));
+    if(mS3DCamera)
+    {
+        CHECK(meta->findInt32(kKeySEIEncodingType, &seiEncodingType));
+        CHECK(meta->findCString(kKeyFrameLayout, &frameLayoutStr));
+    }
+#endif
 
     enc_meta->setInt32(kKeyWidth, width);
     enc_meta->setInt32(kKeyHeight, height);
@@ -1041,6 +1130,17 @@ status_t StagefrightRecorder::setupVideoEncoder(sp<MediaSource> *source) {
     enc_meta->setInt32(kKeyStride, stride);
     enc_meta->setInt32(kKeySliceHeight, sliceHeight);
     enc_meta->setInt32(kKeyColorFormat, colorFormat);
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    enc_meta->setInt32(kKeyPaddedWidth, paddedWidth);
+    enc_meta->setInt32(kKeyPaddedHeight, paddedHeight);
+    enc_meta->setInt32(kKeyS3dSupported, mS3DCamera);
+    if(mS3DCamera)
+    {
+        enc_meta->setInt32(kKeySEIEncodingType, seiEncodingType);
+        enc_meta->setCString(kKeyFrameLayout, frameLayoutStr);
+    }
+#endif
+
     if (mVideoTimeScale > 0) {
         enc_meta->setInt32(kKeyTimeScale, mVideoTimeScale);
     }
@@ -1092,12 +1192,14 @@ status_t StagefrightRecorder::startMPEG4Recording() {
     status_t err = OK;
     sp<MediaWriter> writer = new MPEG4Writer(dup(mOutputFd));
 
+#if !defined(OMAP_ENHANCEMENT)
     // Add audio source first if it exists
     if (mAudioSource != AUDIO_SOURCE_LIST_END) {
         err = setupAudioEncoder(writer);
         if (err != OK) return err;
         totalBitRate += mAudioBitRate;
     }
+#endif
     if (mVideoSource == VIDEO_SOURCE_DEFAULT
             || mVideoSource == VIDEO_SOURCE_CAMERA) {
         sp<MediaSource> encoder;
@@ -1106,6 +1208,16 @@ status_t StagefrightRecorder::startMPEG4Recording() {
         writer->addSource(encoder);
         totalBitRate += mVideoBitRate;
     }
+#if defined(OMAP_ENHANCEMENT)
+    // Starting Audio after video to fix AV-Sync issue. The AV-Sync issue here refers to lip-sync not achieved in recorded video.
+    // This is due to the audio track thread blocking the video thread for approx half a second which results in audio recorded
+    // half a second earlier than video. This when played back results in audio/video out of sync.
+    if (mAudioSource != AUDIO_SOURCE_LIST_END) {
+        err = setupAudioEncoder(writer);
+        if (err != OK) return err;
+        totalBitRate += mAudioBitRate;
+    }
+#endif
 
     if (mInterleaveDurationUs > 0) {
         reinterpret_cast<MPEG4Writer *>(writer.get())->
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index e42df2e..82d0adc 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -55,6 +55,7 @@ struct StagefrightRecorder : public MediaRecorderBase {
     virtual status_t reset();
     virtual status_t getMaxAmplitude(int *max);
     virtual status_t dump(int fd, const Vector<String16>& args) const;
+    virtual status_t setCameraParameters(const String8& params);
 
 private:
     enum CameraFlags {
diff --git a/media/libstagefright/AMRExtractor.cpp b/media/libstagefright/AMRExtractor.cpp
index 1b05528..60e4329 100644
--- a/media/libstagefright/AMRExtractor.cpp
+++ b/media/libstagefright/AMRExtractor.cpp
@@ -36,7 +36,9 @@ public:
     AMRSource(const sp<DataSource> &source,
               const sp<MetaData> &meta,
               size_t frameSize,
-              bool isWide);
+              bool isWide,
+              List<AMRFrameTableEntry> mAMRFrameTableEntries,
+              uint64_t mTotalFrames);
 
     virtual status_t start(MetaData *params = NULL);
     virtual status_t stop();
@@ -52,6 +54,9 @@ protected:
 private:
     sp<DataSource> mDataSource;
     sp<MetaData> mMeta;
+    uint64_t mTotalFrames;
+    List<AMRFrameTableEntry> mAMRFrameTableEntries;
+
     size_t mFrameSize;
     bool mIsWide;
 
@@ -65,20 +70,46 @@ private:
 };
 
 ////////////////////////////////////////////////////////////////////////////////
-
+#define MAX_AMRMODE 16
 static size_t getFrameSize(bool isWide, unsigned FT) {
-    static const size_t kFrameSizeNB[8] = {
-        95, 103, 118, 134, 148, 159, 204, 244
+//RFC 4867
+    static const size_t kFrameSizeNB[MAX_AMRMODE] = { 13      // AMR 4.75 Kbps
+          , 14        // AMR 5.15 Kbps
+          , 16        // AMR 5.90 Kbps
+          , 18        // AMR 6.70 Kbps
+          , 20        // AMR 7.40 Kbps
+          , 21        // AMR 7.95 Kbps
+          , 27        // AMR 10.2 Kbps
+          , 32        // AMR 12.2 Kbps
+          , 6     // GsmAmr comfort noise
+          , 7     // Gsm-Efr comfort noise
+          , 6     // IS-641 comfort noise
+          , 6     // Pdc-Efr comfort noise
+          , 1     // future use; 0 length but set to 1 to skip the frame type byte
+          , 1     // future use; 0 length but set to 1 to skip the frame type byte
+          , 1     // future use; 0 length but set to 1 to skip the frame type byte
+          , 1     // AMR Frame No Data
     };
-    static const size_t kFrameSizeWB[9] = {
-        132, 177, 253, 285, 317, 365, 397, 461, 477
+    static const size_t kFrameSizeWB[MAX_AMRMODE] = { 18      // AMR-WB 6.60 Kbps
+          , 24        // AMR-WB 8.85 Kbps
+          , 33        // AMR-WB 12.65 Kbps
+          , 37        // AMR-WB 14.25 Kbps
+          , 41        // AMR-WB 15.85 Kbps
+          , 47        // AMR-WB 18.25 Kbps
+          , 51        // AMR-WB 19.85 Kbps
+          , 59        // AMR-WB 23.05 Kbps
+          , 61        // AMR-WB 23.85 Kbps
+          , 6     // AMR-WB SID
+          , 1
+          , 1
+          , 1
+          , 1
+          , 1     // WBAMR Frame No Data
+          , 1     // WBAMR Frame No Data
     };
 
     size_t frameSize = isWide ? kFrameSizeWB[FT] : kFrameSizeNB[FT];
 
-    // Round up bits to bytes and add 1 for the header byte.
-    frameSize = (frameSize + 7) / 8 + 1;
-
     return frameSize;
 }
 
@@ -101,27 +132,101 @@ AMRExtractor::AMRExtractor(const sp<DataSource> &source)
     mMeta->setInt32(kKeyChannelCount, 1);
     mMeta->setInt32(kKeySampleRate, mIsWide ? 16000 : 8000);
 
-    size_t offset = mIsWide ? 9 : 6;
+    off_t offset = mIsWide ? 9 : 6;
+
+    uint32_t mFrmNumber;
+
+    //add first sample entry mIsWide ? 9 : 6;
+    {
+       AMRFrameTableEntry amrframetableentry(1, offset, 0);
+       mAMRFrameTableEntries.push_back(amrframetableentry);
+    }
+
+    ssize_t n = 0;
+    mFrmNumber = 0;
+    mTotalFrames = 0;
     uint8_t header;
-    if (mDataSource->readAt(offset, &header, 1) != 1) {
+
+    n = mDataSource->readAt(offset, &header, 1);
+
+    if (header & 0x83) {
+          LOGE("padding bits must be 0, header is 0x%02x", header);
+          return;
+    }
+
+    if(n<1){
+        LOGE("AMRxtractor: header incorrect");
         return;
     }
 
     unsigned FT = (header >> 3) & 0x0f;
 
-    if (FT > 8 || (!mIsWide && FT > 7)) {
+    if (FT > MAX_AMRMODE || (!mIsWide && FT > MAX_AMRMODE)) {
+        LOGE("UnSupported AMR FrameType(%d) ERROR",FT);
         return;
     }
 
     mFrameSize = getFrameSize(mIsWide, FT);
 
-    off_t streamSize;
-    if (mDataSource->getSize(&streamSize) == OK) {
-        off_t numFrames = streamSize / mFrameSize;
+    size_t framesize = mFrameSize;
+    size_t numframes = 1;
+    size_t framerate = FT;
+
+    mFrmNumber++;
+    offset = offset+mFrameSize;
+
+    while(n)
+    {
+        n = mDataSource->readAt(offset, &header, 1);
+
+        if(n<1){
+           LOGI("EOF reached");
+           break;
+        }
+
+        if (header & 0x83) {
+        LOGE("padding bits must be 0, header is 0x%02x", header);
+        return; //ERROR_MALFORMED;
+        }
+
+        unsigned FT = (header >> 3) & 0x0f;
+        if (FT > MAX_AMRMODE) {
+            LOGE("UnSupported AMR FrameType(%d) ERROR",FT);
+            return;
+        }
+
+        mFrameSize = getFrameSize(mIsWide, FT);
+        size_t framesize1 = mFrameSize;
+        size_t framerate1 = FT;
+
+        mFrmNumber++;
+        offset = offset+mFrameSize;
+
+        if(framerate1 != framerate)
+        {
+           /* When framerate is different then we store the chunk back on the
+            * list
+            */
+           AMRFrameTableEntry amrframetableentry(numframes, framesize, framerate);
+           mAMRFrameTableEntries.push_back(amrframetableentry);
+
+           framesize = framesize1;
+           framerate = framerate1;
+           numframes = 1;
+        }
+        else
+           numframes++;
+    }
 
-        mMeta->setInt64(kKeyDuration, 20000ll * numFrames);
+    {
+       AMRFrameTableEntry amrframetableentry(numframes, framesize, framerate);
+       mAMRFrameTableEntries.push_back(amrframetableentry);
+       mTotalFrames = mFrmNumber;
     }
 
+    uint32_t numFrames = mFrmNumber;
+    int64_t duration = 20000ll * ((int64_t)numFrames+1);
+    mMeta->setInt64(kKeyDuration, duration);
     mInitCheck = OK;
 }
 
@@ -149,7 +254,7 @@ sp<MediaSource> AMRExtractor::getTrack(size_t index) {
         return NULL;
     }
 
-    return new AMRSource(mDataSource, mMeta, mFrameSize, mIsWide);
+    return new AMRSource(mDataSource, mMeta, mFrameSize, mIsWide, mAMRFrameTableEntries, mTotalFrames);
 }
 
 sp<MetaData> AMRExtractor::getTrackMetaData(size_t index, uint32_t flags) {
@@ -164,9 +269,12 @@ sp<MetaData> AMRExtractor::getTrackMetaData(size_t index, uint32_t flags) {
 
 AMRSource::AMRSource(
         const sp<DataSource> &source, const sp<MetaData> &meta,
-        size_t frameSize, bool isWide)
+        size_t frameSize, bool isWide, List<AMRFrameTableEntry> AMRFrameTableEntries,
+        uint64_t TotalFrames)
     : mDataSource(source),
       mMeta(meta),
+      mTotalFrames(TotalFrames),
+      mAMRFrameTableEntries(AMRFrameTableEntries),
       mFrameSize(frameSize),
       mIsWide(isWide),
       mOffset(mIsWide ? 9 : 6),
@@ -187,6 +295,7 @@ status_t AMRSource::start(MetaData *params) {
     mOffset = mIsWide ? 9 : 6;
     mCurrentTimeUs = 0;
     mGroup = new MediaBufferGroup;
+    //if crash observed during playback then the size needs to be increased
     mGroup->add_buffer(new MediaBuffer(128));
     mStarted = true;
 
@@ -214,9 +323,47 @@ status_t AMRSource::read(
     int64_t seekTimeUs;
     ReadOptions::SeekMode mode;
     if (options && options->getSeekTo(&seekTimeUs, &mode)) {
-        int64_t seekFrame = seekTimeUs / 20000ll;  // 20ms per frame.
+        uint64_t seekFrame = seekTimeUs / 20000ll;  // 20ms per frame.
         mCurrentTimeUs = seekFrame * 20000ll;
-        mOffset = seekFrame * mFrameSize + (mIsWide ? 9 : 6);
+        uint32_t framesize=0;
+        uint64_t offset = 0, numframes = 0;
+
+        if(seekFrame > (mTotalFrames + 1)) {
+            LOGE("Invalid seekTime");
+            return ERROR_OUT_OF_RANGE;
+        } else if(seekFrame >= mTotalFrames) {
+            LOGW("seekTime is equal to the duration");
+            return ERROR_END_OF_STREAM;
+        } else {
+            seekFrame = seekFrame + 1; //why seekframe+1, since the array starts from zero
+        }
+
+        LOGI("seekframe %lld", seekFrame);
+        for (List<AMRFrameTableEntry>::iterator it = mAMRFrameTableEntries.begin();
+               it != mAMRFrameTableEntries.end(); ++it) {
+
+             numframes = it->mNumFrames;
+             framesize = it->mFrameSize;
+             if(seekFrame >= mTotalFrames)
+             {
+               LOGE("seek beyond EOF");
+               return ERROR_OUT_OF_RANGE;
+             }
+
+             if(seekFrame > numframes)
+             {
+               offset = offset + (numframes * framesize);
+               seekFrame = seekFrame - numframes;
+               LOGV("> offset %lld seekFrame %lld numframes %lld framesize %d", offset, seekFrame, numframes, framesize);
+             }
+             else
+             {
+               offset = offset + (seekFrame * framesize);
+               LOGV("!> offset %lld numframes %lld framesize %d", offset, numframes, framesize);
+               break;
+             }
+        }
+        mOffset = offset;
     }
 
     uint8_t header;
@@ -236,7 +383,7 @@ status_t AMRSource::read(
 
     unsigned FT = (header >> 3) & 0x0f;
 
-    if (FT > 8 || (!mIsWide && FT > 7)) {
+    if (FT > MAX_AMRMODE) {
 
         LOGE("illegal AMR frame type %d", FT);
 
@@ -244,7 +391,6 @@ status_t AMRSource::read(
     }
 
     size_t frameSize = getFrameSize(mIsWide, FT);
-    CHECK_EQ(frameSize, mFrameSize);
 
     MediaBuffer *buffer;
     status_t err = mGroup->acquire_buffer(&buffer);
diff --git a/media/libstagefright/ASFExtractor.cpp b/media/libstagefright/ASFExtractor.cpp
new file mode 100644
index 0000000..317ff36
--- /dev/null
+++ b/media/libstagefright/ASFExtractor.cpp
@@ -0,0 +1,179 @@
+/**
+ *****************************************************************************
+ *
+ *  @file     ASFExtractor.cpp
+ *
+ *  @brief    This file works as a wrapper to the ASFExtractor class
+ *
+ *****************************************************************************
+ */
+
+#define LOG_TAG "ASFDummyExtractor"
+#include <utils/Log.h>
+
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <utils/Vector.h>
+#include <dlfcn.h>   /* For dynamic loading */
+#include "include/ASFExtractor.h"
+
+
+namespace android {
+    static void * pASFHandle = NULL;
+
+ASFExtractor::ASFExtractor(const sp<DataSource> &source) {
+    const char *errstr;
+    LOGD("Dummy ASFExtractor contructor");
+
+    pASFParser = new ASF_WRAPER;
+
+    pASFParser->ASFExtractor =     ( ASFExtractorImpl* (*)(const android::sp<android::DataSource>&))dlsym(pASFHandle, "ASFExtractor");
+    if((errstr = dlerror()) != NULL){
+        LOGE("dlsym(), err: %s", errstr);
+        dlclose(pASFHandle);
+        delete pASFParser;
+        return;
+    }
+    pASFParser->destructorASFExtractor =     (void (*)(ASFExtractorImpl *))dlsym(pASFHandle, "destructorASFExtractor");
+    if((errstr = dlerror()) != NULL){
+        LOGE("dlsym(), err: %s", errstr);
+        dlclose(pASFHandle);
+        delete pASFParser;
+        return;
+    }
+    pASFParser->countTracks =       (size_t (*)(ASFExtractorImpl *))dlsym(pASFHandle, "countTracks");
+    if((errstr = dlerror()) != NULL){
+        LOGE("dlsym(), err: %s", errstr);
+        dlclose(pASFHandle);
+        delete pASFParser;
+        return;
+    }
+    pASFParser->getTrack =          (android::sp<android::MediaSource> (*)(size_t, ASFExtractorImpl *))dlsym(pASFHandle, "getTrack");
+    if((errstr = dlerror()) != NULL){
+        LOGE("dlsym(), err: %s", errstr);
+        dlclose(pASFHandle);
+        delete pASFParser;
+        return;
+    }
+    pASFParser->getTrackMetaData =  (android::sp<android::MetaData> (*)(size_t, uint32_t, ASFExtractorImpl *))dlsym(pASFHandle, "getTrackMetaData");
+    if((errstr = dlerror()) != NULL){
+        LOGE("dlsym(), err: %s", errstr);
+        dlclose(pASFHandle);
+        delete pASFParser;
+        return;
+    }
+    pASFParser->getMetaData =       (android::sp<android::MetaData> (*)(ASFExtractorImpl *))dlsym(pASFHandle, "getMetaData");
+    if((errstr = dlerror()) != NULL){
+        LOGE("dlsym(), err: %s", errstr);
+        dlclose(pASFHandle);
+        delete pASFParser;
+        return;
+    }
+
+
+    mHandle = (*pASFParser->ASFExtractor)(source);
+}
+
+ASFExtractor::~ASFExtractor() {
+    LOGD("Dummy ASFExtractor destructor");
+    if(!pASFParser) {
+        return;
+    }
+
+    (pASFParser->destructorASFExtractor)(mHandle);
+
+	// Commented to handle the MediaSource::getFormat() issue.
+    delete pASFParser;
+    pASFParser = NULL;
+}
+
+size_t ASFExtractor::countTracks() {
+    LOGV("Dummy ASFExtractor::countTracks()");
+    if(!pASFParser) {
+        return 0;
+    }
+
+    return (*pASFParser->countTracks)(mHandle);
+}
+
+sp<MediaSource> ASFExtractor::getTrack(size_t index) {
+    LOGV("Dummy ASFExtractor::getTrack()");
+    if(!pASFParser) {
+        return NULL;
+    }
+
+    return (*pASFParser->getTrack)(index, mHandle);
+}
+
+sp<MetaData> ASFExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    if(!pASFParser) {
+        return NULL;
+    }
+
+    return (*pASFParser->getTrackMetaData)(index, flags, mHandle);
+}
+
+sp<MetaData> ASFExtractor::getMetaData() {
+    LOGV("Dummy ASFExtractor::getMetaData()");
+    if(!pASFParser) {
+        return NULL;
+    }
+
+    return (*pASFParser->getMetaData)(mHandle);
+}
+
+bool SniffASF(const sp<DataSource> &source,
+              String8 *mimeType,
+              float *confidence,
+              sp<AMessage> *meta)
+{
+    const char *errstr;
+
+    static bool (*pSniffASF)(
+        const sp<DataSource> &source,
+        String8 *mimeType,
+        float *confidence,
+        sp<AMessage> *meta);
+
+    LOGV("Dummy SniffASF function");
+
+    if(!pASFHandle) {
+        pASFHandle = dlopen("/system/lib/libittiam_asfextractor.so", RTLD_LAZY | RTLD_GLOBAL);
+        if((errstr = dlerror()) != NULL){
+            LOGE("dlopen() err: %s", errstr);
+            return false;
+        }
+    }
+
+    pSniffASF =(bool (*)(const android::sp<android::DataSource>&, android::String8*, float*, android::sp<android::AMessage>*)) dlsym(pASFHandle, "SniffASF");
+    if((errstr = dlerror()) != NULL) {
+        LOGE("Error dlsym(pSniffASF), err: %s", errstr);
+        return false;
+    }
+    return (*pSniffASF)(source, mimeType, confidence, meta);
+}
+
+bool isASFParserAvailable()
+{
+    FILE *pF;
+
+    pF = fopen("/system/lib/libittiam_asfextractor.so", "r");
+    if(!pF) {
+        LOGW("ASF parser is not available");
+        return false;
+    }
+    fclose(pF);
+
+    return true;
+}
+
+void closeASFLib()
+{
+    if (pASFHandle) {
+        dlclose(pASFHandle);
+        pASFHandle = NULL;
+     }
+}
+}  // namespace android
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 615f3e8..e1ef766 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -2,7 +2,9 @@ LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
 include frameworks/base/media/libstagefright/codecs/common/Config.mk
-
+ifeq ($(TARGET_BOARD_PLATFORM),omap4)
+LOCAL_CFLAGS += -DTARGET_OMAP4 -DARM_4K_PAGE_SIZE=4096
+endif
 LOCAL_SRC_FILES:=                         \
         AMRExtractor.cpp                  \
         AMRWriter.cpp                     \
@@ -44,12 +46,35 @@ LOCAL_SRC_FILES:=                         \
         avc_utils.cpp                     \
         string.cpp
 
+ifeq ($(OMAP_ENHANCEMENT),true)
+LOCAL_SRC_FILES += \
+    ASFExtractor.cpp
+endif
+
+ifeq ($(TARGET_BOARD_PLATFORM),omap4)
+LOCAL_SRC_FILES +=               \
+        TIVideoConfigParser.cpp  \
+        TISEIMessagesParser.cpp
+endif
 LOCAL_C_INCLUDES:= \
 	$(JNI_H_INCLUDE) \
         $(TOP)/frameworks/base/include/media/stagefright/openmax \
         $(TOP)/external/tremolo \
+        $(TOP)/external/flac/include \
         $(TOP)/frameworks/base/media/libstagefright/rtsp
+ifeq ($(OMAP_ENHANCEMENT),true)
+LOCAL_C_INCLUDES += \
+        $(TOP)/hardware/ti/omap3/liboverlay
+endif
 
+ifeq ($(TARGET_BOARD_PLATFORM),omap4)
+LOCAL_C_INCLUDES +=					\
+	hardware/ti/omx/ducati/domx/system/omx_core/inc \
+	hardware/ti/omap3/camera-omap4/inc
+endif
+ifeq ($(OMAP_ENHANCEMENT),true)
+LOCAL_C_INCLUDES += $(TOP)/hardware/ti/omap3/liboverlay
+endif
 LOCAL_SHARED_LIBRARIES := \
         libbinder         \
         libmedia          \
@@ -59,7 +84,13 @@ LOCAL_SHARED_LIBRARIES := \
         libsonivox        \
         libvorbisidec     \
         libsurfaceflinger_client \
-        libcamera_client
+        libcamera_client  \
+        libFLAC
+
+ifeq ($(TARGET_BOARD_PLATFORM),omap4)
+LOCAL_SHARED_LIBRARIES += \
+	libcamera
+endif
 
 LOCAL_STATIC_LIBRARIES := \
         libstagefright_aacdec \
@@ -100,6 +131,31 @@ ifneq ($(TARGET_SIMULATOR),true)
 LOCAL_SHARED_LIBRARIES += libdl
 endif
 
+ifneq ($(filter qsd8k msm7k msm7625 msm7x30, $(TARGET_BOARD_PLATFORM)),)
+        LOCAL_CFLAGS += -DUSE_QCOM_OMX_FIX
+endif
+
+ifeq ($(BOARD_USE_YUV422I_DEFAULT_COLORFORMAT),true)
+	LOCAL_CFLAGS += -DUSE_YUV422I_DEFAULT_COLORFORMAT
+endif
+
+ifeq ($(BOARD_CAMERA_USE_GETBUFFERINFO),true)
+        LOCAL_CFLAGS += -DUSE_GETBUFFERINFO
+        LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media/mm-core/omxcore/inc
+endif
+
+ifeq ($(TARGET_USE_SOFTWARE_AUDIO_AAC),true)
+	LOCAL_CFLAGS += -DUSE_SOFTWARE_AUDIO_AAC
+endif
+
+ifeq ($(TARGET_DONT_SET_AUDIO_AAC_FORMAT),true)
+        LOCAL_CFLAGS += -DDONT_SET_AUDIO_AAC_FORMAT
+endif
+
+ifeq ($(TARGET_USE_OMAP_COMPAT),true)
+        LOCAL_CFLAGS += -DOMAP_COMPAT
+endif
+
 ifeq ($(TARGET_OS)-$(TARGET_SIMULATOR),linux-true)
         LOCAL_LDLIBS += -lpthread
 endif
diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index 5ff934d..60c4533 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -26,7 +26,9 @@
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MetaData.h>
-
+#ifdef OMAP_ENHANCEMENT
+#include <media/stagefright/MediaErrors.h>
+#endif
 #include "include/AwesomePlayer.h"
 
 namespace android {
@@ -68,6 +70,11 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
     CHECK(!mStarted);
     CHECK(mSource != NULL);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    mRealTimeInterpolation = GetSystemTimeuSec();
+#endif
+
+
     status_t err;
     if (!sourceAlreadyStarted) {
         err = mSource->start();
@@ -182,10 +189,24 @@ void AudioPlayer::pause(bool playPendingSamples) {
         }
     }
 }
+#ifdef OMAP_ENHANCEMENT
+void AudioPlayer::flush() {
+    CHECK(mStarted);
 
+    if (mAudioSink.get() != NULL) {
+        mAudioSink->flush();
+    } else {
+        mAudioTrack->flush();
+    }
+}
+#endif
 void AudioPlayer::resume() {
     CHECK(mStarted);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    mRealTimeInterpolation = GetSystemTimeuSec();
+#endif
+
     if (mAudioSink.get() != NULL) {
         mAudioSink->start();
     } else {
@@ -387,12 +408,61 @@ size_t AudioPlayer::fillBuffer(void *data, size_t size) {
     Mutex::Autolock autoLock(mLock);
     mNumFramesPlayed += size_done / mFrameSize;
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    //Reset the interpolation time
+    mRealTimeInterpolation = GetSystemTimeuSec();
+#endif
     return size_done;
 }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+//Function to get the system time
+int64_t AudioPlayer::GetSystemTimeuSec(){
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    return ((int64_t)tv.tv_sec * 1000000 + tv.tv_usec);
+}
+#endif
+
 int64_t AudioPlayer::getRealTimeUs() {
     Mutex::Autolock autoLock(mLock);
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    int64_t realtime = getRealTimeUsLocked();
+
+    //We need to interpolate the time to reolution of 1msec
+    //to get precise posting of buffers
+    int64_t deltaFromPosting = 0;
+
+    //Take care of first time read in case no frame has returned
+    if(mRealTimeInterpolation ==0){
+        LOGV("reset %lld",mRealTimeInterpolation);
+        mRealTimeInterpolation = GetSystemTimeuSec();
+        deltaFromPosting = 0;
+    }
+    else{
+        //Fetch the delta time from the last time we got the audio
+        //frame completion. We are only intereseted in delata
+        LOGV("mRealTimeInterpolation %lld = %lld - %lld",
+          ((int64_t)GetSystemTimeuSec()) - mRealTimeInterpolation,
+          ((int64_t)GetSystemTimeuSec()), mRealTimeInterpolation);
+
+        deltaFromPosting =  GetSystemTimeuSec() - mRealTimeInterpolation;
+    }
+
+    //if audio hangs we should drop frames. We will wait worst case of
+    //1 Sec
+    if((deltaFromPosting > 1000000) || (deltaFromPosting < 0) ) {
+        LOGE("To late ... there is a hang %lld",deltaFromPosting);
+        return realtime;
+    }
+
+    LOGV("IPT %lld",deltaFromPosting/1000);
+    return realtime + deltaFromPosting;
+#else
     return getRealTimeUsLocked();
+#endif
+
 }
 
 int64_t AudioPlayer::getRealTimeUsLocked() const {
diff --git a/media/libstagefright/AudioSource.cpp b/media/libstagefright/AudioSource.cpp
index a84365f..942d64f 100644
--- a/media/libstagefright/AudioSource.cpp
+++ b/media/libstagefright/AudioSource.cpp
@@ -48,7 +48,7 @@ AudioSource::AudioSource(
     mRecord = new AudioRecord(
                 inputSource, sampleRate, AudioSystem::PCM_16_BIT,
                 channels > 1? AudioSystem::CHANNEL_IN_STEREO: AudioSystem::CHANNEL_IN_MONO,
-                4 * kMaxBufferSize / sizeof(int16_t), /* Enable ping-pong buffers */
+                4 * kMaxBufferSize / (sizeof(int16_t) * channels), /* Enable ping-pong buffers */
                 flags);
 
     mInitCheck = mRecord->initCheck();
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index e017038..1c87bd9 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -49,10 +49,27 @@
 
 #include <media/stagefright/foundation/ALooper.h>
 
-namespace android {
+#ifdef OMAP_ENHANCEMENT
+#include "include/ASFExtractor.h"
+
+#if defined(TARGET_OMAP4)
+#include <OMX_TI_Video.h>
+#include <OMX_TI_Common.h>
+#include <OMX_TI_IVCommon.h>
+#endif
+
+#endif
 
+namespace android {
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+extern void updateMetaData(sp<MetaData> meta_track);
+#endif
 static int64_t kLowWaterMarkUs = 2000000ll;  // 2secs
+#ifndef OMAP_ENHANCEMENT
 static int64_t kHighWaterMarkUs = 10000000ll;  // 10secs
+#else
+static int64_t kHighWaterMarkUs = 6000000ll;  // 6secs
+#endif
 static const size_t kLowWaterMarkBytes = 40000;
 static const size_t kHighWaterMarkBytes = 200000;
 
@@ -95,6 +112,28 @@ struct AwesomeRemoteRenderer : public AwesomeRenderer {
         }
     }
 
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers(){
+        return mTarget->getBuffers();
+    }
+
+    virtual bool setCallback(release_rendered_buffer_callback cb, void *cookie) {
+        return mTarget->setCallback(cb, cookie);
+    }
+
+    virtual void set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling) {
+         mTarget->set_s3d_frame_layout(s3d_mode, s3d_fmt, s3d_order, s3d_subsampling);
+    }
+
+    virtual void resizeRenderer(void* resize_params) {
+        mTarget->resizeRenderer(resize_params);
+    }
+
+    virtual void requestRendererClone(bool enable) {
+        mTarget->requestRendererClone(enable);
+    }
+#endif
+
 private:
     sp<IOMXRenderer> mTarget;
 
@@ -133,6 +172,18 @@ struct AwesomeLocalRenderer : public AwesomeRenderer {
         mTarget->render(data, size, NULL);
     }
 
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers(){
+        return mTarget->getBuffers();
+    }
+    virtual void resizeRenderer(void* resize_params) {
+        mTarget->resizeRenderer(resize_params);
+    }
+    virtual void requestRendererClone(bool enable) {
+        mTarget->requestRendererClone(enable);
+    }
+#endif
+
 protected:
     virtual ~AwesomeLocalRenderer() {
         delete mTarget;
@@ -238,6 +289,13 @@ status_t AwesomeLocalRenderer::init(
     return ((SoftwareRenderer *)mTarget)->initCheck();
 }
 
+#ifdef OMAP_ENHANCEMENT
+static void releaseRenderedBufferCallback(const sp<IMemory>& mem, void *cookie){
+    AwesomePlayer *ap = static_cast<AwesomePlayer *>(cookie);
+    ap->releaseRenderedBuffer(mem);
+}
+#endif
+
 AwesomePlayer::AwesomePlayer()
     : mQueueStarted(false),
       mTimeSource(NULL),
@@ -245,7 +303,16 @@ AwesomePlayer::AwesomePlayer()
       mAudioPlayer(NULL),
       mFlags(0),
       mExtractorFlags(0),
+#ifdef OMAP_ENHANCEMENT
+      mBufferReleaseCallbackSet(false),
+      mIsFirstVideoBuffer(false),
+      mFirstVideoBufferResult(OK),
+      mFirstVideoBuffer(NULL),
+      mExtractorType(NULL),
+      mExtractor(NULL),
+#else
       mLastVideoBuffer(NULL),
+#endif
       mVideoBuffer(NULL),
       mSuspensionState(NULL) {
     CHECK_EQ(mClient.connect(), OK);
@@ -264,6 +331,16 @@ AwesomePlayer::AwesomePlayer()
 
     mAudioStatusEventPending = false;
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    mS3Dparams.active = S3D_MODE_OFF;
+    mS3Dparams.mode = S3D_MODE_OFF;
+    mS3Dparams.fmt = S3D_FORMAT_NONE;
+    mS3Dparams.order = S3D_ORDER_LF;
+    mS3Dparams.subsampling = S3D_SS_NONE;
+    mS3Dparams.metadata = S3D_SEI_NONE;
+    mVideoMode = VID_MODE_NORMAL;
+#endif
+
     reset();
 }
 
@@ -275,6 +352,9 @@ AwesomePlayer::~AwesomePlayer() {
     reset();
 
     mClient.disconnect();
+#ifdef OMAP_ENHANCEMENT
+    mExtractor.clear();
+#endif
 }
 
 void AwesomePlayer::cancelPlayerEvents(bool keepBufferingGoing) {
@@ -304,6 +384,9 @@ status_t AwesomePlayer::setDataSource(
 
 status_t AwesomePlayer::setDataSource_l(
         const char *uri, const KeyedVector<String8, String8> *headers) {
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    LOGD("setDataSource_l(%s)", uri);
+#endif
     reset_l();
 
     mUri = uri;
@@ -345,6 +428,17 @@ status_t AwesomePlayer::setDataSource_l(
     if (extractor == NULL) {
         return UNKNOWN_ERROR;
     }
+#ifdef OMAP_ENHANCEMENT
+    sp<MetaData> fileMetadata = extractor->getMetaData();
+    bool isAvailable = fileMetadata->findCString(kKeyMIMEType, &mExtractorType);
+    if(isAvailable) {
+        LOGV("%s:: ExtractorType %s", __FUNCTION__,  mExtractorType);
+    }
+    else {
+        LOGV("%s:: ExtractorType not available", __FUNCTION__);
+    }
+    mExtractor = extractor;
+#endif
 
     return setDataSource_l(extractor);
 }
@@ -381,7 +475,20 @@ status_t AwesomePlayer::setDataSource_l(const sp<MediaExtractor> &extractor) {
         CHECK(meta->findCString(kKeyMIMEType, &mime));
 
         if (!haveVideo && !strncasecmp(mime, "video/", 6)) {
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+           sp<MediaSource> mysource = extractor->getTrack(i);
+            if(!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_WMV)){
+                LOGV("ASF parser doesn't support parseSEIMessages()");
+            }
+            else {
+                LOGV("Call parseSEIMessages()");
+                mysource->parseSEIMessages(mS3Dparams);
+            }
+            LOGV("Call setVideoSource(mysource)");
+           setVideoSource(mysource);
+#else
             setVideoSource(extractor->getTrack(i));
+#endif
             haveVideo = true;
         } else if (!haveAudio && !strncasecmp(mime, "audio/", 6)) {
             setAudioSource(extractor->getTrack(i));
@@ -439,6 +546,10 @@ void AwesomePlayer::reset_l() {
     mAudioTrack.clear();
     mVideoTrack.clear();
 
+#ifdef OMAP_ENHANCEMENT
+    mVideoMode = VID_MODE_NORMAL;
+#endif
+
     // Shutdown audio first, so that the respone to the reset request
     // appears to happen instantaneously as far as the user is concerned
     // If we did this later, audio would continue playing while we
@@ -457,12 +568,34 @@ void AwesomePlayer::reset_l() {
     delete mAudioPlayer;
     mAudioPlayer = NULL;
 
+#ifndef OMAP_ENHANCEMENT
     mVideoRenderer.clear();
+#endif
+
+#ifdef OMAP_ENHANCEMENT
+    if (mBuffersWithRenderer.size()) {
+        unsigned int i;
+        unsigned int sz = mBuffersWithRenderer.size();
+
+        for(i = 0; i < sz; i++){
+            mBuffersWithRenderer[i]->release();
+        }
 
+        for(i = 0; i < sz; i++){
+            mBuffersWithRenderer.pop();
+        }
+    }
+    // release reference in case it exists
+    if (mFirstVideoBuffer != NULL) {
+        mFirstVideoBuffer->release();
+        mFirstVideoBuffer = NULL;
+    }
+#else
     if (mLastVideoBuffer) {
         mLastVideoBuffer->release();
         mLastVideoBuffer = NULL;
     }
+#endif
 
     if (mVideoBuffer) {
         mVideoBuffer->release();
@@ -492,6 +625,10 @@ void AwesomePlayer::reset_l() {
         IPCThreadState::self()->flushCommands();
     }
 
+#ifdef OMAP_ENHANCEMENT
+    mVideoRenderer.clear();
+#endif
+
     mDurationUs = -1;
     mFlags = 0;
     mExtractorFlags = 0;
@@ -593,11 +730,18 @@ void AwesomePlayer::onBufferingUpdate() {
 
                 if ((mFlags & PLAYING) && !eos
                         && (cachedDataRemaining < kLowWaterMarkBytes)) {
+#ifdef OMAP_ENHANCEMENT
+                //if low cache duration is caused by a seek, wait audio callback to avoid MEDIA_SEEK_COMPLETE being lost.
+                if (!mWatchForAudioSeekComplete) {
+#endif
                     LOGI("cache is running low (< %d) , pausing.",
                          kLowWaterMarkBytes);
                     mFlags |= CACHE_UNDERRUN;
                     pause_l();
                     notifyListener_l(MEDIA_INFO, MEDIA_INFO_BUFFERING_START);
+#ifdef OMAP_ENHANCEMENT
+                }
+#endif
                 } else if (eos || cachedDataRemaining > kHighWaterMarkBytes) {
                     if (mFlags & CACHE_UNDERRUN) {
                         LOGI("cache has filled up (> %d), resuming.",
@@ -620,11 +764,18 @@ void AwesomePlayer::onBufferingUpdate() {
     if (getCachedDuration_l(&cachedDurationUs, &eos)) {
         if ((mFlags & PLAYING) && !eos
                 && (cachedDurationUs < kLowWaterMarkUs)) {
+#ifdef OMAP_ENHANCEMENT
+            //if low cache duration is caused by a seek, wait audio callback to avoid MEDIA_SEEK_COMPLETE being lost.
+            if (!mWatchForAudioSeekComplete) {
+#endif
             LOGI("cache is running low (%.2f secs) , pausing.",
                  cachedDurationUs / 1E6);
             mFlags |= CACHE_UNDERRUN;
             pause_l();
             notifyListener_l(MEDIA_INFO, MEDIA_INFO_BUFFERING_START);
+#ifdef OMAP_ENHANCEMENT
+            }
+#endif
         } else if (eos || cachedDurationUs > kHighWaterMarkUs) {
             if (mFlags & CACHE_UNDERRUN) {
                 LOGI("cache has filled up (%.2f secs), resuming.",
@@ -649,10 +800,12 @@ void AwesomePlayer::partial_reset_l() {
 
     mVideoRenderer.clear();
 
+#ifndef OMAP_ENHANCEMENT
     if (mLastVideoBuffer) {
         mLastVideoBuffer->release();
         mLastVideoBuffer = NULL;
     }
+#endif
 
     if (mVideoBuffer) {
         mVideoBuffer->release();
@@ -759,6 +912,35 @@ status_t AwesomePlayer::play_l() {
     mFlags |= PLAYING;
     mFlags |= FIRST_FRAME;
 
+#ifdef OMAP_ENHANCEMENT
+    if(mVideoSource != NULL) {
+         if (mFirstVideoBuffer != NULL) {
+                    mFirstVideoBuffer->release();
+                    mFirstVideoBuffer = NULL;
+        }
+        mFirstVideoBufferResult = mVideoSource->read(&mFirstVideoBuffer);
+        if (mFirstVideoBufferResult == INFO_FORMAT_CHANGED) {
+            LOGV("First INFO_FORMAT_CHANGED!!!");
+            LOGV("VideoSource signalled format change.");
+            if (mVideoRenderer != NULL) {
+                mVideoRendererIsPreview = false;
+                initRenderer_l();
+#ifdef OMAP_ENHANCEMENT
+            if (mVideoRenderer != NULL) {
+                // Share overlay buffers with video decoder.
+                mVideoSource->setBuffers(mVideoRenderer->getBuffers(), true);
+            }
+#endif
+            }
+            CHECK(mFirstVideoBuffer == NULL);
+            mFirstVideoBufferResult = OK;
+            mIsFirstVideoBuffer = false;
+        } 
+       else {
+            mIsFirstVideoBuffer = true;
+        }
+}
+#endif
     bool deferredAudioSeek = false;
 
     if (mAudioSource != NULL) {
@@ -777,7 +959,12 @@ status_t AwesomePlayer::play_l() {
                     mAudioPlayer = NULL;
 
                     mFlags &= ~(PLAYING | FIRST_FRAME);
-
+#ifdef OMAP_ENHANCEMENT
+                    if (mFirstVideoBuffer) {
+                        mFirstVideoBuffer->release();
+                        mFirstVideoBuffer = NULL;
+                    }
+#endif
                     return err;
                 }
 
@@ -789,7 +976,25 @@ status_t AwesomePlayer::play_l() {
                 mWatchForAudioEOS = true;
             }
         } else {
+#ifdef OMAP_ENHANCEMENT
+            if (!mSeeking || mVideoSource == NULL) {
+               // Resume when video is not present or when
+               // not seeking and flush the sink so buffer from
+                //previous position is not heard
+                if(mSeeking){
+                    if(mAudioSink.get() != NULL){
+                        mAudioSink->flush();
+                    }
+                }
+                mAudioPlayer->resume();
+            } else {
+                // when seeking it is too early to resume
+                // as audio has not seek yet
+                mFlags |= HOLD_TO_RESUME;
+            }
+#else
             mAudioPlayer->resume();
+#endif
         }
     }
 
@@ -831,7 +1036,41 @@ status_t AwesomePlayer::initRenderer_l() {
     CHECK(meta->findCString(kKeyDecoderComponent, &component));
     CHECK(meta->findInt32(kKeyWidth, &decodedWidth));
     CHECK(meta->findInt32(kKeyHeight, &decodedHeight));
-
+#ifdef OMAP_ENHANCEMENT
+#ifdef TARGET_OMAP4
+    CHECK(meta->findInt32(kKeyWidth, &mVideoWidth));
+    CHECK(meta->findInt32(kKeyHeight, &mVideoHeight));
+ 
+    if(!(meta->findInt32(kKeyPaddedWidth, &decodedWidth))) {
+       CHECK(meta->findInt32(kKeyWidth, &decodedWidth));
+    }
+    if(!(meta->findInt32(kKeyPaddedHeight, &decodedHeight))) {
+       CHECK(meta->findInt32(kKeyHeight, &decodedHeight));
+    }
+#endif
+    LOGD(" initRenderer_l %dx%d",decodedWidth,decodedHeight );
+    LOGD(" initRenderer_l %dx%d",mVideoWidth,mVideoHeight );
+    if (mVideoRenderer != NULL) {
+        //we cant destroy overlay based renderer here,as the overlay has 2 handles 
+        //(1) from media server process (the current process)
+        //(2) from surface flinger process.
+        // Hence, we have to resize the renderer for new dimensions than dstroying and  
+        // re-creating
+
+        uint32_t outputBufferCnt = -1;
+        outputBufferCnt = mVideoSource->getNumofOutputBuffers();
+        LOGD("Codec Recommended outputBuffer count after portreconfig %d",outputBufferCnt);
+        render_resize_params resize_params;
+        resize_params.decoded_width = decodedWidth;
+        resize_params.decoded_height = decodedHeight;
+        resize_params.buffercount = outputBufferCnt;
+        resize_params.display_width = mVideoWidth;
+        resize_params.display_height = mVideoHeight;
+
+        mVideoRenderer->resizeRenderer((void*)(&resize_params));
+        return 0;
+    } 
+#endif
     int32_t rotationDegrees;
     if (!mVideoTrack->getFormat()->findInt32(
                 kKeyRotation, &rotationDegrees)) {
@@ -840,6 +1079,11 @@ status_t AwesomePlayer::initRenderer_l() {
 
     mVideoRenderer.clear();
 
+#if defined( OMAP_ENHANCEMENT) && !defined(TARGET_OMAP4)
+    // Initializing S3D flag, to be passed by higher layer
+    int isS3D =0;
+#endif
+
     // Must ensure that mVideoRenderer's destructor is actually executed
     // before creating a new one.
     IPCThreadState::self()->flushCommands();
@@ -849,6 +1093,44 @@ status_t AwesomePlayer::initRenderer_l() {
         // therefore they require a remote IOMXRenderer that knows how
         // to display them.
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        //initialize the codec recommended buffers to -1
+        int32_t outputBufferCnt = -1;
+        outputBufferCnt = mVideoSource->getNumofOutputBuffers();
+        LOGD("Codec Recommended outputBuffer count %d",outputBufferCnt);
+
+        sp<IOMXRenderer> native =
+            mClient.interface()->createRenderer(
+                    mISurface, component,
+                    (OMX_COLOR_FORMATTYPE)format,
+                    decodedWidth, decodedHeight,
+                    mVideoWidth, mVideoHeight,
+                    rotationDegrees, mS3Dparams.active, outputBufferCnt);
+
+        if (native == NULL) {
+            return NO_INIT;
+        }
+
+        mVideoRenderer = new AwesomeRemoteRenderer(native);
+
+#elif defined(OMAP_ENHANCEMENT)
+        int32_t outputBufferCnt = -1;
+
+        sp<IOMXRenderer> native =
+            mClient.interface()->createRenderer(
+                    mISurface, component,
+                    (OMX_COLOR_FORMATTYPE)format,
+                    decodedWidth, decodedHeight,
+                    mVideoWidth, mVideoHeight,
+                    rotationDegrees, isS3D, outputBufferCnt);
+
+        if (native == NULL) {
+            return NO_INIT;
+        }
+
+        mVideoRenderer = new AwesomeRemoteRenderer(native);
+
+#else
         sp<IOMXRenderer> native =
             mClient.interface()->createRenderer(
                     mISurface, component,
@@ -862,6 +1144,18 @@ status_t AwesomePlayer::initRenderer_l() {
         }
 
         mVideoRenderer = new AwesomeRemoteRenderer(native);
+#endif
+#ifdef OMAP_ENHANCEMENT
+            if (!strncmp("OMX.TI", component, 6)) {
+#if defined(TARGET_OMAP4)
+                if(mS3Dparams.active)
+                    mVideoRenderer->set_s3d_frame_layout(mS3Dparams.mode ,mS3Dparams.fmt ,mS3Dparams.order, mS3Dparams.subsampling);
+#endif
+                mBufferReleaseCallbackSet = mVideoRenderer->setCallback(releaseRenderedBufferCallback, this);
+                mVideoRenderer->setCallback(releaseRenderedBufferCallback, this);  
+            }
+#endif
+
     } else {
         // Other decoders are instantiated locally and as a consequence
         // allocate their buffers in local address space.
@@ -890,6 +1184,12 @@ status_t AwesomePlayer::pause_l(bool at_eos) {
         return OK;
     }
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+    if (mVideoSource != NULL) {
+        // Indicating to codec that Pause button pressed
+        mVideoSource->pause();
+    }
+#endif
     cancelPlayerEvents(true /* keepBufferingGoing */);
 
     if (mAudioPlayer != NULL) {
@@ -1053,11 +1353,86 @@ status_t AwesomePlayer::initAudioDecoder() {
 
     if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
         mAudioSource = mAudioTrack;
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    }
+    else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_WMA)) {
+        const char *componentName  = "OMX.ITTIAM.WMA.decode";
+        mAudioSource = OMXCodec::Create(
+        mClient.interface(), mAudioTrack->getFormat(),
+        false,
+        mAudioTrack, componentName);
+        if (mAudioSource == NULL) {
+            LOGE("Failed to create OMX component for WMA codec");
+        }
+#endif
     } else {
+#ifdef OMAP_ENHANCEMENT
+        if (mVideoWidth*mVideoHeight > MAX_RESOLUTION) {
+         // video is launched first, so these capablities are known
+         // audio can be selected accordingly
+         // TODO: extend this to a method that can include more
+         // capabilities to evaluate
+
+#ifdef TARGET_OMAP4
+            //for OMAP4 720p,1080p videos, lets stick to OMX.PV audio codecs
+            mAudioSource = OMXCodec::Create(
+                    mClient.interface(), mAudioTrack->getFormat(),
+                    false, // createEncoder
+                    mAudioTrack);
+#else
+        bool isIttiamAudioCodecRequired = false;
+        bool is720PCodecRequired = (mVideoWidth*mVideoHeight > MAX_RESOLUTION) ? true : false;
+
+        if (true == is720PCodecRequired) {
+            isIttiamAudioCodecRequired = true;
+        }
+        if (true == isIttiamAudioCodecRequired){
+
+         // video is launched first, so these capablities are known
+         // audio can be selected accordingly
+         // TODO: extend this to a method that can include more
+         // capabilities to evaluate
+
+            const char *componentName;
+            if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
+                componentName = "OMX.ITTIAM.AAC.decode";
+
+            mAudioSource = OMXCodec::Create(
+                    mClient.interface(), mAudioTrack->getFormat(),
+                    false, // createEncoder
+                        mAudioTrack, componentName);
+            }
+            else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_WMA)) {
+                componentName = "OMX.ITTIAM.WMA.decode";
+
+                mAudioSource = OMXCodec::Create(
+                        mClient.interface(), mAudioTrack->getFormat(),
+                        false,
+                        mAudioTrack, componentName);
+
+            }
+            else {
+                componentName = "NoComponentAvailable";
+
+                mAudioSource = OMXCodec::Create(
+                        mClient.interface(), mAudioTrack->getFormat(),
+                        false,
+                        mAudioTrack);
+            }
+        }
+#endif
+        } else {
+            mAudioSource = OMXCodec::Create(
+                    mClient.interface(), mAudioTrack->getFormat(),
+                    false, // createEncoder
+                    mAudioTrack);
+        }
+#else
         mAudioSource = OMXCodec::Create(
                 mClient.interface(), mAudioTrack->getFormat(),
                 false, // createEncoder
                 mAudioTrack);
+#endif
     }
 
     if (mAudioSource != NULL) {
@@ -1091,12 +1466,136 @@ void AwesomePlayer::setVideoSource(sp<MediaSource> source) {
     mVideoTrack = source;
 }
 
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+/*
+  * Dynamically update S3D display driver based on framelayout configuration changes
+  * sent by Codec as OMX metadata
+  */
+void AwesomePlayer::updateS3DRenderer()
+{
+
+    status_t ret = NO_ERROR;
+    void *OMXplaformPrivate;
+    OMX_OTHER_EXTRADATATYPE *extraData;
+    int32_t lCounter = 0;
+
+    CHECK_EQ(mVideoBuffer->meta_data()->findPointer(kKeyPlatformPrivate, &OMXplaformPrivate), true);
+
+    if ( ((OMX_TI_PLATFORMPRIVATE *)OMXplaformPrivate)->nMetaDataSize <= 0 || ((OMX_TI_PLATFORMPRIVATE *) OMXplaformPrivate)->pMetaDataBuffer == NULL)
+    {
+        LOGV("No MetaData in this buffer \n");
+        return;
+    }
+
+    do
+    {
+        extraData = (OMX_OTHER_EXTRADATATYPE *) (((OMX_TI_PLATFORMPRIVATE *) OMXplaformPrivate)->pMetaDataBuffer + lCounter);
+        switch( extraData-> eType)
+        {
+            case OMX_TI_SEIinfo2004Frame1:
+            case OMX_TI_SEIinfo2004Frame2:
+            {
+                if(configSEI2004Infos(extraData))
+                    //update S3D driver dynamic configuration parameters
+                    mVideoRenderer->set_s3d_frame_layout(mS3Dparams.mode ,mS3Dparams.fmt ,mS3Dparams.order, mS3Dparams.subsampling);
+                return;
+                break;
+            }
+            case OMX_TI_SEIinfo2010Frame1:
+            case OMX_TI_SEIinfo2010Frame2:
+            {
+                if(configSEI2010Infos(extraData))
+                    //update S3D driver dynamic configuration parameters
+                    mVideoRenderer->set_s3d_frame_layout(mS3Dparams.mode ,mS3Dparams.fmt ,mS3Dparams.order, mS3Dparams.subsampling);
+                return;
+                break;
+            }
+            default:
+            {
+                LOGV("No SEI meta data \n");
+                break;
+            }
+        }
+        lCounter += extraData->nSize;
+    }while ((lCounter < ( (OMX_TI_PLATFORMPRIVATE *)OMXplaformPrivate)->nMetaDataSize ) && (extraData-> eType !=0 ));
+
+}
+
+bool AwesomePlayer::configSEI2004Infos(OMX_OTHER_EXTRADATATYPE *extraData)
+{
+    if(mS3Dparams.metadata != S3D_SEI_STEREO_INFO_PROGRESSIVE || mS3Dparams.metadata != S3D_SEI_STEREO_INFO_INTERLACED)
+        LOGV("SEI buffer configuration changed \n");
+
+    OMX_TI_STEREODECINFO * pstereoDecInfo;
+    pstereoDecInfo = (OMX_TI_STEREODECINFO *) (extraData->data);
+
+    if(sizeof(OMX_TI_STEREODECINFO) == extraData->nDataSize)
+    {
+        if(pstereoDecInfo->nFieldViewsFlag)
+        {
+            if(pstereoDecInfo->nTopFieldIsLeftViewFlag)
+                mS3Dparams.order = S3D_ORDER_LF;
+            else
+                mS3Dparams.order = S3D_ORDER_RF;
+        }
+        else
+        {
+             if(pstereoDecInfo->nCurrentFrameIsLeftViewFlag)
+                mS3Dparams.order = S3D_ORDER_LF;
+            else
+                mS3Dparams.order = S3D_ORDER_RF;
+        }
+        return true;
+    }
+    return false;
+}
+
+bool AwesomePlayer::configSEI2010Infos(OMX_OTHER_EXTRADATATYPE *extraData)
+{
+    if(mS3Dparams.metadata != S3D_SEI_STEREO_FRAME_PACKING)
+        LOGV("SEI buffer configuration changed \n");
+
+    OMX_TI_FRAMEPACKINGDECINFO * pframePackingDecInfo;
+    pframePackingDecInfo = (OMX_TI_FRAMEPACKINGDECINFO *) (extraData->data);
+
+    if(sizeof(OMX_TI_FRAMEPACKINGDECINFO) == extraData->nDataSize)
+    {
+        if(pframePackingDecInfo->nFramePackingArrangementCancelFlag)
+        {
+            set_frame_packing_arrangement_type(pframePackingDecInfo->nFramePackingArrangementType, mS3Dparams.fmt, mS3Dparams.subsampling);
+            if(pframePackingDecInfo->nContentInterpretationType)
+                mS3Dparams.order = S3D_ORDER_LF;
+            else
+                mS3Dparams.order = S3D_ORDER_RF;
+            return true;
+        }
+    }
+    return false;
+}
+#endif
+
 status_t AwesomePlayer::initVideoDecoder(uint32_t flags) {
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+    //Call config parser to update profile,level,interlaced,reference frame data
+    updateMetaData(mVideoTrack->getFormat());
+
+    int32_t isInterlaced = false;
+    mVideoTrack->getFormat()->findInt32(kKeyVideoInterlaced, &isInterlaced);
+
+    mVideoSource = OMXCodec::Create(
+            mClient.interface(), mVideoTrack->getFormat(),
+            false, // createEncoder
+            mVideoTrack,
+            NULL,
+            (flags | isInterlaced)?OMXCodec::kPreferInterlacedOutputContent:0);
+#else
     mVideoSource = OMXCodec::Create(
             mClient.interface(), mVideoTrack->getFormat(),
             false, // createEncoder
             mVideoTrack,
             NULL, flags);
+#endif
 
     if (mVideoSource != NULL) {
         int64_t durationUs;
@@ -1110,12 +1609,15 @@ status_t AwesomePlayer::initVideoDecoder(uint32_t flags) {
         CHECK(mVideoTrack->getFormat()->findInt32(kKeyWidth, &mVideoWidth));
         CHECK(mVideoTrack->getFormat()->findInt32(kKeyHeight, &mVideoHeight));
 
+#ifndef OMAP_ENHANCEMENT
         status_t err = mVideoSource->start();
 
         if (err != OK) {
             mVideoSource.clear();
             return err;
         }
+#endif
+
     }
 
     return mVideoSource != NULL ? OK : UNKNOWN_ERROR;
@@ -1157,11 +1659,17 @@ void AwesomePlayer::onVideoEvent() {
     mVideoEventPending = false;
 
     if (mSeeking) {
+#ifdef OMAP_ENHANCEMENT
+        if (mFirstVideoBuffer) {
+            mFirstVideoBuffer->release();
+            mFirstVideoBuffer = NULL;
+        }
+#else
         if (mLastVideoBuffer) {
             mLastVideoBuffer->release();
             mLastVideoBuffer = NULL;
         }
-
+#endif
         if (mVideoBuffer) {
             mVideoBuffer->release();
             mVideoBuffer = NULL;
@@ -1187,12 +1695,33 @@ void AwesomePlayer::onVideoEvent() {
         MediaSource::ReadOptions options;
         if (mSeeking) {
             LOGV("seeking to %lld us (%.2f secs)", mSeekTimeUs, mSeekTimeUs / 1E6);
-
+#ifdef OMAP_ENHANCEMENT
+            if (mIsFirstVideoBuffer) {
+                if (mFirstVideoBuffer != NULL) {
+                    mFirstVideoBuffer->release();
+                    mFirstVideoBuffer = NULL;
+                }
+                mIsFirstVideoBuffer = false;
+            }
+#endif
             options.setSeekTo(
                     mSeekTimeUs, MediaSource::ReadOptions::SEEK_CLOSEST_SYNC);
         }
         for (;;) {
+#ifdef OMAP_ENHANCEMENT
+            status_t err;
+            if (mIsFirstVideoBuffer) {
+                mVideoBuffer = mFirstVideoBuffer;
+                mFirstVideoBuffer = NULL;
+                err = mFirstVideoBufferResult;
+
+                mIsFirstVideoBuffer = false;
+            } else {
+                err = mVideoSource->read(&mVideoBuffer, &options);
+            }
+#else
             status_t err = mVideoSource->read(&mVideoBuffer, &options);
+#endif
             options.clearSeekTo();
 
             if (err != OK) {
@@ -1203,10 +1732,40 @@ void AwesomePlayer::onVideoEvent() {
 
                     if (mVideoRenderer != NULL) {
                         mVideoRendererIsPreview = false;
-                        err = initRenderer_l();
+#ifdef OMAP_ENHANCEMENT
+                        if (mBuffersWithRenderer.size()) {
+                            unsigned int i;
+                            unsigned int sz = mBuffersWithRenderer.size();
+
+                            for(i = 0; i < sz; i++){
+                                mBuffersWithRenderer[i]->release();
+                            }
+
+                            for(i = 0; i < sz; i++){
+                                mBuffersWithRenderer.pop();
+                            }
+                        }
 
+                        if (mFirstVideoBuffer != NULL) {
+                            mFirstVideoBuffer->release();
+                            mFirstVideoBuffer = NULL;
+                        }
+                        if (mVideoBuffer) {
+                            mVideoBuffer->release();
+                            mVideoBuffer = NULL;
+                        }
+#endif
+
+                        err = initRenderer_l();
                         if (err == OK) {
-                            continue;
+#ifdef OMAP_ENHANCEMENT
+                        if (mVideoRenderer != NULL) {
+                            // Share overlay buffers with video decoder.
+                            mVideoSource->setBuffers(mVideoRenderer->getBuffers(), true);
+                        }
+                        postVideoEvent_l(0);
+#endif
+                            return;
                         }
 
                         // fall through
@@ -1280,22 +1839,50 @@ void AwesomePlayer::onVideoEvent() {
         // and we'll play incoming video as fast as we get it.
         latenessUs = 0;
     }
+#ifdef OMAP_ENHANCEMENT
+    LOGV("%s::%d: (latenessUs= %lld) = ((nowUs= %lld) - (timeUs=%lld))", __FUNCTION__, __LINE__, latenessUs, nowUs, timeUs);
 
+    if (latenessUs > 50000) {
+        // We're more than 50ms late.
+
+        /* Trace to detect frame drops */
+        LOGV("Frame dropped - lateness (%lld - %lld = %lld uS)",nowUs,timeUs,latenessUs);
+
+#else
     if (latenessUs > 40000) {
         // We're more than 40ms late.
+#endif
         LOGV("we're late by %lld us (%.2f secs)", latenessUs, latenessUs / 1E6);
 
         mVideoBuffer->release();
         mVideoBuffer = NULL;
-
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        postVideoEvent_l(0);
+#else
         postVideoEvent_l();
+#endif
         return;
     }
-
+#if defined(OMAP_ENHANCEMENT) && !defined(TARGET_OMAP4)
+    if (latenessUs < -100000) {
+        // We're more than 100ms early.
+        LOGV("%s::%d: Frame is early than 100ms: %lld", __FUNCTION__, __LINE__, latenessUs);
+        LOGV("%s::%d: postVideoEvent_l(10000)", __FUNCTION__, __LINE__);
+#else
     if (latenessUs < -10000) {
         // We're more than 10ms early.
+#endif
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        //There is no need to poll for 10 msec
+        //This going to increase the MHz on ARM. Try to come back
+        //when we need to exactly post. Need to do a mod for 100 msec
+        //so that while seeking the video frame doesnt wait for lateness
+        //which can be a huge delay. This will result like a hang
+        postVideoEvent_l((latenessUs * -1) % 100000);
+#else
         postVideoEvent_l(10000);
+#endif
         return;
     }
 
@@ -1310,21 +1897,56 @@ void AwesomePlayer::onVideoEvent() {
             mFlags |= VIDEO_AT_EOS;
             postStreamDoneEvent_l(err);
             return;
+        } else {
+#ifdef OMAP_ENHANCEMENT
+        if (mVideoRenderer != NULL) {
+            // Share overlay buffers with video decoder.
+            mVideoSource->setBuffers(mVideoRenderer->getBuffers(), true);
         }
+#endif
+    }
     }
 
+#ifdef OMAP_ENHANCEMENT
+    /*the buffer needs to be pushed to local database before calling render.
+    * This is required to release the buffer back to Video source if the
+    * buffer can't be queued to the DSS
+    */
+    mBuffersWithRenderer.push(mVideoBuffer);
+#endif
+
     if (mVideoRenderer != NULL) {
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+    int32_t isExtraData = 0;
+    if(mS3Dparams.active && mVideoBuffer->meta_data()->findInt32(kKeyIsExtraData, &isExtraData))
+            updateS3DRenderer();
+#endif
         mVideoRenderer->render(mVideoBuffer);
     }
 
+#ifdef OMAP_ENHANCEMENT
+    if ((!mBufferReleaseCallbackSet)  && (mBuffersWithRenderer.size())){
+        mBuffersWithRenderer[0]->release();
+        mBuffersWithRenderer.pop();
+    }
+#else
     if (mLastVideoBuffer) {
         mLastVideoBuffer->release();
         mLastVideoBuffer = NULL;
     }
     mLastVideoBuffer = mVideoBuffer;
-    mVideoBuffer = NULL;
+#endif
 
+    mVideoBuffer = NULL;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    // No need to trigger the poll after 10 msec which is default value
+    // This is causing a jerk in AV sync. We can trigger a 0 msec and accurate
+    // wait which will allow more ARM sleep time
+    postVideoEvent_l(0);
+#else
     postVideoEvent_l();
+#endif
+
 }
 
 void AwesomePlayer::postVideoEvent_l(int64_t delayUs) {
@@ -1664,6 +2286,17 @@ status_t AwesomePlayer::finishSetDataSource_l() {
     if (extractor == NULL) {
         return UNKNOWN_ERROR;
     }
+#ifdef OMAP_ENHANCEMENT
+    sp<MetaData> fileMetadata = extractor->getMetaData();
+    bool isAvailable = fileMetadata->findCString(kKeyMIMEType, &mExtractorType);
+    if(isAvailable) {
+        LOGV("%s:: ExtractorType %s", __FUNCTION__,  mExtractorType);
+    }
+    else {
+        LOGV("%s:: ExtractorType not available", __FUNCTION__);
+    }
+    mExtractor = extractor;
+#endif
 
     return setDataSource_l(extractor);
 }
@@ -1708,7 +2341,24 @@ void AwesomePlayer::onPrepareAsyncEvent() {
 
     if (mVideoTrack != NULL && mVideoSource == NULL) {
         status_t err = initVideoDecoder();
+#ifdef OMAP_ENHANCEMENT
+            if (err == OK){
+                if (mVideoRendererIsPreview || mVideoRenderer == NULL) {
+                    mVideoRendererIsPreview = false;
+                    initRenderer_l();
+                    if (mVideoRenderer != NULL) {
+                        // Share overlay buffers with video decoder.
+                        mVideoSource->setBuffers(mVideoRenderer->getBuffers(), false);
+                    }
+                }
 
+                err = mVideoSource->start();
+                if (err != OK) {
+                    mVideoSource.clear();
+                    //Subsequent error handling will take of returning.
+                }
+            }
+#endif
         if (err != OK) {
             abortPrepare(err);
             return;
@@ -1769,7 +2419,11 @@ status_t AwesomePlayer::suspend() {
     Mutex::Autolock autoLock(mLock);
 
     if (mSuspensionState != NULL) {
+#ifdef OMAP_ENHANCEMENT
+        if (mBuffersWithRenderer.size() == 0) {
+#else
         if (mLastVideoBuffer == NULL) {
+#endif
             //go into here if video is suspended again
             //after resuming without being played between
             //them
@@ -1804,20 +2458,50 @@ status_t AwesomePlayer::suspend() {
     state->mFlags = mFlags & (PLAYING | AUTO_LOOPING | LOOPING | AT_EOS);
     getPosition(&state->mPositionUs);
 
+#ifdef OMAP_ENHANCEMENT
+#ifdef TARGET_OMAP4
+    // FIXME: This caching of last frame crashes in L27x. Not used anyway, but check why.
+    // This should be removed after fill the code for (mBufferWithRenderer.size() > 0)
+    if (0) {
+#else /* TARGET_OMAP3 */
+    // Currently this code is used only by OMAP3.
+    if (mBuffersWithRenderer.size()) {
+#endif
+        size_t size = mBuffersWithRenderer[0]->range_length();
+#else
     if (mLastVideoBuffer) {
         size_t size = mLastVideoBuffer->range_length();
-
+#endif
         if (size) {
             int32_t unreadable;
+#ifdef OMAP_ENHANCEMENT
+            if (!mBuffersWithRenderer[0]->meta_data()->findInt32(
+                        kKeyIsUnreadable, &unreadable)
+                    || unreadable == 0) {
+                state->mLastVideoFrameSize = size;
+                state->mLastVideoFrame = malloc(size);
+
+#ifdef TARGET_OMAP4
+                // FIXME: here for OMAP4
+                // Please fill this part for OMAP4
+#else
+                memcpy(state->mLastVideoFrame,
+                   (const uint8_t *)mBuffersWithRenderer[0]->data()
+                        + mBuffersWithRenderer[0]->range_offset(),
+                   size);
+#endif
+#else
             if (!mLastVideoBuffer->meta_data()->findInt32(
                         kKeyIsUnreadable, &unreadable)
                     || unreadable == 0) {
                 state->mLastVideoFrameSize = size;
                 state->mLastVideoFrame = malloc(size);
+
                 memcpy(state->mLastVideoFrame,
-                       (const uint8_t *)mLastVideoBuffer->data()
-                            + mLastVideoBuffer->range_offset(),
-                       size);
+                   (const uint8_t *)mLastVideoBuffer->data()
+                        + mLastVideoBuffer->range_offset(),
+                   size);
+#endif
 
                 state->mVideoWidth = mVideoWidth;
                 state->mVideoHeight = mVideoHeight;
@@ -1890,6 +2574,10 @@ status_t AwesomePlayer::resume() {
 
         ((AwesomeLocalRenderer *)mVideoRenderer.get())->render(
                 state->mLastVideoFrame, state->mLastVideoFrameSize);
+#ifdef OMAP_ENHANCEMENT
+        mVideoRenderer.clear();
+        mVideoRenderer = NULL;
+#endif
     }
 
     if (state->mFlags & PLAYING) {
@@ -1913,6 +2601,46 @@ void AwesomePlayer::postAudioEOS() {
 void AwesomePlayer::postAudioSeekComplete() {
     postCheckAudioStatusEvent_l();
 }
+#ifdef OMAP_ENHANCEMENT
+void AwesomePlayer::releaseRenderedBuffer(const sp<IMemory>& mem){
+
+    bool buffer_released = false;
+    unsigned int i = 0;
+
+    for(i = 0; i < mBuffersWithRenderer.size(); i++){
+        if (mBuffersWithRenderer[i]->data() == mem->pointer()){
+            mBuffersWithRenderer[i]->release();
+            mBuffersWithRenderer.removeAt(i);
+            buffer_released = true;
+            break;
+        }
+    }
+
+    if (buffer_released == false)
+        LOGD("Something wrong... Overlay returned wrong buffer address(%p). This message is harmless if you just did a seek.", mem->pointer());
+}
+
+
+status_t AwesomePlayer::requestVideoCloneMode(bool enable) {
+    if (enable)
+    {
+        if ((mVideoMode != VID_MODE_CLONE) && (mVideoRenderer != NULL)) {
+            mVideoMode = VID_MODE_CLONE;
+            mVideoRenderer->requestRendererClone(enable);
+        }
+    }
+    else
+    {
+        if ((mVideoMode != VID_MODE_NORMAL) && (mVideoRenderer != NULL)) {
+            mVideoMode = VID_MODE_NORMAL;
+            mVideoRenderer->requestRendererClone(enable);
+        }
+    }
+    LOGD("CloneMode[%d]", mVideoMode);
+    return OK;
+}
+
+#endif
 
 }  // namespace android
 
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 89cb135..8eb665e 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -30,6 +30,11 @@
 #include <utils/String8.h>
 #include <cutils/properties.h>
 
+#if defined(OMAP_ENHANCEMENT) && (TARGET_OMAP4)
+#include <TICameraParameters.h>
+#include "OMX_TI_Video.h"
+#endif
+
 namespace android {
 
 struct CameraSourceListener : public CameraListener {
@@ -37,9 +42,14 @@ struct CameraSourceListener : public CameraListener {
 
     virtual void notify(int32_t msgType, int32_t ext1, int32_t ext2);
     virtual void postData(int32_t msgType, const sp<IMemory> &dataPtr);
-
+#ifdef OMAP_ENHANCEMENT
+    virtual void postDataTimestamp(
+            nsecs_t timestamp, int32_t msgType, const sp<IMemory>& dataPtr,
+            uint32_t offset=0, uint32_t stride=0);
+#else
     virtual void postDataTimestamp(
             nsecs_t timestamp, int32_t msgType, const sp<IMemory>& dataPtr);
+#endif
 
 protected:
     virtual ~CameraSourceListener();
@@ -67,12 +77,23 @@ void CameraSourceListener::postData(int32_t msgType, const sp<IMemory> &dataPtr)
          msgType, dataPtr->pointer(), dataPtr->size());
 }
 
+#ifdef OMAP_ENHANCEMENT
 void CameraSourceListener::postDataTimestamp(
-        nsecs_t timestamp, int32_t msgType, const sp<IMemory>& dataPtr) {
+        nsecs_t timestamp, int32_t msgType, const sp<IMemory>& dataPtr,
+        uint32_t offset, uint32_t stride)
+#else
+void CameraSourceListener::postDataTimestamp(
+        nsecs_t timestamp, int32_t msgType, const sp<IMemory>& dataPtr)
+#endif
+{
 
     sp<CameraSource> source = mSource.promote();
     if (source.get() != NULL) {
+#ifdef OMAP_ENHANCEMENT
+        source->dataCallbackTimestamp(timestamp/1000, msgType, dataPtr, offset, stride);
+#else
         source->dataCallbackTimestamp(timestamp/1000, msgType, dataPtr);
+#endif
     }
 }
 
@@ -82,11 +103,19 @@ static int32_t getColorFormat(const char* colorFormat) {
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420SP)) {
+#if defined(TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+        return OMX_COLOR_FormatYUV420PackedSemiPlanar;
+#else
         return OMX_COLOR_FormatYUV420SemiPlanar;
+#endif
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV422I)) {
+#if defined(TARGET_OMAP3) && defined(OMAP_ENHANCEMENT)
+        return OMX_COLOR_FormatCbYCrY;
+#else
         return OMX_COLOR_FormatYCbYCr;
+#endif
     }
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_RGB565)) {
@@ -99,6 +128,27 @@ static int32_t getColorFormat(const char* colorFormat) {
     CHECK_EQ(0, "Unknown color format");
 }
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+static int32_t getSEIEncodingType(const char* seiEncodingType)
+{
+    if (!strcmp(seiEncodingType, TICameraParameters::SEI_ENCODING_2004)) {
+       return OMX_TI_Video_AVC_2004_StereoInfoType;
+    }
+
+    if (!strcmp(seiEncodingType, TICameraParameters::SEI_ENCODING_2010)) {
+        return OMX_TI_Video_AVC_2010_StereoFramePackingType;
+    }
+
+    if (!strcmp(seiEncodingType, TICameraParameters::SEI_ENCODING_NONE)) {
+        return OMX_TI_Video_Progressive;
+    }
+
+    LOGE("Unsupported SEI encoding type (%s), reverting back to progressive", seiEncodingType);
+
+    return OMX_TI_Video_Progressive;
+}
+#endif
+
 // static
 CameraSource *CameraSource::Create() {
     sp<Camera> camera = Camera::connect(0);
@@ -149,7 +199,16 @@ CameraSource::CameraSource(const sp<Camera> &camera)
     }
 
     const char *colorFormatStr = params.get(CameraParameters::KEY_VIDEO_FRAME_FORMAT);
-    CHECK(colorFormatStr != NULL);
+    if (colorFormatStr == NULL) {
+#ifdef USE_YUV422I_DEFAULT_COLORFORMAT
+        // on some devices (such as sholes), the camera doesn't properly report what
+        // color format it needs, so we need to force it as a default
+        colorFormatStr = CameraParameters::PIXEL_FORMAT_YUV422I;
+#else
+        colorFormatStr = CameraParameters::PIXEL_FORMAT_YUV420SP;
+#endif
+    }
+
     int32_t colorFormat = getColorFormat(colorFormatStr);
 
     // XXX: query camera for the stride and slice height
@@ -165,6 +224,54 @@ CameraSource::CameraSource(const sp<Camera> &camera)
     mMeta->setInt32(kKeyStride, stride);
     mMeta->setInt32(kKeySliceHeight, sliceHeight);
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    int32_t paddedFrameWidth, paddedFrameHeight;
+    if (mCamera != 0) {
+        // Since we may not honor the preview size that app has requested
+        // It is a good idea to get the actual preview size and use it for video recording.
+        paddedFrameWidth = atoi(params.get("padded-width"));
+        paddedFrameHeight = atoi(params.get("padded-height"));
+        if (paddedFrameWidth < 0 || paddedFrameHeight < 0) {
+            LOGE("Failed to get camera(%p) preview size", mCamera.get());
+        }
+        LOGV("CameraSource() : padded WxH=%dx%d", paddedFrameWidth, paddedFrameHeight);
+    }
+    else
+    {
+        LOGE("mCamera is NULL");
+        paddedFrameWidth = width;
+        paddedFrameHeight = height;
+    }
+
+    mMeta->setInt32(kKeyPaddedWidth, paddedFrameWidth);
+    mMeta->setInt32(kKeyPaddedHeight, paddedFrameHeight);
+
+    int32_t  mS3DCamera = false;
+    if (mCamera != 0) {
+
+        if(params.get("s3d-supported")!= NULL && CameraParameters::TRUE != NULL)
+            mS3DCamera = strcmp(params.get("s3d-supported"), CameraParameters::TRUE) == 0;
+
+        if(mS3DCamera)
+        {
+            const char *seiEncodingTypeStr = params.get(TICameraParameters::KEY_SEI_ENCODING_TYPE);
+            CHECK(seiEncodingTypeStr != NULL);
+            int32_t seiEncodingType = getSEIEncodingType(seiEncodingTypeStr);
+            mMeta->setInt32(kKeySEIEncodingType, seiEncodingType);
+
+            const char *frameLayoutStr = params.get(TICameraParameters::KEY_S3D_FRAME_LAYOUT);
+            CHECK(frameLayoutStr != NULL);
+            mMeta->setCString(kKeyFrameLayout, frameLayoutStr);
+        }
+
+    }
+    else
+    {
+        LOGE("mCamera is NULL");
+        mS3DCamera = false;
+    }
+    mMeta->setInt32(kKeyS3dSupported, mS3DCamera);
+#endif
 }
 
 CameraSource::~CameraSource() {
@@ -279,11 +386,29 @@ status_t CameraSource::read(
     sp<IMemory> frame;
     int64_t frameTime;
 
+#if defined(OMAP_ENHANCEMENT) && (TARGET_OMAP4)
+    uint32_t frameOffset;
+#endif
     {
         Mutex::Autolock autoLock(mLock);
         while (mStarted) {
             while(mFramesReceived.empty()) {
-                mFrameAvailableCondition.wait(mLock);
+                if (mNumFramesReceived == 0) {
+                    /*
+                     * It's perfectly normal that we don't receive frames for quite some
+                     * time at record start, so don't use a timeout in that case.
+                     */
+                    mFrameAvailableCondition.wait(mLock);
+                } else {
+                    /*
+                     * Don't wait indefinitely for camera frames, buggy HALs may
+                     * fail to provide them in a timely manner under some conditions.
+                     */
+                    status_t err = mFrameAvailableCondition.waitRelative(mLock, 250000000);
+                    if (err) {
+                        return err;
+                    }
+                }
             }
 
             if (!mStarted) {
@@ -293,6 +418,10 @@ status_t CameraSource::read(
             frame = *mFramesReceived.begin();
             mFramesReceived.erase(mFramesReceived.begin());
 
+#if defined(OMAP_ENHANCEMENT) && (TARGET_OMAP4)
+            frameOffset = *mFrameOffset.begin();
+            mFrameOffset.erase(mFrameOffset.begin());
+#endif
             frameTime = *mFrameTimes.begin();
             mFrameTimes.erase(mFrameTimes.begin());
             int64_t skipTimeUs;
@@ -317,6 +446,9 @@ status_t CameraSource::read(
                 (*buffer)->add_ref();
                 (*buffer)->meta_data()->setInt64(kKeyTime, frameTime);
 
+#if defined(OMAP_ENHANCEMENT) && (TARGET_OMAP4)
+                (*buffer)->meta_data()->setInt32(kKeyOffset, frameOffset);
+#endif
                 return OK;
             }
         }
@@ -324,8 +456,15 @@ status_t CameraSource::read(
     return OK;
 }
 
+#ifdef OMAP_ENHANCEMENT
+void CameraSource::dataCallbackTimestamp(int64_t timestampUs,
+        int32_t msgType, const sp<IMemory> &data,
+        uint32_t offset, uint32_t stride)
+#else
 void CameraSource::dataCallbackTimestamp(int64_t timestampUs,
-        int32_t msgType, const sp<IMemory> &data) {
+        int32_t msgType, const sp<IMemory> &data)
+#endif
+{
     LOGV("dataCallbackTimestamp: timestamp %lld us", timestampUs);
     Mutex::Autolock autoLock(mLock);
     if (!mStarted) {
@@ -364,7 +503,19 @@ void CameraSource::dataCallbackTimestamp(int64_t timestampUs,
     mFrameTimes.push_back(timeUs);
     LOGV("initial delay: %lld, current time stamp: %lld",
         mStartTimeUs, timeUs);
+
+#if defined(OMAP_ENHANCEMENT) && (TARGET_OMAP4)
+    mFrameOffset.push_back(offset);
+#endif
+
     mFrameAvailableCondition.signal();
 }
 
+#ifdef USE_GETBUFFERINFO
+status_t CameraSource::getBufferInfo(sp<IMemory>& Frame, size_t *alignedSize)
+{
+    return mCamera->getBufferInfo(Frame, alignedSize);
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 49eac62..8280239 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -31,6 +31,10 @@
 #include <media/stagefright/MediaErrors.h>
 #include <utils/String8.h>
 
+#if defined(OMAP_ENHANCEMENT)
+#include "include/ASFExtractor.h"
+#endif
+
 namespace android {
 
 bool DataSource::getUInt16(off_t offset, uint16_t *x) {
@@ -104,6 +108,11 @@ void DataSource::RegisterDefaultSniffers() {
     RegisterSniffer(SniffAMR);
     RegisterSniffer(SniffMPEG2TS);
     RegisterSniffer(SniffMP3);
+#ifdef OMAP_ENHANCEMENT
+    if(isASFParserAvailable()){
+        RegisterSniffer(SniffASF);
+    }
+#endif
 }
 
 // static
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index 34064c8..cea7998 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -38,8 +38,44 @@
 #include <media/stagefright/Utils.h>
 #include <utils/String8.h>
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+#include "include/TISEIMessagesParser.h"
+#endif
+
 namespace android {
 
+#ifdef OMAP_ENHANCEMENT
+#define POS_ESDS_CANT_BE_FOUND(chunk_size) (chunk_size - 3)
+/*Array containing the pointers to known types. This should be read only*/
+    static const struct Mpeg4FileType{
+        const char *const type;
+        const uint8_t size;
+    } knownFileTypes[] = {
+    {"ftyp3gp", 7},
+    {"ftypmp42", 8},
+    {"ftyp3gr6", 8},
+    {"ftyp3gs6", 8},
+    {"ftyp3ge6", 8},
+    {"ftyp3gg6", 8},
+    {"ftypiso", 7},
+    {"ftypM4V ", 8},
+    {"ftypM4A ", 8},
+    {"ftypf4v ", 8},
+    {"ftypkddi", 8},
+    {"ftypM4VP", 8},
+    {"ftypqt", 6},
+    {"ftypmmp4", 8},
+    {"ftypmp41", 8},
+    {"ftypwmf",  7},
+    {"ftypMSNV", 8},
+    {"ftyp3g2", 7},
+    {"ftypskm2",8},
+    {"ftypavc1",8}
+    };
+/*Indicates the number of known types and it should be linked to variable knownFileTypes*/
+#define NUMBER_OF_KNOWN_FILE_TYPES (sizeof(knownFileTypes)/sizeof(struct Mpeg4FileType))
+#endif
+
 class MPEG4Source : public MediaSource {
 public:
     // Caller retains ownership of both "dataSource" and "sampleTable".
@@ -48,6 +84,9 @@ public:
                 int32_t timeScale,
                 const sp<SampleTable> &sampleTable);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    virtual void parseSEIMessages(S3D_params &mS3Dparams);
+#endif
     virtual status_t start(MetaData *params = NULL);
     virtual status_t stop();
 
@@ -70,7 +109,9 @@ private:
 
     bool mIsAVC;
     size_t mNALLengthSize;
-
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    size_t SEINALLength;
+#endif
     bool mStarted;
 
     MediaBufferGroup *mGroup;
@@ -249,6 +290,10 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('s', '2', '6', '3'):
             return MEDIA_MIMETYPE_VIDEO_H263;
 
+#ifdef OMAP_ENHANCEMENT
+        case FOURCC('H', '2', '6', '3'):
+            return MEDIA_MIMETYPE_VIDEO_H263;
+#endif
         case FOURCC('a', 'v', 'c', '1'):
             return MEDIA_MIMETYPE_VIDEO_AVC;
 
@@ -323,7 +368,31 @@ sp<MetaData> MPEG4Extractor::getTrackMetaData(
     if (track == NULL) {
         return NULL;
     }
-
+#ifdef OMAP_ENHANCEMENT
+    if (flags & kIncludeExtensiveMetaData){
+        track->includes_expensive_metadata = true;
+        const char *mime;
+        CHECK(track->meta->findCString(kKeyMIMEType, &mime));
+        if (!strncasecmp("video/", mime, 6)) {
+            uint32_t sampleIndex=0;
+            uint32_t sampleTime;
+            if (flags & kSelectFirstSample || track->sampleTable->findThumbnailSample(&sampleIndex) != OK){
+                /*It will be forced the frame zero which is supposed to
+                 *be an I frame every time.
+                 * */
+                LOGD("Forced first sample\n");
+                sampleIndex=0;
+            }
+            if (track->sampleTable->getMetaDataForSample(
+                        sampleIndex, NULL /* offset */, NULL /* size */,
+                        &sampleTime) == OK) {
+                track->meta->setInt64(
+                        kKeyThumbnailTime,
+                        ((int64_t)sampleTime * 1000000) / track->timescale);
+            }
+        }
+    }
+#else
     if ((flags & kIncludeExtensiveMetaData)
             && !track->includes_expensive_metadata) {
         track->includes_expensive_metadata = true;
@@ -343,7 +412,7 @@ sp<MetaData> MPEG4Extractor::getTrackMetaData(
             }
         }
     }
-
+#endif
     return track->meta;
 }
 
@@ -360,6 +429,36 @@ status_t MPEG4Extractor::readMetaData() {
     if (mHaveMetadata) {
         if (mHasVideo) {
             mFileMetaData->setCString(kKeyMIMEType, "video/mp4");
+#ifdef OMAP_ENHANCEMENT
+            Track *tempTrack = mFirstTrack;
+            int count = 0;
+            const char *mime;
+            while (tempTrack) {
+				CHECK(tempTrack->meta->findCString(kKeyMIMEType, &mime));
+
+				if (!strncasecmp("video/", mime, 6)) {
+
+					size_t totalframes;
+					int64_t duration;
+					int32_t dur32,fps;
+
+					fps = 0;
+                                        totalframes = tempTrack->sampleTable->countSamples();
+					tempTrack->meta->findInt64(kKeyDuration, &duration);
+
+					dur32 =  (int32_t) (duration / 1000000);
+                                        if(dur32 <=0){
+                                            //dur32 will be zero for clips < 1 second.
+                                            dur32 = 1;
+                                        }
+                                        fps = totalframes/dur32;
+                                        LOGV("totalframes %d duration %lld dur32 %d fps %d",totalframes,duration,dur32,fps);
+					tempTrack->meta->setInt32(kKeyVideoFPS,fps);
+				}
+				tempTrack= tempTrack->next;
+            }
+#endif
+
         } else {
             mFileMetaData->setCString(kKeyMIMEType, "audio/mp4");
         }
@@ -415,6 +514,12 @@ static void convertTimeToDate(int64_t time_1904, String8 *s) {
 
 status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
     uint32_t hdr[2];
+#ifdef  OMAP_ENHANCEMENT
+    // A copy of the unmodified offset; needed to skip unrecognized
+    // atoms (unrecognized by this logic means that its name isn't
+    // recognized in the switch below)
+    off_t originalOffset=*offset;
+#endif
     if (mDataSource->readAt(*offset, hdr, 8) < 8) {
         return ERROR_IO;
     }
@@ -433,11 +538,17 @@ status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
             // The smallest valid chunk is 16 bytes long in this case.
             return ERROR_MALFORMED;
         }
-    } else if (chunk_size < 8) {
+#ifdef OMAP_ENHANCEMENT
+    } else if ((chunk_size < 8) && (chunk_size != 0)){
         // The smallest valid chunk is 8 bytes long.
         return ERROR_MALFORMED;
     }
-
+#else
+    } else if (chunk_size < 8){
+        // The smallest valid chunk is 8 bytes long.
+        return ERROR_MALFORMED;
+    }
+#endif
     char chunk[5];
     MakeFourCCString(chunk_type, chunk);
 
@@ -480,7 +591,28 @@ status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
 
         return OK;
     }
+#ifdef OMAP_ENHANCEMENT
+    {
+        union {
+            uint32_t chunk;
+            uint8_t t[4];
+        }chnk;
+        chnk.chunk=chunk_type;
+        LOGV("Chunk: %c%c%c%c\n", chnk.t[3],chnk.t[2],chnk.t[1],chnk.t[0]);
+    }
+
+    // If the size of the atom is zero, then this is an empty atom that
+    //  needs to be skipped; the way to skip it is by making its size 4,
+    //  so the next time the instruction *offset += chunk_size happen
+    //  the atom be skipped and it doesn't cause the parser enter in
+    //  aninfinite loop.
+    //  (*offset would be pointing to the same place again and again if
+    //  chunk_size is zero)
 
+    if (!chunk_size){
+        chunk_size=4;
+    }
+#endif
     switch(chunk_type) {
         case FOURCC('m', 'o', 'o', 'v'):
         case FOURCC('t', 'r', 'a', 'k'):
@@ -693,6 +825,153 @@ status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
         case FOURCC('m', 'p', '4', 'a'):
         case FOURCC('s', 'a', 'm', 'r'):
         case FOURCC('s', 'a', 'w', 'b'):
+#ifdef OMAP_ENHANCEMENT
+        {
+            // This pointer will hold the address of a buffer with the
+            // data content inside the mp4a, samr or sawb atoms.
+
+            uint8_t *buffer;
+
+            // Allocate buffer content
+
+            if (!(buffer = (uint8_t *)malloc(chunk_size))){
+                LOGD("Error allocating memory\n");
+                *offset += chunk_size;
+                return ERROR_OUT_OF_MEM;
+            }
+            // Fill out the buffer with the data
+
+            if (mDataSource->readAt(
+                        data_offset, buffer, chunk_size) < (ssize_t) chunk_size) {
+                free(buffer);
+                return ERROR_IO;
+            }
+            uint16_t data_ref_index = 0;
+            uint16_t num_channels = 0;
+            uint16_t sample_size = 0;
+            uint32_t sample_rate = 0;
+            if (chunk_size >= 25){
+                data_ref_index = U16_AT(&buffer[6]);
+                num_channels = U16_AT(&buffer[16]);
+
+                sample_size = U16_AT(&buffer[18]);
+                sample_rate = U32_AT(&buffer[24]) >> 16;
+            }
+
+            if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB,
+                            FourCC2MIME(chunk_type))) {
+                // AMR NB audio is always mono, 8kHz
+                num_channels = 1;
+                sample_rate = 8000;
+            } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_WB,
+                               FourCC2MIME(chunk_type))) {
+                // AMR WB audio is always mono, 16kHz
+                num_channels = 1;
+                sample_rate = 16000;
+            }
+
+            LOGV("*** coding='%s' %d channels, size %d, rate %d\n",
+                   chunk, num_channels, sample_size, sample_rate);
+
+            mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));
+            mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);
+            mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);
+
+            // The following section of code is like a parser that
+            // replaces the complete processing of the atoms mp4a, samr,
+            // and sawb.
+            // For each case, ideally there should be different parsers,
+            // but all should yield to the position of the esds atom.
+            // A search for a string is implemented (something like
+            // strstr but for chains that can have '\0' chars in the
+            // stream)
+            // In fact the code below is a modification of strstr
+
+
+            //s will store the position of the esds atom
+            uint8_t * s = (uint8_t *)buffer;
+            {
+                char c, sc;
+                // This is a modification of strstr; since
+                // '\0' is allowed, the stop logic will work
+                // by knowing the size of the array (instead of looking
+                // for '/0')
+
+                unsigned int count = 0;
+                // This is the tag that needs to be found.
+
+                const char * find = "esds";
+                c = *find++;
+                do {
+                    do {
+                        sc = *s++;
+                        count++;
+                    } while (sc != c && count < POS_ESDS_CANT_BE_FOUND(chunk_size));
+                } while ((memcmp(s, find, 3)) && count < POS_ESDS_CANT_BE_FOUND(chunk_size));
+                s--;
+            }
+
+            // The stop offset indicates the place where the current
+            // atom should end.
+
+            off_t stop_offset = *offset + chunk_size;
+            // Check if the parsing succeeded or not. If it didn't,
+            // there is still chance to properly play the file so no
+            // error will be reported, yet.
+
+            if (s==buffer + POS_ESDS_CANT_BE_FOUND(chunk_size)
+                || !(s-buffer)){
+                LOGD("esds not found continue parsing next atoms\n");
+                *offset = stop_offset;
+                free(buffer);
+                break;
+            }
+
+            // esds atom was found. Set the offset to the place where
+            // the atom was found, and rewind 4 bytes in order to seek
+            // from the place the atom's size is found.
+
+            *offset = data_offset + (s - buffer) - 4;
+
+            // Information found or not found, there is no need for
+            // the buffer anymore.
+
+            free(buffer);
+
+            // Parse esds atom
+
+            while (*offset < stop_offset) {
+                status_t err = parseChunk(offset, depth + 1);
+                if (err != OK) {
+                    // If the esds atom couldn't be parsed, then try to
+                    // continue parsing the other atoms and use the
+                    // default values.
+
+                    LOGD("Malformed\n");
+                    LOGD("Error while parsing audio metadata, should use default settings\n");
+                }
+            }
+
+            // This error will not be forgiven since this indicates
+            // the esds parser jumped above the size of the atom and
+            // attempted to read more information than what was
+            // contained in esds. (Case when the parser reads all the
+            // info and expects to find more, but it can't)
+            // However, if the offset is smaller, then the esds parser
+            // wasn't able to complete its parsing, this could be due
+            // to the fact it couldn't recognize a pattern in the esds
+            // atom; This indicates that some information could have
+            // been extracted from the esds, but not all and this parser
+            // will attempt to continue launching the application with
+            // the collected information (which may not be complete).
+
+            if (*offset > stop_offset) {
+                return ERROR_MALFORMED;
+            }
+
+            break;
+        }
+#else
         {
             uint8_t buffer[8 + 20];
             if (chunk_data_size < (ssize_t)sizeof(buffer)) {
@@ -746,9 +1025,12 @@ status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
             }
             break;
         }
-
+#endif
         case FOURCC('m', 'p', '4', 'v'):
         case FOURCC('s', '2', '6', '3'):
+#ifdef OMAP_ENHANCEMENT
+        case FOURCC('H', '2', '6', '3'):
+#endif
         case FOURCC('a', 'v', 'c', '1'):
         {
             mHasVideo = true;
@@ -847,6 +1129,21 @@ status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
             break;
         }
 
+#ifdef OMAP_ENHANCEMENT
+        case FOURCC('c', 't', 't', 's'):
+        {
+            status_t err =
+                mLastTrack->sampleTable->setTimeToSampleParamsCtts(
+                        data_offset, chunk_data_size);
+
+            if (err != OK) {
+                return err;
+            }
+
+            *offset += chunk_size;
+            break;
+        }
+#endif
         case FOURCC('s', 't', 't', 's'):
         {
             status_t err =
@@ -910,6 +1207,11 @@ status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
                         &buffer[4], chunk_data_size - 4);
 
                 if (err != OK) {
+#ifdef OMAP_ENHANCEMENT
+                    LOGD("Error retrieving audio metadata, attempt to "
+                    "continue by skipping the atom\n");
+                    *offset += chunk_size;
+#endif
                     return err;
                 }
             }
@@ -1020,9 +1322,29 @@ status_t MPEG4Extractor::parseChunk(off_t *offset, int depth) {
             break;
         }
 
+#ifdef OMAP_ENHANCEMENT
+        case FOURCC('d', 'a', 'm', 'r'):
+        {
+             // validate chunk size of damr ATOM
+             if((chunk_data_size > 9)||(chunk_data_size < 0)){
+                 LOGV(" Chunk data size is INVALID ");
+                 return ERROR_MALFORMED;
+             }
+
+             *offset += chunk_size;
+             break;
+        }
+#endif
+
         default:
         {
+#ifdef OMAP_ENHANCEMENT
+            // Skip this unknown atom
+
+            *offset = originalOffset + chunk_size;
+#else
             *offset += chunk_size;
+#endif
             break;
         }
     }
@@ -1376,10 +1698,6 @@ status_t MPEG4Extractor::updateAudioTrackInfoFromESDS_MPEG4Audio(
         numChannels = (csd[1] >> 3) & 15;
     }
 
-    if (numChannels == 0) {
-        return ERROR_UNSUPPORTED;
-    }
-
     int32_t prevSampleRate;
     CHECK(mLastTrack->meta->findInt32(kKeySampleRate, &prevSampleRate));
 
@@ -1417,6 +1735,9 @@ MPEG4Source::MPEG4Source(
       mCurrentSampleIndex(0),
       mIsAVC(false),
       mNALLengthSize(0),
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+      SEINALLength(0),
+#endif
       mStarted(false),
       mGroup(NULL),
       mBuffer(NULL),
@@ -1450,6 +1771,88 @@ MPEG4Source::~MPEG4Source() {
     }
 }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+void MPEG4Source::parseSEIMessages(S3D_params &mS3Dparams) {
+    status_t stats=0;
+
+    if (mIsAVC) {
+        int32_t max_size;
+        CHECK(mFormat->findInt32(kKeyMaxInputSize, &max_size));
+
+        int nalType, nalRefIdc;
+        status_t res;
+        size_t srcOffset = 0, size;
+
+        MediaBuffer *out = NULL;
+        uint8_t *myData;
+
+        status_t err = this->start();
+        if (err != OK)
+            goto EXIT;
+
+        err = read(&out);
+        if (err != OK)
+            goto EXIT;
+
+        myData = (uint8_t *)out->data();
+        // Getting the size read
+        size = out->size();
+        while (srcOffset < (size-4)) {
+            if((myData[srcOffset] == 0) &&
+                (myData[srcOffset+1] == 0) &&
+                (myData[srcOffset+2] == 0) &&
+                (myData[srcOffset+3] == 1))
+            {
+                srcOffset +=mNALLengthSize;
+                res = AVCGetNALType(&myData[srcOffset], (size-(srcOffset +mNALLengthSize)),&nalType, &nalRefIdc);
+                if (res)
+                {
+                    LOGE("FAILED Cannot determine nal type");
+                    goto EXIT;
+                }
+
+                switch (nalType)
+                {
+                    case AVC_NALTYPE_SEI:
+                    {
+                        LOGV("Calling DecodeSEI() \n");
+                        res = sei_rbsp(&myData[srcOffset], SEINALLength, mS3Dparams);//(size-(srcOffset +mNALLengthSize))
+                        if(res)
+                        {
+                            LOGE("FAILED parsing SEI messages \n");
+                            goto EXIT;
+                        }
+                        break;
+                    }
+                    default:
+                    {
+                        LOGV("Default value for NALType %d \n", nalType);
+                        break;
+                    }
+                }
+            }
+            else
+            {
+                srcOffset++;
+                if (srcOffset + mNALLengthSize>= size)
+                {
+                    LOGV("No more NAL Unit \n");
+                    goto EXIT;
+                }
+            }
+        }
+
+        EXIT:
+        if(out != NULL)
+        {
+            out->release();
+            out = NULL;myData=NULL;
+        }
+       this->stop();
+    }
+}
+#endif
+
 status_t MPEG4Source::start(MetaData *params) {
     Mutex::Autolock autoLock(mLock);
 
@@ -1530,7 +1933,9 @@ status_t MPEG4Source::read(
 
     CHECK(mStarted);
 
+#if !defined(TARGET_OMAP4)
     *out = NULL;
+#endif
 
     int64_t targetSampleTimeUs = -1;
 
@@ -1618,7 +2023,11 @@ status_t MPEG4Source::read(
     uint32_t dts;
     bool isSyncSample;
     bool newBuffer = false;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    if (mBuffer == NULL || (*out && !mWantsNALFragments)) {
+#else
     if (mBuffer == NULL) {
+#endif
         newBuffer = true;
 
         status_t err =
@@ -1629,7 +2038,15 @@ status_t MPEG4Source::read(
             return err;
         }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        if (NULL == *out || mWantsNALFragments) {
+            err = mGroup->acquire_buffer(&mBuffer);
+        } else {
+            mBuffer = *out;
+        }
+#else
         err = mGroup->acquire_buffer(&mBuffer);
+#endif
 
         if (err != OK) {
             CHECK(mBuffer == NULL);
@@ -1650,6 +2067,12 @@ status_t MPEG4Source::read(
             }
 
             CHECK(mBuffer != NULL);
+#ifdef OMAP_ENHANCEMENT
+            if(mSampleTable->mTimeToSampleCtts) {
+                dts += mSampleTable->mTimeToSampleCtts[mCurrentSampleIndex];
+            }
+#endif
+
             mBuffer->set_range(0, size);
             mBuffer->meta_data()->clear();
             mBuffer->meta_data()->setInt64(
@@ -1712,7 +2135,53 @@ status_t MPEG4Source::read(
     } else {
         // Whole NAL units are returned but each fragment is prefixed by
         // the start code (0x00 00 00 01).
+#ifdef OMAP_ENHANCEMENT
+        uint8_t *dstData = (uint8_t *)mBuffer->data();
+        size_t srcOffset = 0;
+        size_t dstOffset = 0;
 
+        while (srcOffset < size) {
+            CHECK(srcOffset + mNALLengthSize <= size);
+            ssize_t num_bytes_read = mDataSource->readAt(offset+srcOffset, mSrcBuffer, mNALLengthSize);
+            if (num_bytes_read < (ssize_t)mNALLengthSize) {
+                mBuffer->release();
+                mBuffer = NULL;
+                return ERROR_IO;
+            }
+            size_t nalLength = parseNALSize(&mSrcBuffer[0]);
+            srcOffset += mNALLengthSize;
+            if (srcOffset + nalLength > size) {
+                mBuffer->release();
+                mBuffer = NULL;
+                return ERROR_MALFORMED;
+            }
+
+            if (nalLength == 0) {
+                continue;
+            }
+
+            CHECK(dstOffset + 4 <= mBuffer->size());
+
+            dstData[dstOffset++] = 0;
+            dstData[dstOffset++] = 0;
+            dstData[dstOffset++] = 0;
+            dstData[dstOffset++] = 1;
+            num_bytes_read = mDataSource->readAt(offset+srcOffset, &dstData[dstOffset], nalLength);
+            if (num_bytes_read < (ssize_t)nalLength) {
+                 mBuffer->release();
+                 mBuffer = NULL;
+                 return ERROR_IO;
+            }
+#if defined(TARGET_OMAP4)
+            // Getting NAL length for SEI messages Gilles
+            if(dstData[dstOffset] == AVC_NALTYPE_SEI)
+                SEINALLength = nalLength;
+#endif
+            srcOffset += nalLength;
+            dstOffset += nalLength;
+        }
+        CHECK_EQ(srcOffset, size);
+#else
         ssize_t num_bytes_read =
             mDataSource->readAt(offset, mSrcBuffer, size);
 
@@ -1754,10 +2223,16 @@ status_t MPEG4Source::read(
             dstOffset += nalLength;
         }
         CHECK_EQ(srcOffset, size);
+#endif
 
         CHECK(mBuffer != NULL);
         mBuffer->set_range(0, dstOffset);
         mBuffer->meta_data()->clear();
+#ifdef OMAP_ENHANCEMENT
+        if(mSampleTable->mTimeToSampleCtts)
+            dts = dts + mSampleTable->mTimeToSampleCtts[mCurrentSampleIndex];
+#endif
+
         mBuffer->meta_data()->setInt64(
                 kKeyTime, ((int64_t)dts * 1000000) / mTimescale);
 
@@ -1866,7 +2341,217 @@ static bool BetterSniffMPEG4(
 
     return true;
 }
+#ifdef OMAP_ENHANCEMENT
+bool positionFileAtAtom (const sp<DataSource> &source, uint32_t &offsetToNextAtom, const char *patern, off_t fileSize, uint32_t &atomSize) {
+    /*Fail safe counter*/
+    uint32_t failSafe = 0;
+    /*Stores the return value from comparations*/
+    int memCompRetVal;
+    /*Stores the analyzed atom's name and size*/
+    struct {
+        union {
+            uint32_t size;
+            uint8_t sizeArray[4];
+        } atomSize;
+        uint8_t  atomName[4];
+    } atomNameAndSize;
+
+    /*Check parameters*/
+
+    /*Init Atom Size to null*/
+    atomNameAndSize.atomSize.size = 0;
+
+    do {
+        /*increment the fail safe counter*/
+        failSafe++;
+
+        /*Jump to the next atom and read its type*/
+
+        /*Compute offset where the atom is stored*/
+        offsetToNextAtom += atomNameAndSize.atomSize.size;
+
+        /*Check the size is within the file size. Currently this is limited to a file of 2GB*/
+        if (fileSize > 0 && offsetToNextAtom >= (unsigned)fileSize) {
+            /*Bad offset*/
+            return false;
+        }
+
+
+        /*Read the cached info*/
+        if (source->readAt(offsetToNextAtom, &atomNameAndSize, sizeof(atomNameAndSize)) < (signed)sizeof(atomNameAndSize)) {
+            /*Couldnt read the atom's type and size*/
+            LOGD("Couldnt find next atom");
+            return false;
+        }
 
+        /*The size is in big endian, so it is necesary to convert the value so it can be used*/
+        /*Swap the framing bytes*/
+        atomNameAndSize.atomSize.sizeArray[0] ^= atomNameAndSize.atomSize.sizeArray[3];
+        atomNameAndSize.atomSize.sizeArray[3] ^= atomNameAndSize.atomSize.sizeArray[0];
+        atomNameAndSize.atomSize.sizeArray[0] ^= atomNameAndSize.atomSize.sizeArray[3];
+        /*Swap the middle bytes*/
+        atomNameAndSize.atomSize.sizeArray[1] ^= atomNameAndSize.atomSize.sizeArray[2];
+        atomNameAndSize.atomSize.sizeArray[2] ^= atomNameAndSize.atomSize.sizeArray[1];
+        atomNameAndSize.atomSize.sizeArray[1] ^= atomNameAndSize.atomSize.sizeArray[2];
+
+        LOGD("Atom found: %c%c%c%c with size = %x\n", atomNameAndSize.atomName[0], atomNameAndSize.atomName[1], atomNameAndSize.atomName[2], atomNameAndSize.atomName[3], atomNameAndSize.atomSize.size);
+    } while ((memCompRetVal = memcmp(atomNameAndSize.atomName, patern, 4))  && atomNameAndSize.atomSize.size && atomNameAndSize.atomSize.size >= 8 && failSafe < 10 && (offsetToNextAtom+atomNameAndSize.atomSize.size) < (unsigned)fileSize);
+
+
+    /*Check if the atom was found or that the iterations ended due to an error*/
+    if ((memCompRetVal) && ((offsetToNextAtom+atomNameAndSize.atomSize.size) < (unsigned)fileSize)) {
+        /*Didn't find it return with no success*/
+        return false;
+    }
+
+    /*If this point is reach the atom was found*/
+    atomSize = atomNameAndSize.atomSize.size;
+    return true;
+}
+
+bool SniffMPEG4(const sp<DataSource> &source, String8 *mimeType, float *confidence, sp<AMessage> *) {
+
+    /*Stores the ftyp type*/
+    uint8_t header[8];
+    /*Stores the return value from comparations*/
+    int memCompRetVal;
+
+    /*Read the header*/
+    if (source->readAt(4, header, sizeof(header)) < (signed)sizeof(header)) {
+        /*Couldnt read ftyp's atom's type*/
+        LOGD("Couldnt read ftyps atom type");
+        return false;
+    }
+
+    /*Look for known type headers*/
+    memCompRetVal = true;
+
+    for (int i = 0; i < NUMBER_OF_KNOWN_FILE_TYPES; i++) {
+        if (!(memCompRetVal = memcmp(header, knownFileTypes[i].type, knownFileTypes[i].size))) {
+            /*header has been found*/
+            break;
+        }
+    }
+
+#ifdef OMAP_ENHANCEMENT
+    bool mdat_result = memcmp(header, "mdat", 4);
+
+    /*Exit if the pattern wasn't found*/
+    if (memCompRetVal && mdat_result ) {
+#else
+    if (memCompRetVal) {
+#endif
+        /*Couldn't find the pattern*/
+#ifdef OMAP_ENHANCEMENT
+        LOGE("both mdat,ftyp not found");
+#endif
+        return false;
+    }
+
+    /*header has been found set the confidence to .1*/
+    *confidence=0.1f;
+    *mimeType = MEDIA_MIMETYPE_CONTAINER_MPEG4;
+
+    /*See if the confidence can be increased
+     *since the header was found the result will be true in any case
+     *the only thing that would change is the confidence.*/
+
+    /*The file type matched one in the known list, look for the track indicating a video handler*/
+    {
+        /*Stores the file size this is a signed value compared to the unsigned value used to store the atom's sizes*/
+        off_t fileSize;
+        /*Stores the computed offset to the new atom*/
+        uint32_t offsetToSeek;
+        /*Stores the atom's size*/
+        uint32_t atomSize;
+        /*fail safe counter*/
+        uint8_t failCounter;
+        /*Handler type*/
+        uint8_t handler[4];
+        /*Location of the first track atom*/
+        uint32_t trakOffset;
+        /*Stores the atom's track size*/
+        uint32_t trakSize;
+
+        /*Initialize the file size variable*/
+        if (source->getSize(&fileSize)) {
+            /*couldn't get the file size nor increase confidence*/
+            return true;
+        }
+
+        /*Look for the moov atom from the begining of the file*/
+        offsetToSeek = 0;
+
+        if (!positionFileAtAtom(source, offsetToSeek, "moov", fileSize, atomSize)) {
+            /*Couldn't find moov atom, return true as header was found*/
+            return true;
+        }
+
+        /*Once the moov atom has been found inspect each of the trak atoms looking for the vide handler*/
+        failCounter = 0;
+        /*Skip the header of the moov atom*/
+        offsetToSeek += 8;
+
+        do {
+            failCounter++;
+
+            if (!positionFileAtAtom(source, offsetToSeek, "trak", fileSize, atomSize)) {
+                /*Couldn't find trak atom, return true as the header was found*/
+                return true;
+            }
+
+            /*Store the position of the track atom and its size for future references*/
+            trakOffset = offsetToSeek;
+            trakSize = atomSize;
+
+            /*Look for the mdia atom inside the trak atom*/
+            /*Skip the header of the atom*/
+            offsetToSeek += 8;
+
+            if (!positionFileAtAtom(source, offsetToSeek, "mdia", fileSize, atomSize)) {
+                /*Couldn't find mdia atom, return true as header was found*/
+                return true;
+            }
+
+            /*Look for the hdlr atom inside the mdia atom*/
+            /*Skip the header of the atom*/
+            offsetToSeek += 8;
+
+            if (!positionFileAtAtom(source, offsetToSeek, "hdlr", fileSize, atomSize)) {
+                /*Couldn't find hdlr atom, return true as header was found*/
+                return true;
+            }
+
+            /*Read the handler*/
+            /*Adjust the offset to skip the null information*/
+            offsetToSeek += 0x10;
+
+            if (source->readAt(offsetToSeek, &handler, sizeof(handler)) < sizeof(handler)) {
+                /*Couldnt read the atom's type and size*/
+                LOGD("Couldnt read the handler");
+                return true;
+            }
+
+            /*Adjust the offset to look for the next trak atom*/
+            offsetToSeek = trakOffset + trakSize;
+        } while (memCompRetVal = memcmp(handler, "vide", 4) && failCounter < 10 && (offsetToSeek < fileSize));
+
+       /*For some clips which have only audio track, the above loop goes till the end of the file,
+       * without finding video handler, this is not an issue. And there is no string match for audio track,
+       * becuase such clips are found to be having NULL string for handler component name.
+       * Here the count 10 restricts us to allow the audio only clips having maximum of 10 tracks, which may be acceptable.
+       */
+        if ((memCompRetVal) && (offsetToSeek < fileSize)) {
+            return true;
+        }
+
+        /*Vide handler was found!!!*/
+        *confidence = 0.4;
+
+        return true;
+    }
+}
+#else
 bool SniffMPEG4(
         const sp<DataSource> &source, String8 *mimeType, float *confidence,
         sp<AMessage> *) {
@@ -1881,6 +2566,6 @@ bool SniffMPEG4(
 
     return false;
 }
-
+#endif
 }  // namespace android
 
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
old mode 100644
new mode 100755
index 7eb7d46..8e0ec89
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -41,6 +41,10 @@ namespace android {
 static const int64_t kMax32BitFileSize = 0x007fffffffLL;
 static const uint8_t kNalUnitTypeSeqParamSet = 0x07;
 static const uint8_t kNalUnitTypePicParamSet = 0x08;
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+static const uint8_t kNalUnitTypeH264Sei = 0x06;
+static const uint8_t kNalUnitTypeH264IFrame = 0x5;
+#endif
 
 // Using longer adjustment period to suppress fluctuations in
 // the audio encoding paths
@@ -211,6 +215,19 @@ private:
 
     Track(const Track &);
     Track &operator=(const Track &);
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    bool misOutofOrderTimestamps;
+    struct TSTableEntry {
+        TSTableEntry(uint32_t count, uint64_t timestampUs)
+            : sampleCount(count), sampleTimestampUs(timestampUs) {}
+        uint32_t sampleCount;
+        uint64_t sampleTimestampUs;
+    };
+
+    List<TSTableEntry> mPresentationTimeStamp;
+    List<TSTableEntry> mDecodeTimeStamp;
+    void sortPresentationTimestamp(List<TSTableEntry> &DecodingTS);
+#endif
 };
 
 MPEG4Writer::MPEG4Writer(const char *filename)
@@ -714,6 +731,44 @@ static void StripStartcode(MediaBuffer *buffer) {
         return;
     }
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP3)
+    uint8_t *data =
+        (uint8_t *)buffer->data() + buffer->range_offset();
+    size_t size = buffer->range_length();
+    uint8_t *tmp = data;
+    uint8_t *foundStartData = data;
+    size_t bytesLeft = size;
+    size_t nal_size;
+    bool foundStartCode = false;
+
+    while (bytesLeft > 4) {
+        if (!memcmp("\x00\x00\x00\x01", tmp, 4)) {
+            if (tmp - foundStartData) {
+                if (foundStartCode == true) {
+                    nal_size = tmp - foundStartData - 4;
+                    foundStartData[0] = nal_size >> 24;
+                    foundStartData[1] = (nal_size >> 16) & 0xFF;
+                    foundStartData[2] = (nal_size >> 8) & 0xFF;
+                    foundStartData[3] = nal_size & 0xFF;
+                }
+                foundStartData = tmp;
+            }
+            foundStartCode = true;
+            tmp += 4;
+            bytesLeft -= 4;
+        } else {
+            bytesLeft--;
+            tmp++;
+        }
+    }
+    if (foundStartCode == true) {
+        nal_size = data + size - foundStartData - 4;
+        foundStartData[0] = nal_size >> 24;
+        foundStartData[1] = (nal_size >> 16) & 0xFF;
+        foundStartData[2] = (nal_size >> 8) & 0xFF;
+        foundStartData[3] = nal_size & 0xFF;
+    }
+#else
     const uint8_t *ptr =
         (const uint8_t *)buffer->data() + buffer->range_offset();
 
@@ -721,6 +776,7 @@ static void StripStartcode(MediaBuffer *buffer) {
         buffer->set_range(
                 buffer->range_offset() + 4, buffer->range_length() - 4);
     }
+#endif
 }
 
 off_t MPEG4Writer::addLengthPrefixedSample_l(MediaBuffer *buffer) {
@@ -987,6 +1043,40 @@ void MPEG4Writer::Track::addOneSttsTableEntry(
     mSttsTableEntries.push_back(sttsEntry);
     ++mNumSttsTableEntries;
 }
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+void MPEG4Writer::Track::sortPresentationTimestamp(List<TSTableEntry> &DecodingTS)
+{
+    int i, j, flag = 1;    // set flag to 1 to start first pass
+    TSTableEntry temp(0,0);             // holding variable
+    size_t numLength = DecodingTS.size();
+    List<TSTableEntry>::iterator it = DecodingTS.begin();
+    List<TSTableEntry>::iterator ittemp1;
+    List<TSTableEntry>::iterator ittemp2;
+    //Initalize the variable to zero
+    //Out of order flag should be set for Bframe
+    //scenario. If this is set the ctts structure
+    //preparation is mandatory.
+    misOutofOrderTimestamps = 0;
+    it = DecodingTS.begin();
+    for(i = 1; (i <= numLength) && flag; i++) {
+        ittemp1 = it;
+        flag = 0;
+        for (j = 0; j < (numLength -1); j++) {
+            ittemp2 = ittemp1;
+            ittemp1 ++;
+            if (ittemp1->sampleTimestampUs < ittemp2->sampleTimestampUs){
+                temp = *ittemp2;             // swap elements
+                *ittemp2 = *ittemp1;
+                *ittemp1 = temp;
+                flag = 1;               // indicates that a swap occurred.
+                //This means that we have out of order
+                //timestamps and bframes are present
+                misOutofOrderTimestamps = 1;
+            }
+        }
+    }
+}
+#endif
 
 void MPEG4Writer::Track::addChunkOffset(off_t offset) {
     ++mNumStcoTableEntries;
@@ -1103,9 +1193,13 @@ void MPEG4Writer::writeFirstChunk(ChunkInfo* info) {
     for (List<MediaBuffer *>::iterator it = chunkIt->mSamples.begin();
          it != chunkIt->mSamples.end(); ++it) {
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP3)
+        off_t offset = addSample_l(*it);
+#else
         off_t offset = info->mTrack->isAvc()
                             ? addLengthPrefixedSample_l(*it)
                             : addSample_l(*it);
+#endif
         if (it == chunkIt->mSamples.begin()) {
             info->mTrack->addChunkOffset(offset);
         }
@@ -1244,6 +1338,9 @@ status_t MPEG4Writer::Track::start(MetaData *params) {
 
     sp<MetaData> meta = new MetaData;
     meta->setInt64(kKeyTime, startTimeUs);
+    int32_t bitRate = 0;
+    params->findInt32(kKeyBitRate, &bitRate);
+    mMeta->setInt32(kKeyBitRate, bitRate);
     status_t err = mSource->start(meta.get());
     if (err != OK) {
         mDone = mReachedEOS = true;
@@ -1338,6 +1435,48 @@ static const uint8_t *findNextStartCode(
     return &data[length - bytesLeft];
 }
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+static const uint16_t getLengthNalUnit(
+        const uint8_t *data, size_t length) {
+
+    LOGV("getLengthNalUnit: %p %d", data, length);
+
+    size_t bytesLeft = length;
+    uint16_t NalUnitLength = 0;
+    while (bytesLeft > 4  &&
+            memcmp("\x00\x00\x00\x01", &data[length - bytesLeft], 4)) {
+        --bytesLeft;
+        NalUnitLength++;
+    }
+    return (NalUnitLength + 4);
+}
+
+static void StripSpsPps(MediaBuffer *buffer) {
+   const uint8_t *ptr = (const uint8_t *)buffer->data() + buffer->range_offset();
+   const uint8_t *nextStartCode = ptr;
+   size_t bytesLeft = buffer->range_length();
+   uint8_t type = 0;
+   uint16_t nalLength = 0;
+
+    while (bytesLeft > 4 && !memcmp("\x00\x00\x00\x01", ptr, 4)) {
+        getNalUnitType(*(ptr + 4), &type);
+        if (type == kNalUnitTypeH264IFrame) {
+            LOGV("Got the sync frame. Break out.");
+            break;
+        }
+        // Strip SPS, PPS or SEI info if any
+        else if (type == kNalUnitTypeSeqParamSet || type == kNalUnitTypePicParamSet ) {
+            nalLength = getLengthNalUnit(ptr+4,bytesLeft-4);
+            LOGV("Stripping Nal Type 0x%x, Nal-Length %d",type,nalLength);
+            buffer->set_range(buffer->range_offset() + nalLength, buffer->range_length() - nalLength);
+        }
+        nextStartCode = findNextStartCode(ptr+4,bytesLeft-4);
+        bytesLeft -= nextStartCode - ptr;
+        ptr = nextStartCode;
+    }
+}
+#endif
+
 const uint8_t *MPEG4Writer::Track::parseParamSet(
         const uint8_t *data, size_t length, int type, size_t *paramSetLen) {
 
@@ -1474,8 +1613,13 @@ status_t MPEG4Writer::Track::parseAVCCodecSpecificData(
     {
         // Check on the profiles
         // These profiles requires additional parameter set extensions
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+        if (mProfileIdc == 110 || mProfileIdc == 122 || mProfileIdc == 144) {
+#else
         if (mProfileIdc == 100 || mProfileIdc == 110 ||
             mProfileIdc == 122 || mProfileIdc == 144) {
+#endif
             LOGE("Sorry, no support for profile_idc: %d!", mProfileIdc);
             return BAD_VALUE;
         }
@@ -1710,6 +1854,10 @@ status_t MPEG4Writer::Track::threadEntry() {
     uint32_t previousSampleSize = 0;  // Size of the previous sample
     int64_t previousPausedDurationUs = 0;
     int64_t timestampUs;
+#if (defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3)) || defined(OMAP_COMPAT)
+    uint8_t *copy_spspps;
+    int32_t copy_spspps_size = 0;
+#endif
 
     if (mIsAudio) {
         prctl(PR_SET_NAME, (unsigned long)"AudioTrackEncoding", 0, 0, 0);
@@ -1766,20 +1914,112 @@ status_t MPEG4Writer::Track::threadEntry() {
             mGotAllCodecSpecificData = true;
             continue;
         }
+#if (defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3)) || defined(OMAP_COMPAT)
+        else if (mIsAvc && count < 3) {
+            size_t size = buffer->range_length();
+            size_t start_code_size = 0;
+
+            CHECK(!mGotAllCodecSpecificData);
+
+            start_code_size = memcmp("\x00\x00\x00\x01",
+                    (uint8_t *)buffer->data(), 4) ? 4 : 0;
+
+            switch (count) {
+                case 1:
+                {
+                    copy_spspps = (uint8_t *)malloc(size + start_code_size);
+                    copy_spspps_size = size + start_code_size;
+                    if (start_code_size)
+                        memcpy(copy_spspps,
+                                "\x00\x00\x00\x01", start_code_size);
+                    memcpy((uint8_t *)copy_spspps + start_code_size,
+                            (const uint8_t *)buffer->data()
+                                + buffer->range_offset(),
+                            size);
+                    break;
+                }
+
+                case 2:
+                {
+                    size_t offset = copy_spspps_size;
+                    copy_spspps_size += (size + start_code_size);
+                    copy_spspps = (uint8_t *)realloc(copy_spspps, copy_spspps_size);
+                    if (start_code_size)
+                        memcpy(&copy_spspps[offset],
+                                "\x00\x00\x00\x01", start_code_size);
+                    memcpy(&copy_spspps[offset + start_code_size],
+                            (const uint8_t *)buffer->data()
+                                + buffer->range_offset(),
+                            size);
+                    status_t err = makeAVCCodecSpecificData(
+                            copy_spspps, copy_spspps_size);
+                    CHECK_EQ(OK, err);
+                    free(copy_spspps);
+                    copy_spspps = NULL;
+                    mGotAllCodecSpecificData = true;
+                    break;
+                }
+            }
+
+            buffer->release();
+            buffer = NULL;
+
+            continue;
+
+        } else if (mCodecSpecificData == NULL && mIsMPEG4) {
+            CHECK(!mGotAllCodecSpecificData);
+            mCodecSpecificDataSize = buffer->range_length();
+            mCodecSpecificData = malloc(mCodecSpecificDataSize);
+            memcpy(mCodecSpecificData,
+                    (const uint8_t *)buffer->data()
+                        + buffer->range_offset(),
+                   buffer->range_length());
+            buffer->release();
+            buffer = NULL;
+
+            mGotAllCodecSpecificData = true;
+            continue;
+        }
+#endif
 
         // Make a deep copy of the MediaBuffer and Metadata and release
         // the original as soon as we can
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP3)
+        MediaBuffer *copy;
+        size_t start_code_size = 0;
+
+        if (mIsAvc) {
+            start_code_size = memcmp("\x00\x00\x00\x01",
+                    (uint8_t *)buffer->data(), 4) ? 4 : 0;
+        }
+        copy = new MediaBuffer(buffer->range_length() + start_code_size);
+        if (start_code_size)
+            memcpy(copy->data(), "\x00\x00\x00\x01", start_code_size);
+        memcpy((uint8_t *)copy->data() + start_code_size,
+                (uint8_t *)buffer->data() + buffer->range_offset(),
+                buffer->range_length());
+        copy->set_range(0, buffer->range_length() + start_code_size);
+#else
         MediaBuffer *copy = new MediaBuffer(buffer->range_length());
         memcpy(copy->data(), (uint8_t *)buffer->data() + buffer->range_offset(),
                 buffer->range_length());
         copy->set_range(0, buffer->range_length());
+#endif
         meta_data = new MetaData(*buffer->meta_data().get());
         buffer->release();
         buffer = NULL;
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+        int32_t isSync1 = 0;
+        meta_data->findInt32(kKeyIsSyncFrame, &isSync1);
+
+        if (mIsAvc && isSync1) StripSpsPps(copy);
+#endif
+
         if (mIsAvc) StripStartcode(copy);
 
         size_t sampleSize = copy->range_length();
+#if !defined (OMAP_ENHANCEMENT) || !defined (TARGET_OMAP3)
         if (mIsAvc) {
             if (mOwner->useNalLengthFour()) {
                 sampleSize += 4;
@@ -1787,6 +2027,7 @@ status_t MPEG4Writer::Track::threadEntry() {
                 sampleSize += 2;
             }
         }
+#endif
 
         // Max file size or duration handling
         mMdatSizeBytes += sampleSize;
@@ -1863,6 +2104,7 @@ status_t MPEG4Writer::Track::threadEntry() {
 
         CHECK(timestampUs >= 0);
         if (mNumSamples > 1) {
+#if !defined(OMAP_ENHANCEMENT) && !defined(TARGET_OMAP4)
             if (timestampUs <= lastTimestampUs) {
                 LOGW("Frame arrives too late!");
                 // Don't drop the late frame, since dropping a frame may cause
@@ -1876,6 +2118,7 @@ status_t MPEG4Writer::Track::threadEntry() {
                     timestampUs = lastTimestampUs + (1000000LL + (mTimeScale >> 1)) / mTimeScale;
                 }
             }
+#endif
         }
 
         LOGV("%s media time stamp: %lld and previous paused duration %lld",
@@ -1897,7 +2140,18 @@ status_t MPEG4Writer::Track::threadEntry() {
                      (lastTimestampUs * mTimeScale + 500000LL) / 1000000LL);
 
             if (currDurationTicks != lastDurationTicks) {
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+            if(!mIsAudio) {
+                //Collect timestamps
+                TSTableEntry sample(sampleCount,lastTimestampUs);
+                mPresentationTimeStamp.push_back(sample);
+                mDecodeTimeStamp.push_back(sample);
+            } else {
                 addOneSttsTableEntry(sampleCount, lastDurationUs);
+            }
+#else
+                addOneSttsTableEntry(sampleCount, lastDurationUs);
+#endif
                 sampleCount = 1;
             } else {
                 ++sampleCount;
@@ -1924,8 +2178,12 @@ status_t MPEG4Writer::Track::threadEntry() {
             trackProgressStatus(timestampUs);
         }
         if (mOwner->numTracks() == 1) {
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP3)
+            off_t offset = mOwner->addSample_l(copy);
+#else
             off_t offset = mIsAvc? mOwner->addLengthPrefixedSample_l(copy)
                                  : mOwner->addSample_l(copy);
+#endif
             if (mChunkOffsets.empty()) {
                 addChunkOffset(offset);
             }
@@ -1980,7 +2238,19 @@ status_t MPEG4Writer::Track::threadEntry() {
     } else {
         ++sampleCount;  // Count for the last sample
     }
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    if(!mIsAudio) {
+        //Collect timestamps
+        TSTableEntry sample(sampleCount,lastTimestampUs);
+        mPresentationTimeStamp.push_back(sample);
+        mDecodeTimeStamp.push_back(sample);
+    } else {
+        addOneSttsTableEntry(sampleCount, lastDurationUs);
+    }
+#else
     addOneSttsTableEntry(sampleCount, lastDurationUs);
+#endif
+
     mTrackDurationUs += lastDurationUs;
     mReachedEOS = true;
     LOGI("Received total/0-length (%d/%d) buffers and encoded %d frames. - %s",
@@ -2299,7 +2569,7 @@ void MPEG4Writer::Track::writeTrackHeader(
                       mOwner->writeInt8(0);         // decoder version
                       mOwner->writeInt16(0x83FF);   // mode set: all enabled
                       mOwner->writeInt8(0);         // mode change period
-                      mOwner->writeInt8(1);         // frames per sample
+                      mOwner->writeInt8(0x0F);      // frames per sample
                     mOwner->endBox();
                   }
                 mOwner->endBox();
@@ -2358,12 +2628,18 @@ void MPEG4Writer::Track::writeTrackHeader(
                         mOwner->writeInt8(0x20);  // objectTypeIndication ISO/IEC 14492-2
                         mOwner->writeInt8(0x11);  // streamType VisualStream
 
+                        CHECK(tkhdDuration > 0);
+                        int32_t avgBitRate = ((float(mEstimatedTrackSizeBytes) / float(tkhdDuration)) * 8 * 1000);
+                        int32_t maxBitRate = 0;
+                        mMeta->findInt32(kKeyBitRate, &maxBitRate);
+
                         static const uint8_t kData[] = {
-                            0x01, 0x77, 0x00,
-                            0x00, 0x03, 0xe8, 0x00,
-                            0x00, 0x03, 0xe8, 0x00
+                            0x01, 0x77, 0x00
                         };
+
                         mOwner->write(kData, sizeof(kData));
+                        mOwner->writeInt32(maxBitRate);
+                        mOwner->writeInt32(avgBitRate);
 
                         mOwner->writeInt8(0x05);  // DecoderSpecificInfoTag
 
@@ -2413,6 +2689,37 @@ void MPEG4Writer::Track::writeTrackHeader(
           mOwner->endBox();  // stsd
 
           mOwner->beginBox("stts");
+
+ #if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+            if(!mIsAudio) { // ctts is valid only for video
+
+                //Make sure that the Stts value is sorted and
+                //is in increasing order. As per standard stts
+                //cannot be negative so unless we sort the out
+                //of order timestamp the duration encoding will
+                //not be positive.
+                // stts[n] = dts[n+1] - dts[n]
+                sortPresentationTimestamp(mDecodeTimeStamp);
+
+                //Need to add First frame time stamp as zero
+                //for the Iframe encoding
+                TSTableEntry temp (1,0);
+                mDecodeTimeStamp.push_front(temp);
+
+                //Update the duration in stts stucture.
+                uint32_t countDecodeTSList = mDecodeTimeStamp.size();
+                List<TSTableEntry>::iterator itcur = mDecodeTimeStamp.begin();
+                List<TSTableEntry>::iterator itnext = itcur;
+                itnext ++;
+                for (uint32_t i = 1; i < countDecodeTSList; i++) {
+                    addOneSttsTableEntry(itnext->sampleCount, (itnext->sampleTimestampUs - itcur->sampleTimestampUs) / itnext->sampleCount);
+                    itnext ++;
+                    itcur ++;
+                }
+
+            }
+ #endif
+
             mOwner->writeInt32(0);  // version=0, flags=0
             mOwner->writeInt32(mNumSttsTableEntries);
             int64_t prevTimestampUs = 0;
@@ -2431,6 +2738,33 @@ void MPEG4Writer::Track::writeTrackHeader(
             }
           mOwner->endBox();  // stts
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        if(!mIsAudio && misOutofOrderTimestamps) {
+            LOGE("Out of order detected!");
+            mOwner->beginBox("ctts");
+            mOwner->writeInt32(0);  // version=0, flags=0
+            mOwner->writeInt32(mDecodeTimeStamp.size());
+
+            // Write first sample for Iframe as zero
+            mOwner->writeInt32(1);
+            mOwner->writeInt32(0);
+
+            // Encode the offset of ctts as difference between presentation timestamp
+            // and decoding timestamp.
+            size_t countPresentationTSList = mPresentationTimeStamp.size();
+            List<TSTableEntry>::iterator itpresentation = mPresentationTimeStamp.begin();
+            List<TSTableEntry>::iterator itdecoding     = mDecodeTimeStamp.begin();
+            for (size_t i = 0; i < countPresentationTSList; ++i) {
+                mOwner->writeInt32(itdecoding->sampleCount);
+                int32_t dur =  ((itpresentation->sampleTimestampUs * mTimeScale + 500000LL) / 1000000LL -
+                             (itdecoding->sampleTimestampUs * mTimeScale + 500000LL) / 1000000LL);
+                itpresentation ++;
+                itdecoding ++;
+                mOwner->writeInt32(dur);
+            }
+          mOwner->endBox();  // ctts
+        }
+#endif
           if (!mIsAudio) {
             mOwner->beginBox("stss");
               mOwner->writeInt32(0);  // version=0, flags=0
diff --git a/media/libstagefright/MediaBuffer.cpp b/media/libstagefright/MediaBuffer.cpp
index b973745..b93fb62 100644
--- a/media/libstagefright/MediaBuffer.cpp
+++ b/media/libstagefright/MediaBuffer.cpp
@@ -91,6 +91,10 @@ void MediaBuffer::add_ref() {
     atomic_add(&mRefCount, 1);
 }
 
+void MediaBuffer::setData(void *data) {
+    mData = data;
+}
+
 void *MediaBuffer::data() const {
     return mData;
 }
@@ -108,10 +112,25 @@ size_t MediaBuffer::range_length() const {
 }
 
 void MediaBuffer::set_range(size_t offset, size_t length) {
+#ifdef OMAP_ENHANCEMENT
+    if(offset) {
+        if (offset + length > mSize) {
+            LOGE("offset = %d, length = %d, mSize = %d", offset, length, mSize);
+        }
+        CHECK(offset + length <= mSize);
+    }
+    else {
+        if (length > mSize) {
+            LOGE("offset = %d, length = %d, mSize = %d", offset, length, mSize);
+            length = mSize;
+        }
+    }
+#else
     if (offset + length > mSize) {
         LOGE("offset = %d, length = %d, mSize = %d", offset, length, mSize);
     }
     CHECK(offset + length <= mSize);
+#endif
 
     mRangeOffset = offset;
     mRangeLength = length;
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index 7648d42..eea093a 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -25,6 +25,13 @@ const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
+const char *MEDIA_MIMETYPE_VIDEO_VP6 = "video/x-vp6";
+const char *MEDIA_MIMETYPE_VIDEO_VP7 = "video/x-vp7";
+const char *MEDIA_MIMETYPE_VIDEO_WMV  = "video/x-ms-wmv";
+
+const char *MEDIA_MIMETYPE_AUDIO_WMA = "audio/x-ms-wma";
+const char *MEDIA_MIMETYPE_AUDIO_WMAPRO = "audio/wmapro";
+const char *MEDIA_MIMETYPE_AUDIO_WMALSL = "audio/wmalsl";
 
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";
@@ -41,5 +48,7 @@ const char *MEDIA_MIMETYPE_CONTAINER_WAV = "audio/wav";
 const char *MEDIA_MIMETYPE_CONTAINER_OGG = "application/ogg";
 const char *MEDIA_MIMETYPE_CONTAINER_MATROSKA = "video/x-matroska";
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG2TS = "video/mp2ts";
+const char *MEDIA_MIMETYPE_CONTAINER_ASF = "video/x-ms-asf";
+const char *MEDIA_MIMETYPE_CONTAINER_AVI = "video/x-msvideo";
 
 }  // namespace android
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index 8a5fb11..a41649b 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -34,6 +34,10 @@
 #include <media/stagefright/MetaData.h>
 #include <utils/String8.h>
 
+#ifdef OMAP_ENHANCEMENT
+#include "include/ASFExtractor.h"
+#endif
+
 namespace android {
 
 sp<MetaData> MediaExtractor::getMetaData() {
@@ -80,6 +84,16 @@ sp<MediaExtractor> MediaExtractor::Create(
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS)) {
         return new MPEG2TSExtractor(source);
     }
+#ifdef OMAP_ENHANCEMENT
+    else if(!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_ASF)) {
+        if(isASFParserAvailable()) {
+            return new ASFExtractor(source);
+        }
+        else {
+            return NULL;
+        }
+    }
+#endif
 
     return NULL;
 }
diff --git a/media/libstagefright/MediaSource.cpp b/media/libstagefright/MediaSource.cpp
index b4ef338..1200b2e 100644
--- a/media/libstagefright/MediaSource.cpp
+++ b/media/libstagefright/MediaSource.cpp
@@ -37,10 +37,23 @@ void MediaSource::ReadOptions::reset() {
 
 void MediaSource::ReadOptions::setSeekTo(int64_t time_us, SeekMode mode) {
     mOptions |= kSeekTo_Option;
+#ifdef OMAP_ENHANCEMENT
+    //Incase the app layer tries to seek to negative offset,
+    //resetting the value to Zero.
+    if (time_us < 0)
+    {
+        time_us = 0;
+    }
+#endif
     mSeekTimeUs = time_us;
     mSeekMode = mode;
 }
 
+extern "C" void _ZN7android11MediaSource11ReadOptions9setSeekToExNS1_8SeekModeE(int64_t time_us, void *mode);
+extern "C" void _ZN7android11MediaSource11ReadOptions9setSeekToEx(int64_t time_us) {
+    _ZN7android11MediaSource11ReadOptions9setSeekToExNS1_8SeekModeE(time_us, NULL);
+}
+
 void MediaSource::ReadOptions::clearSeekTo() {
     mOptions &= ~kSeekTo_Option;
     mSeekTimeUs = 0;
@@ -77,4 +90,11 @@ int64_t MediaSource::ReadOptions::getLateBy() const {
     return mLatenessUs;
 }
 
+#ifdef USE_GETBUFFERINFO
+status_t MediaSource::getBufferInfo(sp<IMemory>& Frame, size_t *alignedSize) {
+    //do nothing, since it is virtual, need dummy implementation
+    return OK;
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/NOTICE.cm b/media/libstagefright/NOTICE.cm
new file mode 100644
index 0000000..a5f5733
--- /dev/null
+++ b/media/libstagefright/NOTICE.cm
@@ -0,0 +1,192 @@
+   Parts of this library, including but not limited to the compatibility
+   with all msm7k devices are:
+
+   Copyright (c) 2011, The CyanogenMod Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/media/libstagefright/NuCachedSource2.cpp b/media/libstagefright/NuCachedSource2.cpp
old mode 100644
new mode 100755
index 3a37bf3..fe7b876
--- a/media/libstagefright/NuCachedSource2.cpp
+++ b/media/libstagefright/NuCachedSource2.cpp
@@ -327,7 +327,11 @@ void NuCachedSource2::onRead(const sp<AMessage> &msg) {
 }
 
 void NuCachedSource2::restartPrefetcherIfNecessary_l(bool force) {
+#ifndef OMAP_ENHANCEMENT
     static const size_t kGrayArea = 256 * 1024;
+#else
+    static const size_t kGrayArea = 256 * 1024 * 12;
+#endif
 
     if (mFetching || mFinalStatus != OK) {
         return;
@@ -435,8 +439,12 @@ ssize_t NuCachedSource2::readInternal(off_t offset, void *data, size_t size) {
 
     if (offset < mCacheOffset
             || offset >= (off_t)(mCacheOffset + mCache->totalSize())) {
+#ifndef OMAP_ENHANCEMENT
         static const off_t kPadding = 32768;
-
+#else
+        // make this value larger for high profile playback
+        static const off_t kPadding = 768 * 1024;
+#endif
         // In the presence of multiple decoded streams, once of them will
         // trigger this seek request, the other one will request data "nearby"
         // soon, adjust the seek position so that that subsequent request
@@ -447,6 +455,13 @@ ssize_t NuCachedSource2::readInternal(off_t offset, void *data, size_t size) {
     }
 
     size_t delta = offset - mCacheOffset;
+#ifdef OMAP_ENHANCEMENT
+    if (offset + size <= mCacheOffset + mCache->totalSize()) {
+        mCache->copy(delta, data, size);
+
+        return size;
+    }
+#endif
 
     if (mFinalStatus != OK) {
         if (delta >= mCache->totalSize()) {
@@ -459,11 +474,13 @@ ssize_t NuCachedSource2::readInternal(off_t offset, void *data, size_t size) {
         return avail;
     }
 
+#ifndef OMAP_ENHANCEMENT
     if (offset + size <= mCacheOffset + mCache->totalSize()) {
         mCache->copy(delta, data, size);
 
         return size;
     }
+#endif
 
     LOGV("deferring read");
 
diff --git a/media/libstagefright/NuHTTPDataSource.cpp b/media/libstagefright/NuHTTPDataSource.cpp
index 6d4fbcb..af247d5 100644
--- a/media/libstagefright/NuHTTPDataSource.cpp
+++ b/media/libstagefright/NuHTTPDataSource.cpp
@@ -58,7 +58,7 @@ static bool ParseURL(
         path->setTo(slashPos);
     }
 
-    char *colonPos = strchr(host->string(), ':');
+    const char *colonPos = strchr(host->string(), ':');
 
     if (colonPos != NULL) {
         unsigned long x;
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index b5d00bf..592ca05 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -35,9 +35,16 @@
 
 #include "include/ESDS.h"
 
+#if defined(OMAP_ENHANCEMENT) && (TARGET_OMAP4)
+#define NPA_BUFFERS
+#endif
+
 #include <binder/IServiceManager.h>
 #include <binder/MemoryDealer.h>
 #include <binder/ProcessState.h>
+#ifdef USE_GETBUFFERINFO
+#include <binder/MemoryBase.h>
+#endif
 #include <media/IMediaPlayerService.h>
 #include <media/stagefright/MediaBuffer.h>
 #include <media/stagefright/MediaBufferGroup.h>
@@ -52,7 +59,84 @@
 #include <OMX_Audio.h>
 #include <OMX_Component.h>
 
+#ifdef USE_GETBUFFERINFO
+#include <OMX_QCOMExtns.h>
+#endif
+
 #include "include/ThreadedSource.h"
+#ifdef OMAP_ENHANCEMENT
+#include <overlay_common.h>
+#include <cutils/properties.h>
+#ifdef TARGET_OMAP4
+#include <TICameraParameters.h>
+
+#include "OMX_TI_Index.h"
+#include "OMX_TI_Common.h"
+#include "OMX_TI_Video.h"
+#include "OMX_TI_IVCommon.h"
+#endif
+
+/**
+* Important Note#
+* Method to calculate the reference frames required for decoder on output port
+* This is as per standard, hence no changes are expected in this function logic in the future
+* But for any changes done inside Codec, it is required to update here as well as in
+* TIHardwareRenderer.cpp (platform/hardware/ti/omap3/libstagefrighthw)
+* And this will be removed once flash backward compatibity issue is resolved.
+*/
+static int Calculate_TotalRefFrames(int nWidth, int nHeight) {
+    LOGD("Calculate_TotalRefFrames");
+    uint32_t ref_frames = 0;
+    uint32_t MaxDpbMbs;
+    uint32_t PicWidthInMbs;
+    uint32_t FrameHeightInMbs;
+
+    MaxDpbMbs = 32768; //Maximum value for upto level 4.1
+
+    PicWidthInMbs = nWidth / 16;
+
+    FrameHeightInMbs = nHeight / 16;
+
+    ref_frames =  (uint32_t)(MaxDpbMbs / (PicWidthInMbs * FrameHeightInMbs));
+
+    LOGD("nWidth [%d] PicWidthInMbs [%d] nHeight [%d] FrameHeightInMbs [%d] ref_frames [%d]",
+          nWidth, PicWidthInMbs, nHeight, FrameHeightInMbs, ref_frames);
+
+    ref_frames = (ref_frames > 16) ? 16 : ref_frames;
+
+    LOGD("Final ref_frames [%d]",  ref_frames);
+
+    return (ref_frames + 3 + 2*NUM_BUFFERS_TO_BE_QUEUED_FOR_OPTIMAL_PERFORMANCE);
+}
+
+#if defined NPA_BUFFERS
+#define OMX_BUFFERHEADERFLAG_MODIFIED 0x00000100
+#define THUMBNAIL_BUFFERS_NPA_MODE 2
+#define NPA_BUFFER_SIZE 4
+#endif
+
+#ifdef TARGET_OMAP4
+#define SUPPORT_B_FRAMES
+#ifdef SUPPORT_B_FRAMES
+#define OMX_NUM_B_FRAMES 2
+#else
+#define OMX_NUM_B_FRAMES 0
+#endif
+#define OUTPUT_BUFFER_COUNT 2
+#define INPUT_BUFFER_COUNT 2
+#elif defined(TARGET_OMAP3)
+#if defined(OVERLAY_NUM_REQBUFFERS)
+#define OUTPUT_BUFFER_COUNT OVERLAY_NUM_REQBUFFERS
+#else
+#define OUTPUT_BUFFER_COUNT 4
+#endif
+#endif
+
+#endif
+
+#ifdef OMAP_ENHANCEMENT
+#include <overlay_common.h>
+#endif
 
 namespace android {
 
@@ -150,8 +234,89 @@ static sp<MediaSource> InstantiateSoftwareCodec(
 #undef FACTORY_REF
 #undef FACTORY_CREATE
 
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+#ifdef TARGET_OMAP4
+//Enable Ducati Codecs for Video, PV SW codecs for Audio
+static const CodecInfo kDecoderInfo[] = {
+    { MEDIA_MIMETYPE_AUDIO_MPEG, "MP3Decoder" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "AMRNBDecoder" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB, "AMRWBDecoder" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "AACDecoder" },
+    { MEDIA_MIMETYPE_AUDIO_G711_ALAW, "G711Decoder" },
+    { MEDIA_MIMETYPE_AUDIO_G711_MLAW, "G711Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_WMV, "OMX.TI.DUCATI1.VIDEO.DECODER" },
+    { MEDIA_MIMETYPE_AUDIO_WMA, "OMX.ITTIAM.WMA.decode" },
+    { MEDIA_MIMETYPE_AUDIO_WMALSL, "OMX.ITTIAM.WMALSL.decode" },
+    { MEDIA_MIMETYPE_AUDIO_WMAPRO, "OMX.ITTIAM.WMAPRO.decode" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.DUCATI1.VIDEO.DECODER" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "M4vH263Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.TI.DUCATI1.VIDEO.DECODER" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "M4vH263Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.DUCATI1.VIDEO.DECODER" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "AVCDecoder" },
+    { MEDIA_MIMETYPE_AUDIO_VORBIS, "VorbisDecoder" },
+    { MEDIA_MIMETYPE_VIDEO_VPX, "VPXDecoder" },
+    { MEDIA_MIMETYPE_VIDEO_VP6, "OMX.TI.DUCATI1.VIDEO.DECODER" },
+    { MEDIA_MIMETYPE_VIDEO_VP7, "OMX.TI.DUCATI1.VIDEO.DECODER" }
+};
+
+//Maintain only s/w encoders till ducati encoders are integrated to SF
+static const CodecInfo kEncoderInfo[] = {
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "AMRNBEncoder" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.ITTIAM.AAC.encode" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "AACEncoder" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.DUCATI1.VIDEO.MPEG4E" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.TI.DUCATI1.VIDEO.MPEG4E" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.DUCATI1.VIDEO.H264E" },
+};
+#elif defined(TARGET_OMAP3)
 static const CodecInfo kDecoderInfo[] = {
-    { MEDIA_MIMETYPE_IMAGE_JPEG, "OMX.TI.JPEG.decode" },
+    { MEDIA_MIMETYPE_IMAGE_JPEG, "OMX.TI.JPEG.decoder" },
+    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.TI.MP3.decode" },
+    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.PV.mp3dec" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.TI.AMR.decode" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.PV.amrdec" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.TI.WBAMR.decode" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.PV.amrdec" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.decode" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.ITTIAM.AAC.decode" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.PV.aacdec" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "AACDecoder" },
+    { MEDIA_MIMETYPE_AUDIO_G711_ALAW, "G711Decoder" },
+    { MEDIA_MIMETYPE_AUDIO_G711_MLAW, "G711Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.Video.Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.720P.Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "M4vH263Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.TI.Video.Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "M4vH263Decoder" },
+    /* 720p Video Decoder must be placed before the TI Video Decoder.
+       DO NOT CHANGE THIS SEQUENCE. IT WILL BREAK FLASH. */
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.720P.Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.Video.Decoder" },
+    { MEDIA_MIMETYPE_AUDIO_VORBIS, "VorbisDecoder" },
+    { MEDIA_MIMETYPE_VIDEO_VPX, "VPXDecoder" },
+    { MEDIA_MIMETYPE_VIDEO_WMV, "OMX.TI.Video.Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_WMV, "OMX.TI.720P.Decoder" },
+    { MEDIA_MIMETYPE_AUDIO_WMA, "OMX.TI.WMA.decode"},
+    { MEDIA_MIMETYPE_AUDIO_WMA, "OMX.ITTIAM.WMA.decode"},
+};
+
+static const CodecInfo kEncoderInfo[] = {
+    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.TI.AMR.encode" },
+    { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.TI.WBAMR.encode" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.encode" },
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.ITTIAM.AAC.encode" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.Video.encoder" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.720P.Encoder" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.TI.Video.encoder" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.Video.encoder" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.720P.Encoder" },
+};
+#endif
+#else
+static const CodecInfo kDecoderInfo[] = {
+    { MEDIA_MIMETYPE_IMAGE_JPEG, "OMX.TI.JPEG.decoder" },
+    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.Nvidia.mp3.decoder" },
 //    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.TI.MP3.decode" },
     { MEDIA_MIMETYPE_AUDIO_MPEG, "MP3Decoder" },
 //    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.PV.mp3dec" },
@@ -161,28 +326,36 @@ static const CodecInfo kDecoderInfo[] = {
     { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.TI.WBAMR.decode" },
     { MEDIA_MIMETYPE_AUDIO_AMR_WB, "AMRWBDecoder" },
 //    { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.PV.amrdec" },
+#ifndef USE_SOFTWARE_AUDIO_AAC
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.Nvidia.aac.decoder" },
+#endif
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.decode" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "AACDecoder" },
 //    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.PV.aacdec" },
+    //{ MEDIA_MIMETYPE_AUDIO_WMA, "OMX.Nvidia.wma.decoder" },
     { MEDIA_MIMETYPE_AUDIO_G711_ALAW, "G711Decoder" },
     { MEDIA_MIMETYPE_AUDIO_G711_MLAW, "G711Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.Nvidia.mp4.decode" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.7x30.video.decoder.mpeg4" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.video.decoder.mpeg4" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.Video.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.SEC.MPEG4.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "M4vH263Decoder" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.Nvidia.h263.decode" },
 //    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.PV.mpeg4dec" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.7x30.video.decoder.h263" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.video.decoder.h263" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.SEC.H263.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_H263, "M4vH263Decoder" },
 //    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.PV.h263dec" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.Nvidia.h264.decode" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.7x30.video.decoder.avc" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.video.decoder.avc" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.Video.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.SEC.AVC.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "AVCDecoder" },
 //    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.PV.avcdec" },
+    //{MEDIA_MIMETYPE_VIDEO_WMV, "OMX.Nvidia.vc1.decode" },
     { MEDIA_MIMETYPE_AUDIO_VORBIS, "VorbisDecoder" },
     { MEDIA_MIMETYPE_VIDEO_VPX, "VPXDecoder" },
 };
@@ -195,18 +368,21 @@ static const CodecInfo kEncoderInfo[] = {
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.encode" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "AACEncoder" },
 //    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.PV.aacenc" },
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.Nvidia.mp4.encoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.7x30.video.encoder.mpeg4" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.video.encoder.mpeg4" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.Video.encoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.SEC.MPEG4.Encoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "M4vH263Encoder" },
 //    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.PV.mpeg4enc" },
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.Nvidia.h263.encoder" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.7x30.video.encoder.h263" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.video.encoder.h263" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.TI.Video.encoder" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.SEC.H263.Encoder" },
     { MEDIA_MIMETYPE_VIDEO_H263, "M4vH263Encoder" },
 //    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.PV.h263enc" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.Nvidia.h264.encoder" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.7x30.video.encoder.avc" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.video.encoder.avc" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.Video.encoder" },
@@ -214,6 +390,7 @@ static const CodecInfo kEncoderInfo[] = {
     { MEDIA_MIMETYPE_VIDEO_AVC, "AVCEncoder" },
 //    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.PV.avcenc" },
 };
+#endif
 
 #undef OPTIONAL
 
@@ -221,6 +398,20 @@ static const CodecInfo kEncoderInfo[] = {
 #define CODEC_LOGV(x, ...) LOGV("[%s] "x, mComponentName, ##__VA_ARGS__)
 #define CODEC_LOGE(x, ...) LOGE("[%s] "x, mComponentName, ##__VA_ARGS__)
 
+#ifdef OMAP_ENHANCEMENT
+/* This flag has to be updated according to the Memory dealer cache line
+ * alignment value "SimpleBestFitAllocator::kMemoryAlign"
+ * It is required to allocate correct amount of memory considering the
+ * alignment, Otherwise alloc fails when input buffer sizes are not aligned*/
+#ifdef TARGET_OMAP4
+#define CACHELINE_BOUNDARY_MEMALIGNMENT 32
+#else
+#define CACHELINE_BOUNDARY_MEMALIGNMENT 128
+#endif
+#endif
+
+#ifndef OMAP_ENHANCEMENT
+// the new omap one is defined in .h
 struct OMXCodecObserver : public BnOMXObserver {
     OMXCodecObserver() {
     }
@@ -240,6 +431,13 @@ struct OMXCodecObserver : public BnOMXObserver {
         }
     }
 
+    virtual void registerBuffers(const sp<IMemoryHeap> &mem) {
+        sp<OMXCodec> codec = mTarget.promote();
+        if (codec.get() != NULL) {
+            codec->registerBuffers(mem);
+        }
+    }
+
 protected:
     virtual ~OMXCodecObserver() {}
 
@@ -249,6 +447,7 @@ private:
     OMXCodecObserver(const OMXCodecObserver &);
     OMXCodecObserver &operator=(const OMXCodecObserver &);
 };
+#endif
 
 static const char *GetCodec(const CodecInfo *info, size_t numInfos,
                             const char *mime, int index) {
@@ -299,6 +498,7 @@ static const char *AVCProfileToString(uint8_t profile) {
     }
 }
 
+#ifndef OMAP_ENHANCEMENT
 template<class T>
 static void InitOMXParams(T *params) {
     params->nSize = sizeof(T);
@@ -307,6 +507,7 @@ static void InitOMXParams(T *params) {
     params->nVersion.s.nRevision = 0;
     params->nVersion.s.nStep = 0;
 }
+#endif
 
 static bool IsSoftwareCodec(const char *componentName) {
     if (!strncmp("OMX.PV.", componentName, 7)) {
@@ -348,26 +549,69 @@ static int CompareSoftwareCodecsFirst(
 }
 
 // static
-uint32_t OMXCodec::getComponentQuirks(
-        const char *componentName, bool isEncoder) {
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+uint32_t OMXCodec::getComponentQuirks(const char *componentName,bool isEncoder, uint32_t flags) {
+#else
+uint32_t OMXCodec::getComponentQuirks(const char *componentName, bool isEncoder) {
+#endif
     uint32_t quirks = 0;
 
     if (!strcmp(componentName, "OMX.PV.avcdec")) {
         quirks |= kWantsNALFragments;
     }
+
+    if (!strcmp(componentName, "OMX.Nvidia.amr.decoder") ||
+         !strcmp(componentName, "OMX.Nvidia.amrwb.decoder") ||
+         !strcmp(componentName, "OMX.Nvidia.aac.decoder") ||
+         !strcmp(componentName, "OMX.Nvidia.mp3.decoder")) {
+        quirks |= kDecoderLiesAboutNumberOfChannels;
+    }
+
     if (!strcmp(componentName, "OMX.TI.MP3.decode")) {
         quirks |= kNeedsFlushBeforeDisable;
         quirks |= kDecoderLiesAboutNumberOfChannels;
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+        quirks |= kSupportsMultipleFramesPerInputBuffer;
+        quirks |= kDecoderCantRenderSmallClips;
+#endif
     }
     if (!strcmp(componentName, "OMX.TI.AAC.decode")) {
         quirks |= kNeedsFlushBeforeDisable;
         quirks |= kRequiresFlushCompleteEmulation;
         quirks |= kSupportsMultipleFramesPerInputBuffer;
     }
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+    if (!strcmp(componentName, "OMX.TI.WMA.decode")) {
+        quirks |= kNeedsFlushBeforeDisable;
+        quirks |= kRequiresFlushCompleteEmulation;
+    }
+    if (!strcmp(componentName, "OMX.ITTIAM.WMA.decode")) {
+       quirks |= kNeedsFlushBeforeDisable;
+       quirks |= kRequiresFlushCompleteEmulation;
+    }
+    if (!strcmp(componentName, "OMX.ITTIAM.WMALSL.decode")) {
+        quirks |= kNeedsFlushBeforeDisable;
+        quirks |= kRequiresFlushCompleteEmulation;
+    }
+    if (!strcmp(componentName, "OMX.ITTIAM.WMAPRO.decode")) {
+        quirks |= kNeedsFlushBeforeDisable;
+        quirks |= kRequiresFlushCompleteEmulation;
+    }
+    if (!strcmp(componentName, "OMX.ITTIAM.AAC.decode")) {
+
+        quirks |= kNeedsFlushBeforeDisable;
+        quirks |= kDecoderNeedsPortReconfiguration;
+    }
+    if (!strcmp(componentName, "OMX.PV.aacdec")) {
+        quirks |= kNeedsFlushBeforeDisable;
+        quirks |= kDecoderNeedsPortReconfiguration;
+    }
+#endif
     if (!strncmp(componentName, "OMX.qcom.video.encoder.", 23)) {
         quirks |= kRequiresLoadedToIdleAfterAllocation;
         quirks |= kRequiresAllocateBufferOnInputPorts;
         quirks |= kRequiresAllocateBufferOnOutputPorts;
+        quirks |= kCanNotSetVideoParameters;
         if (!strncmp(componentName, "OMX.qcom.video.encoder.avc", 26)) {
 
             // The AVC encoder advertises the size of output buffers
@@ -379,6 +623,8 @@ uint32_t OMXCodec::getComponentQuirks(
         }
     }
     if (!strncmp(componentName, "OMX.qcom.7x30.video.encoder.", 28)) {
+        quirks |= kAvoidMemcopyInputRecordingFrames;
+        quirks |= kCanNotSetVideoParameters;
     }
     if (!strncmp(componentName, "OMX.qcom.video.decoder.", 23)) {
         quirks |= kRequiresAllocateBufferOnOutputPorts;
@@ -388,25 +634,68 @@ uint32_t OMXCodec::getComponentQuirks(
         quirks |= kRequiresAllocateBufferOnInputPorts;
         quirks |= kRequiresAllocateBufferOnOutputPorts;
         quirks |= kDefersOutputBufferAllocation;
+        quirks |= kDoesNotRequireMemcpyOnOutputPort;
+    }
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+    if (!strcmp(componentName, "OMX.TI.Video.Decoder") ||
+            !strcmp(componentName, "OMX.TI.720P.Decoder")) {
+        // TI Video Decoder and TI 720p Decoder must use buffers allocated
+        // by Overlay for output port. So, I cannot call OMX_AllocateBuffer
+        // on output port. I must use OMX_UseBuffer on input port to ensure
+        // 128 byte alignment.
+        quirks |= kRequiresAllocateBufferOnInputPorts;
+        quirks |= kInputBufferSizesAreBogus;
+
+        if( flags & kPreferThumbnailMode) {
+                quirks |= OMXCodec::kRequiresAllocateBufferOnOutputPorts;
+        }
     }
+#ifdef TARGET_OMAP4
+    else if(!strcmp(componentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) {
+        //quirks |= kRequiresAllocateBufferOnInputPorts;
+
+        quirks |= kNeedsFlushBeforeDisable;
+        if(flags & kPreferThumbnailMode)
+        {
+            quirks |= OMXCodec::kThumbnailMode;
+        }
+
+        if(flags & kPreferInterlacedOutputContent) {
+                quirks |= OMXCodec::kInterlacedOutputContent;
+        }
 
+    }
+#endif
+    else if (!strncmp(componentName, "OMX.TI.", 7) || !strncmp("OMX.ITTIAM.", componentName, 11)) {
+#else
     if (!strncmp(componentName, "OMX.TI.", 7)) {
+#endif
         // Apparently I must not use OMX_UseBuffer on either input or
         // output ports on any of the TI components or quote:
         // "(I) may have unexpected problem (sic) which can be timing related
         //  and hard to reproduce."
 
+#if defined(OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+        if (!strncmp(componentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E", strlen("OMX.TI.DUCATI1.VIDEO.MPEG4E")) ||
+           !strncmp(componentName, "OMX.TI.DUCATI1.VIDEO.H264E", strlen("OMX.TI.DUCATI1.VIDEO.H264E"))) {
+            LOGV("USING DUCATI ENCODER. isEncoder : %d",isEncoder);
+            quirks |= kRequiresAllocateBufferOnOutputPorts;
+            quirks |= kAvoidMemcopyInputRecordingFrames;
+        }
+#else
         quirks |= kRequiresAllocateBufferOnInputPorts;
         quirks |= kRequiresAllocateBufferOnOutputPorts;
-        if (!strncmp(componentName, "OMX.TI.Video.encoder", 20)) {
+        if (!strncmp(componentName, "OMX.TI.Video.encoder", 20) ||
+            !strncmp(componentName, "OMX.TI.720P.Encoder", 19)) {
             quirks |= kAvoidMemcopyInputRecordingFrames;
         }
+#endif
     }
-
+#if !(defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT))
     if (!strcmp(componentName, "OMX.TI.Video.Decoder")) {
         quirks |= kInputBufferSizesAreBogus;
     }
-
+#endif
     if (!strncmp(componentName, "OMX.SEC.", 8) && !isEncoder) {
         // These output buffers contain no video data, just some
         // opaque information that allows the overlay to display their
@@ -459,6 +748,15 @@ void OMXCodec::findMatchingCodecs(
         matchingCodecs->push(String8(componentName));
     }
 
+#ifdef OMAP_ENHANCEMENT
+    char value[PROPERTY_VALUE_MAX];
+    property_get("debug.video.preferswcodec", value, "0");
+    if (atoi(value))
+    {
+        flags |= kPreferSoftwareCodecs;
+    }
+#endif
+
     if (flags & kPreferSoftwareCodecs) {
         matchingCodecs->sort(CompareSoftwareCodecsFirst);
     }
@@ -501,8 +799,27 @@ sp<MediaSource> OMXCodec::Create(
         }
 
         LOGV("Attempting to allocate OMX node '%s'", componentName);
-
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+        uint32_t quirks = getComponentQuirks(componentName, createEncoder, flags);
+#else
         uint32_t quirks = getComponentQuirks(componentName, createEncoder);
+#endif
+
+#ifdef OMAP_COMPAT
+        if (!strcmp(componentName, "OMX.TI.Video.Decoder")) {
+            int32_t width, height;
+            bool success = meta->findInt32(kKeyWidth, &width);
+            success = success && meta->findInt32(kKeyHeight, &height);
+            CHECK(success);
+            // We need this for 720p video without AVC profile
+            // Not a good solution, but ..
+            if (width*height > 412800) {  //860*480
+               componentName = "OMX.TI.720P.Decoder";
+               LOGE("Format exceed the decoder's capabilities.");
+               continue;
+            }
+        }
+#endif
 
         if (!createEncoder
                 && (quirks & kOutputBuffersAreUnreadable)
@@ -543,12 +860,135 @@ sp<MediaSource> OMXCodec::Create(
     return NULL;
 }
 
+#ifdef OMAP_ENHANCEMENT
+// static
+sp<MediaSource> OMXCodec::Create(
+        const sp<IOMX> &omx,
+        const sp<MetaData> &meta, bool createEncoder,
+        const sp<MediaSource> &source,
+        IOMX::node_id &nodeId,
+        const char *matchComponentName,
+        uint32_t flags) {
+    const char *mime;
+    bool success = meta->findCString(kKeyMIMEType, &mime);
+    CHECK(success);
+
+    Vector<String8> matchingCodecs;
+    findMatchingCodecs(
+            mime, createEncoder, matchComponentName, flags, &matchingCodecs);
+
+    if (matchingCodecs.isEmpty()) {
+        return NULL;
+    }
+
+    sp<OMXCodecObserver> observer = new OMXCodecObserver;
+    IOMX::node_id node = 0;
+
+    const char *componentName;
+    for (size_t i = 0; i < matchingCodecs.size(); ++i) {
+        componentName = matchingCodecs[i].string();
+
+#if BUILD_WITH_FULL_STAGEFRIGHT
+        sp<MediaSource> softwareCodec =
+            InstantiateSoftwareCodec(componentName, source);
+
+        if (softwareCodec != NULL) {
+            LOGV("Successfully allocated software codec '%s'", componentName);
+
+            return softwareCodec;
+        }
+#endif
+
+        LOGV("Attempting to allocate OMX node '%s'", componentName);
+
+        status_t err = omx->allocateNode(componentName, observer, &node);
+        if (err == OK) {
+            LOGV("Successfully allocated OMX node '%s'", componentName);
+
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+            sp<OMXCodec> codec = new OMXCodec(
+                    omx, node, getComponentQuirks(componentName,createEncoder,flags),
+                    createEncoder, mime, componentName,
+                    source);
+#else
+            sp<OMXCodec> codec = new OMXCodec(
+                    omx, node, getComponentQuirks(componentName,createEncoder),
+                    createEncoder, mime, componentName,
+                    source);
+#endif
+
+            observer->setCodec(codec);
+
+            nodeId = node;
+
+            err = codec->configureCodec(meta,flags);
+
+            if (err == OK) {
+                return codec;
+            }
+
+            LOGV("Failed to configure codec '%s'", componentName);
+        }
+    }
+
+    return NULL;
+}
+#endif
+
 status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
+#if !(defined(OMAP_ENHANCEMENT) && defined (TARGET_OMAP4))
     if (!(flags & kIgnoreCodecSpecificData)) {
+#endif
         uint32_t type;
         const void *data;
         size_t size;
-        if (meta->findData(kKeyESDS, &type, &data, &size)) {
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    status_t err;
+
+    if (meta->findData(kKeyStreamSpecificData, &type, &data, &size))
+    {
+        if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) {
+
+            if ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP6, mMIME)) ||
+                (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP7, mMIME))) {
+
+                LOGD("Setting VP6/7 Params");
+                OMX_TI_PARAM_IVFFLAG tVP6Param;
+                InitOMXParams(&tVP6Param);
+                err = mOMX->getParameter(
+                        mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoIvfMode, &tVP6Param, sizeof(tVP6Param));
+
+                CHECK_EQ(err, OK);
+                tVP6Param.bIvfFlag = OMX_FALSE;
+
+                char *t = ((char *)(data));
+                if ((t[0] == 'D') && (t[1] == 'K') && (t[2] == 'I') && (t[3] == 'F')){
+                    LOGD("IVF Header Present. Size = %d. Limiting it to 32 as per spec.", size);
+                    size = 32;
+                    addCodecSpecificData(data, size);
+                    tVP6Param.bIvfFlag = OMX_TRUE;
+                }
+                err = mOMX->setParameter(
+                        mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoIvfMode, &tVP6Param, sizeof(tVP6Param));
+
+                OMX_TI_PARAM_PAYLOADHEADERFLAG tVP6Payloadheader;
+                InitOMXParams(&tVP6Payloadheader);
+                err = mOMX->getParameter(
+                        mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoPayloadHeaderFlag, &tVP6Payloadheader, sizeof(tVP6Payloadheader));
+                CHECK_EQ(err, OK);
+                tVP6Payloadheader.bPayloadHeaderFlag = OMX_FALSE;
+                err = mOMX->setParameter(
+                        mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoPayloadHeaderFlag, &tVP6Payloadheader, sizeof(tVP6Payloadheader));
+
+            }
+        }
+        else addCodecSpecificData(data, size);
+    }
+    else if (meta->findData(kKeyESDS, &type, &data, &size)) {
+#else
+    if (meta->findData(kKeyESDS, &type, &data, &size)) {
+#endif
             ESDS esds((const char *)data, size);
             CHECK_EQ(esds.InitCheck(), OK);
 
@@ -624,7 +1064,7 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
                     (int)profile, AVCProfileToString(profile), level);
 
             if (!strcmp(mComponentName, "OMX.TI.Video.Decoder")
-                && (profile != kAVCProfileBaseline || level > 30)) {
+                && (profile != kAVCProfileBaseline || level > 31)) {
                 // This stream exceeds the decoder's capabilities. The decoder
                 // does not handle this gracefully and would clobber the heap
                 // and wreak havoc instead...
@@ -632,12 +1072,105 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
                 LOGE("Profile and/or level exceed the decoder's capabilities.");
                 return ERROR_UNSUPPORTED;
             }
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+            int32_t width, height;
+            bool success = meta->findInt32(kKeyWidth, &width);
+            success = success && meta->findInt32(kKeyHeight, &height);
+            CHECK(success);
+            if (!strcmp(mComponentName, "OMX.TI.720P.Decoder")
+                && (profile == kAVCProfileBaseline && level <= 39)
+                && (width*height <= MAX_RESOLUTION)
+                && (width <= MAX_RESOLUTION_WIDTH && height <= MAX_RESOLUTION_HEIGHT ))
+            {
+                // Though this decoder can handle this profile/level,
+                // we prefer to use "OMX.TI.Video.Decoder" for
+                // Baseline Profile with level <=39 and sub 720p
+                return ERROR_UNSUPPORTED;
+            }
+#endif
         }
+#ifdef OMAP_ENHANCEMENT
+    else if (meta->findData(kKeyHdr, &type, &data, &size)) {
+        CODEC_LOGV("Codec specific information of size %d", size);
+        addCodecSpecificData(data, size);
     }
 
+    if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mMIME)) {
+        bool success = meta->findData(kKeyHdr, &type, &data, &size);
+        const uint8_t *ptr = (const uint8_t *)data;
+        CHECK(success);
+
+        OMX_U32 width = (((OMX_U32)ptr[18] << 24) | ((OMX_U32)ptr[17] << 16)
+                           | ((OMX_U32)ptr[16] << 8) | (OMX_U32)ptr[15]);
+        OMX_U32 height = (((OMX_U32)ptr[22] << 24) | ((OMX_U32)ptr[21] << 16)
+                           | ((OMX_U32)ptr[20] << 8) | (OMX_U32)ptr[19]);
+
+        CODEC_LOGV("Height and width = %u %u\n", height, width);
+
+        // MAX_RESOLUTION is used to take the decision between TI and Ittiam WMV codec.
+        if (!strcmp(mComponentName, "OMX.TI.Video.Decoder") &&
+            (width*height > MAX_RESOLUTION)) {
+
+            // need OMX.TI.720P.Decoder
+            return ERROR_UNSUPPORTED;
+        }
+        if(!strcmp(mComponentName, "OMX.TI.720P.Decoder")) {
+            OMX_U32 NewCompression = MAKEFOURCC_WMC((OMX_U8)ptr[27], (OMX_U8)ptr[28],
+                                                    (OMX_U8)ptr[29], (OMX_U8)ptr[30]);
+            OMX_U32 StreamType;
+            OMX_PARAM_WMVFILETYPE WMVFileType;
+            InitOMXParams(&WMVFileType);
+
+            if (NewCompression == FOURCC_WMV3) {
+                CODEC_LOGV("VIDDEC_WMV_RCVSTREAM\n");
+                StreamType = VIDDEC_WMV_RCVSTREAM;
+            } else if (NewCompression == FOURCC_WVC1) {
+                CODEC_LOGV("VIDDEC_WMV_ELEMSTREAM\n");
+                StreamType = VIDDEC_WMV_ELEMSTREAM;
+            } else {
+                CODEC_LOGI("ERROR...  PROFILE NOT KNOWN ASSUMED TO BE VIDDEC_WMV_RCVSTREAM\n");
+                StreamType = VIDDEC_WMV_RCVSTREAM;
+            }
+            WMVFileType.nWmvFileType = StreamType;
+
+            status_t err = mOMX->setParameter(mNode,
+                                              (OMX_INDEXTYPE)VideoDecodeCustomParamWMVFileType,
+                                              &WMVFileType, sizeof(WMVFileType));
+            if (err != OMX_ErrorNone) {
+                return err;
+            }
+        }
+    }
+#endif
+
+#if !(defined(OMAP_ENHANCEMENT) && defined (TARGET_OMAP4))
+    }
+#endif
+
     int32_t bitRate = 0;
     if (mIsEncoder) {
         CHECK(meta->findInt32(kKeyBitRate, &bitRate));
+
+#if (defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP3)) || defined(OMAP_COMPAT)
+
+        // required to prefer the 720P encoder on Defy red lens, and Defy+
+        #ifdef OMAP_COMPAT
+        #  define MAX_ENCODER_RESOLUTION 848*480
+        #else
+        #  define MAX_ENCODER_RESOLUTION MAX_RESOLUTION
+        #endif
+
+        if (!strcmp(mComponentName, "OMX.TI.Video.encoder")) {
+            int32_t width, height;
+            bool success = meta->findInt32(kKeyWidth, &width);
+            success = success && meta->findInt32(kKeyHeight, &height);
+            CHECK(success);
+            if (width*height > MAX_ENCODER_RESOLUTION) {
+                // require OMX.TI.720P.Encoder
+                return ERROR_UNSUPPORTED;
+            }
+        }
+#endif
     }
     if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_AMR_NB, mMIME)) {
         setAMRFormat(false /* isWAMR */, bitRate);
@@ -650,7 +1183,31 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
         CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
         CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
 
+#ifndef DONT_SET_AUDIO_AAC_FORMAT
         setAACFormat(numChannels, sampleRate, bitRate);
+#endif
+#ifdef OMAP_ENHANCEMENT
+        // Configure TI OMX component to FrameMode for AAC-ADTS
+        if (!strcmp(mComponentName, "OMX.TI.AAC.decode")) {
+            OMX_INDEXTYPE index;
+
+            CODEC_LOGV("OMXCodec::configureCodec() TI AAC - Configure Component to FrameMode");
+
+            // Get Extension Index from Component
+            status_t err = mOMX->getExtensionIndex(mNode, "OMX.TI.index.config.AacDecFrameModeInfo", &index);
+            if (err != OK) {
+                CODEC_LOGV("OMXCodec::configureCodec() TI AAC - Problem getting ExtensionIndex - Use SteamMode");
+            }
+            else {
+                OMX_U16 framemode = 1;
+                // Set FrameMode for ADTS streams
+                err = mOMX->setConfig(mNode, index, &framemode, sizeof(framemode));
+                if (err != OK) {
+                    CODEC_LOGV("OMXCodec::configureCodec() TI AAC - Problem configuring FrameMode - Use SteamMode");
+                }
+            }
+        }
+#endif
     }
 
     if (!strncasecmp(mMIME, "video/", 6)) {
@@ -662,6 +1219,142 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
             bool success = meta->findInt32(kKeyWidth, &width);
             success = success && meta->findInt32(kKeyHeight, &height);
             CHECK(success);
+
+#ifdef OMAP_ENHANCEMENT
+
+            /* Update proper Profile, Level, No. of Reference frames.
+               This will aid in less (tiler) memory utilization by ducati side */
+            if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) {
+                /* save video FPS */
+                if (!(meta->findInt32(kKeyVideoFPS, &mVideoFPS))) {
+                    mVideoFPS = 30; //default value in case of FPS data not found
+                }
+
+                int32_t vprofile,vlevel,vinterlaced,vnumrefframes;
+
+                if ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mMIME)) &&
+                        meta->findInt32(kKeyVideoProfile, &vprofile) &&
+                        meta->findInt32(kKeyVideoLevel, &vlevel) &&
+                        meta->findInt32(kKeyVideoInterlaced, &vinterlaced) &&
+                        meta->findInt32(kKeyNumRefFrames, &vnumrefframes))
+                {
+
+                    OMX_VIDEO_PARAM_AVCTYPE h264type;
+                    InitOMXParams(&h264type);
+                    h264type.nPortIndex = kPortIndexInput;
+
+                    status_t err = mOMX->getParameter(
+                            mNode, OMX_IndexParamVideoAvc, &h264type, sizeof(h264type));
+                    CHECK_EQ(err, OK);
+
+                    //h264type.nBFrames = 0; //check if requred
+
+
+                    /* Update profile from uint32_t type */
+                    switch(vprofile)
+                    {
+                        case kAVCProfileBaseline :
+                                    h264type.eProfile = OMX_VIDEO_AVCProfileBaseline;
+                                    break;
+                        case kAVCProfileMain :
+                                    h264type.eProfile = OMX_VIDEO_AVCProfileMain;
+                                    break;
+                        case kAVCProfileExtended :
+                                    h264type.eProfile = OMX_VIDEO_AVCProfileExtended;
+                                    break;
+                        case kAVCProfileHigh :
+                                    h264type.eProfile = OMX_VIDEO_AVCProfileHigh;
+                                    break;
+
+                        case kAVCProfileHigh10 :
+                        case kAVCProfileHigh422 :
+                        case kAVCProfileHigh444 :
+                        default:
+                                    //Unsupported profiles by OMX.TI.DUCATI1.VIDEO.DECODER
+                                    LOGE("profile code 0x%x %d not supported", vprofile,vprofile);
+                                    CHECK_EQ(0,1);
+                                    return UNKNOWN_ERROR;
+                    }
+
+
+                    switch(vlevel)
+                    {
+
+                        case 9 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel1b;
+                                    break;
+                        case 10 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel1;
+                                    break;
+                        case 11 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel11;
+                                    break;
+                        case 12 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel12;
+                                    break;
+                        case 13 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel13;
+                                    break;
+                        case 20 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel2;
+                                    break;
+                        case 21 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel21;
+                                    break;
+                        case 22 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel22;
+                                    break;
+                        case 30 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel3;
+                                    break;
+                        case 31 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel31;
+                                    break;
+                        case 32 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel32;
+                                    break;
+
+                        case 40 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel4;
+                                    break;
+
+                        case 41 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel41;
+                                    break;
+
+                        case 42 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel42;
+                                    break;
+
+                        case 50 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel5;
+                                    break;
+
+                        case 51 :
+                                    h264type.eLevel = OMX_VIDEO_AVCLevel51;
+                                    break;
+
+                        default:
+                                    //Unsupported level value
+                                    LOGE("profile code 0x%x %d not supported", vlevel,vlevel);
+                                    CHECK_EQ(0,1);
+                                    return UNKNOWN_ERROR;
+                    }
+
+                    h264type.nRefFrames = vnumrefframes;
+
+                    err = mOMX->setParameter(
+                            mNode, OMX_IndexParamVideoAvc, &h264type, sizeof(h264type));
+                    CHECK_EQ(err, OK);
+
+                    /* Cross check from component */
+                    err = mOMX->getParameter(
+                            mNode, OMX_IndexParamVideoAvc, &h264type, sizeof(h264type));
+
+                    LOGD("Updated. H264 Component profile %d level %d NRefFrames %d", h264type.eProfile,h264type.eLevel, (int)h264type.nRefFrames);
+                }
+            }
+#endif
             status_t err = setVideoOutputFormat(
                     mMIME, width, height);
 
@@ -672,7 +1365,7 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
     }
 
     if (!strcasecmp(mMIME, MEDIA_MIMETYPE_IMAGE_JPEG)
-        && !strcmp(mComponentName, "OMX.TI.JPEG.decode")) {
+        && !strcmp(mComponentName, "OMX.TI.JPEG.decoder")) {
         OMX_COLOR_FORMATTYPE format =
             OMX_COLOR_Format32bitARGB8888;
             // OMX_COLOR_FormatYUV420PackedPlanar;
@@ -696,6 +1389,14 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
 
     int32_t maxInputSize;
     if (meta->findInt32(kKeyMaxInputSize, &maxInputSize)) {
+#ifdef OMAP_ENHANCEMENT
+        if (!strcmp(mComponentName, "OMX.TI.Video.Decoder") || !strcmp(mComponentName, "OMX.TI.720P.Decoder")) {
+            // We need to allocate at least twice the "maxInputSize"
+            // to get enough room for internal OMX buffer handling.
+            maxInputSize += maxInputSize;
+            CODEC_LOGV("Resize maxInputSize*2, maxInputSize=%d", maxInputSize);
+        }
+#endif
         setMinBufferSize(kPortIndexInput, (OMX_U32)maxInputSize);
     }
 
@@ -734,6 +1435,17 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta, uint32_t flags) {
         mQuirks &= ~kOutputBuffersAreUnreadable;
     }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    mNSecsToWait = 5000000000; // 5 seconds
+    const char *flash_fp_usecase;
+    const char *flash_em_usecase;
+    if ((meta->findCString('fpfl', &flash_fp_usecase)) ||
+        (meta->findCString('fpem', &flash_em_usecase))) {
+        LOGD("\n\n\n Executing a flash usecase \n\n\n");
+        mNSecsToWait = 0;
+    }
+#endif
+
     return OK;
 }
 
@@ -751,6 +1463,17 @@ void OMXCodec::setMinBufferSize(OMX_U32 portIndex, OMX_U32 size) {
         def.nBufferSize = size;
     }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    /* Aligning the buffer size as observed memory failures in allocateBuffersOnPort
+     * for input port incase buffer sizes are not Cache line boundary aligned.
+     * Actually the Memory Dealer allocates a large chunk for the Total buffer size.
+     * While requesting individual buffers, it provides chunks (offset) from the large
+     * memory. During this, it provides address based on Cache line boundary. Hence
+     * there would not be sufficient memory for the last chunk and it fails */
+    def.nBufferSize = ((def.nBufferSize + CACHELINE_BOUNDARY_MEMALIGNMENT - 1) &
+                        ~(CACHELINE_BOUNDARY_MEMALIGNMENT - 1));
+#endif
+
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, OK);
@@ -798,7 +1521,8 @@ status_t OMXCodec::setVideoPortFormatType(
              index, format.eCompressionFormat, format.eColorFormat);
 #endif
 
-        if (!strcmp("OMX.TI.Video.encoder", mComponentName)) {
+        if (!strcmp("OMX.TI.Video.encoder", mComponentName) ||
+            !strcmp("OMX.TI.720P.Encoder", mComponentName)) {
             if (portIndex == kPortIndexInput
                     && colorFormat == format.eColorFormat) {
                 // eCompressionFormat does not seem right.
@@ -813,6 +1537,20 @@ status_t OMXCodec::setVideoPortFormatType(
             }
         }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        if (!strcmp("OMX.TI.DUCATI1.VIDEO.DECODER", mComponentName)) {
+            if ( (compressionFormat == OMX_VIDEO_CodingH263) &&
+                 (format.eCompressionFormat != compressionFormat) ) {
+                // Ducati Decoder returns MPEG4 as default compression type.
+                // Update H263 compression type
+                format.eCompressionFormat=compressionFormat;
+                found = true;
+                break;
+            }
+        format.eColorFormat = colorFormat; //HACK. Should be removed in 1.20 ducati release
+        }
+#endif
+
         if (format.eCompressionFormat == compressionFormat
             && format.eColorFormat == colorFormat) {
             found = true;
@@ -845,6 +1583,11 @@ static size_t getFrameSize(
         case OMX_COLOR_FormatYUV420SemiPlanar:
             return (width * height * 3) / 2;
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+        case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+            return (4096 * height *3)/2;
+#endif
+
         default:
             CHECK(!"Should not be here. Unsupported color format.");
             break;
@@ -861,7 +1604,8 @@ status_t OMXCodec::findTargetColorFormat(
     if (meta->findInt32(kKeyColorFormat, &targetColorFormat)) {
         *colorFormat = (OMX_COLOR_FORMATTYPE) targetColorFormat;
     } else {
-        if (!strcasecmp("OMX.TI.Video.encoder", mComponentName)) {
+        if (!strcasecmp("OMX.TI.Video.encoder", mComponentName) ||
+            !strcasecmp("OMX.TI.720P.Encoder", mComponentName)) {
             *colorFormat = OMX_COLOR_FormatYCbYCr;
         }
     }
@@ -915,12 +1659,20 @@ void OMXCodec::setVideoInputFormat(
         const char *mime, const sp<MetaData>& meta) {
 
     int32_t width, height, frameRate, bitRate, stride, sliceHeight;
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    int32_t paddedWidth, paddedHeight;
+#endif
     bool success = meta->findInt32(kKeyWidth, &width);
     success = success && meta->findInt32(kKeyHeight, &height);
     success = success && meta->findInt32(kKeySampleRate, &frameRate);
     success = success && meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeyStride, &stride);
     success = success && meta->findInt32(kKeySliceHeight, &sliceHeight);
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    success = success && meta->findInt32(kKeyPaddedWidth, &paddedWidth);
+    success = success && meta->findInt32(kKeyPaddedHeight, &paddedHeight);
+#endif
+
     CHECK(success);
     CHECK(stride != 0);
 
@@ -931,6 +1683,12 @@ void OMXCodec::setVideoInputFormat(
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
+#ifdef OMAP_ENHANCEMENT
+    }
+    else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV, mime))
+    {
+        compressionFormat = OMX_VIDEO_CodingWMV;
+#endif
     } else {
         LOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -955,15 +1713,37 @@ void OMXCodec::setVideoInputFormat(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, OK);
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    def.nBufferSize = getFrameSize(colorFormat,
+            stride > 0? stride: -stride, paddedHeight);
+#else
     def.nBufferSize = getFrameSize(colorFormat,
             stride > 0? stride: -stride, sliceHeight);
+#endif
 
     CHECK_EQ(def.eDomain, OMX_PortDomainVideo);
 
     video_def->nFrameWidth = width;
     video_def->nFrameHeight = height;
     video_def->nStride = stride;
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    if( !strcmp(mComponentName,"OMX.TI.DUCATI1.VIDEO.H264E")
+        || !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E")){
+        video_def->nStride = 4096; // TI 2D-Buffer specific Hardcoding
+    }
+
+    def.nBufferCountActual = INPUT_BUFFER_COUNT;
+    if(!strcmp(mComponentName,"OMX.TI.DUCATI1.VIDEO.H264E"))
+    {
+#ifdef SUPPORT_B_FRAMES
+        def.nBufferCountActual = OMX_NUM_B_FRAMES + 1;;
+#else
+        def.nBufferCountActual = 2;
+#endif
+    }
+#else
     video_def->nSliceHeight = sliceHeight;
+#endif
     video_def->xFramerate = (frameRate << 16);  // Q16 format
     video_def->eCompressionFormat = OMX_VIDEO_CodingUnused;
     video_def->eColorFormat = colorFormat;
@@ -987,7 +1767,7 @@ void OMXCodec::setVideoInputFormat(
 
     video_def->nFrameWidth = width;
     video_def->nFrameHeight = height;
-    video_def->xFramerate = 0;      // No need for output port
+    video_def->xFramerate = (frameRate << 16);      // Value is used on output port for rate control
     video_def->nBitrate = bitRate;  // Q16 format
     video_def->eCompressionFormat = compressionFormat;
     video_def->eColorFormat = OMX_COLOR_FormatUnused;
@@ -996,10 +1776,40 @@ void OMXCodec::setVideoInputFormat(
         def.nBufferSize = ((def.nBufferSize * 3) >> 1);
     }
 
+#ifdef TARGET_OMAP4
+    def.nBufferCountActual = OUTPUT_BUFFER_COUNT;
+#endif
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, OK);
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    if( !strcmp(mComponentName,"OMX.TI.DUCATI1.VIDEO.H264E")
+        || !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E")){
+
+        //OMX_TI_IndexParam2DBufferAllocDimension
+        OMX_CONFIG_RECTTYPE tFrameDim;
+        tFrameDim.nPortIndex = kPortIndexInput;
+        tFrameDim.nWidth = paddedWidth;
+        tFrameDim.nHeight = paddedHeight;
+        InitOMXParams(&tFrameDim);
+
+        err = mOMX->setParameter( mNode, (OMX_INDEXTYPE)OMX_TI_IndexParam2DBufferAllocDimension, &tFrameDim, sizeof(tFrameDim));
+            CHECK_EQ(err, OK);
+
+        //OMX_TI_IndexParamBufferPreAnnouncement
+        OMX_TI_PARAM_BUFFERPREANNOUNCE PreAnnouncement;
+        InitOMXParams(&PreAnnouncement);
+        PreAnnouncement.nPortIndex = kPortIndexInput;
+        err = mOMX->getParameter( mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamBufferPreAnnouncement, &PreAnnouncement, sizeof(PreAnnouncement));
+        CHECK_EQ(err, OK);
+
+        PreAnnouncement.bEnabled = OMX_FALSE;
+        err = mOMX->setParameter( mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamBufferPreAnnouncement, &PreAnnouncement,sizeof(PreAnnouncement));
+        CHECK_EQ(err, OK);
+    }
+#endif
+
     /////////////////// Codec-specific ////////////////////////
     switch (compressionFormat) {
         case OMX_VIDEO_CodingMPEG4:
@@ -1049,8 +1859,13 @@ status_t OMXCodec::setupErrorCorrectionParameters() {
     }
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    errorCorrectionType.bEnableResync = OMX_FALSE;
+    errorCorrectionType.nResynchMarkerSpacing = 0;
+#else
     errorCorrectionType.bEnableResync = OMX_TRUE;
     errorCorrectionType.nResynchMarkerSpacing = 256;
+#endif
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
@@ -1075,7 +1890,19 @@ status_t OMXCodec::setupBitRate(int32_t bitRate) {
             &bitrateType, sizeof(bitrateType));
     CHECK_EQ(err, OK);
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+    if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.H264E"))
+    {
+        bitrateType.eControlRate = OMX_Video_ControlRateVariable;
+    }
+    else if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E"))
+    {
+        bitrateType.eControlRate = OMX_Video_ControlRateVariable;
+    }
+#else
     bitrateType.eControlRate = OMX_Video_ControlRateVariable;
+#endif
+
     bitrateType.nTargetBitrate = bitRate;
 
     err = mOMX->setParameter(
@@ -1085,6 +1912,120 @@ status_t OMXCodec::setupBitRate(int32_t bitRate) {
     return OK;
 }
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+status_t OMXCodec::setupEncoderPresetParams(int32_t isS3DEnabled) {
+    OMX_VIDEO_PARAM_ENCODER_PRESETTYPE EncoderPreset;
+    status_t Err = OK;
+
+    /*Encoder Preset settings*/
+    InitOMXParams(&EncoderPreset);
+    EncoderPreset.nPortIndex = kPortIndexOutput;
+    Err = mOMX->getParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoEncoderPreset, &EncoderPreset,sizeof(EncoderPreset));
+    CHECK_EQ(Err, OK);
+
+    if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.H264E"))
+    {
+//#ifdef FOURMV_ENABLED
+        if(isS3DEnabled)
+            EncoderPreset.eEncodingModePreset = OMX_Video_Enc_User_Defined;
+        else
+            EncoderPreset.eEncodingModePreset = OMX_Video_Enc_Med_Speed_High_Quality;
+
+        EncoderPreset.eRateControlPreset= OMX_Video_RC_Storage ; //mpeg4VencClient->encoderPreset.eRateControlPreset;  // 4
+//#endif
+    }
+    else if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E"))
+    {
+        EncoderPreset.eEncodingModePreset = OMX_Video_Enc_User_Defined; // mpeg4VencClient->encoderPreset.eEncodingModePreset; // 2
+        EncoderPreset.eRateControlPreset= OMX_Video_RC_Storage ; //mpeg4VencClient->encoderPreset.eRateControlPreset;  // 4
+    }
+
+    Err = mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoEncoderPreset, &EncoderPreset,sizeof(EncoderPreset));
+    CHECK_EQ(Err, OK);
+
+    return Err;
+}
+#endif
+
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+
+static int32_t getFrameLayout(const char* frameLayout)
+{
+    if (!strcmp(frameLayout, TICameraParameters::S3D_TB_FULL)) {
+       return OMX_TI_Video_FRAMEPACK_TOP_BOTTOM;
+    }
+
+    if (!strcmp(frameLayout, TICameraParameters::S3D_SS_FULL)) {
+        return OMX_TI_Video_FRAMEPACK_SIDE_BY_SIDE;
+    }
+    if (!strcmp(frameLayout, TICameraParameters::S3D_TB_SUBSAMPLED)) {
+        return OMX_TI_Video_FRAMEPACK_TOP_BOTTOM;
+    }
+
+    if (!strcmp(frameLayout,TICameraParameters::S3D_SS_SUBSAMPLED)) {
+       return OMX_TI_Video_FRAMEPACK_SIDE_BY_SIDE;
+    }
+
+    LOGE("Unsupported frame layout (%s)", frameLayout);
+
+    CHECK_EQ(0, "Unsupported frame layout");
+    return OMX_TI_Video_FRAMEPACK_TOP_BOTTOM;
+}
+
+status_t OMXCodec::setupEncoderFrameDataContentParams(const sp<MetaData>& meta) {
+    OMX_TI_VIDEO_PARAM_FRAMEDATACONTENTTYPE FrameDataType;
+    status_t Err = OK;
+    int32_t seiEncodingType;
+    const char *frameLayout;
+
+    bool success = meta->findInt32(kKeySEIEncodingType, &seiEncodingType);
+    CHECK(success);
+
+    InitOMXParams(&FrameDataType);
+    FrameDataType.nPortIndex = kPortIndexInput;
+    Err = mOMX->getParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoFrameDataContentSettings, &FrameDataType,sizeof(FrameDataType));
+    CHECK_EQ(Err, OK);
+
+    FrameDataType.eContentType = (OMX_TI_VIDEO_FRAMECONTENTTYPE) seiEncodingType;
+    Err = mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamVideoFrameDataContentSettings, &FrameDataType,sizeof(FrameDataType));
+    CHECK_EQ(Err, OK);
+
+    if(OMX_TI_Video_AVC_2010_StereoFramePackingType == seiEncodingType) {
+        success = meta->findCString(kKeyFrameLayout, &frameLayout);
+        CHECK(success);
+
+        OMX_TI_VIDEO_PARAM_AVCENC_FRAMEPACKINGINFO2010 SettingsSEI2010;
+        InitOMXParams(&SettingsSEI2010);
+        SettingsSEI2010.nPortIndex = kPortIndexInput;
+        Err = mOMX->getParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamStereoFramePacking2010Settings, &SettingsSEI2010,sizeof(SettingsSEI2010));
+        CHECK_EQ(Err, OK);
+
+        SettingsSEI2010.eFramePackingType = (OMX_TI_VIDEO_AVCSTEREO_FRAMEPACKTYPE) getFrameLayout(frameLayout);
+        SettingsSEI2010.nFrame0PositionX = 0;
+        SettingsSEI2010.nFrame0PositionY = 0;
+        SettingsSEI2010.nFrame1PositionX = 0;
+        SettingsSEI2010.nFrame1PositionY = 0;
+        Err = mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamStereoFramePacking2010Settings, &SettingsSEI2010,sizeof(SettingsSEI2010));
+        CHECK_EQ(Err, OK);
+    }
+    else if(OMX_TI_Video_AVC_2004_StereoInfoType == seiEncodingType)
+    {
+        OMX_TI_VIDEO_PARAM_AVCENC_STEREOINFO2004 SettingsSEI2004;
+        InitOMXParams(&SettingsSEI2004);
+        SettingsSEI2004.nPortIndex = kPortIndexInput;
+        Err = mOMX->getParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamStereoInfo2004Settings, &SettingsSEI2004,sizeof(SettingsSEI2004));
+        CHECK_EQ(Err, OK);
+
+        SettingsSEI2004.btopFieldIsLeftViewFlag = OMX_TRUE;
+        SettingsSEI2004.bViewSelfContainedFlag = OMX_FALSE;
+        Err = mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamStereoInfo2004Settings, &SettingsSEI2004,sizeof(SettingsSEI2004));
+        CHECK_EQ(Err, OK);
+    }
+
+    return Err;
+}
+#endif
+
 status_t OMXCodec::getVideoProfileLevel(
         const sp<MetaData>& meta,
         const CodecProfileLevel& defaultProfileLevel,
@@ -1146,7 +2087,9 @@ status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
 
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamVideoH263, &h263type, sizeof(h263type));
-    CHECK_EQ(err, OK);
+    if (!(mQuirks & kCanNotSetVideoParameters)) {
+        CHECK_EQ(err, OK);
+    }
 
     h263type.nAllowedPictureTypes =
         OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP;
@@ -1171,12 +2114,58 @@ status_t OMXCodec::setupH263EncoderParameters(const sp<MetaData>& meta) {
     h263type.nPictureHeaderRepetition = 0;
     h263type.nGOBHeaderInterval = 0;
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+    h263type.eProfile = OMX_VIDEO_H263ProfileBaseline;
+    h263type.eLevel =  OMX_VIDEO_H263Level70;
+#endif
+
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoH263, &h263type, sizeof(h263type));
-    CHECK_EQ(err, OK);
+    if (!(mQuirks & kCanNotSetVideoParameters)) {
+        CHECK_EQ(err, OK);
+    }
 
     CHECK_EQ(setupBitRate(bitRate), OK);
     CHECK_EQ(setupErrorCorrectionParameters(), OK);
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+    CHECK_EQ(setupEncoderPresetParams(false), OK);
+
+     //OMX_VIDEO_PARAM_MOTIONVECTORTYPE Settings
+    OMX_VIDEO_PARAM_MOTIONVECTORTYPE MotionVector;
+    OMX_VIDEO_PARAM_INTRAREFRESHTYPE RefreshParam;
+    InitOMXParams(&MotionVector);
+    MotionVector.nPortIndex = kPortIndexOutput;
+
+    err = mOMX->getParameter(
+            mNode, OMX_IndexParamVideoMotionVector, &MotionVector,sizeof(MotionVector));
+
+    MotionVector.nPortIndex = kPortIndexOutput;
+
+    // extra parameters - hardcoded
+    MotionVector.sXSearchRange = 16;
+    MotionVector.sYSearchRange = 16;
+    MotionVector.bFourMV =  OMX_FALSE;
+    MotionVector.eAccuracy =  OMX_Video_MotionVectorHalfPel ;
+    MotionVector.bUnrestrictedMVs = OMX_TRUE;
+
+    err = mOMX->setParameter(
+            mNode, OMX_IndexParamVideoMotionVector, &MotionVector,sizeof(MotionVector));
+
+    //OMX_VIDEO_PARAM_INTRAREFRESHTYPE Settings
+     InitOMXParams(&RefreshParam);
+    RefreshParam.nPortIndex = kPortIndexOutput;
+
+    err = mOMX->getParameter(
+            mNode, OMX_IndexParamVideoIntraRefresh, &RefreshParam,sizeof(RefreshParam));
+
+    // extra parameters - hardcoded based on PV defaults
+    RefreshParam.nPortIndex = kPortIndexOutput;
+    RefreshParam.eRefreshMode = OMX_VIDEO_IntraRefreshBoth;
+    //RefreshParam.nCirMBs = 0;
+
+    err = mOMX->setParameter(mNode, OMX_IndexParamVideoIntraRefresh, &RefreshParam,sizeof(RefreshParam));
+#endif
+
 
     return OK;
 }
@@ -1202,7 +2191,12 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
     mpeg4type.nAllowedPictureTypes =
         OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP;
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    mpeg4type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate) -1;
+#else
     mpeg4type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate);
+#endif
+
     if (mpeg4type.nPFrames == 0) {
         mpeg4type.nAllowedPictureTypes = OMX_VIDEO_PictureTypeI;
     }
@@ -1210,6 +2204,20 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
     mpeg4type.nIDCVLCThreshold = 0;
     mpeg4type.bACPred = OMX_TRUE;
     mpeg4type.nMaxPacketSize = 256;
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    int32_t width, height;
+    success = success && meta->findInt32(kKeyWidth, &width);
+    success = success && meta->findInt32(kKeyHeight, &height);
+    // In order to have normal amount of resync markers(and packets) in the encoded stream,
+    // we need set this value to 4096, this will reduce the number of bits used for marking
+    // seperate packets in the stream and allow us to use these bits for other purposes.
+    if((width >= 640) || (height >= 480)) {
+    // To improve performance
+        if( (frameRate > 15) && (bitRate > 2000000)) {
+            mpeg4type.bACPred = OMX_FALSE;
+        }
+    }
+#endif
     mpeg4type.nTimeIncRes = 1000;
     mpeg4type.nHeaderExtension = 0;
     mpeg4type.bReversibleVLC = OMX_FALSE;
@@ -1222,19 +2230,69 @@ status_t OMXCodec::setupMPEG4EncoderParameters(const sp<MetaData>& meta) {
     if (err != OK) return err;
     mpeg4type.eProfile = static_cast<OMX_VIDEO_MPEG4PROFILETYPE>(profileLevel.mProfile);
     mpeg4type.eLevel = static_cast<OMX_VIDEO_MPEG4LEVELTYPE>(profileLevel.mLevel);
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    mpeg4type.eLevel = OMX_VIDEO_MPEG4Level5;
+#endif
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoMpeg4, &mpeg4type, sizeof(mpeg4type));
-    CHECK_EQ(err, OK);
+    if (!(mQuirks & kCanNotSetVideoParameters)) {
+        CHECK_EQ(err, OK);
+    }
 
     CHECK_EQ(setupBitRate(bitRate), OK);
     CHECK_EQ(setupErrorCorrectionParameters(), OK);
 
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+     //OMX_VIDEO_PARAM_MOTIONVECTORTYPE Settings
+    OMX_VIDEO_PARAM_MOTIONVECTORTYPE MotionVector;
+    OMX_VIDEO_PARAM_INTRAREFRESHTYPE RefreshParam;
+    InitOMXParams(&MotionVector);
+    MotionVector.nPortIndex = kPortIndexOutput;
+
+    err = mOMX->getParameter(
+            mNode, OMX_IndexParamVideoMotionVector, &MotionVector,sizeof(MotionVector));
+
+    MotionVector.nPortIndex = kPortIndexOutput;
+
+    // extra parameters - hardcoded
+    MotionVector.sXSearchRange = 16;
+    MotionVector.sYSearchRange = 16;
+    MotionVector.bFourMV =  OMX_FALSE;
+    MotionVector.eAccuracy =  OMX_Video_MotionVectorHalfPel ;
+    MotionVector.bUnrestrictedMVs = OMX_TRUE;
+
+    err = mOMX->setParameter(
+            mNode, OMX_IndexParamVideoMotionVector, &MotionVector,sizeof(MotionVector));
+
+    //OMX_VIDEO_PARAM_INTRAREFRESHTYPE Settings
+     InitOMXParams(&RefreshParam);
+    RefreshParam.nPortIndex = kPortIndexOutput;
+
+    err = mOMX->getParameter(
+            mNode, OMX_IndexParamVideoIntraRefresh, &RefreshParam,sizeof(RefreshParam));
+
+    // extra parameters - hardcoded based on PV defaults
+    RefreshParam.nPortIndex = kPortIndexOutput;
+    RefreshParam.eRefreshMode = OMX_VIDEO_IntraRefreshBoth;
+
+    if(((width >= 640) || (height >= 480)) && (frameRate > 15) && (bitRate > 2000000))
+    {
+        RefreshParam.nAirRef = 0;
+    }
+
+    err = mOMX->setParameter(mNode, OMX_IndexParamVideoIntraRefresh, &RefreshParam,sizeof(RefreshParam));
+#endif
+
     return OK;
 }
 
 status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
     int32_t iFramesInterval, frameRate, bitRate;
+
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+    OMX_VIDEO_PARAM_VBSMCTYPE VbsmcType;
+#endif
     bool success = meta->findInt32(kKeyBitRate, &bitRate);
     success = success && meta->findInt32(kKeySampleRate, &frameRate);
     success = success && meta->findInt32(kKeyIFramesInterval, &iFramesInterval);
@@ -1252,8 +2310,26 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
         OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP;
 
     h264type.nSliceHeaderSpacing = 0;
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    h264type.nBFrames = OMX_NUM_B_FRAMES;
+    h264type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate);
+
+#ifdef SUPPORT_B_FRAMES
+    int32_t remainder = h264type.nPFrames % (OMX_NUM_B_FRAMES + 1);
+    if(remainder)
+    {
+        LOGD("h264type.nPFrames=%d", (int) h264type.nPFrames);
+        h264type.nPFrames = h264type.nPFrames - remainder;
+        LOGD("adjusted to h264type.nPFrames=%d", (int) h264type.nPFrames);
+    }
+#endif
+
+#else
     h264type.nBFrames = 0;   // No B frames support yet
     h264type.nPFrames = setPFramesSpacing(iFramesInterval, frameRate);
+#endif
+
     if (h264type.nPFrames == 0) {
         h264type.nAllowedPictureTypes = OMX_VIDEO_PictureTypeI;
     }
@@ -1263,17 +2339,35 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
     defaultProfileLevel.mProfile = h264type.eProfile;
     defaultProfileLevel.mLevel = h264type.eLevel;
     err = getVideoProfileLevel(meta, defaultProfileLevel, profileLevel);
-    if (err != OK) return err;
+    if (!(mQuirks & kCanNotSetVideoParameters) && err != OK) return err;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    h264type.eProfile = OMX_VIDEO_AVCProfileHigh;
+    h264type.eLevel = OMX_VIDEO_AVCLevel4;
+    LOGV("h264type.eProfile=%d, h264type.eLevel=%d", h264type.eProfile, h264type.eLevel);
+#else
     h264type.eProfile = static_cast<OMX_VIDEO_AVCPROFILETYPE>(profileLevel.mProfile);
     h264type.eLevel = static_cast<OMX_VIDEO_AVCLEVELTYPE>(profileLevel.mLevel);
+#endif
 
-    if (h264type.eProfile == OMX_VIDEO_AVCProfileBaseline) {
+    if (h264type.eProfile == OMX_VIDEO_AVCProfileBaseline
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+       || h264type.eProfile == OMX_VIDEO_AVCProfileMain
+       || h264type.eProfile == OMX_VIDEO_AVCProfileHigh
+#endif
+       ) {
         h264type.bUseHadamard = OMX_TRUE;
         h264type.nRefFrames = 1;
         h264type.nRefIdx10ActiveMinus1 = 0;
         h264type.nRefIdx11ActiveMinus1 = 0;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        h264type.bEntropyCodingCABAC = OMX_TRUE;
+#else
         h264type.bEntropyCodingCABAC = OMX_FALSE;
+#endif
         h264type.bWeightedPPrediction = OMX_FALSE;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        h264type.nWeightedBipredicitonMode = OMX_FALSE;
+#endif
         h264type.bconstIpred = OMX_FALSE;
         h264type.bDirect8x8Inference = OMX_FALSE;
         h264type.bDirectSpatialTemporal = OMX_FALSE;
@@ -1294,10 +2388,74 @@ status_t OMXCodec::setupAVCEncoderParameters(const sp<MetaData>& meta) {
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoAvc, &h264type, sizeof(h264type));
-    CHECK_EQ(err, OK);
+    if (!(mQuirks & kCanNotSetVideoParameters)) {
+        CHECK_EQ(err, OK);
+    }
 
     CHECK_EQ(setupBitRate(bitRate), OK);
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+    //OMX_IndexParamVideoMotionVector+
+    OMX_VIDEO_PARAM_MOTIONVECTORTYPE MotionVector;
+    InitOMXParams(&MotionVector);
+    MotionVector.nPortIndex = kPortIndexOutput;
+
+    err = mOMX->getParameter(mNode, OMX_IndexParamVideoMotionVector, &MotionVector, sizeof(MotionVector));
+    CHECK_EQ(err, OK);
+
+    // extra parameters - hardcoded
+    MotionVector.sXSearchRange = 16;
+    MotionVector.sYSearchRange = 16;
+    MotionVector.sXSearchRange = 144; // Set Horizontal search range to 144
+    MotionVector.sYSearchRange = 32; // Set Vertical search range to 32
+    MotionVector.bFourMV =  OMX_FALSE;
+    MotionVector.eAccuracy = OMX_Video_MotionVectorQuarterPel; // hardcoded
+    MotionVector.bUnrestrictedMVs = OMX_TRUE;
+
+    err = mOMX->setParameter(mNode, OMX_IndexParamVideoMotionVector, &MotionVector, sizeof(MotionVector));
+    CHECK_EQ(err, OK);
+
+    //OMX_IndexParamVideoIntraRefresh+
+    OMX_VIDEO_PARAM_INTRAREFRESHTYPE RefreshParam;
+    InitOMXParams(&RefreshParam);
+    RefreshParam.nPortIndex = kPortIndexOutput;
+
+    err = mOMX->getParameter(mNode, OMX_IndexParamVideoIntraRefresh, &RefreshParam, sizeof(RefreshParam));
+    CHECK_EQ(err, OK);
+
+    // extra parameters - hardcoded
+    RefreshParam.nPortIndex = kPortIndexOutput;
+    RefreshParam.eRefreshMode = OMX_VIDEO_IntraRefreshMax;//OMX_VIDEO_IntraRefreshBoth;
+    RefreshParam.nCirMBs = 0; //TO DO: need to confirm again.
+
+    err = mOMX->setParameter(mNode, OMX_IndexParamVideoIntraRefresh, &RefreshParam, sizeof(RefreshParam));
+    CHECK_EQ(err, OK);
+
+    int32_t isS3DEnabled = false;
+    success = success && meta->findInt32(kKeyS3dSupported, &isS3DEnabled);
+    CHECK(success);
+
+    //OMX_TI_IndexParamVideoEncoderPreset+
+    CHECK_EQ(setupEncoderPresetParams(isS3DEnabled), OK);
+
+    //OMX_TI_IndexParamVideoFrameDataContentSettings+
+    if(isS3DEnabled)
+        CHECK_EQ(setupEncoderFrameDataContentParams(meta), OK);
+
+    //OMX_IndexParamVideoVBSMC+
+    InitOMXParams(&VbsmcType);
+    VbsmcType.nPortIndex = kPortIndexOutput;
+
+    err = mOMX->getParameter(mNode, OMX_IndexParamVideoVBSMC, &VbsmcType,sizeof(VbsmcType));
+    CHECK_EQ(err, OK);
+
+    VbsmcType.b16x16 = OMX_TRUE;
+    VbsmcType.b16x8 = VbsmcType.b8x16 = VbsmcType.b8x8 = VbsmcType.b8x4 = VbsmcType.b4x8 = VbsmcType.b4x4 = OMX_FALSE;
+
+    err =mOMX->setParameter(mNode, OMX_IndexParamVideoVBSMC, &VbsmcType,sizeof(VbsmcType));
+    CHECK_EQ(err, OK);
+#endif
+
     return OK;
 }
 
@@ -1312,6 +2470,18 @@ status_t OMXCodec::setVideoOutputFormat(
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
+#if defined(OMAP_ENHANCEMENT) || defined(OMAP_COMPAT)
+#if defined(TARGET_OMAP4)
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP6, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP6;
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_VP7, mime)) {
+        compressionFormat = (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP7;
+#endif
+    }
+    else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_WMV , mime))
+    {
+        compressionFormat = OMX_VIDEO_CodingWMV;
+#endif
     } else {
         LOGE("Not a supported video mime type: %s", mime);
         CHECK(!"Should not be here. Not a supported video mime type.");
@@ -1329,7 +2499,31 @@ status_t OMXCodec::setVideoOutputFormat(
         OMX_VIDEO_PARAM_PORTFORMATTYPE format;
         InitOMXParams(&format);
         format.nPortIndex = kPortIndexOutput;
+
+        // For 3rd party applications we want to iterate through all the
+        // supported color formats by the OMX component. If OMX codec is
+        // being run in a sepparate process, then pick the second iterated
+        // color format.
+#if 1
+        if (!strncmp(mComponentName, "OMX.qcom.7x30",13)) {
+            OMX_U32 index;
+	    
+            for(index = 0 ;; index++){
+              format.nIndex = index;
+	      if(mOMX->getParameter(
+			    mNode, OMX_IndexParamVideoPortFormat,
+			    &format, sizeof(format)) != OK) {
+		if(format.nIndex) format.nIndex--;
+		break;
+	      }
+            }
+            if(mOMXLivesLocally)
+              format.nIndex = 0;
+        } else
+          format.nIndex = 0;
+#else
         format.nIndex = 0;
+#endif
 
         status_t err = mOMX->getParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
@@ -1338,11 +2532,18 @@ status_t OMXCodec::setVideoOutputFormat(
         CHECK_EQ(format.eCompressionFormat, OMX_VIDEO_CodingUnused);
 
         static const int OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00;
+        static const int QOMX_COLOR_FormatYVU420PackedSemiPlanar32m4ka = 0x7FA30C01;
+        static const int QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03;
 
         CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
                || format.eColorFormat == OMX_COLOR_FormatCbYCrY
-               || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar);
+               || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+               || format.eColorFormat == QOMX_COLOR_FormatYVU420PackedSemiPlanar32m4ka
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+               || format.eColorFormat == OMX_COLOR_FormatYUV420PackedSemiPlanar
+#endif
+               || format.eColorFormat == QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka);
 
         err = mOMX->setParameter(
                 mNode, OMX_IndexParamVideoPortFormat,
@@ -1365,6 +2566,18 @@ status_t OMXCodec::setVideoOutputFormat(
 
     CHECK_EQ(err, OK);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) {
+                //update input buffer size as per resolution
+                def.nBufferSize = width * height;
+
+         if(mQuirks & OMXCodec::kThumbnailMode){
+                def.nBufferCountActual = 1;
+         }else{
+                def.nBufferCountActual = 4;
+    }
+    }
+#else
 #if 1
     // XXX Need a (much) better heuristic to compute input buffer sizes.
     const size_t X = 64 * 1024;
@@ -1372,6 +2585,7 @@ status_t OMXCodec::setVideoOutputFormat(
         def.nBufferSize = X;
     }
 #endif
+#endif
 
     CHECK_EQ(def.eDomain, OMX_PortDomainVideo);
 
@@ -1403,12 +2617,103 @@ status_t OMXCodec::setVideoOutputFormat(
         (((width + 15) & -16) * ((height + 15) & -16) * 3) / 2;  // YUV420
 #endif
 
+#if defined(OMAP_ENHANCEMENT)
+#if defined(TARGET_OMAP4)
+    if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) {
+
+        OMX_CONFIG_RECTTYPE tParamStruct;
+        InitOMXParams(&tParamStruct);
+        tParamStruct.nPortIndex = kPortIndexOutput;
+
+        err = mOMX->getParameter(
+                mNode, (OMX_INDEXTYPE)OMX_TI_IndexParam2DBufferAllocDimension, &tParamStruct, sizeof(tParamStruct));
+
+        CHECK_EQ(err, OK);
+
+        video_def->nStride = tParamStruct.nWidth;
+        mStride = video_def->nStride ;
+
+        if(mQuirks & kInterlacedOutputContent){
+            video_def->eColorFormat = (OMX_COLOR_FORMATTYPE) OMX_TI_COLOR_FormatYUV420PackedSemiPlanar_Sequential_TopBottom;
+        }
+
+        video_def->xFramerate = mVideoFPS << 16;
+    }
+
+    if(!(mQuirks & OMXCodec::kThumbnailMode)){
+            //playback usecase. Calculate the buffer count to take display optimal buffer count into account
+            //Note: this is applicable for both ducati and h/w codecs
+            //def.nBufferCountMin    => minimum no of buffers required on a port (communicated by codec)
+            //def.nBufferCountActual => actual no. of buffers allocated on a port (communicated to codec)
+            def.nBufferCountActual = def.nBufferCountMin + (2 * NUM_BUFFERS_TO_BE_QUEUED_FOR_OPTIMAL_PERFORMANCE);
+            if (def.nBufferCountActual > 20) def.nBufferCountActual = 20;
+    }
+#elif defined(TARGET_OMAP3)
+    // Suppress output buffer count for OMAP3
+    // The number of VRFB buffer, which is used for rotation, is 4.
+    // Output buffer count can not exceed VRFB buffer count.
+    if (def.nBufferCountActual > OUTPUT_BUFFER_COUNT)
+        def.nBufferCountActual = OUTPUT_BUFFER_COUNT;
+#endif
+#endif
     video_def->nFrameWidth = width;
     video_def->nFrameHeight = height;
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")) {
+
+        if(mQuirks & OMXCodec::kThumbnailMode){
+
+            LOGD("Thumbnail Mode");
+            //Get the calculated min buffer count
+            err = mOMX->getParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            CHECK_EQ(err, OK);
+            CHECK_EQ(def.eDomain, OMX_PortDomainVideo);
+
+            //Thumbnail usecase. Set buffer count to optimal
+            def.nBufferCountActual = def.nBufferCountMin;
+
+            //Set the proper parameters again, as it is marshalled in Get_Parameter()
+            video_def->nFrameWidth = width;
+            video_def->nFrameHeight = height;
+
+            err = mOMX->setParameter(
+                    mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+            CHECK_EQ(err, OK);
+
+#if defined (NPA_BUFFERS)
+            CODEC_LOGV("Setting up the non-pre-annoucement mode");
+            OMX_TI_PARAM_BUFFERPREANNOUNCE PreAnnouncement;
+            InitOMXParams(&PreAnnouncement);
+            PreAnnouncement.nPortIndex = def.nPortIndex;
+            err = mOMX->getParameter(
+                    mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamBufferPreAnnouncement, &PreAnnouncement, sizeof(PreAnnouncement));
+               if (err != OMX_ErrorNone)
+            {
+                CODEC_LOGE("get OMX_TI_IndexParamBufferPreAnnouncement err : %x",err);
+            }
+
+            //Set the pre-annoucement to be false. i.e we will provide the buffer when we get it from camera.
+            PreAnnouncement.bEnabled = OMX_FALSE;
+            err = mOMX->setParameter(
+                    mNode, (OMX_INDEXTYPE)OMX_TI_IndexParamBufferPreAnnouncement, &PreAnnouncement, sizeof(PreAnnouncement));
+            if (err != OMX_ErrorNone)
+            {
+                CODEC_LOGE("set OMX_TI_IndexParamBufferPreAnnouncement err : %x",err);
+            }
+
+            mNumberOfNPABuffersSent = 0;
+            mThumbnailEOSSent = 0;
+#endif
+
+        }
+   }
+#endif
+
     return err;
 }
 
@@ -1427,6 +2732,7 @@ OMXCodec::OMXCodec(
       mComponentName(strdup(componentName)),
       mSource(source),
       mCodecSpecificDataIndex(0),
+      mPmemInfo(NULL),
       mState(LOADED),
       mInitialBufferSubmit(true),
       mSignalledEOS(false),
@@ -1437,7 +2743,7 @@ OMXCodec::OMXCodec(
       mTargetTimeUs(-1),
       mSkipTimeUs(-1),
       mLeftOverBuffer(NULL),
-      mPaused(false) {
+      mPaused(false){
     mPortStatus[kPortIndexInput] = ENABLED;
     mPortStatus[kPortIndexOutput] = ENABLED;
 
@@ -1469,6 +2775,18 @@ void OMXCodec::setComponentRole(
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
+        { MEDIA_MIMETYPE_VIDEO_VP6,
+            "video_decoder.vp6", NULL },
+        { MEDIA_MIMETYPE_VIDEO_VP7,
+            "video_decoder.vp7", NULL },
+        { MEDIA_MIMETYPE_VIDEO_WMV,
+            "video_decoder.wmv", "video_encoder.wmv" },
+        { MEDIA_MIMETYPE_AUDIO_WMA,
+            "audio_decoder.wma", "audio_encoder.wma" },
+        { MEDIA_MIMETYPE_AUDIO_WMAPRO,
+            "audio_decoder.wmapro", "audio_encoder.wmapro" },
+        { MEDIA_MIMETYPE_AUDIO_WMALSL,
+            "audio_decoder.wmalsl", "audio_encoder.wmalsl" },
     };
 
     static const size_t kNumMimeToRole =
@@ -1596,16 +2914,128 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
             def.nBufferCountActual, def.nBufferSize,
             portIndex == kPortIndexInput ? "input" : "output");
 
-    size_t totalSize = def.nBufferCountActual * def.nBufferSize;
+    size_t totalSize = def.nBufferCountActual * ((def.nBufferSize + 31) & (~31));
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4) && defined (NPA_BUFFERS)
+            if( !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER") &&
+                (mQuirks & OMXCodec::kThumbnailMode) &&
+                (portIndex == kPortIndexOutput)){
+            totalSize = (THUMBNAIL_BUFFERS_NPA_MODE * def.nBufferSize)
+                        + ((def.nBufferCountActual - THUMBNAIL_BUFFERS_NPA_MODE) * NPA_BUFFER_SIZE);
+            }
+#endif
+
+#ifdef OMAP_ENHANCEMENT
+    bool useExternallyAllocatedBuffers = false;
+
+    if ((!strcmp(mComponentName, "OMX.TI.Video.Decoder") ||
+         !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER") ||
+         !strcmp(mComponentName, "OMX.TI.720P.Decoder")) &&
+        (portIndex == kPortIndexOutput) &&
+        (mExtBufferAddresses.size() == def.nBufferCountActual)
+#if defined(TARGET_OMAP4)
+        && !(mQuirks & OMXCodec::kThumbnailMode)
+#endif
+        ){
+
+        // One must use overlay buffers for TI video decoder output port.
+        // So, do not allocate memory here.
+        useExternallyAllocatedBuffers = true;
+    }
+    else{
+        mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
+    }
+
+    sp<IMemory> mem;
+#else
     mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
+#endif
+
+#ifdef USE_GETBUFFERINFO
+    sp<IMemoryHeap> pFrameHeap = NULL;
+    size_t alignedSize = 0;
+    size_t size = 0;
+    if (mIsEncoder && (portIndex == kPortIndexInput) &&
+            (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
+        sp<IMemory> pFrame = NULL;
+        ssize_t offset = 0;
+        size_t nBuffers = 0;
+
+        mSource->getBufferInfo(pFrame, &alignedSize);
+        if (pFrame == NULL)
+            LOGE("pFrame==NULL");
+
+        pFrameHeap = pFrame->getMemory(&offset, &size);
+        nBuffers = pFrameHeap->getSize( )/alignedSize;
+
+        //update OMX with new buffer count.
+        if( nBuffers < def.nBufferCountMin || size < def.nBufferSize ) {
+            LOGE("Buffer count/size less than minimum required");
+            return UNKNOWN_ERROR;
+        }
+
+        if (nBuffers < def.nBufferCountActual) {
+            status_t err = mOMX->setParameter(
+                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+            if (err != OK) {
+                LOGE("Updating buffer count failed");
+                return err;
+            }
+        }
+    }
+#endif
 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
+#ifdef OMAP_ENHANCEMENT
+        if (useExternallyAllocatedBuffers){
+            mem = mExtBufferAddresses[i];
+        }
+        else{
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4) && defined (NPA_BUFFERS)
+            if( !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER") &&
+                (mQuirks & OMXCodec::kThumbnailMode) &&
+                (portIndex == kPortIndexOutput) &&
+                (i>=THUMBNAIL_BUFFERS_NPA_MODE))
+                mem = mDealer[portIndex]->allocate(NPA_BUFFER_SIZE);
+            else
+#endif
+            {
+                if(portIndex == kPortIndexOutput)
+                {
+                    def.nBufferSize = ((def.nBufferSize + CACHELINE_BOUNDARY_MEMALIGNMENT - 1) &
+                      ~(CACHELINE_BOUNDARY_MEMALIGNMENT - 1));
+                }
+                mem = mDealer[portIndex]->allocate(def.nBufferSize);
+            }
+        }
+#else
         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
+#endif
         CHECK(mem.get() != NULL);
 
         BufferInfo info;
         info.mData = NULL;
         info.mSize = def.nBufferSize;
+        info.mAllocatedBuffer = NULL;
+        info.mAllocatedSize = 0;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        //Update Output buffers range as per 2D buffer requirement.
+        //Doubling size to contain (nFilledLen + nOffset) check. Extra range is harmless here.
+        if (!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")){
+            if(useExternallyAllocatedBuffers)
+            {
+                OMX_VIDEO_PORTDEFINITIONTYPE *videoDef = &def.format.video;
+                int32_t padded_height;
+
+                if (!(mOutputFormat->findInt32(kKeyPaddedHeight, &padded_height))) {
+                    padded_height =  videoDef->nFrameHeight;
+                }
+
+                info.mSize = ARM_4K_PAGE_SIZE * padded_height * 2;
+            }
+        }
+#endif
 
         IOMX::buffer_id buffer;
         if (portIndex == kPortIndexInput
@@ -1622,7 +3052,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
             }
         } else if (portIndex == kPortIndexOutput
                 && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {
-            if (mOMXLivesLocally) {
+            if (mOMXLivesLocally || (mQuirks & kDoesNotRequireMemcpyOnOutputPort)) {
                 mem.clear();
 
                 err = mOMX->allocateBuffer(
@@ -1633,7 +3063,35 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                         mNode, portIndex, mem, &buffer);
             }
         } else {
-            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer);
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+                if((!strcmp(mComponentName,"OMX.TI.DUCATI1.VIDEO.H264E")
+                                        || !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E"))
+                                && (portIndex == kPortIndexInput)
+                                && !(mQuirks & kRequiresAllocateBufferOnInputPorts) ){
+                        sp<IMemory> tempmem = mem;
+                        tempmem.clear();
+                        err = mOMX->useBuffer(mNode, portIndex, tempmem, &buffer, mem->size());
+                } else {
+                        err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());
+                }
+#elif defined(USE_GETBUFFERINFO)
+            if(pFrameHeap != NULL && mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
+                ssize_t temp_offset = i * alignedSize;
+                size_t temp_size = size;
+                sp<IMemory> pFrame = NULL;
+                sp<MemoryBase> pFrameBase = new MemoryBase(pFrameHeap, temp_offset, temp_size);
+                pFrame = pFrameBase;
+                LOGI("getParametersSync: pmem_fd = %d, base = %p, temp_offset %d,"
+                    " temp_size %d, alignedSize = %d, pointer %p, Total Size = %d", pFrameHeap->getHeapID(), pFrameHeap->base(), temp_offset,
+                    temp_size, alignedSize, pFrame->pointer(), pFrameHeap->getSize());
+                err = mOMX->useBuffer(mNode, portIndex, pFrame, &buffer);
+            } else
+#endif
+#if !defined(TARGET_OMAP4)
+            {
+                err = mOMX->useBuffer(mNode, portIndex, mem, &buffer);
+            }
+#endif
         }
 
         if (err != OK) {
@@ -1647,11 +3105,14 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
         info.mBuffer = buffer;
         info.mOwnedByComponent = false;
+#ifdef OMAP_ENHANCEMENT
+        info.mOwnedByPlayer = false;
+#endif
         info.mMem = mem;
         info.mMediaBuffer = NULL;
 
         if (portIndex == kPortIndexOutput) {
-            if (!(mOMXLivesLocally
+            if (!((mOMXLivesLocally || (mQuirks & kDoesNotRequireMemcpyOnOutputPort))
                         && (mQuirks & kRequiresAllocateBufferOnOutputPorts)
                         && (mQuirks & kDefersOutputBufferAllocation))) {
                 // If the node does not fill in the buffer ptr at this time,
@@ -1715,8 +3176,7 @@ void OMXCodec::on_message(const omx_message &msg) {
             if (mPortStatus[kPortIndexInput] == DISABLING) {
                 CODEC_LOGV("Port is disabled, freeing buffer %p", buffer);
 
-                status_t err =
-                    mOMX->freeBuffer(mNode, kPortIndexInput, buffer);
+                status_t err = freeBuffer(kPortIndexInput, &buffers->editItemAt(i));
                 CHECK_EQ(err, OK);
 
                 buffers->removeAt(i);
@@ -1724,6 +3184,19 @@ void OMXCodec::on_message(const omx_message &msg) {
                     && mPortStatus[kPortIndexInput] != SHUTTING_DOWN) {
                 CHECK_EQ(mPortStatus[kPortIndexInput], ENABLED);
                 drainInputBuffer(&buffers->editItemAt(i));
+            } else if ((mQuirks & kRequiresFlushBeforeShutdown) && mState == EXECUTING_TO_IDLE && mPortStatus[kPortIndexInput] == SHUTTING_DOWN) {
+                if (countBuffersWeOwn(mPortBuffers[kPortIndexInput]) == mPortBuffers[kPortIndexInput].size()
+                    && countBuffersWeOwn(mPortBuffers[kPortIndexOutput]) == mPortBuffers[kPortIndexOutput].size()) {
+                    CODEC_LOGV("Finished emptying both ports, now completing "
+                         "transition from EXECUTING to IDLE.");
+
+                    status_t err =
+                        mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
+                    CHECK_EQ(err, OK);
+                } else {
+                    LOGV("own %d/%d input and %d/%d output", countBuffersWeOwn(mPortBuffers[kPortIndexInput]), mPortBuffers[kPortIndexInput].size(),
+                        countBuffersWeOwn(mPortBuffers[kPortIndexOutput]), mPortBuffers[kPortIndexOutput].size());
+                }
             }
             break;
         }
@@ -1754,13 +3227,19 @@ void OMXCodec::on_message(const omx_message &msg) {
                      "a FILL_BUFFER_DONE.", buffer);
             }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4) && defined (NPA_BUFFERS)
+        if( !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER") &&
+            (mQuirks & OMXCodec::kThumbnailMode) ){
+            if (mNumberOfNPABuffersSent > 0)
+                mNumberOfNPABuffersSent--;
+        }
+#endif
             info->mOwnedByComponent = false;
 
             if (mPortStatus[kPortIndexOutput] == DISABLING) {
                 CODEC_LOGV("Port is disabled, freeing buffer %p", buffer);
 
-                status_t err =
-                    mOMX->freeBuffer(mNode, kPortIndexOutput, buffer);
+                status_t err = freeBuffer(kPortIndexOutput, &buffers->editItemAt(i));
                 CHECK_EQ(err, OK);
 
                 buffers->removeAt(i);
@@ -1775,7 +3254,7 @@ void OMXCodec::on_message(const omx_message &msg) {
                 CHECK_EQ(mPortStatus[kPortIndexOutput], ENABLED);
 
                 if (info->mMediaBuffer == NULL) {
-                    CHECK(mOMXLivesLocally);
+                    CHECK(mOMXLivesLocally || (mQuirks & kDoesNotRequireMemcpyOnOutputPort));
                     CHECK(mQuirks & kRequiresAllocateBufferOnOutputPorts);
                     CHECK(mQuirks & kDefersOutputBufferAllocation);
 
@@ -1799,13 +3278,23 @@ void OMXCodec::on_message(const omx_message &msg) {
                             "Codec lied about its buffer size requirements, "
                             "sending a buffer larger than the originally "
                             "advertised size in FILL_BUFFER_DONE!");
+		}
+                
+                if(!mOMXLivesLocally && mPmemInfo != NULL && buffer != NULL) {
+                    OMX_U8* base = (OMX_U8*)mPmemInfo->getBase();
+                    OMX_U8* data = base + msg.u.extended_buffer_data.pmem_offset;
+                    buffer->setData(data);
                 }
+
                 buffer->set_range(
                         msg.u.extended_buffer_data.range_offset,
                         msg.u.extended_buffer_data.range_length);
 
                 buffer->meta_data()->clear();
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+                buffer->meta_data()->setInt32(kKeyStride, mStride);
+#endif
                 buffer->meta_data()->setInt64(
                         kKeyTime, msg.u.extended_buffer_data.timestamp);
 
@@ -1816,6 +3305,11 @@ void OMXCodec::on_message(const omx_message &msg) {
                     buffer->meta_data()->setInt32(kKeyIsCodecConfig, true);
                 }
 
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+                if (msg.u.extended_buffer_data.flags & OMX_TI_BUFFERFLAG_DETACHEDEXTRADATA)
+                    buffer->meta_data()->setInt32(kKeyIsExtraData, true);
+#endif
+
                 if (mQuirks & kOutputBuffersAreUnreadable) {
                     buffer->meta_data()->setInt32(kKeyIsUnreadable, true);
                 }
@@ -1832,7 +3326,6 @@ void OMXCodec::on_message(const omx_message &msg) {
                     CODEC_LOGV("No more output data.");
                     mNoMoreOutputData = true;
                 }
-
                 if (mTargetTimeUs >= 0) {
                     CHECK(msg.u.extended_buffer_data.timestamp <= mTargetTimeUs);
 
@@ -1855,6 +3348,19 @@ void OMXCodec::on_message(const omx_message &msg) {
 
                 mFilledBuffers.push_back(i);
                 mBufferFilled.signal();
+            } else if ((mQuirks & kRequiresFlushBeforeShutdown) && mState == EXECUTING_TO_IDLE) {
+                if (countBuffersWeOwn(mPortBuffers[kPortIndexInput]) == mPortBuffers[kPortIndexInput].size()
+                    && countBuffersWeOwn(mPortBuffers[kPortIndexOutput]) == mPortBuffers[kPortIndexOutput].size()) {
+                    CODEC_LOGV("Finished flushing both ports, now completing "
+                         "transition from EXECUTING to IDLE.");
+
+                    status_t err =
+                        mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
+                    CHECK_EQ(err, OK);
+                } else {
+                    LOGV("own %d/%d input and %d/%d output", countBuffersWeOwn(mPortBuffers[kPortIndexInput]), mPortBuffers[kPortIndexInput].size(),
+                        countBuffersWeOwn(mPortBuffers[kPortIndexOutput]), mPortBuffers[kPortIndexOutput].size());
+                }
             }
 
             break;
@@ -1867,7 +3373,9 @@ void OMXCodec::on_message(const omx_message &msg) {
         }
     }
 }
-
+void OMXCodec::registerBuffers(const sp<IMemoryHeap> &mem) {
+    mPmemInfo = mem;
+}
 void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
     switch (event) {
         case OMX_EventCmdComplete:
@@ -1878,6 +3386,10 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
 
         case OMX_EventError:
         {
+            if (data1 && (OMX_S32)data1 == OMX_ErrorSameState) {
+                /* Don't raise fatal errors for samestate changes */
+                break;
+            }
             CODEC_LOGE("ERROR(0x%08lx, %ld)", data1, data2);
 
             setState(ERROR);
@@ -1886,7 +3398,22 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
 
         case OMX_EventPortSettingsChanged:
         {
+#ifndef OMAP_ENHANCEMENT
+            if(mState == EXECUTING)
+                CODEC_LOGV("OMX_EventPortSettingsChanged(port=%ld, data2=0x%08lx)",
+                       data1, data2);
+
+                if (data2 == 0 || data2 == OMX_IndexParamPortDefinition) {
+                    onPortSettingsChanged(data1);
+                } else if (data1 == kPortIndexOutput
+                        && data2 == OMX_IndexConfigCommonOutputCrop) {
+                    // todo: handle crop rect
+                }
+            else
+              LOGE("Ignore PortSettingsChanged event \n");
+#else
             onPortSettingsChanged(data1);
+#endif
             break;
         }
 
@@ -1998,7 +3525,9 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
                 CHECK_EQ(portIndex, kPortIndexOutput);
 
                 sp<MetaData> oldOutputFormat = mOutputFormat;
-                initOutputFormat(mSource->getFormat());
+                if (strncmp(mComponentName, "OMX.Nvidia.h26",14)) {
+                    initOutputFormat(mSource->getFormat());
+                }
 
                 // Don't notify clients if the output port settings change
                 // wasn't of importance to them, i.e. it may be that just the
@@ -2006,10 +3535,57 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
                 mOutputPortSettingsHaveChanged =
                     formatHasNotablyChanged(oldOutputFormat, mOutputFormat);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+                if( !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")){
+                    if (mExtBufferAddresses.size() == 0) /* Any Ducati codec non-overlay usecase */
+                    {
+                        LOGD("OMX_CommandPortDisable Done. Reenabling port for non-overlay playback usecase");
+
+                        /*Since we are mostly dealing 1D buffers here,
+                          nStride has to be updated as nFrameWidth will change on portreconfig
+                          */
+                        OMX_PARAM_PORTDEFINITIONTYPE def;
+                        InitOMXParams(&def);
+                        def.nPortIndex = kPortIndexOutput;
+
+                        status_t err = mOMX->getParameter(
+                              mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+                        CHECK_EQ(err, OK);
+
+                        OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
+
+                        int32_t padded_width;
+                        CHECK(mOutputFormat->findInt32(kKeyPaddedWidth, &padded_width));
+                        video_def->nStride = padded_width;
+                        mStride = video_def->nStride;
+
+                        LOGE("Updating video_def->nStride with new width %d", (int) video_def->nStride);
+
+                        err = mOMX->setParameter(
+                                     mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+
+                        enablePortAsync(portIndex);
+
+                        err = allocateBuffersOnPort(portIndex);
+                        CHECK_EQ(err, OK);
+                   }else
+                   {
+                      LOGD("OMX_CommandPortDisable Done. Not enabling port till overlay buffers are available");
+                   }
+                } else
+                {
                 enablePortAsync(portIndex);
 
                 status_t err = allocateBuffersOnPort(portIndex);
                 CHECK_EQ(err, OK);
+                }
+#else
+                enablePortAsync(portIndex);
+
+                status_t err = allocateBuffersOnPort(portIndex);
+                CHECK_EQ(err, OK);
+#endif
             }
             break;
         }
@@ -2041,24 +3617,24 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
             CODEC_LOGV("FLUSH_DONE(%ld)", portIndex);
 
             CHECK_EQ(mPortStatus[portIndex], SHUTTING_DOWN);
-            mPortStatus[portIndex] = ENABLED;
 
-            CHECK_EQ(countBuffersWeOwn(mPortBuffers[portIndex]),
-                     mPortBuffers[portIndex].size());
+            mPortStatus[portIndex] = ENABLED;
 
             if (mState == RECONFIGURING) {
                 CHECK_EQ(portIndex, kPortIndexOutput);
 
                 disablePortAsync(portIndex);
             } else if (mState == EXECUTING_TO_IDLE) {
-                if (mPortStatus[kPortIndexInput] == ENABLED
-                    && mPortStatus[kPortIndexOutput] == ENABLED) {
+                mPortStatus[portIndex] = SHUTTING_DOWN;
+
+                CHECK_EQ(mPortStatus[kPortIndexInput], SHUTTING_DOWN);
+                CHECK_EQ(mPortStatus[kPortIndexOutput], SHUTTING_DOWN);
+
+                if (countBuffersWeOwn(mPortBuffers[kPortIndexInput]) == mPortBuffers[kPortIndexInput].size()
+                    && countBuffersWeOwn(mPortBuffers[kPortIndexOutput]) == mPortBuffers[kPortIndexOutput].size()) {
                     CODEC_LOGV("Finished flushing both ports, now completing "
                          "transition from EXECUTING to IDLE.");
 
-                    mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
-                    mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
-
                     status_t err =
                         mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
                     CHECK_EQ(err, OK);
@@ -2152,6 +3728,12 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
 
         case OMX_StateLoaded:
         {
+#ifdef OMAP_ENHANCEMENT
+            if(LOADED == mState)
+            {
+                break;
+            }
+#endif
             CHECK_EQ(mState, IDLE_TO_LOADED);
 
             CODEC_LOGV("Now Loaded.");
@@ -2186,6 +3768,16 @@ size_t OMXCodec::countBuffersWeOwn(const Vector<BufferInfo> &buffers) {
     return n;
 }
 
+status_t OMXCodec::freeBuffer(OMX_U32 portIndex, BufferInfo *info) {
+    if (info->mAllocatedBuffer != NULL) {
+        OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *) info->mBuffer;
+        header->pBuffer = info->mAllocatedBuffer;
+        header->nAllocLen = info->mAllocatedSize;
+    }
+
+    return mOMX->freeBuffer(mNode, portIndex, info->mBuffer);
+}
+
 status_t OMXCodec::freeBuffersOnPort(
         OMX_U32 portIndex, bool onlyThoseWeOwn) {
     Vector<BufferInfo> *buffers = &mPortBuffers[portIndex];
@@ -2195,7 +3787,11 @@ status_t OMXCodec::freeBuffersOnPort(
     for (size_t i = buffers->size(); i-- > 0;) {
         BufferInfo *info = &buffers->editItemAt(i);
 
-        if (onlyThoseWeOwn && info->mOwnedByComponent) {
+#ifdef OMAP_ENHANCEMENT
+        if (onlyThoseWeOwn && (info->mOwnedByComponent || info->mOwnedByPlayer) ) {
+#else
+        if (onlyThoseWeOwn && info->mOwnedByComponent ) {
+#endif
             continue;
         }
 
@@ -2203,8 +3799,7 @@ status_t OMXCodec::freeBuffersOnPort(
 
         CODEC_LOGV("freeing buffer %p on port %ld", info->mBuffer, portIndex);
 
-        status_t err =
-            mOMX->freeBuffer(mNode, portIndex, info->mBuffer);
+        status_t err = freeBuffer(portIndex, info);
 
         if (err != OK) {
             stickyErr = err;
@@ -2235,6 +3830,34 @@ void OMXCodec::onPortSettingsChanged(OMX_U32 portIndex) {
     CHECK_EQ(portIndex, kPortIndexOutput);
     setState(RECONFIGURING);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    LOGD("[%s] PORT_SETTINGS_CHANGED(%d)",mComponentName, (int)portIndex);
+
+#if defined (NPA_BUFFERS)
+    //reset NPA buffer counter on port reconfig.
+    mNumberOfNPABuffersSent = 0;
+	mThumbnailEOSSent = 0;
+#endif
+
+    if( !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER"))
+    {
+        /* update new port settings, since renderer needs new WxH for new buffers */
+        initOutputFormat(mSource->getFormat());
+
+        /* For thumbnail color conversion routine will require unpadded display WxH
+           update it in video-source meta data here, to be used later during color conversion */
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+        status_t err = mOMX->getParameter(
+                mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ(err, OK);
+        OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
+        mSource->getFormat()->setInt32(kKeyWidth, video_def->nFrameWidth);
+        mSource->getFormat()->setInt32(kKeyHeight, video_def->nFrameHeight);
+        LOGI("Updated source WxH %dx%d", (int) video_def->nFrameWidth, (int) video_def->nFrameHeight);
+    }
+#endif
     if (mQuirks & kNeedsFlushBeforeDisable) {
         if (!flushPortAsync(portIndex)) {
             onCmdComplete(OMX_CommandFlush, portIndex);
@@ -2273,7 +3896,6 @@ bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
 
 void OMXCodec::disablePortAsync(OMX_U32 portIndex) {
     CHECK(mState == EXECUTING || mState == RECONFIGURING);
-
     CHECK_EQ(mPortStatus[portIndex], ENABLED);
     mPortStatus[portIndex] = DISABLING;
 
@@ -2315,7 +3937,26 @@ void OMXCodec::fillOutputBuffers() {
 
     Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexOutput];
     for (size_t i = 0; i < buffers->size(); ++i) {
+#ifdef OMAP_ENHANCEMENT
+        if ((*buffers)[i].mOwnedByPlayer) {
+            continue;
+        }
+#endif
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+        if (!(*buffers)[i].mOwnedByComponent) {
+
+#if defined (NPA_BUFFERS)
+        if( !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER") &&
+            (mQuirks & OMXCodec::kThumbnailMode) ){
+            if(mNumberOfNPABuffersSent++ >= THUMBNAIL_BUFFERS_NPA_MODE)
+                return;
+        }
+#endif
+            fillOutputBuffer(&buffers->editItemAt(i));
+        }
+#else
         fillOutputBuffer(&buffers->editItemAt(i));
+#endif
     }
 }
 
@@ -2324,7 +3965,20 @@ void OMXCodec::drainInputBuffers() {
 
     Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
     for (size_t i = 0; i < buffers->size(); ++i) {
+#ifdef USE_GETBUFFERINFO
+        //we need do this since camera holds 3 buffer + 1 is for index starts from 0
+        //if we don't do this it will be a deadlock since we will be waiting for camera to be done
+        //and camera will not give any more unless we give release
+        if (mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames) && (i == 4))
+            break;
+#endif
+#ifdef OMAP_ENHANCEMENT
+        if (!(*buffers)[i].mOwnedByComponent) {
+            drainInputBuffer(&buffers->editItemAt(i));
+        }
+#else
         drainInputBuffer(&buffers->editItemAt(i));
+#endif
     }
 }
 
@@ -2362,14 +4016,13 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
 
         CODEC_LOGV("calling emptyBuffer with codec specific data");
 
+        info->mOwnedByComponent = true;
         status_t err = mOMX->emptyBuffer(
                 mNode, info->mBuffer, 0, size,
                 OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_CODECCONFIG,
                 0);
         CHECK_EQ(err, OK);
 
-        info->mOwnedByComponent = true;
-
         ++mCodecSpecificDataIndex;
         return;
     }
@@ -2385,9 +4038,20 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     size_t offset = 0;
     int32_t n = 0;
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    uint32_t omx_offset = 0;
+#endif
+
     for (;;) {
         MediaBuffer *srcBuffer;
         MediaSource::ReadOptions options;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        MediaBuffer *tmpBuffer = NULL;
+        if (!mIsEncoder) {
+            srcBuffer = new MediaBuffer(info->mData, info->mSize);
+            tmpBuffer = srcBuffer;
+        }
+#endif
         if (mSkipTimeUs >= 0) {
             options.setSkipFrame(mSkipTimeUs);
         }
@@ -2424,6 +4088,17 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
         }
 
         if (err != OK) {
+#ifdef OMAP_ENHANCEMENT
+            if(mQuirks & kDecoderCantRenderSmallClips &&
+               err == ERROR_END_OF_STREAM){
+                static char mBufferAfterEos = 0;
+                if(!mBufferAfterEos){
+                    mBufferAfterEos = 1;
+                    break;
+                }
+                mBufferAfterEos = 0;
+            }
+#endif
             signalEOS = true;
             mFinalStatus = err;
             mSignalledEOS = true;
@@ -2431,13 +4106,14 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
         }
 
         size_t remainingBytes = info->mSize - offset;
+        size_t srcBufferLength = srcBuffer->range_length();
 
-        if (srcBuffer->range_length() > remainingBytes) {
+        if (srcBufferLength > remainingBytes) {
             if (offset == 0) {
                 CODEC_LOGE(
                      "Codec's input buffers are too small to accomodate "
                      "buffer read from source (info->mSize = %d, srcLength = %d)",
-                     info->mSize, srcBuffer->range_length());
+                     info->mSize, srcBufferLength);
 
                 srcBuffer->release();
                 srcBuffer = NULL;
@@ -2457,15 +4133,47 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
         if (mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
             CHECK(mOMXLivesLocally && offset == 0);
             OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *) info->mBuffer;
+            if (info->mAllocatedBuffer == NULL) {
+                info->mAllocatedBuffer = header->pBuffer;
+                info->mAllocatedSize = header->nAllocLen;
+            }
             header->pBuffer = (OMX_U8 *) srcBuffer->data() + srcBuffer->range_offset();
+            header->nAllocLen = srcBuffer->size() - srcBuffer->range_offset();
+#if defined (OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+            //closed loop.
+            if(!strcmp(mComponentName,"OMX.TI.DUCATI1.VIDEO.H264E")
+               || !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E")) {
+                srcBuffer->meta_data()->findInt32(kKeyOffset,(int32_t *) &omx_offset);
+            }
+
+            releaseBuffer = false;
+            info->mMediaBuffer = srcBuffer;
+#endif
         } else {
             if (mQuirks & kStoreMetaDataInInputVideoBuffers) {
                 releaseBuffer = false;
                 info->mMediaBuffer = srcBuffer;
             }
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        if (tmpBuffer != srcBuffer) {
             memcpy((uint8_t *)info->mData + offset,
                     (const uint8_t *)srcBuffer->data() + srcBuffer->range_offset(),
                     srcBuffer->range_length());
+            if (tmpBuffer)
+                tmpBuffer->release();
+        }
+#else
+            if (srcBuffer->data()) {
+                memcpy((uint8_t *)info->mData + offset,
+                        (const uint8_t *)srcBuffer->data() + srcBuffer->range_offset(),
+                        srcBufferLength);
+            } else {
+                if (srcBufferLength != 0) {
+                    LOGW("Source buffer was NULL but the size wasn't 0 bytes (is %d bytes)", srcBufferLength);
+                    srcBufferLength = 0;
+                }
+            }
+#endif
         }
 
         int64_t lastBufferTimeUs;
@@ -2476,9 +4184,11 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
             timestampUs = lastBufferTimeUs;
         }
 
-        offset += srcBuffer->range_length();
+        offset += srcBufferLength;
 
-        if (releaseBuffer) {
+        if (mIsEncoder && (mQuirks & kAvoidMemcopyInputRecordingFrames)) {
+            info->mMediaBuffer = srcBuffer;
+        } else if (releaseBuffer) {
             srcBuffer->release();
             srcBuffer = NULL;
         }
@@ -2502,6 +4212,30 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
     }
 
     OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4) && defined (NPA_BUFFERS)
+    if(mQuirks & OMXCodec::kThumbnailMode) {
+        CODEC_LOGV("Sending eos flag %d",mThumbnailEOSSent);
+        if(mThumbnailEOSSent == 1) {
+            CODEC_LOGV("Previously EOS was sent out for thumbnail mode");
+            // Returning for this point since we dont want to send
+            // any more input buffers to the codec as it is expected to
+            // flush out the frame from codec since we have send EOS
+            // flag in input previous buffer.
+            return;
+        }
+        mThumbnailEOSSent = 1;
+        flags |= OMX_BUFFERFLAG_EOS;
+    }
+#endif
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+    if(!strcmp(mComponentName,"OMX.TI.DUCATI1.VIDEO.H264E")
+       || !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E"))
+    {
+        flags |= OMX_BUFFERFLAG_SYNCFRAME;
+        flags |= OMX_BUFFERHEADERFLAG_MODIFIED;
+    }
+#endif
 
     if (signalEOS) {
         flags |= OMX_BUFFERFLAG_EOS;
@@ -2514,20 +4248,36 @@ void OMXCodec::drainInputBuffer(BufferInfo *info) {
                info->mBuffer, offset,
                timestampUs, timestampUs / 1E6);
 
+    info->mOwnedByComponent = true;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    if(!strcmp(mComponentName,"OMX.TI.DUCATI1.VIDEO.H264E")
+       || !strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.MPEG4E")) {
+        CODEC_LOGV("Calling emptybuffer with offset value =%ld ",omx_offset);
+
+        err = mOMX->emptyBuffer(
+            mNode, info->mBuffer, omx_offset, offset,
+            flags, timestampUs);
+    } else {
+        err = mOMX->emptyBuffer(
+            mNode, info->mBuffer, 0, offset,
+            flags, timestampUs);
+    }
+#else
     err = mOMX->emptyBuffer(
             mNode, info->mBuffer, 0, offset,
             flags, timestampUs);
+#endif
 
     if (err != OK) {
         setState(ERROR);
         return;
     }
 
-    info->mOwnedByComponent = true;
-
     // This component does not ever signal the EOS flag on output buffers,
     // Thanks for nothing.
-    if (mSignalledEOS && !strcmp(mComponentName, "OMX.TI.Video.encoder")) {
+    if (mSignalledEOS &&
+            (!strcmp(mComponentName, "OMX.TI.Video.encoder") ||
+             !strcmp(mComponentName, "OMX.TI.720P.Encoder"))) {
         mNoMoreOutputData = true;
         mBufferFilled.signal();
     }
@@ -2543,6 +4293,7 @@ void OMXCodec::fillOutputBuffer(BufferInfo *info) {
     }
 
     CODEC_LOGV("Calling fill_buffer on buffer %p", info->mBuffer);
+    info->mOwnedByComponent = true;
     status_t err = mOMX->fillBuffer(mNode, info->mBuffer);
 
     if (err != OK) {
@@ -2551,8 +4302,6 @@ void OMXCodec::fillOutputBuffer(BufferInfo *info) {
         setState(ERROR);
         return;
     }
-
-    info->mOwnedByComponent = true;
 }
 
 void OMXCodec::drainInputBuffer(IOMX::buffer_id buffer) {
@@ -2571,8 +4320,19 @@ void OMXCodec::fillOutputBuffer(IOMX::buffer_id buffer) {
     Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexOutput];
     for (size_t i = 0; i < buffers->size(); ++i) {
         if ((*buffers)[i].mBuffer == buffer) {
-            fillOutputBuffer(&buffers->editItemAt(i));
-            return;
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+            if (!(*buffers)[i].mOwnedByComponent) {
+                fillOutputBuffer(&buffers->editItemAt(i));
+                return;
+            }
+            else {
+                CODEC_LOGV("ALREADY OWNING THE BUFFER. RETURNING");
+                return;
+            }
+#else
+        fillOutputBuffer(&buffers->editItemAt(i));
+        return;
+#endif
         }
     }
 
@@ -2710,7 +4470,6 @@ void OMXCodec::setAMRFormat(bool isWAMR, int32_t bitRate) {
 }
 
 void OMXCodec::setAACFormat(int32_t numChannels, int32_t sampleRate, int32_t bitRate) {
-    CHECK(numChannels == 1 || numChannels == 2);
     if (mIsEncoder) {
         //////////////// input port ////////////////////
         setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
@@ -3002,6 +4761,16 @@ status_t OMXCodec::stop() {
 
     mSource->stop();
 
+    int i = 0;
+    while(getStrongCount() != 1) {
+        usleep(100);
+        i++;
+        if( i > 5) {
+            LOGE("Someone else, besides client, is holding the refernce. We might have trouble.");
+            break;
+        }
+    }
+
     CODEC_LOGV("stopped");
 
     return OK;
@@ -3013,8 +4782,94 @@ sp<MetaData> OMXCodec::getFormat() {
     return mOutputFormat;
 }
 
+#ifdef OMAP_ENHANCEMENT
+void OMXCodec::setBuffers(Vector< sp<IMemory> > mBufferAddresses, bool portReconfig){
+    mExtBufferAddresses = mBufferAddresses;
+
+#ifdef TARGET_OMAP4
+    if(!portReconfig){
+
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+
+        status_t err = mOMX->getParameter(
+                        mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ(err, OK);
+        //reconfigure codec with the number of buffers actually got created
+        //by the Hardware Renderer
+        def.nBufferCountActual = mExtBufferAddresses.size();
+
+        //Update stride for 2D buffers
+        OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
+        video_def->nStride = ARM_4K_PAGE_SIZE;
+        mStride = video_def->nStride;
+
+        err = mOMX->setParameter(
+                     mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        //CHECK_EQ(err, OK);
+    }else{
+
+        if(portReconfig && mState!= RECONFIGURING)
+        {
+            LOGE("Extra setbuffer(portreconfig=true) call when port reconfigure is done. REPORT THIS");
+            return;
+        }
+
+        // Wait till all fillbuffer done events are handled cleanly
+        usleep(10000); 
+
+        // Flush all the buffers
+        freeBuffersOnPort(kPortIndexOutput);
+
+        //disable the port if it enabled
+        if (mPortStatus[kPortIndexOutput] == ENABLED) {
+            disablePortAsync(kPortIndexOutput);
+        }
+
+        int32_t retrycount = 0;
+        while(mPortStatus[kPortIndexOutput] == DISABLING){
+            usleep(2000); // 2 mS
+            LOGD("(%d) Output port is DISABLING.. Waiting for port to be disabled.. %d",retrycount,mPortStatus[kPortIndexOutput] );
+            retrycount++;
+            CHECK(retrycount < 100);
+        }
+
+        OMX_PARAM_PORTDEFINITIONTYPE def;
+        InitOMXParams(&def);
+        def.nPortIndex = kPortIndexOutput;
+
+        status_t err = mOMX->getParameter(
+        mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+        CHECK_EQ(err, OK);
+
+        OMX_VIDEO_PORTDEFINITIONTYPE *video_def = &def.format.video;
+        video_def->nStride = 4096;
+        LOGE("Updating video_def->nStride with new width %d", (int) video_def->nStride);
+        err = mOMX->setParameter(mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+
+        /*output port is not enabled for ducati codecs, delayed till we get buffers here */
+        enablePortAsync(kPortIndexOutput);
+        allocateBuffersOnPort(kPortIndexOutput);
+
+        //Make sure output port is reached to ENABLED state and thus mstate to EXECUTING
+        retrycount = 0;
+        while(mPortStatus[kPortIndexOutput] == ENABLING){
+            usleep(2000); // 2 mS
+            LOGD("(%d) Output port is ENABLING.. Waiting for port to be enabled.. %d",retrycount,mPortStatus[kPortIndexOutput] );
+            retrycount++;
+            CHECK(retrycount < 100);
+        }
+    }
+#endif
+}
+#endif
+
 status_t OMXCodec::read(
         MediaBuffer **buffer, const ReadOptions *options) {
+
+    status_t wait_status = 0;
+
     *buffer = NULL;
 
     Mutex::Autolock autoLock(mLock);
@@ -3023,6 +4878,18 @@ status_t OMXCodec::read(
         return UNKNOWN_ERROR;
     }
 
+#if defined(OMAP_ENHANCEMENT) && defined (TARGET_OMAP4)
+    /*Stagefright port-reconfiguration logic is based on mOutputPortSettingsHaveChanged, which will be updated very late when port is reenabled */
+    /*Detect port-config event quickly so overlay buffers will be available upfront*/
+    if(!strcmp(mComponentName, "OMX.TI.DUCATI1.VIDEO.DECODER")){
+        if (mState == RECONFIGURING) {
+            mOutputPortSettingsHaveChanged = false;
+            mFilledBuffers.clear();
+            return INFO_FORMAT_CHANGED;
+        }
+    }
+#endif
+
     bool seeking = false;
     int64_t seekTimeUs;
     ReadOptions::SeekMode seekMode;
@@ -3084,13 +4951,98 @@ status_t OMXCodec::read(
         }
 
         while (mSeekTimeUs >= 0) {
-            mBufferFilled.wait(mLock);
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+            wait_status = (mNSecsToWait == 0) ? mBufferFilled.wait(mLock) : mBufferFilled.waitRelative(mLock, mNSecsToWait);
+#else
+            wait_status = mBufferFilled.waitRelative(mLock, 3000000000);
+#endif
+            if (wait_status) {
+                LOGE("Timed out waiting for the buffer! Line %d", __LINE__);
+                return UNKNOWN_ERROR;
+            }
+        }
+    }
+
+#ifdef OMAP_ENHANCEMENT
+    bool wasPaused = false;
+    if (mPaused) {
+        wasPaused = mPaused;
+        // We are resuming from the pause state. resetting the pause flag
+        mPaused = false;
+            /*Initiate the buffer flow on input port once again
+             * This is required to avoid starvation on I/P port if the
+             * previous empty_buffer_done calls are returned without
+             * initiating empty_buffer due to mpause was asserted.
+             * This needs to be done before waiting for the output buffer fill
+             * to avoid the deadlock
+             */
+            if (mState == EXECUTING) {
+                drainInputBuffers();
+            }
+    }
+#endif
+
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+    //only for OMAP4 Video decoder we shall check the buffers which are not with component
+    if (!strcmp("OMX.TI.DUCATI1.VIDEO.DECODER", mComponentName)) {
+        while (mState != RECONFIGURING && mState != ERROR && !mNoMoreOutputData && mFilledBuffers.empty()) {
+            CODEC_LOGV("READ LOCKED BUFFER QUEUE EMPTY FLAG : %d",mFilledBuffers.empty());
+            if (mState == EXECUTING && wasPaused) {
+                fillOutputBuffers();
+            }
+
+#if defined (NPA_BUFFERS)
+            if (mQuirks & OMXCodec::kThumbnailMode) {
+                if(mNumberOfNPABuffersSent){
+                    /*wait if atleast one filledbuffer is sent in NPA mode*/
+                    wait_status = (mNSecsToWait == 0) ? mBufferFilled.wait(mLock) : mBufferFilled.waitRelative(mLock, mNSecsToWait);
+                    if (wait_status) {
+                        LOGE("Timed out waiting for the buffer! Line %d", __LINE__);
+                        return UNKNOWN_ERROR;
+                    }
+                }
+            }else{
+                //Dont wait forever.
+                wait_status = (mNSecsToWait == 0) ? mBufferFilled.wait(mLock) : mBufferFilled.waitRelative(mLock, mNSecsToWait);
+                if (wait_status) {
+                    LOGE("Timed out waiting for the buffer! Line %d", __LINE__);
+                    return UNKNOWN_ERROR;
+                }
+            }
+#else
+            wait_status = (mNSecsToWait == 0) ? mBufferFilled.wait(mLock) : mBufferFilled.waitRelative(mLock, mNSecsToWait);
+            if (wait_status) {
+                LOGE("Timed out waiting for the buffer! Line %d", __LINE__);
+                return UNKNOWN_ERROR;
+            }
+#endif
+        }
+        /*see if we received a port reconfiguration */
+        if (mState == RECONFIGURING) {
+            mOutputPortSettingsHaveChanged = false;
+            mFilledBuffers.clear();
+            return INFO_FORMAT_CHANGED;
         }
     }
+    else {
+        while (mState != ERROR && !mNoMoreOutputData && mFilledBuffers.empty()) {
+            wait_status = (mNSecsToWait == 0) ? mBufferFilled.wait(mLock) : mBufferFilled.waitRelative(mLock, mNSecsToWait);
+        if (wait_status) {
+            LOGE("Timed out waiting for the buffer! Line %d", __LINE__);
+            return UNKNOWN_ERROR;
+        }
+    }
+    }
 
+#else
     while (mState != ERROR && !mNoMoreOutputData && mFilledBuffers.empty()) {
-        mBufferFilled.wait(mLock);
+        wait_status = mBufferFilled.waitRelative(mLock, 3000000000);
+        if (wait_status) {
+            LOGE("Timed out waiting for the buffer! Line %d", __LINE__);
+            return UNKNOWN_ERROR;
+        }
     }
+#endif
 
     if (mState == ERROR) {
         return UNKNOWN_ERROR;
@@ -3102,8 +5054,17 @@ status_t OMXCodec::read(
 
     if (mOutputPortSettingsHaveChanged) {
         mOutputPortSettingsHaveChanged = false;
-
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+        //for ducati codecs, to assert port reconfiguration immediately (so as to allocate overlay buffers upfront), we use mState as above.
+        //so, mOutputPortSettingsHaveChanged conditon check will result in redundant INFO_FORMAT_CHANGED event. Just proceed now.
+        //also, mOutputPortSettingsHaveChanged will be updated very late on port reenable, by the time overlay buffers are available and port enabled => just go ahead.
+        if (strcmp("OMX.TI.DUCATI1.VIDEO.DECODER", mComponentName)){
+            mFilledBuffers.clear();
+            return INFO_FORMAT_CHANGED;
+        }
+#else
         return INFO_FORMAT_CHANGED;
+#endif
     }
 
     size_t index = *mFilledBuffers.begin();
@@ -3111,6 +5072,9 @@ status_t OMXCodec::read(
 
     BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(index);
     info->mMediaBuffer->add_ref();
+#ifdef OMAP_ENHANCEMENT
+    info->mOwnedByPlayer = true;
+#endif
     *buffer = info->mMediaBuffer;
 
     return OK;
@@ -3124,9 +5088,26 @@ void OMXCodec::signalBufferReturned(MediaBuffer *buffer) {
         BufferInfo *info = &buffers->editItemAt(i);
 
         if (info->mMediaBuffer == buffer) {
+#ifdef OMAP_ENHANCEMENT
+            info->mOwnedByPlayer = false;
+            if(mState == RECONFIGURING) {
+                return;
+            }
+#endif
             CHECK_EQ(mPortStatus[kPortIndexOutput], ENABLED);
-            fillOutputBuffer(info);
-            return;
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+            if (!(*buffers)[i].mOwnedByComponent) {
+                fillOutputBuffer(info);
+                return;
+            }
+            else {
+                CODEC_LOGV("OP BUFFER ALREADY OWNED BY COMPONENT. RETURNING");
+                return;
+            }
+#else
+        fillOutputBuffer(info);
+        return;
+#endif
         }
     }
 
@@ -3226,8 +5207,23 @@ static const char *videoCompressionFormatString(OMX_VIDEO_CODINGTYPE type) {
         "OMX_VIDEO_CodingRV",
         "OMX_VIDEO_CodingAVC",
         "OMX_VIDEO_CodingMJPEG",
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        "OMX_VIDEO_CodingVP6",
+        "OMX_VIDEO_CodingVP7"
+#endif
     };
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+    if (type == (OMX_VIDEO_CODINGTYPE) OMX_VIDEO_CodingVP6) {
+        return kNames[9];
+    }
+
+    if (type == (OMX_VIDEO_CODINGTYPE) OMX_VIDEO_CodingVP7) {
+        return kNames[10];
+    }
+#endif
+
     size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
 
     if (type < 0 || (size_t)type >= numNames) {
@@ -3529,8 +5525,26 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                         (mQuirks & kDecoderLiesAboutNumberOfChannels)
                             ? numChannels : params.nChannels);
 
+#ifndef OMAP_ENHANCEMENT
                 // The codec-reported sampleRate is not reliable...
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
+#else
+                if ((OMX_U32)sampleRate != params.nSamplingRate) {
+                    LOGW("Codec outputs a different number of samplerate than "
+                            "the input stream contains (contains %d samplerate, "
+                            "codec outputs %ld samplerate).",
+                            sampleRate, params.nSamplingRate);
+                    mOutputFormat->setInt32(
+                            kKeySampleRate,
+                            (mQuirks & kDecoderNeedsPortReconfiguration)
+                            ? params.nSamplingRate : sampleRate);
+                }
+                else
+                {
+                  // The codec-reported sampleRate is not reliable...
+                    mOutputFormat->setInt32(kKeySampleRate, sampleRate);
+                }
+#endif
             } else if (audio_def->eEncoding == OMX_AUDIO_CodingAMR) {
                 OMX_AUDIO_PARAM_AMRTYPE amr;
                 InitOMXParams(&amr);
@@ -3588,6 +5602,20 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
             } else if (video_def->eCompressionFormat == OMX_VIDEO_CodingAVC) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
+#if defined(OMAP_ENHANCEMENT)
+#if defined(TARGET_OMAP4)
+            } else if (video_def->eCompressionFormat == (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP6) {
+                mOutputFormat->setCString(
+                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_VP6);
+            } else if (video_def->eCompressionFormat == (OMX_VIDEO_CODINGTYPE)OMX_VIDEO_CodingVP7) {
+                mOutputFormat->setCString(
+                        kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_VP7);
+#endif
+            }
+            else if (video_def->eCompressionFormat == OMX_VIDEO_CodingWMV)
+            {
+                mOutputFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_WMV);
+#endif
             } else {
                 CHECK(!"Unknown compression format.");
             }
@@ -3599,11 +5627,83 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setInt32(
                         kKeyHeight, (video_def->nFrameHeight + 15) & -16);
             } else {
+#ifdef USE_QCOM_OMX_FIX
+                //Update the Stride and Slice Height
+                //Allows creation of Renderer with correct height and width
+                if( mIsEncoder ){
+                    int32_t width, height;
+                    bool success = inputFormat->findInt32( kKeyWidth, &width ) &&
+                        inputFormat->findInt32( kKeyHeight, &height);
+                    CHECK( success );
+                    mOutputFormat->setInt32(kKeyWidth, width );
+                    mOutputFormat->setInt32(kKeyHeight, height );
+
+#ifdef USE_GETBUFFERINFO
+                    /* Tell the encoder to use our supplied pmem on
+                       the input buffer, via vendor-specific useBuffer */
+                    OMX_QCOM_PARAM_PORTDEFINITIONTYPE portDefn;
+                    InitOMXParams(&portDefn);
+                    portDefn.nPortIndex = kPortIndexInput;
+                    portDefn.nMemRegion = OMX_QCOM_MemRegionEBI1;
+
+                    err = mOMX->setParameter( mNode,
+                        (OMX_INDEXTYPE) OMX_QcomIndexPortDefn,
+                        &portDefn, sizeof(portDefn) );
+                    CHECK_EQ(err, OK);
+#endif
+                }
+                else {
+                    LOGV("video_def->nStride = %d, video_def->nSliceHeight = %d", video_def->nStride,
+                            video_def->nSliceHeight );
+                    if (video_def->nStride && video_def->nSliceHeight) {
+                        /* Make sure we actually got the values from the decoder */
+                        mOutputFormat->setInt32(kKeyWidth, video_def->nStride);
+                        mOutputFormat->setInt32(kKeyHeight, video_def->nSliceHeight);
+                    } else {
+                        /* We didn't. Use the old behavior */
+                        mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
+                        mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);
+                    }
+                }
+#else
+                //Some hardware expects the old behavior
                 mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
                 mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);
+#endif
             }
 
             mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+        /* for Non-Ducati HW codecs, padded with and height are updated with the
+        * video frame width and Height
+        */
+        mOutputFormat->setInt32(kKeyPaddedWidth, video_def->nFrameWidth);
+        mOutputFormat->setInt32(kKeyPaddedHeight, video_def->nFrameHeight);
+
+        /* Ducati codecs require padded output buffers.
+           Query proper size and update meta-data accordingly
+           which will be used later in renderer.
+           Note: 2D WxH in other OMX Get/Set parameter calls are seamless */
+        if (!strcmp("OMX.TI.DUCATI1.VIDEO.DECODER", mComponentName)) {
+
+            OMX_CONFIG_RECTTYPE tParamStruct;
+
+            InitOMXParams(&tParamStruct);
+            tParamStruct.nPortIndex = kPortIndexOutput;
+
+            err = mOMX->getParameter(
+                    mNode, (OMX_INDEXTYPE)OMX_TI_IndexParam2DBufferAllocDimension, &tParamStruct, sizeof(tParamStruct));
+
+            CHECK_EQ(err, OK);
+            mOutputFormat->setInt32(kKeyPaddedWidth, tParamStruct.nWidth);
+            mOutputFormat->setInt32(kKeyPaddedHeight, tParamStruct.nHeight);
+            LOGD("initOutputFormat WxH %dx%d Padded %dx%d ",
+                        (int) video_def->nFrameWidth, (int) video_def->nFrameHeight,
+                        (int) tParamStruct.nWidth, (int) tParamStruct.nHeight);
+        }
+#endif
             break;
         }
 
@@ -3623,6 +5723,23 @@ status_t OMXCodec::pause() {
     return OK;
 }
 
+#ifdef OMAP_ENHANCEMENT
+int OMXCodec::getNumofOutputBuffers() {
+    OMX_PARAM_PORTDEFINITIONTYPE def;
+    InitOMXParams(&def);
+    def.nPortIndex = kPortIndexOutput;
+
+    status_t err = mOMX->getParameter(
+            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
+    CHECK_EQ(err, OK);
+    CHECK_EQ(def.eDomain, OMX_PortDomainVideo);
+
+    LOGD("CodecRecommended O/P BufferCnt[%ld]", def.nBufferCountActual);
+
+    return (def.nBufferCountActual);
+}
+#endif
+
 ////////////////////////////////////////////////////////////////////////////////
 
 status_t QueryCodecs(
diff --git a/media/libstagefright/SampleTable.cpp b/media/libstagefright/SampleTable.cpp
index 27faf4f..be0fec0 100644
--- a/media/libstagefright/SampleTable.cpp
+++ b/media/libstagefright/SampleTable.cpp
@@ -57,6 +57,11 @@ SampleTable::SampleTable(const sp<DataSource> &source)
       mNumSyncSamples(0),
       mSyncSamples(NULL),
       mLastSyncSampleIndex(0),
+#ifdef OMAP_ENHANCEMENT
+      mTimeToSampleCountCtts(0),
+      mCttsSampleBuffer(NULL),
+      mTimeToSampleCtts(NULL),
+#endif
       mSampleToChunkEntries(NULL) {
     mSampleIterator = new SampleIterator(this);
 }
@@ -73,6 +78,15 @@ SampleTable::~SampleTable() {
 
     delete mSampleIterator;
     mSampleIterator = NULL;
+
+#ifdef OMAP_ENHANCEMENT
+    delete[] mTimeToSampleCtts;
+    mTimeToSampleCtts = NULL;
+
+    delete[] mCttsSampleBuffer;
+    mCttsSampleBuffer = NULL;
+#endif
+
 }
 
 status_t SampleTable::setChunkOffsetParams(
@@ -227,6 +241,52 @@ status_t SampleTable::setSampleSizeParams(
     return OK;
 }
 
+#ifdef OMAP_ENHANCEMENT
+status_t SampleTable::setTimeToSampleParamsCtts(
+        off_t data_offset, size_t data_size) {
+    if (mTimeToSampleCtts != NULL || data_size < 8) {
+        return ERROR_MALFORMED;
+    }
+    uint8_t header[8];
+    uint32_t count_ctts,k=0;
+    if (mDataSource->readAt(
+                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
+        return ERROR_IO;
+    }
+
+    if (U32_AT(header) != 0) {
+        // Expected version = 0, flags = 0.
+        return ERROR_MALFORMED;
+    }
+
+    mTimeToSampleCountCtts = U32_AT(&header[4]);
+
+    //find out the actual number of samples
+    mCttsSampleBuffer = new int32_t[mTimeToSampleCountCtts * 2];
+    size_t size = sizeof(int32_t) * mTimeToSampleCountCtts * 2;
+    if (mDataSource->readAt(
+                data_offset + 8, mCttsSampleBuffer, size) < (ssize_t)size) {
+        return ERROR_IO;
+    }
+
+    uint32_t countsamples = 0;
+    for(uint32_t i=0 ; i < mTimeToSampleCountCtts * 2; i+=2)
+        countsamples += ntohl(mCttsSampleBuffer[i]);
+
+    mTimeToSampleCtts = new int32_t[countsamples];
+
+    for (uint32_t i = 0; i < mTimeToSampleCountCtts * 2; i++) {
+        count_ctts = ntohl(mCttsSampleBuffer[i++]);
+        for(uint32_t j = 0;j < count_ctts ;j++){
+           mTimeToSampleCtts[k] = ntohl(mCttsSampleBuffer[i]);
+           LOGV("for loop ctts samples %d %d %d",mTimeToSampleCountCtts,mTimeToSampleCtts[k],k);
+           k++;
+        }
+    }
+    return OK;
+}
+#endif
+
 status_t SampleTable::setTimeToSampleParams(
         off_t data_offset, size_t data_size) {
     if (mTimeToSample != NULL || data_size < 8) {
@@ -421,7 +481,16 @@ status_t SampleTable::findSyncSampleNear(
     }
 
     --left;
+#ifdef OMAP_ENHANCEMENT
+    /*This variable will be initialized to 1, so in case the stss table
+     *has 0 elements it will take by default frame 0. Frame 0 is supposed
+     * to be an I frame every time. When stss is zero mNumSyncSamples
+     * will be zero too, so the while loop will be skipped.
+     * */
+    uint32_t x=1;
+#else
     uint32_t x;
+#endif
     if (mDataSource->readAt(
                 mSyncSampleOffset + 8 + left * 4, &x, 4) != 4) {
         return ERROR_IO;
@@ -527,6 +596,11 @@ status_t SampleTable::findThumbnailSample(uint32_t *sample_index) {
     if (numSamplesToScan > kMaxNumSyncSamplesToScan) {
         numSamplesToScan = kMaxNumSyncSamplesToScan;
     }
+    else if(numSamplesToScan > 1)
+    {
+      //Ignore last sync sample, it may be the last sample at the end of the file
+      numSamplesToScan = (numSamplesToScan - 1);
+    }
 
     for (size_t i = 0; i < numSamplesToScan; ++i) {
         uint32_t x = mSyncSamples[i];
diff --git a/media/libstagefright/StagefrightMediaScanner.cpp b/media/libstagefright/StagefrightMediaScanner.cpp
index 10c6e41..3659019 100644
--- a/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/media/libstagefright/StagefrightMediaScanner.cpp
@@ -26,6 +26,9 @@
 // Sonivox includes
 #include <libsonivox/eas.h>
 
+// FLAC includes
+#include <FLAC/all.h>
+
 namespace android {
 
 StagefrightMediaScanner::StagefrightMediaScanner()
@@ -39,7 +42,10 @@ static bool FileHasAcceptableExtension(const char *extension) {
         ".mp3", ".mp4", ".m4a", ".3gp", ".3gpp", ".3g2", ".3gpp2",
         ".mpeg", ".ogg", ".mid", ".smf", ".imy", ".wma", ".aac",
         ".wav", ".amr", ".midi", ".xmf", ".rtttl", ".rtx", ".ota",
-        ".mkv", ".mka", ".webm", ".ts"
+        ".mkv", ".mka", ".webm", ".ts", ".flac"
+#if defined(OMAP_ENHANCEMENT)
+        ,".wmv", ".asf"
+#endif
     };
     static const size_t kNumValidExtensions =
         sizeof(kValidExtensions) / sizeof(kValidExtensions[0]);
@@ -99,6 +105,73 @@ static status_t HandleMIDI(
     return OK;
 }
 
+static FLAC__StreamDecoderWriteStatus flac_write(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 *const buffer[], void *client_data) {
+    (void)decoder, (void)frame, (void)buffer, (void)client_data;
+    return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
+}
+
+static void flac_error(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data) {
+    (void)decoder, (void)status, (void)client_data;
+}
+
+static void flac_metadata(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data) {
+    MediaScannerClient *client = (MediaScannerClient *)client_data;
+
+    if (metadata->type == FLAC__METADATA_TYPE_STREAMINFO) {
+        FLAC__uint64 duration = 1000 * metadata->data.stream_info.total_samples / metadata->data.stream_info.sample_rate;
+        if (duration > 0) {
+            char buffer[20];
+            sprintf(buffer, "%lld", duration);
+            if (!client->addStringTag("duration", buffer))
+                return;
+        }
+    } else if (metadata->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {
+        for (uint32_t i = 0; i < metadata->data.vorbis_comment.num_comments; i++) {
+            char *ptr = (char *)metadata->data.vorbis_comment.comments[i].entry;
+
+            char *val = strchr(ptr, '=');
+            if (val) {
+                int keylen = val++ - ptr;
+                char key[keylen + 1];
+                strncpy(key, ptr, keylen);
+                key[keylen] = 0;
+                if (!client->addStringTag(key, val)) return;
+            }
+        }
+    }
+}
+
+static status_t HandleFLAC(const char *filename, MediaScannerClient* client)
+{
+    status_t status = UNKNOWN_ERROR;
+    FLAC__StreamDecoder *decoder;
+
+    decoder = FLAC__stream_decoder_new();
+    if (!decoder)
+        return status;
+
+    FLAC__stream_decoder_set_md5_checking(decoder, false);
+    FLAC__stream_decoder_set_metadata_ignore_all(decoder);
+    FLAC__stream_decoder_set_metadata_respond(decoder, FLAC__METADATA_TYPE_STREAMINFO);
+    FLAC__stream_decoder_set_metadata_respond(decoder, FLAC__METADATA_TYPE_VORBIS_COMMENT);
+
+    FLAC__StreamDecoderInitStatus init_status;
+    init_status = FLAC__stream_decoder_init_file(decoder, filename, flac_write, flac_metadata, flac_error, client);
+    if (init_status != FLAC__STREAM_DECODER_INIT_STATUS_OK)
+        goto exit;
+
+    if (!FLAC__stream_decoder_process_until_end_of_metadata(decoder))
+        goto exit;
+
+    status = OK;
+
+exit:
+    FLAC__stream_decoder_finish(decoder);
+    FLAC__stream_decoder_delete(decoder);
+
+    return status;
+}
+
 status_t StagefrightMediaScanner::processFile(
         const char *path, const char *mimeType,
         MediaScannerClient &client) {
@@ -130,6 +203,10 @@ status_t StagefrightMediaScanner::processFile(
         return HandleMIDI(path, &client);
     }
 
+    if (!strcasecmp(extension, ".flac")) {
+        return HandleFLAC(path, &client);
+    }
+
     if (mRetriever->setDataSource(path) == OK) {
         const char *value;
         if ((value = mRetriever->extractMetadata(
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index e8f4839..6e76650 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -28,8 +28,16 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/OMXCodec.h>
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+#include <OMX_TI_IVCommon.h>
+#endif
+
 namespace android {
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+extern void updateMetaData(sp<MetaData> meta_track);
+#endif
+
 StagefrightMetadataRetriever::StagefrightMetadataRetriever()
     : mParsedMetaData(false),
       mAlbumArt(NULL) {
@@ -49,7 +57,11 @@ StagefrightMetadataRetriever::~StagefrightMetadataRetriever() {
 }
 
 status_t StagefrightMetadataRetriever::setDataSource(const char *uri) {
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    LOGD("setDataSource(%s)", uri);
+#else
     LOGV("setDataSource(%s)", uri);
+#endif
 
     mParsedMetaData = false;
     mMetaData.clear();
@@ -112,6 +124,24 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
         uint32_t flags,
         int64_t frameTimeUs,
         int seekMode) {
+
+#ifdef OMAP_ENHANCEMENT
+    flags |= OMXCodec::kPreferThumbnailMode;
+#ifdef TARGET_OMAP4
+
+    int32_t isInterlaced = false;
+
+    //Call config parser to update profile,level,interlaced,reference frame data
+    updateMetaData(trackMeta);
+
+    trackMeta->findInt32(kKeyVideoInterlaced, &isInterlaced);
+
+    if(isInterlaced)
+    {
+      flags |= OMXCodec::kPreferInterlacedOutputContent;
+    }
+#endif
+#endif
     sp<MediaSource> decoder =
         OMXCodec::Create(
                 client->interface(), source->getFormat(), false, source,
@@ -148,7 +178,7 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
         options.setSeekTo(thumbNailTime, mode);
     } else {
         thumbNailTime = -1;
-        options.setSeekTo(frameTimeUs, mode);
+        options.setSeekTo(frameTimeUs < 0 ? 0 : frameTimeUs, mode);
     }
 
     MediaBuffer *buffer = NULL;
@@ -157,7 +187,18 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
             buffer->release();
             buffer = NULL;
         }
+
         err = decoder->read(&buffer, &options);
+#ifdef OMAP_ENHANCEMENT
+        if(err == INFO_FORMAT_CHANGED)
+        {
+            int32_t w1,h1;
+            decoder->getFormat()->findInt32(kKeyWidth, &w1);
+            decoder->getFormat()->findInt32(kKeyHeight, &h1);
+            LOGD("Got portreconfig event. New WxH %dx%d. wait 5mS for port to be enabled",w1,h1);
+            usleep(5000); //sleep 5mS for port disable-enable to complete
+        }
+#endif
         options.clearSeekTo();
     } while (err == INFO_FORMAT_CHANGED
              || (buffer != NULL && buffer->range_length() == 0));
@@ -211,6 +252,77 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
     }
 
     VideoFrame *frame = new VideoFrame;
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    int32_t srcFormat;
+    CHECK(meta->findInt32(kKeyColorFormat, &srcFormat));
+
+    int32_t format;
+    const char *component;
+
+    //cache the display width and height
+    int32_t displayWidth, displayHeight;
+    displayWidth = width;
+    displayHeight = height;
+
+    //update width & height with the buffer width&height
+    if(!(meta->findInt32(kKeyPaddedWidth, &width))) {
+        CHECK(meta->findInt32(kKeyWidth, &width));
+    }
+    if(!(meta->findInt32(kKeyPaddedHeight, &height))) {
+        CHECK(meta->findInt32(kKeyHeight, &height));
+    }
+    LOGD("VideoFrame WxH %dx%d", displayWidth, displayHeight);
+
+    if(((OMX_COLOR_FORMATTYPE)srcFormat == OMX_COLOR_FormatYUV420PackedSemiPlanar) ||
+       ((OMX_COLOR_FORMATTYPE)srcFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar_Sequential_TopBottom)){
+        frame->mWidth = displayWidth;
+        frame->mHeight = displayHeight;
+        frame->mDisplayWidth = displayWidth;
+        frame->mDisplayHeight = displayHeight;
+        frame->mSize = displayWidth * displayHeight * 2;
+        frame->mData = new uint8_t[frame->mSize];
+    frame->mRotationAngle = rotationAngle;
+    }else {
+        frame->mWidth = width;
+        frame->mHeight = height;
+        frame->mDisplayWidth = width;
+        frame->mDisplayHeight = height;
+        frame->mSize = width * height * 2;
+        frame->mData = new uint8_t[frame->mSize];
+    frame->mRotationAngle = rotationAngle;
+    }
+
+    if(((OMX_COLOR_FORMATTYPE)srcFormat == OMX_COLOR_FormatYUV420PackedSemiPlanar) ||
+       ((OMX_COLOR_FORMATTYPE)srcFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar_Sequential_TopBottom)){
+
+        ColorConverter converter(
+                (OMX_COLOR_FORMATTYPE)srcFormat, OMX_COLOR_Format16bitRGB565);
+
+        CHECK(converter.isValid());
+
+        converter.convert(
+                width, height,
+                (const uint8_t *)buffer->data() + buffer->range_offset(),
+                0, //1D buffer in 1.16 Ducati rls. If 2D buffer -> 4096 stride should be used
+                frame->mData, displayWidth * 2,
+                displayWidth,displayHeight,buffer->range_offset(),isInterlaced);
+    }
+    else{
+
+        ColorConverter converter(
+                (OMX_COLOR_FORMATTYPE)srcFormat, OMX_COLOR_Format16bitRGB565);
+
+        CHECK(converter.isValid());
+
+        converter.convert(
+                width, height,
+                (const uint8_t *)buffer->data() + buffer->range_offset(),
+                0,
+                frame->mData, width * 2);
+    }
+
+#else
     frame->mWidth = width;
     frame->mHeight = height;
     frame->mDisplayWidth = width;
@@ -231,6 +343,7 @@ static VideoFrame *extractVideoFrameWithCodecFlags(
             (const uint8_t *)buffer->data() + buffer->range_offset(),
             0,
             frame->mData, width * 2);
+#endif
 
     buffer->release();
     buffer = NULL;
diff --git a/media/libstagefright/TISEIMessagesParser.cpp b/media/libstagefright/TISEIMessagesParser.cpp
new file mode 100644
index 0000000..d8d471c
--- /dev/null
+++ b/media/libstagefright/TISEIMessagesParser.cpp
@@ -0,0 +1,560 @@
+/*
+ * Copyright (C) Texas Instruments - http://www.ti.com/
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+#define LOG_TAG "SEI_TI_Parser"
+#include "include/TISEIMessagesParser.h"
+#include <utils/Log.h>
+
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/Utils.h>
+
+#define MP4_INVALID_VOL_PARAM -1
+#define STEREO_VIDEO_INFO_TYPE 0x15
+#define FRAME_PACKING_ARRANGEMENT_TYPE 0x2D
+// To account for payloadtype and payloadsize bytes
+#define PAYLOAD_HEADER_SIZE 2
+
+#define PV_CLZ(A,B) while (((B) & 0x8000) == 0) {(B) <<=1; A++;}
+
+static const uint32_t mask[33] =
+{
+    0x00000000, 0x00000001, 0x00000003, 0x00000007,
+    0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
+    0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
+    0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
+    0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
+    0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
+    0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
+    0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
+    0xffffffff
+};
+
+typedef struct
+{
+    uint8_t *data;
+    uint32_t numBytes;
+    uint32_t bytePos;
+    uint32_t bitBuf;
+    uint32_t dataBitPos;
+    uint32_t  bitPos;
+} mp4StreamType;
+
+/*------------------------------------------------------------------------------------
+    sStereo_video_info
+    This structure contains the stereo video information SEI msg elements
+   -----------------------------------------------------------------------------------*/
+typedef struct sei_stereo_video_info {
+   uint32_t field_views_flag;                                                  //!< u(1)
+   uint32_t top_field_is_left_view_flag;                                //!< u(1)
+   uint32_t current_frame_is_left_view_flag;                       //!< u(1)
+   uint32_t next_frame_is_second_view_flag;                     //!< u(1)
+   uint32_t left_view_self_contained_flag;                           //!< u(1)
+   uint32_t right_view_self_contained_flag;                         //!< u(1)
+}sStereo_video_info;
+
+/*------------------------------------------------------------------------------------
+    sframe_packing_arrangement
+    This structure contains the frame packing arrangement info for SEI msg elements
+   -----------------------------------------------------------------------------------*/
+typedef struct sei_frame_packing_arrangement {
+   uint32_t frame_packing_arrangement_id;                                                    //!< ue(v)
+   uint32_t frame_packing_arrangement_cancel_flag;                                    //!< u(1)
+   uint32_t frame_packing_arrangement_type;                                               //!< u(7)
+   uint32_t quincunx_sampling_flag;                                                                //!< u(1)
+   uint32_t content_interpretation_type;                                                          //!< u(6)
+   uint32_t spatial_flipping_flag;                                                                      //!< u(1)
+   uint32_t frame0_flipped_flag;                                                                      //!< u(1)
+   uint32_t field_views_flag;                                                                             //!< u(1)
+   uint32_t current_frame_is_frame0_flag;                                                     //!< u(7)
+   uint32_t frame0_self_contained_flag;                                                         //!< u(1)
+   uint32_t frame1_self_contained_flag;                                                         //!< u(1)
+   uint32_t frame0_grid_position_x;                                                                //!< u(4)
+   uint32_t frame0_grid_position_y;                                                                //!< u(4)
+   uint32_t frame1_grid_position_x;                                                                //!< u(4)
+   uint32_t frame1_grid_position_y;                                                                //!< u(4)
+   uint32_t frame_packing_arrangement_reserved_byte;                             //!< u(8)
+   uint32_t frame_packing_arrangement_repetition_period;                        //!< ue(v)
+   uint32_t frame_packing_arrangement_extension_flag;                            //!< u(1)
+}sframe_packing_arrangement;
+
+/*------------------------------------------------------------------------------------
+    sframe_packing_arrangement_type
+    This enum contains the frame packing arrangement type that will be passed to the display driver
+   -----------------------------------------------------------------------------------*/
+typedef enum {
+   checkerboard = 0,
+   column = 1,
+   row = 2,
+   side_by_side = 3,
+   top_bottom = 4,
+   temporal = 5,
+}sframe_packing_arrangement_type;
+
+using namespace android;
+
+int16_t ShowBits(
+    mp4StreamType *pStream,           /* Input Stream */
+    uint8_t ucNBits,          /* nr of bits to read */
+    uint32_t *pulOutData      /* output target */
+)
+{
+    uint8_t *bits;
+    uint32_t dataBitPos = pStream->dataBitPos;
+    uint32_t bitPos = pStream->bitPos;
+    uint32_t dataBytePos;
+
+    uint i;
+
+    if (ucNBits > (32 - bitPos))    /* not enough bits */
+    {
+        dataBytePos = dataBitPos >> 3; /* Byte Aligned Position */
+        bitPos = dataBitPos & 7; /* update bit position */
+        if (dataBytePos > pStream->numBytes - 4)
+        {
+            pStream->bitBuf = 0;
+            for (i = 0;i < pStream->numBytes - dataBytePos;i++)
+            {
+                pStream->bitBuf |= pStream->data[dataBytePos+i];
+                pStream->bitBuf <<= 8;
+            }
+            pStream->bitBuf <<= 8 * (3 - i);
+        }
+        else
+        {
+            bits = &pStream->data[dataBytePos];
+            pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
+        }
+        pStream->bitPos = bitPos;
+    }
+
+    bitPos += ucNBits;
+
+    *pulOutData = (pStream->bitBuf >> (32 - bitPos)) & mask[(uint16_t)ucNBits];
+
+    return 0;
+}
+
+int16_t FlushBits(
+    mp4StreamType *pStream,           /* Input Stream */
+    uint8_t ucNBits                      /* number of bits to flush */
+)
+{
+    uint8_t *bits;
+    uint32_t dataBitPos = pStream->dataBitPos;
+    uint32_t bitPos = pStream->bitPos;
+    uint32_t dataBytePos;
+
+
+    if ((dataBitPos + ucNBits) > (uint32_t)(pStream->numBytes << 3))
+        return (-2); // Buffer over run
+
+    dataBitPos += ucNBits;
+    bitPos     += ucNBits;
+
+    if (bitPos > 32)
+    {
+        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
+        bitPos = dataBitPos & 7; /* update bit position */
+        bits = &pStream->data[dataBytePos];
+        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
+    }
+
+    pStream->dataBitPos = dataBitPos;
+    pStream->bitPos     = bitPos;
+
+    return 0;
+}
+
+int16_t ReadBits(
+    mp4StreamType *pStream,           /* Input Stream */
+    uint8_t ucNBits,                     /* nr of bits to read */
+    uint32_t *pulOutData                 /* output target */
+)
+{
+    uint8_t *bits;
+    uint32_t dataBitPos = pStream->dataBitPos;
+    uint32_t bitPos = pStream->bitPos;
+    uint32_t dataBytePos;
+
+
+    if ((dataBitPos + ucNBits) > (pStream->numBytes << 3))
+    {
+        *pulOutData = 0;
+        return (-2); // Buffer over run
+    }
+
+    //  dataBitPos += ucNBits;
+
+    if (ucNBits > (32 - bitPos))    /* not enough bits */
+    {
+        dataBytePos = dataBitPos >> 3;    /* Byte Aligned Position */
+        bitPos = dataBitPos & 7; /* update bit position */
+        bits = &pStream->data[dataBytePos];
+        pStream->bitBuf = (bits[0] << 24) | (bits[1] << 16) | (bits[2] << 8) | bits[3];
+    }
+
+    pStream->dataBitPos += ucNBits;
+    pStream->bitPos      = (unsigned char)(bitPos + ucNBits);
+
+    *pulOutData = (pStream->bitBuf >> (32 - pStream->bitPos)) & mask[(uint16_t)ucNBits];
+
+    return 0;
+}
+
+void ue_v(mp4StreamType *psBits, uint32_t *codeNum)
+{
+    uint32_t temp;
+    uint tmp_cnt;
+    int32_t leading_zeros = 0;
+    ShowBits(psBits, 16, &temp);
+    tmp_cnt = temp  | 0x1;
+    PV_CLZ(leading_zeros, tmp_cnt)
+
+    if (leading_zeros < 8)
+    {
+        *codeNum = (temp >> (15 - (leading_zeros << 1))) - 1;
+        FlushBits(psBits, (leading_zeros << 1) + 1);
+    }
+    else
+    {
+        ReadBits(psBits, (leading_zeros << 1) + 1, &temp);
+        *codeNum = temp - 1;
+    }
+}
+
+/* Subclause D.1.22 */
+int16_t stereo_video_info(mp4StreamType *psBits, S3D_params &mS3Dparams)
+{
+    // SEI message detected, default configuration
+    mS3Dparams.active = true;
+    mS3Dparams.mode = S3D_MODE_ON;
+    mS3Dparams.fmt = S3D_FORMAT_OVERUNDER;
+    mS3Dparams.subsampling = S3D_SS_NONE;
+
+    int16_t status =0;
+    uint32_t temp;
+    sStereo_video_info* pStereo_video_info = (sStereo_video_info *)malloc(sizeof(sStereo_video_info));
+    ReadBits(psBits, 1, &temp);
+    pStereo_video_info->field_views_flag = temp;
+
+    if( pStereo_video_info->field_views_flag )
+    {
+        mS3Dparams.metadata = S3D_SEI_STEREO_INFO_INTERLACED;
+        ReadBits(psBits, 1, &temp);
+        pStereo_video_info->top_field_is_left_view_flag = temp;
+        if(pStereo_video_info->top_field_is_left_view_flag)
+                mS3Dparams.order = S3D_ORDER_LF;
+        else
+                mS3Dparams.order = S3D_ORDER_RF;
+    }
+    else
+    {
+        mS3Dparams.metadata = S3D_SEI_STEREO_INFO_PROGRESSIVE;
+        ReadBits(psBits, 1, &temp);
+        pStereo_video_info->current_frame_is_left_view_flag = temp;
+        if(pStereo_video_info->current_frame_is_left_view_flag)
+                mS3Dparams.order = S3D_ORDER_LF;
+        else
+                mS3Dparams.order = S3D_ORDER_RF;
+
+        ReadBits(psBits, 1, &temp);
+        pStereo_video_info->next_frame_is_second_view_flag = temp;
+    }
+
+    ReadBits(psBits, 1, &temp);
+    pStereo_video_info->left_view_self_contained_flag = temp;
+    ReadBits(psBits, 1, &temp);
+    pStereo_video_info->right_view_self_contained_flag = temp;
+
+    free(pStereo_video_info);
+    return status;
+}
+
+/* Subclause D.1.25 */
+int16_t frame_packing_arrangement(mp4StreamType *psBits, S3D_params &mS3Dparams, int32_t payloadSize)
+{
+    // SEI message detected, default configuration
+    mS3Dparams.active = true;
+    mS3Dparams.mode = S3D_MODE_ON;
+    mS3Dparams.subsampling = S3D_SS_NONE;
+    mS3Dparams.metadata = S3D_SEI_STEREO_FRAME_PACKING;
+
+    int status =0, bitsToFlush = 0;
+    uint32_t temp;
+    uint32_t bitsread_diff = psBits->dataBitPos;
+
+    sframe_packing_arrangement* pframe_packing_arrangement = (sframe_packing_arrangement *)malloc(sizeof(sframe_packing_arrangement));
+    // Get and pass frame_packing_arrangement_type
+    ue_v(psBits, &(pframe_packing_arrangement->frame_packing_arrangement_id));
+    ReadBits(psBits, 1, &temp);
+    pframe_packing_arrangement->frame_packing_arrangement_cancel_flag = temp;
+    if(!pframe_packing_arrangement->frame_packing_arrangement_cancel_flag)
+    {
+        ReadBits(psBits, 7, &temp);
+        pframe_packing_arrangement->frame_packing_arrangement_type = temp;
+        set_frame_packing_arrangement_type(pframe_packing_arrangement->frame_packing_arrangement_type, mS3Dparams.fmt, mS3Dparams.subsampling);
+
+        ReadBits(psBits, 1, &temp);
+        pframe_packing_arrangement->quincunx_sampling_flag= temp;
+        ReadBits(psBits, 6, &temp);
+        pframe_packing_arrangement->content_interpretation_type= temp;
+        if(pframe_packing_arrangement->content_interpretation_type)
+            mS3Dparams.order = S3D_ORDER_LF;
+        else
+            mS3Dparams.order = S3D_ORDER_RF;
+
+        ReadBits(psBits, 1, &temp);
+        pframe_packing_arrangement->spatial_flipping_flag= temp;
+        ReadBits(psBits, 1, &temp);
+        pframe_packing_arrangement->frame0_flipped_flag= temp;
+        ReadBits(psBits, 1, &temp);
+        pframe_packing_arrangement->field_views_flag= temp;
+        ReadBits(psBits, 1, &temp);
+        pframe_packing_arrangement->current_frame_is_frame0_flag = temp;
+        ReadBits(psBits, 1, &temp);
+        pframe_packing_arrangement->frame0_self_contained_flag= temp;
+        ReadBits(psBits, 1, &temp);
+        pframe_packing_arrangement->frame1_self_contained_flag= temp;
+
+        if(!pframe_packing_arrangement->quincunx_sampling_flag &&
+            pframe_packing_arrangement->content_interpretation_type != temporal)
+        {
+            ReadBits(psBits, 4, &temp);
+            pframe_packing_arrangement->frame0_grid_position_x= temp;
+            ReadBits(psBits, 4, &temp);
+            pframe_packing_arrangement->frame0_grid_position_y = temp;
+            ReadBits(psBits, 4, &temp);
+            pframe_packing_arrangement->frame1_grid_position_x= temp;
+            ReadBits(psBits, 4, &temp);
+            pframe_packing_arrangement->frame1_grid_position_y= temp;
+        }
+        ReadBits(psBits, 8, &temp);
+        pframe_packing_arrangement->frame_packing_arrangement_reserved_byte = temp;
+        ue_v(psBits, &(pframe_packing_arrangement->frame_packing_arrangement_repetition_period));
+    }
+
+    ReadBits(psBits, 1, &temp);
+    pframe_packing_arrangement->frame_packing_arrangement_extension_flag = temp;
+
+    // To account for trailling 0;
+    bitsread_diff= psBits->dataBitPos - bitsread_diff;
+    bitsToFlush = 8*payloadSize - bitsread_diff;
+    if(bitsToFlush > 0)
+        FlushBits(psBits, bitsToFlush);
+
+    free(pframe_packing_arrangement);
+    return status; // return 0 for success
+}
+
+// Annex D.1 SEI payload syntax
+int16_t sei_payload(mp4StreamType *psBits, int32_t payloadType, int32_t payloadSize, S3D_params &mS3Dparams)
+{
+    int16_t status = 0;
+    int i;
+    switch (payloadType)
+    {
+        case STEREO_VIDEO_INFO_TYPE:
+        /*     Stereo video Information SEI message          */
+            status = stereo_video_info(psBits, mS3Dparams);
+        break;
+        case FRAME_PACKING_ARRANGEMENT_TYPE:
+        /*      Frame packaging arrangement SEI message */
+            status = frame_packing_arrangement(psBits, mS3Dparams, payloadSize);
+        break;
+        default: //for case 0-20,22-44 and reserved sei messages
+        /* SEI messages reserved or not supported*/
+        LOGE("SEI messages reserved or not supported: 0x%x\n", payloadType);
+        for (i = 0; i < payloadSize; i++)
+        {
+            FlushBits(psBits, 8);
+        }
+        break;
+    }
+    return status; // return 0 for success
+}
+
+//ref subclause 7.3.2.3.1 SEI message syntax
+int16_t sei_message(mp4StreamType *psBits, /*int32_t *ff_byte, */ int32_t *last_payload_type_byte, int32_t *last_payload_size_byte, S3D_params &mS3Dparams)
+{
+    uint32_t temp;
+    int32_t payloadType, payloadSize;
+    int16_t status = 0;
+
+    payloadType = 0;
+    // Not needed as the output of the read function does not contain the
+    // emulation prevention bytes.
+    /*while(0xFF == ReadBits(psBits, 8, &temp)) {
+        *ff_byte = temp;
+        payloadType += 255;
+    }*/
+
+    ReadBits(psBits, 8, &temp);
+    *last_payload_type_byte = temp;
+    payloadType += *last_payload_type_byte;
+    LOGV("Value for payloadType = %d \n", payloadType);
+
+    payloadSize = 0;
+    // Not needed as the output of the read function does not contain the
+    // emulation prevention bytes.
+    /*while(0xFF == ReadBits(psBits, 8, &temp)) {
+        *ff_byte = temp;
+        payloadSize += 255;
+    }*/
+
+    ReadBits(psBits, 8, &temp);
+    *last_payload_size_byte = temp;
+    payloadSize += *last_payload_size_byte;
+    LOGV("Value for payloadSize = %d \n", payloadSize);
+
+    status = sei_payload(psBits, payloadType, payloadSize, mS3Dparams);
+
+    return status;
+}
+
+namespace android {
+
+static int got_packing = 0;
+/* ======================================================================== */
+/*  Function : sei_rbsp()                                                   */
+/*  Purpose  : parse SEI messages NAL unit (ref: subclause 7.3.2.3)         */
+/* ======================================================================== */
+int16_t sei_rbsp(uint8_t *buffer, int32_t length , S3D_params &mS3Dparams)
+{
+    int16_t status = 0;
+    int32_t last_payload_type_byte, last_payload_size_byte;
+    uint32_t temp;
+    int32_t NALSize = 0;
+
+    got_packing = 0;
+    mp4StreamType psBits;
+    psBits.data  = buffer;
+    psBits.numBytes = length;
+    psBits.bytePos = 0;
+    psBits.bitBuf = 0;
+    psBits.dataBitPos = 0;
+    psBits.bitPos = 32;
+
+    // Check if SEI NAL Unit
+    ReadBits(&psBits, 8, &temp);
+    if ((temp & 0x1F) != 6) return MP4_INVALID_VOL_PARAM;
+
+    //Account for NAL Unit type message
+    NALSize++;
+
+  /*---------------------------------------------------------------------------
+  *     Multiple SEI messages can be present in one SEI NAL. This do-while
+  *     loop processes one SEI message per iteration.
+  ----------------------------------------------------------------------------*/
+    do
+    {
+        status = 0;
+        if (!got_packing) {
+            status = sei_message(&psBits, &last_payload_type_byte, &last_payload_size_byte, mS3Dparams);
+        }
+        ShowBits(&psBits, 8, &temp);
+        NALSize += PAYLOAD_HEADER_SIZE + last_payload_size_byte;
+    }while(temp != 0x80 && NALSize < (length-1) ); // more_rbsp_data();  We do account for termination bit 0x80
+  // ignore the trailing bits rbsp_trailing_bits();
+  //assert( NALSize+1 == length );
+
+    return status;
+}
+
+/* ======================================================================== */
+/*  Function : AVCGetNALType()                                              */
+/*  Purpose  : Sniff NAL type from the bitstream                            */
+/* ======================================================================== */
+int32_t AVCGetNALType(uint8_t *bitstream, int size,int *nal_type, int *nal_ref_idc)
+{
+    int forbidden_zero_bit;
+    if (size > 0)
+    {
+        forbidden_zero_bit = bitstream[0] >> 7;
+        if (forbidden_zero_bit != 0)
+            return -1;
+        *nal_ref_idc = (bitstream[0] & 0x60) >> 5;
+        *nal_type = bitstream[0] & 0x1F;
+        return 0;
+    }
+
+    return -1;
+}
+
+void set_frame_packing_arrangement_type(uint32_t frame_packing_arrangement_type, uint32_t &format, uint32_t &subsampling)
+{
+
+    switch(frame_packing_arrangement_type)
+    {
+        case checkerboard:
+        {
+            LOGV("Frame packing: Checkerboard \n");
+            format = S3D_FORMAT_CHECKB;
+            break;
+        }
+        case column:
+        {
+            LOGV("Frame packing: col il \n");
+            format = S3D_FORMAT_COL_IL;
+            break;
+        }
+        case row:
+        {
+            LOGV("Frame packing: row il \n");
+            format = S3D_FORMAT_ROW_IL;
+            break;
+        }
+        case side_by_side:
+        {
+            LOGV("Frame packing: side_by_side \n");
+            format = S3D_FORMAT_SIDEBYSIDE;
+            subsampling = S3D_SS_HOR;
+            break;
+        }
+        case top_bottom:
+        {
+            LOGV("Frame packing: TOP/BOT \n");
+            format = S3D_FORMAT_OVERUNDER;
+            subsampling = S3D_SS_VERT;
+            break;
+        }
+        case temporal:
+        {
+            LOGV("Frame packing: Frame Seq \n");
+            format = S3D_FORMAT_FRM_SEQ;
+            break;
+        }
+        default:
+        {
+            LOGV("Frame packing: Default to top/bottom \n");
+            format = S3D_FORMAT_OVERUNDER;
+            break;
+        }
+    }
+    got_packing = 1;
+}
+
+}// namespace android
+
+
+#endif
+
diff --git a/media/libstagefright/TIVideoConfigParser.cpp b/media/libstagefright/TIVideoConfigParser.cpp
new file mode 100644
index 0000000..18f7794
--- /dev/null
+++ b/media/libstagefright/TIVideoConfigParser.cpp
@@ -0,0 +1,596 @@
+/*
+ * Copyright (C) Texas Instruments - http://www.ti.com/
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+#define LOG_TAG "SF_TI_Parser"
+#include <utils/Log.h>
+//#define LOG_NDEBUG 0
+
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/Utils.h>
+
+#define MP4_INVALID_VOL_PARAM               -1
+#define SHORT_HEADER_MODE                   -4
+
+#define VISUAL_OBJECT_SEQUENCE_START_CODE   0x01B0
+#define VISUAL_OBJECT_SEQUENCE_END_CODE     0x01B1
+#define VISUAL_OBJECT_START_CODE            0x01B5
+#define VO_START_CODE                       0x8
+#define VO_HEADER_LENGTH                    32
+#define VOL_START_CODE                      0x12
+#define VOL_START_CODE_LENGTH               28
+
+#define GROUP_START_CODE                    0x01B3
+#define GROUP_START_CODE_LENGTH             32
+
+#define VOP_ID_CODE_LENGTH                  5
+#define VOP_TEMP_REF_CODE_LENGTH            16
+
+#define USER_DATA_START_CODE                0x01B2
+#define USER_DATA_START_CODE_LENGTH         32
+
+#define SHORT_VIDEO_START_MARKER            0x20
+#define SHORT_VIDEO_START_MARKER_LENGTH     22
+
+
+namespace android {
+
+
+typedef struct __bit_buffer {
+    uint8_t * start;
+    size_t size;
+    uint8_t * current;
+    uint8_t read_bits;
+} bit_buffer;
+
+static void skip_bits(bit_buffer * bb, size_t nbits) {
+    bb->current = bb->current + ((nbits + bb->read_bits) / 8);
+    bb->read_bits = (uint8_t)((bb->read_bits + nbits) % 8);
+}
+
+static uint8_t get_bit(bit_buffer * bb) {
+    uint8_t ret;
+    ret = (*(bb->current) >> (7 - bb->read_bits)) & 0x1;
+    if (bb->read_bits == 7) {
+        bb->read_bits = 0;
+        bb->current++;
+    }
+    else {
+        bb->read_bits++;
+    }
+    return ret;
+}
+
+static uint32_t get_bits(bit_buffer * bb, size_t nbits) {
+    uint32_t i, ret;
+    ret = 0;
+    for (i = 0; i < nbits; i++) {
+        ret = (ret << 1) + get_bit(bb);
+    }
+    return ret;
+}
+
+static uint32_t exp_golomb_ue(bit_buffer * bb) {
+    uint8_t bit, significant_bits;
+    significant_bits = 0;
+    bit = get_bit(bb);
+    while (bit == 0) {
+        significant_bits++;
+        bit = get_bit(bb);
+    }
+    return (1 << significant_bits) + get_bits(bb, significant_bits) - 1;
+}
+
+static int32_t exp_golomb_se(bit_buffer * bb) {
+    int32_t ret;
+    ret = exp_golomb_ue(bb);
+    if ((ret & 0x1) == 0) {
+        return -(ret >> 1);
+    }
+    else {
+        return (ret + 1) >> 1;
+    }
+}
+
+static void parse_scaling_list(uint32_t size, bit_buffer * bb) {
+    uint32_t last_scale, next_scale, i;
+    int32_t delta_scale;
+    last_scale = 8;
+    next_scale = 8;
+    for (i = 0; i < size; i++) {
+        if (next_scale != 0) {
+            delta_scale = exp_golomb_se(bb);
+            next_scale = (last_scale + delta_scale + 256) % 256;
+        }
+        if (next_scale != 0) {
+            last_scale = next_scale;
+        }
+    }
+}
+
+void parse_sps(uint8_t * sps,size_t sps_size,uint8_t *aprofile,uint8_t *alevel,uint32_t *num_ref_frames,uint8_t *interlaced)
+{
+    bit_buffer bb;
+    uint32_t pic_order_cnt_type, width_in_mbs, height_in_map_units;
+    uint32_t i, size, left, right, top, bottom;
+    uint8_t frame_mbs_only_flag;
+    uint8_t profile, level;
+    uint32_t width,height;
+
+    bb.start = sps;
+    bb.size = sps_size;
+    bb.current = sps;
+    bb.read_bits = 0;
+
+    /* skip first byte, since we already know we're parsing a SPS */
+    skip_bits(&bb, 8);
+
+    /* get profile */
+    profile = (uint8_t) get_bits(&bb, 8);
+    LOGV("AVC Profile %d",profile);
+
+    /* skip 8 bits */
+    skip_bits(&bb, 8);
+
+    /* get level */
+    level = (uint8_t) get_bits(&bb, 8);
+    LOGV("AVC Level %d",level);
+
+    *aprofile = profile;
+    *alevel = level;
+
+    /* read sps id, first exp-golomb encoded value */
+    exp_golomb_ue(&bb);
+
+    if (profile == 100 || profile == 110 || profile == 122 || profile == 144) {
+        /* chroma format idx */
+        if (exp_golomb_ue(&bb) == 3) {
+            skip_bits(&bb, 1);
+        }
+        /* bit depth luma minus8 */
+        exp_golomb_ue(&bb);
+        /* bit depth chroma minus8 */
+        exp_golomb_ue(&bb);
+        /* Qpprime Y Zero Transform Bypass flag */
+        skip_bits(&bb, 1);
+        /* Seq Scaling Matrix Present Flag */
+        if (get_bit(&bb)) {
+            for (i = 0; i < 8; i++) {
+                /* Seq Scaling List Present Flag */
+                if (get_bit(&bb)) {
+                    parse_scaling_list(i < 6 ? 16 : 64, &bb);
+                }
+            }
+        }
+    }
+    /* log2_max_frame_num_minus4 */
+    exp_golomb_ue(&bb);
+    /* pic_order_cnt_type */
+    pic_order_cnt_type = exp_golomb_ue(&bb);
+    if (pic_order_cnt_type == 0) {
+        /* log2_max_pic_order_cnt_lsb_minus4 */
+        exp_golomb_ue(&bb);
+    }
+    else if (pic_order_cnt_type == 1) {
+        /* delta_pic_order_always_zero_flag */
+        skip_bits(&bb, 1);
+        /* offset_for_non_ref_pic */
+        exp_golomb_se(&bb);
+        /* offset_for_top_to_bottom_field */
+        exp_golomb_se(&bb);
+        size = exp_golomb_ue(&bb);
+        for (i = 0; i < size; i++) {
+            /* offset_for_ref_frame */
+            exp_golomb_se(&bb);
+        }
+    }
+
+    /* num_ref_frames */
+    *num_ref_frames = exp_golomb_ue(&bb);
+    LOGV("AVC No of Ref frames %d",*num_ref_frames);
+
+    /* gaps_in_frame_num_value_allowed_flag */
+    skip_bits(&bb, 1);
+    /* pic_width_in_mbs */
+    width_in_mbs = exp_golomb_ue(&bb) + 1;
+    /* pic_height_in_map_units */
+    height_in_map_units = exp_golomb_ue(&bb) + 1;
+    /* frame_mbs_only_flag */
+    frame_mbs_only_flag = get_bit(&bb);
+
+    LOGV("AVC frame_mbs_only_flag %d", frame_mbs_only_flag);
+
+    /* 0-interlaced. 1-progressive */
+    *interlaced = !frame_mbs_only_flag;
+
+    if (!frame_mbs_only_flag) {
+        /* mb_adaptive_frame_field */
+        skip_bits(&bb, 1);
+    }
+    /* direct_8x8_inference_flag */
+    skip_bits(&bb, 1);
+    /* frame_cropping */
+    left = right = top = bottom = 0;
+    if (get_bit(&bb)) {
+        left = exp_golomb_ue(&bb) * 2;
+        right = exp_golomb_ue(&bb) * 2;
+        top = exp_golomb_ue(&bb) * 2;
+        bottom = exp_golomb_ue(&bb) * 2;
+        if (!frame_mbs_only_flag) {
+            top *= 2;
+            bottom *= 2;
+        }
+    }
+
+    /* width */
+    width = width_in_mbs * 16 - (left + right);
+    /* height */
+    height = height_in_map_units * 16 - (top + bottom);
+    if (!frame_mbs_only_flag) {
+        height *= 2;
+    }
+}
+
+
+void ReadBits(bit_buffer *bb, int nbits, uint32_t* val)
+{
+    *val = get_bits(bb, nbits);
+}
+
+int16_t Search4VOLHeader(bit_buffer *psBits)
+{
+    uint32_t i;
+    int32_t count = 0;
+    int16_t status = -1;
+
+    uint32_t curr_state = 0;
+    bool found = false;
+
+     /* search 0x00 0x00 0x01 0x20 */
+
+     /* Byte alignment*/
+     while(psBits->read_bits)
+     {
+         ReadBits(psBits,1,&i);
+     }
+
+     do{
+        ReadBits(psBits,8,&i);
+        switch(curr_state)
+        {
+            case 0:
+                      if(i==0) curr_state = 1;      /* just got 00 */
+                          else curr_state = 0;
+                      break;
+            case 1:
+                      if(i==0) curr_state = 2;      /* Now 00. Got 00*/
+                      else curr_state = 0;
+                      break;
+            case 2:
+                      if(i==1) curr_state = 3;      /* Now 01. Got 00 00 */
+                      else if(i==0) curr_state = 2; /* Now 00. Got 00 00*/
+                      else curr_state = 0;
+                      break;
+            case 3:
+                      if(i==0x20) found = true;     /*Now 20. Got 00 00 01*/
+                      else curr_state = 0;
+                      break;
+        };
+
+     }while((psBits->current < psBits->start + psBits->size)  && !found);
+
+     if(found)
+       status = 0;
+     else
+       status = -1;
+
+    return status;
+}
+
+int16_t parse_vol(uint8_t *vol,size_t vol_size,uint8_t *aprofile,uint8_t *alevel,uint32_t *num_ref_frames,uint8_t* interlaced)
+{
+    int16_t iErrorStat;
+    uint32_t codeword;
+    uint32_t time_increment_resolution, nbits_time_increment;
+    uint32_t i, j;
+
+    uint32_t display_width, display_height;
+    uint32_t width,height;
+
+    int32_t* profilelevel;
+
+
+    bit_buffer bb;
+    bb.start = vol;
+    bb.size = vol_size;
+    bb.current = vol;
+    bb.read_bits = 0;
+
+    bit_buffer *psBits = &bb;
+
+    uint32_t status =  0;
+
+    while(psBits->current <(psBits->start + psBits->size)){
+
+    /* detect VOL start code 00 00 01 20 */
+    uint32_t status = Search4VOLHeader(psBits);
+
+        uint32_t vol_id;
+
+        /* vol_id (4 bits) */
+        //ReadBits(psBits, 4, & vol_id);
+
+        // RandomAccessibleVOLFlag
+        ReadBits(psBits, 1, &codeword);
+
+        //Video Object Type Indication
+        ReadBits(psBits, 8, &codeword);
+        if (codeword != 1)
+        {
+            //return MP4_INVALID_VOL_PARAM; //TI supports this feature
+        }
+
+        // is_object_layer_identifier
+        ReadBits(psBits, 1, &codeword);
+
+        if (codeword)
+        {
+            ReadBits(psBits, 4, &codeword);
+            ReadBits(psBits, 3, &codeword);
+        }
+
+        // aspect ratio
+        ReadBits(psBits, 4, &codeword);
+
+        if (codeword == 0xF)
+        {
+            // Extended Parameter
+            /* width */
+            ReadBits(psBits, 8, &codeword);
+            /* height */
+            ReadBits(psBits, 8, &codeword);
+        }
+
+        ReadBits(psBits, 1, &codeword);
+
+        if (codeword)
+        {
+            ReadBits(psBits, 2, &codeword);
+            if (codeword != 1)
+            {
+                return MP4_INVALID_VOL_PARAM;
+            }
+
+            ReadBits(psBits, 1, &codeword);
+
+            if (!codeword)
+            {
+                //return MP4_INVALID_VOL_PARAM; //TI supports this feature
+            }
+
+            ReadBits(psBits, 1, &codeword);
+            if (codeword)   /* if (vbv_parameters) {}, page 36 */
+            {
+                ReadBits(psBits, 15, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                {
+                    return MP4_INVALID_VOL_PARAM;
+                }
+
+                ReadBits(psBits, 15, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                {
+                    return MP4_INVALID_VOL_PARAM;
+                }
+
+
+                ReadBits(psBits, 19, &codeword);
+                if (!(codeword & 0x8))
+                {
+                    return MP4_INVALID_VOL_PARAM;
+                }
+
+                ReadBits(psBits, 11, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                {
+                    return MP4_INVALID_VOL_PARAM;
+                }
+
+                ReadBits(psBits, 15, &codeword);
+                ReadBits(psBits, 1, &codeword);
+                if (codeword != 1)
+                {
+                    return MP4_INVALID_VOL_PARAM;
+                }
+            }
+
+        }
+
+        ReadBits(psBits, 2, &codeword);
+
+        if (codeword != 0)
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+
+        ReadBits(psBits, 16, &codeword);
+        time_increment_resolution = codeword;
+
+
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+
+
+
+        ReadBits(psBits, 1, &codeword);
+
+        if (codeword && time_increment_resolution > 2)
+        {
+            i = time_increment_resolution - 1;
+            j = 1;
+            while (i >>= 1)
+            {
+                j++;
+            }
+            nbits_time_increment = j;
+
+            ReadBits(psBits, nbits_time_increment, &codeword);
+        }
+
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+
+        /* this should be 176 for QCIF */
+        ReadBits(psBits, 13, &codeword);
+        display_width = (uint32_t)codeword;
+        ReadBits(psBits, 1, &codeword);
+        if (codeword != 1)
+        {
+            return MP4_INVALID_VOL_PARAM;
+        }
+
+        /* this should be 144 for QCIF */
+        ReadBits(psBits, 13, &codeword);
+        display_height = (uint32_t)codeword;
+
+        width = (display_width + 15) & -16;
+        height = (display_height + 15) & -16;
+
+        /* marker */
+        ReadBits(psBits, 1, &codeword);
+
+        /* interlaced */
+        ReadBits(psBits, 1, &codeword);
+        LOGD("INTERLACE 0x%x",codeword);
+
+        if(codeword == 1)
+        {
+            *interlaced = (uint8_t) 1;
+        }
+        else
+        {
+            *interlaced = (uint8_t) 0;
+        }
+        return 0;
+
+    }
+
+    return 0;
+}
+
+void updateMetaData(sp<MetaData> meta_track)
+{
+    uint32_t type;
+    const void *data;
+    size_t size;
+
+    uint8_t profile,level,interlaced;
+    uint32_t num_ref_frames;
+
+    interlaced = 0;
+    profile = 0;
+    level = 0;
+    num_ref_frames = 0;
+
+    if ( meta_track->findData(kKeyESDS, &type, &data, &size)) {
+        LOGV("MPEG4 Header");
+        LOGV("size %d",size);
+        LOGV("type 0x%x", type);
+        LOGV("data 0x%x", data);
+
+        uint8_t *ptr = (uint8_t *)data;
+
+        parse_vol(ptr, size, &profile, &level, &num_ref_frames, &interlaced);
+
+        LOGV("MPEG4  Profile %d Level %d RefFrames %d Interlaced %d ", profile,level,num_ref_frames,interlaced);
+        meta_track->setInt32(kKeyVideoProfile, profile);
+        meta_track->setInt32(kKeyVideoLevel, level);
+        meta_track->setInt32(kKeyVideoInterlaced, interlaced);
+        meta_track->setInt32(kKeyNumRefFrames, num_ref_frames);
+
+
+    }
+    else if ( meta_track->findData(kKeyAVCC, &type, &data, &size)) {
+        LOGV("H264 Header");
+        LOGV("size %d",size);
+        LOGV("type 0x%x", type);
+        LOGV("data 0x%x", data);
+
+        const uint8_t *ptr = (const uint8_t *)data;
+
+        CHECK(size >= 7);
+        CHECK_EQ(ptr[0], 1);  // configurationVersion == 1
+
+        size_t numSeqParameterSets = ptr[5] & 31;
+
+        LOGV("numSeqParameterSets %d",numSeqParameterSets);
+
+        ptr += 6;
+        size -= 6;
+
+        for (size_t i = 0; i < numSeqParameterSets; ++i) {
+            CHECK(size >= 2);
+            size_t length = U16_AT(ptr);
+
+            ptr += 2;
+            size -= 2;
+
+            CHECK(size >= length);
+
+            parse_sps((uint8_t*)ptr, length, &profile, &level, &num_ref_frames, &interlaced);
+
+            LOGV("H264 Profile %d Level %d RefFrames %d Interlaced %d", profile,level,num_ref_frames,interlaced);
+            meta_track->setInt32(kKeyVideoProfile, profile);
+            meta_track->setInt32(kKeyVideoLevel, level);
+            meta_track->setInt32(kKeyNumRefFrames, num_ref_frames);
+            meta_track->setInt32(kKeyVideoInterlaced, interlaced);
+
+            ptr += length;
+            size -= length;
+        }
+
+    }
+
+    return;
+}
+
+
+}  // namespace android
+
+
+#endif
+
diff --git a/media/libstagefright/WAVExtractor.cpp b/media/libstagefright/WAVExtractor.cpp
index aff06bc..d0f337b 100644
--- a/media/libstagefright/WAVExtractor.cpp
+++ b/media/libstagefright/WAVExtractor.cpp
@@ -316,9 +316,16 @@ status_t WAVSource::read(
     *out = NULL;
 
     int64_t seekTimeUs;
+#ifdef OMAP_ENHANCEMENT
+    size_t bytesPerSample = mBitsPerSample >> 3;
+#endif
     ReadOptions::SeekMode mode;
     if (options != NULL && options->getSeekTo(&seekTimeUs, &mode)) {
+#ifdef OMAP_ENHANCEMENT
+        int64_t pos = (seekTimeUs * mSampleRate) / 1000000 * mNumChannels * bytesPerSample;
+#else
         int64_t pos = (seekTimeUs * mSampleRate) / 1000000 * mNumChannels * 2;
+#endif
         if (pos > mSize) {
             pos = mSize;
         }
@@ -353,7 +360,11 @@ status_t WAVSource::read(
         return ERROR_END_OF_STREAM;
     }
 
+#ifdef OMAP_ENHANCEMENT
+    int64_t offsetPos = n;
+#else
     mCurrentPos += n;
+#endif
 
     buffer->set_range(0, n);
 
@@ -398,13 +409,18 @@ status_t WAVSource::read(
         }
     }
 
+
+#ifndef OMAP_ENHANCEMENT
     size_t bytesPerSample = mBitsPerSample >> 3;
+#endif
 
     buffer->meta_data()->setInt64(
             kKeyTime,
             1000000LL * (mCurrentPos - mOffset)
                 / (mNumChannels * bytesPerSample) / mSampleRate);
-
+#ifdef OMAP_ENHANCEMENT
+    mCurrentPos += offsetPos;
+#endif
     buffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);
 
     *out = buffer;
diff --git a/media/libstagefright/codecs/aacdec/get_prog_config.cpp b/media/libstagefright/codecs/aacdec/get_prog_config.cpp
index 6bddd57..7021039 100644
--- a/media/libstagefright/codecs/aacdec/get_prog_config.cpp
+++ b/media/libstagefright/codecs/aacdec/get_prog_config.cpp
@@ -499,7 +499,7 @@ Int get_prog_config(
         /* rewind the pointer as implicit channel configuration maybe the case */
         pInputStream->usedBits -= (LEN_TAG + LEN_PROFILE + LEN_SAMP_IDX);
 
-        return (1); /*  mismatch cannot happen */
+        pScratchPCE->sampling_rate_idx = pVars->prog_config.sampling_rate_idx;
     }
 
 
diff --git a/media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp
index 7a279dc..9609e02 100644
--- a/media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp
+++ b/media/libstagefright/codecs/aacdec/pvmp4audiodecoderframe.cpp
@@ -521,7 +521,7 @@ OSCL_EXPORT_REF Int PVMP4AudioDecodeFrame(
     per_chan_share_w_fxpCoef *pChLeftShare;  /* Helper pointer */
     per_chan_share_w_fxpCoef *pChRightShare; /* Helper pointer */
 
-    Int            status = MP4AUDEC_SUCCESS;
+    Int            status = -1;
 
 
     Bool empty_frame;
@@ -679,7 +679,7 @@ OSCL_EXPORT_REF Int PVMP4AudioDecodeFrame(
     leaveGetLoop = FALSE;
     empty_frame  = TRUE;
 
-    while ((leaveGetLoop == FALSE) && (status == SUCCESS))
+    while (leaveGetLoop == FALSE)
     {
         /* get audio syntactic element */
         id_syn_ele = (Int)get9_n_lessbits(LEN_SE_ID, &pVars->inputStream);
@@ -755,19 +755,20 @@ OSCL_EXPORT_REF Int PVMP4AudioDecodeFrame(
                 getfill(&pVars->inputStream);
 #endif
 
-                break;
+                continue;
 
             case ID_DSE:       /* Data Streaming element */
                 get_dse(pVars->share.data_stream_bytes,
                         &pVars->inputStream);
-                break;
+                continue;
 
             default: /* Unsupported element, including ID_LFE */
                 status = -1;  /* ERROR CODE needs to be updated */
                 break;
 
         } /* end switch() */
-
+        if(status != SUCCESS)
+            break;
     } /* end while() */
 
     byte_align(&pVars->inputStream);
diff --git a/media/libstagefright/codecs/aacenc/AACEncoder.cpp b/media/libstagefright/codecs/aacenc/AACEncoder.cpp
old mode 100644
new mode 100755
index df9f107..3228c08
--- a/media/libstagefright/codecs/aacenc/AACEncoder.cpp
+++ b/media/libstagefright/codecs/aacenc/AACEncoder.cpp
@@ -138,7 +138,7 @@ status_t AACEncoder::start(MetaData *params) {
     }
 
     mBufferGroup = new MediaBufferGroup;
-    mBufferGroup->add_buffer(new MediaBuffer(2048));
+    mBufferGroup->add_buffer(new MediaBuffer(4096));
 
     CHECK_EQ(OK, initCheck());
 
@@ -236,7 +236,7 @@ status_t AACEncoder::read(
                 break;
             }
 
-            size_t align = mInputBuffer->range_length() % sizeof(int16_t);
+            size_t align = mInputBuffer->range_length() % (sizeof(int16_t) * mChannels);
             CHECK_EQ(align, 0);
 
             int64_t timeUs;
@@ -251,13 +251,13 @@ status_t AACEncoder::read(
             readFromSource = false;
         }
         size_t copy =
-            (kNumSamplesPerFrame - mNumInputSamples) * sizeof(int16_t);
+            (kNumSamplesPerFrame - mNumInputSamples) * sizeof(int16_t) * mChannels;
 
         if (copy > mInputBuffer->range_length()) {
             copy = mInputBuffer->range_length();
         }
 
-        memcpy(&mInputFrame[mNumInputSamples],
+        memcpy(&mInputFrame[mNumInputSamples * mChannels],
                (const uint8_t *) mInputBuffer->data()
                     + mInputBuffer->range_offset(),
                copy);
@@ -270,7 +270,7 @@ status_t AACEncoder::read(
             mInputBuffer->release();
             mInputBuffer = NULL;
         }
-        mNumInputSamples += copy / sizeof(int16_t);
+        mNumInputSamples += copy / (sizeof(int16_t) * mChannels);
         if (mNumInputSamples >= kNumSamplesPerFrame) {
             mNumInputSamples %= kNumSamplesPerFrame;
             break;
@@ -280,7 +280,7 @@ status_t AACEncoder::read(
     VO_CODECBUFFER inputData;
     memset(&inputData, 0, sizeof(inputData));
     inputData.Buffer = (unsigned char*) mInputFrame;
-    inputData.Length = kNumSamplesPerFrame * sizeof(int16_t);
+    inputData.Length = kNumSamplesPerFrame * sizeof(int16_t) * mChannels;
     CHECK(VO_ERR_NONE == mApiHandle->SetInputData(mEncoderHandle,&inputData));
 
     VO_CODECBUFFER outputData;
@@ -293,7 +293,7 @@ status_t AACEncoder::read(
     outputData.Length = buffer->size();
     ret = mApiHandle->GetOutputData(mEncoderHandle, &outputData, &outputInfo);
     CHECK(ret == VO_ERR_NONE || ret == VO_ERR_INPUT_BUFFER_SMALL);
-    CHECK(outputData.Length != 0);
+    //CHECK(outputData.Length != 0);
     buffer->set_range(0, outputData.Length);
 
     int64_t mediaTimeUs =
diff --git a/media/libstagefright/codecs/aacenc/Android.mk b/media/libstagefright/codecs/aacenc/Android.mk
index cda4f9d..3782853 100644
--- a/media/libstagefright/codecs/aacenc/Android.mk
+++ b/media/libstagefright/codecs/aacenc/Android.mk
@@ -59,7 +59,7 @@ LOCAL_MODULE := libstagefright_aacenc
 
 LOCAL_ARM_MODE := arm
 
-LOCAL_STATIC_LIBRARIES := 
+LOCAL_STATIC_LIBRARIES :=
 
 LOCAL_SHARED_LIBRARIES :=
 
diff --git a/media/libstagefright/codecs/aacenc/SampleCode/AAC_E_SAMPLES.c b/media/libstagefright/codecs/aacenc/SampleCode/AAC_E_SAMPLES.c
index 64d012d..c7b2616 100644
--- a/media/libstagefright/codecs/aacenc/SampleCode/AAC_E_SAMPLES.c
+++ b/media/libstagefright/codecs/aacenc/SampleCode/AAC_E_SAMPLES.c
@@ -1,283 +1,283 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		AAC_E_SAMPLES.h
-
-	Content:	sample code for AAC encoder
-
-*******************************************************************************/
-
-#include		<dlfcn.h>
-#include		<stdio.h>
-#include		<stdlib.h>
-#include		<string.h>
-#include		<time.h>
-#include		"voAAC.h"
-#include		"cmnMemory.h"
-
-#define  VO_AAC_E_OUTPUT	  1
-#define READ_SIZE	(1024*8)	
-unsigned char outBuf[1024*8];
-unsigned char inBuf[READ_SIZE];
-
-const char* HelpString = 
-"VisualOn AAC encoder Usage:\n"
-"voAACEncTest -if <inputfile.pcm> -of <outputfile.aac> -sr <samplerate> -ch <channel> -br <bitrate> -adts <adts> \n"
-"-if input file name \n"
-"-of output file name \n"
-"-sr input pcm samplerate, default 44100 \n"
-"-ch input pcm channel, default 2 channel \n"
-"-br encoded aac bitrate, default 64000 * (samplerate/100)*channel/441(480)\n"
-"-adts add or no adts header, default add adts header\n"
-"For example: \n"
-"./voAACEncTest -if raw.pcm -of raw.aac -sr 44100 -ch 2 -br 128000\n";
-
-static int parsecmdline(int argc, char **argv,char  **input_filename, char  **output_filename, AACENC_PARAM *param)
-{
-	// notice that:
-	// bitRate/nChannels > 8000
-	// bitRate/nChannels < 160000 
-	// bitRate/nChannels < sampleRate*6
-	param->adtsUsed = 1;
-	param->bitRate = 0;
-	param->nChannels = 2;
-	param->sampleRate = 44100;
-
-	if(argc < 5 || argc > 13)
-	{
-		return -1;
-	}
-
-	argc--;
-	argv++;
-	while (argc > 0)
-	{
-		if (!strcmp(*argv, "-if"))
-		{
-			argv++;
-			argc--;
-			*input_filename = *argv; 
-		}
-		else if (!strcmp(*argv, "-of"))
-		{
-			argv++;
-			argc--;
-			*output_filename = *argv;
-		}
-		else if (!strcmp(*argv, "-sr"))
-		{
-			argv++;
-			argc--;
-			param->sampleRate = atoi(*argv);
-		}
-		else if (!strcmp(*argv, "-ch"))
-		{
-			argv++;
-			argc--;
-			param->nChannels = atoi(*argv);
-		}
-		else if (!strcmp(*argv, "-br"))
-		{
-			argv++;
-			argc--;
-			param->bitRate = atoi(*argv);
-		}
-		else if(!strcmp(*argv, "-adts"))
-		{
-			argv++;
-			argc--;
-			param->adtsUsed = atoi(*argv);
-		}
-		else
-		{
-			return -1;
-		}
-
-		argv++;
-		argc--;
-	}
-
-	if(param->bitRate == 0)
-	{
-		int scale = 441;
-		if(param->sampleRate%8000 == 0)
-			scale = 480;
-		param->bitRate = 640*param->nChannels*param->sampleRate/scale;
-	}
-
-	return 0;
-}
-
-int ReadFile2Buf(FILE* infile,unsigned char* dest,int readSize)
-{
-	int readBytes = 0;
-	readBytes = fread(dest, 1, readSize, infile);
-	return readBytes;
-}
-
-typedef int (VO_API * VOGETAUDIODECAPI) (VO_AUDIO_CODECAPI * pDecHandle);
-
-int main(int argc, char **argv)
-{
-	FILE						*infile, *outfile;
-	int							t1, t2;
-	VO_AUDIO_CODECAPI			AudioAPI;
-	VO_MEM_OPERATOR				moper;
-	VO_CODEC_INIT_USERDATA		useData;
-	VO_HANDLE					hCodec;
-	VO_CODECBUFFER				inData;
-	VO_CODECBUFFER				outData;
-	VO_AUDIO_OUTPUTINFO			outInfo;
-    int							firstWrite = 1;
-	int							eofFile = 0;
-	int							*info=(int*)inBuf;
-	int							bytesLeft, nRead;
-	int							EncoderdFrame = 0;
-	int							total = 0;
-	int							isOutput = 1;
-	int							returnCode;
-	AACENC_PARAM				aacpara;
-	void						*handle;
-	void						*pfunc;
-	VOGETAUDIODECAPI			pGetAPI;
-	const char					*infileName = NULL;
-    const char					*outfileName = NULL;
-
-	returnCode = parsecmdline(argc,argv, &infileName, &outfileName, &aacpara);
-	if(returnCode)
-	{
-		printf("%s", HelpString);
-		return 0;
-	}
-
-	/* open input file */
-	infile = fopen(infileName, "rb");
-	if (!infile) {
-		printf("Open input file fail...");
-		return -1;
-	}
-
-	/* open output file */
-	if(isOutput)
-	{
-		outfile = fopen(outfileName, "wb"); 
-		if (!outfile) {
-			printf("Open output file fail...");
-			return -1;
-		}
-	}
-	// set memory operators;
-	moper.Alloc = cmnMemAlloc;
-	moper.Copy = cmnMemCopy;
-	moper.Free = cmnMemFree;
-	moper.Set = cmnMemSet;
-	moper.Check = cmnMemCheck;
-	useData.memflag = VO_IMF_USERMEMOPERATOR;
-	useData.memData = (VO_PTR)(&moper);
-	// open encoder dll;
-	handle = dlopen("/data/local/tmp/libvoAACEncv7.so", RTLD_NOW);
-	if(handle == 0)
-	{
-		printf("open dll error......");
-		return -1;
-	}
-	// Get API;
-	pfunc = dlsym(handle, "voGetAACEncAPI");	
-	if(pfunc == 0)
-	{
-		printf("open function error......");
-		return -1;
-	}
-	pGetAPI = (VOGETAUDIODECAPI)pfunc;
-	returnCode  = pGetAPI(&AudioAPI);
-	if(returnCode)
-		return -1;
-
-
-//#######################################   Init Encoding Section   #########################################
-	returnCode = AudioAPI.Init(&hCodec, VO_AUDIO_CodingAAC, &useData);
-	if(returnCode < 0)
-	{
-		printf("#### VOI_Error2:fail to initialize the Encoderr###\n");
-		return -1;
-	}
-
-	returnCode = AudioAPI.SetParam(hCodec, VO_PID_AAC_ENCPARAM, &aacpara);	
-	
-	inData.Buffer = inBuf;
-	bytesLeft = ReadFile2Buf(infile,inData.Buffer,READ_SIZE);
-
-//#######################################    Encoding Section   #########################################
-	
-	do {
-
-		inData.Length    = bytesLeft;
-		outData.Buffer   = outBuf;
-		outData.Length = 1024*8;
-
-		t1 = clock();
-		
-		returnCode = AudioAPI.SetInputData(hCodec,&inData);
-		
-		do {
-			outData.Buffer   = outBuf;
-			outData.Length = 1024*8;
-
-			returnCode = AudioAPI.GetOutputData(hCodec,&outData, &outInfo);
-
-			if(returnCode == 0)
-				EncoderdFrame++;
-			if(returnCode == VO_ERR_LICENSE_ERROR)
-				break;
-
-#if VO_AAC_E_OUTPUT
-			if (isOutput && returnCode == 0)
-			{
-				fwrite(outData.Buffer, 1, outData.Length, outfile);
-			}
-#endif
-		} while(returnCode != (VO_ERR_INPUT_BUFFER_SMALL));
-
-		if(returnCode == VO_ERR_LICENSE_ERROR)
-			break;
-
-		t2 = clock();
-		total += t2 - t1;
-
-		if (!eofFile) {
-			nRead = ReadFile2Buf(infile, inBuf,READ_SIZE);
-			bytesLeft = nRead;
-			inData.Buffer = inBuf;
-			if (feof(infile))
-				eofFile = 1;
-		}
-
-	} while (!eofFile && returnCode);
-
-
-//################################################  End Encoding Section  #######################################################
-	returnCode = AudioAPI.Uninit(hCodec);
-
-	fclose(infile);
-	if (outfile)
-    {
-        fclose(outfile);
-    }
-	dlclose(handle);
-	return 0;
-}
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		AAC_E_SAMPLES.h
+
+	Content:	sample code for AAC encoder
+
+*******************************************************************************/
+
+#include		<dlfcn.h>
+#include		<stdio.h>
+#include		<stdlib.h>
+#include		<string.h>
+#include		<time.h>
+#include		"voAAC.h"
+#include		"cmnMemory.h"
+
+#define  VO_AAC_E_OUTPUT	  1
+#define READ_SIZE	(1024*8)
+unsigned char outBuf[1024*8];
+unsigned char inBuf[READ_SIZE];
+
+const char* HelpString =
+"VisualOn AAC encoder Usage:\n"
+"voAACEncTest -if <inputfile.pcm> -of <outputfile.aac> -sr <samplerate> -ch <channel> -br <bitrate> -adts <adts> \n"
+"-if input file name \n"
+"-of output file name \n"
+"-sr input pcm samplerate, default 44100 \n"
+"-ch input pcm channel, default 2 channel \n"
+"-br encoded aac bitrate, default 64000 * (samplerate/100)*channel/441(480)\n"
+"-adts add or no adts header, default add adts header\n"
+"For example: \n"
+"./voAACEncTest -if raw.pcm -of raw.aac -sr 44100 -ch 2 -br 128000\n";
+
+static int parsecmdline(int argc, char **argv,char  **input_filename, char  **output_filename, AACENC_PARAM *param)
+{
+	// notice that:
+	// bitRate/nChannels > 8000
+	// bitRate/nChannels < 160000
+	// bitRate/nChannels < sampleRate*6
+	param->adtsUsed = 1;
+	param->bitRate = 0;
+	param->nChannels = 2;
+	param->sampleRate = 44100;
+
+	if(argc < 5 || argc > 13)
+	{
+		return -1;
+	}
+
+	argc--;
+	argv++;
+	while (argc > 0)
+	{
+		if (!strcmp(*argv, "-if"))
+		{
+			argv++;
+			argc--;
+			*input_filename = *argv;
+		}
+		else if (!strcmp(*argv, "-of"))
+		{
+			argv++;
+			argc--;
+			*output_filename = *argv;
+		}
+		else if (!strcmp(*argv, "-sr"))
+		{
+			argv++;
+			argc--;
+			param->sampleRate = atoi(*argv);
+		}
+		else if (!strcmp(*argv, "-ch"))
+		{
+			argv++;
+			argc--;
+			param->nChannels = atoi(*argv);
+		}
+		else if (!strcmp(*argv, "-br"))
+		{
+			argv++;
+			argc--;
+			param->bitRate = atoi(*argv);
+		}
+		else if(!strcmp(*argv, "-adts"))
+		{
+			argv++;
+			argc--;
+			param->adtsUsed = atoi(*argv);
+		}
+		else
+		{
+			return -1;
+		}
+
+		argv++;
+		argc--;
+	}
+
+	if(param->bitRate == 0)
+	{
+		int scale = 441;
+		if(param->sampleRate%8000 == 0)
+			scale = 480;
+		param->bitRate = 640*param->nChannels*param->sampleRate/scale;
+	}
+
+	return 0;
+}
+
+int ReadFile2Buf(FILE* infile,unsigned char* dest,int readSize)
+{
+	int readBytes = 0;
+	readBytes = fread(dest, 1, readSize, infile);
+	return readBytes;
+}
+
+typedef int (VO_API * VOGETAUDIODECAPI) (VO_AUDIO_CODECAPI * pDecHandle);
+
+int main(int argc, char **argv)
+{
+	FILE						*infile, *outfile;
+	int							t1, t2;
+	VO_AUDIO_CODECAPI			AudioAPI;
+	VO_MEM_OPERATOR				moper;
+	VO_CODEC_INIT_USERDATA		useData;
+	VO_HANDLE					hCodec;
+	VO_CODECBUFFER				inData;
+	VO_CODECBUFFER				outData;
+	VO_AUDIO_OUTPUTINFO			outInfo;
+    int							firstWrite = 1;
+	int							eofFile = 0;
+	int							*info=(int*)inBuf;
+	int							bytesLeft, nRead;
+	int							EncoderdFrame = 0;
+	int							total = 0;
+	int							isOutput = 1;
+	int							returnCode;
+	AACENC_PARAM				aacpara;
+	void						*handle;
+	void						*pfunc;
+	VOGETAUDIODECAPI			pGetAPI;
+	const char					*infileName = NULL;
+    const char					*outfileName = NULL;
+
+	returnCode = parsecmdline(argc,argv, &infileName, &outfileName, &aacpara);
+	if(returnCode)
+	{
+		printf("%s", HelpString);
+		return 0;
+	}
+
+	/* open input file */
+	infile = fopen(infileName, "rb");
+	if (!infile) {
+		printf("Open input file fail...");
+		return -1;
+	}
+
+	/* open output file */
+	if(isOutput)
+	{
+		outfile = fopen(outfileName, "wb");
+		if (!outfile) {
+			printf("Open output file fail...");
+			return -1;
+		}
+	}
+	// set memory operators;
+	moper.Alloc = cmnMemAlloc;
+	moper.Copy = cmnMemCopy;
+	moper.Free = cmnMemFree;
+	moper.Set = cmnMemSet;
+	moper.Check = cmnMemCheck;
+	useData.memflag = VO_IMF_USERMEMOPERATOR;
+	useData.memData = (VO_PTR)(&moper);
+	// open encoder dll;
+	handle = dlopen("/data/local/tmp/libvoAACEncv7.so", RTLD_NOW);
+	if(handle == 0)
+	{
+		printf("open dll error......");
+		return -1;
+	}
+	// Get API;
+	pfunc = dlsym(handle, "voGetAACEncAPI");
+	if(pfunc == 0)
+	{
+		printf("open function error......");
+		return -1;
+	}
+	pGetAPI = (VOGETAUDIODECAPI)pfunc;
+	returnCode  = pGetAPI(&AudioAPI);
+	if(returnCode)
+		return -1;
+
+
+//#######################################   Init Encoding Section   #########################################
+	returnCode = AudioAPI.Init(&hCodec, VO_AUDIO_CodingAAC, &useData);
+	if(returnCode < 0)
+	{
+		printf("#### VOI_Error2:fail to initialize the Encoderr###\n");
+		return -1;
+	}
+
+	returnCode = AudioAPI.SetParam(hCodec, VO_PID_AAC_ENCPARAM, &aacpara);
+
+	inData.Buffer = inBuf;
+	bytesLeft = ReadFile2Buf(infile,inData.Buffer,READ_SIZE);
+
+//#######################################    Encoding Section   #########################################
+
+	do {
+
+		inData.Length    = bytesLeft;
+		outData.Buffer   = outBuf;
+		outData.Length = 1024*8;
+
+		t1 = clock();
+
+		returnCode = AudioAPI.SetInputData(hCodec,&inData);
+
+		do {
+			outData.Buffer   = outBuf;
+			outData.Length = 1024*8;
+
+			returnCode = AudioAPI.GetOutputData(hCodec,&outData, &outInfo);
+
+			if(returnCode == 0)
+				EncoderdFrame++;
+			if(returnCode == VO_ERR_LICENSE_ERROR)
+				break;
+
+#if VO_AAC_E_OUTPUT
+			if (isOutput && returnCode == 0)
+			{
+				fwrite(outData.Buffer, 1, outData.Length, outfile);
+			}
+#endif
+		} while(returnCode != (VO_ERR_INPUT_BUFFER_SMALL));
+
+		if(returnCode == VO_ERR_LICENSE_ERROR)
+			break;
+
+		t2 = clock();
+		total += t2 - t1;
+
+		if (!eofFile) {
+			nRead = ReadFile2Buf(infile, inBuf,READ_SIZE);
+			bytesLeft = nRead;
+			inData.Buffer = inBuf;
+			if (feof(infile))
+				eofFile = 1;
+		}
+
+	} while (!eofFile && returnCode);
+
+
+//################################################  End Encoding Section  #######################################################
+	returnCode = AudioAPI.Uninit(hCodec);
+
+	fclose(infile);
+	if (outfile)
+    {
+        fclose(outfile);
+    }
+	dlclose(handle);
+	return 0;
+}
+
+
diff --git a/media/libstagefright/codecs/aacenc/SampleCode/Android.mk b/media/libstagefright/codecs/aacenc/SampleCode/Android.mk
index 52c9c07..9f168cb 100644
--- a/media/libstagefright/codecs/aacenc/SampleCode/Android.mk
+++ b/media/libstagefright/codecs/aacenc/SampleCode/Android.mk
@@ -2,15 +2,15 @@ LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := 	AAC_E_SAMPLES.c
-	
+
 LOCAL_SRC_FILES += 	\
-	../../../Common/cmnMemory.c 
+	../../../Common/cmnMemory.c
 
 LOCAL_MODULE := TestvoAACEnc
 
 LOCAL_ARM_MODE := arm
 
-LOCAL_STATIC_LIBRARIES := 
+LOCAL_STATIC_LIBRARIES :=
 
 LOCAL_SHARED_LIBRARIES := libvoAACEnc
 
@@ -20,5 +20,5 @@ LOCAL_C_INCLUDES := \
 	$(LOCAL_PATH)/../../../Include \
 
 LOCAL_CFLAGS := $(VO_CFLAGS)
-	
+
 include $(BUILD_EXECUTABLE)
diff --git a/media/libstagefright/codecs/aacenc/SampleCode/eclair/Makefile b/media/libstagefright/codecs/aacenc/SampleCode/eclair/Makefile
index 22c5dc1..c6ec42f 100644
--- a/media/libstagefright/codecs/aacenc/SampleCode/eclair/Makefile
+++ b/media/libstagefright/codecs/aacenc/SampleCode/eclair/Makefile
@@ -1,55 +1,55 @@
-#/*
-#** Copyright 2003-2010, VisualOn, Inc.
-#**
-#** Licensed under the Apache License, Version 2.0 (the "License");
-#** you may not use this file except in compliance with the License.
-#** You may obtain a copy of the License at
-#**
-#**     http://www.apache.org/licenses/LICENSE-2.0
-#**
-#** Unless required by applicable law or agreed to in writing, software
-#** distributed under the License is distributed on an "AS IS" BASIS,
-#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#** See the License for the specific language governing permissions and
-#** limitations under the License.
-#*/
-
-# target6
-# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
-VOTT:= v7
-
-
-# module type
-# please specify the type of your module: lib or exe
-VOMT:= exe
-
-
-# module macros
-# please append the additional macro definitions here for your module if necessary. 
-# e.g. -DVISUALON, macro VISUALON defined for your module 
-VOMM:= #ARMV5E
-
-
-
-# please specify the name of your module
-VOTARGET:= voAACEncTestv7
-
-
-# please modify here to be sure to see the g1.mk
-include ../../../../Tools/eclair.mk 
-
-# dependent libraries.
-VODEPLIBS:=-ldl
-
-# module source
-# please modify here to be sure to see the ms.mk which specifies all source info of your module
-include ../ms.mk
-
-
-# please specify where is the voRelease on your PC, relative path is suggested
-VORELDIR:=../../../../../Release/
-
-
-# please modify here to be sure to see the doit.mk
-include ../../../../Tools/doit.mk 
-
+#/*
+#** Copyright 2003-2010, VisualOn, Inc.
+#**
+#** Licensed under the Apache License, Version 2.0 (the "License");
+#** you may not use this file except in compliance with the License.
+#** You may obtain a copy of the License at
+#**
+#**     http://www.apache.org/licenses/LICENSE-2.0
+#**
+#** Unless required by applicable law or agreed to in writing, software
+#** distributed under the License is distributed on an "AS IS" BASIS,
+#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#** See the License for the specific language governing permissions and
+#** limitations under the License.
+#*/
+
+# target6
+# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
+VOTT:= v7
+
+
+# module type
+# please specify the type of your module: lib or exe
+VOMT:= exe
+
+
+# module macros
+# please append the additional macro definitions here for your module if necessary.
+# e.g. -DVISUALON, macro VISUALON defined for your module
+VOMM:= #ARMV5E
+
+
+
+# please specify the name of your module
+VOTARGET:= voAACEncTestv7
+
+
+# please modify here to be sure to see the g1.mk
+include ../../../../Tools/eclair.mk
+
+# dependent libraries.
+VODEPLIBS:=-ldl
+
+# module source
+# please modify here to be sure to see the ms.mk which specifies all source info of your module
+include ../ms.mk
+
+
+# please specify where is the voRelease on your PC, relative path is suggested
+VORELDIR:=../../../../../Release/
+
+
+# please modify here to be sure to see the doit.mk
+include ../../../../Tools/doit.mk
+
diff --git a/media/libstagefright/codecs/aacenc/SampleCode/ms.mk b/media/libstagefright/codecs/aacenc/SampleCode/ms.mk
index 771a569..b6255e8 100644
--- a/media/libstagefright/codecs/aacenc/SampleCode/ms.mk
+++ b/media/libstagefright/codecs/aacenc/SampleCode/ms.mk
@@ -1,23 +1,23 @@
-#/*
-#** Copyright 2003-2010, VisualOn, Inc.
-#**
-#** Licensed under the Apache License, Version 2.0 (the "License");
-#** you may not use this file except in compliance with the License.
-#** You may obtain a copy of the License at
-#**
-#**     http://www.apache.org/licenses/LICENSE-2.0
-#**
-#** Unless required by applicable law or agreed to in writing, software
-#** distributed under the License is distributed on an "AS IS" BASIS,
-#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#** See the License for the specific language governing permissions and
-#** limitations under the License.
-#*/
-
-# please list all objects needed by your target here
-OBJS:=AAC_E_SAMPLES.o	cmnMemory.o
-			
-# please list all directories that all source files relative with your module(.h .c .cpp) locate 
-VOSRCDIR:=../ ../../../../include  ../../../../Common
-					
-				
+#/*
+#** Copyright 2003-2010, VisualOn, Inc.
+#**
+#** Licensed under the Apache License, Version 2.0 (the "License");
+#** you may not use this file except in compliance with the License.
+#** You may obtain a copy of the License at
+#**
+#**     http://www.apache.org/licenses/LICENSE-2.0
+#**
+#** Unless required by applicable law or agreed to in writing, software
+#** distributed under the License is distributed on an "AS IS" BASIS,
+#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#** See the License for the specific language governing permissions and
+#** limitations under the License.
+#*/
+
+# please list all objects needed by your target here
+OBJS:=AAC_E_SAMPLES.o	cmnMemory.o
+
+# please list all directories that all source files relative with your module(.h .c .cpp) locate
+VOSRCDIR:=../ ../../../../include  ../../../../Common
+
+
diff --git a/media/libstagefright/codecs/aacenc/Tools/doit.mk b/media/libstagefright/codecs/aacenc/Tools/doit.mk
index dea0b0a..4924341 100644
--- a/media/libstagefright/codecs/aacenc/Tools/doit.mk
+++ b/media/libstagefright/codecs/aacenc/Tools/doit.mk
@@ -28,10 +28,10 @@ ifeq ($(VOMT), exe)
 TARGET=$(VOTARGET)
 endif
 
-CFLAGS=$(VOCFLAGS) $(addprefix -I, $(VOSRCDIR)) 
-CPPFLAGS=$(VOCPPFLAGS) $(addprefix -I, $(VOSRCDIR)) 
+CFLAGS=$(VOCFLAGS) $(addprefix -I, $(VOSRCDIR))
+CPPFLAGS=$(VOCPPFLAGS) $(addprefix -I, $(VOSRCDIR))
 ifneq ($(VOTT), pc)
-ASFLAGS=$(VOASFLAGS) $(addprefix -I, $(VOSRCDIR)) 
+ASFLAGS=$(VOASFLAGS) $(addprefix -I, $(VOSRCDIR))
 endif
 
 LDFLAGS:=$(VOLDFLAGS)
@@ -90,7 +90,7 @@ ifneq ($(VODBG), yes)
 endif
 
 $(LIB_DYNAMIC):$(OBJS)
-	$(GG) $(LDFLAGS) -o $@ $(OBJDIR)/*.o -Wl,--whole-archive $(VOSTCLIBS) -Wl,--no-whole-archive $(VOTLDEPS) 
+	$(GG) $(LDFLAGS) -o $@ $(OBJDIR)/*.o -Wl,--whole-archive $(VOSTCLIBS) -Wl,--no-whole-archive $(VOTLDEPS)
 ifneq ($(VODBG), yes)
 		$(STRIP) $@
 endif
diff --git a/media/libstagefright/codecs/aacenc/Tools/eclair.mk b/media/libstagefright/codecs/aacenc/Tools/eclair.mk
index 1688361..41dd9c1 100644
--- a/media/libstagefright/codecs/aacenc/Tools/eclair.mk
+++ b/media/libstagefright/codecs/aacenc/Tools/eclair.mk
@@ -14,10 +14,10 @@
 # ** limitations under the License.
 # */
 
-# special macro definitions for building 
-VOPREDEF=-DLINUX -D_LINUX 
+# special macro definitions for building
+VOPREDEF=-DLINUX -D_LINUX
 
-VOPRJ ?= 
+VOPRJ ?=
 VONJ ?= eclair
 VOTT ?= v6
 # control the version to release out
@@ -80,19 +80,19 @@ CCTINC:=-I$(TCROOTPATH)/system/core/include \
 	-I$(TCROOTPATH)/bionic/libthread_db/include \
 	-I$(TCROOTPATH)/bionic/libm/arm \
 	-I$(TCROOTPATH)/bionic/libm \
-	-I$(TCROOTPATH)/frameworks/base/include/android_runtime 
+	-I$(TCROOTPATH)/frameworks/base/include/android_runtime
 	#-I$(TCROOTPATH)/out/target/product/$(VOTP)/obj/SHARED_LIBRARIES/libm_intermediates
 
 CCTCFLAGS:=-msoft-float -mthumb-interwork -fno-exceptions -ffunction-sections -funwind-tables -fstack-protector -fno-short-enums -fmessage-length=0 -finline-functions -finline-limit=600 -fno-inline-functions-called-once -fgcse-after-reload -frerun-cse-after-loop -frename-registers -fstrict-aliasing -funswitch-loops
-#-fwide-exec-charset=charset=UTF-32 
+#-fwide-exec-charset=charset=UTF-32
 
 # for target exe
-TELDFLAGS:=-nostdlib -Bdynamic -Wl,-T,$(TCROOTPATH)/build/core/armelf.x -Wl,-dynamic-linker,/system/bin/linker -Wl,--gc-sections -Wl,-z,nocopyreloc -Wl,--no-undefined -Wl,-rpath-link=$(CCTLIB) -L$(CCTLIB) 
+TELDFLAGS:=-nostdlib -Bdynamic -Wl,-T,$(TCROOTPATH)/build/core/armelf.x -Wl,-dynamic-linker,/system/bin/linker -Wl,--gc-sections -Wl,-z,nocopyreloc -Wl,--no-undefined -Wl,-rpath-link=$(CCTLIB) -L$(CCTLIB)
 
 VOTEDEPS:=$(CCTLIB)/crtbegin_dynamic.o $(CCTLIB)/crtend_android.o $(TCPATH)/lib/gcc/arm-eabi/$(GCCVER)/interwork/libgcc.a -lc -lm
 
 # for target lib
-TLLDFLAGS:=-nostdlib -Wl,-T,$(TCROOTPATH)/build/core/armelf.xsc -Wl,--gc-sections -Wl,-shared,-Bsymbolic -L$(CCTLIB) -Wl,--no-whole-archive -Wl,--no-undefined $(TCPATH)/lib/gcc/arm-eabi/$(GCCVER)/interwork/libgcc.a 
+TLLDFLAGS:=-nostdlib -Wl,-T,$(TCROOTPATH)/build/core/armelf.xsc -Wl,--gc-sections -Wl,-shared,-Bsymbolic -L$(CCTLIB) -Wl,--no-whole-archive -Wl,--no-undefined $(TCPATH)/lib/gcc/arm-eabi/$(GCCVER)/interwork/libgcc.a
 
 VOTLDEPS:=-lm -lc
 
@@ -113,7 +113,7 @@ VOASFLAGS:=-march=armv5te -mfpu=vfp
 endif
 
 ifeq ($(VOTT), v6)
-#VOCFLAGS:=-march=armv6 -mtune=arm1136jf-s 
+#VOCFLAGS:=-march=armv6 -mtune=arm1136jf-s
 #VOASFLAGS:=-march=armv6
 VOCFLAGS:=-march=armv6j -mtune=arm1136jf-s -mfpu=vfp -mfloat-abi=softfp -mapcs -mtpcs-leaf-frame -mlong-calls
 VOASFLAGS:=-march=armv6j -mcpu=arm1136jf-s -mfpu=arm1136jf-s -mfloat-abi=softfp -mapcs-float -mapcs-reentrant
@@ -133,7 +133,7 @@ endif
 #global compiling options for ARM target
 ifneq ($(VOTT), pc)
 VOASFLAGS+=--strip-local-absolute -R
-endif 
+endif
 
 
 ifeq ($(VODBG), yes)
@@ -167,6 +167,6 @@ ifeq ($(VODBG), yes)
 #VOLDFLAGS:=
 endif
 
-# where to place object files 
+# where to place object files
 OBJDIR=obj
 
diff --git a/media/libstagefright/codecs/aacenc/basic_op/basic_op.h b/media/libstagefright/codecs/aacenc/basic_op/basic_op.h
index 5457f33..ef3c31b 100644
--- a/media/libstagefright/codecs/aacenc/basic_op/basic_op.h
+++ b/media/libstagefright/codecs/aacenc/basic_op/basic_op.h
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		basicop2.h
-
-	Content:	Constants , Globals and Basic arithmetic operators.
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		basicop2.h
+
+	Content:	Constants , Globals and Basic arithmetic operators.
+
 *******************************************************************************/
 
 #ifndef __BASIC_OP_H
-#define __BASIC_OP_H
+#define __BASIC_OP_H
 
 #include "typedef.h"
 
@@ -30,1137 +30,1137 @@
 
 #define MAX_16 (Word16)0x7fff
 #define MIN_16 (Word16)0x8000
-#define ABS(a)	((a) >= 0) ? (a) : (-(a))
-
-/* Short abs,           1   */
-#define abs_s(x)       ((Word16)(((x) != MIN_16) ? (((x) >= 0) ? (x) : (-(x))) : MAX_16))
-
-/* 16 bit var1 -> MSB,     2 */
-#define L_deposit_h(x) (((Word32)(x)) << 16)
-
-
-/* 16 bit var1 -> LSB,     2 */
-#define L_deposit_l(x) ((Word32)(x))
-
-
-/* Long abs,              3  */
-#define L_abs(x) (((x) != MIN_32) ? (((x) >= 0) ? (x) : (-(x))) : MAX_32)
-
-
-/* Short negate,        1   */
-#define negate(var1) ((Word16)(((var1) == MIN_16) ? MAX_16 : (-(var1))))
-
-
-/* Long negate,     2 */
-#define L_negate(L_var1) (((L_var1) == (MIN_32)) ? (MAX_32) : (-(L_var1)))
-
-
-#define MULHIGH(A,B) (int)(((Word64)(A)*(Word64)(B)) >> 32)
-#define fixmul(a, b) (int)((((Word64)(a)*(Word64)(b)) >> 32) << 1)
-
-
-#if  (SATRUATE_IS_INLINE)
-__inline Word16 saturate(Word32 L_var1);
-#else
-Word16 saturate(Word32 L_var1);
-#endif
-
-/* Short shift left,    1   */
-#if (SHL_IS_INLINE)
-__inline Word16 shl (Word16 var1, Word16 var2);
-#else
-Word16 shl (Word16 var1, Word16 var2);
-#endif
-
-/* Short shift right,   1   */
-#if (SHR_IS_INLINE)
-__inline Word16 shr (Word16 var1, Word16 var2);
-#else
-Word16 shr (Word16 var1, Word16 var2);
-#endif
-
-#if (L_MULT_IS_INLINE)
-__inline Word32 L_mult(Word16 var1, Word16 var2);
-#else
-Word32 L_mult(Word16 var1, Word16 var2);
-#endif
-
-/* Msu,  1  */
-#if (L_MSU_IS_INLINE)
-__inline Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);
-#else
-Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);
-#endif
-    
-/* Long sub,        2 */
-#if (L_SUB_IS_INLINE)
-__inline Word32 L_sub(Word32 L_var1, Word32 L_var2);
-#else
-Word32 L_sub(Word32 L_var1, Word32 L_var2);
-#endif
-
-/* Long shift left, 2 */
-#if (L_SHL_IS_INLINE)
-__inline Word32 L_shl (Word32 L_var1, Word16 var2);
-#else
-Word32 L_shl (Word32 L_var1, Word16 var2);
-#endif
-
-/* Long shift right, 2*/
-#if (L_SHR_IS_INLINE)
-__inline Word32 L_shr (Word32 L_var1, Word16 var2);
-#else
-Word32 L_shr (Word32 L_var1, Word16 var2);
-#endif
-
-/* Short add,           1   */
-#if (ADD_IS_INLINE)
-__inline Word16 add (Word16 var1, Word16 var2);
-#else
-Word16 add (Word16 var1, Word16 var2);
-#endif
-    
-/* Short sub,           1   */
-#if (SUB_IS_INLINE)
-__inline Word16 sub(Word16 var1, Word16 var2);
-#else
-Word16 sub(Word16 var1, Word16 var2);
-#endif
-
-/* Short division,       18  */
-#if (DIV_S_IS_INLINE)
-__inline Word16 div_s (Word16 var1, Word16 var2);
-#else
-Word16 div_s (Word16 var1, Word16 var2);
-#endif
-
-/* Short mult,          1   */
-#if (MULT_IS_INLINE)
-__inline Word16 mult (Word16 var1, Word16 var2);
-#else
-Word16 mult (Word16 var1, Word16 var2);
-#endif
-
-/* Short norm,           15  */
-#if (NORM_S_IS_INLINE)
-__inline Word16 norm_s (Word16 var1);
-#else
-Word16 norm_s (Word16 var1);
-#endif
-
-/* Long norm,            30  */
-#if (NORM_L_IS_INLINE)
-__inline Word16 norm_l (Word32 L_var1);
-#else
-Word16 norm_l (Word32 L_var1);
-#endif
-
-/* Round,               1   */
-#if (ROUND_IS_INLINE)
-__inline Word16 round16(Word32 L_var1);
-#else
-Word16 round16(Word32 L_var1);
-#endif
-
-/* Mac,  1  */
-#if (L_MAC_IS_INLINE)
-__inline Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);
-#else
-Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);
-#endif
-
-#if (L_ADD_IS_INLINE)
-__inline Word32 L_add (Word32 L_var1, Word32 L_var2);
-#else
-Word32 L_add (Word32 L_var1, Word32 L_var2);
-#endif
-
-/* Extract high,        1   */
-#if (EXTRACT_H_IS_INLINE)
-__inline Word16 extract_h (Word32 L_var1);
-#else
-Word16 extract_h (Word32 L_var1);
-#endif
-
-/* Extract low,         1   */
-#if (EXTRACT_L_IS_INLINE)
-__inline Word16 extract_l(Word32 L_var1);
-#else
-Word16 extract_l(Word32 L_var1);
-#endif
-
-/* Mult with round, 2 */
-#if (MULT_R_IS_INLINE)
-__inline Word16 mult_r(Word16 var1, Word16 var2);
-#else
-Word16 mult_r(Word16 var1, Word16 var2);
-#endif
-
-/* Shift right with round, 2           */
-#if (SHR_R_IS_INLINE)
-__inline Word16 shr_r (Word16 var1, Word16 var2);
-#else
-Word16 shr_r (Word16 var1, Word16 var2);
-#endif
-
-/* Mac with rounding,2 */
-#if (MAC_R_IS_INLINE)
-__inline Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2);
-#else
-Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2);
-#endif
-
-/* Msu with rounding,2 */
-#if (MSU_R_IS_INLINE)
-__inline Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2);
-#else
-Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2);
-#endif
-
-/* Long shift right with round,  3             */
-#if (L_SHR_R_IS_INLINE)
-__inline Word32 L_shr_r (Word32 L_var1, Word16 var2);
-#else
-Word32 L_shr_r (Word32 L_var1, Word16 var2);
-#endif
-
-#if ARMV4_INASM
-__inline Word32 ASM_L_shr(Word32 L_var1, Word16 var2)
-{
-	Word32 result; 
-	asm volatile( 
-		"MOV %[result], %[L_var1], ASR %[var2] \n" 
-		:[result]"=r"(result)
-		:[L_var1]"r"(L_var1), [var2]"r"(var2)
-		); 
-	return result;	
-}
- 
-__inline Word32 ASM_L_shl(Word32 L_var1, Word16 var2)
-{
-	Word32 result; 
-	asm volatile( 
-		"MOV	r2, %[L_var1] \n"
-		"MOV	r3, #0x7fffffff\n"
-		"MOV	%[result], %[L_var1], ASL %[var2] \n" 
-		"TEQ	r2, %[result], ASR %[var2]\n"
-		"EORNE  %[result],r3,r2,ASR#31\n"
-		:[result]"+r"(result)
-		:[L_var1]"r"(L_var1), [var2]"r"(var2)
-		:"r2", "r3"
-		); 
-	return result;	
-}
-
-__inline Word32 ASM_shr(Word32 L_var1, Word16 var2)
-{
-	Word32 result; 
-	asm volatile( 
-		"CMP	%[var2], #15\n"
-		"MOVGE  %[var2], #15\n"
-		"MOV	%[result], %[L_var1], ASR %[var2]\n"
-		:[result]"=r"(result)
-		:[L_var1]"r"(L_var1), [var2]"r"(var2) 
-		); 
-	return result;	
-} 
-
-__inline Word32 ASM_shl(Word32 L_var1, Word16 var2)
-{
-	Word32 result; 
-	asm volatile( 
-		"CMP	%[var2], #16\n"
-		"MOVGE  %[var2], #16\n"
-		"MOV    %[result], %[L_var1], ASL %[var2]\n"
-		"MOV    r3, #1\n"
-        "MOV    r2, %[result], ASR #15\n"
-        "RSB    r3,r3,r3,LSL #15 \n"
-        "TEQ    r2, %[result], ASR #31 \n"
-        "EORNE  %[result], r3, %[result],ASR #31"
-		:[result]"+r"(result)
-		:[L_var1]"r"(L_var1), [var2]"r"(var2)
-		:"r2", "r3"
-		); 
-	return result;	
-} 
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   definitions for inline basic arithmetic operators                       |
- |___________________________________________________________________________|
-*/
-#if (SATRUATE_IS_INLINE)
-__inline Word16 saturate(Word32 L_var1)
-{
-#if ARMV5TE_SAT
-	Word16 result;
-	asm volatile (
-		"MOV	%[result], %[L_var1]\n"
-		"MOV	r3, #1\n"
-		"MOV	r2,%[L_var1],ASR#15\n"
-		"RSB	r3, r3, r3, LSL #15\n"
-		"TEQ	r2,%[L_var1],ASR#31\n"	
-		"EORNE	%[result],r3,%[L_var1],ASR#31\n"
-		:[result]"+r"(result)
-		:[L_var1]"r"(L_var1)
-		:"r2", "r3"			
-	);
-
-	return result;
-#else
-    Word16 var_out;
-    
-    //var_out = (L_var1 > (Word32)0X00007fffL) ? (MAX_16) : ((L_var1 < (Word32)0xffff8000L) ? (MIN_16) : ((Word16)L_var1));
-
-    if (L_var1 > 0X00007fffL)
-    {
-        var_out = MAX_16;
-    }
-    else if (L_var1 < (Word32) 0xffff8000L)
-    {
-        var_out = MIN_16;
-    }
-    else
-    {
-        var_out = extract_l(L_var1);
-    }
-
-    return (var_out);
-#endif
-}
-#endif
-
-/* Short shift left,    1   */
-#if (SHL_IS_INLINE)
-__inline Word16 shl (Word16 var1, Word16 var2)
-{
-#if ARMV5TE_SHL
-	if(var2>=0)
-	{
-		return ASM_shl( var1, var2);
-	}
-	else
-	{
-		return ASM_shr( var1, -var2);
-	}
-#else
-    Word16 var_out;
-    Word32 result;
-
-    if (var2 < 0)
-    {
-        var_out = shr (var1, (Word16)-var2);
-    }
-    else
-    {
-        result = (Word32) var1 *((Word32) 1 << var2);
-
-        if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
-        {
-            var_out = (Word16)((var1 > 0) ? MAX_16 : MIN_16);
-        }
-        else
-        {
-            var_out = extract_l(result);
-        }
-    }
-    return (var_out);
-#endif
-}
-#endif
-
-/* Short shift right,   1   */
-#if (SHR_IS_INLINE)
-__inline Word16 shr (Word16 var1, Word16 var2)
-{
-#if ARMV5TE_SHR
-	if(var2>=0)
-	{
-		return  ASM_shr( var1, var2);
-	}
-	else
-	{
-		return  ASM_shl( var1, -var2);
-	}
-#else
-    Word16 var_out;
-
-    if (var2 < 0)
-    {
-        var_out = shl (var1, (Word16)-var2);
-    }
-    else
-    {
-        if (var2 >= 15)
-        {
-            var_out = (Word16)((var1 < 0) ? -1 : 0);
-        }
-        else
-        {
-            if (var1 < 0)
-            {
-                var_out = (Word16)(~((~var1) >> var2));
-            }
-            else
-            {
-                var_out = (Word16)(var1 >> var2);
-            }
-        }
-    }
-
-    return (var_out);
-#endif
-}
-#endif
-
-
-#if (L_MULT_IS_INLINE)
-__inline Word32 L_mult(Word16 var1, Word16 var2)
-{
-#if ARMV5TE_L_MULT
-	Word32 result; 
-	asm volatile( 
-		"SMULBB %[result], %[var1], %[var2] \n" 
-		"QADD %[result], %[result], %[result] \n" 
-		:[result]"+r"(result)
-		:[var1]"r"(var1), [var2]"r"(var2)
-		); 
-	return result;
-#else
-    Word32 L_var_out;
-
-    L_var_out = (Word32) var1 *(Word32) var2;
-
-    if (L_var_out != (Word32) 0x40000000L)
-    {
-        L_var_out <<= 1;
-    }
-    else
-    {
-        L_var_out = MAX_32;
-    }
-    return (L_var_out);
-#endif
-}
-#endif
-
-#if (L_MSU_IS_INLINE)
-__inline Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
-{
-#if ARMV5TE_L_MSU
-	Word32 result; 
-	asm volatile( 
-		"SMULBB %[result], %[var1], %[var2] \n" 
-		"QADD %[result], %[result], %[result] \n"
-		"QSUB %[result], %[L_var3], %[result]\n"
-		:[result]"+r"(result)
-		:[L_var3]"r"(L_var3), [var1]"r"(var1), [var2]"r"(var2)
-		); 
-	return result;
-#else
-    Word32 L_var_out;
-    Word32 L_product;
-
-    L_product = L_mult(var1, var2);
-    L_var_out = L_sub(L_var3, L_product);
-    return (L_var_out);
-#endif
-}
-#endif
-
-#if (L_SUB_IS_INLINE)
-__inline Word32 L_sub(Word32 L_var1, Word32 L_var2)
-{
-#if ARMV5TE_L_SUB
-	Word32 result; 
-	asm volatile( 
-		"QSUB %[result], %[L_var1], %[L_var2]\n"
-		:[result]"+r"(result)
-		:[L_var1]"r"(L_var1), [L_var2]"r"(L_var2)
-		); 
-	return result;
-#else
-    Word32 L_var_out;
-
-    L_var_out = L_var1 - L_var2;
-
-    if (((L_var1 ^ L_var2) & MIN_32) != 0)
-    {
-        if ((L_var_out ^ L_var1) & MIN_32)
-        {
-            L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
-        }
-    }
-
-    return (L_var_out);
-#endif
-}
-#endif
-
-#if (L_SHL_IS_INLINE)
-__inline Word32 L_shl(Word32 L_var1, Word16 var2)
-{
-#if ARMV5TE_L_SHL
-    if(var2>=0)
-    {
-        return  ASM_L_shl( L_var1, var2);
-    }
-    else
-    {
-        return  ASM_L_shr( L_var1, -var2);
-    }
-#else
-    Word32 L_var_out = 0L;
-
-    if (var2 <= 0)
-    {
-        L_var1 = L_shr(L_var1, (Word16)-var2);
-    }
-    else
-    {
-        for (; var2 > 0; var2--)
-        {
-            if (L_var1 > (Word32) 0X3fffffffL)
-            {
-                return MAX_32;
-            }
-            else
-            {
-                if (L_var1 < (Word32) 0xc0000000L)
-                {
-                    return MIN_32;
-                }
-            }
-            L_var1 <<= 1;
-            L_var_out = L_var1;
-        }
-    }
-    return (L_var1);
-#endif
-}
-#endif
-
-#if (L_SHR_IS_INLINE)
-__inline Word32 L_shr (Word32 L_var1, Word16 var2)
-{
-#if ARMV5TE_L_SHR
-	if(var2>=0)
-	{
-		return ASM_L_shr( L_var1, var2);
-	}
-	else
-	{
-		return ASM_L_shl( L_var1, -var2);
-	}
-#else
-    Word32 L_var_out;
-
-    if (var2 < 0)
-    {
-        L_var_out = L_shl (L_var1, (Word16)-var2);
-    }
-    else
-    {
-        if (var2 >= 31)
-        {
-            L_var_out = (L_var1 < 0L) ? -1 : 0;
-        }
-        else
-        {
-            if (L_var1 < 0)
-            {
-                L_var_out = ~((~L_var1) >> var2);
-            }
-            else
-            {
-                L_var_out = L_var1 >> var2;
-            }
-        }
-    }
-    return (L_var_out);
-#endif
-}
-#endif
-
-/* Short add,           1   */
-#if (ADD_IS_INLINE)
-__inline Word16 add (Word16 var1, Word16 var2)
-{
-#if ARMV5TE_ADD
-	Word32 result; 
-	asm volatile( 
-		"ADD  %[result], %[var1], %[var2] \n" 
-		"MOV  r3, #0x1\n"
-		"MOV  r2, %[result], ASR #15\n"
-		"RSB  r3, r3, r3, LSL, #15\n"
-		"TEQ  r2, %[result], ASR #31\n"
-		"EORNE %[result], r3, %[result], ASR #31"
-		:[result]"+r"(result)
-		:[var1]"r"(var1), [var2]"r"(var2)
-		:"r2", "r3"
-		); 
-	return result;
-#else
-    Word16 var_out;
-    Word32 L_sum;
-
-    L_sum = (Word32) var1 + var2;
-    var_out = saturate(L_sum);
-
-    return (var_out);
-#endif
-}
-#endif
-
-/* Short sub,           1   */
-#if (SUB_IS_INLINE)
-__inline Word16 sub(Word16 var1, Word16 var2)
-{
-#if ARMV5TE_SUB
-	Word32 result; 
-	asm volatile( 
-		"MOV   r3, #1\n"
-		"SUB   %[result], %[var1], %[var2] \n"		
-		"RSB   r3,r3,r3,LSL#15\n"
-		"MOV   r2, %[var1], ASR #15 \n" 
-		"TEQ   r2, %[var1], ASR #31 \n"
-		"EORNE %[result], r3, %[result], ASR #31 \n"
-		:[result]"+r"(result)
-		:[var1]"r"(var1), [var2]"r"(var2)
-		:"r2", "r3"
-		); 
-	return result;
-#else
-    Word16 var_out;
-    Word32 L_diff;
-
-    L_diff = (Word32) var1 - var2;
-    var_out = saturate(L_diff);
-   
-    return (var_out);
-#endif
-}
-#endif
-
-/* Short division,       18  */
-#if (DIV_S_IS_INLINE)
-__inline Word16 div_s (Word16 var1, Word16 var2)
-{
-    Word16 var_out = 0;
-    Word16 iteration;
-    Word32 L_num;
-    Word32 L_denom;
-
-    var_out = MAX_16;
-    if (var1!= var2)//var1!= var2
-    {
-    	var_out = 0;
-    	L_num = (Word32) var1;
-    
-    	L_denom = (Word32) var2;
-    	
-		//return (L_num<<15)/var2;
-
-    	for (iteration = 0; iteration < 15; iteration++)
-    	{
-    		var_out <<= 1;
-    		L_num <<= 1;
-    		
-    		if (L_num >= L_denom)
-    		{
-    			L_num -= L_denom;
-    			var_out++;
-    		}
-    	}
-    }
-    return (var_out);
-}
-#endif
-
-/* Short mult,          1   */
-#if (MULT_IS_INLINE)
-__inline Word16 mult (Word16 var1, Word16 var2)
-{
-#if ARMV5TE_MULT
-	Word32 result; 
-	asm volatile( 
-		"SMULBB r2, %[var1], %[var2] \n"
-		"MOV	r3, #1\n"
-		"MOV	%[result], r2, ASR #15\n"
-		"RSB	r3, r3, r3, LSL #15\n"
-		"MOV	r2, %[result], ASR #15\n"
-		"TEQ	r2, %[result], ASR #31\n"
-		"EORNE  %[result], r3, %[result], ASR #31 \n"
-		:[result]"+r"(result)
-		:[var1]"r"(var1), [var2]"r"(var2)
-		:"r2", "r3"
-		); 
-	return result;
-#else
-    Word16 var_out;
-    Word32 L_product;
-
-    L_product = (Word32) var1 *(Word32) var2;
-    L_product = (L_product & (Word32) 0xffff8000L) >> 15;
-    if (L_product & (Word32) 0x00010000L)
-        L_product = L_product | (Word32) 0xffff0000L;
-    var_out = saturate(L_product);
-
-    return (var_out);
-#endif
-}
-#endif
-
-
-/* Short norm,           15  */
-#if (NORM_S_IS_INLINE)
-__inline Word16 norm_s (Word16 var1)
-{
-#if ARMV5TE_NORM_S
-	Word16 result; 
-	asm volatile( 
-		"MOV   r2,%[var1] \n"
-		"CMP   r2, #0\n"
-		"RSBLT %[var1], %[var1], #0 \n"
-		"CLZNE %[result], %[var1]\n"
-		"SUBNE %[result], %[result], #17\n"
-		"MOVEQ %[result], #0\n"
-		"CMP   r2, #-1\n"
-		"MOVEQ %[result], #15\n" 
-		:[result]"+r"(result)
-		:[var1]"r"(var1)
-		:"r2"
-		); 
-	return result;
-#else
-    Word16 var_out;
-
-    if (var1 == 0)
-    {
-        var_out = 0;
-    }
-    else
-    {
-        if (var1 == -1)
-        {
-            var_out = 15;
-        }
-        else
-        {
-            if (var1 < 0)
-            {
-                var1 = (Word16)~var1;
-            }
-            for (var_out = 0; var1 < 0x4000; var_out++)
-            {
-                var1 <<= 1;
-            }
-        }
-    }
-    return (var_out);
-#endif
-}
-#endif
-
-/* Long norm,            30  */
-#if (NORM_L_IS_INLINE)
-__inline Word16 norm_l (Word32 L_var1)
-{
-#if ARMV5TE_NORM_L
-	Word16 result; 
-	asm volatile( 
-		"CMP    %[L_var1], #0\n"
-		"CLZNE  %[result], %[L_var1]\n"
-		"SUBNE  %[result], %[result], #1\n" 
-		"MOVEQ  %[result], #0\n"
-		:[result]"+r"(result)
-		:[L_var1]"r"(L_var1)
-		); 
-	return result;
-#else
-    //Word16 var_out;
-
-    //if (L_var1 == 0)
-    //{
-    //    var_out = 0;
-    //}
-    //else
-    //{
-    //    if (L_var1 == (Word32) 0xffffffffL)
-    //    {
-    //        var_out = 31;
-    //    }
-    //    else
-    //    {
-    //        if (L_var1 < 0)
-    //        {
-    //            L_var1 = ~L_var1;
-    //        }
-    //        for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)
-    //        {
-    //            L_var1 <<= 1;
-    //        }
-    //    }
-    //}
-    //return (var_out);
-  Word16 a16;
-  Word16 r = 0 ;       
-
-   
-  if ( L_var1 < 0 ) {
-    L_var1 = ~L_var1; 
-  }
-
-  if (0 == (L_var1 & 0x7fff8000)) {
-    a16 = extract_l(L_var1);
-    r += 16;
-       
-    if (0 == (a16 & 0x7f80)) {
-      r += 8;
-         
-      if (0 == (a16 & 0x0078)) {
-        r += 4;
-           
-        if (0 == (a16 & 0x0006)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x0001)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x0004)) {
-            r += 1;
-          }
-        }
-      }
-      else {
-           
-        if (0 == (a16 & 0x0060)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x0010)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x0040)) {
-            r += 1;
-          }
-        }
-      }
-    } 
-    else { 
-         
-      if (0 == (a16 & 0x7800)) {
-        r += 4;
-           
-        if (0 == (a16 & 0x0600)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x0100)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x0400)) {
-            r += 1;
-          }
-        }
-      }
-      else {
-           
-        if (0 == (a16 & 0x6000)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x1000)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x4000)) {
-            r += 1;
-          }
-        }
-      }
-    }
-  }
-  else {
-    a16 = extract_h(L_var1);
-       
-    if (0 == (a16 & 0x7f80)) {
-      r += 8;
-         
-      if (0 == (a16 & 0x0078)) {
-        r += 4 ;
-           
-        if (0 == (a16 & 0x0006)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x0001)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x0004)) {
-            r += 1;
-          }
-        }
-      }
-      else {
-           
-        if (0 == (a16 & 0x0060)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x0010)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x0040)) {
-            r += 1;
-          }
-        }
-      }
-    }
-    else {
-         
-      if (0 == (a16 & 0x7800)) {
-        r += 4;
-           
-        if (0 == (a16 & 0x0600)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x0100)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x0400)) {
-            r += 1;
-          }
-        }
-      }
-      else {
-           
-        if (0 == (a16 & 0x6000)) {
-          r += 2;
-             
-          if (0 == (a16 & 0x1000)) {
-            r += 1;
-          }
-        }
-        else {
-             
-          if (0 == (a16 & 0x4000)) {
-            return 1;
-          }
-        }
-      }
-    }
-  }
-  
-  return r ;
-#endif
-}
-#endif
-
-/* Round,               1   */
-#if (ROUND_IS_INLINE)
-__inline Word16 round16(Word32 L_var1)
-{
-#if ARMV5TE_ROUND
-	Word16 result; 
-	asm volatile( 
-		"MOV   r1,#0x00008000\n"
-		"QADD  %[result], %[L_var1], r1\n"
-		"MOV   %[result], %[result], ASR #16 \n" 
-		:[result]"+r"(result)
-		:[L_var1]"r"(L_var1)
-		:"r1"
-		); 
-	return result;
-#else   
-    Word16 var_out;
-    Word32 L_rounded;
-
-    L_rounded = L_add (L_var1, (Word32) 0x00008000L);
-    var_out = extract_h (L_rounded);
-    return (var_out);
-#endif
-}
-#endif
-
-/* Mac,  1  */
-#if (L_MAC_IS_INLINE)
-__inline Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
-{
-#if ARMV5TE_L_MAC
-	Word32 result; 
-	asm volatile( 
-		"SMULBB %[result], %[var1], %[var2]\n"
-		"QADD	%[result], %[result], %[result]\n"
-		"QADD   %[result], %[result], %[L_var3]\n"
-		:[result]"+r"(result)
-		: [L_var3]"r"(L_var3), [var1]"r"(var1), [var2]"r"(var2)
-		); 
-	return result;
-#else
-    Word32 L_var_out;
-    Word32 L_product;
-
-    L_product = L_mult(var1, var2);
-    L_var_out = L_add (L_var3, L_product);
-    return (L_var_out);
-#endif
-}
-#endif
-
-#if (L_ADD_IS_INLINE)
-__inline Word32 L_add (Word32 L_var1, Word32 L_var2)
-{
-#if ARMV5TE_L_ADD
-	Word32 result; 
-	asm volatile( 
-		"QADD %[result], %[L_var1], %[L_var2]\n"
-		:[result]"+r"(result)
-		:[L_var1]"r"(L_var1), [L_var2]"r"(L_var2)
-		); 
-	return result;
-#else
-    Word32 L_var_out;
-
-    L_var_out = L_var1 + L_var2;
-    if (((L_var1 ^ L_var2) & MIN_32) == 0)
-    {
-        if ((L_var_out ^ L_var1) & MIN_32)
-        {
-            L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
-        }
-    }
-    return (L_var_out);
-#endif
-}
-#endif
-
-
-
-#if (MULT_R_IS_INLINE)
-__inline Word16 mult_r (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-    Word32 L_product_arr;
-
-    L_product_arr = (Word32)var1 *(Word32)var2;       /* product */
-    L_product_arr += (Word32)0x00004000L;      /* round */
-    L_product_arr >>= 15;       /* shift */
-
-    var_out = saturate(L_product_arr);
-
-    return (var_out);
-}
-#endif
-
-#if (SHR_R_IS_INLINE)
-__inline Word16 shr_r (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-
-    if (var2 > 15)
-    {
-        var_out = 0;
-    }
-    else
-    {
-        var_out = shr(var1, var2);
-
-        if (var2 > 0)
-        {
-            if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
-            {
-                var_out++;
-            }
-        }
-    }
-
-    return (var_out);
-}
-#endif
-
-#if (MAC_R_IS_INLINE)
-__inline Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-
-    L_var3 = L_mac (L_var3, var1, var2);
-    var_out = (Word16)((L_var3 + 0x8000L) >> 16);
-
-    return (var_out);
-}
-#endif
-
-#if (MSU_R_IS_INLINE)
-__inline Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-
-    L_var3 = L_msu (L_var3, var1, var2);
-    var_out = (Word16)((L_var3 + 0x8000L) >> 16);
-    
-    return (var_out);
-}
-#endif
-
-#if (L_SHR_R_IS_INLINE)
-__inline Word32 L_shr_r (Word32 L_var1, Word16 var2)
-{
-    Word32 L_var_out;
-
-    if (var2 > 31)
-    {
-        L_var_out = 0;
-    }
-    else
-    {
-        L_var_out = L_shr(L_var1, var2);
-
-        if (var2 > 0)
-        {
-            if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)
-            {
-                L_var_out++;
-            }
-        }
-    }
-
-    return (L_var_out);
-}
-#endif
-
-#if (EXTRACT_H_IS_INLINE)
-__inline Word16 extract_h (Word32 L_var1)
-{
-    Word16 var_out;
-
-    var_out = (Word16) (L_var1 >> 16);
-
-    return (var_out);
-}
-#endif
-
-#if (EXTRACT_L_IS_INLINE)
-__inline Word16 extract_l(Word32 L_var1)
-{
-	return (Word16) L_var1;
-}
-#endif
-
+#define ABS(a)	((a) >= 0) ? (a) : (-(a))
+
+/* Short abs,           1   */
+#define abs_s(x)       ((Word16)(((x) != MIN_16) ? (((x) >= 0) ? (x) : (-(x))) : MAX_16))
+
+/* 16 bit var1 -> MSB,     2 */
+#define L_deposit_h(x) (((Word32)(x)) << 16)
+
+
+/* 16 bit var1 -> LSB,     2 */
+#define L_deposit_l(x) ((Word32)(x))
+
+
+/* Long abs,              3  */
+#define L_abs(x) (((x) != MIN_32) ? (((x) >= 0) ? (x) : (-(x))) : MAX_32)
+
+
+/* Short negate,        1   */
+#define negate(var1) ((Word16)(((var1) == MIN_16) ? MAX_16 : (-(var1))))
+
+
+/* Long negate,     2 */
+#define L_negate(L_var1) (((L_var1) == (MIN_32)) ? (MAX_32) : (-(L_var1)))
+
+
+#define MULHIGH(A,B) (int)(((Word64)(A)*(Word64)(B)) >> 32)
+#define fixmul(a, b) (int)((((Word64)(a)*(Word64)(b)) >> 32) << 1)
+
+
+#if  (SATRUATE_IS_INLINE)
+__inline Word16 saturate(Word32 L_var1);
+#else
+Word16 saturate(Word32 L_var1);
+#endif
+
+/* Short shift left,    1   */
+#if (SHL_IS_INLINE)
+__inline Word16 shl (Word16 var1, Word16 var2);
+#else
+Word16 shl (Word16 var1, Word16 var2);
+#endif
+
+/* Short shift right,   1   */
+#if (SHR_IS_INLINE)
+__inline Word16 shr (Word16 var1, Word16 var2);
+#else
+Word16 shr (Word16 var1, Word16 var2);
+#endif
+
+#if (L_MULT_IS_INLINE)
+__inline Word32 L_mult(Word16 var1, Word16 var2);
+#else
+Word32 L_mult(Word16 var1, Word16 var2);
+#endif
+
+/* Msu,  1  */
+#if (L_MSU_IS_INLINE)
+__inline Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);
+#else
+Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);
+#endif
+
+/* Long sub,        2 */
+#if (L_SUB_IS_INLINE)
+__inline Word32 L_sub(Word32 L_var1, Word32 L_var2);
+#else
+Word32 L_sub(Word32 L_var1, Word32 L_var2);
+#endif
+
+/* Long shift left, 2 */
+#if (L_SHL_IS_INLINE)
+__inline Word32 L_shl (Word32 L_var1, Word16 var2);
+#else
+Word32 L_shl (Word32 L_var1, Word16 var2);
+#endif
+
+/* Long shift right, 2*/
+#if (L_SHR_IS_INLINE)
+__inline Word32 L_shr (Word32 L_var1, Word16 var2);
+#else
+Word32 L_shr (Word32 L_var1, Word16 var2);
+#endif
+
+/* Short add,           1   */
+#if (ADD_IS_INLINE)
+__inline Word16 add (Word16 var1, Word16 var2);
+#else
+Word16 add (Word16 var1, Word16 var2);
+#endif
+
+/* Short sub,           1   */
+#if (SUB_IS_INLINE)
+__inline Word16 sub(Word16 var1, Word16 var2);
+#else
+Word16 sub(Word16 var1, Word16 var2);
+#endif
+
+/* Short division,       18  */
+#if (DIV_S_IS_INLINE)
+__inline Word16 div_s (Word16 var1, Word16 var2);
+#else
+Word16 div_s (Word16 var1, Word16 var2);
+#endif
+
+/* Short mult,          1   */
+#if (MULT_IS_INLINE)
+__inline Word16 mult (Word16 var1, Word16 var2);
+#else
+Word16 mult (Word16 var1, Word16 var2);
+#endif
+
+/* Short norm,           15  */
+#if (NORM_S_IS_INLINE)
+__inline Word16 norm_s (Word16 var1);
+#else
+Word16 norm_s (Word16 var1);
+#endif
+
+/* Long norm,            30  */
+#if (NORM_L_IS_INLINE)
+__inline Word16 norm_l (Word32 L_var1);
+#else
+Word16 norm_l (Word32 L_var1);
+#endif
+
+/* Round,               1   */
+#if (ROUND_IS_INLINE)
+__inline Word16 round16(Word32 L_var1);
+#else
+Word16 round16(Word32 L_var1);
+#endif
+
+/* Mac,  1  */
+#if (L_MAC_IS_INLINE)
+__inline Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);
+#else
+Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);
+#endif
+
+#if (L_ADD_IS_INLINE)
+__inline Word32 L_add (Word32 L_var1, Word32 L_var2);
+#else
+Word32 L_add (Word32 L_var1, Word32 L_var2);
+#endif
+
+/* Extract high,        1   */
+#if (EXTRACT_H_IS_INLINE)
+__inline Word16 extract_h (Word32 L_var1);
+#else
+Word16 extract_h (Word32 L_var1);
+#endif
+
+/* Extract low,         1   */
+#if (EXTRACT_L_IS_INLINE)
+__inline Word16 extract_l(Word32 L_var1);
+#else
+Word16 extract_l(Word32 L_var1);
+#endif
+
+/* Mult with round, 2 */
+#if (MULT_R_IS_INLINE)
+__inline Word16 mult_r(Word16 var1, Word16 var2);
+#else
+Word16 mult_r(Word16 var1, Word16 var2);
+#endif
+
+/* Shift right with round, 2           */
+#if (SHR_R_IS_INLINE)
+__inline Word16 shr_r (Word16 var1, Word16 var2);
+#else
+Word16 shr_r (Word16 var1, Word16 var2);
+#endif
+
+/* Mac with rounding,2 */
+#if (MAC_R_IS_INLINE)
+__inline Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2);
+#else
+Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2);
+#endif
+
+/* Msu with rounding,2 */
+#if (MSU_R_IS_INLINE)
+__inline Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2);
+#else
+Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2);
+#endif
+
+/* Long shift right with round,  3             */
+#if (L_SHR_R_IS_INLINE)
+__inline Word32 L_shr_r (Word32 L_var1, Word16 var2);
+#else
+Word32 L_shr_r (Word32 L_var1, Word16 var2);
+#endif
+
+#if ARMV4_INASM
+__inline Word32 ASM_L_shr(Word32 L_var1, Word16 var2)
+{
+	Word32 result;
+	asm volatile(
+		"MOV %[result], %[L_var1], ASR %[var2] \n"
+		:[result]"=r"(result)
+		:[L_var1]"r"(L_var1), [var2]"r"(var2)
+		);
+	return result;
+}
+
+__inline Word32 ASM_L_shl(Word32 L_var1, Word16 var2)
+{
+	Word32 result;
+	asm volatile(
+		"MOV	r2, %[L_var1] \n"
+		"MOV	r3, #0x7fffffff\n"
+		"MOV	%[result], %[L_var1], ASL %[var2] \n"
+		"TEQ	r2, %[result], ASR %[var2]\n"
+		"EORNE  %[result],r3,r2,ASR#31\n"
+		:[result]"+r"(result)
+		:[L_var1]"r"(L_var1), [var2]"r"(var2)
+		:"r2", "r3"
+		);
+	return result;
+}
+
+__inline Word32 ASM_shr(Word32 L_var1, Word16 var2)
+{
+	Word32 result;
+	asm volatile(
+		"CMP	%[var2], #15\n"
+		"MOVGE  %[var2], #15\n"
+		"MOV	%[result], %[L_var1], ASR %[var2]\n"
+		:[result]"=r"(result)
+		:[L_var1]"r"(L_var1), [var2]"r"(var2)
+		);
+	return result;
+}
+
+__inline Word32 ASM_shl(Word32 L_var1, Word16 var2)
+{
+	Word32 result;
+	asm volatile(
+		"CMP	%[var2], #16\n"
+		"MOVGE  %[var2], #16\n"
+		"MOV    %[result], %[L_var1], ASL %[var2]\n"
+		"MOV    r3, #1\n"
+        "MOV    r2, %[result], ASR #15\n"
+        "RSB    r3,r3,r3,LSL #15 \n"
+        "TEQ    r2, %[result], ASR #31 \n"
+        "EORNE  %[result], r3, %[result],ASR #31"
+		:[result]"+r"(result)
+		:[L_var1]"r"(L_var1), [var2]"r"(var2)
+		:"r2", "r3"
+		);
+	return result;
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   definitions for inline basic arithmetic operators                       |
+ |___________________________________________________________________________|
+*/
+#if (SATRUATE_IS_INLINE)
+__inline Word16 saturate(Word32 L_var1)
+{
+#if ARMV5TE_SAT
+	Word16 result;
+	asm volatile (
+		"MOV	%[result], %[L_var1]\n"
+		"MOV	r3, #1\n"
+		"MOV	r2,%[L_var1],ASR#15\n"
+		"RSB	r3, r3, r3, LSL #15\n"
+		"TEQ	r2,%[L_var1],ASR#31\n"
+		"EORNE	%[result],r3,%[L_var1],ASR#31\n"
+		:[result]"+r"(result)
+		:[L_var1]"r"(L_var1)
+		:"r2", "r3"
+	);
+
+	return result;
+#else
+    Word16 var_out;
+
+    //var_out = (L_var1 > (Word32)0X00007fffL) ? (MAX_16) : ((L_var1 < (Word32)0xffff8000L) ? (MIN_16) : ((Word16)L_var1));
+
+    if (L_var1 > 0X00007fffL)
+    {
+        var_out = MAX_16;
+    }
+    else if (L_var1 < (Word32) 0xffff8000L)
+    {
+        var_out = MIN_16;
+    }
+    else
+    {
+        var_out = extract_l(L_var1);
+    }
+
+    return (var_out);
+#endif
+}
+#endif
+
+/* Short shift left,    1   */
+#if (SHL_IS_INLINE)
+__inline Word16 shl (Word16 var1, Word16 var2)
+{
+#if ARMV5TE_SHL
+	if(var2>=0)
+	{
+		return ASM_shl( var1, var2);
+	}
+	else
+	{
+		return ASM_shr( var1, -var2);
+	}
+#else
+    Word16 var_out;
+    Word32 result;
+
+    if (var2 < 0)
+    {
+        var_out = shr (var1, (Word16)-var2);
+    }
+    else
+    {
+        result = (Word32) var1 *((Word32) 1 << var2);
+
+        if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
+        {
+            var_out = (Word16)((var1 > 0) ? MAX_16 : MIN_16);
+        }
+        else
+        {
+            var_out = extract_l(result);
+        }
+    }
+    return (var_out);
+#endif
+}
+#endif
+
+/* Short shift right,   1   */
+#if (SHR_IS_INLINE)
+__inline Word16 shr (Word16 var1, Word16 var2)
+{
+#if ARMV5TE_SHR
+	if(var2>=0)
+	{
+		return  ASM_shr( var1, var2);
+	}
+	else
+	{
+		return  ASM_shl( var1, -var2);
+	}
+#else
+    Word16 var_out;
+
+    if (var2 < 0)
+    {
+        var_out = shl (var1, (Word16)-var2);
+    }
+    else
+    {
+        if (var2 >= 15)
+        {
+            var_out = (Word16)((var1 < 0) ? -1 : 0);
+        }
+        else
+        {
+            if (var1 < 0)
+            {
+                var_out = (Word16)(~((~var1) >> var2));
+            }
+            else
+            {
+                var_out = (Word16)(var1 >> var2);
+            }
+        }
+    }
+
+    return (var_out);
+#endif
+}
+#endif
+
+
+#if (L_MULT_IS_INLINE)
+__inline Word32 L_mult(Word16 var1, Word16 var2)
+{
+#if ARMV5TE_L_MULT
+	Word32 result;
+	asm volatile(
+		"SMULBB %[result], %[var1], %[var2] \n"
+		"QADD %[result], %[result], %[result] \n"
+		:[result]"+r"(result)
+		:[var1]"r"(var1), [var2]"r"(var2)
+		);
+	return result;
+#else
+    Word32 L_var_out;
+
+    L_var_out = (Word32) var1 *(Word32) var2;
+
+    if (L_var_out != (Word32) 0x40000000L)
+    {
+        L_var_out <<= 1;
+    }
+    else
+    {
+        L_var_out = MAX_32;
+    }
+    return (L_var_out);
+#endif
+}
+#endif
+
+#if (L_MSU_IS_INLINE)
+__inline Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
+{
+#if ARMV5TE_L_MSU
+	Word32 result;
+	asm volatile(
+		"SMULBB %[result], %[var1], %[var2] \n"
+		"QADD %[result], %[result], %[result] \n"
+		"QSUB %[result], %[L_var3], %[result]\n"
+		:[result]"+r"(result)
+		:[L_var3]"r"(L_var3), [var1]"r"(var1), [var2]"r"(var2)
+		);
+	return result;
+#else
+    Word32 L_var_out;
+    Word32 L_product;
+
+    L_product = L_mult(var1, var2);
+    L_var_out = L_sub(L_var3, L_product);
+    return (L_var_out);
+#endif
+}
+#endif
+
+#if (L_SUB_IS_INLINE)
+__inline Word32 L_sub(Word32 L_var1, Word32 L_var2)
+{
+#if ARMV5TE_L_SUB
+	Word32 result;
+	asm volatile(
+		"QSUB %[result], %[L_var1], %[L_var2]\n"
+		:[result]"+r"(result)
+		:[L_var1]"r"(L_var1), [L_var2]"r"(L_var2)
+		);
+	return result;
+#else
+    Word32 L_var_out;
+
+    L_var_out = L_var1 - L_var2;
+
+    if (((L_var1 ^ L_var2) & MIN_32) != 0)
+    {
+        if ((L_var_out ^ L_var1) & MIN_32)
+        {
+            L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
+        }
+    }
+
+    return (L_var_out);
+#endif
+}
+#endif
+
+#if (L_SHL_IS_INLINE)
+__inline Word32 L_shl(Word32 L_var1, Word16 var2)
+{
+#if ARMV5TE_L_SHL
+    if(var2>=0)
+    {
+        return  ASM_L_shl( L_var1, var2);
+    }
+    else
+    {
+        return  ASM_L_shr( L_var1, -var2);
+    }
+#else
+    Word32 L_var_out = 0L;
+
+    if (var2 <= 0)
+    {
+        L_var1 = L_shr(L_var1, (Word16)-var2);
+    }
+    else
+    {
+        for (; var2 > 0; var2--)
+        {
+            if (L_var1 > (Word32) 0X3fffffffL)
+            {
+                return MAX_32;
+            }
+            else
+            {
+                if (L_var1 < (Word32) 0xc0000000L)
+                {
+                    return MIN_32;
+                }
+            }
+            L_var1 <<= 1;
+            L_var_out = L_var1;
+        }
+    }
+    return (L_var1);
+#endif
+}
+#endif
+
+#if (L_SHR_IS_INLINE)
+__inline Word32 L_shr (Word32 L_var1, Word16 var2)
+{
+#if ARMV5TE_L_SHR
+	if(var2>=0)
+	{
+		return ASM_L_shr( L_var1, var2);
+	}
+	else
+	{
+		return ASM_L_shl( L_var1, -var2);
+	}
+#else
+    Word32 L_var_out;
+
+    if (var2 < 0)
+    {
+        L_var_out = L_shl (L_var1, (Word16)-var2);
+    }
+    else
+    {
+        if (var2 >= 31)
+        {
+            L_var_out = (L_var1 < 0L) ? -1 : 0;
+        }
+        else
+        {
+            if (L_var1 < 0)
+            {
+                L_var_out = ~((~L_var1) >> var2);
+            }
+            else
+            {
+                L_var_out = L_var1 >> var2;
+            }
+        }
+    }
+    return (L_var_out);
+#endif
+}
+#endif
+
+/* Short add,           1   */
+#if (ADD_IS_INLINE)
+__inline Word16 add (Word16 var1, Word16 var2)
+{
+#if ARMV5TE_ADD
+	Word32 result;
+	asm volatile(
+		"ADD  %[result], %[var1], %[var2] \n"
+		"MOV  r3, #0x1\n"
+		"MOV  r2, %[result], ASR #15\n"
+		"RSB  r3, r3, r3, LSL, #15\n"
+		"TEQ  r2, %[result], ASR #31\n"
+		"EORNE %[result], r3, %[result], ASR #31"
+		:[result]"+r"(result)
+		:[var1]"r"(var1), [var2]"r"(var2)
+		:"r2", "r3"
+		);
+	return result;
+#else
+    Word16 var_out;
+    Word32 L_sum;
+
+    L_sum = (Word32) var1 + var2;
+    var_out = saturate(L_sum);
+
+    return (var_out);
+#endif
+}
+#endif
+
+/* Short sub,           1   */
+#if (SUB_IS_INLINE)
+__inline Word16 sub(Word16 var1, Word16 var2)
+{
+#if ARMV5TE_SUB
+	Word32 result;
+	asm volatile(
+		"MOV   r3, #1\n"
+		"SUB   %[result], %[var1], %[var2] \n"
+		"RSB   r3,r3,r3,LSL#15\n"
+		"MOV   r2, %[var1], ASR #15 \n"
+		"TEQ   r2, %[var1], ASR #31 \n"
+		"EORNE %[result], r3, %[result], ASR #31 \n"
+		:[result]"+r"(result)
+		:[var1]"r"(var1), [var2]"r"(var2)
+		:"r2", "r3"
+		);
+	return result;
+#else
+    Word16 var_out;
+    Word32 L_diff;
+
+    L_diff = (Word32) var1 - var2;
+    var_out = saturate(L_diff);
+
+    return (var_out);
+#endif
+}
+#endif
+
+/* Short division,       18  */
+#if (DIV_S_IS_INLINE)
+__inline Word16 div_s (Word16 var1, Word16 var2)
+{
+    Word16 var_out = 0;
+    Word16 iteration;
+    Word32 L_num;
+    Word32 L_denom;
+
+    var_out = MAX_16;
+    if (var1!= var2)//var1!= var2
+    {
+    	var_out = 0;
+    	L_num = (Word32) var1;
+
+    	L_denom = (Word32) var2;
+
+		//return (L_num<<15)/var2;
+
+    	for (iteration = 0; iteration < 15; iteration++)
+    	{
+    		var_out <<= 1;
+    		L_num <<= 1;
+
+    		if (L_num >= L_denom)
+    		{
+    			L_num -= L_denom;
+    			var_out++;
+    		}
+    	}
+    }
+    return (var_out);
+}
+#endif
+
+/* Short mult,          1   */
+#if (MULT_IS_INLINE)
+__inline Word16 mult (Word16 var1, Word16 var2)
+{
+#if ARMV5TE_MULT
+	Word32 result;
+	asm volatile(
+		"SMULBB r2, %[var1], %[var2] \n"
+		"MOV	r3, #1\n"
+		"MOV	%[result], r2, ASR #15\n"
+		"RSB	r3, r3, r3, LSL #15\n"
+		"MOV	r2, %[result], ASR #15\n"
+		"TEQ	r2, %[result], ASR #31\n"
+		"EORNE  %[result], r3, %[result], ASR #31 \n"
+		:[result]"+r"(result)
+		:[var1]"r"(var1), [var2]"r"(var2)
+		:"r2", "r3"
+		);
+	return result;
+#else
+    Word16 var_out;
+    Word32 L_product;
+
+    L_product = (Word32) var1 *(Word32) var2;
+    L_product = (L_product & (Word32) 0xffff8000L) >> 15;
+    if (L_product & (Word32) 0x00010000L)
+        L_product = L_product | (Word32) 0xffff0000L;
+    var_out = saturate(L_product);
+
+    return (var_out);
+#endif
+}
+#endif
+
+
+/* Short norm,           15  */
+#if (NORM_S_IS_INLINE)
+__inline Word16 norm_s (Word16 var1)
+{
+#if ARMV5TE_NORM_S
+	Word16 result;
+	asm volatile(
+		"MOV   r2,%[var1] \n"
+		"CMP   r2, #0\n"
+		"RSBLT %[var1], %[var1], #0 \n"
+		"CLZNE %[result], %[var1]\n"
+		"SUBNE %[result], %[result], #17\n"
+		"MOVEQ %[result], #0\n"
+		"CMP   r2, #-1\n"
+		"MOVEQ %[result], #15\n"
+		:[result]"+r"(result)
+		:[var1]"r"(var1)
+		:"r2"
+		);
+	return result;
+#else
+    Word16 var_out;
+
+    if (var1 == 0)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        if (var1 == -1)
+        {
+            var_out = 15;
+        }
+        else
+        {
+            if (var1 < 0)
+            {
+                var1 = (Word16)~var1;
+            }
+            for (var_out = 0; var1 < 0x4000; var_out++)
+            {
+                var1 <<= 1;
+            }
+        }
+    }
+    return (var_out);
+#endif
+}
+#endif
+
+/* Long norm,            30  */
+#if (NORM_L_IS_INLINE)
+__inline Word16 norm_l (Word32 L_var1)
+{
+#if ARMV5TE_NORM_L
+	Word16 result;
+	asm volatile(
+		"CMP    %[L_var1], #0\n"
+		"CLZNE  %[result], %[L_var1]\n"
+		"SUBNE  %[result], %[result], #1\n"
+		"MOVEQ  %[result], #0\n"
+		:[result]"+r"(result)
+		:[L_var1]"r"(L_var1)
+		);
+	return result;
+#else
+    //Word16 var_out;
+
+    //if (L_var1 == 0)
+    //{
+    //    var_out = 0;
+    //}
+    //else
+    //{
+    //    if (L_var1 == (Word32) 0xffffffffL)
+    //    {
+    //        var_out = 31;
+    //    }
+    //    else
+    //    {
+    //        if (L_var1 < 0)
+    //        {
+    //            L_var1 = ~L_var1;
+    //        }
+    //        for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)
+    //        {
+    //            L_var1 <<= 1;
+    //        }
+    //    }
+    //}
+    //return (var_out);
+  Word16 a16;
+  Word16 r = 0 ;
+
+
+  if ( L_var1 < 0 ) {
+    L_var1 = ~L_var1;
+  }
+
+  if (0 == (L_var1 & 0x7fff8000)) {
+    a16 = extract_l(L_var1);
+    r += 16;
+
+    if (0 == (a16 & 0x7f80)) {
+      r += 8;
+
+      if (0 == (a16 & 0x0078)) {
+        r += 4;
+
+        if (0 == (a16 & 0x0006)) {
+          r += 2;
+
+          if (0 == (a16 & 0x0001)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x0004)) {
+            r += 1;
+          }
+        }
+      }
+      else {
+
+        if (0 == (a16 & 0x0060)) {
+          r += 2;
+
+          if (0 == (a16 & 0x0010)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x0040)) {
+            r += 1;
+          }
+        }
+      }
+    }
+    else {
+
+      if (0 == (a16 & 0x7800)) {
+        r += 4;
+
+        if (0 == (a16 & 0x0600)) {
+          r += 2;
+
+          if (0 == (a16 & 0x0100)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x0400)) {
+            r += 1;
+          }
+        }
+      }
+      else {
+
+        if (0 == (a16 & 0x6000)) {
+          r += 2;
+
+          if (0 == (a16 & 0x1000)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x4000)) {
+            r += 1;
+          }
+        }
+      }
+    }
+  }
+  else {
+    a16 = extract_h(L_var1);
+
+    if (0 == (a16 & 0x7f80)) {
+      r += 8;
+
+      if (0 == (a16 & 0x0078)) {
+        r += 4 ;
+
+        if (0 == (a16 & 0x0006)) {
+          r += 2;
+
+          if (0 == (a16 & 0x0001)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x0004)) {
+            r += 1;
+          }
+        }
+      }
+      else {
+
+        if (0 == (a16 & 0x0060)) {
+          r += 2;
+
+          if (0 == (a16 & 0x0010)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x0040)) {
+            r += 1;
+          }
+        }
+      }
+    }
+    else {
+
+      if (0 == (a16 & 0x7800)) {
+        r += 4;
+
+        if (0 == (a16 & 0x0600)) {
+          r += 2;
+
+          if (0 == (a16 & 0x0100)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x0400)) {
+            r += 1;
+          }
+        }
+      }
+      else {
+
+        if (0 == (a16 & 0x6000)) {
+          r += 2;
+
+          if (0 == (a16 & 0x1000)) {
+            r += 1;
+          }
+        }
+        else {
+
+          if (0 == (a16 & 0x4000)) {
+            return 1;
+          }
+        }
+      }
+    }
+  }
+
+  return r ;
+#endif
+}
+#endif
+
+/* Round,               1   */
+#if (ROUND_IS_INLINE)
+__inline Word16 round16(Word32 L_var1)
+{
+#if ARMV5TE_ROUND
+	Word16 result;
+	asm volatile(
+		"MOV   r1,#0x00008000\n"
+		"QADD  %[result], %[L_var1], r1\n"
+		"MOV   %[result], %[result], ASR #16 \n"
+		:[result]"+r"(result)
+		:[L_var1]"r"(L_var1)
+		:"r1"
+		);
+	return result;
+#else
+    Word16 var_out;
+    Word32 L_rounded;
+
+    L_rounded = L_add (L_var1, (Word32) 0x00008000L);
+    var_out = extract_h (L_rounded);
+    return (var_out);
+#endif
+}
+#endif
+
+/* Mac,  1  */
+#if (L_MAC_IS_INLINE)
+__inline Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
+{
+#if ARMV5TE_L_MAC
+	Word32 result;
+	asm volatile(
+		"SMULBB %[result], %[var1], %[var2]\n"
+		"QADD	%[result], %[result], %[result]\n"
+		"QADD   %[result], %[result], %[L_var3]\n"
+		:[result]"+r"(result)
+		: [L_var3]"r"(L_var3), [var1]"r"(var1), [var2]"r"(var2)
+		);
+	return result;
+#else
+    Word32 L_var_out;
+    Word32 L_product;
+
+    L_product = L_mult(var1, var2);
+    L_var_out = L_add (L_var3, L_product);
+    return (L_var_out);
+#endif
+}
+#endif
+
+#if (L_ADD_IS_INLINE)
+__inline Word32 L_add (Word32 L_var1, Word32 L_var2)
+{
+#if ARMV5TE_L_ADD
+	Word32 result;
+	asm volatile(
+		"QADD %[result], %[L_var1], %[L_var2]\n"
+		:[result]"+r"(result)
+		:[L_var1]"r"(L_var1), [L_var2]"r"(L_var2)
+		);
+	return result;
+#else
+    Word32 L_var_out;
+
+    L_var_out = L_var1 + L_var2;
+    if (((L_var1 ^ L_var2) & MIN_32) == 0)
+    {
+        if ((L_var_out ^ L_var1) & MIN_32)
+        {
+            L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
+        }
+    }
+    return (L_var_out);
+#endif
+}
+#endif
+
+
+
+#if (MULT_R_IS_INLINE)
+__inline Word16 mult_r (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_product_arr;
+
+    L_product_arr = (Word32)var1 *(Word32)var2;       /* product */
+    L_product_arr += (Word32)0x00004000L;      /* round */
+    L_product_arr >>= 15;       /* shift */
+
+    var_out = saturate(L_product_arr);
+
+    return (var_out);
+}
+#endif
+
+#if (SHR_R_IS_INLINE)
+__inline Word16 shr_r (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    if (var2 > 15)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        var_out = shr(var1, var2);
+
+        if (var2 > 0)
+        {
+            if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
+            {
+                var_out++;
+            }
+        }
+    }
+
+    return (var_out);
+}
+#endif
+
+#if (MAC_R_IS_INLINE)
+__inline Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    L_var3 = L_mac (L_var3, var1, var2);
+    var_out = (Word16)((L_var3 + 0x8000L) >> 16);
+
+    return (var_out);
+}
+#endif
+
+#if (MSU_R_IS_INLINE)
+__inline Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    L_var3 = L_msu (L_var3, var1, var2);
+    var_out = (Word16)((L_var3 + 0x8000L) >> 16);
+
+    return (var_out);
+}
+#endif
+
+#if (L_SHR_R_IS_INLINE)
+__inline Word32 L_shr_r (Word32 L_var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    if (var2 > 31)
+    {
+        L_var_out = 0;
+    }
+    else
+    {
+        L_var_out = L_shr(L_var1, var2);
+
+        if (var2 > 0)
+        {
+            if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)
+            {
+                L_var_out++;
+            }
+        }
+    }
+
+    return (L_var_out);
+}
+#endif
+
+#if (EXTRACT_H_IS_INLINE)
+__inline Word16 extract_h (Word32 L_var1)
+{
+    Word16 var_out;
+
+    var_out = (Word16) (L_var1 >> 16);
+
+    return (var_out);
+}
+#endif
+
+#if (EXTRACT_L_IS_INLINE)
+__inline Word16 extract_l(Word32 L_var1)
+{
+	return (Word16) L_var1;
+}
+#endif
+
 #endif
diff --git a/media/libstagefright/codecs/aacenc/basic_op/basicop2.c b/media/libstagefright/codecs/aacenc/basic_op/basicop2.c
index a0d5dba..d43bbd9 100644
--- a/media/libstagefright/codecs/aacenc/basic_op/basicop2.c
+++ b/media/libstagefright/codecs/aacenc/basic_op/basicop2.c
@@ -1,1624 +1,1624 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		basicop2.c
-
-	Content:	Basic arithmetic operators. 
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		basicop2.c
+
+	Content:	Basic arithmetic operators.
+
 *******************************************************************************/
 
 #include "typedef.h"
-#include "basic_op.h"
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Functions                                                               |
- |___________________________________________________________________________|
-*/
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : saturate                                                |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |    Limit the 32 bit input to the range of a 16 bit word.                  |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1                                                                 |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-
-#if (!SATRUATE_IS_INLINE)
-Word16 saturate(Word32 L_var1)
-{
-    Word16 var_out;
-
-    if (L_var1 > 0X00007fffL)
-    {
-        var_out = MAX_16;
-    }
-    else if (L_var1 < (Word32) 0xffff8000L)
-    {
-        var_out = MIN_16;
-    }
-    else
-    {
-        var_out = extract_l(L_var1);
-    }
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : add                                                     |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |    Performs the addition (var1+var2) with overflow control and saturation;|
- |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
- |    when underflow occurs.                                                 |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-
-#if (!ADD_IS_INLINE)
-Word16 add (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-    Word32 L_sum;
-
-    L_sum = (Word32)var1 + (Word32)var2;
-    var_out = saturate(L_sum);
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : sub                                                     |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |    Performs the subtraction (var1+var2) with overflow control and satu-   |
- |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
- |    -32768 when underflow occurs.                                          |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-#if (!SUB_IS_INLINE)
-Word16 sub(Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-    Word32 L_diff;
-
-    L_diff = (Word32) var1 - var2;
-    var_out = saturate(L_diff);
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : abs_s                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |    Absolute value of var1; abs_s(-32768) = 32767.                         |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-//Word16 abs_s (Word16 var1)
-//{
-//    Word16 var_out;
-//
-//    if (var1 == MIN_16)
-//    {
-//        var_out = MAX_16;
-//    }
-//    else
-//    {
-//        if (var1 < 0)
-//        {
-//            var_out = (Word16)-var1;
-//        }
-//        else
-//        {
-//            var_out = var1;
-//        }
-//    }
-//
-//    return (var_out);
-//}
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : shl                                                     |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
- |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
- |   var1 right by -var2 with sign extension. Saturate the result in case of |
- |   underflows or overflows.                                                |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-
-#if (!SHL_IS_INLINE)
-Word16 shl (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-    Word32 result;
-
-    if (var2 < 0)
-    {
-        if (var2 < -16)
-            var2 = -16;
-        var_out = shr (var1, (Word16)-var2);
-    }
-    else
-    {
-        result = (Word32) var1 *((Word32) 1 << var2);
-
-        if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
-        {
-            //Overflow = 1;
-            var_out = (Word16)((var1 > 0) ? MAX_16 : MIN_16);
-        }
-        else
-        {
-            var_out = extract_l(result);
-        }
-    }
-
-    return (var_out);
-}
-#endif
-// end
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : shr                                                     |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
- |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
- |   -var2 with sign extension. Saturate the result in case of underflows or |
- |   overflows.                                                              |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-
-#if (!SHR_IS_INLINE)
-Word16 shr (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-
-    if (var2 < 0)
-    {
-        if (var2 < -16)
-            var2 = -16;
-        var_out = shl (var1, (Word16)-var2);
-    }
-    else
-    {
-        if (var2 >= 15)
-        {
-            var_out = (Word16)((var1 < 0) ? -1 : 0);
-        }
-        else
-        {
-            if (var1 < 0)
-            {
-                var_out = (Word16)(~((~var1) >> var2));
-            }
-            else
-            {
-                var_out = (Word16)(var1 >> var2);
-            }
-        }
-    }
-
-    return (var_out);
-}
-#endif
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : mult                                                    |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
- |    which is scaled i.e.:                                                  |
- |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
- |             mult(-32768,-32768) = 32767.                                  |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-#if (!MULT_IS_INLINE)
-Word16 mult (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-    Word32 L_product;
-
-    L_product = (Word32) var1 *(Word32) var2;
-
-    L_product = (L_product & (Word32) 0xffff8000L) >> 15;
-
-    if (L_product & (Word32) 0x00010000L)
-        L_product = L_product | (Word32) 0xffff0000L;
-
-    var_out = saturate(L_product);
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_mult                                                  |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
- |   with one shift left i.e.:                                               |
- |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                 |
- |        L_mult(-32768,-32768) = 2147483647.                                |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-
-#if (!L_MULT_IS_INLINE)
-Word32 L_mult(Word16 var1, Word16 var2)
-{
-    Word32 L_var_out;
-
-    L_var_out = (Word32) var1 *(Word32) var2;
-
-    if (L_var_out != (Word32) 0x40000000L)
-    {
-        L_var_out <<= 1;
-    }
-    else
-    {
-        L_var_out = MAX_32;
-    }
-        
-    return (L_var_out);
-}
-#endif
-// end
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : negate                                                  |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Negate var1 with saturation, saturate in the case where input is -32768:|
- |                negate(var1) = sub(0,var1).                                |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-//Word16 negate (Word16 var1)
-//{
-//    Word16 var_out;
-//
-//    var_out = (Word16)((var1 == MIN_16) ? MAX_16 : -var1);
-//
-//    return (var_out);
-//}
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : extract_h                                               |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Return the 16 MSB of L_var1.                                            |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1                                                                 |
- |             32 bit long signed integer (Word32 ) whose value falls in the |
- |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-#if (!EXTRACT_H_IS_INLINE)
-Word16 extract_h (Word32 L_var1)
-{
-    Word16 var_out;
-
-    var_out = (Word16) (L_var1 >> 16);
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : extract_l                                               |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Return the 16 LSB of L_var1.                                            |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1                                                                 |
- |             32 bit long signed integer (Word32 ) whose value falls in the |
- |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-#if (!EXTRACT_L_IS_INLINE)
-Word16 extract_l(Word32 L_var1)
-{
-    Word16 var_out;
-
-    var_out = (Word16) L_var1;
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : round                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
- |   with saturation. Shift the resulting bits right by 16 and return the 16 |
- |   bit number:                                                             |
- |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1                                                                 |
- |             32 bit long signed integer (Word32 ) whose value falls in the |
- |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-
-#if (!ROUND_IS_INLINE)
-Word16 round16(Word32 L_var1)
-{
-    Word16 var_out;
-    Word32 L_rounded;
-
-    L_rounded = L_add (L_var1, (Word32) 0x00008000L);
-    var_out = extract_h (L_rounded);
-
-    return (var_out);
-}
-#endif
-// end
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_mac                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
- |   result to L_var3 with saturation, return a 32 bit result:               |
- |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-#if (!L_MSU_IS_INLINE)
-Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
-{
-    Word32 L_var_out;
-    Word32 L_product;
-
-    L_product = L_mult(var1, var2);
-    L_var_out = L_add (L_var3, L_product);
-
-    return (L_var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_msu                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
- |   bit result to L_var3 with saturation, return a 32 bit result:           |
- |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
- |                                                                           |
- |   Complexity weight : 1                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-
-#if (!L_MSU_IS_INLINE)
-Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
-{
-    Word32 L_var_out;
-    Word32 L_product;
-
-    L_product = L_mult(var1, var2);
-    L_var_out = L_sub (L_var3, L_product);
-
-    return (L_var_out);
-}
-#endif
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_add                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
- |   overflow control and saturation; the result is set at +2147483647 when  |
- |   overflow occurs or at -2147483648 when underflow occurs.                |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-#if (!L_ADD_IS_INLINE)
-Word32 L_add (Word32 L_var1, Word32 L_var2)
-{
-    Word32 L_var_out;
-
-    L_var_out = L_var1 + L_var2;
-
-    if (((L_var1 ^ L_var2) & MIN_32) == 0)
-    {
-        if ((L_var_out ^ L_var1) & MIN_32)
-        {
-            L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
-            //Overflow = 1;
-        }
-    }
-
-    return (L_var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_sub                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
- |   overflow control and saturation; the result is set at +2147483647 when  |
- |   overflow occurs or at -2147483648 when underflow occurs.                |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-#if (!L_SUB_IS_INLINE)
-Word32 L_sub(Word32 L_var1, Word32 L_var2)
-{
-    Word32 L_var_out;
-
-    L_var_out = L_var1 - L_var2;
-
-    if (((L_var1 ^ L_var2) & MIN_32) != 0)
-    {
-        if ((L_var_out ^ L_var1) & MIN_32)
-        {
-            L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
-            //Overflow = 1;
-        }
-    }
-
-    return (L_var_out);
-}
-#endif
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_negate                                                |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
- |   where input is -2147483648 (0x8000 0000).                               |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-//Word32 L_negate (Word32 L_var1)
-//{
-//    Word32 L_var_out;
-//
-//    L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
-//
-//    return (L_var_out);
-//}
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : mult_r                                                  |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Same as mult with rounding, i.e.:                                       |
- |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
- |     mult_r(-32768,-32768) = 32767.                                        |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-#if (!MULT_R_IS_INLINE)
-Word16 mult_r (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-    Word32 L_product_arr;
-
-    L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
-    L_product_arr += (Word32) 0x00004000L;      /* round */
-    L_product_arr &= (Word32) 0xffff8000L;
-    L_product_arr >>= 15;       /* shift */
-
-    if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
-    {
-        L_product_arr |= (Word32) 0xffff0000L;
-    }
-    var_out = saturate(L_product_arr);
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_shl                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
- |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
- |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
- |   case of underflows or overflows.                                        |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-
-#if (!L_SHL_IS_INLINE)
-Word32 L_shl (Word32 L_var1, Word16 var2)
-{
-    Word32 L_var_out = 0L;
-
-    if (var2 <= 0)
-    {
-        L_var1 = L_shr(L_var1, (Word16)-var2);
-    }
-    else
-    {
-        for (; var2 > 0; var2--)
-        {
-            if (L_var1 > (Word32) 0X3fffffffL)
-            {
-                return MAX_32;
-            }
-            else
-            {
-                if (L_var1 < (Word32) 0xc0000000L)
-                {
-                    return MIN_32;
-                }
-            }
-            L_var1 <<= 1;
-        }
-    }
-    return (L_var1);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_shr                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
- |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
- |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
- |   in case of underflows or overflows.                                     |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
- |___________________________________________________________________________|
-*/
-
-#if (!L_SHR_IS_INLINE)
-Word32 L_shr (Word32 L_var1, Word16 var2)
-{
-    Word32 L_var_out;
-
-    if (var2 < 0)
-    {
-        L_var_out = L_shl (L_var1, (Word16)-var2);
-    }
-    else
-    {
-        if (var2 >= 31)
-        {
-            L_var_out = (L_var1 < 0L) ? -1 : 0;
-        }
-        else
-        {
-            if (L_var1 < 0)
-            {
-                L_var_out = ~((~L_var1) >> var2);
-            }
-            else
-            {
-                L_var_out = L_var1 >> var2;
-            }
-        }
-    }
-    return (L_var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : shr_r                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
- |   underflows or overflows :                                               |
- |    - If var2 is greater than zero :                                       |
- |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
- |          is equal to zero                                                 |
- |                     then                                                  |
- |                     shr_r(var1,var2) = shr(var1,var2)                     |
- |                     else                                                  |
- |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
- |    - If var2 is less than or equal to zero :                              |
- |                     shr_r(var1,var2) = shr(var1,var2).                    |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-#if (!SHR_R_IS_INLINE)
-Word16 shr_r (Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-
-    if (var2 > 15)
-    {
-        var_out = 0;
-    }
-    else
-    {
-        var_out = shr (var1, var2);
-
-        if (var2 > 0)
-        {
-            if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
-            {
-                var_out++;
-            }
-        }
-    }
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : mac_r                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
- |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
- |   into the MS 16 bits with saturation and shift the result right by 16.   |
- |   Return a 16 bit result.                                                 |
- |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
- |___________________________________________________________________________|
-*/
-#if (!MAC_R_IS_INLINE)
-Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-
-    L_var3 = L_mac (L_var3, var1, var2);
-    L_var3 = L_add (L_var3, (Word32) 0x00008000L);
-    var_out = extract_h (L_var3);
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : msu_r                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
- |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
- |   ult into the MS 16 bits with saturation and shift the result right by   |
- |   16. Return a 16 bit result.                                             |
- |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
- |___________________________________________________________________________|
-*/
-#if (!MSU_R_IS_INLINE)
-Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
-{
-    Word16 var_out;
-
-    L_var3 = L_msu (L_var3, var1, var2);
-    L_var3 = L_add (L_var3, (Word32) 0x00008000L);
-    var_out = extract_h (L_var3);
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_deposit_h                                             |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
- |   16 LS bits of the output are zeroed.                                    |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
- |___________________________________________________________________________|
-*/
-//Word32 L_deposit_h (Word16 var1)
-//{
-//    Word32 L_var_out;
-//
-//    L_var_out = (Word32) var1 << 16;
-//
-//    return (L_var_out);
-//}
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_deposit_l                                             |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
- |   16 MS bits of the output are sign extended.                             |
- |                                                                           |
- |   Complexity weight : 2                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
- |___________________________________________________________________________|
-*/
-//Word32 L_deposit_l (Word16 var1)
-//{
-//    Word32 L_var_out;
-//
-//    L_var_out = (Word32) var1;
-//
-//    return (L_var_out);
-//}
-
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_shr_r                                                 |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
- |   case of underflows or overflows :                                       |
- |    - If var2 is greater than zero :                                       |
- |          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
- |          is equal to zero                                                 |
- |                     then                                                  |
- |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
- |                     else                                                  |
- |                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
- |    - If var2 is less than or equal to zero :                              |
- |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
- |                                                                           |
- |   Complexity weight : 3                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1                                                                 |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
- |___________________________________________________________________________|
-*/
-#if (!L_SHR_R_IS_INLINE)
-Word32 L_shr_r (Word32 L_var1, Word16 var2)
-{
-    Word32 L_var_out;
-
-    if (var2 > 31)
-    {
-        L_var_out = 0;
-    }
-    else
-    {
-        L_var_out = L_shr (L_var1, var2);
-
-        if (var2 > 0)
-        {
-            if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)
-            {
-                L_var_out++;
-            }
-        }
-    }
-
-    return (L_var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : L_abs                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |    Absolute value of L_var1; Saturate in case where the input is          |
- |                                                               -214783648  |
- |                                                                           |
- |   Complexity weight : 3                                                   |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1                                                                 |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    L_var_out                                                              |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x0000 0000 <= var_out <= 0x7fff ffff.                |
- |___________________________________________________________________________|
-*/
-//Word32 L_abs (Word32 L_var1)
-//{
-//    Word32 L_var_out;
-//
-//    if (L_var1 == MIN_32)
-//    {
-//        L_var_out = MAX_32;
-//    }
-//    else
-//    {
-//        if (L_var1 < 0)
-//        {
-//            L_var_out = -L_var1;
-//        }
-//        else
-//        {
-//            L_var_out = L_var1;
-//        }
-//    }
-//
-//    return (L_var_out);
-//}
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : norm_s                                                  |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Produces the number of left shift needed to normalize the 16 bit varia- |
- |   ble var1 for positive values on the interval with minimum of 16384 and  |
- |   maximum of 32767, and for negative values on the interval with minimum  |
- |   of -32768 and maximum of -16384; in order to normalize the result, the  |
- |   following operation must be done :                                      |
- |                    norm_var1 = shl(var1,norm_s(var1)).                    |
- |                                                                           |
- |   Complexity weight : 15                                                  |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0x0000 0000 <= var_out <= 0x0000 000f.                |
- |___________________________________________________________________________|
-*/
-
-#if (!NORM_S_IS_INLINE)
-Word16 norm_s (Word16 var1)
-{
-    Word16 var_out;
-
-    if (var1 == 0)
-    {
-        var_out = 0;
-    }
-    else
-    {
-        if (var1 == -1)
-        {
-            var_out = 15;
-        }
-        else
-        {
-            if (var1 < 0)
-            {
-                var1 = (Word16)~var1;
-            }
-            for (var_out = 0; var1 < 0x4000; var_out++)
-            {
-                var1 <<= 1;
-            }
-        }
-    }
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : div_s                                                   |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Produces a result which is the fractional integer division of var1  by  |
- |   var2; var1 and var2 must be positive and var2 must be greater or equal  |
- |   to var1; the result is positive (leading bit equal to 0) and truncated  |
- |   to 16 bits.                                                             |
- |   If var1 = var2 then div(var1,var2) = 32767.                             |
- |                                                                           |
- |   Complexity weight : 18                                                  |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    var1                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0x0000 0000 <= var1 <= var2 and var2 != 0.            |
- |                                                                           |
- |    var2                                                                   |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : var1 <= var2 <= 0x0000 7fff and var2 != 0.            |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
- |             It's a Q15 value (point between b15 and b14).                 |
- |___________________________________________________________________________|
-*/
-
-#if (!DIV_S_IS_INLINE)
-Word16 div_s (Word16 var1, Word16 var2)
-{
-    Word16 var_out = 0;
-    Word16 iteration;
-    Word32 L_num;
-    Word32 L_denom;
-
-    if (var1 == 0)
-    {
-        var_out = 0;
-    }
-    else
-    {
-        if (var1 == var2)
-        {
-            var_out = MAX_16;
-        }
-        else
-        {
-            L_num = L_deposit_l (var1);
-            L_denom = L_deposit_l (var2);
-
-            for (iteration = 0; iteration < 15; iteration++)
-            {
-                var_out <<= 1;
-                L_num <<= 1;
-
-                if (L_num >= L_denom)
-                {
-                    L_num = L_sub(L_num, L_denom);
-                    var_out = add (var_out, 1);
-                }
-            }
-        }
-    }
-
-    return (var_out);
-}
-#endif
-
-/*___________________________________________________________________________
- |                                                                           |
- |   Function Name : norm_l                                                  |
- |                                                                           |
- |   Purpose :                                                               |
- |                                                                           |
- |   Produces the number of left shifts needed to normalize the 32 bit varia-|
- |   ble L_var1 for positive values on the interval with minimum of          |
- |   1073741824 and maximum of 2147483647, and for negative values on the in-|
- |   terval with minimum of -2147483648 and maximum of -1073741824; in order |
- |   to normalize the result, the following operation must be done :         |
- |                   norm_L_var1 = L_shl(L_var1,norm_l(L_var1)).             |
- |                                                                           |
- |   Complexity weight : 30                                                  |
- |                                                                           |
- |   Inputs :                                                                |
- |                                                                           |
- |    L_var1                                                                 |
- |             32 bit long signed integer (Word32) whose value falls in the  |
- |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
- |                                                                           |
- |   Outputs :                                                               |
- |                                                                           |
- |    none                                                                   |
- |                                                                           |
- |   Return Value :                                                          |
- |                                                                           |
- |    var_out                                                                |
- |             16 bit short signed integer (Word16) whose value falls in the |
- |             range : 0x0000 0000 <= var_out <= 0x0000 001f.                |
- |___________________________________________________________________________|
-*/
-
-#if (!NORM_L_IS_INLINE)
-Word16 norm_l (Word32 L_var1)
-{
-    Word16 var_out;
-
-    if (L_var1 == 0)
-    {
-        var_out = 0;
-    }
-    else
-    {
-        if (L_var1 == (Word32) 0xffffffffL)
-        {
-            var_out = 31;
-        }
-        else
-        {
-            if (L_var1 < 0)
-            {
-                L_var1 = ~L_var1;
-            }
-            for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)
-            {
-                L_var1 <<= 1;
-            }
-        }
-    }
-
-    return (var_out);
-}
-#endif
+#include "basic_op.h"
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Functions                                                               |
+ |___________________________________________________________________________|
+*/
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : saturate                                                |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Limit the 32 bit input to the range of a 16 bit word.                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+#if (!SATRUATE_IS_INLINE)
+Word16 saturate(Word32 L_var1)
+{
+    Word16 var_out;
+
+    if (L_var1 > 0X00007fffL)
+    {
+        var_out = MAX_16;
+    }
+    else if (L_var1 < (Word32) 0xffff8000L)
+    {
+        var_out = MIN_16;
+    }
+    else
+    {
+        var_out = extract_l(L_var1);
+    }
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : add                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Performs the addition (var1+var2) with overflow control and saturation;|
+ |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
+ |    when underflow occurs.                                                 |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+#if (!ADD_IS_INLINE)
+Word16 add (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_sum;
+
+    L_sum = (Word32)var1 + (Word32)var2;
+    var_out = saturate(L_sum);
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : sub                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Performs the subtraction (var1+var2) with overflow control and satu-   |
+ |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
+ |    -32768 when underflow occurs.                                          |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+#if (!SUB_IS_INLINE)
+Word16 sub(Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_diff;
+
+    L_diff = (Word32) var1 - var2;
+    var_out = saturate(L_diff);
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : abs_s                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Absolute value of var1; abs_s(-32768) = 32767.                         |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+//Word16 abs_s (Word16 var1)
+//{
+//    Word16 var_out;
+//
+//    if (var1 == MIN_16)
+//    {
+//        var_out = MAX_16;
+//    }
+//    else
+//    {
+//        if (var1 < 0)
+//        {
+//            var_out = (Word16)-var1;
+//        }
+//        else
+//        {
+//            var_out = var1;
+//        }
+//    }
+//
+//    return (var_out);
+//}
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : shl                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
+ |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
+ |   var1 right by -var2 with sign extension. Saturate the result in case of |
+ |   underflows or overflows.                                                |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+#if (!SHL_IS_INLINE)
+Word16 shl (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 result;
+
+    if (var2 < 0)
+    {
+        if (var2 < -16)
+            var2 = -16;
+        var_out = shr (var1, (Word16)-var2);
+    }
+    else
+    {
+        result = (Word32) var1 *((Word32) 1 << var2);
+
+        if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
+        {
+            //Overflow = 1;
+            var_out = (Word16)((var1 > 0) ? MAX_16 : MIN_16);
+        }
+        else
+        {
+            var_out = extract_l(result);
+        }
+    }
+
+    return (var_out);
+}
+#endif
+// end
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : shr                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
+ |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
+ |   -var2 with sign extension. Saturate the result in case of underflows or |
+ |   overflows.                                                              |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+#if (!SHR_IS_INLINE)
+Word16 shr (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    if (var2 < 0)
+    {
+        if (var2 < -16)
+            var2 = -16;
+        var_out = shl (var1, (Word16)-var2);
+    }
+    else
+    {
+        if (var2 >= 15)
+        {
+            var_out = (Word16)((var1 < 0) ? -1 : 0);
+        }
+        else
+        {
+            if (var1 < 0)
+            {
+                var_out = (Word16)(~((~var1) >> var2));
+            }
+            else
+            {
+                var_out = (Word16)(var1 >> var2);
+            }
+        }
+    }
+
+    return (var_out);
+}
+#endif
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : mult                                                    |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
+ |    which is scaled i.e.:                                                  |
+ |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
+ |             mult(-32768,-32768) = 32767.                                  |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+#if (!MULT_IS_INLINE)
+Word16 mult (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_product;
+
+    L_product = (Word32) var1 *(Word32) var2;
+
+    L_product = (L_product & (Word32) 0xffff8000L) >> 15;
+
+    if (L_product & (Word32) 0x00010000L)
+        L_product = L_product | (Word32) 0xffff0000L;
+
+    var_out = saturate(L_product);
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_mult                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
+ |   with one shift left i.e.:                                               |
+ |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                 |
+ |        L_mult(-32768,-32768) = 2147483647.                                |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+#if (!L_MULT_IS_INLINE)
+Word32 L_mult(Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = (Word32) var1 *(Word32) var2;
+
+    if (L_var_out != (Word32) 0x40000000L)
+    {
+        L_var_out <<= 1;
+    }
+    else
+    {
+        L_var_out = MAX_32;
+    }
+
+    return (L_var_out);
+}
+#endif
+// end
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : negate                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Negate var1 with saturation, saturate in the case where input is -32768:|
+ |                negate(var1) = sub(0,var1).                                |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+//Word16 negate (Word16 var1)
+//{
+//    Word16 var_out;
+//
+//    var_out = (Word16)((var1 == MIN_16) ? MAX_16 : -var1);
+//
+//    return (var_out);
+//}
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : extract_h                                               |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Return the 16 MSB of L_var1.                                            |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32 ) whose value falls in the |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+#if (!EXTRACT_H_IS_INLINE)
+Word16 extract_h (Word32 L_var1)
+{
+    Word16 var_out;
+
+    var_out = (Word16) (L_var1 >> 16);
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : extract_l                                               |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Return the 16 LSB of L_var1.                                            |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32 ) whose value falls in the |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+#if (!EXTRACT_L_IS_INLINE)
+Word16 extract_l(Word32 L_var1)
+{
+    Word16 var_out;
+
+    var_out = (Word16) L_var1;
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : round                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
+ |   with saturation. Shift the resulting bits right by 16 and return the 16 |
+ |   bit number:                                                             |
+ |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32 ) whose value falls in the |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+#if (!ROUND_IS_INLINE)
+Word16 round16(Word32 L_var1)
+{
+    Word16 var_out;
+    Word32 L_rounded;
+
+    L_rounded = L_add (L_var1, (Word32) 0x00008000L);
+    var_out = extract_h (L_rounded);
+
+    return (var_out);
+}
+#endif
+// end
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_mac                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
+ |   result to L_var3 with saturation, return a 32 bit result:               |
+ |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+#if (!L_MSU_IS_INLINE)
+Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+    Word32 L_product;
+
+    L_product = L_mult(var1, var2);
+    L_var_out = L_add (L_var3, L_product);
+
+    return (L_var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_msu                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
+ |   bit result to L_var3 with saturation, return a 32 bit result:           |
+ |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+#if (!L_MSU_IS_INLINE)
+Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+    Word32 L_product;
+
+    L_product = L_mult(var1, var2);
+    L_var_out = L_sub (L_var3, L_product);
+
+    return (L_var_out);
+}
+#endif
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_add                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
+ |   overflow control and saturation; the result is set at +2147483647 when  |
+ |   overflow occurs or at -2147483648 when underflow occurs.                |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+#if (!L_ADD_IS_INLINE)
+Word32 L_add (Word32 L_var1, Word32 L_var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = L_var1 + L_var2;
+
+    if (((L_var1 ^ L_var2) & MIN_32) == 0)
+    {
+        if ((L_var_out ^ L_var1) & MIN_32)
+        {
+            L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
+            //Overflow = 1;
+        }
+    }
+
+    return (L_var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_sub                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
+ |   overflow control and saturation; the result is set at +2147483647 when  |
+ |   overflow occurs or at -2147483648 when underflow occurs.                |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+#if (!L_SUB_IS_INLINE)
+Word32 L_sub(Word32 L_var1, Word32 L_var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = L_var1 - L_var2;
+
+    if (((L_var1 ^ L_var2) & MIN_32) != 0)
+    {
+        if ((L_var_out ^ L_var1) & MIN_32)
+        {
+            L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
+            //Overflow = 1;
+        }
+    }
+
+    return (L_var_out);
+}
+#endif
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_negate                                                |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
+ |   where input is -2147483648 (0x8000 0000).                               |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+//Word32 L_negate (Word32 L_var1)
+//{
+//    Word32 L_var_out;
+//
+//    L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
+//
+//    return (L_var_out);
+//}
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : mult_r                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Same as mult with rounding, i.e.:                                       |
+ |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
+ |     mult_r(-32768,-32768) = 32767.                                        |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+#if (!MULT_R_IS_INLINE)
+Word16 mult_r (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_product_arr;
+
+    L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
+    L_product_arr += (Word32) 0x00004000L;      /* round */
+    L_product_arr &= (Word32) 0xffff8000L;
+    L_product_arr >>= 15;       /* shift */
+
+    if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
+    {
+        L_product_arr |= (Word32) 0xffff0000L;
+    }
+    var_out = saturate(L_product_arr);
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_shl                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
+ |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
+ |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
+ |   case of underflows or overflows.                                        |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+#if (!L_SHL_IS_INLINE)
+Word32 L_shl (Word32 L_var1, Word16 var2)
+{
+    Word32 L_var_out = 0L;
+
+    if (var2 <= 0)
+    {
+        L_var1 = L_shr(L_var1, (Word16)-var2);
+    }
+    else
+    {
+        for (; var2 > 0; var2--)
+        {
+            if (L_var1 > (Word32) 0X3fffffffL)
+            {
+                return MAX_32;
+            }
+            else
+            {
+                if (L_var1 < (Word32) 0xc0000000L)
+                {
+                    return MIN_32;
+                }
+            }
+            L_var1 <<= 1;
+        }
+    }
+    return (L_var1);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_shr                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
+ |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
+ |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
+ |   in case of underflows or overflows.                                     |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+#if (!L_SHR_IS_INLINE)
+Word32 L_shr (Word32 L_var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    if (var2 < 0)
+    {
+        L_var_out = L_shl (L_var1, (Word16)-var2);
+    }
+    else
+    {
+        if (var2 >= 31)
+        {
+            L_var_out = (L_var1 < 0L) ? -1 : 0;
+        }
+        else
+        {
+            if (L_var1 < 0)
+            {
+                L_var_out = ~((~L_var1) >> var2);
+            }
+            else
+            {
+                L_var_out = L_var1 >> var2;
+            }
+        }
+    }
+    return (L_var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : shr_r                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
+ |   underflows or overflows :                                               |
+ |    - If var2 is greater than zero :                                       |
+ |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
+ |          is equal to zero                                                 |
+ |                     then                                                  |
+ |                     shr_r(var1,var2) = shr(var1,var2)                     |
+ |                     else                                                  |
+ |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
+ |    - If var2 is less than or equal to zero :                              |
+ |                     shr_r(var1,var2) = shr(var1,var2).                    |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+#if (!SHR_R_IS_INLINE)
+Word16 shr_r (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    if (var2 > 15)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        var_out = shr (var1, var2);
+
+        if (var2 > 0)
+        {
+            if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
+            {
+                var_out++;
+            }
+        }
+    }
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : mac_r                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
+ |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
+ |   into the MS 16 bits with saturation and shift the result right by 16.   |
+ |   Return a 16 bit result.                                                 |
+ |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
+ |___________________________________________________________________________|
+*/
+#if (!MAC_R_IS_INLINE)
+Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    L_var3 = L_mac (L_var3, var1, var2);
+    L_var3 = L_add (L_var3, (Word32) 0x00008000L);
+    var_out = extract_h (L_var3);
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : msu_r                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
+ |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
+ |   ult into the MS 16 bits with saturation and shift the result right by   |
+ |   16. Return a 16 bit result.                                             |
+ |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
+ |___________________________________________________________________________|
+*/
+#if (!MSU_R_IS_INLINE)
+Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    L_var3 = L_msu (L_var3, var1, var2);
+    L_var3 = L_add (L_var3, (Word32) 0x00008000L);
+    var_out = extract_h (L_var3);
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_deposit_h                                             |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
+ |   16 LS bits of the output are zeroed.                                    |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
+ |___________________________________________________________________________|
+*/
+//Word32 L_deposit_h (Word16 var1)
+//{
+//    Word32 L_var_out;
+//
+//    L_var_out = (Word32) var1 << 16;
+//
+//    return (L_var_out);
+//}
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_deposit_l                                             |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
+ |   16 MS bits of the output are sign extended.                             |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+//Word32 L_deposit_l (Word16 var1)
+//{
+//    Word32 L_var_out;
+//
+//    L_var_out = (Word32) var1;
+//
+//    return (L_var_out);
+//}
+
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_shr_r                                                 |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
+ |   case of underflows or overflows :                                       |
+ |    - If var2 is greater than zero :                                       |
+ |          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
+ |          is equal to zero                                                 |
+ |                     then                                                  |
+ |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
+ |                     else                                                  |
+ |                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
+ |    - If var2 is less than or equal to zero :                              |
+ |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
+ |                                                                           |
+ |   Complexity weight : 3                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
+ |___________________________________________________________________________|
+*/
+#if (!L_SHR_R_IS_INLINE)
+Word32 L_shr_r (Word32 L_var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    if (var2 > 31)
+    {
+        L_var_out = 0;
+    }
+    else
+    {
+        L_var_out = L_shr (L_var1, var2);
+
+        if (var2 > 0)
+        {
+            if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)
+            {
+                L_var_out++;
+            }
+        }
+    }
+
+    return (L_var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_abs                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Absolute value of L_var1; Saturate in case where the input is          |
+ |                                                               -214783648  |
+ |                                                                           |
+ |   Complexity weight : 3                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x0000 0000 <= var_out <= 0x7fff ffff.                |
+ |___________________________________________________________________________|
+*/
+//Word32 L_abs (Word32 L_var1)
+//{
+//    Word32 L_var_out;
+//
+//    if (L_var1 == MIN_32)
+//    {
+//        L_var_out = MAX_32;
+//    }
+//    else
+//    {
+//        if (L_var1 < 0)
+//        {
+//            L_var_out = -L_var1;
+//        }
+//        else
+//        {
+//            L_var_out = L_var1;
+//        }
+//    }
+//
+//    return (L_var_out);
+//}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : norm_s                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Produces the number of left shift needed to normalize the 16 bit varia- |
+ |   ble var1 for positive values on the interval with minimum of 16384 and  |
+ |   maximum of 32767, and for negative values on the interval with minimum  |
+ |   of -32768 and maximum of -16384; in order to normalize the result, the  |
+ |   following operation must be done :                                      |
+ |                    norm_var1 = shl(var1,norm_s(var1)).                    |
+ |                                                                           |
+ |   Complexity weight : 15                                                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 000f.                |
+ |___________________________________________________________________________|
+*/
+
+#if (!NORM_S_IS_INLINE)
+Word16 norm_s (Word16 var1)
+{
+    Word16 var_out;
+
+    if (var1 == 0)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        if (var1 == -1)
+        {
+            var_out = 15;
+        }
+        else
+        {
+            if (var1 < 0)
+            {
+                var1 = (Word16)~var1;
+            }
+            for (var_out = 0; var1 < 0x4000; var_out++)
+            {
+                var1 <<= 1;
+            }
+        }
+    }
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : div_s                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Produces a result which is the fractional integer division of var1  by  |
+ |   var2; var1 and var2 must be positive and var2 must be greater or equal  |
+ |   to var1; the result is positive (leading bit equal to 0) and truncated  |
+ |   to 16 bits.                                                             |
+ |   If var1 = var2 then div(var1,var2) = 32767.                             |
+ |                                                                           |
+ |   Complexity weight : 18                                                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var1 <= var2 and var2 != 0.            |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : var1 <= var2 <= 0x0000 7fff and var2 != 0.            |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
+ |             It's a Q15 value (point between b15 and b14).                 |
+ |___________________________________________________________________________|
+*/
+
+#if (!DIV_S_IS_INLINE)
+Word16 div_s (Word16 var1, Word16 var2)
+{
+    Word16 var_out = 0;
+    Word16 iteration;
+    Word32 L_num;
+    Word32 L_denom;
+
+    if (var1 == 0)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        if (var1 == var2)
+        {
+            var_out = MAX_16;
+        }
+        else
+        {
+            L_num = L_deposit_l (var1);
+            L_denom = L_deposit_l (var2);
+
+            for (iteration = 0; iteration < 15; iteration++)
+            {
+                var_out <<= 1;
+                L_num <<= 1;
+
+                if (L_num >= L_denom)
+                {
+                    L_num = L_sub(L_num, L_denom);
+                    var_out = add (var_out, 1);
+                }
+            }
+        }
+    }
+
+    return (var_out);
+}
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : norm_l                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Produces the number of left shifts needed to normalize the 32 bit varia-|
+ |   ble L_var1 for positive values on the interval with minimum of          |
+ |   1073741824 and maximum of 2147483647, and for negative values on the in-|
+ |   terval with minimum of -2147483648 and maximum of -1073741824; in order |
+ |   to normalize the result, the following operation must be done :         |
+ |                   norm_L_var1 = L_shl(L_var1,norm_l(L_var1)).             |
+ |                                                                           |
+ |   Complexity weight : 30                                                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 001f.                |
+ |___________________________________________________________________________|
+*/
+
+#if (!NORM_L_IS_INLINE)
+Word16 norm_l (Word32 L_var1)
+{
+    Word16 var_out;
+
+    if (L_var1 == 0)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        if (L_var1 == (Word32) 0xffffffffL)
+        {
+            var_out = 31;
+        }
+        else
+        {
+            if (L_var1 < 0)
+            {
+                L_var1 = ~L_var1;
+            }
+            for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)
+            {
+                L_var1 <<= 1;
+            }
+        }
+    }
+
+    return (var_out);
+}
+#endif
 
diff --git a/media/libstagefright/codecs/aacenc/basic_op/oper_32b.c b/media/libstagefright/codecs/aacenc/basic_op/oper_32b.c
index 906a9df..e48af9d 100644
--- a/media/libstagefright/codecs/aacenc/basic_op/oper_32b.c
+++ b/media/libstagefright/codecs/aacenc/basic_op/oper_32b.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		oper_32b.c
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		oper_32b.c
+
 	Content:	  This file contains operations in double precision.
- 
+
 *******************************************************************************/
 
 #include "typedef.h"
@@ -198,164 +198,164 @@ Word32 Div_32 (Word32 L_num, Word32 denom)
 
     return (L_32);
 }
-
-/*!
- 
-  \brief  calculates the log dualis times 4 of argument 
-          iLog4(x) = (Word32)(4 * log(value)/log(2.0))
-
-  \return ilog4 value
- 
-*/
-Word16 iLog4(Word32 value)
-{
-  Word16 iLog4;
-
-  if(value != 0){
-    Word32 tmp;
-    Word16 tmp16;
-    iLog4 = norm_l(value);
-    tmp = (value << iLog4);
-    tmp16 = round16(tmp);
-    tmp = L_mult(tmp16, tmp16);
-    tmp16 = round16(tmp);
-    tmp = L_mult(tmp16, tmp16);
-    tmp16 = round16(tmp);
-
-    iLog4 = (-(iLog4 << 2) - norm_s(tmp16)) - 1;
-  }
-  else {
-    iLog4 = -128; /* -(INT_BITS*4); */                                          
-  }
-
-  return iLog4;
-}
-
-#define step(shift) \
-    if ((0x40000000l >> shift) + root <= value)       \
-    {                                                 \
-        value -= (0x40000000l >> shift) + root;       \
-        root = (root >> 1) | (0x40000000l >> shift);  \
-    } else {                                          \
-        root = root >> 1;                             \
-    }
-
-Word32 rsqrt(Word32 value,     /*!< Operand to square root (0.0 ... 1) */
-             Word32 accuracy)  /*!< Number of valid bits that will be calculated */
-{
-    Word32 root = 0;
-	Word32 scale;
-
-	if(value < 0)
-		return 0;
-
-	scale = norm_l(value);
-	if(scale & 1) scale--;
-
-	value <<= scale;
-
-	step( 0); step( 2); step( 4); step( 6);
-    step( 8); step(10); step(12); step(14);
-    step(16); step(18); step(20); step(22);
-    step(24); step(26); step(28); step(30);
-
-    scale >>= 1;
-	if (root < value)
-        ++root;
-
-	root >>= scale;
-    return root* 46334;
-}
-
-static const Word32 pow2Table[POW2_TABLE_SIZE] = {
-0x7fffffff, 0x7fa765ad, 0x7f4f08ae, 0x7ef6e8da, 
-0x7e9f0606, 0x7e476009, 0x7deff6b6, 0x7d98c9e6, 
-0x7d41d96e, 0x7ceb2523, 0x7c94acde, 0x7c3e7073, 
-0x7be86fb9, 0x7b92aa88, 0x7b3d20b6, 0x7ae7d21a, 
-0x7a92be8b, 0x7a3de5df, 0x79e947ef, 0x7994e492, 
-0x7940bb9e, 0x78ecccec, 0x78991854, 0x78459dac, 
-0x77f25cce, 0x779f5591, 0x774c87cc, 0x76f9f359, 
-0x76a7980f, 0x765575c8, 0x76038c5b, 0x75b1dba2, 
-0x75606374, 0x750f23ab, 0x74be1c20, 0x746d4cac, 
-0x741cb528, 0x73cc556d, 0x737c2d55, 0x732c3cba, 
-0x72dc8374, 0x728d015d, 0x723db650, 0x71eea226, 
-0x719fc4b9, 0x71511de4, 0x7102ad80, 0x70b47368, 
-0x70666f76, 0x7018a185, 0x6fcb096f, 0x6f7da710, 
-0x6f307a41, 0x6ee382de, 0x6e96c0c3, 0x6e4a33c9, 
-0x6dfddbcc, 0x6db1b8a8, 0x6d65ca38, 0x6d1a1057, 
-0x6cce8ae1, 0x6c8339b2, 0x6c381ca6, 0x6bed3398, 
-0x6ba27e66, 0x6b57fce9, 0x6b0daeff, 0x6ac39485, 
-0x6a79ad56, 0x6a2ff94f, 0x69e6784d, 0x699d2a2c, 
-0x69540ec9, 0x690b2601, 0x68c26fb1, 0x6879ebb6, 
-0x683199ed, 0x67e97a34, 0x67a18c68, 0x6759d065, 
-0x6712460b, 0x66caed35, 0x6683c5c3, 0x663ccf92, 
-0x65f60a80, 0x65af766a, 0x6569132f, 0x6522e0ad, 
-0x64dcdec3, 0x64970d4f, 0x64516c2e, 0x640bfb41, 
-0x63c6ba64, 0x6381a978, 0x633cc85b, 0x62f816eb, 
-0x62b39509, 0x626f4292, 0x622b1f66, 0x61e72b65, 
-0x61a3666d, 0x615fd05f, 0x611c6919, 0x60d9307b, 
-0x60962665, 0x60534ab7, 0x60109d51, 0x5fce1e12, 
-0x5f8bccdb, 0x5f49a98c, 0x5f07b405, 0x5ec5ec26, 
-0x5e8451d0, 0x5e42e4e3, 0x5e01a540, 0x5dc092c7, 
-0x5d7fad59, 0x5d3ef4d7, 0x5cfe6923, 0x5cbe0a1c, 
-0x5c7dd7a4, 0x5c3dd19c, 0x5bfdf7e5, 0x5bbe4a61, 
-0x5b7ec8f2, 0x5b3f7377, 0x5b0049d4, 0x5ac14bea, 
-0x5a82799a, 0x5a43d2c6, 0x5a055751, 0x59c7071c, 
-0x5988e209, 0x594ae7fb, 0x590d18d3, 0x58cf7474, 
-0x5891fac1, 0x5854ab9b, 0x581786e6, 0x57da8c83, 
-0x579dbc57, 0x57611642, 0x57249a29, 0x56e847ef, 
-0x56ac1f75, 0x567020a0, 0x56344b52, 0x55f89f70, 
-0x55bd1cdb, 0x5581c378, 0x55469329, 0x550b8bd4, 
-0x54d0ad5b, 0x5495f7a1, 0x545b6a8b, 0x542105fd, 
-0x53e6c9db, 0x53acb607, 0x5372ca68, 0x533906e0, 
-0x52ff6b55, 0x52c5f7aa, 0x528cabc3, 0x52538786, 
-0x521a8ad7, 0x51e1b59a, 0x51a907b4, 0x5170810b, 
-0x51382182, 0x50ffe8fe, 0x50c7d765, 0x508fec9c, 
-0x50582888, 0x50208b0e, 0x4fe91413, 0x4fb1c37c, 
-0x4f7a9930, 0x4f439514, 0x4f0cb70c, 0x4ed5ff00, 
-0x4e9f6cd4, 0x4e69006e, 0x4e32b9b4, 0x4dfc988c, 
-0x4dc69cdd, 0x4d90c68b, 0x4d5b157e, 0x4d25899c, 
-0x4cf022ca, 0x4cbae0ef, 0x4c85c3f1, 0x4c50cbb8, 
-0x4c1bf829, 0x4be7492b, 0x4bb2bea5, 0x4b7e587d, 
-0x4b4a169c, 0x4b15f8e6, 0x4ae1ff43, 0x4aae299b, 
-0x4a7a77d5, 0x4a46e9d6, 0x4a137f88, 0x49e038d0, 
-0x49ad1598, 0x497a15c4, 0x4947393f, 0x49147fee, 
-0x48e1e9ba, 0x48af768a, 0x487d2646, 0x484af8d6, 
-0x4818ee22, 0x47e70611, 0x47b5408c, 0x47839d7b, 
-0x47521cc6, 0x4720be55, 0x46ef8210, 0x46be67e0, 
-0x468d6fae, 0x465c9961, 0x462be4e2, 0x45fb521a, 
-0x45cae0f2, 0x459a9152, 0x456a6323, 0x453a564d, 
-0x450a6abb, 0x44daa054, 0x44aaf702, 0x447b6ead, 
-0x444c0740, 0x441cc0a3, 0x43ed9ac0, 0x43be9580, 
-0x438fb0cb, 0x4360ec8d, 0x433248ae, 0x4303c517, 
-0x42d561b4, 0x42a71e6c, 0x4278fb2b, 0x424af7da, 
-0x421d1462, 0x41ef50ae, 0x41c1aca8, 0x41942839, 
-0x4166c34c, 0x41397dcc, 0x410c57a2, 0x40df50b8, 
-0x40b268fa, 0x4085a051, 0x4058f6a8, 0x402c6be9 
-};
-
-/*!
- 
-  \brief calculates 2 ^ (x/y) for x<=0, y > 0, x <= 32768 * y 
-  
-  avoids integer division
-  
-  \return 
-*/
-Word32 pow2_xy(Word32 x, Word32 y)
-{
-  Word32 iPart;
-  Word32 fPart;
-  Word32 res;
-  Word32 tmp, tmp2;
-  Word32 shift, shift2;
-
-  tmp2 = -x;
-  iPart = tmp2 / y;
-  fPart = tmp2 - iPart*y;
-  iPart = min(iPart,INT_BITS-1);
-
-  res = pow2Table[(POW2_TABLE_SIZE*fPart)/y] >> iPart; 
- 
-  return(res);
+
+/*!
+
+  \brief  calculates the log dualis times 4 of argument
+          iLog4(x) = (Word32)(4 * log(value)/log(2.0))
+
+  \return ilog4 value
+
+*/
+Word16 iLog4(Word32 value)
+{
+  Word16 iLog4;
+
+  if(value != 0){
+    Word32 tmp;
+    Word16 tmp16;
+    iLog4 = norm_l(value);
+    tmp = (value << iLog4);
+    tmp16 = round16(tmp);
+    tmp = L_mult(tmp16, tmp16);
+    tmp16 = round16(tmp);
+    tmp = L_mult(tmp16, tmp16);
+    tmp16 = round16(tmp);
+
+    iLog4 = (-(iLog4 << 2) - norm_s(tmp16)) - 1;
+  }
+  else {
+    iLog4 = -128; /* -(INT_BITS*4); */
+  }
+
+  return iLog4;
+}
+
+#define step(shift) \
+    if ((0x40000000l >> shift) + root <= value)       \
+    {                                                 \
+        value -= (0x40000000l >> shift) + root;       \
+        root = (root >> 1) | (0x40000000l >> shift);  \
+    } else {                                          \
+        root = root >> 1;                             \
+    }
+
+Word32 rsqrt(Word32 value,     /*!< Operand to square root (0.0 ... 1) */
+             Word32 accuracy)  /*!< Number of valid bits that will be calculated */
+{
+    Word32 root = 0;
+	Word32 scale;
+
+	if(value < 0)
+		return 0;
+
+	scale = norm_l(value);
+	if(scale & 1) scale--;
+
+	value <<= scale;
+
+	step( 0); step( 2); step( 4); step( 6);
+    step( 8); step(10); step(12); step(14);
+    step(16); step(18); step(20); step(22);
+    step(24); step(26); step(28); step(30);
+
+    scale >>= 1;
+	if (root < value)
+        ++root;
+
+	root >>= scale;
+    return root* 46334;
+}
+
+static const Word32 pow2Table[POW2_TABLE_SIZE] = {
+0x7fffffff, 0x7fa765ad, 0x7f4f08ae, 0x7ef6e8da,
+0x7e9f0606, 0x7e476009, 0x7deff6b6, 0x7d98c9e6,
+0x7d41d96e, 0x7ceb2523, 0x7c94acde, 0x7c3e7073,
+0x7be86fb9, 0x7b92aa88, 0x7b3d20b6, 0x7ae7d21a,
+0x7a92be8b, 0x7a3de5df, 0x79e947ef, 0x7994e492,
+0x7940bb9e, 0x78ecccec, 0x78991854, 0x78459dac,
+0x77f25cce, 0x779f5591, 0x774c87cc, 0x76f9f359,
+0x76a7980f, 0x765575c8, 0x76038c5b, 0x75b1dba2,
+0x75606374, 0x750f23ab, 0x74be1c20, 0x746d4cac,
+0x741cb528, 0x73cc556d, 0x737c2d55, 0x732c3cba,
+0x72dc8374, 0x728d015d, 0x723db650, 0x71eea226,
+0x719fc4b9, 0x71511de4, 0x7102ad80, 0x70b47368,
+0x70666f76, 0x7018a185, 0x6fcb096f, 0x6f7da710,
+0x6f307a41, 0x6ee382de, 0x6e96c0c3, 0x6e4a33c9,
+0x6dfddbcc, 0x6db1b8a8, 0x6d65ca38, 0x6d1a1057,
+0x6cce8ae1, 0x6c8339b2, 0x6c381ca6, 0x6bed3398,
+0x6ba27e66, 0x6b57fce9, 0x6b0daeff, 0x6ac39485,
+0x6a79ad56, 0x6a2ff94f, 0x69e6784d, 0x699d2a2c,
+0x69540ec9, 0x690b2601, 0x68c26fb1, 0x6879ebb6,
+0x683199ed, 0x67e97a34, 0x67a18c68, 0x6759d065,
+0x6712460b, 0x66caed35, 0x6683c5c3, 0x663ccf92,
+0x65f60a80, 0x65af766a, 0x6569132f, 0x6522e0ad,
+0x64dcdec3, 0x64970d4f, 0x64516c2e, 0x640bfb41,
+0x63c6ba64, 0x6381a978, 0x633cc85b, 0x62f816eb,
+0x62b39509, 0x626f4292, 0x622b1f66, 0x61e72b65,
+0x61a3666d, 0x615fd05f, 0x611c6919, 0x60d9307b,
+0x60962665, 0x60534ab7, 0x60109d51, 0x5fce1e12,
+0x5f8bccdb, 0x5f49a98c, 0x5f07b405, 0x5ec5ec26,
+0x5e8451d0, 0x5e42e4e3, 0x5e01a540, 0x5dc092c7,
+0x5d7fad59, 0x5d3ef4d7, 0x5cfe6923, 0x5cbe0a1c,
+0x5c7dd7a4, 0x5c3dd19c, 0x5bfdf7e5, 0x5bbe4a61,
+0x5b7ec8f2, 0x5b3f7377, 0x5b0049d4, 0x5ac14bea,
+0x5a82799a, 0x5a43d2c6, 0x5a055751, 0x59c7071c,
+0x5988e209, 0x594ae7fb, 0x590d18d3, 0x58cf7474,
+0x5891fac1, 0x5854ab9b, 0x581786e6, 0x57da8c83,
+0x579dbc57, 0x57611642, 0x57249a29, 0x56e847ef,
+0x56ac1f75, 0x567020a0, 0x56344b52, 0x55f89f70,
+0x55bd1cdb, 0x5581c378, 0x55469329, 0x550b8bd4,
+0x54d0ad5b, 0x5495f7a1, 0x545b6a8b, 0x542105fd,
+0x53e6c9db, 0x53acb607, 0x5372ca68, 0x533906e0,
+0x52ff6b55, 0x52c5f7aa, 0x528cabc3, 0x52538786,
+0x521a8ad7, 0x51e1b59a, 0x51a907b4, 0x5170810b,
+0x51382182, 0x50ffe8fe, 0x50c7d765, 0x508fec9c,
+0x50582888, 0x50208b0e, 0x4fe91413, 0x4fb1c37c,
+0x4f7a9930, 0x4f439514, 0x4f0cb70c, 0x4ed5ff00,
+0x4e9f6cd4, 0x4e69006e, 0x4e32b9b4, 0x4dfc988c,
+0x4dc69cdd, 0x4d90c68b, 0x4d5b157e, 0x4d25899c,
+0x4cf022ca, 0x4cbae0ef, 0x4c85c3f1, 0x4c50cbb8,
+0x4c1bf829, 0x4be7492b, 0x4bb2bea5, 0x4b7e587d,
+0x4b4a169c, 0x4b15f8e6, 0x4ae1ff43, 0x4aae299b,
+0x4a7a77d5, 0x4a46e9d6, 0x4a137f88, 0x49e038d0,
+0x49ad1598, 0x497a15c4, 0x4947393f, 0x49147fee,
+0x48e1e9ba, 0x48af768a, 0x487d2646, 0x484af8d6,
+0x4818ee22, 0x47e70611, 0x47b5408c, 0x47839d7b,
+0x47521cc6, 0x4720be55, 0x46ef8210, 0x46be67e0,
+0x468d6fae, 0x465c9961, 0x462be4e2, 0x45fb521a,
+0x45cae0f2, 0x459a9152, 0x456a6323, 0x453a564d,
+0x450a6abb, 0x44daa054, 0x44aaf702, 0x447b6ead,
+0x444c0740, 0x441cc0a3, 0x43ed9ac0, 0x43be9580,
+0x438fb0cb, 0x4360ec8d, 0x433248ae, 0x4303c517,
+0x42d561b4, 0x42a71e6c, 0x4278fb2b, 0x424af7da,
+0x421d1462, 0x41ef50ae, 0x41c1aca8, 0x41942839,
+0x4166c34c, 0x41397dcc, 0x410c57a2, 0x40df50b8,
+0x40b268fa, 0x4085a051, 0x4058f6a8, 0x402c6be9
+};
+
+/*!
+
+  \brief calculates 2 ^ (x/y) for x<=0, y > 0, x <= 32768 * y
+
+  avoids integer division
+
+  \return
+*/
+Word32 pow2_xy(Word32 x, Word32 y)
+{
+  Word32 iPart;
+  Word32 fPart;
+  Word32 res;
+  Word32 tmp, tmp2;
+  Word32 shift, shift2;
+
+  tmp2 = -x;
+  iPart = tmp2 / y;
+  fPart = tmp2 - iPart*y;
+  iPart = min(iPart,INT_BITS-1);
+
+  res = pow2Table[(POW2_TABLE_SIZE*fPart)/y] >> iPart;
+
+  return(res);
 }
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/basic_op/oper_32b.h b/media/libstagefright/codecs/aacenc/basic_op/oper_32b.h
index 4119bc3..9ebd1c2 100644
--- a/media/libstagefright/codecs/aacenc/basic_op/oper_32b.h
+++ b/media/libstagefright/codecs/aacenc/basic_op/oper_32b.h
@@ -1,86 +1,86 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		oper_32b.h
-
-	Content:	Double precision operations
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		oper_32b.h
+
+	Content:	Double precision operations
+
 *******************************************************************************/
 
 #ifndef __OPER_32b_H
 #define __OPER_32b_H
-
-#include "typedef.h"
+
+#include "typedef.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
-
-#define POW2_TABLE_BITS 8
-#define POW2_TABLE_SIZE (1<<POW2_TABLE_BITS)
+
+#define POW2_TABLE_BITS 8
+#define POW2_TABLE_SIZE (1<<POW2_TABLE_BITS)
 
 void L_Extract (Word32 L_32, Word16 *hi, Word16 *lo);
 Word32 L_Comp (Word16 hi, Word16 lo);
 Word32 Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2);
 Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n);
 Word32 Div_32 (Word32 L_num, Word32 denom);
-Word16 iLog4(Word32 value);
-Word32 rsqrt(Word32 value,  Word32 accuracy);
-Word32 pow2_xy(Word32 x, Word32 y);
-
-__inline Word32 L_mpy_ls(Word32 L_var2, Word16 var1)
-{
-    unsigned short swLow1;
-    Word16 swHigh1;
-    Word32 l_var_out;
-
-    swLow1 = (unsigned short)(L_var2);
-    swHigh1 = (Word16)(L_var2 >> 16);
-
-    l_var_out = (long)swLow1 * (long)var1 >> 15;
-    
-    l_var_out += swHigh1 * var1 << 1;
-    
-    return(l_var_out);
-}
-
-__inline Word32 L_mpy_wx(Word32 L_var2, Word16 var1)
-{
-#if ARMV5TE_L_MPY_LS
-	Word32 result; 
-	asm volatile( 
-		"SMULWB  %[result], %[L_var2], %[var1] \n" 
-		:[result]"+r"(result)
-		:[L_var2]"r"(L_var2), [var1]"r"(var1)
-		); 
-	return result;
-#else
-    unsigned short swLow1;
-    Word16 swHigh1;
-    Word32 l_var_out;
-
-    swLow1 = (unsigned short)(L_var2);
-    swHigh1 = (Word16)(L_var2 >> 16);
-
-    l_var_out = (long)swLow1 * (long)var1 >> 16;    
-    l_var_out += swHigh1 * var1;
-    
-    return(l_var_out);
-#endif
-}
+Word16 iLog4(Word32 value);
+Word32 rsqrt(Word32 value,  Word32 accuracy);
+Word32 pow2_xy(Word32 x, Word32 y);
+
+__inline Word32 L_mpy_ls(Word32 L_var2, Word16 var1)
+{
+    unsigned short swLow1;
+    Word16 swHigh1;
+    Word32 l_var_out;
+
+    swLow1 = (unsigned short)(L_var2);
+    swHigh1 = (Word16)(L_var2 >> 16);
+
+    l_var_out = (long)swLow1 * (long)var1 >> 15;
+
+    l_var_out += swHigh1 * var1 << 1;
+
+    return(l_var_out);
+}
+
+__inline Word32 L_mpy_wx(Word32 L_var2, Word16 var1)
+{
+#if ARMV5TE_L_MPY_LS
+	Word32 result;
+	asm volatile(
+		"SMULWB  %[result], %[L_var2], %[var1] \n"
+		:[result]"+r"(result)
+		:[L_var2]"r"(L_var2), [var1]"r"(var1)
+		);
+	return result;
+#else
+    unsigned short swLow1;
+    Word16 swHigh1;
+    Word32 l_var_out;
+
+    swLow1 = (unsigned short)(L_var2);
+    swHigh1 = (Word16)(L_var2 >> 16);
+
+    l_var_out = (long)swLow1 * (long)var1 >> 16;
+    l_var_out += swHigh1 * var1;
+
+    return(l_var_out);
+#endif
+}
 
 #ifdef __cplusplus
 }
diff --git a/media/libstagefright/codecs/aacenc/basic_op/typedef.h b/media/libstagefright/codecs/aacenc/basic_op/typedef.h
index d3a626a..b1f8225 100644
--- a/media/libstagefright/codecs/aacenc/basic_op/typedef.h
+++ b/media/libstagefright/codecs/aacenc/basic_op/typedef.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		typedef.h
-
-	Content:	type defined for defferent paltform
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		typedef.h
+
+	Content:	type defined for defferent paltform
+
 *******************************************************************************/
 
 #ifndef typedef_h
@@ -30,7 +30,7 @@
 /*
  * this is the original code from the ETSI file typedef.h
  */
-   
+
 #if defined(__BORLANDC__) || defined(__WATCOMC__) || defined(_MSC_VER) || defined(__ZTC__)
 typedef signed char Word8;
 typedef short Word16;
@@ -54,7 +54,7 @@ typedef int Flag;
 
 /*
  * use (improved) type definition file typdefs.h and add a "Flag" type
- */
+ */
 #include "typedefs.h"
 typedef int Flag;
 
diff --git a/media/libstagefright/codecs/aacenc/basic_op/typedefs.h b/media/libstagefright/codecs/aacenc/basic_op/typedefs.h
index 7d16fca..c924e2c 100644
--- a/media/libstagefright/codecs/aacenc/basic_op/typedefs.h
+++ b/media/libstagefright/codecs/aacenc/basic_op/typedefs.h
@@ -1,61 +1,61 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		typedefs.h
-
-	Content:	type defined or const defined
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		typedefs.h
+
+	Content:	type defined or const defined
+
 *******************************************************************************/
 
 #ifndef typedefs_h
 #define typedefs_h "$Id $"
 
-#ifndef CHAR_BIT
-#define CHAR_BIT      8         /* number of bits in a char */
-#endif
-
-#ifndef VOAAC_SHRT_MAX
-#define VOAAC_SHRT_MAX    (32767)        /* maximum (signed) short value */
-#endif
-
-#ifndef VOAAC_SHRT_MIN
-#define VOAAC_SHRT_MIN    (-32768)        /* minimum (signed) short value */
-#endif
-
-/* Define NULL pointer value */
-#ifndef NULL
-#ifdef __cplusplus
-#define NULL    0
-#else
-#define NULL    ((void *)0)
-#endif
+#ifndef CHAR_BIT
+#define CHAR_BIT      8         /* number of bits in a char */
+#endif
+
+#ifndef VOAAC_SHRT_MAX
+#define VOAAC_SHRT_MAX    (32767)        /* maximum (signed) short value */
+#endif
+
+#ifndef VOAAC_SHRT_MIN
+#define VOAAC_SHRT_MIN    (-32768)        /* minimum (signed) short value */
+#endif
+
+/* Define NULL pointer value */
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL    0
+#else
+#define NULL    ((void *)0)
+#endif
 #endif
 
 #ifndef assert
 #define assert(_Expression)     ((void)0)
 #endif
-
-#ifdef LINUX
-#define __inline static __inline__
-#endif
+
+#ifdef LINUX
+#define __inline static __inline__
+#endif
 
 #define INT_BITS   32
 /*
 ********************************************************************************
-*                         DEFINITION OF CONSTANTS 
+*                         DEFINITION OF CONSTANTS
 ********************************************************************************
 */
 /*
@@ -80,100 +80,100 @@ typedef unsigned short UWord16;
 typedef long Word32;
 typedef unsigned long UWord32;
 
-
-
+
+
 #ifdef LINUX
 typedef long long Word64;
 typedef unsigned long long UWord64;
 #else
-typedef __int64 Word64;
+typedef __int64 Word64;
 typedef unsigned __int64 UWord64;
 #endif
 
-#ifndef min
-#define min(a,b) ( a < b ? a : b)
-#endif
-
-#ifndef max
-#define max(a,b) ( a > b ? a : b)
-#endif
-
-#ifdef ARM_INASM
-#ifdef ARMV5_INASM
-#define ARMV5E_INASM	1
-#endif
-#define ARMV4_INASM		1
-#endif
-
-#if ARMV4_INASM
-	#define ARMV5TE_SAT           1
-    #define ARMV5TE_ADD           1
-    #define ARMV5TE_SUB           1
-	#define ARMV5TE_SHL           1
-    #define ARMV5TE_SHR           1
-	#define ARMV5TE_L_SHL         1
-    #define ARMV5TE_L_SHR         1
-#endif//ARMV4
-#if ARMV5E_INASM
-    #define ARMV5TE_L_ADD         1
-    #define ARMV5TE_L_SUB         1
-    #define ARMV5TE_L_MULT        1
-    #define ARMV5TE_L_MAC         1
-    #define ARMV5TE_L_MSU         1
-   
-    
-    #define ARMV5TE_DIV_S         1
-    #define ARMV5TE_ROUND         1
-    #define ARMV5TE_MULT          1
-    
-    #define ARMV5TE_NORM_S        1
-    #define ARMV5TE_NORM_L        1
-	#define ARMV5TE_L_MPY_LS	  1
+#ifndef min
+#define min(a,b) ( a < b ? a : b)
+#endif
+
+#ifndef max
+#define max(a,b) ( a > b ? a : b)
+#endif
+
+#ifdef ARM_INASM
+#ifdef ARMV5_INASM
+#define ARMV5E_INASM	1
+#endif
+#define ARMV4_INASM		1
+#endif
+
+#if ARMV4_INASM
+	#define ARMV5TE_SAT           1
+    #define ARMV5TE_ADD           1
+    #define ARMV5TE_SUB           1
+	#define ARMV5TE_SHL           1
+    #define ARMV5TE_SHR           1
+	#define ARMV5TE_L_SHL         1
+    #define ARMV5TE_L_SHR         1
+#endif//ARMV4
+#if ARMV5E_INASM
+    #define ARMV5TE_L_ADD         1
+    #define ARMV5TE_L_SUB         1
+    #define ARMV5TE_L_MULT        1
+    #define ARMV5TE_L_MAC         1
+    #define ARMV5TE_L_MSU         1
+
+
+    #define ARMV5TE_DIV_S         1
+    #define ARMV5TE_ROUND         1
+    #define ARMV5TE_MULT          1
+
+    #define ARMV5TE_NORM_S        1
+    #define ARMV5TE_NORM_L        1
+	#define ARMV5TE_L_MPY_LS	  1
 #endif
-
-//basic operation functions optimization flags
-#define SATRUATE_IS_INLINE              1   //define saturate as inline function
-#define SHL_IS_INLINE                   1  //define shl as inline function
-#define SHR_IS_INLINE                   1   //define shr as inline function
-#define L_MULT_IS_INLINE                1   //define L_mult as inline function
-#define L_MSU_IS_INLINE                 1   //define L_msu as inline function
-#define L_SUB_IS_INLINE                 1   //define L_sub as inline function
-#define L_SHL_IS_INLINE                 1   //define L_shl as inline function
-#define L_SHR_IS_INLINE                 1   //define L_shr as inline function
-#define ADD_IS_INLINE                   1   //define add as inline function //add, inline is the best
-#define SUB_IS_INLINE                   1   //define sub as inline function //sub, inline is the best
-#define DIV_S_IS_INLINE                 1   //define div_s as inline function
-#define MULT_IS_INLINE                  1   //define mult as inline function
-#define NORM_S_IS_INLINE                1   //define norm_s as inline function
-#define NORM_L_IS_INLINE                1   //define norm_l as inline function
-#define ROUND_IS_INLINE                 1   //define round as inline function
-#define L_MAC_IS_INLINE                 1   //define L_mac as inline function
-#define L_ADD_IS_INLINE                 1   //define L_add as inline function
-#define EXTRACT_H_IS_INLINE             1   //define extract_h as inline function 
-#define EXTRACT_L_IS_INLINE             1   //define extract_l as inline function        //???
-#define MULT_R_IS_INLINE                1   //define mult_r as inline function
-#define SHR_R_IS_INLINE                 1   //define shr_r as inline function
-#define MAC_R_IS_INLINE                 1   //define mac_r as inline function
-#define MSU_R_IS_INLINE                 1   //define msu_r as inline function
-#define L_SHR_R_IS_INLINE               1   //define L_shr_r as inline function
-
-#define PREFIX				voAACEnc
-#define LINK0(x, y, z)		LINK1(x,y,z)
-#define LINK1(x,y,z)		x##y##z
-#define ADD_PREFIX(func)	LINK0(PREFIX, _, func)
-
-#define  L_Extract		ADD_PREFIX(L_Extract)
-#define  L_Comp			ADD_PREFIX(L_Comp)
-#define  Mpy_32			ADD_PREFIX(Mpy_32)
-#define  Mpy_32_16		ADD_PREFIX(Mpy_32_16)
-#define  Div_32			ADD_PREFIX(Div_32)
-#define  iLog4			ADD_PREFIX(iLog4)
-#define  rsqrt			ADD_PREFIX(rsqrt)
-#define  pow2_xy		ADD_PREFIX(pow2_xy)
-#define  L_mpy_ls		ADD_PREFIX(L_mpy_ls)
-#define  L_mpy_wx		ADD_PREFIX(L_mpy_wx)
-
-#define mem_malloc		ADD_PREFIX(mem_malloc)
-#define mem_free		ADD_PREFIX(mem_free)
-
+
+//basic operation functions optimization flags
+#define SATRUATE_IS_INLINE              1   //define saturate as inline function
+#define SHL_IS_INLINE                   1  //define shl as inline function
+#define SHR_IS_INLINE                   1   //define shr as inline function
+#define L_MULT_IS_INLINE                1   //define L_mult as inline function
+#define L_MSU_IS_INLINE                 1   //define L_msu as inline function
+#define L_SUB_IS_INLINE                 1   //define L_sub as inline function
+#define L_SHL_IS_INLINE                 1   //define L_shl as inline function
+#define L_SHR_IS_INLINE                 1   //define L_shr as inline function
+#define ADD_IS_INLINE                   1   //define add as inline function //add, inline is the best
+#define SUB_IS_INLINE                   1   //define sub as inline function //sub, inline is the best
+#define DIV_S_IS_INLINE                 1   //define div_s as inline function
+#define MULT_IS_INLINE                  1   //define mult as inline function
+#define NORM_S_IS_INLINE                1   //define norm_s as inline function
+#define NORM_L_IS_INLINE                1   //define norm_l as inline function
+#define ROUND_IS_INLINE                 1   //define round as inline function
+#define L_MAC_IS_INLINE                 1   //define L_mac as inline function
+#define L_ADD_IS_INLINE                 1   //define L_add as inline function
+#define EXTRACT_H_IS_INLINE             1   //define extract_h as inline function
+#define EXTRACT_L_IS_INLINE             1   //define extract_l as inline function        //???
+#define MULT_R_IS_INLINE                1   //define mult_r as inline function
+#define SHR_R_IS_INLINE                 1   //define shr_r as inline function
+#define MAC_R_IS_INLINE                 1   //define mac_r as inline function
+#define MSU_R_IS_INLINE                 1   //define msu_r as inline function
+#define L_SHR_R_IS_INLINE               1   //define L_shr_r as inline function
+
+#define PREFIX				voAACEnc
+#define LINK0(x, y, z)		LINK1(x,y,z)
+#define LINK1(x,y,z)		x##y##z
+#define ADD_PREFIX(func)	LINK0(PREFIX, _, func)
+
+#define  L_Extract		ADD_PREFIX(L_Extract)
+#define  L_Comp			ADD_PREFIX(L_Comp)
+#define  Mpy_32			ADD_PREFIX(Mpy_32)
+#define  Mpy_32_16		ADD_PREFIX(Mpy_32_16)
+#define  Div_32			ADD_PREFIX(Div_32)
+#define  iLog4			ADD_PREFIX(iLog4)
+#define  rsqrt			ADD_PREFIX(rsqrt)
+#define  pow2_xy		ADD_PREFIX(pow2_xy)
+#define  L_mpy_ls		ADD_PREFIX(L_mpy_ls)
+#define  L_mpy_wx		ADD_PREFIX(L_mpy_wx)
+
+#define mem_malloc		ADD_PREFIX(mem_malloc)
+#define mem_free		ADD_PREFIX(mem_free)
+
 #endif
diff --git a/media/libstagefright/codecs/aacenc/build/eclair/ARMV5E/Makefile b/media/libstagefright/codecs/aacenc/build/eclair/ARMV5E/Makefile
index b4f63af..79be7da 100644
--- a/media/libstagefright/codecs/aacenc/build/eclair/ARMV5E/Makefile
+++ b/media/libstagefright/codecs/aacenc/build/eclair/ARMV5E/Makefile
@@ -1,55 +1,55 @@
-#/*
-#** Copyright 2003-2010, VisualOn, Inc.
-#**
-#** Licensed under the Apache License, Version 2.0 (the "License");
-#** you may not use this file except in compliance with the License.
-#** You may obtain a copy of the License at
-#**
-#**     http://www.apache.org/licenses/LICENSE-2.0
-#**
-#** Unless required by applicable law or agreed to in writing, software
-#** distributed under the License is distributed on an "AS IS" BASIS,
-#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#** See the License for the specific language governing permissions and
-#** limitations under the License.
-#*/
-
-# target6
-# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
-VOTT:= v5
-
-
-# module type
-# please specify the type of your module: lib or exe
-VOMT:= lib
-
-
-# module macros
-# please append the additional macro definitions here for your module if necessary. 
-# e.g. -DVISUALON, macro VISUALON defined for your module 
-VOMM:= -DARMV5E -DARM_INASM -DARMV5_INASM 
-
-
-
-# please specify the name of your module
-VOTARGET:=libvoAACEncv5
-
-
-# please modify here to be sure to see the g1.mk
-include ../../../../../Tools/eclair.mk 
-
-# dependent libraries.
-VODEPLIBS:=#-ldl -lstdc++ 
-
-# module source
-# please modify here to be sure to see the ms.mk which specifies all source info of your module
-include ../../ms.mk
-
-
-# please specify where is the voRelease on your PC, relative path is suggested
-VORELDIR:=../../../../../../Release
-
-
-# please modify here to be sure to see the doit.mk
-include ../../../../../Tools/doit.mk 
-
+#/*
+#** Copyright 2003-2010, VisualOn, Inc.
+#**
+#** Licensed under the Apache License, Version 2.0 (the "License");
+#** you may not use this file except in compliance with the License.
+#** You may obtain a copy of the License at
+#**
+#**     http://www.apache.org/licenses/LICENSE-2.0
+#**
+#** Unless required by applicable law or agreed to in writing, software
+#** distributed under the License is distributed on an "AS IS" BASIS,
+#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#** See the License for the specific language governing permissions and
+#** limitations under the License.
+#*/
+
+# target6
+# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
+VOTT:= v5
+
+
+# module type
+# please specify the type of your module: lib or exe
+VOMT:= lib
+
+
+# module macros
+# please append the additional macro definitions here for your module if necessary.
+# e.g. -DVISUALON, macro VISUALON defined for your module
+VOMM:= -DARMV5E -DARM_INASM -DARMV5_INASM
+
+
+
+# please specify the name of your module
+VOTARGET:=libvoAACEncv5
+
+
+# please modify here to be sure to see the g1.mk
+include ../../../../../Tools/eclair.mk
+
+# dependent libraries.
+VODEPLIBS:=#-ldl -lstdc++
+
+# module source
+# please modify here to be sure to see the ms.mk which specifies all source info of your module
+include ../../ms.mk
+
+
+# please specify where is the voRelease on your PC, relative path is suggested
+VORELDIR:=../../../../../../Release
+
+
+# please modify here to be sure to see the doit.mk
+include ../../../../../Tools/doit.mk
+
diff --git a/media/libstagefright/codecs/aacenc/build/eclair/ARMV7/Makefile b/media/libstagefright/codecs/aacenc/build/eclair/ARMV7/Makefile
index cdce2c1..a72c850 100644
--- a/media/libstagefright/codecs/aacenc/build/eclair/ARMV7/Makefile
+++ b/media/libstagefright/codecs/aacenc/build/eclair/ARMV7/Makefile
@@ -1,55 +1,55 @@
-#/*
-#** Copyright 2003-2010, VisualOn, Inc.
-#**
-#** Licensed under the Apache License, Version 2.0 (the "License");
-#** you may not use this file except in compliance with the License.
-#** You may obtain a copy of the License at
-#**
-#**     http://www.apache.org/licenses/LICENSE-2.0
-#**
-#** Unless required by applicable law or agreed to in writing, software
-#** distributed under the License is distributed on an "AS IS" BASIS,
-#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#** See the License for the specific language governing permissions and
-#** limitations under the License.
-#*/
-
-# target6
-# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
-VOTT:= v7
-
-
-# module type
-# please specify the type of your module: lib or exe
-VOMT:= lib
-
-
-# module macros
-# please append the additional macro definitions here for your module if necessary. 
-# e.g. -DVISUALON, macro VISUALON defined for your module 
-VOMM:= -DARMV5E -DARMV7Neon -DARM_INASM -DARMV5_INASM 
-
-
-
-# please specify the name of your module
-VOTARGET:=libvoAACEncv7
-
-
-# please modify here to be sure to see the g1.mk
-include ../../../../../Tools/eclair.mk 
-
-# dependent libraries.
-VODEPLIBS:=#-ldl -lstdc++ 
-
-# module source
-# please modify here to be sure to see the ms.mk which specifies all source info of your module
-include ../../ms.mk
-
-
-# please specify where is the voRelease on your PC, relative path is suggested
-VORELDIR:=../../../../../../Release
-
-
-# please modify here to be sure to see the doit.mk
-include ../../../../../Tools/doit.mk  
-
+#/*
+#** Copyright 2003-2010, VisualOn, Inc.
+#**
+#** Licensed under the Apache License, Version 2.0 (the "License");
+#** you may not use this file except in compliance with the License.
+#** You may obtain a copy of the License at
+#**
+#**     http://www.apache.org/licenses/LICENSE-2.0
+#**
+#** Unless required by applicable law or agreed to in writing, software
+#** distributed under the License is distributed on an "AS IS" BASIS,
+#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#** See the License for the specific language governing permissions and
+#** limitations under the License.
+#*/
+
+# target6
+# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
+VOTT:= v7
+
+
+# module type
+# please specify the type of your module: lib or exe
+VOMT:= lib
+
+
+# module macros
+# please append the additional macro definitions here for your module if necessary.
+# e.g. -DVISUALON, macro VISUALON defined for your module
+VOMM:= -DARMV5E -DARMV7Neon -DARM_INASM -DARMV5_INASM
+
+
+
+# please specify the name of your module
+VOTARGET:=libvoAACEncv7
+
+
+# please modify here to be sure to see the g1.mk
+include ../../../../../Tools/eclair.mk
+
+# dependent libraries.
+VODEPLIBS:=#-ldl -lstdc++
+
+# module source
+# please modify here to be sure to see the ms.mk which specifies all source info of your module
+include ../../ms.mk
+
+
+# please specify where is the voRelease on your PC, relative path is suggested
+VORELDIR:=../../../../../../Release
+
+
+# please modify here to be sure to see the doit.mk
+include ../../../../../Tools/doit.mk
+
diff --git a/media/libstagefright/codecs/aacenc/build/eclair/makefile b/media/libstagefright/codecs/aacenc/build/eclair/makefile
index 6bb3c13..5824d17 100644
--- a/media/libstagefright/codecs/aacenc/build/eclair/makefile
+++ b/media/libstagefright/codecs/aacenc/build/eclair/makefile
@@ -16,7 +16,7 @@
 
 # Just acting as Father Makefile of Modules
 # please keep the name 'makefile' unchanged
- 
+
 # Module Subdirs
 VOMSD:=$(dir $(shell find . -name 'Makefile'))
 
diff --git a/media/libstagefright/codecs/aacenc/build/ms.mk b/media/libstagefright/codecs/aacenc/build/ms.mk
index b67efbc..85adba1 100644
--- a/media/libstagefright/codecs/aacenc/build/ms.mk
+++ b/media/libstagefright/codecs/aacenc/build/ms.mk
@@ -1,42 +1,42 @@
-#/*
-#** Copyright 2003-2010, VisualOn, Inc.
-#**
-#** Licensed under the Apache License, Version 2.0 (the "License");
-#** you may not use this file except in compliance with the License.
-#** You may obtain a copy of the License at
-#**
-#**     http://www.apache.org/licenses/LICENSE-2.0
-#**
-#** Unless required by applicable law or agreed to in writing, software
-#** distributed under the License is distributed on an "AS IS" BASIS,
-#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#** See the License for the specific language governing permissions and
-#** limitations under the License.
-#*/
-
-
-# please list all objects needed by your target here
-OBJS:=basicop2.o oper_32b.o aac_rom.o aacenc.o aacenc_core.o adj_thr.o \
-			band_nrg.o bit_cnt.o bitbuffer.o bitenc.o block_switch.o channel_map.o \
-			dyn_bits.o grp_data.o interface.o line_pe.o memalign.o ms_stereo.o \
-			pre_echo_control.o psy_configuration.o psy_main.o qc_main.o quantize.o sf_estim.o \
-			spreading.o stat_bits.o tns.o transform.o
-			
-# please list all directories that all source files relative with your module(.h .c .cpp) locate 
-VOSRCDIR:=../../../src \
-					../../../inc \
-					../../../basic_op\
-					../../../../../Include 
-					
-ifeq ($(VOTT), v5)
-OBJS+= AutoCorrelation_v5.o band_nrg_v5.o CalcWindowEnergy_v5.o \
-				PrePostMDCT_v5.o R4R8First_v5.o Radix4FFT_v5.o
-VOSRCDIR+= ../../../src/asm/ARMV5E/
-endif	
-
-ifeq ($(VOTT), v7)
-OBJS+= AutoCorrelation_v5.o band_nrg_v5.o CalcWindowEnergy_v5.o \
-			 PrePostMDCT_v7.o R4R8First_v7.o Radix4FFT_v7.o
-VOSRCDIR+= ../../../src/asm/ARMV5E/
-VOSRCDIR+= ../../../src/asm/ARMV7/
-endif		
\ No newline at end of file
+#/*
+#** Copyright 2003-2010, VisualOn, Inc.
+#**
+#** Licensed under the Apache License, Version 2.0 (the "License");
+#** you may not use this file except in compliance with the License.
+#** You may obtain a copy of the License at
+#**
+#**     http://www.apache.org/licenses/LICENSE-2.0
+#**
+#** Unless required by applicable law or agreed to in writing, software
+#** distributed under the License is distributed on an "AS IS" BASIS,
+#** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#** See the License for the specific language governing permissions and
+#** limitations under the License.
+#*/
+
+
+# please list all objects needed by your target here
+OBJS:=basicop2.o oper_32b.o aac_rom.o aacenc.o aacenc_core.o adj_thr.o \
+			band_nrg.o bit_cnt.o bitbuffer.o bitenc.o block_switch.o channel_map.o \
+			dyn_bits.o grp_data.o interface.o line_pe.o memalign.o ms_stereo.o \
+			pre_echo_control.o psy_configuration.o psy_main.o qc_main.o quantize.o sf_estim.o \
+			spreading.o stat_bits.o tns.o transform.o
+
+# please list all directories that all source files relative with your module(.h .c .cpp) locate
+VOSRCDIR:=../../../src \
+					../../../inc \
+					../../../basic_op\
+					../../../../../Include
+
+ifeq ($(VOTT), v5)
+OBJS+= AutoCorrelation_v5.o band_nrg_v5.o CalcWindowEnergy_v5.o \
+				PrePostMDCT_v5.o R4R8First_v5.o Radix4FFT_v5.o
+VOSRCDIR+= ../../../src/asm/ARMV5E/
+endif
+
+ifeq ($(VOTT), v7)
+OBJS+= AutoCorrelation_v5.o band_nrg_v5.o CalcWindowEnergy_v5.o \
+			 PrePostMDCT_v7.o R4R8First_v7.o Radix4FFT_v7.o
+VOSRCDIR+= ../../../src/asm/ARMV5E/
+VOSRCDIR+= ../../../src/asm/ARMV7/
+endif
diff --git a/media/libstagefright/codecs/aacenc/inc/aac_rom.h b/media/libstagefright/codecs/aacenc/inc/aac_rom.h
index b0429fc..8e206b7 100644
--- a/media/libstagefright/codecs/aacenc/inc/aac_rom.h
+++ b/media/libstagefright/codecs/aacenc/inc/aac_rom.h
@@ -1,28 +1,28 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		aac_rom.h
-
-	Content:	constant tables 
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		aac_rom.h
+
+	Content:	constant tables
+
 *******************************************************************************/
 
 #ifndef ROM_H
 #define ROM_H
-
+
 #include "config.h"
 #include "psy_const.h"
 #include "tns_param.h"
@@ -31,16 +31,16 @@
   mdct
 */
 extern const int ShortWindowSine[FRAME_LEN_SHORT/2];
-extern const int LongWindowKBD[FRAME_LEN_LONG/2];
-
-extern const unsigned char bitrevTab[17 + 129];
-extern const int cossintab[128 + 1024];
-
-#if defined (ARMV5E) && !defined (ARMV7Neon)
-extern const int twidTab64[(4*6 + 16*6)/2];
-extern const int twidTab512[(8*6 + 32*6 + 128*6)/2];
-#else
-extern const int twidTab64[4*6 + 16*6];
+extern const int LongWindowKBD[FRAME_LEN_LONG/2];
+
+extern const unsigned char bitrevTab[17 + 129];
+extern const int cossintab[128 + 1024];
+
+#if defined (ARMV5E) && !defined (ARMV7Neon)
+extern const int twidTab64[(4*6 + 16*6)/2];
+extern const int twidTab512[(8*6 + 32*6 + 128*6)/2];
+#else
+extern const int twidTab64[4*6 + 16*6];
 extern const int twidTab512[8*6 + 32*6 + 128*6];
 #endif
 
@@ -61,7 +61,7 @@ extern Word32 specExpMantTableComb_enc[4][14];
 extern const UWord8 specExpTableComb_enc[4][14];
 
 extern const Word16 quantBorders[4][4];
-//extern const Word16 quantRecon[3][4];
+//extern const Word16 quantRecon[3][4];
 extern const Word16 quantRecon[4][3];
 
 /*
@@ -92,26 +92,26 @@ extern const UWord32 huff_ctabscf[121];
 /*
   misc
 */
-extern const int sampRateTab[NUM_SAMPLE_RATES];
-extern const int BandwithCoefTab[8][NUM_SAMPLE_RATES];
-extern const int rates[8];
-extern const UWord8 sfBandTotalShort[NUM_SAMPLE_RATES];
-extern const UWord8 sfBandTotalLong[NUM_SAMPLE_RATES];
-extern const int sfBandTabShortOffset[NUM_SAMPLE_RATES];
-extern const short sfBandTabShort[76];
-extern const int sfBandTabLongOffset[NUM_SAMPLE_RATES];
-extern const short sfBandTabLong[325];
+extern const int sampRateTab[NUM_SAMPLE_RATES];
+extern const int BandwithCoefTab[8][NUM_SAMPLE_RATES];
+extern const int rates[8];
+extern const UWord8 sfBandTotalShort[NUM_SAMPLE_RATES];
+extern const UWord8 sfBandTotalLong[NUM_SAMPLE_RATES];
+extern const int sfBandTabShortOffset[NUM_SAMPLE_RATES];
+extern const short sfBandTabShort[76];
+extern const int sfBandTabLongOffset[NUM_SAMPLE_RATES];
+extern const short sfBandTabLong[325];
 
 extern const Word32 m_log2_table[INT_BITS];
 
 /*
   TNS
 */
-extern const Word32 tnsCoeff3[8];
-extern const Word32 tnsCoeff3Borders[8];
-extern const Word32 tnsCoeff4[16];
-extern const Word32 tnsCoeff4Borders[16];
-extern const Word32 invSBF[24];
-extern const Word16 sideInfoTabLong[MAX_SFB_LONG + 1];
+extern const Word32 tnsCoeff3[8];
+extern const Word32 tnsCoeff3Borders[8];
+extern const Word32 tnsCoeff4[16];
+extern const Word32 tnsCoeff4Borders[16];
+extern const Word32 invSBF[24];
+extern const Word16 sideInfoTabLong[MAX_SFB_LONG + 1];
 extern const Word16 sideInfoTabShort[MAX_SFB_SHORT + 1];
 #endif
diff --git a/media/libstagefright/codecs/aacenc/inc/aacenc_core.h b/media/libstagefright/codecs/aacenc/inc/aacenc_core.h
index faa1d20..1acdbbc 100644
--- a/media/libstagefright/codecs/aacenc/inc/aacenc_core.h
+++ b/media/libstagefright/codecs/aacenc/inc/aacenc_core.h
@@ -1,37 +1,37 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		aacenc_core.h
-
-	Content:	aac encoder interface functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		aacenc_core.h
+
+	Content:	aac encoder interface functions
+
 *******************************************************************************/
 
 #ifndef _aacenc_core_h_
 #define _aacenc_core_h_
 
-
+
 #include "typedef.h"
-#include "config.h"
-#include "bitenc.h"
-
-#include "psy_configuration.h"
-#include "psy_main.h"
-#include "qc_main.h"
-#include "psy_main.h"
+#include "config.h"
+#include "bitenc.h"
+
+#include "psy_configuration.h"
+#include "psy_main.h"
+#include "qc_main.h"
+#include "psy_main.h"
 /*-------------------------- defines --------------------------------------*/
 
 
@@ -41,42 +41,42 @@ typedef  struct {
   Word32   bitRate;               /* encoder bit rate in bits/sec */
   Word16   nChannelsIn;           /* number of channels on input (1,2) */
   Word16   nChannelsOut;          /* number of channels on output (1,2) */
-  Word16   bandWidth;             /* targeted audio bandwidth in Hz */
+  Word16   bandWidth;             /* targeted audio bandwidth in Hz */
   Word16   adtsUsed;			  /* whether write adts header */
 } AACENC_CONFIG;
-
-
-typedef struct {
-	
-  AACENC_CONFIG config;     /* Word16 size: 8 */
-
-  ELEMENT_INFO elInfo;      /* Word16 size: 4 */
-
-  QC_STATE qcKernel;        /* Word16 size: 6 + 5(PADDING) + 7(ELEMENT_BITS) + 54(ADJ_THR_STATE) = 72 */
-  QC_OUT   qcOut;           /* Word16 size: MAX_CHANNELS*920(QC_OUT_CHANNEL) + 5(QC_OUT_ELEMENT) + 7 = 932 / 1852 */
-
-  PSY_OUT    psyOut;        /* Word16 size: MAX_CHANNELS*186 + 2 = 188 / 374 */
-  PSY_KERNEL psyKernel;     /* Word16 size:  2587 / 4491 */
-
-  struct BITSTREAMENCODER_INIT bseInit; /* Word16 size: 6 */
-  struct BIT_BUF  bitStream;            /* Word16 size: 8 */
-  HANDLE_BIT_BUF  hBitStream;
-  int			  initOK;
-
-  short			*intbuf;
-  short			*encbuf;
-  short			*inbuf;
-  int			enclen;
-  int			inlen;
-  int			intlen;
-  int			uselength;
-
-  void			*hCheck;
-  VO_MEM_OPERATOR *voMemop;
-  VO_MEM_OPERATOR voMemoprator;
-
-}AAC_ENCODER; /* Word16 size: 3809 / 6851 */
-
+
+
+typedef struct {
+
+  AACENC_CONFIG config;     /* Word16 size: 8 */
+
+  ELEMENT_INFO elInfo;      /* Word16 size: 4 */
+
+  QC_STATE qcKernel;        /* Word16 size: 6 + 5(PADDING) + 7(ELEMENT_BITS) + 54(ADJ_THR_STATE) = 72 */
+  QC_OUT   qcOut;           /* Word16 size: MAX_CHANNELS*920(QC_OUT_CHANNEL) + 5(QC_OUT_ELEMENT) + 7 = 932 / 1852 */
+
+  PSY_OUT    psyOut;        /* Word16 size: MAX_CHANNELS*186 + 2 = 188 / 374 */
+  PSY_KERNEL psyKernel;     /* Word16 size:  2587 / 4491 */
+
+  struct BITSTREAMENCODER_INIT bseInit; /* Word16 size: 6 */
+  struct BIT_BUF  bitStream;            /* Word16 size: 8 */
+  HANDLE_BIT_BUF  hBitStream;
+  int			  initOK;
+
+  short			*intbuf;
+  short			*encbuf;
+  short			*inbuf;
+  int			enclen;
+  int			inlen;
+  int			intlen;
+  int			uselength;
+
+  void			*hCheck;
+  VO_MEM_OPERATOR *voMemop;
+  VO_MEM_OPERATOR voMemoprator;
+
+}AAC_ENCODER; /* Word16 size: 3809 / 6851 */
+
 /*-----------------------------------------------------------------------------
 
 functionname: AacInitDefaultConfig
diff --git a/media/libstagefright/codecs/aacenc/inc/adj_thr.h b/media/libstagefright/codecs/aacenc/inc/adj_thr.h
index 4057cbe..0f4bb5e 100644
--- a/media/libstagefright/codecs/aacenc/inc/adj_thr.h
+++ b/media/libstagefright/codecs/aacenc/inc/adj_thr.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		adj_thr.h
-
-	Content:	Threshold compensation function 
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		adj_thr.h
+
+	Content:	Threshold compensation function
+
 *******************************************************************************/
 
 #ifndef __ADJ_THR_H
@@ -44,7 +44,7 @@ void AdjustThresholds(ADJ_THR_STATE *adjThrState,
                       PSY_OUT_ELEMENT *psyOutElement,
                       Word16 *chBitDistribution,
                       Word16 logSfbEnergy[MAX_CHANNELS][MAX_GROUPED_SFB],
-                      Word16 sfbNRelevantLines[MAX_CHANNELS][MAX_GROUPED_SFB],                      
+                      Word16 sfbNRelevantLines[MAX_CHANNELS][MAX_GROUPED_SFB],
                       QC_OUT_ELEMENT* qcOE,
 					  ELEMENT_BITS* elBits,
 					  const Word16 nChannels,
diff --git a/media/libstagefright/codecs/aacenc/inc/adj_thr_data.h b/media/libstagefright/codecs/aacenc/inc/adj_thr_data.h
index 25dd437..30132d8 100644
--- a/media/libstagefright/codecs/aacenc/inc/adj_thr_data.h
+++ b/media/libstagefright/codecs/aacenc/inc/adj_thr_data.h
@@ -1,29 +1,29 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		adj_thr_data.h
-
-	Content:	Threshold compensation parameter 
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		adj_thr_data.h
+
+	Content:	Threshold compensation parameter
+
 *******************************************************************************/
 
 #ifndef __ADJ_THR_DATA_H
 #define __ADJ_THR_DATA_H
 
-#include "typedef.h"
+#include "typedef.h"
 #include "psy_const.h"
 #include "line_pe.h"
 
diff --git a/media/libstagefright/codecs/aacenc/inc/band_nrg.h b/media/libstagefright/codecs/aacenc/inc/band_nrg.h
index 68509da..65453c0 100644
--- a/media/libstagefright/codecs/aacenc/inc/band_nrg.h
+++ b/media/libstagefright/codecs/aacenc/inc/band_nrg.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		band_nrg.h
-
-	Content:	Band/Line energy calculations functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		band_nrg.h
+
+	Content:	Band/Line energy calculations functions
+
 *******************************************************************************/
 
 
diff --git a/media/libstagefright/codecs/aacenc/inc/bit_cnt.h b/media/libstagefright/codecs/aacenc/inc/bit_cnt.h
index 808319e..266a219 100644
--- a/media/libstagefright/codecs/aacenc/inc/bit_cnt.h
+++ b/media/libstagefright/codecs/aacenc/inc/bit_cnt.h
@@ -1,29 +1,29 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		bit_cnt.h
-
-	Content:	Huffman Bitcounter & coder structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		bit_cnt.h
+
+	Content:	Huffman Bitcounter & coder structure and functions
+
 *******************************************************************************/
 
 #ifndef __BITCOUNT_H
 #define __BITCOUNT_H
 
-#include "bitbuffer.h"
+#include "bitbuffer.h"
 #include "basic_op.h"
 #define INVALID_BITCOUNT (MAX_16/4)
 
diff --git a/media/libstagefright/codecs/aacenc/inc/bitbuffer.h b/media/libstagefright/codecs/aacenc/inc/bitbuffer.h
index cb850c9..e538064 100644
--- a/media/libstagefright/codecs/aacenc/inc/bitbuffer.h
+++ b/media/libstagefright/codecs/aacenc/inc/bitbuffer.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		bitbuffer.h
-
-	Content:	Bit Buffer Management structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		bitbuffer.h
+
+	Content:	Bit Buffer Management structure and functions
+
 *******************************************************************************/
 
 #ifndef BITBUFFER_H
diff --git a/media/libstagefright/codecs/aacenc/inc/bitenc.h b/media/libstagefright/codecs/aacenc/inc/bitenc.h
index 1151057..6a58aeb 100644
--- a/media/libstagefright/codecs/aacenc/inc/bitenc.h
+++ b/media/libstagefright/codecs/aacenc/inc/bitenc.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		bitenc.h
-
-	Content:	Bitstream encoder structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		bitenc.h
+
+	Content:	Bitstream encoder structure and functions
+
 *******************************************************************************/
 
 #ifndef _BITENC_H
@@ -26,7 +26,7 @@
 #include "qc_data.h"
 #include "tns.h"
 #include "channel_map.h"
-#include "interface.h"  
+#include "interface.h"
 
 struct BITSTREAMENCODER_INIT
 {
@@ -42,8 +42,8 @@ Word16 WriteBitstream (HANDLE_BIT_BUF hBitstream,
                        ELEMENT_INFO elInfo,
                        QC_OUT *qcOut,
                        PSY_OUT *psyOut,
-                       Word16 *globUsedBits,
-                       const UWord8 *ancBytes,
+                       Word16 *globUsedBits,
+                       const UWord8 *ancBytes,
 					   Word16 samplerate
                        );
 
diff --git a/media/libstagefright/codecs/aacenc/inc/block_switch.h b/media/libstagefright/codecs/aacenc/inc/block_switch.h
index 3e35819..a4d3e8f 100644
--- a/media/libstagefright/codecs/aacenc/inc/block_switch.h
+++ b/media/libstagefright/codecs/aacenc/inc/block_switch.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		block_switch.h
-
-	Content:	Block switching structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		block_switch.h
+
+	Content:	Block switching structure and functions
+
 *******************************************************************************/
 
 #ifndef _BLOCK_SWITCH_H
diff --git a/media/libstagefright/codecs/aacenc/inc/channel_map.h b/media/libstagefright/codecs/aacenc/inc/channel_map.h
index e3aa8dc..c361feb 100644
--- a/media/libstagefright/codecs/aacenc/inc/channel_map.h
+++ b/media/libstagefright/codecs/aacenc/inc/channel_map.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		channel_map.h
-
-	Content:	channel mapping functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		channel_map.h
+
+	Content:	channel mapping functions
+
 *******************************************************************************/
 
 #ifndef _CHANNEL_MAP_H
diff --git a/media/libstagefright/codecs/aacenc/inc/config.h b/media/libstagefright/codecs/aacenc/inc/config.h
index 6211c8f..3b29cef 100644
--- a/media/libstagefright/codecs/aacenc/inc/config.h
+++ b/media/libstagefright/codecs/aacenc/inc/config.h
@@ -1,36 +1,36 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		config.h
-
-	Content:	aac encoder parameter
-
-*******************************************************************************/
-
-#ifndef _AACENC_CONFIG_H_
-#define _AACENC_CONFIG_H_
-
-#define MAX_CHANNELS        2
-
-#define AACENC_BLOCKSIZE    1024   /*! encoder only takes BLOCKSIZE samples at a time */
-#define AACENC_TRANS_FAC    8      /*! encoder short long ratio */
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		config.h
+
+	Content:	aac encoder parameter
+
+*******************************************************************************/
+
+#ifndef _AACENC_CONFIG_H_
+#define _AACENC_CONFIG_H_
+
+#define MAX_CHANNELS        2
+
+#define AACENC_BLOCKSIZE    1024   /*! encoder only takes BLOCKSIZE samples at a time */
+#define AACENC_TRANS_FAC    8      /*! encoder short long ratio */
+
+
 #define MAXBITS_COEF		6144
-#define MINBITS_COEF		744
-
-
+#define MINBITS_COEF		744
+
+
 #endif
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/inc/dyn_bits.h b/media/libstagefright/codecs/aacenc/inc/dyn_bits.h
index 0468fa2..d3a8a67 100644
--- a/media/libstagefright/codecs/aacenc/inc/dyn_bits.h
+++ b/media/libstagefright/codecs/aacenc/inc/dyn_bits.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		dyn_bits.h
-
-	Content:	Noiseless coder module structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		dyn_bits.h
+
+	Content:	Noiseless coder module structure and functions
+
 *******************************************************************************/
 
 #ifndef __DYN_BITS_H
diff --git a/media/libstagefright/codecs/aacenc/inc/grp_data.h b/media/libstagefright/codecs/aacenc/inc/grp_data.h
index 9666577..4c1b2cb 100644
--- a/media/libstagefright/codecs/aacenc/inc/grp_data.h
+++ b/media/libstagefright/codecs/aacenc/inc/grp_data.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		grp_data.h
-
-	Content:	Short block grouping function
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		grp_data.h
+
+	Content:	Short block grouping function
+
 *******************************************************************************/
 
 #ifndef __GRP_DATA_H__
diff --git a/media/libstagefright/codecs/aacenc/inc/interface.h b/media/libstagefright/codecs/aacenc/inc/interface.h
index b84334a..a42e6a9 100644
--- a/media/libstagefright/codecs/aacenc/inc/interface.h
+++ b/media/libstagefright/codecs/aacenc/inc/interface.h
@@ -1,29 +1,29 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		interface.h
-
-	Content:	psychoaccoustic/quantizer structures and interface
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		interface.h
+
+	Content:	psychoaccoustic/quantizer structures and interface
+
 *******************************************************************************/
 
 #ifndef _INTERFACE_H
 #define _INTERFACE_H
 
-#include "config.h"
+#include "config.h"
 #include "psy_const.h"
 #include "psy_data.h"
 #include "typedefs.h"
@@ -55,11 +55,11 @@ typedef struct {
   Word16  windowShape;
   Word16  groupingMask;
   Word16  sfbOffsets[MAX_GROUPED_SFB+1];
-  Word16  mdctScale; 
-  Word32 *sfbEnergy; 
+  Word16  mdctScale;
+  Word32 *sfbEnergy;
   Word32 *sfbSpreadedEnergy;
-  Word32 *sfbThreshold;       
-  Word32 *mdctSpectrum;        
+  Word32 *sfbThreshold;
+  Word32 *mdctSpectrum;
   Word32  sfbEnSumLR;
   Word32  sfbEnSumMS;
   Word32 sfbDist[MAX_GROUPED_SFB];
diff --git a/media/libstagefright/codecs/aacenc/inc/line_pe.h b/media/libstagefright/codecs/aacenc/inc/line_pe.h
index fed938b..116d5a8 100644
--- a/media/libstagefright/codecs/aacenc/inc/line_pe.h
+++ b/media/libstagefright/codecs/aacenc/inc/line_pe.h
@@ -1,31 +1,31 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		line_pe.h
-
-	Content:	Perceptual entropie module structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		line_pe.h
+
+	Content:	Perceptual entropie module structure and functions
+
 *******************************************************************************/
 
 #ifndef __LINE_PE_H
 #define __LINE_PE_H
 
 
-#include "psy_const.h" 
-#include "interface.h" 
+#include "psy_const.h"
+#include "interface.h"
 
 
 typedef struct {
@@ -72,4 +72,4 @@ void calcSfbPe(PE_DATA *peData,
 
 
 
-#endif 
+#endif
diff --git a/media/libstagefright/codecs/aacenc/inc/memalign.h b/media/libstagefright/codecs/aacenc/inc/memalign.h
index 3b302a7..30bbf45 100644
--- a/media/libstagefright/codecs/aacenc/inc/memalign.h
+++ b/media/libstagefright/codecs/aacenc/inc/memalign.h
@@ -1,35 +1,35 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		memalign.h
-
-	Content:	Memory alloc alignments functions
-
-*******************************************************************************/
-
-#ifndef __VO_AACENC_MEM_ALIGN_H__
-#define __VO_AACENC_MEM_ALIGN_H__
-
-#include "voMem.h"
-#include "typedef.h"
-
-extern void *mem_malloc(VO_MEM_OPERATOR *pMemop, unsigned int size, unsigned char alignment, unsigned int CodecID);
-extern void mem_free(VO_MEM_OPERATOR *pMemop, void *mem_ptr, unsigned int CodecID);
-
-#endif	/* __VO_MEM_ALIGN_H__ */
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		memalign.h
+
+	Content:	Memory alloc alignments functions
+
+*******************************************************************************/
+
+#ifndef __VO_AACENC_MEM_ALIGN_H__
+#define __VO_AACENC_MEM_ALIGN_H__
+
+#include "voMem.h"
+#include "typedef.h"
+
+extern void *mem_malloc(VO_MEM_OPERATOR *pMemop, unsigned int size, unsigned char alignment, unsigned int CodecID);
+extern void mem_free(VO_MEM_OPERATOR *pMemop, void *mem_ptr, unsigned int CodecID);
+
+#endif	/* __VO_MEM_ALIGN_H__ */
+
+
+
diff --git a/media/libstagefright/codecs/aacenc/inc/ms_stereo.h b/media/libstagefright/codecs/aacenc/inc/ms_stereo.h
index 6d43dec..3c03dea 100644
--- a/media/libstagefright/codecs/aacenc/inc/ms_stereo.h
+++ b/media/libstagefright/codecs/aacenc/inc/ms_stereo.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		ms_stereo.h
-
-	Content:	Declaration MS stereo processing structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		ms_stereo.h
+
+	Content:	Declaration MS stereo processing structure and functions
+
 *******************************************************************************/
 
 #ifndef __MS_STEREO_H__
diff --git a/media/libstagefright/codecs/aacenc/inc/pre_echo_control.h b/media/libstagefright/codecs/aacenc/inc/pre_echo_control.h
index 35f36e8..e719ba7 100644
--- a/media/libstagefright/codecs/aacenc/inc/pre_echo_control.h
+++ b/media/libstagefright/codecs/aacenc/inc/pre_echo_control.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		pre_echo_control.h
-
-	Content:	Pre echo control functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		pre_echo_control.h
+
+	Content:	Pre echo control functions
+
 *******************************************************************************/
 
 #ifndef __PRE_ECHO_CONTROL_H
diff --git a/media/libstagefright/codecs/aacenc/inc/psy_configuration.h b/media/libstagefright/codecs/aacenc/inc/psy_configuration.h
index 53cf25b..9abfc99 100644
--- a/media/libstagefright/codecs/aacenc/inc/psy_configuration.h
+++ b/media/libstagefright/codecs/aacenc/inc/psy_configuration.h
@@ -1,28 +1,28 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		psy_configuration.h
-
-	Content:	Psychoaccoustic configuration structure and functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		psy_configuration.h
+
+	Content:	Psychoaccoustic configuration structure and functions
+
 *******************************************************************************/
 
 #ifndef _PSY_CONFIGURATION_H
 #define _PSY_CONFIGURATION_H
-
+
 #include "typedefs.h"
 #include "psy_const.h"
 #include "tns.h"
@@ -38,7 +38,7 @@ typedef struct{
   Word16 maxAllowedIncreaseFactor;   /* preecho control */
   Word16 minRemainingThresholdFactor;
 
-  Word16 lowpassLine;
+  Word16 lowpassLine;
   Word16 sampRateIdx;
   Word32 clipEnergy;                 /* for level dependend tmn */
 
@@ -68,7 +68,7 @@ typedef struct{
   Word16 maxAllowedIncreaseFactor;   /* preecho control */
   Word16 minRemainingThresholdFactor;
 
-  Word16 lowpassLine;
+  Word16 lowpassLine;
   Word16 sampRateIdx;
   Word32 clipEnergy;                 /* for level dependend tmn */
 
@@ -85,10 +85,10 @@ typedef struct{
   TNS_CONFIG tnsConf;
 
 }PSY_CONFIGURATION_SHORT; /*Word16 size: 8 + 16 + 16 + 16 + 16 + 16 + 16 + 16 + 47 = 167 */
-
-
-/* Returns the sample rate index */
-Word32 GetSRIndex(Word32 sampleRate);
+
+
+/* Returns the sample rate index */
+Word32 GetSRIndex(Word32 sampleRate);
 
 
 Word16 InitPsyConfigurationLong(Word32 bitrate,
diff --git a/media/libstagefright/codecs/aacenc/inc/psy_const.h b/media/libstagefright/codecs/aacenc/inc/psy_const.h
index 5455ab1..19fb9b2 100644
--- a/media/libstagefright/codecs/aacenc/inc/psy_const.h
+++ b/media/libstagefright/codecs/aacenc/inc/psy_const.h
@@ -1,37 +1,37 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		psy_const.h
-
-	Content:	Global psychoacoustic constants structures
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		psy_const.h
+
+	Content:	Global psychoacoustic constants structures
+
 *******************************************************************************/
 
 #ifndef _PSYCONST_H
 #define _PSYCONST_H
 
-#include "config.h"
+#include "config.h"
 
 #define TRUE  1
 #define FALSE 0
 
 #define FRAME_LEN_LONG    AACENC_BLOCKSIZE
 #define TRANS_FAC         8
-#define FRAME_LEN_SHORT   (FRAME_LEN_LONG/TRANS_FAC)
-
+#define FRAME_LEN_SHORT   (FRAME_LEN_LONG/TRANS_FAC)
+
 
 
 /* Block types */
@@ -69,12 +69,12 @@ enum
 
 #define BLOCK_SWITCHING_OFFSET		   (1*1024+3*128+64+128)
 #define BLOCK_SWITCHING_DATA_SIZE          FRAME_LEN_LONG
-										    
+
 #define TRANSFORM_OFFSET_LONG    0
 #define TRANSFORM_OFFSET_SHORT   448
 
 #define LOG_NORM_PCM          -15
-
+
 #define NUM_SAMPLE_RATES	12
 
 #endif /* _PSYCONST_H */
diff --git a/media/libstagefright/codecs/aacenc/inc/psy_data.h b/media/libstagefright/codecs/aacenc/inc/psy_data.h
index 1412d53..3ea6a84 100644
--- a/media/libstagefright/codecs/aacenc/inc/psy_data.h
+++ b/media/libstagefright/codecs/aacenc/inc/psy_data.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		psy_data.h
-
-	Content:	Psychoacoustic data and structures
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		psy_data.h
+
+	Content:	Psychoacoustic data and structures
+
 *******************************************************************************/
 
 #ifndef _PSY_DATA_H
diff --git a/media/libstagefright/codecs/aacenc/inc/psy_main.h b/media/libstagefright/codecs/aacenc/inc/psy_main.h
index ab0b8b1..2ccac60 100644
--- a/media/libstagefright/codecs/aacenc/inc/psy_main.h
+++ b/media/libstagefright/codecs/aacenc/inc/psy_main.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		psy_main.h
-
-	Content:	Psychoacoustic major function block
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		psy_main.h
+
+	Content:	Psychoacoustic major function block
+
 *******************************************************************************/
 
 #ifndef _PSYMAIN_H
@@ -35,7 +35,7 @@ typedef struct  {
   PSY_CONFIGURATION_SHORT psyConfShort;          /* Word16 size: 167 */
   PSY_DATA                psyData[MAX_CHANNELS]; /* Word16 size: MAX_CHANNELS*1669*/
   TNS_DATA                tnsData[MAX_CHANNELS]; /* Word16 size: MAX_CHANNELS*235 */
-  Word32*                 pScratchTns;
+  Word32*                 pScratchTns;
   Word16				  sampleRateIdx;
 }PSY_KERNEL; /* Word16 size: 2587 / 4491 */
 
@@ -54,9 +54,9 @@ Word16 psyMainInit( PSY_KERNEL *hPsy,
                     Word16 bandwidth);
 
 
-Word16 psyMain(Word16                   nChannels,   /*!< total number of channels */              
+Word16 psyMain(Word16                   nChannels,   /*!< total number of channels */
                ELEMENT_INFO             *elemInfo,
-               Word16                   *timeSignal, /*!< interleaved time signal */ 
+               Word16                   *timeSignal, /*!< interleaved time signal */
                PSY_DATA                 psyData[MAX_CHANNELS],
                TNS_DATA                 tnsData[MAX_CHANNELS],
                PSY_CONFIGURATION_LONG*  psyConfLong,
diff --git a/media/libstagefright/codecs/aacenc/inc/qc_data.h b/media/libstagefright/codecs/aacenc/inc/qc_data.h
index 81d4051..109922d 100644
--- a/media/libstagefright/codecs/aacenc/inc/qc_data.h
+++ b/media/libstagefright/codecs/aacenc/inc/qc_data.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		qc_data.h
-
-	Content:	Quantizing & coding structures
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		qc_data.h
+
+	Content:	Quantizing & coding structures
+
 *******************************************************************************/
 
 #ifndef _QC_DATA_H
@@ -89,7 +89,7 @@ typedef struct
 
 typedef struct
 {
-  Word16		  adtsUsed;
+  Word16		  adtsUsed;
   Word16          staticBitsUsed; /* for verification purposes */
   Word16          dynBitsUsed;    /* for verification purposes */
   Word16          pe;
diff --git a/media/libstagefright/codecs/aacenc/inc/qc_main.h b/media/libstagefright/codecs/aacenc/inc/qc_main.h
index e1138b2..8f83973 100644
--- a/media/libstagefright/codecs/aacenc/inc/qc_main.h
+++ b/media/libstagefright/codecs/aacenc/inc/qc_main.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		qc_main.h
-
-	Content:	Quantizing & coding functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		qc_main.h
+
+	Content:	Quantizing & coding functions
+
 *******************************************************************************/
 
 #ifndef _QC_MAIN_H
@@ -35,7 +35,7 @@ void QCOutDelete(QC_OUT *hQC, VO_MEM_OPERATOR *pMemOP);
 
 Word16 QCNew(QC_STATE *hQC, VO_MEM_OPERATOR *pMemOP);
 
-Word16 QCInit(QC_STATE *hQC, 
+Word16 QCInit(QC_STATE *hQC,
               struct QC_INIT *init);
 
 void QCDelete(QC_STATE *hQC, VO_MEM_OPERATOR *pMemOP);
diff --git a/media/libstagefright/codecs/aacenc/inc/quantize.h b/media/libstagefright/codecs/aacenc/inc/quantize.h
index 88a95e1..1cafef6 100644
--- a/media/libstagefright/codecs/aacenc/inc/quantize.h
+++ b/media/libstagefright/codecs/aacenc/inc/quantize.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		quantize.h
-
-	Content:	Quantization functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		quantize.h
+
+	Content:	Quantization functions
+
 *******************************************************************************/
 
 #ifndef _QUANTIZE_H_
@@ -28,7 +28,7 @@
 
 #define MAX_QUANT 8191
 
-void QuantizeSpectrum(Word16 sfbCnt, 
+void QuantizeSpectrum(Word16 sfbCnt,
                       Word16 maxSfbPerGroup,
                       Word16 sfbPerGroup,
                       Word16 *sfbOffset, Word32 *mdctSpectrum,
diff --git a/media/libstagefright/codecs/aacenc/inc/sf_estim.h b/media/libstagefright/codecs/aacenc/inc/sf_estim.h
index b25ec3c..9039f25 100644
--- a/media/libstagefright/codecs/aacenc/inc/sf_estim.h
+++ b/media/libstagefright/codecs/aacenc/inc/sf_estim.h
@@ -1,29 +1,29 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		sf_estim.h
-
-	Content:	Scale factor estimation functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		sf_estim.h
+
+	Content:	Scale factor estimation functions
+
 *******************************************************************************/
 
 #ifndef __SF_ESTIM_H__
 #define __SF_ESTIM_H__
 /*
-   Scale factor estimation 
+   Scale factor estimation
  */
 #include "psy_const.h"
 #include "interface.h"
diff --git a/media/libstagefright/codecs/aacenc/inc/spreading.h b/media/libstagefright/codecs/aacenc/inc/spreading.h
index 29cf63d..0c96fc7 100644
--- a/media/libstagefright/codecs/aacenc/inc/spreading.h
+++ b/media/libstagefright/codecs/aacenc/inc/spreading.h
@@ -1,29 +1,29 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		spreading.h
-
-	Content:	Spreading of energy functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		spreading.h
+
+	Content:	Spreading of energy functions
+
 *******************************************************************************/
 
 #ifndef _SPREADING_H
 #define _SPREADING_H
 #include "typedefs.h"
-
+
 
 void SpreadingMax(const Word16 pbCnt,
                   const Word16 *maskLowFactor,
diff --git a/media/libstagefright/codecs/aacenc/inc/stat_bits.h b/media/libstagefright/codecs/aacenc/inc/stat_bits.h
index 6e90b9c..9cddc1d 100644
--- a/media/libstagefright/codecs/aacenc/inc/stat_bits.h
+++ b/media/libstagefright/codecs/aacenc/inc/stat_bits.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		stat_bits.h
-
-	Content:	Static bit counter functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		stat_bits.h
+
+	Content:	Static bit counter functions
+
 *******************************************************************************/
 
 #ifndef __STAT_BITS_H
@@ -28,7 +28,7 @@
 
 Word16 countStaticBitdemand(PSY_OUT_CHANNEL psyOutChannel[MAX_CHANNELS],
                             PSY_OUT_ELEMENT *psyOutElement,
-                            Word16 nChannels, 
+                            Word16 nChannels,
 							Word16 adtsUsed);
 
 #endif /* __STAT_BITS_H */
diff --git a/media/libstagefright/codecs/aacenc/inc/tns.h b/media/libstagefright/codecs/aacenc/inc/tns.h
index 9ffcce9..40cfaee 100644
--- a/media/libstagefright/codecs/aacenc/inc/tns.h
+++ b/media/libstagefright/codecs/aacenc/inc/tns.h
@@ -1,28 +1,28 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		tns.h
-
-	Content:	TNS structures
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		tns.h
+
+	Content:	TNS structures
+
 *******************************************************************************/
 
 #ifndef _TNS_H
 #define _TNS_H
-
+
 #include "typedef.h"
 #include "psy_const.h"
 
diff --git a/media/libstagefright/codecs/aacenc/inc/tns_func.h b/media/libstagefright/codecs/aacenc/inc/tns_func.h
index 58b75b6..02df24d 100644
--- a/media/libstagefright/codecs/aacenc/inc/tns_func.h
+++ b/media/libstagefright/codecs/aacenc/inc/tns_func.h
@@ -1,30 +1,30 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		tns_func.h
-
-	Content:	TNS functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		tns_func.h
+
+	Content:	TNS functions
+
 *******************************************************************************/
 
 /*
    Temporal noise shaping
  */
 #ifndef _TNS_FUNC_H
-#define _TNS_FUNC_H
+#define _TNS_FUNC_H
 #include "typedef.h"
 #include "psy_configuration.h"
 
diff --git a/media/libstagefright/codecs/aacenc/inc/tns_param.h b/media/libstagefright/codecs/aacenc/inc/tns_param.h
index 26266ac..0aa33c3 100644
--- a/media/libstagefright/codecs/aacenc/inc/tns_param.h
+++ b/media/libstagefright/codecs/aacenc/inc/tns_param.h
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		tns_param.h
-
-	Content:	TNS parameters
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		tns_param.h
+
+	Content:	TNS parameters
+
 *******************************************************************************/
 
 /*
@@ -44,7 +44,7 @@ typedef struct{
 }TNS_INFO_TAB;
 
 
-void GetTnsParam(TNS_CONFIG_TABULATED *tnsConfigTab, 
+void GetTnsParam(TNS_CONFIG_TABULATED *tnsConfigTab,
                  Word32 bitRate, Word16 channels, Word16 blockType);
 
 void GetTnsMaxBands(Word32 samplingRate, Word16 blockType, Word16* tnsMaxSfb);
diff --git a/media/libstagefright/codecs/aacenc/inc/transform.h b/media/libstagefright/codecs/aacenc/inc/transform.h
index 2666914..fbac7aa 100644
--- a/media/libstagefright/codecs/aacenc/inc/transform.h
+++ b/media/libstagefright/codecs/aacenc/inc/transform.h
@@ -1,30 +1,30 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		transform.h
-
-	Content:	MDCT Transform functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		transform.h
+
+	Content:	MDCT Transform functions
+
 *******************************************************************************/
 
 #ifndef  __TRANSFORM_H__
 #define __TRANSFORM_H__
 
 #include "typedef.h"
-                  
+
 void Transform_Real(Word16 *mdctDelayBuffer,
                     Word16 *timeSignal,
                     Word16 chIncrement,     /*! channel increment */
diff --git a/media/libstagefright/codecs/aacenc/src/aac_rom.c b/media/libstagefright/codecs/aacenc/src/aac_rom.c
index 2ce0352..08792e8 100644
--- a/media/libstagefright/codecs/aacenc/src/aac_rom.c
+++ b/media/libstagefright/codecs/aacenc/src/aac_rom.c
@@ -1,1045 +1,1045 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		aac_rom.c
-
-	Content:	constant tables
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		aac_rom.c
+
+	Content:	constant tables
+
 *******************************************************************************/
 
-#include "aac_rom.h"
-
-#if defined (ARMV5E) && !defined (ARMV7Neon)
-
-/* 
- *  Q30 for 128 and 1024 
- *
- * for (i = 0; i < num/4; i++) {
- *   angle = (i + 0.125) * M_PI / num;
- *   x = cos(angle) * (1 << 30);
- *   x = sin(angle) * (1 << 30);
- * 
- *   angle = (num/2 - 1 - i + 0.125) * M_PI / num;
- *   x = cos(angle) * (1 << 30);
- *   x = sin(angle) * (1 << 30);
- * }
- */
-const int cossintab[128 + 1024] = {
-	/* 128 */
-	0x3fffec43, 0x003243f1, 0x015fd4d2, 0x3ffc38d1, 0x3ff9c13a, 0x01c454f5, 0x02f1b755, 0x3feea776, 
-	0x3fe9b8a9, 0x03562038, 0x0483259d, 0x3fd73a4a, 0x3fcfd50b, 0x04e767c5, 0x0613e1c5, 0x3fb5f4ea, 
-	0x3fac1a5b, 0x0677edbb, 0x07a3adff, 0x3f8adc77, 0x3f7e8e1e, 0x08077457, 0x09324ca7, 0x3f55f796, 
-	0x3f473759, 0x0995bdfd, 0x0abf8043, 0x3f174e70, 0x3f061e95, 0x0b228d42, 0x0c4b0b94, 0x3eceeaad, 
-	0x3ebb4ddb, 0x0cada4f5, 0x0dd4b19a, 0x3e7cd778, 0x3e66d0b4, 0x0e36c82a, 0x0f5c35a3, 0x3e212179, 
-	0x3e08b42a, 0x0fbdba40, 0x10e15b4e, 0x3dbbd6d4, 0x3da106bd, 0x11423ef0, 0x1263e699, 0x3d4d0728, 
-	0x3d2fd86c, 0x12c41a4f, 0x13e39be9, 0x3cd4c38b, 0x3cb53aaa, 0x144310dd, 0x15604013, 0x3c531e88, 
-	0x3c314060, 0x15bee78c, 0x16d99864, 0x3bc82c1f, 0x3ba3fde7, 0x173763c9, 0x184f6aab, 0x3b3401bb, 
-	0x3b0d8909, 0x18ac4b87, 0x19c17d44, 0x3a96b636, 0x3a6df8f8, 0x1a1d6544, 0x1b2f971e, 0x39f061d2, 
-	0x39c5664f, 0x1b8a7815, 0x1c997fc4, 0x39411e33, 0x3913eb0e, 0x1cf34baf, 0x1dfeff67, 0x38890663, 
-	0x3859a292, 0x1e57a86d, 0x1f5fdee6, 0x37c836c2, 0x3796a996, 0x1fb7575c, 0x20bbe7d8, 0x36fecd0e, 
-	0x36cb1e2a, 0x21122240, 0x2212e492, 0x362ce855, 0x35f71fb1, 0x2267d3a0, 0x2364a02e, 0x3552a8f4, 
-	0x351acedd, 0x23b836ca, 0x24b0e699, 0x34703095, 0x34364da6, 0x250317df, 0x25f78497, 0x3385a222, 
-	0x3349bf48, 0x264843d9, 0x273847c8, 0x329321c7, 0x32554840, 0x27878893, 0x2872feb6, 0x3198d4ea, 
-	0x31590e3e, 0x28c0b4d2, 0x29a778db, 0x3096e223, 0x30553828, 0x29f3984c, 0x2ad586a3, 0x2f8d713a, 
-	0x2f49ee0f, 0x2b2003ac, 0x2bfcf97c, 0x2e7cab1c, 0x2e37592c, 0x2c45c8a0, 0x2d1da3d5, 0x2d64b9da, 
-	/* 1024 */
-	0x3fffffb1, 0x0006487f, 0x002bfb74, 0x3ffff0e3, 0x3fffe705, 0x00388c6e, 0x005e3f4c, 0x3fffba9b, 
-	0x3fffa6de, 0x006ad03b, 0x009082ea, 0x3fff5cd8, 0x3fff3f3c, 0x009d13c5, 0x00c2c62f, 0x3ffed79b, 
-	0x3ffeb021, 0x00cf56ef, 0x00f508fc, 0x3ffe2ae5, 0x3ffdf98c, 0x01019998, 0x01274b31, 0x3ffd56b5, 
-	0x3ffd1b7e, 0x0133dba3, 0x01598cb1, 0x3ffc5b0c, 0x3ffc15f7, 0x01661cf0, 0x018bcd5b, 0x3ffb37ec, 
-	0x3ffae8f9, 0x01985d60, 0x01be0d11, 0x3ff9ed53, 0x3ff99483, 0x01ca9cd4, 0x01f04bb4, 0x3ff87b44, 
-	0x3ff81896, 0x01fcdb2e, 0x02228924, 0x3ff6e1bf, 0x3ff67534, 0x022f184d, 0x0254c544, 0x3ff520c5, 
-	0x3ff4aa5d, 0x02615414, 0x0286fff3, 0x3ff33858, 0x3ff2b813, 0x02938e62, 0x02b93914, 0x3ff12878, 
-	0x3ff09e56, 0x02c5c71a, 0x02eb7086, 0x3feef126, 0x3fee5d28, 0x02f7fe1c, 0x031da62b, 0x3fec9265, 
-	0x3febf48b, 0x032a3349, 0x034fd9e5, 0x3fea0c35, 0x3fe96480, 0x035c6682, 0x03820b93, 0x3fe75e98, 
-	0x3fe6ad08, 0x038e97a9, 0x03b43b17, 0x3fe48990, 0x3fe3ce26, 0x03c0c69e, 0x03e66852, 0x3fe18d1f, 
-	0x3fe0c7da, 0x03f2f342, 0x04189326, 0x3fde6945, 0x3fdd9a27, 0x04251d77, 0x044abb73, 0x3fdb1e06, 
-	0x3fda450f, 0x0457451d, 0x047ce11a, 0x3fd7ab64, 0x3fd6c894, 0x04896a16, 0x04af03fc, 0x3fd4115f, 
-	0x3fd324b7, 0x04bb8c42, 0x04e123fa, 0x3fd04ffc, 0x3fcf597c, 0x04edab83, 0x051340f6, 0x3fcc673b, 
-	0x3fcb66e4, 0x051fc7b9, 0x05455ad1, 0x3fc8571f, 0x3fc74cf3, 0x0551e0c7, 0x0577716b, 0x3fc41fac, 
-	0x3fc30baa, 0x0583f68c, 0x05a984a6, 0x3fbfc0e3, 0x3fbea30c, 0x05b608eb, 0x05db9463, 0x3fbb3ac7, 
-	0x3fba131b, 0x05e817c3, 0x060da083, 0x3fb68d5b, 0x3fb55bdc, 0x061a22f7, 0x063fa8e7, 0x3fb1b8a2, 
-	0x3fb07d50, 0x064c2a67, 0x0671ad71, 0x3facbc9f, 0x3fab777b, 0x067e2df5, 0x06a3ae00, 0x3fa79954, 
-	0x3fa64a5f, 0x06b02d81, 0x06d5aa77, 0x3fa24ec6, 0x3fa0f600, 0x06e228ee, 0x0707a2b7, 0x3f9cdcf7, 
-	0x3f9b7a62, 0x0714201b, 0x073996a1, 0x3f9743eb, 0x3f95d787, 0x074612eb, 0x076b8616, 0x3f9183a5, 
-	0x3f900d72, 0x0778013d, 0x079d70f7, 0x3f8b9c28, 0x3f8a1c29, 0x07a9eaf5, 0x07cf5726, 0x3f858d79, 
-	0x3f8403ae, 0x07dbcff2, 0x08013883, 0x3f7f579b, 0x3f7dc405, 0x080db016, 0x083314f1, 0x3f78fa92, 
-	0x3f775d31, 0x083f8b43, 0x0864ec4f, 0x3f727661, 0x3f70cf38, 0x08716159, 0x0896be80, 0x3f6bcb0e, 
-	0x3f6a1a1c, 0x08a3323a, 0x08c88b65, 0x3f64f89b, 0x3f633de2, 0x08d4fdc6, 0x08fa52de, 0x3f5dff0e, 
-	0x3f5c3a8f, 0x0906c3e0, 0x092c14ce, 0x3f56de6a, 0x3f551026, 0x09388469, 0x095dd116, 0x3f4f96b4, 
-	0x3f4dbeac, 0x096a3f42, 0x098f8796, 0x3f4827f0, 0x3f464626, 0x099bf44c, 0x09c13831, 0x3f409223, 
-	0x3f3ea697, 0x09cda368, 0x09f2e2c7, 0x3f38d552, 0x3f36e006, 0x09ff4c78, 0x0a24873a, 0x3f30f181, 
-	0x3f2ef276, 0x0a30ef5e, 0x0a56256c, 0x3f28e6b6, 0x3f26ddec, 0x0a628bfa, 0x0a87bd3d, 0x3f20b4f5, 
-	0x3f1ea26e, 0x0a94222f, 0x0ab94e8f, 0x3f185c43, 0x3f164001, 0x0ac5b1dc, 0x0aead944, 0x3f0fdca5, 
-	0x3f0db6a9, 0x0af73ae5, 0x0b1c5d3d, 0x3f073621, 0x3f05066d, 0x0b28bd2a, 0x0b4dda5c, 0x3efe68bc, 
-	0x3efc2f50, 0x0b5a388d, 0x0b7f5081, 0x3ef5747b, 0x3ef3315a, 0x0b8bacf0, 0x0bb0bf8f, 0x3eec5965, 
-	0x3eea0c8e, 0x0bbd1a33, 0x0be22766, 0x3ee3177e, 0x3ee0c0f4, 0x0bee8038, 0x0c1387e9, 0x3ed9aecc, 
-	0x3ed74e91, 0x0c1fdee1, 0x0c44e0f9, 0x3ed01f55, 0x3ecdb56a, 0x0c513610, 0x0c763278, 0x3ec66920, 
-	0x3ec3f585, 0x0c8285a5, 0x0ca77c47, 0x3ebc8c31, 0x3eba0ee9, 0x0cb3cd84, 0x0cd8be47, 0x3eb2888f, 
-	0x3eb0019c, 0x0ce50d8c, 0x0d09f85b, 0x3ea85e41, 0x3ea5cda3, 0x0d1645a0, 0x0d3b2a64, 0x3e9e0d4c, 
-	0x3e9b7306, 0x0d4775a1, 0x0d6c5443, 0x3e9395b7, 0x3e90f1ca, 0x0d789d71, 0x0d9d75db, 0x3e88f788, 
-	0x3e8649f5, 0x0da9bcf2, 0x0dce8f0d, 0x3e7e32c6, 0x3e7b7b90, 0x0ddad406, 0x0dff9fba, 0x3e734778, 
-	0x3e70869f, 0x0e0be28e, 0x0e30a7c5, 0x3e6835a4, 0x3e656b2b, 0x0e3ce86b, 0x0e61a70f, 0x3e5cfd51, 
-	0x3e5a2939, 0x0e6de580, 0x0e929d7a, 0x3e519e86, 0x3e4ec0d1, 0x0e9ed9af, 0x0ec38ae8, 0x3e46194a, 
-	0x3e4331fa, 0x0ecfc4d9, 0x0ef46f3b, 0x3e3a6da4, 0x3e377cbb, 0x0f00a6df, 0x0f254a53, 0x3e2e9b9c, 
-	0x3e2ba11b, 0x0f317fa5, 0x0f561c15, 0x3e22a338, 0x3e1f9f21, 0x0f624f0c, 0x0f86e460, 0x3e168480, 
-	0x3e1376d5, 0x0f9314f5, 0x0fb7a317, 0x3e0a3f7b, 0x3e07283f, 0x0fc3d143, 0x0fe8581d, 0x3dfdd432, 
-	0x3dfab365, 0x0ff483d7, 0x10190352, 0x3df142ab, 0x3dee1851, 0x10252c94, 0x1049a49a, 0x3de48aef, 
-	0x3de15708, 0x1055cb5b, 0x107a3bd5, 0x3dd7ad05, 0x3dd46f94, 0x1086600e, 0x10aac8e6, 0x3dcaa8f5, 
-	0x3dc761fc, 0x10b6ea90, 0x10db4baf, 0x3dbd7ec7, 0x3dba2e48, 0x10e76ac3, 0x110bc413, 0x3db02e84, 
-	0x3dacd481, 0x1117e088, 0x113c31f3, 0x3da2b834, 0x3d9f54af, 0x11484bc2, 0x116c9531, 0x3d951bde, 
-	0x3d91aed9, 0x1178ac53, 0x119cedaf, 0x3d87598c, 0x3d83e309, 0x11a9021d, 0x11cd3b50, 0x3d797145, 
-	0x3d75f147, 0x11d94d02, 0x11fd7df6, 0x3d6b6313, 0x3d67d99b, 0x12098ce5, 0x122db583, 0x3d5d2efe, 
-	0x3d599c0e, 0x1239c1a7, 0x125de1da, 0x3d4ed50f, 0x3d4b38aa, 0x1269eb2b, 0x128e02dc, 0x3d40554e, 
-	0x3d3caf76, 0x129a0954, 0x12be186c, 0x3d31afc5, 0x3d2e007c, 0x12ca1c03, 0x12ee226c, 0x3d22e47c, 
-	0x3d1f2bc5, 0x12fa231b, 0x131e20c0, 0x3d13f37e, 0x3d10315a, 0x132a1e7e, 0x134e1348, 0x3d04dcd2, 
-	0x3d011145, 0x135a0e0e, 0x137df9e7, 0x3cf5a082, 0x3cf1cb8e, 0x1389f1af, 0x13add481, 0x3ce63e98, 
-	0x3ce2603f, 0x13b9c943, 0x13dda2f7, 0x3cd6b71e, 0x3cd2cf62, 0x13e994ab, 0x140d652c, 0x3cc70a1c, 
-	0x3cc318ff, 0x141953cb, 0x143d1b02, 0x3cb7379c, 0x3cb33d22, 0x14490685, 0x146cc45c, 0x3ca73fa9, 
-	0x3ca33bd3, 0x1478acbc, 0x149c611d, 0x3c97224c, 0x3c93151d, 0x14a84652, 0x14cbf127, 0x3c86df8e, 
-	0x3c82c909, 0x14d7d32a, 0x14fb745e, 0x3c76777b, 0x3c7257a2, 0x15075327, 0x152aeaa3, 0x3c65ea1c, 
-	0x3c61c0f1, 0x1536c62b, 0x155a53d9, 0x3c55377b, 0x3c510501, 0x15662c18, 0x1589afe3, 0x3c445fa2, 
-	0x3c4023dd, 0x159584d3, 0x15b8fea4, 0x3c33629d, 0x3c2f1d8e, 0x15c4d03e, 0x15e83fff, 0x3c224075, 
-	0x3c1df21f, 0x15f40e3a, 0x161773d6, 0x3c10f935, 0x3c0ca19b, 0x16233eac, 0x16469a0d, 0x3bff8ce8, 
-	0x3bfb2c0c, 0x16526176, 0x1675b286, 0x3bedfb99, 0x3be9917e, 0x1681767c, 0x16a4bd25, 0x3bdc4552, 
-	0x3bd7d1fa, 0x16b07d9f, 0x16d3b9cc, 0x3bca6a1d, 0x3bc5ed8d, 0x16df76c3, 0x1702a85e, 0x3bb86a08, 
-	0x3bb3e440, 0x170e61cc, 0x173188be, 0x3ba6451b, 0x3ba1b620, 0x173d3e9b, 0x17605ad0, 0x3b93fb63, 
-	0x3b8f6337, 0x176c0d15, 0x178f1e76, 0x3b818ceb, 0x3b7ceb90, 0x179acd1c, 0x17bdd394, 0x3b6ef9be, 
-	0x3b6a4f38, 0x17c97e93, 0x17ec7a0d, 0x3b5c41e8, 0x3b578e39, 0x17f8215e, 0x181b11c4, 0x3b496574, 
-	0x3b44a8a0, 0x1826b561, 0x18499a9d, 0x3b36646e, 0x3b319e77, 0x18553a7d, 0x1878147a, 0x3b233ee1, 
-	0x3b1e6fca, 0x1883b097, 0x18a67f3f, 0x3b0ff4d9, 0x3b0b1ca6, 0x18b21791, 0x18d4dad0, 0x3afc8663, 
-	0x3af7a516, 0x18e06f50, 0x1903270f, 0x3ae8f38b, 0x3ae40926, 0x190eb7b7, 0x193163e1, 0x3ad53c5b, 
-	0x3ad048e3, 0x193cf0a9, 0x195f9128, 0x3ac160e1, 0x3abc6458, 0x196b1a09, 0x198daec8, 0x3aad6129, 
-	0x3aa85b92, 0x199933bb, 0x19bbbca6, 0x3a993d3e, 0x3a942e9d, 0x19c73da3, 0x19e9baa3, 0x3a84f52f, 
-	0x3a7fdd86, 0x19f537a4, 0x1a17a8a5, 0x3a708906, 0x3a6b6859, 0x1a2321a2, 0x1a45868e, 0x3a5bf8d1, 
-	0x3a56cf23, 0x1a50fb81, 0x1a735442, 0x3a47449c, 0x3a4211f0, 0x1a7ec524, 0x1aa111a6, 0x3a326c74, 
-	0x3a2d30cd, 0x1aac7e6f, 0x1acebe9d, 0x3a1d7066, 0x3a182bc8, 0x1ada2746, 0x1afc5b0a, 0x3a08507f, 
-	0x3a0302ed, 0x1b07bf8c, 0x1b29e6d2, 0x39f30ccc, 0x39edb649, 0x1b354727, 0x1b5761d8, 0x39dda55a, 
-	0x39d845e9, 0x1b62bdf8, 0x1b84cc01, 0x39c81a36, 0x39c2b1da, 0x1b9023e5, 0x1bb22530, 0x39b26b6d, 
-	0x39acfa2b, 0x1bbd78d2, 0x1bdf6d4a, 0x399c990d, 0x39971ee7, 0x1beabca1, 0x1c0ca432, 0x3986a324, 
-	0x3981201e, 0x1c17ef39, 0x1c39c9cd, 0x397089bf, 0x396afddc, 0x1c45107c, 0x1c66ddfe, 0x395a4ceb, 
-	0x3954b82e, 0x1c72204f, 0x1c93e0ab, 0x3943ecb6, 0x393e4f23, 0x1c9f1e96, 0x1cc0d1b6, 0x392d692f, 
-	0x3927c2c9, 0x1ccc0b35, 0x1cedb106, 0x3916c262, 0x3911132d, 0x1cf8e611, 0x1d1a7e7d, 0x38fff85e, 
-	0x38fa405e, 0x1d25af0d, 0x1d473a00, 0x38e90b31, 0x38e34a69, 0x1d52660f, 0x1d73e374, 0x38d1fae9, 
-	0x38cc315d, 0x1d7f0afb, 0x1da07abc, 0x38bac795, 0x38b4f547, 0x1dab9db5, 0x1dccffbf, 0x38a37142, 
-	0x389d9637, 0x1dd81e21, 0x1df9725f, 0x388bf7ff, 0x3886143b, 0x1e048c24, 0x1e25d282, 0x38745bdb, 
-	0x386e6f60, 0x1e30e7a4, 0x1e52200c, 0x385c9ce3, 0x3856a7b6, 0x1e5d3084, 0x1e7e5ae2, 0x3844bb28, 
-	0x383ebd4c, 0x1e8966a8, 0x1eaa82e9, 0x382cb6b7, 0x3826b030, 0x1eb589f7, 0x1ed69805, 0x38148f9f, 
-	0x380e8071, 0x1ee19a54, 0x1f029a1c, 0x37fc45ef, 0x37f62e1d, 0x1f0d97a5, 0x1f2e8911, 0x37e3d9b7, 
-	0x37ddb945, 0x1f3981ce, 0x1f5a64cb, 0x37cb4b04, 0x37c521f6, 0x1f6558b5, 0x1f862d2d, 0x37b299e7, 
-	0x37ac6841, 0x1f911c3d, 0x1fb1e21d, 0x3799c66f, 0x37938c34, 0x1fbccc4d, 0x1fdd8381, 0x3780d0aa, 
-	0x377a8ddf, 0x1fe868c8, 0x2009113c, 0x3767b8a9, 0x37616d51, 0x2013f196, 0x20348b35, 0x374e7e7b, 
-	0x37482a9a, 0x203f6699, 0x205ff14f, 0x3735222f, 0x372ec5c9, 0x206ac7b8, 0x208b4372, 0x371ba3d4, 
-	0x37153eee, 0x209614d9, 0x20b68181, 0x3702037c, 0x36fb9618, 0x20c14ddf, 0x20e1ab63, 0x36e84135, 
-	0x36e1cb58, 0x20ec72b1, 0x210cc0fc, 0x36ce5d10, 0x36c7debd, 0x21178334, 0x2137c232, 0x36b4571b, 
-	0x36add058, 0x21427f4d, 0x2162aeea, 0x369a2f69, 0x3693a038, 0x216d66e2, 0x218d870b, 0x367fe608, 
-	0x36794e6e, 0x219839d8, 0x21b84a79, 0x36657b08, 0x365edb09, 0x21c2f815, 0x21e2f91a, 0x364aee7b, 
-	0x3644461b, 0x21eda17f, 0x220d92d4, 0x36304070, 0x36298fb4, 0x221835fb, 0x2238178d, 0x361570f8, 
-	0x360eb7e3, 0x2242b56f, 0x22628729, 0x35fa8023, 0x35f3beba, 0x226d1fc1, 0x228ce191, 0x35df6e03, 
-	0x35d8a449, 0x229774d7, 0x22b726a8, 0x35c43aa7, 0x35bd68a1, 0x22c1b496, 0x22e15655, 0x35a8e621, 
-	0x35a20bd3, 0x22ebdee5, 0x230b707e, 0x358d7081, 0x35868def, 0x2315f3a8, 0x23357509, 0x3571d9d9, 
-	0x356aef08, 0x233ff2c8, 0x235f63dc, 0x35562239, 0x354f2f2c, 0x2369dc29, 0x23893cdd, 0x353a49b2, 
-	0x35334e6f, 0x2393afb2, 0x23b2fff3, 0x351e5056, 0x35174ce0, 0x23bd6d48, 0x23dcad03, 0x35023636, 
-	0x34fb2a92, 0x23e714d3, 0x240643f4, 0x34e5fb63, 0x34dee795, 0x2410a639, 0x242fc4ad, 0x34c99fef, 
-	0x34c283fb, 0x243a215f, 0x24592f13, 0x34ad23eb, 0x34a5ffd5, 0x2463862c, 0x2482830d, 0x34908768, 
-	0x34895b36, 0x248cd487, 0x24abc082, 0x3473ca79, 0x346c962f, 0x24b60c57, 0x24d4e757, 0x3456ed2f, 
-	0x344fb0d1, 0x24df2d81, 0x24fdf775, 0x3439ef9c, 0x3432ab2e, 0x250837ed, 0x2526f0c1, 0x341cd1d2, 
-	0x34158559, 0x25312b81, 0x254fd323, 0x33ff93e2, 0x33f83f62, 0x255a0823, 0x25789e80, 0x33e235df, 
-	0x33dad95e, 0x2582cdbc, 0x25a152c0, 0x33c4b7db, 0x33bd535c, 0x25ab7c30, 0x25c9efca, 0x33a719e8, 
-	0x339fad70, 0x25d41369, 0x25f27584, 0x33895c18, 0x3381e7ac, 0x25fc934b, 0x261ae3d6, 0x336b7e7e, 
-	0x33640223, 0x2624fbbf, 0x26433aa7, 0x334d812d, 0x3345fce6, 0x264d4cac, 0x266b79dd, 0x332f6435, 
-	0x3327d808, 0x267585f8, 0x2693a161, 0x331127ab, 0x3309939c, 0x269da78b, 0x26bbb119, 0x32f2cba1, 
-	0x32eb2fb5, 0x26c5b14c, 0x26e3a8ec, 0x32d45029, 0x32ccac64, 0x26eda322, 0x270b88c2, 0x32b5b557, 
-	0x32ae09be, 0x27157cf5, 0x27335082, 0x3296fb3d, 0x328f47d5, 0x273d3eac, 0x275b0014, 0x327821ee, 
-	0x327066bc, 0x2764e82f, 0x27829760, 0x3259297d, 0x32516686, 0x278c7965, 0x27aa164c, 0x323a11fe, 
-	0x32324746, 0x27b3f235, 0x27d17cc1, 0x321adb83, 0x3213090f, 0x27db5288, 0x27f8caa5, 0x31fb8620, 
-	0x31f3abf5, 0x28029a45, 0x281fffe2, 0x31dc11e8, 0x31d4300b, 0x2829c954, 0x28471c5e, 0x31bc7eee, 
-	0x31b49564, 0x2850df9d, 0x286e2002, 0x319ccd46, 0x3194dc14, 0x2877dd07, 0x28950ab6, 0x317cfd04, 
-	0x3175042e, 0x289ec17a, 0x28bbdc61, 0x315d0e3b, 0x31550dc6, 0x28c58cdf, 0x28e294eb, 0x313d00ff, 
-	0x3134f8f1, 0x28ec3f1e, 0x2909343e, 0x311cd564, 0x3114c5c0, 0x2912d81f, 0x292fba40, 0x30fc8b7d, 
-	0x30f47449, 0x293957c9, 0x295626da, 0x30dc235e, 0x30d404a0, 0x295fbe06, 0x297c79f5, 0x30bb9d1c, 
-	0x30b376d8, 0x29860abd, 0x29a2b378, 0x309af8ca, 0x3092cb05, 0x29ac3dd7, 0x29c8d34d, 0x307a367c, 
-	0x3072013c, 0x29d2573c, 0x29eed95b, 0x30595648, 0x30511991, 0x29f856d5, 0x2a14c58b, 0x30385840, 
-	0x30301418, 0x2a1e3c8a, 0x2a3a97c7, 0x30173c7a, 0x300ef0e5, 0x2a440844, 0x2a604ff5, 0x2ff6030a, 
-	0x2fedb00d, 0x2a69b9ec, 0x2a85ee00, 0x2fd4ac04, 0x2fcc51a5, 0x2a8f516b, 0x2aab71d0, 0x2fb3377c, 
-	0x2faad5c1, 0x2ab4cea9, 0x2ad0db4e, 0x2f91a589, 0x2f893c75, 0x2ada318e, 0x2af62a63, 0x2f6ff63d, 
-	0x2f6785d7, 0x2aff7a05, 0x2b1b5ef8, 0x2f4e29af, 0x2f45b1fb, 0x2b24a7f6, 0x2b4078f5, 0x2f2c3ff2, 
-	0x2f23c0f6, 0x2b49bb4a, 0x2b657844, 0x2f0a391d, 0x2f01b2de, 0x2b6eb3ea, 0x2b8a5cce, 0x2ee81543, 
-	0x2edf87c6, 0x2b9391c0, 0x2baf267d, 0x2ec5d479, 0x2ebd3fc4, 0x2bb854b4, 0x2bd3d53a, 0x2ea376d6, 
-	0x2e9adaee, 0x2bdcfcb0, 0x2bf868ed, 0x2e80fc6e, 0x2e785958, 0x2c01899e, 0x2c1ce181, 0x2e5e6556, 
-	0x2e55bb17, 0x2c25fb66, 0x2c413edf, 0x2e3bb1a4, 0x2e330042, 0x2c4a51f3, 0x2c6580f1, 0x2e18e16d, 
-	0x2e1028ed, 0x2c6e8d2e, 0x2c89a79f, 0x2df5f4c7, 0x2ded352f, 0x2c92ad01, 0x2cadb2d5, 0x2dd2ebc7, 
-	0x2dca251c, 0x2cb6b155, 0x2cd1a27b, 0x2dafc683, 0x2da6f8ca, 0x2cda9a14, 0x2cf5767c, 0x2d8c8510, 
-	0x2d83b04f, 0x2cfe6728, 0x2d192ec1, 0x2d692784, 0x2d604bc0, 0x2d22187a, 0x2d3ccb34, 0x2d45adf6
-};
-
-
-const int twidTab512[(8*6 + 32*6 + 128*6)/2] = {
-	0x40000000, 0x40000000, 0x40000000, 0x3b20187d, 
-	0x3ec50c7c, 0x3536238e, 0x2d412d41, 0x3b20187d, 
-	0x187d3b20, 0x187d3b20, 0x3536238e, 0xf3843ec5, 
-	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xe7833b20, 
-	0x238e3536, 0xc13b0c7c, 0xd2bf2d41, 0x187d3b20, 
-	0xc4e0e783, 0xc4e0187d, 0x0c7c3ec5, 0xdc72caca, 
-
-	0x40000000, 0x40000000, 0x40000000, 0x3fb10645, 
-	0x3fec0323, 0x3f4e0964, 0x3ec50c7c, 0x3fb10645, 
-	0x3d3e1294, 0x3d3e1294, 0x3f4e0964, 0x39da1b5d, 
-	0x3b20187d, 0x3ec50c7c, 0x3536238e, 0x38711e2b, 
-	0x3e140f8c, 0x2f6b2afa, 0x3536238e, 0x3d3e1294, 
-	0x28993179, 0x31792899, 0x3c42158f, 0x20e736e5, 
-	0x2d412d41, 0x3b20187d, 0x187d3b20, 0x28993179, 
-	0x39da1b5d, 0x0f8c3e14, 0x238e3536, 0x38711e2b, 
-	0x06453fb1, 0x1e2b3871, 0x36e520e7, 0xfcdd3fec, 
-	0x187d3b20, 0x3536238e, 0xf3843ec5, 0x12943d3e, 
-	0x3367261f, 0xea713c42, 0x0c7c3ec5, 0x31792899, 
-	0xe1d53871, 0x06453fb1, 0x2f6b2afa, 0xd9e13367, 
-	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xf9bb3fb1, 
-	0x2afa2f6b, 0xcc99261f, 0xf3843ec5, 0x28993179, 
-	0xc78f1e2b, 0xed6c3d3e, 0x261f3367, 0xc3be158f, 
-	0xe7833b20, 0x238e3536, 0xc13b0c7c, 0xe1d53871, 
-	0x20e736e5, 0xc0140323, 0xdc723536, 0x1e2b3871, 
-	0xc04ff9bb, 0xd7673179, 0x1b5d39da, 0xc1ecf074, 
-	0xd2bf2d41, 0x187d3b20, 0xc4e0e783, 0xce872899, 
-	0x158f3c42, 0xc91bdf19, 0xcaca238e, 0x12943d3e, 
-	0xce87d767, 0xc78f1e2b, 0x0f8c3e14, 0xd506d095, 
-	0xc4e0187d, 0x0c7c3ec5, 0xdc72caca, 0xc2c21294, 
-	0x09643f4e, 0xe4a3c626, 0xc13b0c7c, 0x06453fb1, 
-	0xed6cc2c2, 0xc04f0645, 0x03233fec, 0xf69cc0b2, 
-
-	0x40000000, 0x40000000, 0x40000000, 0x3ffb0192, 
-	0x3ffe00c9, 0x3ff4025b, 0x3fec0323, 0x3ffb0192, 
-	0x3fd304b5, 0x3fd304b5, 0x3ff4025b, 0x3f9c070d, 
-	0x3fb10645, 0x3fec0323, 0x3f4e0964, 0x3f8407d5, 
-	0x3fe103ec, 0x3eeb0bb6, 0x3f4e0964, 0x3fd304b5, 
-	0x3e710e05, 0x3f0e0af1, 0x3fc3057d, 0x3de2104f, 
-	0x3ec50c7c, 0x3fb10645, 0x3d3e1294, 0x3e710e05, 
-	0x3f9c070d, 0x3c8414d1, 0x3e140f8c, 0x3f8407d5, 
-	0x3bb61708, 0x3dae1111, 0x3f6a089c, 0x3ad21937, 
-	0x3d3e1294, 0x3f4e0964, 0x39da1b5d, 0x3cc51413, 
-	0x3f2f0a2a, 0x38cf1d79, 0x3c42158f, 0x3f0e0af1, 
-	0x37af1f8b, 0x3bb61708, 0x3eeb0bb6, 0x367c2192, 
-	0x3b20187d, 0x3ec50c7c, 0x3536238e, 0x3a8219ef, 
-	0x3e9c0d41, 0x33de257d, 0x39da1b5d, 0x3e710e05, 
-	0x3274275f, 0x392a1cc6, 0x3e440ec9, 0x30f82934, 
-	0x38711e2b, 0x3e140f8c, 0x2f6b2afa, 0x37af1f8b, 
-	0x3de2104f, 0x2dce2cb2, 0x36e520e7, 0x3dae1111, 
-	0x2c212e5a, 0x3612223d, 0x3d7711d3, 0x2a652ff1, 
-	0x3536238e, 0x3d3e1294, 0x28993179, 0x345324da, 
-	0x3d021354, 0x26c032ee, 0x3367261f, 0x3cc51413, 
-	0x24da3453, 0x3274275f, 0x3c8414d1, 0x22e635a5, 
-	0x31792899, 0x3c42158f, 0x20e736e5, 0x307629cd, 
-	0x3bfd164c, 0x1edc3811, 0x2f6b2afa, 0x3bb61708, 
-	0x1cc6392a, 0x2e5a2c21, 0x3b6c17c3, 0x1aa63a2f, 
-	0x2d412d41, 0x3b20187d, 0x187d3b20, 0x2c212e5a, 
-	0x3ad21937, 0x164c3bfd, 0x2afa2f6b, 0x3a8219ef, 
-	0x14133cc5, 0x29cd3076, 0x3a2f1aa6, 0x11d33d77, 
-	0x28993179, 0x39da1b5d, 0x0f8c3e14, 0x275f3274, 
-	0x39831c12, 0x0d413e9c, 0x261f3367, 0x392a1cc6, 
-	0x0af13f0e, 0x24da3453, 0x38cf1d79, 0x089c3f6a, 
-	0x238e3536, 0x38711e2b, 0x06453fb1, 0x223d3612, 
-	0x38111edc, 0x03ec3fe1, 0x20e736e5, 0x37af1f8b, 
-	0x01923ffb, 0x1f8b37af, 0x374b2039, 0xff373ffe, 
-	0x1e2b3871, 0x36e520e7, 0xfcdd3fec, 0x1cc6392a, 
-	0x367c2192, 0xfa833fc3, 0x1b5d39da, 0x3612223d, 
-	0xf82b3f84, 0x19ef3a82, 0x35a522e6, 0xf5d63f2f, 
-	0x187d3b20, 0x3536238e, 0xf3843ec5, 0x17083bb6, 
-	0x34c62434, 0xf1373e44, 0x158f3c42, 0x345324da, 
-	0xeeef3dae, 0x14133cc5, 0x33de257d, 0xecac3d02, 
-	0x12943d3e, 0x3367261f, 0xea713c42, 0x11113dae, 
-	0x32ee26c0, 0xe83d3b6c, 0x0f8c3e14, 0x3274275f, 
-	0xe6113a82, 0x0e053e71, 0x31f727fd, 0xe3ee3983, 
-	0x0c7c3ec5, 0x31792899, 0xe1d53871, 0x0af13f0e, 
-	0x30f82934, 0xdfc7374b, 0x09643f4e, 0x307629cd, 
-	0xddc33612, 0x07d53f84, 0x2ff12a65, 0xdbcc34c6, 
-	0x06453fb1, 0x2f6b2afa, 0xd9e13367, 0x04b53fd3, 
-	0x2ee32b8e, 0xd80331f7, 0x03233fec, 0x2e5a2c21, 
-	0xd6333076, 0x01923ffb, 0x2dce2cb2, 0xd4722ee3, 
-	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xfe6e3ffb, 
-	0x2cb22dce, 0xd11d2b8e, 0xfcdd3fec, 0x2c212e5a, 
-	0xcf8a29cd, 0xfb4b3fd3, 0x2b8e2ee3, 0xce0927fd, 
-	0xf9bb3fb1, 0x2afa2f6b, 0xcc99261f, 0xf82b3f84, 
-	0x2a652ff1, 0xcb3a2434, 0xf69c3f4e, 0x29cd3076, 
-	0xc9ee223d, 0xf50f3f0e, 0x293430f8, 0xc8b52039, 
-	0xf3843ec5, 0x28993179, 0xc78f1e2b, 0xf1fb3e71, 
-	0x27fd31f7, 0xc67d1c12, 0xf0743e14, 0x275f3274, 
-	0xc57e19ef, 0xeeef3dae, 0x26c032ee, 0xc49417c3, 
-	0xed6c3d3e, 0x261f3367, 0xc3be158f, 0xebed3cc5, 
-	0x257d33de, 0xc2fe1354, 0xea713c42, 0x24da3453, 
-	0xc2521111, 0xe8f83bb6, 0x243434c6, 0xc1bc0ec9, 
-	0xe7833b20, 0x238e3536, 0xc13b0c7c, 0xe6113a82, 
-	0x22e635a5, 0xc0d10a2a, 0xe4a339da, 0x223d3612, 
-	0xc07c07d5, 0xe33a392a, 0x2192367c, 0xc03d057d, 
-	0xe1d53871, 0x20e736e5, 0xc0140323, 0xe07537af, 
-	0x2039374b, 0xc00200c9, 0xdf1936e5, 0x1f8b37af, 
-	0xc005fe6e, 0xddc33612, 0x1edc3811, 0xc01ffc14, 
-	0xdc723536, 0x1e2b3871, 0xc04ff9bb, 0xdb263453, 
-	0x1d7938cf, 0xc096f764, 0xd9e13367, 0x1cc6392a, 
-	0xc0f2f50f, 0xd8a13274, 0x1c123983, 0xc164f2bf, 
-	0xd7673179, 0x1b5d39da, 0xc1ecf074, 0xd6333076, 
-	0x1aa63a2f, 0xc289ee2d, 0xd5062f6b, 0x19ef3a82, 
-	0xc33bebed, 0xd3df2e5a, 0x19373ad2, 0xc403e9b4, 
-	0xd2bf2d41, 0x187d3b20, 0xc4e0e783, 0xd1a62c21, 
-	0x17c33b6c, 0xc5d1e55a, 0xd0952afa, 0x17083bb6, 
-	0xc6d6e33a, 0xcf8a29cd, 0x164c3bfd, 0xc7efe124, 
-	0xce872899, 0x158f3c42, 0xc91bdf19, 0xcd8c275f, 
-	0x14d13c84, 0xca5bdd1a, 0xcc99261f, 0x14133cc5, 
-	0xcbaddb26, 0xcbad24da, 0x13543d02, 0xcd12d940, 
-	0xcaca238e, 0x12943d3e, 0xce87d767, 0xc9ee223d, 
-	0x11d33d77, 0xd00fd59b, 0xc91b20e7, 0x11113dae, 
-	0xd1a6d3df, 0xc8511f8b, 0x104f3de2, 0xd34ed232, 
-	0xc78f1e2b, 0x0f8c3e14, 0xd506d095, 0xc6d61cc6, 
-	0x0ec93e44, 0xd6cccf08, 0xc6261b5d, 0x0e053e71, 
-	0xd8a1cd8c, 0xc57e19ef, 0x0d413e9c, 0xda83cc22, 
-	0xc4e0187d, 0x0c7c3ec5, 0xdc72caca, 0xc44a1708, 
-	0x0bb63eeb, 0xde6ec984, 0xc3be158f, 0x0af13f0e, 
-	0xe075c851, 0xc33b1413, 0x0a2a3f2f, 0xe287c731, 
-	0xc2c21294, 0x09643f4e, 0xe4a3c626, 0xc2521111, 
-	0x089c3f6a, 0xe6c9c52e, 0xc1ec0f8c, 0x07d53f84, 
-	0xe8f8c44a, 0xc18f0e05, 0x070d3f9c, 0xeb2fc37c, 
-	0xc13b0c7c, 0x06453fb1, 0xed6cc2c2, 0xc0f20af1, 
-	0x057d3fc3, 0xefb1c21e, 0xc0b20964, 0x04b53fd3, 
-	0xf1fbc18f, 0xc07c07d5, 0x03ec3fe1, 0xf44ac115, 
-	0xc04f0645, 0x03233fec, 0xf69cc0b2, 0xc02d04b5, 
-	0x025b3ff4, 0xf8f3c064, 0xc0140323, 0x01923ffb, 
-	0xfb4bc02d, 0xc0050192, 0x00c93ffe, 0xfda5c00c	
-};
-
-const int twidTab64[(4*6 + 16*6)/2] = {
-	0x40000000, 0x40000000, 0x40000000, 0x2d412d41, 
-	0x3b20187d, 0x187d3b20, 0x00004000, 0x2d412d41, 
-	0xd2bf2d41, 0xd2bf2d41, 0x187d3b20, 0xc4e0e783, 
-
-	0x40000000, 0x40000000, 0x40000000, 0x3ec50c7c, 
-	0x3fb10645, 0x3d3e1294, 0x3b20187d, 0x3ec50c7c, 
-	0x3536238e, 0x3536238e, 0x3d3e1294, 0x28993179, 
-	0x2d412d41, 0x3b20187d, 0x187d3b20, 0x238e3536, 
-	0x38711e2b, 0x06453fb1, 0x187d3b20, 0x3536238e, 
-	0xf3843ec5, 0x0c7c3ec5, 0x31792899, 0xe1d53871, 
-	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xf3843ec5, 
-	0x28993179, 0xc78f1e2b, 0xe7833b20, 0x238e3536, 
-	0xc13b0c7c, 0xdc723536, 0x1e2b3871, 0xc04ff9bb, 
-	0xd2bf2d41, 0x187d3b20, 0xc4e0e783, 0xcaca238e, 
-	0x12943d3e, 0xce87d767, 0xc4e0187d, 0x0c7c3ec5, 
-	0xdc72caca, 0xc13b0c7c, 0x06453fb1, 0xed6cc2c2 
-};
-
-#elif defined ARMV7Neon
-/* 
- *  Q29 for 128 and 1024 
- *
- * for (i = 0; i < num/4; i++) {
- *   angle = (i + 0.125) * M_PI / num;
- *   x = cos(angle) * (1 << 29);
- *   x = sin(angle) * (1 << 29);
- * 
- *   angle = (num/2 - 1 - i + 0.125) * M_PI / num;
- *   x = cos(angle) * (1 << 29);
- *   x = sin(angle) * (1 << 29);
- * }
- */
-const int cossintab[128 + 1024] = {
-	/* 128 */
-	0x1ffff621, 0x001921f9, 0x00afea69, 0x1ffe1c68, 0x1ffce09d, 0x00e22a7a, 0x0178dbaa, 0x1ff753bb, 
-	0x1ff4dc55, 0x01ab101c, 0x024192cf, 0x1feb9d25, 0x1fe7ea85, 0x0273b3e2, 0x0309f0e2, 0x1fdafa75, 
-	0x1fd60d2e, 0x033bf6dd, 0x03d1d700, 0x1fc56e3b, 0x1fbf470f, 0x0403ba2b, 0x04992653, 0x1faafbcb, 
-	0x1fa39bac, 0x04cadefe, 0x055fc022, 0x1f8ba738, 0x1f830f4a, 0x059146a1, 0x062585ca, 0x1f677557, 
-	0x1f5da6ed, 0x0656d27a, 0x06ea58cd, 0x1f3e6bbc, 0x1f33685a, 0x071b6415, 0x07ae1ad2, 0x1f1090bd, 
-	0x1f045a15, 0x07dedd20, 0x0870ada7, 0x1eddeb6a, 0x1ed0835f, 0x08a11f78, 0x0931f34d, 0x1ea68394, 
-	0x1e97ec36, 0x09620d27, 0x09f1cdf5, 0x1e6a61c5, 0x1e5a9d55, 0x0a21886e, 0x0ab02009, 0x1e298f44, 
-	0x1e18a030, 0x0adf73c6, 0x0b6ccc32, 0x1de4160f, 0x1dd1fef4, 0x0b9bb1e5, 0x0c27b555, 0x1d9a00de, 
-	0x1d86c484, 0x0c5625c3, 0x0ce0bea2, 0x1d4b5b1b, 0x1d36fc7c, 0x0d0eb2a2, 0x0d97cb8f, 0x1cf830e9, 
-	0x1ce2b328, 0x0dc53c0a, 0x0e4cbfe2, 0x1ca08f1a, 0x1c89f587, 0x0e79a5d7, 0x0eff7fb3, 0x1c448331, 
-	0x1c2cd149, 0x0f2bd437, 0x0fafef73, 0x1be41b61, 0x1bcb54cb, 0x0fdbabae, 0x105df3ec, 0x1b7f6687, 
-	0x1b658f15, 0x10891120, 0x11097249, 0x1b16742a, 0x1afb8fd9, 0x1133e9d0, 0x11b25017, 0x1aa9547a, 
-	0x1a8d676e, 0x11dc1b65, 0x1258734d, 0x1a38184a, 0x1a1b26d3, 0x12818bef, 0x12fbc24b, 0x19c2d111, 
-	0x19a4dfa4, 0x132421ec, 0x139c23e4, 0x194990e4, 0x192aa420, 0x13c3c44a, 0x14397f5b, 0x18cc6a75, 
-	0x18ac871f, 0x14605a69, 0x14d3bc6d, 0x184b7112, 0x182a9c14, 0x14f9cc26, 0x156ac352, 0x17c6b89d, 
-	0x17a4f708, 0x159001d6, 0x15fe7cbe, 0x173e558e, 0x171bac96, 0x1622e450, 0x168ed1eb, 0x16b25ced,
-	/* 1024 */
-	0x1fffffd9, 0x0003243f, 0x0015fdba, 0x1ffff872, 0x1ffff382, 0x001c4637, 0x002f1fa6, 0x1fffdd4d, 
-	0x1fffd36f, 0x0035681d, 0x00484175, 0x1fffae6c, 0x1fff9f9e, 0x004e89e3, 0x00616318, 0x1fff6bce, 
-	0x1fff5811, 0x0067ab77, 0x007a847e, 0x1fff1572, 0x1ffefcc6, 0x0080cccc, 0x0093a599, 0x1ffeab5b, 
-	0x1ffe8dbf, 0x0099edd2, 0x00acc658, 0x1ffe2d86, 0x1ffe0afc, 0x00b30e78, 0x00c5e6ad, 0x1ffd9bf6, 
-	0x1ffd747c, 0x00cc2eb0, 0x00df0688, 0x1ffcf6aa, 0x1ffcca41, 0x00e54e6a, 0x00f825da, 0x1ffc3da2, 
-	0x1ffc0c4b, 0x00fe6d97, 0x01114492, 0x1ffb70e0, 0x1ffb3a9a, 0x01178c27, 0x012a62a2, 0x1ffa9063, 
-	0x1ffa552e, 0x0130aa0a, 0x01437ffa, 0x1ff99c2c, 0x1ff95c09, 0x0149c731, 0x015c9c8a, 0x1ff8943c, 
-	0x1ff84f2b, 0x0162e38d, 0x0175b843, 0x1ff77893, 0x1ff72e94, 0x017bff0e, 0x018ed316, 0x1ff64932, 
-	0x1ff5fa46, 0x019519a5, 0x01a7ecf2, 0x1ff5061b, 0x1ff4b240, 0x01ae3341, 0x01c105c9, 0x1ff3af4c, 
-	0x1ff35684, 0x01c74bd5, 0x01da1d8c, 0x1ff244c8, 0x1ff1e713, 0x01e0634f, 0x01f33429, 0x1ff0c68f, 
-	0x1ff063ed, 0x01f979a1, 0x020c4993, 0x1fef34a3, 0x1feecd14, 0x02128ebb, 0x02255db9, 0x1fed8f03, 
-	0x1fed2287, 0x022ba28f, 0x023e708d, 0x1febd5b2, 0x1feb644a, 0x0244b50b, 0x025781fe, 0x1fea08b0, 
-	0x1fe9925c, 0x025dc621, 0x027091fd, 0x1fe827fe, 0x1fe7acbe, 0x0276d5c1, 0x0289a07b, 0x1fe6339d, 
-	0x1fe5b372, 0x028fe3dd, 0x02a2ad69, 0x1fe42b90, 0x1fe3a679, 0x02a8f063, 0x02bbb8b6, 0x1fe20fd6, 
-	0x1fe185d5, 0x02c1fb46, 0x02d4c253, 0x1fdfe071, 0x1fdf5186, 0x02db0475, 0x02edca32, 0x1fdd9d64, 
-	0x1fdd098e, 0x02f40be2, 0x0306d042, 0x1fdb46ae, 0x1fdaadee, 0x030d117c, 0x031fd474, 0x1fd8dc51, 
-	0x1fd83ea8, 0x03261534, 0x0338d6b8, 0x1fd65e4f, 0x1fd5bbbd, 0x033f16fb, 0x0351d700, 0x1fd3ccaa, 
-	0x1fd32530, 0x035816c1, 0x036ad53c, 0x1fd12763, 0x1fd07b00, 0x03711477, 0x0383d15c, 0x1fce6e7c, 
-	0x1fcdbd31, 0x038a100e, 0x039ccb51, 0x1fcba1f5, 0x1fcaebc3, 0x03a30975, 0x03b5c30b, 0x1fc8c1d2, 
-	0x1fc806b9, 0x03bc009f, 0x03ceb87c, 0x1fc5ce14, 0x1fc50e14, 0x03d4f57a, 0x03e7ab93, 0x1fc2c6bd, 
-	0x1fc201d7, 0x03ede7f9, 0x04009c42, 0x1fbfabcd, 0x1fbee202, 0x0406d80b, 0x04198a78, 0x1fbc7d49, 
-	0x1fbbae99, 0x041fc5a1, 0x04327628, 0x1fb93b31, 0x1fb8679c, 0x0438b0ac, 0x044b5f40, 0x1fb5e587, 
-	0x1fb50d0e, 0x0451991d, 0x046445b2, 0x1fb27c4e, 0x1fb19ef1, 0x046a7ee3, 0x047d296f, 0x1faeff87, 
-	0x1fae1d47, 0x048361f0, 0x04960a67, 0x1fab6f35, 0x1faa8813, 0x049c4235, 0x04aee88b, 0x1fa7cb5a, 
-	0x1fa6df56, 0x04b51fa1, 0x04c7c3cb, 0x1fa413f8, 0x1fa32313, 0x04cdfa26, 0x04e09c18, 0x1fa04912, 
-	0x1f9f534c, 0x04e6d1b4, 0x04f97163, 0x1f9c6aa9, 0x1f9b7003, 0x04ffa63c, 0x0512439d, 0x1f9878c1, 
-	0x1f97793b, 0x051877af, 0x052b12b6, 0x1f94735b, 0x1f936ef6, 0x053145fd, 0x0543de9e, 0x1f905a7a, 
-	0x1f8f5137, 0x054a1117, 0x055ca748, 0x1f8c2e21, 0x1f8b2000, 0x0562d8ee, 0x05756ca2, 0x1f87ee52, 
-	0x1f86db55, 0x057b9d73, 0x058e2e9f, 0x1f839b10, 0x1f828336, 0x05945e95, 0x05a6ed2e, 0x1f7f345e, 
-	0x1f7e17a8, 0x05ad1c47, 0x05bfa840, 0x1f7aba3e, 0x1f7998ad, 0x05c5d678, 0x05d85fc7, 0x1f762cb2, 
-	0x1f750647, 0x05de8d19, 0x05f113b3, 0x1f718bbf, 0x1f70607a, 0x05f7401c, 0x0609c3f5, 0x1f6cd766, 
-	0x1f6ba748, 0x060fef71, 0x0622707d, 0x1f680fab, 0x1f66dab5, 0x06289b08, 0x063b193c, 0x1f633490, 
-	0x1f61fac3, 0x064142d3, 0x0653be23, 0x1f5e4619, 0x1f5d0775, 0x0659e6c2, 0x066c5f24, 0x1f594448, 
-	0x1f5800ce, 0x067286c6, 0x0684fc2e, 0x1f542f21, 0x1f52e6d2, 0x068b22d0, 0x069d9532, 0x1f4f06a6, 
-	0x1f4db983, 0x06a3bad0, 0x06b62a22, 0x1f49cadc, 0x1f4878e5, 0x06bc4eb9, 0x06cebaee, 0x1f447bc4, 
-	0x1f4324fb, 0x06d4de79, 0x06e74786, 0x1f3f1963, 0x1f3dbdc8, 0x06ed6a03, 0x06ffcfdd, 0x1f39a3bc, 
-	0x1f384350, 0x0705f147, 0x071853e3, 0x1f341ad2, 0x1f32b595, 0x071e7436, 0x0730d388, 0x1f2e7ea9, 
-	0x1f2d149d, 0x0736f2c0, 0x07494ebd, 0x1f28cf43, 0x1f276069, 0x074f6cd7, 0x0761c574, 0x1f230ca5, 
-	0x1f2198fd, 0x0767e26c, 0x077a379d, 0x1f1d36d2, 0x1f1bbe5d, 0x07805370, 0x0792a52a, 0x1f174dce, 
-	0x1f15d08d, 0x0798bfd3, 0x07ab0e0a, 0x1f11519c, 0x1f0fcf91, 0x07b12786, 0x07c37230, 0x1f0b4240, 
-	0x1f09bb6b, 0x07c98a7a, 0x07dbd18c, 0x1f051fbe, 0x1f03941f, 0x07e1e8a1, 0x07f42c0e, 0x1efeea19, 
-	0x1efd59b3, 0x07fa41eb, 0x080c81a9, 0x1ef8a155, 0x1ef70c28, 0x0812964a, 0x0824d24d, 0x1ef24577, 
-	0x1ef0ab84, 0x082ae5ad, 0x083d1dea, 0x1eebd682, 0x1eea37ca, 0x08433007, 0x08556473, 0x1ee5547a, 
-	0x1ee3b0fe, 0x085b7548, 0x086da5d8, 0x1edebf64, 0x1edd1724, 0x0873b562, 0x0885e209, 0x1ed81742, 
-	0x1ed66a41, 0x088bf044, 0x089e18f9, 0x1ed15c1a, 0x1ecfaa57, 0x08a425e1, 0x08b64a98, 0x1eca8def, 
-	0x1ec8d76c, 0x08bc562a, 0x08ce76d8, 0x1ec3acc6, 0x1ec1f184, 0x08d4810f, 0x08e69da8, 0x1ebcb8a3, 
-	0x1ebaf8a3, 0x08eca681, 0x08febefb, 0x1eb5b18a, 0x1eb3eccd, 0x0904c673, 0x0916dac2, 0x1eae977f, 
-	0x1eacce07, 0x091ce0d4, 0x092ef0ed, 0x1ea76a87, 0x1ea59c55, 0x0934f596, 0x0947016e, 0x1ea02aa7, 
-	0x1e9e57bb, 0x094d04aa, 0x095f0c36, 0x1e98d7e2, 0x1e97003e, 0x09650e01, 0x09771136, 0x1e91723e, 
-	0x1e8f95e3, 0x097d118d, 0x098f1060, 0x1e89f9bf, 0x1e8818ad, 0x09950f3f, 0x09a709a4, 0x1e826e69, 
-	0x1e8088a2, 0x09ad0707, 0x09befcf4, 0x1e7ad041, 0x1e78e5c7, 0x09c4f8d8, 0x09d6ea40, 0x1e731f4c, 
-	0x1e71301f, 0x09dce4a1, 0x09eed17b, 0x1e6b5b8f, 0x1e6967b1, 0x09f4ca56, 0x0a06b296, 0x1e63850e, 
-	0x1e618c80, 0x0a0ca9e6, 0x0a1e8d81, 0x1e5b9bce, 0x1e599e91, 0x0a248343, 0x0a36622e, 0x1e539fd4, 
-	0x1e519dea, 0x0a3c565e, 0x0a4e308f, 0x1e4b9126, 0x1e498a8e, 0x0a542329, 0x0a65f894, 0x1e436fc7, 
-	0x1e416485, 0x0a6be995, 0x0a7dba2f, 0x1e3b3bbd, 0x1e392bd1, 0x0a83a993, 0x0a957551, 0x1e32f50e, 
-	0x1e30e079, 0x0a9b6315, 0x0aad29ec, 0x1e2a9bbd, 0x1e288281, 0x0ab3160c, 0x0ac4d7f1, 0x1e222fd1, 
-	0x1e2011ee, 0x0acac26a, 0x0adc7f52, 0x1e19b14f, 0x1e178ec7, 0x0ae2681f, 0x0af41fff, 0x1e11203b, 
-	0x1e0ef910, 0x0afa071d, 0x0b0bb9eb, 0x1e087c9b, 0x1e0650ce, 0x0b119f56, 0x0b234d07, 0x1dffc674, 
-	0x1dfd9606, 0x0b2930bb, 0x0b3ad943, 0x1df6fdcc, 0x1df4c8bf, 0x0b40bb3e, 0x0b525e92, 0x1dee22a9, 
-	0x1debe8fd, 0x0b583ecf, 0x0b69dce6, 0x1de5350f, 0x1de2f6c6, 0x0b6fbb62, 0x0b81542f, 0x1ddc3504, 
-	0x1dd9f220, 0x0b8730e6, 0x0b98c45f, 0x1dd3228e, 0x1dd0db10, 0x0b9e9f4d, 0x0bb02d68, 0x1dc9fdb2, 
-	0x1dc7b19b, 0x0bb6068a, 0x0bc78f3b, 0x1dc0c676, 0x1dbe75c8, 0x0bcd668e, 0x0bdee9ca, 0x1db77cdf, 
-	0x1db5279c, 0x0be4bf4a, 0x0bf63d07, 0x1dae20f4, 0x1dabc71d, 0x0bfc10af, 0x0c0d88e2, 0x1da4b2ba, 
-	0x1da25450, 0x0c135ab0, 0x0c24cd4e, 0x1d9b3237, 0x1d98cf3b, 0x0c2a9d3e, 0x0c3c0a3d, 0x1d919f70, 
-	0x1d8f37e5, 0x0c41d84b, 0x0c533fa0, 0x1d87fa6d, 0x1d858e53, 0x0c590bc9, 0x0c6a6d68, 0x1d7e4332, 
-	0x1d7bd28b, 0x0c7037a8, 0x0c819388, 0x1d7479c5, 0x1d720493, 0x0c875bdb, 0x0c98b1f0, 0x1d6a9e2e, 
-	0x1d682472, 0x0c9e7854, 0x0cafc894, 0x1d60b070, 0x1d5e322c, 0x0cb58d04, 0x0cc6d764, 0x1d56b094, 
-	0x1d542dc9, 0x0ccc99de, 0x0cddde53, 0x1d4c9e9f, 0x1d4a174f, 0x0ce39ed2, 0x0cf4dd52, 0x1d427a97, 
-	0x1d3feec3, 0x0cfa9bd2, 0x0d0bd452, 0x1d384483, 0x1d35b42d, 0x0d1190d1, 0x0d22c347, 0x1d2dfc68, 
-	0x1d2b6791, 0x0d287dc1, 0x0d39aa21, 0x1d23a24e, 0x1d2108f8, 0x0d3f6292, 0x0d5088d3, 0x1d19363a, 
-	0x1d169867, 0x0d563f38, 0x0d675f4e, 0x1d0eb833, 0x1d0c15e4, 0x0d6d13a3, 0x0d7e2d85, 0x1d04283f, 
-	0x1d018176, 0x0d83dfc6, 0x0d94f369, 0x1cf98666, 0x1cf6db24, 0x0d9aa393, 0x0dabb0ec, 0x1ceed2ad, 
-	0x1cec22f4, 0x0db15efc, 0x0dc26600, 0x1ce40d1b, 0x1ce158ed, 0x0dc811f3, 0x0dd91298, 0x1cd935b7, 
-	0x1cd67d15, 0x0ddebc69, 0x0defb6a5, 0x1cce4c87, 0x1ccb8f74, 0x0df55e51, 0x0e065219, 0x1cc35192, 
-	0x1cc0900f, 0x0e0bf79c, 0x0e1ce4e6, 0x1cb844df, 0x1cb57eee, 0x0e22883e, 0x0e336eff, 0x1cad2675, 
-	0x1caa5c17, 0x0e391027, 0x0e49f055, 0x1ca1f65b, 0x1c9f2792, 0x0e4f8f4b, 0x0e6068db, 0x1c96b497, 
-	0x1c93e165, 0x0e66059a, 0x0e76d883, 0x1c8b6131, 0x1c888997, 0x0e7c7308, 0x0e8d3f3e, 0x1c7ffc2f, 
-	0x1c7d202f, 0x0e92d787, 0x0ea39d00, 0x1c748599, 0x1c71a535, 0x0ea93308, 0x0eb9f1ba, 0x1c68fd75, 
-	0x1c6618ae, 0x0ebf857d, 0x0ed03d5e, 0x1c5d63ca, 0x1c5a7aa4, 0x0ed5ceda, 0x0ee67fdf, 0x1c51b8a1, 
-	0x1c4ecb1c, 0x0eec0f10, 0x0efcb92f, 0x1c45fc00, 0x1c430a1d, 0x0f024612, 0x0f12e941, 0x1c3a2ded, 
-	0x1c3737b0, 0x0f1873d2, 0x0f291006, 0x1c2e4e72, 0x1c2b53db, 0x0f2e9842, 0x0f3f2d71, 0x1c225d94, 
-	0x1c1f5ea6, 0x0f44b354, 0x0f554175, 0x1c165b5b, 0x1c135818, 0x0f5ac4fc, 0x0f6b4c03, 0x1c0a47cf, 
-	0x1c074038, 0x0f70cd2a, 0x0f814d0e, 0x1bfe22f8, 0x1bfb170f, 0x0f86cbd3, 0x0f974489, 0x1bf1ecdb, 
-	0x1beedca2, 0x0f9cc0e7, 0x0fad3265, 0x1be5a582, 0x1be290fb, 0x0fb2ac5a, 0x0fc31697, 0x1bd94cf4, 
-	0x1bd63421, 0x0fc88e1e, 0x0fd8f10f, 0x1bcce337, 0x1bc9c61a, 0x0fde6626, 0x0feec1c0, 0x1bc06855, 
-	0x1bbd46f0, 0x0ff43464, 0x1004889e, 0x1bb3dc55, 0x1bb0b6a9, 0x1009f8cb, 0x101a459a, 0x1ba73f3d, 
-	0x1ba4154d, 0x101fb34d, 0x102ff8a8, 0x1b9a9117, 0x1b9762e4, 0x103563dc, 0x1045a1b9, 0x1b8dd1ea, 
-	0x1b8a9f77, 0x104b0a6c, 0x105b40c1, 0x1b8101be, 0x1b7dcb0c, 0x1060a6ef, 0x1070d5b1, 0x1b74209b, 
-	0x1b70e5ac, 0x10763958, 0x1086607e, 0x1b672e88, 0x1b63ef5f, 0x108bc19a, 0x109be119, 0x1b5a2b8e, 
-	0x1b56e82c, 0x10a13fa6, 0x10b15775, 0x1b4d17b4, 0x1b49d01c, 0x10b6b371, 0x10c6c385, 0x1b3ff304, 
-	0x1b3ca737, 0x10cc1cec, 0x10dc253c, 0x1b32bd84, 0x1b2f6d85, 0x10e17c0b, 0x10f17c8d, 0x1b25773d, 
-	0x1b22230e, 0x10f6d0c0, 0x1106c96a, 0x1b182038, 0x1b14c7da, 0x110c1afe, 0x111c0bc6, 0x1b0ab87c, 
-	0x1b075bf1, 0x11215ab8, 0x11314395, 0x1afd4012, 0x1af9df5d, 0x11368fe1, 0x114670c8, 0x1aefb702, 
-	0x1aec5225, 0x114bba6b, 0x115b9354, 0x1ae21d54, 0x1adeb451, 0x1160da4b, 0x1170ab2a, 0x1ad47311, 
-	0x1ad105e9, 0x1175ef72, 0x1185b83f, 0x1ac6b841, 0x1ac346f8, 0x118af9d4, 0x119aba84, 0x1ab8ecec, 
-	0x1ab57784, 0x119ff964, 0x11afb1ee, 0x1aab111c, 0x1aa79796, 0x11b4ee14, 0x11c49e6f, 0x1a9d24d9, 
-	0x1a99a737, 0x11c9d7d9, 0x11d97ff9, 0x1a8f282b, 0x1a8ba670, 0x11deb6a4, 0x11ee5682, 0x1a811b1b, 
-	0x1a7d9549, 0x11f38a6a, 0x120321fa, 0x1a72fdb2, 0x1a6f73ca, 0x1208531c, 0x1217e256, 0x1a64cff8, 
-	0x1a6141fd, 0x121d10af, 0x122c9789, 0x1a5691f5, 0x1a52ffeb, 0x1231c316, 0x12414186, 0x1a4843b4, 
-	0x1a44ad9b, 0x12466a44, 0x1255e041, 0x1a39e53d, 0x1a364b17, 0x125b062b, 0x126a73ac, 0x1a2b7698, 
-	0x1a27d868, 0x126f96c1, 0x127efbbb, 0x1a1cf7ce, 0x1a195597, 0x12841bf6, 0x12937861, 0x1a0e68e9, 
-	0x1a0ac2ac, 0x129895c0, 0x12a7e991, 0x19ffc9f1, 0x19fc1fb1, 0x12ad0412, 0x12bc4f40, 0x19f11af0, 
-	0x19ed6caf, 0x12c166de, 0x12d0a960, 0x19e25bee, 0x19dea9ae, 0x12d5be18, 0x12e4f7e5, 0x19d38cf4, 
-	0x19cfd6b8, 0x12ea09b4, 0x12f93ac2, 0x19c4ae0c, 0x19c0f3d6, 0x12fe49a6, 0x130d71eb, 0x19b5bf3f, 
-	0x19b20111, 0x13127de0, 0x13219d53, 0x19a6c096, 0x19a2fe73, 0x1326a656, 0x1335bcef, 0x1997b21b, 
-	0x1993ec04, 0x133ac2fc, 0x1349d0b0, 0x198893d6, 0x1984c9ce, 0x134ed3c5, 0x135dd88c, 0x197965d0, 
-	0x197597da, 0x1362d8a6, 0x1371d476, 0x196a2815, 0x19665632, 0x1376d191, 0x1385c461, 0x195adaab, 
-	0x195704df, 0x138abe7b, 0x1399a841, 0x194b7d9e, 0x1947a3eb, 0x139e9f56, 0x13ad800a, 0x193c10f7, 
-	0x1938335e, 0x13b27417, 0x13c14bb0, 0x192c94bf, 0x1928b343, 0x13c63cb2, 0x13d50b26, 0x191d08ff, 
-	0x191923a3, 0x13d9f91b, 0x13e8be60, 0x190d6dc1, 0x19098488, 0x13eda944, 0x13fc6553, 0x18fdc310, 
-	0x18f9d5fa, 0x14014d23, 0x140ffff1, 0x18ee08f4, 0x18ea1805, 0x1414e4aa, 0x14238e2f, 0x18de3f77, 
-	0x18da4ab2, 0x14286fce, 0x14371001, 0x18ce66a3, 0x18ca6e0a, 0x143bee83, 0x144a855b, 0x18be7e82, 
-	0x18ba8217, 0x144f60bd, 0x145dee30, 0x18ae871e, 0x18aa86e3, 0x1462c670, 0x14714a76, 0x189e8080, 
-	0x189a7c78, 0x14761f8f, 0x14849a1f, 0x188e6ab2, 0x188a62e0, 0x14896c0f, 0x1497dd20, 0x187e45be, 
-	0x187a3a25, 0x149cabe4, 0x14ab136d, 0x186e11af, 0x186a0250, 0x14afdf03, 0x14be3cfa, 0x185dce8e, 
-	0x1859bb6c, 0x14c3055e, 0x14d159bc, 0x184d7c65, 0x18496583, 0x14d61eeb, 0x14e469a6, 0x183d1b3e, 
-	0x1839009e, 0x14e92b9e, 0x14f76cad, 0x182cab24, 0x18288cc8, 0x14fc2b6a, 0x150a62c6, 0x181c2c20, 
-	0x18180a0c, 0x150f1e45, 0x151d4be3, 0x180b9e3d, 0x18077873, 0x15220422, 0x153027fb, 0x17fb0185, 
-	0x17f6d807, 0x1534dcf6, 0x1542f700, 0x17ea5602, 0x17e628d3, 0x1547a8b5, 0x1555b8e8, 0x17d99bbe, 
-	0x17d56ae0, 0x155a6754, 0x15686da7, 0x17c8d2c4, 0x17c49e3b, 0x156d18c7, 0x157b1532, 0x17b7fb1f, 
-	0x17b3c2ec, 0x157fbd03, 0x158daf7c, 0x17a714d7, 0x17a2d8fe, 0x159253fb, 0x15a03c7a, 0x17961ff9, 
-	0x1791e07b, 0x15a4dda5, 0x15b2bc22, 0x17851c8e, 0x1780d96f, 0x15b759f5, 0x15c52e67, 0x17740aa1, 
-	0x176fc3e3, 0x15c9c8e0, 0x15d7933f, 0x1762ea3d, 0x175e9fe2, 0x15dc2a5a, 0x15e9ea9d, 0x1751bb6b, 
-	0x174d6d77, 0x15ee7e58, 0x15fc3477, 0x17407e37, 0x173c2cac, 0x1600c4cf, 0x160e70c1, 0x172f32ab, 
-	0x172add8c, 0x1612fdb3, 0x16209f70, 0x171dd8d2, 0x17198021, 0x162528fa, 0x1632c078, 0x170c70b7, 
-	0x17081477, 0x16374697, 0x1644d3d0, 0x16fafa64, 0x16f69a97, 0x16495680, 0x1656d96a, 0x16e975e4, 
-	0x16e5128e, 0x165b58aa, 0x1668d13e, 0x16d7e341, 0x16d37c65, 0x166d4d0a, 0x167abb3e, 0x16c64288, 
-	0x16c1d827, 0x167f3394, 0x168c9760, 0x16b493c2, 0x16b025e0, 0x16910c3d, 0x169e659a, 0x16a2d6fb
-};
-
-const int twidTab512[8*6 + 32*6 + 128*6] = {
-	0x20000000, 0x00000000, 0x1d906bcf, 0x0c3ef153, 0x16a09e66, 0x16a09e66, 0x0c3ef153, 0x1d906bcf, 
-	0x20000000, 0x00000000, 0x1f6297d0, 0x063e2e0f, 0x1d906bcf, 0x0c3ef153, 0x1a9b6629, 0x11c73b3a, 
-	0x20000000, 0x00000000, 0x1a9b6629, 0x11c73b3a, 0x0c3ef153, 0x1d906bcf, 0xf9c1d1f1, 0x1f6297d0, 
-	0x00000000, 0x20000000, 0xf3c10ead, 0x1d906bcf, 0xe95f619a, 0x16a09e66, 0xe26f9431, 0x0c3ef153, 
-	0x16a09e66, 0x16a09e66, 0x11c73b3a, 0x1a9b6629, 0x0c3ef153, 0x1d906bcf, 0x063e2e0f, 0x1f6297d0, 
-	0xe95f619a, 0x16a09e66, 0xe09d6830, 0x063e2e0f, 0xe26f9431, 0xf3c10ead, 0xee38c4c6, 0xe56499d7, 
-
-	0x20000000, 0x00000000, 0x1fd88da4, 0x0322f4d8, 0x1f6297d0, 0x063e2e0f, 0x1e9f4157, 0x094a0317, 
-	0x20000000, 0x00000000, 0x1ff621e3, 0x0191f65f, 0x1fd88da4, 0x0322f4d8, 0x1fa7557f, 0x04b2041c, 
-	0x20000000, 0x00000000, 0x1fa7557f, 0x04b2041c, 0x1e9f4157, 0x094a0317, 0x1ced7af4, 0x0dae8805, 
-	0x1d906bcf, 0x0c3ef153, 0x1c38b2f2, 0x0f15ae9c, 0x1a9b6629, 0x11c73b3a, 0x18bc806b, 0x144cf325, 
-	0x1f6297d0, 0x063e2e0f, 0x1f0a7efc, 0x07c67e5f, 0x1e9f4157, 0x094a0317, 0x1e212105, 0x0ac7cd3b, 
-	0x1a9b6629, 0x11c73b3a, 0x17b5df22, 0x157d6935, 0x144cf325, 0x18bc806b, 0x10738799, 0x1b728345, 
-	0x16a09e66, 0x16a09e66, 0x144cf325, 0x18bc806b, 0x11c73b3a, 0x1a9b6629, 0x0f15ae9c, 0x1c38b2f2, 
-	0x1d906bcf, 0x0c3ef153, 0x1ced7af4, 0x0dae8805, 0x1c38b2f2, 0x0f15ae9c, 0x1b728345, 0x10738799, 
-	0x0c3ef153, 0x1d906bcf, 0x07c67e5f, 0x1f0a7efc, 0x0322f4d8, 0x1fd88da4, 0xfe6e09a1, 0x1ff621e3, 
-	0x0c3ef153, 0x1d906bcf, 0x094a0317, 0x1e9f4157, 0x063e2e0f, 0x1f6297d0, 0x0322f4d8, 0x1fd88da4, 
-	0x1a9b6629, 0x11c73b3a, 0x19b3e048, 0x130ff7fd, 0x18bc806b, 0x144cf325, 0x17b5df22, 0x157d6935, 
-	0xf9c1d1f1, 0x1f6297d0, 0xf53832c5, 0x1e212105, 0xf0ea5164, 0x1c38b2f2, 0xecf00803, 0x19b3e048, 
-	0x00000000, 0x20000000, 0xfcdd0b28, 0x1fd88da4, 0xf9c1d1f1, 0x1f6297d0, 0xf6b5fce9, 0x1e9f4157, 
-	0x16a09e66, 0x16a09e66, 0x157d6935, 0x17b5df22, 0x144cf325, 0x18bc806b, 0x130ff7fd, 0x19b3e048, 
-	0xe95f619a, 0x16a09e66, 0xe64c1fb8, 0x130ff7fd, 0xe3c74d0e, 0x0f15ae9c, 0xe1dedefb, 0x0ac7cd3b, 
-	0xf3c10ead, 0x1d906bcf, 0xf0ea5164, 0x1c38b2f2, 0xee38c4c6, 0x1a9b6629, 0xebb30cdb, 0x18bc806b, 
-	0x11c73b3a, 0x1a9b6629, 0x10738799, 0x1b728345, 0x0f15ae9c, 0x1c38b2f2, 0x0dae8805, 0x1ced7af4, 
-	0xe09d6830, 0x063e2e0f, 0xe009de1d, 0x0191f65f, 0xe027725c, 0xfcdd0b28, 0xe0f58104, 0xf83981a1, 
-	0xe95f619a, 0x16a09e66, 0xe7437f95, 0x144cf325, 0xe56499d7, 0x11c73b3a, 0xe3c74d0e, 0x0f15ae9c, 
-	0x0c3ef153, 0x1d906bcf, 0x0ac7cd3b, 0x1e212105, 0x094a0317, 0x1e9f4157, 0x07c67e5f, 0x1f0a7efc, 
-	0xe26f9431, 0xf3c10ead, 0xe48d7cbb, 0xef8c7867, 0xe7437f95, 0xebb30cdb, 0xea8296cb, 0xe84a20de, 
-	0xe26f9431, 0x0c3ef153, 0xe160bea9, 0x094a0317, 0xe09d6830, 0x063e2e0f, 0xe027725c, 0x0322f4d8, 
-	0x063e2e0f, 0x1f6297d0, 0x04b2041c, 0x1fa7557f, 0x0322f4d8, 0x1fd88da4, 0x0191f65f, 0x1ff621e3, 
-	0xee38c4c6, 0xe56499d7, 0xf25177fb, 0xe312850c, 0xf6b5fce9, 0xe160bea9, 0xfb4dfbe4, 0xe058aa81, 
-
-	0x20000000, 0x00000000, 0x1ffd8861, 0x00c90ab0, 0x1ff621e3, 0x0191f65f, 0x1fe9cdad, 0x025aa412, 
-	0x20000000, 0x00000000, 0x1fff6217, 0x00648748, 0x1ffd8861, 0x00c90ab0, 0x1ffa72f0, 0x012d8657, 
-	0x20000000, 0x00000000, 0x1ffa72f0, 0x012d8657, 0x1fe9cdad, 0x025aa412, 0x1fce15fd, 0x0386f0b9, 
-	0x1fd88da4, 0x0322f4d8, 0x1fc26471, 0x03eac9cb, 0x1fa7557f, 0x04b2041c, 0x1f8764fa, 0x05788511, 
-	0x1ff621e3, 0x0191f65f, 0x1ff09566, 0x01f656e8, 0x1fe9cdad, 0x025aa412, 0x1fe1cafd, 0x02beda01, 
-	0x1fa7557f, 0x04b2041c, 0x1f7599a4, 0x05db7678, 0x1f38f3ac, 0x0702e09b, 0x1ef178a4, 0x0827dc07, 
-	0x1f6297d0, 0x063e2e0f, 0x1f38f3ac, 0x0702e09b, 0x1f0a7efc, 0x07c67e5f, 0x1ed740e7, 0x0888e931, 
-	0x1fd88da4, 0x0322f4d8, 0x1fce15fd, 0x0386f0b9, 0x1fc26471, 0x03eac9cb, 0x1fb57972, 0x044e7c34, 
-	0x1e9f4157, 0x094a0317, 0x1e426a4b, 0x0a68f121, 0x1ddb13b7, 0x0b844298, 0x1d696174, 0x0c9b9532, 
-	0x1e9f4157, 0x094a0317, 0x1e6288ec, 0x0a09ae4a, 0x1e212105, 0x0ac7cd3b, 0x1ddb13b7, 0x0b844298, 
-	0x1fa7557f, 0x04b2041c, 0x1f97f925, 0x05155dac, 0x1f8764fa, 0x05788511, 0x1f7599a4, 0x05db7678, 
-	0x1ced7af4, 0x0dae8805, 0x1c678b35, 0x0ebcbbae, 0x1bd7c0ac, 0x0fc5d26e, 0x1b3e4d3f, 0x10c9704d, 
-	0x1d906bcf, 0x0c3ef153, 0x1d4134d1, 0x0cf7bca2, 0x1ced7af4, 0x0dae8805, 0x1c954b21, 0x0e63374d, 
-	0x1f6297d0, 0x063e2e0f, 0x1f4e603b, 0x06a0a809, 0x1f38f3ac, 0x0702e09b, 0x1f2252f7, 0x0764d3f9, 
-	0x1a9b6629, 0x11c73b3a, 0x19ef43ef, 0x12bedb26, 0x193a224a, 0x13affa29, 0x187c4010, 0x149a449c, 
-	0x1c38b2f2, 0x0f15ae9c, 0x1bd7c0ac, 0x0fc5d26e, 0x1b728345, 0x10738799, 0x1b090a58, 0x111eb354, 
-	0x1f0a7efc, 0x07c67e5f, 0x1ef178a4, 0x0827dc07, 0x1ed740e7, 0x0888e931, 0x1ebbd8c9, 0x08e9a220, 
-	0x17b5df22, 0x157d6935, 0x16e74455, 0x16591926, 0x1610b755, 0x172d0838, 0x15328293, 0x17f8ece3, 
-	0x1a9b6629, 0x11c73b3a, 0x1a29a7a0, 0x126d054d, 0x19b3e048, 0x130ff7fd, 0x193a224a, 0x13affa29, 
-	0x1e9f4157, 0x094a0317, 0x1e817bab, 0x09aa0861, 0x1e6288ec, 0x0a09ae4a, 0x1e426a4b, 0x0a68f121, 
-	0x144cf325, 0x18bc806b, 0x136058b1, 0x19777ef5, 0x126d054d, 0x1a29a7a0, 0x11734d64, 0x1ad2bc9e, 
-	0x18bc806b, 0x144cf325, 0x183b0e0c, 0x14e6cabc, 0x17b5df22, 0x157d6935, 0x172d0838, 0x1610b755, 
-	0x1e212105, 0x0ac7cd3b, 0x1dfeae62, 0x0b263eef, 0x1ddb13b7, 0x0b844298, 0x1db65262, 0x0be1d499, 
-	0x10738799, 0x1b728345, 0x0f6e0ca9, 0x1c08c426, 0x0e63374d, 0x1c954b21, 0x0d536416, 0x1d17e774, 
-	0x16a09e66, 0x16a09e66, 0x1610b755, 0x172d0838, 0x157d6935, 0x17b5df22, 0x14e6cabc, 0x183b0e0c, 
-	0x1d906bcf, 0x0c3ef153, 0x1d696174, 0x0c9b9532, 0x1d4134d1, 0x0cf7bca2, 0x1d17e774, 0x0d536416, 
-	0x0c3ef153, 0x1d906bcf, 0x0b263eef, 0x1dfeae62, 0x0a09ae4a, 0x1e6288ec, 0x08e9a220, 0x1ebbd8c9, 
-	0x144cf325, 0x18bc806b, 0x13affa29, 0x193a224a, 0x130ff7fd, 0x19b3e048, 0x126d054d, 0x1a29a7a0, 
-	0x1ced7af4, 0x0dae8805, 0x1cc1f0f4, 0x0e0924ec, 0x1c954b21, 0x0e63374d, 0x1c678b35, 0x0ebcbbae, 
-	0x07c67e5f, 0x1f0a7efc, 0x06a0a809, 0x1f4e603b, 0x05788511, 0x1f8764fa, 0x044e7c34, 0x1fb57972, 
-	0x11c73b3a, 0x1a9b6629, 0x111eb354, 0x1b090a58, 0x10738799, 0x1b728345, 0x0fc5d26e, 0x1bd7c0ac, 
-	0x1c38b2f2, 0x0f15ae9c, 0x1c08c426, 0x0f6e0ca9, 0x1bd7c0ac, 0x0fc5d26e, 0x1ba5aa67, 0x101cfc87, 
-	0x0322f4d8, 0x1fd88da4, 0x01f656e8, 0x1ff09566, 0x00c90ab0, 0x1ffd8861, 0xff9b78b8, 0x1fff6217, 
-	0x0f15ae9c, 0x1c38b2f2, 0x0e63374d, 0x1c954b21, 0x0dae8805, 0x1ced7af4, 0x0cf7bca2, 0x1d4134d1, 
-	0x1b728345, 0x10738799, 0x1b3e4d3f, 0x10c9704d, 0x1b090a58, 0x111eb354, 0x1ad2bc9e, 0x11734d64, 
-	0xfe6e09a1, 0x1ff621e3, 0xfd4125ff, 0x1fe1cafd, 0xfc153635, 0x1fc26471, 0xfaeaa254, 0x1f97f925, 
-	0x0c3ef153, 0x1d906bcf, 0x0b844298, 0x1ddb13b7, 0x0ac7cd3b, 0x1e212105, 0x0a09ae4a, 0x1e6288ec, 
-	0x1a9b6629, 0x11c73b3a, 0x1a63091b, 0x121a7999, 0x1a29a7a0, 0x126d054d, 0x19ef43ef, 0x12bedb26, 
-	0xf9c1d1f1, 0x1f6297d0, 0xf89b2c07, 0x1f2252f7, 0xf77716cf, 0x1ed740e7, 0xf655f79f, 0x1e817bab, 
-	0x094a0317, 0x1e9f4157, 0x0888e931, 0x1ed740e7, 0x07c67e5f, 0x1f0a7efc, 0x0702e09b, 0x1f38f3ac, 
-	0x19b3e048, 0x130ff7fd, 0x19777ef5, 0x136058b1, 0x193a224a, 0x13affa29, 0x18fbcca4, 0x13fed953, 
-	0xf53832c5, 0x1e212105, 0xf41e2b67, 0x1db65262, 0xf308435e, 0x1d4134d1, 0xf1f6db14, 0x1cc1f0f4, 
-	0x063e2e0f, 0x1f6297d0, 0x05788511, 0x1f8764fa, 0x04b2041c, 0x1fa7557f, 0x03eac9cb, 0x1fc26471, 
-	0x18bc806b, 0x144cf325, 0x187c4010, 0x149a449c, 0x183b0e0c, 0x14e6cabc, 0x17f8ece3, 0x15328293, 
-	0xf0ea5164, 0x1c38b2f2, 0xefe30379, 0x1ba5aa67, 0xeee14cac, 0x1b090a58, 0xede58667, 0x1a63091b, 
-	0x0322f4d8, 0x1fd88da4, 0x025aa412, 0x1fe9cdad, 0x0191f65f, 0x1ff621e3, 0x00c90ab0, 0x1ffd8861, 
-	0x17b5df22, 0x157d6935, 0x1771e75f, 0x15c77bbe, 0x172d0838, 0x1610b755, 0x16e74455, 0x16591926, 
-	0xecf00803, 0x19b3e048, 0xec0126ad, 0x18fbcca4, 0xeb193544, 0x183b0e0c, 0xea388442, 0x1771e75f, 
-	0x00000000, 0x20000000, 0xff36f550, 0x1ffd8861, 0xfe6e09a1, 0x1ff621e3, 0xfda55bee, 0x1fe9cdad, 
-	0x16a09e66, 0x16a09e66, 0x16591926, 0x16e74455, 0x1610b755, 0x172d0838, 0x15c77bbe, 0x1771e75f, 
-	0xe95f619a, 0x16a09e66, 0xe88e18a1, 0x15c77bbe, 0xe7c4f1f4, 0x14e6cabc, 0xe704335c, 0x13fed953, 
-	0xfcdd0b28, 0x1fd88da4, 0xfc153635, 0x1fc26471, 0xfb4dfbe4, 0x1fa7557f, 0xfa877aef, 0x1f8764fa, 
-	0x157d6935, 0x17b5df22, 0x15328293, 0x17f8ece3, 0x14e6cabc, 0x183b0e0c, 0x149a449c, 0x187c4010, 
-	0xe64c1fb8, 0x130ff7fd, 0xe59cf6e5, 0x121a7999, 0xe4f6f5a8, 0x111eb354, 0xe45a5599, 0x101cfc87, 
-	0xf9c1d1f1, 0x1f6297d0, 0xf8fd1f65, 0x1f38f3ac, 0xf83981a1, 0x1f0a7efc, 0xf77716cf, 0x1ed740e7, 
-	0x144cf325, 0x18bc806b, 0x13fed953, 0x18fbcca4, 0x13affa29, 0x193a224a, 0x136058b1, 0x19777ef5, 
-	0xe3c74d0e, 0x0f15ae9c, 0xe33e0f0c, 0x0e0924ec, 0xe2becb2f, 0x0cf7bca2, 0xe249ad9e, 0x0be1d499, 
-	0xf6b5fce9, 0x1e9f4157, 0xf5f651b6, 0x1e6288ec, 0xf53832c5, 0x1e212105, 0xf47bbd68, 0x1ddb13b7, 
-	0x130ff7fd, 0x19b3e048, 0x12bedb26, 0x19ef43ef, 0x126d054d, 0x1a29a7a0, 0x121a7999, 0x1a63091b, 
-	0xe1dedefb, 0x0ac7cd3b, 0xe17e8455, 0x09aa0861, 0xe128bf19, 0x0888e931, 0xe0ddad09, 0x0764d3f9, 
-	0xf3c10ead, 0x1d906bcf, 0xf308435e, 0x1d4134d1, 0xf25177fb, 0x1ced7af4, 0xf19cc8b3, 0x1c954b21, 
-	0x11c73b3a, 0x1a9b6629, 0x11734d64, 0x1ad2bc9e, 0x111eb354, 0x1b090a58, 0x10c9704d, 0x1b3e4d3f, 
-	0xe09d6830, 0x063e2e0f, 0xe06806db, 0x05155dac, 0xe03d9b8f, 0x03eac9cb, 0xe01e3503, 0x02beda01, 
-	0xf0ea5164, 0x1c38b2f2, 0xf03a2d92, 0x1bd7c0ac, 0xef8c7867, 0x1b728345, 0xeee14cac, 0x1b090a58, 
-	0x10738799, 0x1b728345, 0x101cfc87, 0x1ba5aa67, 0x0fc5d26e, 0x1bd7c0ac, 0x0f6e0ca9, 0x1c08c426, 
-	0xe009de1d, 0x0191f65f, 0xe0009de9, 0x00648748, 0xe002779f, 0xff36f550, 0xe00f6a9a, 0xfe09a918, 
-	0xee38c4c6, 0x1a9b6629, 0xed92fab3, 0x1a29a7a0, 0xecf00803, 0x19b3e048, 0xec5005d7, 0x193a224a, 
-	0x0f15ae9c, 0x1c38b2f2, 0x0ebcbbae, 0x1c678b35, 0x0e63374d, 0x1c954b21, 0x0e0924ec, 0x1cc1f0f4, 
-	0xe027725c, 0xfcdd0b28, 0xe04a868e, 0xfbb183cc, 0xe0789b06, 0xfa877aef, 0xe0b19fc5, 0xf95f57f7, 
-	0xebb30cdb, 0x18bc806b, 0xeb193544, 0x183b0e0c, 0xea8296cb, 0x17b5df22, 0xe9ef48ab, 0x172d0838, 
-	0x0dae8805, 0x1ced7af4, 0x0d536416, 0x1d17e774, 0x0cf7bca2, 0x1d4134d1, 0x0c9b9532, 0x1d696174, 
-	0xe0f58104, 0xf83981a1, 0xe1442737, 0xf7165de0, 0xe19d7714, 0xf5f651b6, 0xe201519e, 0xf4d9c111, 
-	0xe95f619a, 0x16a09e66, 0xe8d2f7c8, 0x1610b755, 0xe84a20de, 0x157d6935, 0xe7c4f1f4, 0x14e6cabc, 
-	0x0c3ef153, 0x1d906bcf, 0x0be1d499, 0x1db65262, 0x0b844298, 0x1ddb13b7, 0x0b263eef, 0x1dfeae62, 
-	0xe26f9431, 0xf3c10ead, 0xe2e8188c, 0xf2ac9bea, 0xe36ab4df, 0xf19cc8b3, 0xe3f73bda, 0xf091f357, 
-	0xe7437f95, 0x144cf325, 0xe6c5ddb6, 0x13affa29, 0xe64c1fb8, 0x130ff7fd, 0xe5d65860, 0x126d054d, 
-	0x0ac7cd3b, 0x1e212105, 0x0a68f121, 0x1e426a4b, 0x0a09ae4a, 0x1e6288ec, 0x09aa0861, 0x1e817bab, 
-	0xe48d7cbb, 0xef8c7867, 0xe52d4362, 0xee8cb29c, 0xe5d65860, 0xed92fab3, 0xe688810b, 0xec9fa74f, 
-	0xe56499d7, 0x11c73b3a, 0xe4f6f5a8, 0x111eb354, 0xe48d7cbb, 0x10738799, 0xe4283f54, 0x0fc5d26e, 
-	0x094a0317, 0x1e9f4157, 0x08e9a220, 0x1ebbd8c9, 0x0888e931, 0x1ed740e7, 0x0827dc07, 0x1ef178a4, 
-	0xe7437f95, 0xebb30cdb, 0xe807131d, 0xeacd7d6d, 0xe8d2f7c8, 0xe9ef48ab, 0xe9a6e6da, 0xe918bbab, 
-	0xe3c74d0e, 0x0f15ae9c, 0xe36ab4df, 0x0e63374d, 0xe312850c, 0x0dae8805, 0xe2becb2f, 0x0cf7bca2, 
-	0x07c67e5f, 0x1f0a7efc, 0x0764d3f9, 0x1f2252f7, 0x0702e09b, 0x1f38f3ac, 0x06a0a809, 0x1f4e603b, 
-	0xea8296cb, 0xe84a20de, 0xeb65bb64, 0xe783bff0, 0xec5005d7, 0xe6c5ddb6, 0xed4124da, 0xe610bc11, 
-	0xe26f9431, 0x0c3ef153, 0xe224ec49, 0x0b844298, 0xe1dedefb, 0x0ac7cd3b, 0xe19d7714, 0x0a09ae4a, 
-	0x063e2e0f, 0x1f6297d0, 0x05db7678, 0x1f7599a4, 0x05788511, 0x1f8764fa, 0x05155dac, 0x1f97f925, 
-	0xee38c4c6, 0xe56499d7, 0xef368fb3, 0xe4c1b2c1, 0xf03a2d92, 0xe4283f54, 0xf1434452, 0xe39874cb, 
-	0xe160bea9, 0x094a0317, 0xe128bf19, 0x0888e931, 0xe0f58104, 0x07c67e5f, 0xe0c70c54, 0x0702e09b, 
-	0x04b2041c, 0x1fa7557f, 0x044e7c34, 0x1fb57972, 0x03eac9cb, 0x1fc26471, 0x0386f0b9, 0x1fce15fd, 
-	0xf25177fb, 0xe312850c, 0xf3646ace, 0xe2969e8c, 0xf47bbd68, 0xe224ec49, 0xf5970edf, 0xe1bd95b5, 
-	0xe09d6830, 0x063e2e0f, 0xe0789b06, 0x05788511, 0xe058aa81, 0x04b2041c, 0xe03d9b8f, 0x03eac9cb, 
-	0x0322f4d8, 0x1fd88da4, 0x02beda01, 0x1fe1cafd, 0x025aa412, 0x1fe9cdad, 0x01f656e8, 0x1ff09566, 
-	0xf6b5fce9, 0xe160bea9, 0xf7d823f9, 0xe10e875c, 0xf8fd1f65, 0xe0c70c54, 0xfa248988, 0xe08a665c, 
-	0xe027725c, 0x0322f4d8, 0xe0163253, 0x025aa412, 0xe009de1d, 0x0191f65f, 0xe002779f, 0x00c90ab0, 
-	0x0191f65f, 0x1ff621e3, 0x012d8657, 0x1ffa72f0, 0x00c90ab0, 0x1ffd8861, 0x00648748, 0x1fff6217, 
-	0xfb4dfbe4, 0xe058aa81, 0xfc790f47, 0xe031ea03, 0xfda55bee, 0xe0163253, 0xfed279a9, 0xe0058d10
-};
-
-const int twidTab64[4*6 + 16*6] = {
-	0x20000000, 0x00000000, 0x16a09e66, 0x16a09e66, 0x00000000, 0x20000000, 0xe95f619a, 0x16a09e66, 
-	0x20000000, 0x00000000, 0x1d906bcf, 0x0c3ef153, 0x16a09e66, 0x16a09e66, 0x0c3ef153, 0x1d906bcf, 
-	0x20000000, 0x00000000, 0x0c3ef153, 0x1d906bcf, 0xe95f619a, 0x16a09e66, 0xe26f9431, 0xf3c10ead, 
-
-	0x20000000, 0x00000000, 0x1f6297d0, 0x063e2e0f, 0x1d906bcf, 0x0c3ef153, 0x1a9b6629, 0x11c73b3a, 
-	0x20000000, 0x00000000, 0x1fd88da4, 0x0322f4d8, 0x1f6297d0, 0x063e2e0f, 0x1e9f4157, 0x094a0317, 
-	0x20000000, 0x00000000, 0x1e9f4157, 0x094a0317, 0x1a9b6629, 0x11c73b3a, 0x144cf325, 0x18bc806b, 
-	0x16a09e66, 0x16a09e66, 0x11c73b3a, 0x1a9b6629, 0x0c3ef153, 0x1d906bcf, 0x063e2e0f, 0x1f6297d0, 
-	0x1d906bcf, 0x0c3ef153, 0x1c38b2f2, 0x0f15ae9c, 0x1a9b6629, 0x11c73b3a, 0x18bc806b, 0x144cf325, 
-	0x0c3ef153, 0x1d906bcf, 0x0322f4d8, 0x1fd88da4, 0xf9c1d1f1, 0x1f6297d0, 0xf0ea5164, 0x1c38b2f2, 
-	0x00000000, 0x20000000, 0xf9c1d1f1, 0x1f6297d0, 0xf3c10ead, 0x1d906bcf, 0xee38c4c6, 0x1a9b6629, 
-	0x16a09e66, 0x16a09e66, 0x144cf325, 0x18bc806b, 0x11c73b3a, 0x1a9b6629, 0x0f15ae9c, 0x1c38b2f2, 
-	0xe95f619a, 0x16a09e66, 0xe3c74d0e, 0x0f15ae9c, 0xe09d6830, 0x063e2e0f, 0xe027725c, 0xfcdd0b28, 
-	0xe95f619a, 0x16a09e66, 0xe56499d7, 0x11c73b3a, 0xe26f9431, 0x0c3ef153, 0xe09d6830, 0x063e2e0f, 
-	0x0c3ef153, 0x1d906bcf, 0x094a0317, 0x1e9f4157, 0x063e2e0f, 0x1f6297d0, 0x0322f4d8, 0x1fd88da4, 
-	0xe26f9431, 0xf3c10ead, 0xe7437f95, 0xebb30cdb, 0xee38c4c6, 0xe56499d7, 0xf6b5fce9, 0xe160bea9
-};
-
+#include "aac_rom.h"
+
+#if defined (ARMV5E) && !defined (ARMV7Neon)
+
+/*
+ *  Q30 for 128 and 1024
+ *
+ * for (i = 0; i < num/4; i++) {
+ *   angle = (i + 0.125) * M_PI / num;
+ *   x = cos(angle) * (1 << 30);
+ *   x = sin(angle) * (1 << 30);
+ *
+ *   angle = (num/2 - 1 - i + 0.125) * M_PI / num;
+ *   x = cos(angle) * (1 << 30);
+ *   x = sin(angle) * (1 << 30);
+ * }
+ */
+const int cossintab[128 + 1024] = {
+	/* 128 */
+	0x3fffec43, 0x003243f1, 0x015fd4d2, 0x3ffc38d1, 0x3ff9c13a, 0x01c454f5, 0x02f1b755, 0x3feea776,
+	0x3fe9b8a9, 0x03562038, 0x0483259d, 0x3fd73a4a, 0x3fcfd50b, 0x04e767c5, 0x0613e1c5, 0x3fb5f4ea,
+	0x3fac1a5b, 0x0677edbb, 0x07a3adff, 0x3f8adc77, 0x3f7e8e1e, 0x08077457, 0x09324ca7, 0x3f55f796,
+	0x3f473759, 0x0995bdfd, 0x0abf8043, 0x3f174e70, 0x3f061e95, 0x0b228d42, 0x0c4b0b94, 0x3eceeaad,
+	0x3ebb4ddb, 0x0cada4f5, 0x0dd4b19a, 0x3e7cd778, 0x3e66d0b4, 0x0e36c82a, 0x0f5c35a3, 0x3e212179,
+	0x3e08b42a, 0x0fbdba40, 0x10e15b4e, 0x3dbbd6d4, 0x3da106bd, 0x11423ef0, 0x1263e699, 0x3d4d0728,
+	0x3d2fd86c, 0x12c41a4f, 0x13e39be9, 0x3cd4c38b, 0x3cb53aaa, 0x144310dd, 0x15604013, 0x3c531e88,
+	0x3c314060, 0x15bee78c, 0x16d99864, 0x3bc82c1f, 0x3ba3fde7, 0x173763c9, 0x184f6aab, 0x3b3401bb,
+	0x3b0d8909, 0x18ac4b87, 0x19c17d44, 0x3a96b636, 0x3a6df8f8, 0x1a1d6544, 0x1b2f971e, 0x39f061d2,
+	0x39c5664f, 0x1b8a7815, 0x1c997fc4, 0x39411e33, 0x3913eb0e, 0x1cf34baf, 0x1dfeff67, 0x38890663,
+	0x3859a292, 0x1e57a86d, 0x1f5fdee6, 0x37c836c2, 0x3796a996, 0x1fb7575c, 0x20bbe7d8, 0x36fecd0e,
+	0x36cb1e2a, 0x21122240, 0x2212e492, 0x362ce855, 0x35f71fb1, 0x2267d3a0, 0x2364a02e, 0x3552a8f4,
+	0x351acedd, 0x23b836ca, 0x24b0e699, 0x34703095, 0x34364da6, 0x250317df, 0x25f78497, 0x3385a222,
+	0x3349bf48, 0x264843d9, 0x273847c8, 0x329321c7, 0x32554840, 0x27878893, 0x2872feb6, 0x3198d4ea,
+	0x31590e3e, 0x28c0b4d2, 0x29a778db, 0x3096e223, 0x30553828, 0x29f3984c, 0x2ad586a3, 0x2f8d713a,
+	0x2f49ee0f, 0x2b2003ac, 0x2bfcf97c, 0x2e7cab1c, 0x2e37592c, 0x2c45c8a0, 0x2d1da3d5, 0x2d64b9da,
+	/* 1024 */
+	0x3fffffb1, 0x0006487f, 0x002bfb74, 0x3ffff0e3, 0x3fffe705, 0x00388c6e, 0x005e3f4c, 0x3fffba9b,
+	0x3fffa6de, 0x006ad03b, 0x009082ea, 0x3fff5cd8, 0x3fff3f3c, 0x009d13c5, 0x00c2c62f, 0x3ffed79b,
+	0x3ffeb021, 0x00cf56ef, 0x00f508fc, 0x3ffe2ae5, 0x3ffdf98c, 0x01019998, 0x01274b31, 0x3ffd56b5,
+	0x3ffd1b7e, 0x0133dba3, 0x01598cb1, 0x3ffc5b0c, 0x3ffc15f7, 0x01661cf0, 0x018bcd5b, 0x3ffb37ec,
+	0x3ffae8f9, 0x01985d60, 0x01be0d11, 0x3ff9ed53, 0x3ff99483, 0x01ca9cd4, 0x01f04bb4, 0x3ff87b44,
+	0x3ff81896, 0x01fcdb2e, 0x02228924, 0x3ff6e1bf, 0x3ff67534, 0x022f184d, 0x0254c544, 0x3ff520c5,
+	0x3ff4aa5d, 0x02615414, 0x0286fff3, 0x3ff33858, 0x3ff2b813, 0x02938e62, 0x02b93914, 0x3ff12878,
+	0x3ff09e56, 0x02c5c71a, 0x02eb7086, 0x3feef126, 0x3fee5d28, 0x02f7fe1c, 0x031da62b, 0x3fec9265,
+	0x3febf48b, 0x032a3349, 0x034fd9e5, 0x3fea0c35, 0x3fe96480, 0x035c6682, 0x03820b93, 0x3fe75e98,
+	0x3fe6ad08, 0x038e97a9, 0x03b43b17, 0x3fe48990, 0x3fe3ce26, 0x03c0c69e, 0x03e66852, 0x3fe18d1f,
+	0x3fe0c7da, 0x03f2f342, 0x04189326, 0x3fde6945, 0x3fdd9a27, 0x04251d77, 0x044abb73, 0x3fdb1e06,
+	0x3fda450f, 0x0457451d, 0x047ce11a, 0x3fd7ab64, 0x3fd6c894, 0x04896a16, 0x04af03fc, 0x3fd4115f,
+	0x3fd324b7, 0x04bb8c42, 0x04e123fa, 0x3fd04ffc, 0x3fcf597c, 0x04edab83, 0x051340f6, 0x3fcc673b,
+	0x3fcb66e4, 0x051fc7b9, 0x05455ad1, 0x3fc8571f, 0x3fc74cf3, 0x0551e0c7, 0x0577716b, 0x3fc41fac,
+	0x3fc30baa, 0x0583f68c, 0x05a984a6, 0x3fbfc0e3, 0x3fbea30c, 0x05b608eb, 0x05db9463, 0x3fbb3ac7,
+	0x3fba131b, 0x05e817c3, 0x060da083, 0x3fb68d5b, 0x3fb55bdc, 0x061a22f7, 0x063fa8e7, 0x3fb1b8a2,
+	0x3fb07d50, 0x064c2a67, 0x0671ad71, 0x3facbc9f, 0x3fab777b, 0x067e2df5, 0x06a3ae00, 0x3fa79954,
+	0x3fa64a5f, 0x06b02d81, 0x06d5aa77, 0x3fa24ec6, 0x3fa0f600, 0x06e228ee, 0x0707a2b7, 0x3f9cdcf7,
+	0x3f9b7a62, 0x0714201b, 0x073996a1, 0x3f9743eb, 0x3f95d787, 0x074612eb, 0x076b8616, 0x3f9183a5,
+	0x3f900d72, 0x0778013d, 0x079d70f7, 0x3f8b9c28, 0x3f8a1c29, 0x07a9eaf5, 0x07cf5726, 0x3f858d79,
+	0x3f8403ae, 0x07dbcff2, 0x08013883, 0x3f7f579b, 0x3f7dc405, 0x080db016, 0x083314f1, 0x3f78fa92,
+	0x3f775d31, 0x083f8b43, 0x0864ec4f, 0x3f727661, 0x3f70cf38, 0x08716159, 0x0896be80, 0x3f6bcb0e,
+	0x3f6a1a1c, 0x08a3323a, 0x08c88b65, 0x3f64f89b, 0x3f633de2, 0x08d4fdc6, 0x08fa52de, 0x3f5dff0e,
+	0x3f5c3a8f, 0x0906c3e0, 0x092c14ce, 0x3f56de6a, 0x3f551026, 0x09388469, 0x095dd116, 0x3f4f96b4,
+	0x3f4dbeac, 0x096a3f42, 0x098f8796, 0x3f4827f0, 0x3f464626, 0x099bf44c, 0x09c13831, 0x3f409223,
+	0x3f3ea697, 0x09cda368, 0x09f2e2c7, 0x3f38d552, 0x3f36e006, 0x09ff4c78, 0x0a24873a, 0x3f30f181,
+	0x3f2ef276, 0x0a30ef5e, 0x0a56256c, 0x3f28e6b6, 0x3f26ddec, 0x0a628bfa, 0x0a87bd3d, 0x3f20b4f5,
+	0x3f1ea26e, 0x0a94222f, 0x0ab94e8f, 0x3f185c43, 0x3f164001, 0x0ac5b1dc, 0x0aead944, 0x3f0fdca5,
+	0x3f0db6a9, 0x0af73ae5, 0x0b1c5d3d, 0x3f073621, 0x3f05066d, 0x0b28bd2a, 0x0b4dda5c, 0x3efe68bc,
+	0x3efc2f50, 0x0b5a388d, 0x0b7f5081, 0x3ef5747b, 0x3ef3315a, 0x0b8bacf0, 0x0bb0bf8f, 0x3eec5965,
+	0x3eea0c8e, 0x0bbd1a33, 0x0be22766, 0x3ee3177e, 0x3ee0c0f4, 0x0bee8038, 0x0c1387e9, 0x3ed9aecc,
+	0x3ed74e91, 0x0c1fdee1, 0x0c44e0f9, 0x3ed01f55, 0x3ecdb56a, 0x0c513610, 0x0c763278, 0x3ec66920,
+	0x3ec3f585, 0x0c8285a5, 0x0ca77c47, 0x3ebc8c31, 0x3eba0ee9, 0x0cb3cd84, 0x0cd8be47, 0x3eb2888f,
+	0x3eb0019c, 0x0ce50d8c, 0x0d09f85b, 0x3ea85e41, 0x3ea5cda3, 0x0d1645a0, 0x0d3b2a64, 0x3e9e0d4c,
+	0x3e9b7306, 0x0d4775a1, 0x0d6c5443, 0x3e9395b7, 0x3e90f1ca, 0x0d789d71, 0x0d9d75db, 0x3e88f788,
+	0x3e8649f5, 0x0da9bcf2, 0x0dce8f0d, 0x3e7e32c6, 0x3e7b7b90, 0x0ddad406, 0x0dff9fba, 0x3e734778,
+	0x3e70869f, 0x0e0be28e, 0x0e30a7c5, 0x3e6835a4, 0x3e656b2b, 0x0e3ce86b, 0x0e61a70f, 0x3e5cfd51,
+	0x3e5a2939, 0x0e6de580, 0x0e929d7a, 0x3e519e86, 0x3e4ec0d1, 0x0e9ed9af, 0x0ec38ae8, 0x3e46194a,
+	0x3e4331fa, 0x0ecfc4d9, 0x0ef46f3b, 0x3e3a6da4, 0x3e377cbb, 0x0f00a6df, 0x0f254a53, 0x3e2e9b9c,
+	0x3e2ba11b, 0x0f317fa5, 0x0f561c15, 0x3e22a338, 0x3e1f9f21, 0x0f624f0c, 0x0f86e460, 0x3e168480,
+	0x3e1376d5, 0x0f9314f5, 0x0fb7a317, 0x3e0a3f7b, 0x3e07283f, 0x0fc3d143, 0x0fe8581d, 0x3dfdd432,
+	0x3dfab365, 0x0ff483d7, 0x10190352, 0x3df142ab, 0x3dee1851, 0x10252c94, 0x1049a49a, 0x3de48aef,
+	0x3de15708, 0x1055cb5b, 0x107a3bd5, 0x3dd7ad05, 0x3dd46f94, 0x1086600e, 0x10aac8e6, 0x3dcaa8f5,
+	0x3dc761fc, 0x10b6ea90, 0x10db4baf, 0x3dbd7ec7, 0x3dba2e48, 0x10e76ac3, 0x110bc413, 0x3db02e84,
+	0x3dacd481, 0x1117e088, 0x113c31f3, 0x3da2b834, 0x3d9f54af, 0x11484bc2, 0x116c9531, 0x3d951bde,
+	0x3d91aed9, 0x1178ac53, 0x119cedaf, 0x3d87598c, 0x3d83e309, 0x11a9021d, 0x11cd3b50, 0x3d797145,
+	0x3d75f147, 0x11d94d02, 0x11fd7df6, 0x3d6b6313, 0x3d67d99b, 0x12098ce5, 0x122db583, 0x3d5d2efe,
+	0x3d599c0e, 0x1239c1a7, 0x125de1da, 0x3d4ed50f, 0x3d4b38aa, 0x1269eb2b, 0x128e02dc, 0x3d40554e,
+	0x3d3caf76, 0x129a0954, 0x12be186c, 0x3d31afc5, 0x3d2e007c, 0x12ca1c03, 0x12ee226c, 0x3d22e47c,
+	0x3d1f2bc5, 0x12fa231b, 0x131e20c0, 0x3d13f37e, 0x3d10315a, 0x132a1e7e, 0x134e1348, 0x3d04dcd2,
+	0x3d011145, 0x135a0e0e, 0x137df9e7, 0x3cf5a082, 0x3cf1cb8e, 0x1389f1af, 0x13add481, 0x3ce63e98,
+	0x3ce2603f, 0x13b9c943, 0x13dda2f7, 0x3cd6b71e, 0x3cd2cf62, 0x13e994ab, 0x140d652c, 0x3cc70a1c,
+	0x3cc318ff, 0x141953cb, 0x143d1b02, 0x3cb7379c, 0x3cb33d22, 0x14490685, 0x146cc45c, 0x3ca73fa9,
+	0x3ca33bd3, 0x1478acbc, 0x149c611d, 0x3c97224c, 0x3c93151d, 0x14a84652, 0x14cbf127, 0x3c86df8e,
+	0x3c82c909, 0x14d7d32a, 0x14fb745e, 0x3c76777b, 0x3c7257a2, 0x15075327, 0x152aeaa3, 0x3c65ea1c,
+	0x3c61c0f1, 0x1536c62b, 0x155a53d9, 0x3c55377b, 0x3c510501, 0x15662c18, 0x1589afe3, 0x3c445fa2,
+	0x3c4023dd, 0x159584d3, 0x15b8fea4, 0x3c33629d, 0x3c2f1d8e, 0x15c4d03e, 0x15e83fff, 0x3c224075,
+	0x3c1df21f, 0x15f40e3a, 0x161773d6, 0x3c10f935, 0x3c0ca19b, 0x16233eac, 0x16469a0d, 0x3bff8ce8,
+	0x3bfb2c0c, 0x16526176, 0x1675b286, 0x3bedfb99, 0x3be9917e, 0x1681767c, 0x16a4bd25, 0x3bdc4552,
+	0x3bd7d1fa, 0x16b07d9f, 0x16d3b9cc, 0x3bca6a1d, 0x3bc5ed8d, 0x16df76c3, 0x1702a85e, 0x3bb86a08,
+	0x3bb3e440, 0x170e61cc, 0x173188be, 0x3ba6451b, 0x3ba1b620, 0x173d3e9b, 0x17605ad0, 0x3b93fb63,
+	0x3b8f6337, 0x176c0d15, 0x178f1e76, 0x3b818ceb, 0x3b7ceb90, 0x179acd1c, 0x17bdd394, 0x3b6ef9be,
+	0x3b6a4f38, 0x17c97e93, 0x17ec7a0d, 0x3b5c41e8, 0x3b578e39, 0x17f8215e, 0x181b11c4, 0x3b496574,
+	0x3b44a8a0, 0x1826b561, 0x18499a9d, 0x3b36646e, 0x3b319e77, 0x18553a7d, 0x1878147a, 0x3b233ee1,
+	0x3b1e6fca, 0x1883b097, 0x18a67f3f, 0x3b0ff4d9, 0x3b0b1ca6, 0x18b21791, 0x18d4dad0, 0x3afc8663,
+	0x3af7a516, 0x18e06f50, 0x1903270f, 0x3ae8f38b, 0x3ae40926, 0x190eb7b7, 0x193163e1, 0x3ad53c5b,
+	0x3ad048e3, 0x193cf0a9, 0x195f9128, 0x3ac160e1, 0x3abc6458, 0x196b1a09, 0x198daec8, 0x3aad6129,
+	0x3aa85b92, 0x199933bb, 0x19bbbca6, 0x3a993d3e, 0x3a942e9d, 0x19c73da3, 0x19e9baa3, 0x3a84f52f,
+	0x3a7fdd86, 0x19f537a4, 0x1a17a8a5, 0x3a708906, 0x3a6b6859, 0x1a2321a2, 0x1a45868e, 0x3a5bf8d1,
+	0x3a56cf23, 0x1a50fb81, 0x1a735442, 0x3a47449c, 0x3a4211f0, 0x1a7ec524, 0x1aa111a6, 0x3a326c74,
+	0x3a2d30cd, 0x1aac7e6f, 0x1acebe9d, 0x3a1d7066, 0x3a182bc8, 0x1ada2746, 0x1afc5b0a, 0x3a08507f,
+	0x3a0302ed, 0x1b07bf8c, 0x1b29e6d2, 0x39f30ccc, 0x39edb649, 0x1b354727, 0x1b5761d8, 0x39dda55a,
+	0x39d845e9, 0x1b62bdf8, 0x1b84cc01, 0x39c81a36, 0x39c2b1da, 0x1b9023e5, 0x1bb22530, 0x39b26b6d,
+	0x39acfa2b, 0x1bbd78d2, 0x1bdf6d4a, 0x399c990d, 0x39971ee7, 0x1beabca1, 0x1c0ca432, 0x3986a324,
+	0x3981201e, 0x1c17ef39, 0x1c39c9cd, 0x397089bf, 0x396afddc, 0x1c45107c, 0x1c66ddfe, 0x395a4ceb,
+	0x3954b82e, 0x1c72204f, 0x1c93e0ab, 0x3943ecb6, 0x393e4f23, 0x1c9f1e96, 0x1cc0d1b6, 0x392d692f,
+	0x3927c2c9, 0x1ccc0b35, 0x1cedb106, 0x3916c262, 0x3911132d, 0x1cf8e611, 0x1d1a7e7d, 0x38fff85e,
+	0x38fa405e, 0x1d25af0d, 0x1d473a00, 0x38e90b31, 0x38e34a69, 0x1d52660f, 0x1d73e374, 0x38d1fae9,
+	0x38cc315d, 0x1d7f0afb, 0x1da07abc, 0x38bac795, 0x38b4f547, 0x1dab9db5, 0x1dccffbf, 0x38a37142,
+	0x389d9637, 0x1dd81e21, 0x1df9725f, 0x388bf7ff, 0x3886143b, 0x1e048c24, 0x1e25d282, 0x38745bdb,
+	0x386e6f60, 0x1e30e7a4, 0x1e52200c, 0x385c9ce3, 0x3856a7b6, 0x1e5d3084, 0x1e7e5ae2, 0x3844bb28,
+	0x383ebd4c, 0x1e8966a8, 0x1eaa82e9, 0x382cb6b7, 0x3826b030, 0x1eb589f7, 0x1ed69805, 0x38148f9f,
+	0x380e8071, 0x1ee19a54, 0x1f029a1c, 0x37fc45ef, 0x37f62e1d, 0x1f0d97a5, 0x1f2e8911, 0x37e3d9b7,
+	0x37ddb945, 0x1f3981ce, 0x1f5a64cb, 0x37cb4b04, 0x37c521f6, 0x1f6558b5, 0x1f862d2d, 0x37b299e7,
+	0x37ac6841, 0x1f911c3d, 0x1fb1e21d, 0x3799c66f, 0x37938c34, 0x1fbccc4d, 0x1fdd8381, 0x3780d0aa,
+	0x377a8ddf, 0x1fe868c8, 0x2009113c, 0x3767b8a9, 0x37616d51, 0x2013f196, 0x20348b35, 0x374e7e7b,
+	0x37482a9a, 0x203f6699, 0x205ff14f, 0x3735222f, 0x372ec5c9, 0x206ac7b8, 0x208b4372, 0x371ba3d4,
+	0x37153eee, 0x209614d9, 0x20b68181, 0x3702037c, 0x36fb9618, 0x20c14ddf, 0x20e1ab63, 0x36e84135,
+	0x36e1cb58, 0x20ec72b1, 0x210cc0fc, 0x36ce5d10, 0x36c7debd, 0x21178334, 0x2137c232, 0x36b4571b,
+	0x36add058, 0x21427f4d, 0x2162aeea, 0x369a2f69, 0x3693a038, 0x216d66e2, 0x218d870b, 0x367fe608,
+	0x36794e6e, 0x219839d8, 0x21b84a79, 0x36657b08, 0x365edb09, 0x21c2f815, 0x21e2f91a, 0x364aee7b,
+	0x3644461b, 0x21eda17f, 0x220d92d4, 0x36304070, 0x36298fb4, 0x221835fb, 0x2238178d, 0x361570f8,
+	0x360eb7e3, 0x2242b56f, 0x22628729, 0x35fa8023, 0x35f3beba, 0x226d1fc1, 0x228ce191, 0x35df6e03,
+	0x35d8a449, 0x229774d7, 0x22b726a8, 0x35c43aa7, 0x35bd68a1, 0x22c1b496, 0x22e15655, 0x35a8e621,
+	0x35a20bd3, 0x22ebdee5, 0x230b707e, 0x358d7081, 0x35868def, 0x2315f3a8, 0x23357509, 0x3571d9d9,
+	0x356aef08, 0x233ff2c8, 0x235f63dc, 0x35562239, 0x354f2f2c, 0x2369dc29, 0x23893cdd, 0x353a49b2,
+	0x35334e6f, 0x2393afb2, 0x23b2fff3, 0x351e5056, 0x35174ce0, 0x23bd6d48, 0x23dcad03, 0x35023636,
+	0x34fb2a92, 0x23e714d3, 0x240643f4, 0x34e5fb63, 0x34dee795, 0x2410a639, 0x242fc4ad, 0x34c99fef,
+	0x34c283fb, 0x243a215f, 0x24592f13, 0x34ad23eb, 0x34a5ffd5, 0x2463862c, 0x2482830d, 0x34908768,
+	0x34895b36, 0x248cd487, 0x24abc082, 0x3473ca79, 0x346c962f, 0x24b60c57, 0x24d4e757, 0x3456ed2f,
+	0x344fb0d1, 0x24df2d81, 0x24fdf775, 0x3439ef9c, 0x3432ab2e, 0x250837ed, 0x2526f0c1, 0x341cd1d2,
+	0x34158559, 0x25312b81, 0x254fd323, 0x33ff93e2, 0x33f83f62, 0x255a0823, 0x25789e80, 0x33e235df,
+	0x33dad95e, 0x2582cdbc, 0x25a152c0, 0x33c4b7db, 0x33bd535c, 0x25ab7c30, 0x25c9efca, 0x33a719e8,
+	0x339fad70, 0x25d41369, 0x25f27584, 0x33895c18, 0x3381e7ac, 0x25fc934b, 0x261ae3d6, 0x336b7e7e,
+	0x33640223, 0x2624fbbf, 0x26433aa7, 0x334d812d, 0x3345fce6, 0x264d4cac, 0x266b79dd, 0x332f6435,
+	0x3327d808, 0x267585f8, 0x2693a161, 0x331127ab, 0x3309939c, 0x269da78b, 0x26bbb119, 0x32f2cba1,
+	0x32eb2fb5, 0x26c5b14c, 0x26e3a8ec, 0x32d45029, 0x32ccac64, 0x26eda322, 0x270b88c2, 0x32b5b557,
+	0x32ae09be, 0x27157cf5, 0x27335082, 0x3296fb3d, 0x328f47d5, 0x273d3eac, 0x275b0014, 0x327821ee,
+	0x327066bc, 0x2764e82f, 0x27829760, 0x3259297d, 0x32516686, 0x278c7965, 0x27aa164c, 0x323a11fe,
+	0x32324746, 0x27b3f235, 0x27d17cc1, 0x321adb83, 0x3213090f, 0x27db5288, 0x27f8caa5, 0x31fb8620,
+	0x31f3abf5, 0x28029a45, 0x281fffe2, 0x31dc11e8, 0x31d4300b, 0x2829c954, 0x28471c5e, 0x31bc7eee,
+	0x31b49564, 0x2850df9d, 0x286e2002, 0x319ccd46, 0x3194dc14, 0x2877dd07, 0x28950ab6, 0x317cfd04,
+	0x3175042e, 0x289ec17a, 0x28bbdc61, 0x315d0e3b, 0x31550dc6, 0x28c58cdf, 0x28e294eb, 0x313d00ff,
+	0x3134f8f1, 0x28ec3f1e, 0x2909343e, 0x311cd564, 0x3114c5c0, 0x2912d81f, 0x292fba40, 0x30fc8b7d,
+	0x30f47449, 0x293957c9, 0x295626da, 0x30dc235e, 0x30d404a0, 0x295fbe06, 0x297c79f5, 0x30bb9d1c,
+	0x30b376d8, 0x29860abd, 0x29a2b378, 0x309af8ca, 0x3092cb05, 0x29ac3dd7, 0x29c8d34d, 0x307a367c,
+	0x3072013c, 0x29d2573c, 0x29eed95b, 0x30595648, 0x30511991, 0x29f856d5, 0x2a14c58b, 0x30385840,
+	0x30301418, 0x2a1e3c8a, 0x2a3a97c7, 0x30173c7a, 0x300ef0e5, 0x2a440844, 0x2a604ff5, 0x2ff6030a,
+	0x2fedb00d, 0x2a69b9ec, 0x2a85ee00, 0x2fd4ac04, 0x2fcc51a5, 0x2a8f516b, 0x2aab71d0, 0x2fb3377c,
+	0x2faad5c1, 0x2ab4cea9, 0x2ad0db4e, 0x2f91a589, 0x2f893c75, 0x2ada318e, 0x2af62a63, 0x2f6ff63d,
+	0x2f6785d7, 0x2aff7a05, 0x2b1b5ef8, 0x2f4e29af, 0x2f45b1fb, 0x2b24a7f6, 0x2b4078f5, 0x2f2c3ff2,
+	0x2f23c0f6, 0x2b49bb4a, 0x2b657844, 0x2f0a391d, 0x2f01b2de, 0x2b6eb3ea, 0x2b8a5cce, 0x2ee81543,
+	0x2edf87c6, 0x2b9391c0, 0x2baf267d, 0x2ec5d479, 0x2ebd3fc4, 0x2bb854b4, 0x2bd3d53a, 0x2ea376d6,
+	0x2e9adaee, 0x2bdcfcb0, 0x2bf868ed, 0x2e80fc6e, 0x2e785958, 0x2c01899e, 0x2c1ce181, 0x2e5e6556,
+	0x2e55bb17, 0x2c25fb66, 0x2c413edf, 0x2e3bb1a4, 0x2e330042, 0x2c4a51f3, 0x2c6580f1, 0x2e18e16d,
+	0x2e1028ed, 0x2c6e8d2e, 0x2c89a79f, 0x2df5f4c7, 0x2ded352f, 0x2c92ad01, 0x2cadb2d5, 0x2dd2ebc7,
+	0x2dca251c, 0x2cb6b155, 0x2cd1a27b, 0x2dafc683, 0x2da6f8ca, 0x2cda9a14, 0x2cf5767c, 0x2d8c8510,
+	0x2d83b04f, 0x2cfe6728, 0x2d192ec1, 0x2d692784, 0x2d604bc0, 0x2d22187a, 0x2d3ccb34, 0x2d45adf6
+};
+
+
+const int twidTab512[(8*6 + 32*6 + 128*6)/2] = {
+	0x40000000, 0x40000000, 0x40000000, 0x3b20187d,
+	0x3ec50c7c, 0x3536238e, 0x2d412d41, 0x3b20187d,
+	0x187d3b20, 0x187d3b20, 0x3536238e, 0xf3843ec5,
+	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xe7833b20,
+	0x238e3536, 0xc13b0c7c, 0xd2bf2d41, 0x187d3b20,
+	0xc4e0e783, 0xc4e0187d, 0x0c7c3ec5, 0xdc72caca,
+
+	0x40000000, 0x40000000, 0x40000000, 0x3fb10645,
+	0x3fec0323, 0x3f4e0964, 0x3ec50c7c, 0x3fb10645,
+	0x3d3e1294, 0x3d3e1294, 0x3f4e0964, 0x39da1b5d,
+	0x3b20187d, 0x3ec50c7c, 0x3536238e, 0x38711e2b,
+	0x3e140f8c, 0x2f6b2afa, 0x3536238e, 0x3d3e1294,
+	0x28993179, 0x31792899, 0x3c42158f, 0x20e736e5,
+	0x2d412d41, 0x3b20187d, 0x187d3b20, 0x28993179,
+	0x39da1b5d, 0x0f8c3e14, 0x238e3536, 0x38711e2b,
+	0x06453fb1, 0x1e2b3871, 0x36e520e7, 0xfcdd3fec,
+	0x187d3b20, 0x3536238e, 0xf3843ec5, 0x12943d3e,
+	0x3367261f, 0xea713c42, 0x0c7c3ec5, 0x31792899,
+	0xe1d53871, 0x06453fb1, 0x2f6b2afa, 0xd9e13367,
+	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xf9bb3fb1,
+	0x2afa2f6b, 0xcc99261f, 0xf3843ec5, 0x28993179,
+	0xc78f1e2b, 0xed6c3d3e, 0x261f3367, 0xc3be158f,
+	0xe7833b20, 0x238e3536, 0xc13b0c7c, 0xe1d53871,
+	0x20e736e5, 0xc0140323, 0xdc723536, 0x1e2b3871,
+	0xc04ff9bb, 0xd7673179, 0x1b5d39da, 0xc1ecf074,
+	0xd2bf2d41, 0x187d3b20, 0xc4e0e783, 0xce872899,
+	0x158f3c42, 0xc91bdf19, 0xcaca238e, 0x12943d3e,
+	0xce87d767, 0xc78f1e2b, 0x0f8c3e14, 0xd506d095,
+	0xc4e0187d, 0x0c7c3ec5, 0xdc72caca, 0xc2c21294,
+	0x09643f4e, 0xe4a3c626, 0xc13b0c7c, 0x06453fb1,
+	0xed6cc2c2, 0xc04f0645, 0x03233fec, 0xf69cc0b2,
+
+	0x40000000, 0x40000000, 0x40000000, 0x3ffb0192,
+	0x3ffe00c9, 0x3ff4025b, 0x3fec0323, 0x3ffb0192,
+	0x3fd304b5, 0x3fd304b5, 0x3ff4025b, 0x3f9c070d,
+	0x3fb10645, 0x3fec0323, 0x3f4e0964, 0x3f8407d5,
+	0x3fe103ec, 0x3eeb0bb6, 0x3f4e0964, 0x3fd304b5,
+	0x3e710e05, 0x3f0e0af1, 0x3fc3057d, 0x3de2104f,
+	0x3ec50c7c, 0x3fb10645, 0x3d3e1294, 0x3e710e05,
+	0x3f9c070d, 0x3c8414d1, 0x3e140f8c, 0x3f8407d5,
+	0x3bb61708, 0x3dae1111, 0x3f6a089c, 0x3ad21937,
+	0x3d3e1294, 0x3f4e0964, 0x39da1b5d, 0x3cc51413,
+	0x3f2f0a2a, 0x38cf1d79, 0x3c42158f, 0x3f0e0af1,
+	0x37af1f8b, 0x3bb61708, 0x3eeb0bb6, 0x367c2192,
+	0x3b20187d, 0x3ec50c7c, 0x3536238e, 0x3a8219ef,
+	0x3e9c0d41, 0x33de257d, 0x39da1b5d, 0x3e710e05,
+	0x3274275f, 0x392a1cc6, 0x3e440ec9, 0x30f82934,
+	0x38711e2b, 0x3e140f8c, 0x2f6b2afa, 0x37af1f8b,
+	0x3de2104f, 0x2dce2cb2, 0x36e520e7, 0x3dae1111,
+	0x2c212e5a, 0x3612223d, 0x3d7711d3, 0x2a652ff1,
+	0x3536238e, 0x3d3e1294, 0x28993179, 0x345324da,
+	0x3d021354, 0x26c032ee, 0x3367261f, 0x3cc51413,
+	0x24da3453, 0x3274275f, 0x3c8414d1, 0x22e635a5,
+	0x31792899, 0x3c42158f, 0x20e736e5, 0x307629cd,
+	0x3bfd164c, 0x1edc3811, 0x2f6b2afa, 0x3bb61708,
+	0x1cc6392a, 0x2e5a2c21, 0x3b6c17c3, 0x1aa63a2f,
+	0x2d412d41, 0x3b20187d, 0x187d3b20, 0x2c212e5a,
+	0x3ad21937, 0x164c3bfd, 0x2afa2f6b, 0x3a8219ef,
+	0x14133cc5, 0x29cd3076, 0x3a2f1aa6, 0x11d33d77,
+	0x28993179, 0x39da1b5d, 0x0f8c3e14, 0x275f3274,
+	0x39831c12, 0x0d413e9c, 0x261f3367, 0x392a1cc6,
+	0x0af13f0e, 0x24da3453, 0x38cf1d79, 0x089c3f6a,
+	0x238e3536, 0x38711e2b, 0x06453fb1, 0x223d3612,
+	0x38111edc, 0x03ec3fe1, 0x20e736e5, 0x37af1f8b,
+	0x01923ffb, 0x1f8b37af, 0x374b2039, 0xff373ffe,
+	0x1e2b3871, 0x36e520e7, 0xfcdd3fec, 0x1cc6392a,
+	0x367c2192, 0xfa833fc3, 0x1b5d39da, 0x3612223d,
+	0xf82b3f84, 0x19ef3a82, 0x35a522e6, 0xf5d63f2f,
+	0x187d3b20, 0x3536238e, 0xf3843ec5, 0x17083bb6,
+	0x34c62434, 0xf1373e44, 0x158f3c42, 0x345324da,
+	0xeeef3dae, 0x14133cc5, 0x33de257d, 0xecac3d02,
+	0x12943d3e, 0x3367261f, 0xea713c42, 0x11113dae,
+	0x32ee26c0, 0xe83d3b6c, 0x0f8c3e14, 0x3274275f,
+	0xe6113a82, 0x0e053e71, 0x31f727fd, 0xe3ee3983,
+	0x0c7c3ec5, 0x31792899, 0xe1d53871, 0x0af13f0e,
+	0x30f82934, 0xdfc7374b, 0x09643f4e, 0x307629cd,
+	0xddc33612, 0x07d53f84, 0x2ff12a65, 0xdbcc34c6,
+	0x06453fb1, 0x2f6b2afa, 0xd9e13367, 0x04b53fd3,
+	0x2ee32b8e, 0xd80331f7, 0x03233fec, 0x2e5a2c21,
+	0xd6333076, 0x01923ffb, 0x2dce2cb2, 0xd4722ee3,
+	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xfe6e3ffb,
+	0x2cb22dce, 0xd11d2b8e, 0xfcdd3fec, 0x2c212e5a,
+	0xcf8a29cd, 0xfb4b3fd3, 0x2b8e2ee3, 0xce0927fd,
+	0xf9bb3fb1, 0x2afa2f6b, 0xcc99261f, 0xf82b3f84,
+	0x2a652ff1, 0xcb3a2434, 0xf69c3f4e, 0x29cd3076,
+	0xc9ee223d, 0xf50f3f0e, 0x293430f8, 0xc8b52039,
+	0xf3843ec5, 0x28993179, 0xc78f1e2b, 0xf1fb3e71,
+	0x27fd31f7, 0xc67d1c12, 0xf0743e14, 0x275f3274,
+	0xc57e19ef, 0xeeef3dae, 0x26c032ee, 0xc49417c3,
+	0xed6c3d3e, 0x261f3367, 0xc3be158f, 0xebed3cc5,
+	0x257d33de, 0xc2fe1354, 0xea713c42, 0x24da3453,
+	0xc2521111, 0xe8f83bb6, 0x243434c6, 0xc1bc0ec9,
+	0xe7833b20, 0x238e3536, 0xc13b0c7c, 0xe6113a82,
+	0x22e635a5, 0xc0d10a2a, 0xe4a339da, 0x223d3612,
+	0xc07c07d5, 0xe33a392a, 0x2192367c, 0xc03d057d,
+	0xe1d53871, 0x20e736e5, 0xc0140323, 0xe07537af,
+	0x2039374b, 0xc00200c9, 0xdf1936e5, 0x1f8b37af,
+	0xc005fe6e, 0xddc33612, 0x1edc3811, 0xc01ffc14,
+	0xdc723536, 0x1e2b3871, 0xc04ff9bb, 0xdb263453,
+	0x1d7938cf, 0xc096f764, 0xd9e13367, 0x1cc6392a,
+	0xc0f2f50f, 0xd8a13274, 0x1c123983, 0xc164f2bf,
+	0xd7673179, 0x1b5d39da, 0xc1ecf074, 0xd6333076,
+	0x1aa63a2f, 0xc289ee2d, 0xd5062f6b, 0x19ef3a82,
+	0xc33bebed, 0xd3df2e5a, 0x19373ad2, 0xc403e9b4,
+	0xd2bf2d41, 0x187d3b20, 0xc4e0e783, 0xd1a62c21,
+	0x17c33b6c, 0xc5d1e55a, 0xd0952afa, 0x17083bb6,
+	0xc6d6e33a, 0xcf8a29cd, 0x164c3bfd, 0xc7efe124,
+	0xce872899, 0x158f3c42, 0xc91bdf19, 0xcd8c275f,
+	0x14d13c84, 0xca5bdd1a, 0xcc99261f, 0x14133cc5,
+	0xcbaddb26, 0xcbad24da, 0x13543d02, 0xcd12d940,
+	0xcaca238e, 0x12943d3e, 0xce87d767, 0xc9ee223d,
+	0x11d33d77, 0xd00fd59b, 0xc91b20e7, 0x11113dae,
+	0xd1a6d3df, 0xc8511f8b, 0x104f3de2, 0xd34ed232,
+	0xc78f1e2b, 0x0f8c3e14, 0xd506d095, 0xc6d61cc6,
+	0x0ec93e44, 0xd6cccf08, 0xc6261b5d, 0x0e053e71,
+	0xd8a1cd8c, 0xc57e19ef, 0x0d413e9c, 0xda83cc22,
+	0xc4e0187d, 0x0c7c3ec5, 0xdc72caca, 0xc44a1708,
+	0x0bb63eeb, 0xde6ec984, 0xc3be158f, 0x0af13f0e,
+	0xe075c851, 0xc33b1413, 0x0a2a3f2f, 0xe287c731,
+	0xc2c21294, 0x09643f4e, 0xe4a3c626, 0xc2521111,
+	0x089c3f6a, 0xe6c9c52e, 0xc1ec0f8c, 0x07d53f84,
+	0xe8f8c44a, 0xc18f0e05, 0x070d3f9c, 0xeb2fc37c,
+	0xc13b0c7c, 0x06453fb1, 0xed6cc2c2, 0xc0f20af1,
+	0x057d3fc3, 0xefb1c21e, 0xc0b20964, 0x04b53fd3,
+	0xf1fbc18f, 0xc07c07d5, 0x03ec3fe1, 0xf44ac115,
+	0xc04f0645, 0x03233fec, 0xf69cc0b2, 0xc02d04b5,
+	0x025b3ff4, 0xf8f3c064, 0xc0140323, 0x01923ffb,
+	0xfb4bc02d, 0xc0050192, 0x00c93ffe, 0xfda5c00c
+};
+
+const int twidTab64[(4*6 + 16*6)/2] = {
+	0x40000000, 0x40000000, 0x40000000, 0x2d412d41,
+	0x3b20187d, 0x187d3b20, 0x00004000, 0x2d412d41,
+	0xd2bf2d41, 0xd2bf2d41, 0x187d3b20, 0xc4e0e783,
+
+	0x40000000, 0x40000000, 0x40000000, 0x3ec50c7c,
+	0x3fb10645, 0x3d3e1294, 0x3b20187d, 0x3ec50c7c,
+	0x3536238e, 0x3536238e, 0x3d3e1294, 0x28993179,
+	0x2d412d41, 0x3b20187d, 0x187d3b20, 0x238e3536,
+	0x38711e2b, 0x06453fb1, 0x187d3b20, 0x3536238e,
+	0xf3843ec5, 0x0c7c3ec5, 0x31792899, 0xe1d53871,
+	0x00004000, 0x2d412d41, 0xd2bf2d41, 0xf3843ec5,
+	0x28993179, 0xc78f1e2b, 0xe7833b20, 0x238e3536,
+	0xc13b0c7c, 0xdc723536, 0x1e2b3871, 0xc04ff9bb,
+	0xd2bf2d41, 0x187d3b20, 0xc4e0e783, 0xcaca238e,
+	0x12943d3e, 0xce87d767, 0xc4e0187d, 0x0c7c3ec5,
+	0xdc72caca, 0xc13b0c7c, 0x06453fb1, 0xed6cc2c2
+};
+
+#elif defined ARMV7Neon
+/*
+ *  Q29 for 128 and 1024
+ *
+ * for (i = 0; i < num/4; i++) {
+ *   angle = (i + 0.125) * M_PI / num;
+ *   x = cos(angle) * (1 << 29);
+ *   x = sin(angle) * (1 << 29);
+ *
+ *   angle = (num/2 - 1 - i + 0.125) * M_PI / num;
+ *   x = cos(angle) * (1 << 29);
+ *   x = sin(angle) * (1 << 29);
+ * }
+ */
+const int cossintab[128 + 1024] = {
+	/* 128 */
+	0x1ffff621, 0x001921f9, 0x00afea69, 0x1ffe1c68, 0x1ffce09d, 0x00e22a7a, 0x0178dbaa, 0x1ff753bb,
+	0x1ff4dc55, 0x01ab101c, 0x024192cf, 0x1feb9d25, 0x1fe7ea85, 0x0273b3e2, 0x0309f0e2, 0x1fdafa75,
+	0x1fd60d2e, 0x033bf6dd, 0x03d1d700, 0x1fc56e3b, 0x1fbf470f, 0x0403ba2b, 0x04992653, 0x1faafbcb,
+	0x1fa39bac, 0x04cadefe, 0x055fc022, 0x1f8ba738, 0x1f830f4a, 0x059146a1, 0x062585ca, 0x1f677557,
+	0x1f5da6ed, 0x0656d27a, 0x06ea58cd, 0x1f3e6bbc, 0x1f33685a, 0x071b6415, 0x07ae1ad2, 0x1f1090bd,
+	0x1f045a15, 0x07dedd20, 0x0870ada7, 0x1eddeb6a, 0x1ed0835f, 0x08a11f78, 0x0931f34d, 0x1ea68394,
+	0x1e97ec36, 0x09620d27, 0x09f1cdf5, 0x1e6a61c5, 0x1e5a9d55, 0x0a21886e, 0x0ab02009, 0x1e298f44,
+	0x1e18a030, 0x0adf73c6, 0x0b6ccc32, 0x1de4160f, 0x1dd1fef4, 0x0b9bb1e5, 0x0c27b555, 0x1d9a00de,
+	0x1d86c484, 0x0c5625c3, 0x0ce0bea2, 0x1d4b5b1b, 0x1d36fc7c, 0x0d0eb2a2, 0x0d97cb8f, 0x1cf830e9,
+	0x1ce2b328, 0x0dc53c0a, 0x0e4cbfe2, 0x1ca08f1a, 0x1c89f587, 0x0e79a5d7, 0x0eff7fb3, 0x1c448331,
+	0x1c2cd149, 0x0f2bd437, 0x0fafef73, 0x1be41b61, 0x1bcb54cb, 0x0fdbabae, 0x105df3ec, 0x1b7f6687,
+	0x1b658f15, 0x10891120, 0x11097249, 0x1b16742a, 0x1afb8fd9, 0x1133e9d0, 0x11b25017, 0x1aa9547a,
+	0x1a8d676e, 0x11dc1b65, 0x1258734d, 0x1a38184a, 0x1a1b26d3, 0x12818bef, 0x12fbc24b, 0x19c2d111,
+	0x19a4dfa4, 0x132421ec, 0x139c23e4, 0x194990e4, 0x192aa420, 0x13c3c44a, 0x14397f5b, 0x18cc6a75,
+	0x18ac871f, 0x14605a69, 0x14d3bc6d, 0x184b7112, 0x182a9c14, 0x14f9cc26, 0x156ac352, 0x17c6b89d,
+	0x17a4f708, 0x159001d6, 0x15fe7cbe, 0x173e558e, 0x171bac96, 0x1622e450, 0x168ed1eb, 0x16b25ced,
+	/* 1024 */
+	0x1fffffd9, 0x0003243f, 0x0015fdba, 0x1ffff872, 0x1ffff382, 0x001c4637, 0x002f1fa6, 0x1fffdd4d,
+	0x1fffd36f, 0x0035681d, 0x00484175, 0x1fffae6c, 0x1fff9f9e, 0x004e89e3, 0x00616318, 0x1fff6bce,
+	0x1fff5811, 0x0067ab77, 0x007a847e, 0x1fff1572, 0x1ffefcc6, 0x0080cccc, 0x0093a599, 0x1ffeab5b,
+	0x1ffe8dbf, 0x0099edd2, 0x00acc658, 0x1ffe2d86, 0x1ffe0afc, 0x00b30e78, 0x00c5e6ad, 0x1ffd9bf6,
+	0x1ffd747c, 0x00cc2eb0, 0x00df0688, 0x1ffcf6aa, 0x1ffcca41, 0x00e54e6a, 0x00f825da, 0x1ffc3da2,
+	0x1ffc0c4b, 0x00fe6d97, 0x01114492, 0x1ffb70e0, 0x1ffb3a9a, 0x01178c27, 0x012a62a2, 0x1ffa9063,
+	0x1ffa552e, 0x0130aa0a, 0x01437ffa, 0x1ff99c2c, 0x1ff95c09, 0x0149c731, 0x015c9c8a, 0x1ff8943c,
+	0x1ff84f2b, 0x0162e38d, 0x0175b843, 0x1ff77893, 0x1ff72e94, 0x017bff0e, 0x018ed316, 0x1ff64932,
+	0x1ff5fa46, 0x019519a5, 0x01a7ecf2, 0x1ff5061b, 0x1ff4b240, 0x01ae3341, 0x01c105c9, 0x1ff3af4c,
+	0x1ff35684, 0x01c74bd5, 0x01da1d8c, 0x1ff244c8, 0x1ff1e713, 0x01e0634f, 0x01f33429, 0x1ff0c68f,
+	0x1ff063ed, 0x01f979a1, 0x020c4993, 0x1fef34a3, 0x1feecd14, 0x02128ebb, 0x02255db9, 0x1fed8f03,
+	0x1fed2287, 0x022ba28f, 0x023e708d, 0x1febd5b2, 0x1feb644a, 0x0244b50b, 0x025781fe, 0x1fea08b0,
+	0x1fe9925c, 0x025dc621, 0x027091fd, 0x1fe827fe, 0x1fe7acbe, 0x0276d5c1, 0x0289a07b, 0x1fe6339d,
+	0x1fe5b372, 0x028fe3dd, 0x02a2ad69, 0x1fe42b90, 0x1fe3a679, 0x02a8f063, 0x02bbb8b6, 0x1fe20fd6,
+	0x1fe185d5, 0x02c1fb46, 0x02d4c253, 0x1fdfe071, 0x1fdf5186, 0x02db0475, 0x02edca32, 0x1fdd9d64,
+	0x1fdd098e, 0x02f40be2, 0x0306d042, 0x1fdb46ae, 0x1fdaadee, 0x030d117c, 0x031fd474, 0x1fd8dc51,
+	0x1fd83ea8, 0x03261534, 0x0338d6b8, 0x1fd65e4f, 0x1fd5bbbd, 0x033f16fb, 0x0351d700, 0x1fd3ccaa,
+	0x1fd32530, 0x035816c1, 0x036ad53c, 0x1fd12763, 0x1fd07b00, 0x03711477, 0x0383d15c, 0x1fce6e7c,
+	0x1fcdbd31, 0x038a100e, 0x039ccb51, 0x1fcba1f5, 0x1fcaebc3, 0x03a30975, 0x03b5c30b, 0x1fc8c1d2,
+	0x1fc806b9, 0x03bc009f, 0x03ceb87c, 0x1fc5ce14, 0x1fc50e14, 0x03d4f57a, 0x03e7ab93, 0x1fc2c6bd,
+	0x1fc201d7, 0x03ede7f9, 0x04009c42, 0x1fbfabcd, 0x1fbee202, 0x0406d80b, 0x04198a78, 0x1fbc7d49,
+	0x1fbbae99, 0x041fc5a1, 0x04327628, 0x1fb93b31, 0x1fb8679c, 0x0438b0ac, 0x044b5f40, 0x1fb5e587,
+	0x1fb50d0e, 0x0451991d, 0x046445b2, 0x1fb27c4e, 0x1fb19ef1, 0x046a7ee3, 0x047d296f, 0x1faeff87,
+	0x1fae1d47, 0x048361f0, 0x04960a67, 0x1fab6f35, 0x1faa8813, 0x049c4235, 0x04aee88b, 0x1fa7cb5a,
+	0x1fa6df56, 0x04b51fa1, 0x04c7c3cb, 0x1fa413f8, 0x1fa32313, 0x04cdfa26, 0x04e09c18, 0x1fa04912,
+	0x1f9f534c, 0x04e6d1b4, 0x04f97163, 0x1f9c6aa9, 0x1f9b7003, 0x04ffa63c, 0x0512439d, 0x1f9878c1,
+	0x1f97793b, 0x051877af, 0x052b12b6, 0x1f94735b, 0x1f936ef6, 0x053145fd, 0x0543de9e, 0x1f905a7a,
+	0x1f8f5137, 0x054a1117, 0x055ca748, 0x1f8c2e21, 0x1f8b2000, 0x0562d8ee, 0x05756ca2, 0x1f87ee52,
+	0x1f86db55, 0x057b9d73, 0x058e2e9f, 0x1f839b10, 0x1f828336, 0x05945e95, 0x05a6ed2e, 0x1f7f345e,
+	0x1f7e17a8, 0x05ad1c47, 0x05bfa840, 0x1f7aba3e, 0x1f7998ad, 0x05c5d678, 0x05d85fc7, 0x1f762cb2,
+	0x1f750647, 0x05de8d19, 0x05f113b3, 0x1f718bbf, 0x1f70607a, 0x05f7401c, 0x0609c3f5, 0x1f6cd766,
+	0x1f6ba748, 0x060fef71, 0x0622707d, 0x1f680fab, 0x1f66dab5, 0x06289b08, 0x063b193c, 0x1f633490,
+	0x1f61fac3, 0x064142d3, 0x0653be23, 0x1f5e4619, 0x1f5d0775, 0x0659e6c2, 0x066c5f24, 0x1f594448,
+	0x1f5800ce, 0x067286c6, 0x0684fc2e, 0x1f542f21, 0x1f52e6d2, 0x068b22d0, 0x069d9532, 0x1f4f06a6,
+	0x1f4db983, 0x06a3bad0, 0x06b62a22, 0x1f49cadc, 0x1f4878e5, 0x06bc4eb9, 0x06cebaee, 0x1f447bc4,
+	0x1f4324fb, 0x06d4de79, 0x06e74786, 0x1f3f1963, 0x1f3dbdc8, 0x06ed6a03, 0x06ffcfdd, 0x1f39a3bc,
+	0x1f384350, 0x0705f147, 0x071853e3, 0x1f341ad2, 0x1f32b595, 0x071e7436, 0x0730d388, 0x1f2e7ea9,
+	0x1f2d149d, 0x0736f2c0, 0x07494ebd, 0x1f28cf43, 0x1f276069, 0x074f6cd7, 0x0761c574, 0x1f230ca5,
+	0x1f2198fd, 0x0767e26c, 0x077a379d, 0x1f1d36d2, 0x1f1bbe5d, 0x07805370, 0x0792a52a, 0x1f174dce,
+	0x1f15d08d, 0x0798bfd3, 0x07ab0e0a, 0x1f11519c, 0x1f0fcf91, 0x07b12786, 0x07c37230, 0x1f0b4240,
+	0x1f09bb6b, 0x07c98a7a, 0x07dbd18c, 0x1f051fbe, 0x1f03941f, 0x07e1e8a1, 0x07f42c0e, 0x1efeea19,
+	0x1efd59b3, 0x07fa41eb, 0x080c81a9, 0x1ef8a155, 0x1ef70c28, 0x0812964a, 0x0824d24d, 0x1ef24577,
+	0x1ef0ab84, 0x082ae5ad, 0x083d1dea, 0x1eebd682, 0x1eea37ca, 0x08433007, 0x08556473, 0x1ee5547a,
+	0x1ee3b0fe, 0x085b7548, 0x086da5d8, 0x1edebf64, 0x1edd1724, 0x0873b562, 0x0885e209, 0x1ed81742,
+	0x1ed66a41, 0x088bf044, 0x089e18f9, 0x1ed15c1a, 0x1ecfaa57, 0x08a425e1, 0x08b64a98, 0x1eca8def,
+	0x1ec8d76c, 0x08bc562a, 0x08ce76d8, 0x1ec3acc6, 0x1ec1f184, 0x08d4810f, 0x08e69da8, 0x1ebcb8a3,
+	0x1ebaf8a3, 0x08eca681, 0x08febefb, 0x1eb5b18a, 0x1eb3eccd, 0x0904c673, 0x0916dac2, 0x1eae977f,
+	0x1eacce07, 0x091ce0d4, 0x092ef0ed, 0x1ea76a87, 0x1ea59c55, 0x0934f596, 0x0947016e, 0x1ea02aa7,
+	0x1e9e57bb, 0x094d04aa, 0x095f0c36, 0x1e98d7e2, 0x1e97003e, 0x09650e01, 0x09771136, 0x1e91723e,
+	0x1e8f95e3, 0x097d118d, 0x098f1060, 0x1e89f9bf, 0x1e8818ad, 0x09950f3f, 0x09a709a4, 0x1e826e69,
+	0x1e8088a2, 0x09ad0707, 0x09befcf4, 0x1e7ad041, 0x1e78e5c7, 0x09c4f8d8, 0x09d6ea40, 0x1e731f4c,
+	0x1e71301f, 0x09dce4a1, 0x09eed17b, 0x1e6b5b8f, 0x1e6967b1, 0x09f4ca56, 0x0a06b296, 0x1e63850e,
+	0x1e618c80, 0x0a0ca9e6, 0x0a1e8d81, 0x1e5b9bce, 0x1e599e91, 0x0a248343, 0x0a36622e, 0x1e539fd4,
+	0x1e519dea, 0x0a3c565e, 0x0a4e308f, 0x1e4b9126, 0x1e498a8e, 0x0a542329, 0x0a65f894, 0x1e436fc7,
+	0x1e416485, 0x0a6be995, 0x0a7dba2f, 0x1e3b3bbd, 0x1e392bd1, 0x0a83a993, 0x0a957551, 0x1e32f50e,
+	0x1e30e079, 0x0a9b6315, 0x0aad29ec, 0x1e2a9bbd, 0x1e288281, 0x0ab3160c, 0x0ac4d7f1, 0x1e222fd1,
+	0x1e2011ee, 0x0acac26a, 0x0adc7f52, 0x1e19b14f, 0x1e178ec7, 0x0ae2681f, 0x0af41fff, 0x1e11203b,
+	0x1e0ef910, 0x0afa071d, 0x0b0bb9eb, 0x1e087c9b, 0x1e0650ce, 0x0b119f56, 0x0b234d07, 0x1dffc674,
+	0x1dfd9606, 0x0b2930bb, 0x0b3ad943, 0x1df6fdcc, 0x1df4c8bf, 0x0b40bb3e, 0x0b525e92, 0x1dee22a9,
+	0x1debe8fd, 0x0b583ecf, 0x0b69dce6, 0x1de5350f, 0x1de2f6c6, 0x0b6fbb62, 0x0b81542f, 0x1ddc3504,
+	0x1dd9f220, 0x0b8730e6, 0x0b98c45f, 0x1dd3228e, 0x1dd0db10, 0x0b9e9f4d, 0x0bb02d68, 0x1dc9fdb2,
+	0x1dc7b19b, 0x0bb6068a, 0x0bc78f3b, 0x1dc0c676, 0x1dbe75c8, 0x0bcd668e, 0x0bdee9ca, 0x1db77cdf,
+	0x1db5279c, 0x0be4bf4a, 0x0bf63d07, 0x1dae20f4, 0x1dabc71d, 0x0bfc10af, 0x0c0d88e2, 0x1da4b2ba,
+	0x1da25450, 0x0c135ab0, 0x0c24cd4e, 0x1d9b3237, 0x1d98cf3b, 0x0c2a9d3e, 0x0c3c0a3d, 0x1d919f70,
+	0x1d8f37e5, 0x0c41d84b, 0x0c533fa0, 0x1d87fa6d, 0x1d858e53, 0x0c590bc9, 0x0c6a6d68, 0x1d7e4332,
+	0x1d7bd28b, 0x0c7037a8, 0x0c819388, 0x1d7479c5, 0x1d720493, 0x0c875bdb, 0x0c98b1f0, 0x1d6a9e2e,
+	0x1d682472, 0x0c9e7854, 0x0cafc894, 0x1d60b070, 0x1d5e322c, 0x0cb58d04, 0x0cc6d764, 0x1d56b094,
+	0x1d542dc9, 0x0ccc99de, 0x0cddde53, 0x1d4c9e9f, 0x1d4a174f, 0x0ce39ed2, 0x0cf4dd52, 0x1d427a97,
+	0x1d3feec3, 0x0cfa9bd2, 0x0d0bd452, 0x1d384483, 0x1d35b42d, 0x0d1190d1, 0x0d22c347, 0x1d2dfc68,
+	0x1d2b6791, 0x0d287dc1, 0x0d39aa21, 0x1d23a24e, 0x1d2108f8, 0x0d3f6292, 0x0d5088d3, 0x1d19363a,
+	0x1d169867, 0x0d563f38, 0x0d675f4e, 0x1d0eb833, 0x1d0c15e4, 0x0d6d13a3, 0x0d7e2d85, 0x1d04283f,
+	0x1d018176, 0x0d83dfc6, 0x0d94f369, 0x1cf98666, 0x1cf6db24, 0x0d9aa393, 0x0dabb0ec, 0x1ceed2ad,
+	0x1cec22f4, 0x0db15efc, 0x0dc26600, 0x1ce40d1b, 0x1ce158ed, 0x0dc811f3, 0x0dd91298, 0x1cd935b7,
+	0x1cd67d15, 0x0ddebc69, 0x0defb6a5, 0x1cce4c87, 0x1ccb8f74, 0x0df55e51, 0x0e065219, 0x1cc35192,
+	0x1cc0900f, 0x0e0bf79c, 0x0e1ce4e6, 0x1cb844df, 0x1cb57eee, 0x0e22883e, 0x0e336eff, 0x1cad2675,
+	0x1caa5c17, 0x0e391027, 0x0e49f055, 0x1ca1f65b, 0x1c9f2792, 0x0e4f8f4b, 0x0e6068db, 0x1c96b497,
+	0x1c93e165, 0x0e66059a, 0x0e76d883, 0x1c8b6131, 0x1c888997, 0x0e7c7308, 0x0e8d3f3e, 0x1c7ffc2f,
+	0x1c7d202f, 0x0e92d787, 0x0ea39d00, 0x1c748599, 0x1c71a535, 0x0ea93308, 0x0eb9f1ba, 0x1c68fd75,
+	0x1c6618ae, 0x0ebf857d, 0x0ed03d5e, 0x1c5d63ca, 0x1c5a7aa4, 0x0ed5ceda, 0x0ee67fdf, 0x1c51b8a1,
+	0x1c4ecb1c, 0x0eec0f10, 0x0efcb92f, 0x1c45fc00, 0x1c430a1d, 0x0f024612, 0x0f12e941, 0x1c3a2ded,
+	0x1c3737b0, 0x0f1873d2, 0x0f291006, 0x1c2e4e72, 0x1c2b53db, 0x0f2e9842, 0x0f3f2d71, 0x1c225d94,
+	0x1c1f5ea6, 0x0f44b354, 0x0f554175, 0x1c165b5b, 0x1c135818, 0x0f5ac4fc, 0x0f6b4c03, 0x1c0a47cf,
+	0x1c074038, 0x0f70cd2a, 0x0f814d0e, 0x1bfe22f8, 0x1bfb170f, 0x0f86cbd3, 0x0f974489, 0x1bf1ecdb,
+	0x1beedca2, 0x0f9cc0e7, 0x0fad3265, 0x1be5a582, 0x1be290fb, 0x0fb2ac5a, 0x0fc31697, 0x1bd94cf4,
+	0x1bd63421, 0x0fc88e1e, 0x0fd8f10f, 0x1bcce337, 0x1bc9c61a, 0x0fde6626, 0x0feec1c0, 0x1bc06855,
+	0x1bbd46f0, 0x0ff43464, 0x1004889e, 0x1bb3dc55, 0x1bb0b6a9, 0x1009f8cb, 0x101a459a, 0x1ba73f3d,
+	0x1ba4154d, 0x101fb34d, 0x102ff8a8, 0x1b9a9117, 0x1b9762e4, 0x103563dc, 0x1045a1b9, 0x1b8dd1ea,
+	0x1b8a9f77, 0x104b0a6c, 0x105b40c1, 0x1b8101be, 0x1b7dcb0c, 0x1060a6ef, 0x1070d5b1, 0x1b74209b,
+	0x1b70e5ac, 0x10763958, 0x1086607e, 0x1b672e88, 0x1b63ef5f, 0x108bc19a, 0x109be119, 0x1b5a2b8e,
+	0x1b56e82c, 0x10a13fa6, 0x10b15775, 0x1b4d17b4, 0x1b49d01c, 0x10b6b371, 0x10c6c385, 0x1b3ff304,
+	0x1b3ca737, 0x10cc1cec, 0x10dc253c, 0x1b32bd84, 0x1b2f6d85, 0x10e17c0b, 0x10f17c8d, 0x1b25773d,
+	0x1b22230e, 0x10f6d0c0, 0x1106c96a, 0x1b182038, 0x1b14c7da, 0x110c1afe, 0x111c0bc6, 0x1b0ab87c,
+	0x1b075bf1, 0x11215ab8, 0x11314395, 0x1afd4012, 0x1af9df5d, 0x11368fe1, 0x114670c8, 0x1aefb702,
+	0x1aec5225, 0x114bba6b, 0x115b9354, 0x1ae21d54, 0x1adeb451, 0x1160da4b, 0x1170ab2a, 0x1ad47311,
+	0x1ad105e9, 0x1175ef72, 0x1185b83f, 0x1ac6b841, 0x1ac346f8, 0x118af9d4, 0x119aba84, 0x1ab8ecec,
+	0x1ab57784, 0x119ff964, 0x11afb1ee, 0x1aab111c, 0x1aa79796, 0x11b4ee14, 0x11c49e6f, 0x1a9d24d9,
+	0x1a99a737, 0x11c9d7d9, 0x11d97ff9, 0x1a8f282b, 0x1a8ba670, 0x11deb6a4, 0x11ee5682, 0x1a811b1b,
+	0x1a7d9549, 0x11f38a6a, 0x120321fa, 0x1a72fdb2, 0x1a6f73ca, 0x1208531c, 0x1217e256, 0x1a64cff8,
+	0x1a6141fd, 0x121d10af, 0x122c9789, 0x1a5691f5, 0x1a52ffeb, 0x1231c316, 0x12414186, 0x1a4843b4,
+	0x1a44ad9b, 0x12466a44, 0x1255e041, 0x1a39e53d, 0x1a364b17, 0x125b062b, 0x126a73ac, 0x1a2b7698,
+	0x1a27d868, 0x126f96c1, 0x127efbbb, 0x1a1cf7ce, 0x1a195597, 0x12841bf6, 0x12937861, 0x1a0e68e9,
+	0x1a0ac2ac, 0x129895c0, 0x12a7e991, 0x19ffc9f1, 0x19fc1fb1, 0x12ad0412, 0x12bc4f40, 0x19f11af0,
+	0x19ed6caf, 0x12c166de, 0x12d0a960, 0x19e25bee, 0x19dea9ae, 0x12d5be18, 0x12e4f7e5, 0x19d38cf4,
+	0x19cfd6b8, 0x12ea09b4, 0x12f93ac2, 0x19c4ae0c, 0x19c0f3d6, 0x12fe49a6, 0x130d71eb, 0x19b5bf3f,
+	0x19b20111, 0x13127de0, 0x13219d53, 0x19a6c096, 0x19a2fe73, 0x1326a656, 0x1335bcef, 0x1997b21b,
+	0x1993ec04, 0x133ac2fc, 0x1349d0b0, 0x198893d6, 0x1984c9ce, 0x134ed3c5, 0x135dd88c, 0x197965d0,
+	0x197597da, 0x1362d8a6, 0x1371d476, 0x196a2815, 0x19665632, 0x1376d191, 0x1385c461, 0x195adaab,
+	0x195704df, 0x138abe7b, 0x1399a841, 0x194b7d9e, 0x1947a3eb, 0x139e9f56, 0x13ad800a, 0x193c10f7,
+	0x1938335e, 0x13b27417, 0x13c14bb0, 0x192c94bf, 0x1928b343, 0x13c63cb2, 0x13d50b26, 0x191d08ff,
+	0x191923a3, 0x13d9f91b, 0x13e8be60, 0x190d6dc1, 0x19098488, 0x13eda944, 0x13fc6553, 0x18fdc310,
+	0x18f9d5fa, 0x14014d23, 0x140ffff1, 0x18ee08f4, 0x18ea1805, 0x1414e4aa, 0x14238e2f, 0x18de3f77,
+	0x18da4ab2, 0x14286fce, 0x14371001, 0x18ce66a3, 0x18ca6e0a, 0x143bee83, 0x144a855b, 0x18be7e82,
+	0x18ba8217, 0x144f60bd, 0x145dee30, 0x18ae871e, 0x18aa86e3, 0x1462c670, 0x14714a76, 0x189e8080,
+	0x189a7c78, 0x14761f8f, 0x14849a1f, 0x188e6ab2, 0x188a62e0, 0x14896c0f, 0x1497dd20, 0x187e45be,
+	0x187a3a25, 0x149cabe4, 0x14ab136d, 0x186e11af, 0x186a0250, 0x14afdf03, 0x14be3cfa, 0x185dce8e,
+	0x1859bb6c, 0x14c3055e, 0x14d159bc, 0x184d7c65, 0x18496583, 0x14d61eeb, 0x14e469a6, 0x183d1b3e,
+	0x1839009e, 0x14e92b9e, 0x14f76cad, 0x182cab24, 0x18288cc8, 0x14fc2b6a, 0x150a62c6, 0x181c2c20,
+	0x18180a0c, 0x150f1e45, 0x151d4be3, 0x180b9e3d, 0x18077873, 0x15220422, 0x153027fb, 0x17fb0185,
+	0x17f6d807, 0x1534dcf6, 0x1542f700, 0x17ea5602, 0x17e628d3, 0x1547a8b5, 0x1555b8e8, 0x17d99bbe,
+	0x17d56ae0, 0x155a6754, 0x15686da7, 0x17c8d2c4, 0x17c49e3b, 0x156d18c7, 0x157b1532, 0x17b7fb1f,
+	0x17b3c2ec, 0x157fbd03, 0x158daf7c, 0x17a714d7, 0x17a2d8fe, 0x159253fb, 0x15a03c7a, 0x17961ff9,
+	0x1791e07b, 0x15a4dda5, 0x15b2bc22, 0x17851c8e, 0x1780d96f, 0x15b759f5, 0x15c52e67, 0x17740aa1,
+	0x176fc3e3, 0x15c9c8e0, 0x15d7933f, 0x1762ea3d, 0x175e9fe2, 0x15dc2a5a, 0x15e9ea9d, 0x1751bb6b,
+	0x174d6d77, 0x15ee7e58, 0x15fc3477, 0x17407e37, 0x173c2cac, 0x1600c4cf, 0x160e70c1, 0x172f32ab,
+	0x172add8c, 0x1612fdb3, 0x16209f70, 0x171dd8d2, 0x17198021, 0x162528fa, 0x1632c078, 0x170c70b7,
+	0x17081477, 0x16374697, 0x1644d3d0, 0x16fafa64, 0x16f69a97, 0x16495680, 0x1656d96a, 0x16e975e4,
+	0x16e5128e, 0x165b58aa, 0x1668d13e, 0x16d7e341, 0x16d37c65, 0x166d4d0a, 0x167abb3e, 0x16c64288,
+	0x16c1d827, 0x167f3394, 0x168c9760, 0x16b493c2, 0x16b025e0, 0x16910c3d, 0x169e659a, 0x16a2d6fb
+};
+
+const int twidTab512[8*6 + 32*6 + 128*6] = {
+	0x20000000, 0x00000000, 0x1d906bcf, 0x0c3ef153, 0x16a09e66, 0x16a09e66, 0x0c3ef153, 0x1d906bcf,
+	0x20000000, 0x00000000, 0x1f6297d0, 0x063e2e0f, 0x1d906bcf, 0x0c3ef153, 0x1a9b6629, 0x11c73b3a,
+	0x20000000, 0x00000000, 0x1a9b6629, 0x11c73b3a, 0x0c3ef153, 0x1d906bcf, 0xf9c1d1f1, 0x1f6297d0,
+	0x00000000, 0x20000000, 0xf3c10ead, 0x1d906bcf, 0xe95f619a, 0x16a09e66, 0xe26f9431, 0x0c3ef153,
+	0x16a09e66, 0x16a09e66, 0x11c73b3a, 0x1a9b6629, 0x0c3ef153, 0x1d906bcf, 0x063e2e0f, 0x1f6297d0,
+	0xe95f619a, 0x16a09e66, 0xe09d6830, 0x063e2e0f, 0xe26f9431, 0xf3c10ead, 0xee38c4c6, 0xe56499d7,
+
+	0x20000000, 0x00000000, 0x1fd88da4, 0x0322f4d8, 0x1f6297d0, 0x063e2e0f, 0x1e9f4157, 0x094a0317,
+	0x20000000, 0x00000000, 0x1ff621e3, 0x0191f65f, 0x1fd88da4, 0x0322f4d8, 0x1fa7557f, 0x04b2041c,
+	0x20000000, 0x00000000, 0x1fa7557f, 0x04b2041c, 0x1e9f4157, 0x094a0317, 0x1ced7af4, 0x0dae8805,
+	0x1d906bcf, 0x0c3ef153, 0x1c38b2f2, 0x0f15ae9c, 0x1a9b6629, 0x11c73b3a, 0x18bc806b, 0x144cf325,
+	0x1f6297d0, 0x063e2e0f, 0x1f0a7efc, 0x07c67e5f, 0x1e9f4157, 0x094a0317, 0x1e212105, 0x0ac7cd3b,
+	0x1a9b6629, 0x11c73b3a, 0x17b5df22, 0x157d6935, 0x144cf325, 0x18bc806b, 0x10738799, 0x1b728345,
+	0x16a09e66, 0x16a09e66, 0x144cf325, 0x18bc806b, 0x11c73b3a, 0x1a9b6629, 0x0f15ae9c, 0x1c38b2f2,
+	0x1d906bcf, 0x0c3ef153, 0x1ced7af4, 0x0dae8805, 0x1c38b2f2, 0x0f15ae9c, 0x1b728345, 0x10738799,
+	0x0c3ef153, 0x1d906bcf, 0x07c67e5f, 0x1f0a7efc, 0x0322f4d8, 0x1fd88da4, 0xfe6e09a1, 0x1ff621e3,
+	0x0c3ef153, 0x1d906bcf, 0x094a0317, 0x1e9f4157, 0x063e2e0f, 0x1f6297d0, 0x0322f4d8, 0x1fd88da4,
+	0x1a9b6629, 0x11c73b3a, 0x19b3e048, 0x130ff7fd, 0x18bc806b, 0x144cf325, 0x17b5df22, 0x157d6935,
+	0xf9c1d1f1, 0x1f6297d0, 0xf53832c5, 0x1e212105, 0xf0ea5164, 0x1c38b2f2, 0xecf00803, 0x19b3e048,
+	0x00000000, 0x20000000, 0xfcdd0b28, 0x1fd88da4, 0xf9c1d1f1, 0x1f6297d0, 0xf6b5fce9, 0x1e9f4157,
+	0x16a09e66, 0x16a09e66, 0x157d6935, 0x17b5df22, 0x144cf325, 0x18bc806b, 0x130ff7fd, 0x19b3e048,
+	0xe95f619a, 0x16a09e66, 0xe64c1fb8, 0x130ff7fd, 0xe3c74d0e, 0x0f15ae9c, 0xe1dedefb, 0x0ac7cd3b,
+	0xf3c10ead, 0x1d906bcf, 0xf0ea5164, 0x1c38b2f2, 0xee38c4c6, 0x1a9b6629, 0xebb30cdb, 0x18bc806b,
+	0x11c73b3a, 0x1a9b6629, 0x10738799, 0x1b728345, 0x0f15ae9c, 0x1c38b2f2, 0x0dae8805, 0x1ced7af4,
+	0xe09d6830, 0x063e2e0f, 0xe009de1d, 0x0191f65f, 0xe027725c, 0xfcdd0b28, 0xe0f58104, 0xf83981a1,
+	0xe95f619a, 0x16a09e66, 0xe7437f95, 0x144cf325, 0xe56499d7, 0x11c73b3a, 0xe3c74d0e, 0x0f15ae9c,
+	0x0c3ef153, 0x1d906bcf, 0x0ac7cd3b, 0x1e212105, 0x094a0317, 0x1e9f4157, 0x07c67e5f, 0x1f0a7efc,
+	0xe26f9431, 0xf3c10ead, 0xe48d7cbb, 0xef8c7867, 0xe7437f95, 0xebb30cdb, 0xea8296cb, 0xe84a20de,
+	0xe26f9431, 0x0c3ef153, 0xe160bea9, 0x094a0317, 0xe09d6830, 0x063e2e0f, 0xe027725c, 0x0322f4d8,
+	0x063e2e0f, 0x1f6297d0, 0x04b2041c, 0x1fa7557f, 0x0322f4d8, 0x1fd88da4, 0x0191f65f, 0x1ff621e3,
+	0xee38c4c6, 0xe56499d7, 0xf25177fb, 0xe312850c, 0xf6b5fce9, 0xe160bea9, 0xfb4dfbe4, 0xe058aa81,
+
+	0x20000000, 0x00000000, 0x1ffd8861, 0x00c90ab0, 0x1ff621e3, 0x0191f65f, 0x1fe9cdad, 0x025aa412,
+	0x20000000, 0x00000000, 0x1fff6217, 0x00648748, 0x1ffd8861, 0x00c90ab0, 0x1ffa72f0, 0x012d8657,
+	0x20000000, 0x00000000, 0x1ffa72f0, 0x012d8657, 0x1fe9cdad, 0x025aa412, 0x1fce15fd, 0x0386f0b9,
+	0x1fd88da4, 0x0322f4d8, 0x1fc26471, 0x03eac9cb, 0x1fa7557f, 0x04b2041c, 0x1f8764fa, 0x05788511,
+	0x1ff621e3, 0x0191f65f, 0x1ff09566, 0x01f656e8, 0x1fe9cdad, 0x025aa412, 0x1fe1cafd, 0x02beda01,
+	0x1fa7557f, 0x04b2041c, 0x1f7599a4, 0x05db7678, 0x1f38f3ac, 0x0702e09b, 0x1ef178a4, 0x0827dc07,
+	0x1f6297d0, 0x063e2e0f, 0x1f38f3ac, 0x0702e09b, 0x1f0a7efc, 0x07c67e5f, 0x1ed740e7, 0x0888e931,
+	0x1fd88da4, 0x0322f4d8, 0x1fce15fd, 0x0386f0b9, 0x1fc26471, 0x03eac9cb, 0x1fb57972, 0x044e7c34,
+	0x1e9f4157, 0x094a0317, 0x1e426a4b, 0x0a68f121, 0x1ddb13b7, 0x0b844298, 0x1d696174, 0x0c9b9532,
+	0x1e9f4157, 0x094a0317, 0x1e6288ec, 0x0a09ae4a, 0x1e212105, 0x0ac7cd3b, 0x1ddb13b7, 0x0b844298,
+	0x1fa7557f, 0x04b2041c, 0x1f97f925, 0x05155dac, 0x1f8764fa, 0x05788511, 0x1f7599a4, 0x05db7678,
+	0x1ced7af4, 0x0dae8805, 0x1c678b35, 0x0ebcbbae, 0x1bd7c0ac, 0x0fc5d26e, 0x1b3e4d3f, 0x10c9704d,
+	0x1d906bcf, 0x0c3ef153, 0x1d4134d1, 0x0cf7bca2, 0x1ced7af4, 0x0dae8805, 0x1c954b21, 0x0e63374d,
+	0x1f6297d0, 0x063e2e0f, 0x1f4e603b, 0x06a0a809, 0x1f38f3ac, 0x0702e09b, 0x1f2252f7, 0x0764d3f9,
+	0x1a9b6629, 0x11c73b3a, 0x19ef43ef, 0x12bedb26, 0x193a224a, 0x13affa29, 0x187c4010, 0x149a449c,
+	0x1c38b2f2, 0x0f15ae9c, 0x1bd7c0ac, 0x0fc5d26e, 0x1b728345, 0x10738799, 0x1b090a58, 0x111eb354,
+	0x1f0a7efc, 0x07c67e5f, 0x1ef178a4, 0x0827dc07, 0x1ed740e7, 0x0888e931, 0x1ebbd8c9, 0x08e9a220,
+	0x17b5df22, 0x157d6935, 0x16e74455, 0x16591926, 0x1610b755, 0x172d0838, 0x15328293, 0x17f8ece3,
+	0x1a9b6629, 0x11c73b3a, 0x1a29a7a0, 0x126d054d, 0x19b3e048, 0x130ff7fd, 0x193a224a, 0x13affa29,
+	0x1e9f4157, 0x094a0317, 0x1e817bab, 0x09aa0861, 0x1e6288ec, 0x0a09ae4a, 0x1e426a4b, 0x0a68f121,
+	0x144cf325, 0x18bc806b, 0x136058b1, 0x19777ef5, 0x126d054d, 0x1a29a7a0, 0x11734d64, 0x1ad2bc9e,
+	0x18bc806b, 0x144cf325, 0x183b0e0c, 0x14e6cabc, 0x17b5df22, 0x157d6935, 0x172d0838, 0x1610b755,
+	0x1e212105, 0x0ac7cd3b, 0x1dfeae62, 0x0b263eef, 0x1ddb13b7, 0x0b844298, 0x1db65262, 0x0be1d499,
+	0x10738799, 0x1b728345, 0x0f6e0ca9, 0x1c08c426, 0x0e63374d, 0x1c954b21, 0x0d536416, 0x1d17e774,
+	0x16a09e66, 0x16a09e66, 0x1610b755, 0x172d0838, 0x157d6935, 0x17b5df22, 0x14e6cabc, 0x183b0e0c,
+	0x1d906bcf, 0x0c3ef153, 0x1d696174, 0x0c9b9532, 0x1d4134d1, 0x0cf7bca2, 0x1d17e774, 0x0d536416,
+	0x0c3ef153, 0x1d906bcf, 0x0b263eef, 0x1dfeae62, 0x0a09ae4a, 0x1e6288ec, 0x08e9a220, 0x1ebbd8c9,
+	0x144cf325, 0x18bc806b, 0x13affa29, 0x193a224a, 0x130ff7fd, 0x19b3e048, 0x126d054d, 0x1a29a7a0,
+	0x1ced7af4, 0x0dae8805, 0x1cc1f0f4, 0x0e0924ec, 0x1c954b21, 0x0e63374d, 0x1c678b35, 0x0ebcbbae,
+	0x07c67e5f, 0x1f0a7efc, 0x06a0a809, 0x1f4e603b, 0x05788511, 0x1f8764fa, 0x044e7c34, 0x1fb57972,
+	0x11c73b3a, 0x1a9b6629, 0x111eb354, 0x1b090a58, 0x10738799, 0x1b728345, 0x0fc5d26e, 0x1bd7c0ac,
+	0x1c38b2f2, 0x0f15ae9c, 0x1c08c426, 0x0f6e0ca9, 0x1bd7c0ac, 0x0fc5d26e, 0x1ba5aa67, 0x101cfc87,
+	0x0322f4d8, 0x1fd88da4, 0x01f656e8, 0x1ff09566, 0x00c90ab0, 0x1ffd8861, 0xff9b78b8, 0x1fff6217,
+	0x0f15ae9c, 0x1c38b2f2, 0x0e63374d, 0x1c954b21, 0x0dae8805, 0x1ced7af4, 0x0cf7bca2, 0x1d4134d1,
+	0x1b728345, 0x10738799, 0x1b3e4d3f, 0x10c9704d, 0x1b090a58, 0x111eb354, 0x1ad2bc9e, 0x11734d64,
+	0xfe6e09a1, 0x1ff621e3, 0xfd4125ff, 0x1fe1cafd, 0xfc153635, 0x1fc26471, 0xfaeaa254, 0x1f97f925,
+	0x0c3ef153, 0x1d906bcf, 0x0b844298, 0x1ddb13b7, 0x0ac7cd3b, 0x1e212105, 0x0a09ae4a, 0x1e6288ec,
+	0x1a9b6629, 0x11c73b3a, 0x1a63091b, 0x121a7999, 0x1a29a7a0, 0x126d054d, 0x19ef43ef, 0x12bedb26,
+	0xf9c1d1f1, 0x1f6297d0, 0xf89b2c07, 0x1f2252f7, 0xf77716cf, 0x1ed740e7, 0xf655f79f, 0x1e817bab,
+	0x094a0317, 0x1e9f4157, 0x0888e931, 0x1ed740e7, 0x07c67e5f, 0x1f0a7efc, 0x0702e09b, 0x1f38f3ac,
+	0x19b3e048, 0x130ff7fd, 0x19777ef5, 0x136058b1, 0x193a224a, 0x13affa29, 0x18fbcca4, 0x13fed953,
+	0xf53832c5, 0x1e212105, 0xf41e2b67, 0x1db65262, 0xf308435e, 0x1d4134d1, 0xf1f6db14, 0x1cc1f0f4,
+	0x063e2e0f, 0x1f6297d0, 0x05788511, 0x1f8764fa, 0x04b2041c, 0x1fa7557f, 0x03eac9cb, 0x1fc26471,
+	0x18bc806b, 0x144cf325, 0x187c4010, 0x149a449c, 0x183b0e0c, 0x14e6cabc, 0x17f8ece3, 0x15328293,
+	0xf0ea5164, 0x1c38b2f2, 0xefe30379, 0x1ba5aa67, 0xeee14cac, 0x1b090a58, 0xede58667, 0x1a63091b,
+	0x0322f4d8, 0x1fd88da4, 0x025aa412, 0x1fe9cdad, 0x0191f65f, 0x1ff621e3, 0x00c90ab0, 0x1ffd8861,
+	0x17b5df22, 0x157d6935, 0x1771e75f, 0x15c77bbe, 0x172d0838, 0x1610b755, 0x16e74455, 0x16591926,
+	0xecf00803, 0x19b3e048, 0xec0126ad, 0x18fbcca4, 0xeb193544, 0x183b0e0c, 0xea388442, 0x1771e75f,
+	0x00000000, 0x20000000, 0xff36f550, 0x1ffd8861, 0xfe6e09a1, 0x1ff621e3, 0xfda55bee, 0x1fe9cdad,
+	0x16a09e66, 0x16a09e66, 0x16591926, 0x16e74455, 0x1610b755, 0x172d0838, 0x15c77bbe, 0x1771e75f,
+	0xe95f619a, 0x16a09e66, 0xe88e18a1, 0x15c77bbe, 0xe7c4f1f4, 0x14e6cabc, 0xe704335c, 0x13fed953,
+	0xfcdd0b28, 0x1fd88da4, 0xfc153635, 0x1fc26471, 0xfb4dfbe4, 0x1fa7557f, 0xfa877aef, 0x1f8764fa,
+	0x157d6935, 0x17b5df22, 0x15328293, 0x17f8ece3, 0x14e6cabc, 0x183b0e0c, 0x149a449c, 0x187c4010,
+	0xe64c1fb8, 0x130ff7fd, 0xe59cf6e5, 0x121a7999, 0xe4f6f5a8, 0x111eb354, 0xe45a5599, 0x101cfc87,
+	0xf9c1d1f1, 0x1f6297d0, 0xf8fd1f65, 0x1f38f3ac, 0xf83981a1, 0x1f0a7efc, 0xf77716cf, 0x1ed740e7,
+	0x144cf325, 0x18bc806b, 0x13fed953, 0x18fbcca4, 0x13affa29, 0x193a224a, 0x136058b1, 0x19777ef5,
+	0xe3c74d0e, 0x0f15ae9c, 0xe33e0f0c, 0x0e0924ec, 0xe2becb2f, 0x0cf7bca2, 0xe249ad9e, 0x0be1d499,
+	0xf6b5fce9, 0x1e9f4157, 0xf5f651b6, 0x1e6288ec, 0xf53832c5, 0x1e212105, 0xf47bbd68, 0x1ddb13b7,
+	0x130ff7fd, 0x19b3e048, 0x12bedb26, 0x19ef43ef, 0x126d054d, 0x1a29a7a0, 0x121a7999, 0x1a63091b,
+	0xe1dedefb, 0x0ac7cd3b, 0xe17e8455, 0x09aa0861, 0xe128bf19, 0x0888e931, 0xe0ddad09, 0x0764d3f9,
+	0xf3c10ead, 0x1d906bcf, 0xf308435e, 0x1d4134d1, 0xf25177fb, 0x1ced7af4, 0xf19cc8b3, 0x1c954b21,
+	0x11c73b3a, 0x1a9b6629, 0x11734d64, 0x1ad2bc9e, 0x111eb354, 0x1b090a58, 0x10c9704d, 0x1b3e4d3f,
+	0xe09d6830, 0x063e2e0f, 0xe06806db, 0x05155dac, 0xe03d9b8f, 0x03eac9cb, 0xe01e3503, 0x02beda01,
+	0xf0ea5164, 0x1c38b2f2, 0xf03a2d92, 0x1bd7c0ac, 0xef8c7867, 0x1b728345, 0xeee14cac, 0x1b090a58,
+	0x10738799, 0x1b728345, 0x101cfc87, 0x1ba5aa67, 0x0fc5d26e, 0x1bd7c0ac, 0x0f6e0ca9, 0x1c08c426,
+	0xe009de1d, 0x0191f65f, 0xe0009de9, 0x00648748, 0xe002779f, 0xff36f550, 0xe00f6a9a, 0xfe09a918,
+	0xee38c4c6, 0x1a9b6629, 0xed92fab3, 0x1a29a7a0, 0xecf00803, 0x19b3e048, 0xec5005d7, 0x193a224a,
+	0x0f15ae9c, 0x1c38b2f2, 0x0ebcbbae, 0x1c678b35, 0x0e63374d, 0x1c954b21, 0x0e0924ec, 0x1cc1f0f4,
+	0xe027725c, 0xfcdd0b28, 0xe04a868e, 0xfbb183cc, 0xe0789b06, 0xfa877aef, 0xe0b19fc5, 0xf95f57f7,
+	0xebb30cdb, 0x18bc806b, 0xeb193544, 0x183b0e0c, 0xea8296cb, 0x17b5df22, 0xe9ef48ab, 0x172d0838,
+	0x0dae8805, 0x1ced7af4, 0x0d536416, 0x1d17e774, 0x0cf7bca2, 0x1d4134d1, 0x0c9b9532, 0x1d696174,
+	0xe0f58104, 0xf83981a1, 0xe1442737, 0xf7165de0, 0xe19d7714, 0xf5f651b6, 0xe201519e, 0xf4d9c111,
+	0xe95f619a, 0x16a09e66, 0xe8d2f7c8, 0x1610b755, 0xe84a20de, 0x157d6935, 0xe7c4f1f4, 0x14e6cabc,
+	0x0c3ef153, 0x1d906bcf, 0x0be1d499, 0x1db65262, 0x0b844298, 0x1ddb13b7, 0x0b263eef, 0x1dfeae62,
+	0xe26f9431, 0xf3c10ead, 0xe2e8188c, 0xf2ac9bea, 0xe36ab4df, 0xf19cc8b3, 0xe3f73bda, 0xf091f357,
+	0xe7437f95, 0x144cf325, 0xe6c5ddb6, 0x13affa29, 0xe64c1fb8, 0x130ff7fd, 0xe5d65860, 0x126d054d,
+	0x0ac7cd3b, 0x1e212105, 0x0a68f121, 0x1e426a4b, 0x0a09ae4a, 0x1e6288ec, 0x09aa0861, 0x1e817bab,
+	0xe48d7cbb, 0xef8c7867, 0xe52d4362, 0xee8cb29c, 0xe5d65860, 0xed92fab3, 0xe688810b, 0xec9fa74f,
+	0xe56499d7, 0x11c73b3a, 0xe4f6f5a8, 0x111eb354, 0xe48d7cbb, 0x10738799, 0xe4283f54, 0x0fc5d26e,
+	0x094a0317, 0x1e9f4157, 0x08e9a220, 0x1ebbd8c9, 0x0888e931, 0x1ed740e7, 0x0827dc07, 0x1ef178a4,
+	0xe7437f95, 0xebb30cdb, 0xe807131d, 0xeacd7d6d, 0xe8d2f7c8, 0xe9ef48ab, 0xe9a6e6da, 0xe918bbab,
+	0xe3c74d0e, 0x0f15ae9c, 0xe36ab4df, 0x0e63374d, 0xe312850c, 0x0dae8805, 0xe2becb2f, 0x0cf7bca2,
+	0x07c67e5f, 0x1f0a7efc, 0x0764d3f9, 0x1f2252f7, 0x0702e09b, 0x1f38f3ac, 0x06a0a809, 0x1f4e603b,
+	0xea8296cb, 0xe84a20de, 0xeb65bb64, 0xe783bff0, 0xec5005d7, 0xe6c5ddb6, 0xed4124da, 0xe610bc11,
+	0xe26f9431, 0x0c3ef153, 0xe224ec49, 0x0b844298, 0xe1dedefb, 0x0ac7cd3b, 0xe19d7714, 0x0a09ae4a,
+	0x063e2e0f, 0x1f6297d0, 0x05db7678, 0x1f7599a4, 0x05788511, 0x1f8764fa, 0x05155dac, 0x1f97f925,
+	0xee38c4c6, 0xe56499d7, 0xef368fb3, 0xe4c1b2c1, 0xf03a2d92, 0xe4283f54, 0xf1434452, 0xe39874cb,
+	0xe160bea9, 0x094a0317, 0xe128bf19, 0x0888e931, 0xe0f58104, 0x07c67e5f, 0xe0c70c54, 0x0702e09b,
+	0x04b2041c, 0x1fa7557f, 0x044e7c34, 0x1fb57972, 0x03eac9cb, 0x1fc26471, 0x0386f0b9, 0x1fce15fd,
+	0xf25177fb, 0xe312850c, 0xf3646ace, 0xe2969e8c, 0xf47bbd68, 0xe224ec49, 0xf5970edf, 0xe1bd95b5,
+	0xe09d6830, 0x063e2e0f, 0xe0789b06, 0x05788511, 0xe058aa81, 0x04b2041c, 0xe03d9b8f, 0x03eac9cb,
+	0x0322f4d8, 0x1fd88da4, 0x02beda01, 0x1fe1cafd, 0x025aa412, 0x1fe9cdad, 0x01f656e8, 0x1ff09566,
+	0xf6b5fce9, 0xe160bea9, 0xf7d823f9, 0xe10e875c, 0xf8fd1f65, 0xe0c70c54, 0xfa248988, 0xe08a665c,
+	0xe027725c, 0x0322f4d8, 0xe0163253, 0x025aa412, 0xe009de1d, 0x0191f65f, 0xe002779f, 0x00c90ab0,
+	0x0191f65f, 0x1ff621e3, 0x012d8657, 0x1ffa72f0, 0x00c90ab0, 0x1ffd8861, 0x00648748, 0x1fff6217,
+	0xfb4dfbe4, 0xe058aa81, 0xfc790f47, 0xe031ea03, 0xfda55bee, 0xe0163253, 0xfed279a9, 0xe0058d10
+};
+
+const int twidTab64[4*6 + 16*6] = {
+	0x20000000, 0x00000000, 0x16a09e66, 0x16a09e66, 0x00000000, 0x20000000, 0xe95f619a, 0x16a09e66,
+	0x20000000, 0x00000000, 0x1d906bcf, 0x0c3ef153, 0x16a09e66, 0x16a09e66, 0x0c3ef153, 0x1d906bcf,
+	0x20000000, 0x00000000, 0x0c3ef153, 0x1d906bcf, 0xe95f619a, 0x16a09e66, 0xe26f9431, 0xf3c10ead,
+
+	0x20000000, 0x00000000, 0x1f6297d0, 0x063e2e0f, 0x1d906bcf, 0x0c3ef153, 0x1a9b6629, 0x11c73b3a,
+	0x20000000, 0x00000000, 0x1fd88da4, 0x0322f4d8, 0x1f6297d0, 0x063e2e0f, 0x1e9f4157, 0x094a0317,
+	0x20000000, 0x00000000, 0x1e9f4157, 0x094a0317, 0x1a9b6629, 0x11c73b3a, 0x144cf325, 0x18bc806b,
+	0x16a09e66, 0x16a09e66, 0x11c73b3a, 0x1a9b6629, 0x0c3ef153, 0x1d906bcf, 0x063e2e0f, 0x1f6297d0,
+	0x1d906bcf, 0x0c3ef153, 0x1c38b2f2, 0x0f15ae9c, 0x1a9b6629, 0x11c73b3a, 0x18bc806b, 0x144cf325,
+	0x0c3ef153, 0x1d906bcf, 0x0322f4d8, 0x1fd88da4, 0xf9c1d1f1, 0x1f6297d0, 0xf0ea5164, 0x1c38b2f2,
+	0x00000000, 0x20000000, 0xf9c1d1f1, 0x1f6297d0, 0xf3c10ead, 0x1d906bcf, 0xee38c4c6, 0x1a9b6629,
+	0x16a09e66, 0x16a09e66, 0x144cf325, 0x18bc806b, 0x11c73b3a, 0x1a9b6629, 0x0f15ae9c, 0x1c38b2f2,
+	0xe95f619a, 0x16a09e66, 0xe3c74d0e, 0x0f15ae9c, 0xe09d6830, 0x063e2e0f, 0xe027725c, 0xfcdd0b28,
+	0xe95f619a, 0x16a09e66, 0xe56499d7, 0x11c73b3a, 0xe26f9431, 0x0c3ef153, 0xe09d6830, 0x063e2e0f,
+	0x0c3ef153, 0x1d906bcf, 0x094a0317, 0x1e9f4157, 0x063e2e0f, 0x1f6297d0, 0x0322f4d8, 0x1fd88da4,
+	0xe26f9431, 0xf3c10ead, 0xe7437f95, 0xebb30cdb, 0xee38c4c6, 0xe56499d7, 0xf6b5fce9, 0xe160bea9
+};
+
 #else
 
-/* 
- *  Q30 for 128 and 1024 
- *
- * for (i = 0; i < num/4; i++) {
- *   angle = (i + 0.125) * M_PI / num;
- *   x = cos(angle) * (1 << 30);
- *   x = sin(angle) * (1 << 30);
- * 
- *   angle = (num/2 - 1 - i + 0.125) * M_PI / num;
- *   x = cos(angle) * (1 << 30);
- *   x = sin(angle) * (1 << 30);
- * }
- */
-const int cossintab[128 + 1024] = {
-	/* 128 */
-	0x3fffec43, 0x003243f1, 0x015fd4d2, 0x3ffc38d1, 0x3ff9c13a, 0x01c454f5, 0x02f1b755, 0x3feea776, 
-	0x3fe9b8a9, 0x03562038, 0x0483259d, 0x3fd73a4a, 0x3fcfd50b, 0x04e767c5, 0x0613e1c5, 0x3fb5f4ea, 
-	0x3fac1a5b, 0x0677edbb, 0x07a3adff, 0x3f8adc77, 0x3f7e8e1e, 0x08077457, 0x09324ca7, 0x3f55f796, 
-	0x3f473759, 0x0995bdfd, 0x0abf8043, 0x3f174e70, 0x3f061e95, 0x0b228d42, 0x0c4b0b94, 0x3eceeaad, 
-	0x3ebb4ddb, 0x0cada4f5, 0x0dd4b19a, 0x3e7cd778, 0x3e66d0b4, 0x0e36c82a, 0x0f5c35a3, 0x3e212179, 
-	0x3e08b42a, 0x0fbdba40, 0x10e15b4e, 0x3dbbd6d4, 0x3da106bd, 0x11423ef0, 0x1263e699, 0x3d4d0728, 
-	0x3d2fd86c, 0x12c41a4f, 0x13e39be9, 0x3cd4c38b, 0x3cb53aaa, 0x144310dd, 0x15604013, 0x3c531e88, 
-	0x3c314060, 0x15bee78c, 0x16d99864, 0x3bc82c1f, 0x3ba3fde7, 0x173763c9, 0x184f6aab, 0x3b3401bb, 
-	0x3b0d8909, 0x18ac4b87, 0x19c17d44, 0x3a96b636, 0x3a6df8f8, 0x1a1d6544, 0x1b2f971e, 0x39f061d2, 
-	0x39c5664f, 0x1b8a7815, 0x1c997fc4, 0x39411e33, 0x3913eb0e, 0x1cf34baf, 0x1dfeff67, 0x38890663, 
-	0x3859a292, 0x1e57a86d, 0x1f5fdee6, 0x37c836c2, 0x3796a996, 0x1fb7575c, 0x20bbe7d8, 0x36fecd0e, 
-	0x36cb1e2a, 0x21122240, 0x2212e492, 0x362ce855, 0x35f71fb1, 0x2267d3a0, 0x2364a02e, 0x3552a8f4, 
-	0x351acedd, 0x23b836ca, 0x24b0e699, 0x34703095, 0x34364da6, 0x250317df, 0x25f78497, 0x3385a222, 
-	0x3349bf48, 0x264843d9, 0x273847c8, 0x329321c7, 0x32554840, 0x27878893, 0x2872feb6, 0x3198d4ea, 
-	0x31590e3e, 0x28c0b4d2, 0x29a778db, 0x3096e223, 0x30553828, 0x29f3984c, 0x2ad586a3, 0x2f8d713a, 
-	0x2f49ee0f, 0x2b2003ac, 0x2bfcf97c, 0x2e7cab1c, 0x2e37592c, 0x2c45c8a0, 0x2d1da3d5, 0x2d64b9da, 
-	/* 1024 */
-	0x3fffffb1, 0x0006487f, 0x002bfb74, 0x3ffff0e3, 0x3fffe705, 0x00388c6e, 0x005e3f4c, 0x3fffba9b, 
-	0x3fffa6de, 0x006ad03b, 0x009082ea, 0x3fff5cd8, 0x3fff3f3c, 0x009d13c5, 0x00c2c62f, 0x3ffed79b, 
-	0x3ffeb021, 0x00cf56ef, 0x00f508fc, 0x3ffe2ae5, 0x3ffdf98c, 0x01019998, 0x01274b31, 0x3ffd56b5, 
-	0x3ffd1b7e, 0x0133dba3, 0x01598cb1, 0x3ffc5b0c, 0x3ffc15f7, 0x01661cf0, 0x018bcd5b, 0x3ffb37ec, 
-	0x3ffae8f9, 0x01985d60, 0x01be0d11, 0x3ff9ed53, 0x3ff99483, 0x01ca9cd4, 0x01f04bb4, 0x3ff87b44, 
-	0x3ff81896, 0x01fcdb2e, 0x02228924, 0x3ff6e1bf, 0x3ff67534, 0x022f184d, 0x0254c544, 0x3ff520c5, 
-	0x3ff4aa5d, 0x02615414, 0x0286fff3, 0x3ff33858, 0x3ff2b813, 0x02938e62, 0x02b93914, 0x3ff12878, 
-	0x3ff09e56, 0x02c5c71a, 0x02eb7086, 0x3feef126, 0x3fee5d28, 0x02f7fe1c, 0x031da62b, 0x3fec9265, 
-	0x3febf48b, 0x032a3349, 0x034fd9e5, 0x3fea0c35, 0x3fe96480, 0x035c6682, 0x03820b93, 0x3fe75e98, 
-	0x3fe6ad08, 0x038e97a9, 0x03b43b17, 0x3fe48990, 0x3fe3ce26, 0x03c0c69e, 0x03e66852, 0x3fe18d1f, 
-	0x3fe0c7da, 0x03f2f342, 0x04189326, 0x3fde6945, 0x3fdd9a27, 0x04251d77, 0x044abb73, 0x3fdb1e06, 
-	0x3fda450f, 0x0457451d, 0x047ce11a, 0x3fd7ab64, 0x3fd6c894, 0x04896a16, 0x04af03fc, 0x3fd4115f, 
-	0x3fd324b7, 0x04bb8c42, 0x04e123fa, 0x3fd04ffc, 0x3fcf597c, 0x04edab83, 0x051340f6, 0x3fcc673b, 
-	0x3fcb66e4, 0x051fc7b9, 0x05455ad1, 0x3fc8571f, 0x3fc74cf3, 0x0551e0c7, 0x0577716b, 0x3fc41fac, 
-	0x3fc30baa, 0x0583f68c, 0x05a984a6, 0x3fbfc0e3, 0x3fbea30c, 0x05b608eb, 0x05db9463, 0x3fbb3ac7, 
-	0x3fba131b, 0x05e817c3, 0x060da083, 0x3fb68d5b, 0x3fb55bdc, 0x061a22f7, 0x063fa8e7, 0x3fb1b8a2, 
-	0x3fb07d50, 0x064c2a67, 0x0671ad71, 0x3facbc9f, 0x3fab777b, 0x067e2df5, 0x06a3ae00, 0x3fa79954, 
-	0x3fa64a5f, 0x06b02d81, 0x06d5aa77, 0x3fa24ec6, 0x3fa0f600, 0x06e228ee, 0x0707a2b7, 0x3f9cdcf7, 
-	0x3f9b7a62, 0x0714201b, 0x073996a1, 0x3f9743eb, 0x3f95d787, 0x074612eb, 0x076b8616, 0x3f9183a5, 
-	0x3f900d72, 0x0778013d, 0x079d70f7, 0x3f8b9c28, 0x3f8a1c29, 0x07a9eaf5, 0x07cf5726, 0x3f858d79, 
-	0x3f8403ae, 0x07dbcff2, 0x08013883, 0x3f7f579b, 0x3f7dc405, 0x080db016, 0x083314f1, 0x3f78fa92, 
-	0x3f775d31, 0x083f8b43, 0x0864ec4f, 0x3f727661, 0x3f70cf38, 0x08716159, 0x0896be80, 0x3f6bcb0e, 
-	0x3f6a1a1c, 0x08a3323a, 0x08c88b65, 0x3f64f89b, 0x3f633de2, 0x08d4fdc6, 0x08fa52de, 0x3f5dff0e, 
-	0x3f5c3a8f, 0x0906c3e0, 0x092c14ce, 0x3f56de6a, 0x3f551026, 0x09388469, 0x095dd116, 0x3f4f96b4, 
-	0x3f4dbeac, 0x096a3f42, 0x098f8796, 0x3f4827f0, 0x3f464626, 0x099bf44c, 0x09c13831, 0x3f409223, 
-	0x3f3ea697, 0x09cda368, 0x09f2e2c7, 0x3f38d552, 0x3f36e006, 0x09ff4c78, 0x0a24873a, 0x3f30f181, 
-	0x3f2ef276, 0x0a30ef5e, 0x0a56256c, 0x3f28e6b6, 0x3f26ddec, 0x0a628bfa, 0x0a87bd3d, 0x3f20b4f5, 
-	0x3f1ea26e, 0x0a94222f, 0x0ab94e8f, 0x3f185c43, 0x3f164001, 0x0ac5b1dc, 0x0aead944, 0x3f0fdca5, 
-	0x3f0db6a9, 0x0af73ae5, 0x0b1c5d3d, 0x3f073621, 0x3f05066d, 0x0b28bd2a, 0x0b4dda5c, 0x3efe68bc, 
-	0x3efc2f50, 0x0b5a388d, 0x0b7f5081, 0x3ef5747b, 0x3ef3315a, 0x0b8bacf0, 0x0bb0bf8f, 0x3eec5965, 
-	0x3eea0c8e, 0x0bbd1a33, 0x0be22766, 0x3ee3177e, 0x3ee0c0f4, 0x0bee8038, 0x0c1387e9, 0x3ed9aecc, 
-	0x3ed74e91, 0x0c1fdee1, 0x0c44e0f9, 0x3ed01f55, 0x3ecdb56a, 0x0c513610, 0x0c763278, 0x3ec66920, 
-	0x3ec3f585, 0x0c8285a5, 0x0ca77c47, 0x3ebc8c31, 0x3eba0ee9, 0x0cb3cd84, 0x0cd8be47, 0x3eb2888f, 
-	0x3eb0019c, 0x0ce50d8c, 0x0d09f85b, 0x3ea85e41, 0x3ea5cda3, 0x0d1645a0, 0x0d3b2a64, 0x3e9e0d4c, 
-	0x3e9b7306, 0x0d4775a1, 0x0d6c5443, 0x3e9395b7, 0x3e90f1ca, 0x0d789d71, 0x0d9d75db, 0x3e88f788, 
-	0x3e8649f5, 0x0da9bcf2, 0x0dce8f0d, 0x3e7e32c6, 0x3e7b7b90, 0x0ddad406, 0x0dff9fba, 0x3e734778, 
-	0x3e70869f, 0x0e0be28e, 0x0e30a7c5, 0x3e6835a4, 0x3e656b2b, 0x0e3ce86b, 0x0e61a70f, 0x3e5cfd51, 
-	0x3e5a2939, 0x0e6de580, 0x0e929d7a, 0x3e519e86, 0x3e4ec0d1, 0x0e9ed9af, 0x0ec38ae8, 0x3e46194a, 
-	0x3e4331fa, 0x0ecfc4d9, 0x0ef46f3b, 0x3e3a6da4, 0x3e377cbb, 0x0f00a6df, 0x0f254a53, 0x3e2e9b9c, 
-	0x3e2ba11b, 0x0f317fa5, 0x0f561c15, 0x3e22a338, 0x3e1f9f21, 0x0f624f0c, 0x0f86e460, 0x3e168480, 
-	0x3e1376d5, 0x0f9314f5, 0x0fb7a317, 0x3e0a3f7b, 0x3e07283f, 0x0fc3d143, 0x0fe8581d, 0x3dfdd432, 
-	0x3dfab365, 0x0ff483d7, 0x10190352, 0x3df142ab, 0x3dee1851, 0x10252c94, 0x1049a49a, 0x3de48aef, 
-	0x3de15708, 0x1055cb5b, 0x107a3bd5, 0x3dd7ad05, 0x3dd46f94, 0x1086600e, 0x10aac8e6, 0x3dcaa8f5, 
-	0x3dc761fc, 0x10b6ea90, 0x10db4baf, 0x3dbd7ec7, 0x3dba2e48, 0x10e76ac3, 0x110bc413, 0x3db02e84, 
-	0x3dacd481, 0x1117e088, 0x113c31f3, 0x3da2b834, 0x3d9f54af, 0x11484bc2, 0x116c9531, 0x3d951bde, 
-	0x3d91aed9, 0x1178ac53, 0x119cedaf, 0x3d87598c, 0x3d83e309, 0x11a9021d, 0x11cd3b50, 0x3d797145, 
-	0x3d75f147, 0x11d94d02, 0x11fd7df6, 0x3d6b6313, 0x3d67d99b, 0x12098ce5, 0x122db583, 0x3d5d2efe, 
-	0x3d599c0e, 0x1239c1a7, 0x125de1da, 0x3d4ed50f, 0x3d4b38aa, 0x1269eb2b, 0x128e02dc, 0x3d40554e, 
-	0x3d3caf76, 0x129a0954, 0x12be186c, 0x3d31afc5, 0x3d2e007c, 0x12ca1c03, 0x12ee226c, 0x3d22e47c, 
-	0x3d1f2bc5, 0x12fa231b, 0x131e20c0, 0x3d13f37e, 0x3d10315a, 0x132a1e7e, 0x134e1348, 0x3d04dcd2, 
-	0x3d011145, 0x135a0e0e, 0x137df9e7, 0x3cf5a082, 0x3cf1cb8e, 0x1389f1af, 0x13add481, 0x3ce63e98, 
-	0x3ce2603f, 0x13b9c943, 0x13dda2f7, 0x3cd6b71e, 0x3cd2cf62, 0x13e994ab, 0x140d652c, 0x3cc70a1c, 
-	0x3cc318ff, 0x141953cb, 0x143d1b02, 0x3cb7379c, 0x3cb33d22, 0x14490685, 0x146cc45c, 0x3ca73fa9, 
-	0x3ca33bd3, 0x1478acbc, 0x149c611d, 0x3c97224c, 0x3c93151d, 0x14a84652, 0x14cbf127, 0x3c86df8e, 
-	0x3c82c909, 0x14d7d32a, 0x14fb745e, 0x3c76777b, 0x3c7257a2, 0x15075327, 0x152aeaa3, 0x3c65ea1c, 
-	0x3c61c0f1, 0x1536c62b, 0x155a53d9, 0x3c55377b, 0x3c510501, 0x15662c18, 0x1589afe3, 0x3c445fa2, 
-	0x3c4023dd, 0x159584d3, 0x15b8fea4, 0x3c33629d, 0x3c2f1d8e, 0x15c4d03e, 0x15e83fff, 0x3c224075, 
-	0x3c1df21f, 0x15f40e3a, 0x161773d6, 0x3c10f935, 0x3c0ca19b, 0x16233eac, 0x16469a0d, 0x3bff8ce8, 
-	0x3bfb2c0c, 0x16526176, 0x1675b286, 0x3bedfb99, 0x3be9917e, 0x1681767c, 0x16a4bd25, 0x3bdc4552, 
-	0x3bd7d1fa, 0x16b07d9f, 0x16d3b9cc, 0x3bca6a1d, 0x3bc5ed8d, 0x16df76c3, 0x1702a85e, 0x3bb86a08, 
-	0x3bb3e440, 0x170e61cc, 0x173188be, 0x3ba6451b, 0x3ba1b620, 0x173d3e9b, 0x17605ad0, 0x3b93fb63, 
-	0x3b8f6337, 0x176c0d15, 0x178f1e76, 0x3b818ceb, 0x3b7ceb90, 0x179acd1c, 0x17bdd394, 0x3b6ef9be, 
-	0x3b6a4f38, 0x17c97e93, 0x17ec7a0d, 0x3b5c41e8, 0x3b578e39, 0x17f8215e, 0x181b11c4, 0x3b496574, 
-	0x3b44a8a0, 0x1826b561, 0x18499a9d, 0x3b36646e, 0x3b319e77, 0x18553a7d, 0x1878147a, 0x3b233ee1, 
-	0x3b1e6fca, 0x1883b097, 0x18a67f3f, 0x3b0ff4d9, 0x3b0b1ca6, 0x18b21791, 0x18d4dad0, 0x3afc8663, 
-	0x3af7a516, 0x18e06f50, 0x1903270f, 0x3ae8f38b, 0x3ae40926, 0x190eb7b7, 0x193163e1, 0x3ad53c5b, 
-	0x3ad048e3, 0x193cf0a9, 0x195f9128, 0x3ac160e1, 0x3abc6458, 0x196b1a09, 0x198daec8, 0x3aad6129, 
-	0x3aa85b92, 0x199933bb, 0x19bbbca6, 0x3a993d3e, 0x3a942e9d, 0x19c73da3, 0x19e9baa3, 0x3a84f52f, 
-	0x3a7fdd86, 0x19f537a4, 0x1a17a8a5, 0x3a708906, 0x3a6b6859, 0x1a2321a2, 0x1a45868e, 0x3a5bf8d1, 
-	0x3a56cf23, 0x1a50fb81, 0x1a735442, 0x3a47449c, 0x3a4211f0, 0x1a7ec524, 0x1aa111a6, 0x3a326c74, 
-	0x3a2d30cd, 0x1aac7e6f, 0x1acebe9d, 0x3a1d7066, 0x3a182bc8, 0x1ada2746, 0x1afc5b0a, 0x3a08507f, 
-	0x3a0302ed, 0x1b07bf8c, 0x1b29e6d2, 0x39f30ccc, 0x39edb649, 0x1b354727, 0x1b5761d8, 0x39dda55a, 
-	0x39d845e9, 0x1b62bdf8, 0x1b84cc01, 0x39c81a36, 0x39c2b1da, 0x1b9023e5, 0x1bb22530, 0x39b26b6d, 
-	0x39acfa2b, 0x1bbd78d2, 0x1bdf6d4a, 0x399c990d, 0x39971ee7, 0x1beabca1, 0x1c0ca432, 0x3986a324, 
-	0x3981201e, 0x1c17ef39, 0x1c39c9cd, 0x397089bf, 0x396afddc, 0x1c45107c, 0x1c66ddfe, 0x395a4ceb, 
-	0x3954b82e, 0x1c72204f, 0x1c93e0ab, 0x3943ecb6, 0x393e4f23, 0x1c9f1e96, 0x1cc0d1b6, 0x392d692f, 
-	0x3927c2c9, 0x1ccc0b35, 0x1cedb106, 0x3916c262, 0x3911132d, 0x1cf8e611, 0x1d1a7e7d, 0x38fff85e, 
-	0x38fa405e, 0x1d25af0d, 0x1d473a00, 0x38e90b31, 0x38e34a69, 0x1d52660f, 0x1d73e374, 0x38d1fae9, 
-	0x38cc315d, 0x1d7f0afb, 0x1da07abc, 0x38bac795, 0x38b4f547, 0x1dab9db5, 0x1dccffbf, 0x38a37142, 
-	0x389d9637, 0x1dd81e21, 0x1df9725f, 0x388bf7ff, 0x3886143b, 0x1e048c24, 0x1e25d282, 0x38745bdb, 
-	0x386e6f60, 0x1e30e7a4, 0x1e52200c, 0x385c9ce3, 0x3856a7b6, 0x1e5d3084, 0x1e7e5ae2, 0x3844bb28, 
-	0x383ebd4c, 0x1e8966a8, 0x1eaa82e9, 0x382cb6b7, 0x3826b030, 0x1eb589f7, 0x1ed69805, 0x38148f9f, 
-	0x380e8071, 0x1ee19a54, 0x1f029a1c, 0x37fc45ef, 0x37f62e1d, 0x1f0d97a5, 0x1f2e8911, 0x37e3d9b7, 
-	0x37ddb945, 0x1f3981ce, 0x1f5a64cb, 0x37cb4b04, 0x37c521f6, 0x1f6558b5, 0x1f862d2d, 0x37b299e7, 
-	0x37ac6841, 0x1f911c3d, 0x1fb1e21d, 0x3799c66f, 0x37938c34, 0x1fbccc4d, 0x1fdd8381, 0x3780d0aa, 
-	0x377a8ddf, 0x1fe868c8, 0x2009113c, 0x3767b8a9, 0x37616d51, 0x2013f196, 0x20348b35, 0x374e7e7b, 
-	0x37482a9a, 0x203f6699, 0x205ff14f, 0x3735222f, 0x372ec5c9, 0x206ac7b8, 0x208b4372, 0x371ba3d4, 
-	0x37153eee, 0x209614d9, 0x20b68181, 0x3702037c, 0x36fb9618, 0x20c14ddf, 0x20e1ab63, 0x36e84135, 
-	0x36e1cb58, 0x20ec72b1, 0x210cc0fc, 0x36ce5d10, 0x36c7debd, 0x21178334, 0x2137c232, 0x36b4571b, 
-	0x36add058, 0x21427f4d, 0x2162aeea, 0x369a2f69, 0x3693a038, 0x216d66e2, 0x218d870b, 0x367fe608, 
-	0x36794e6e, 0x219839d8, 0x21b84a79, 0x36657b08, 0x365edb09, 0x21c2f815, 0x21e2f91a, 0x364aee7b, 
-	0x3644461b, 0x21eda17f, 0x220d92d4, 0x36304070, 0x36298fb4, 0x221835fb, 0x2238178d, 0x361570f8, 
-	0x360eb7e3, 0x2242b56f, 0x22628729, 0x35fa8023, 0x35f3beba, 0x226d1fc1, 0x228ce191, 0x35df6e03, 
-	0x35d8a449, 0x229774d7, 0x22b726a8, 0x35c43aa7, 0x35bd68a1, 0x22c1b496, 0x22e15655, 0x35a8e621, 
-	0x35a20bd3, 0x22ebdee5, 0x230b707e, 0x358d7081, 0x35868def, 0x2315f3a8, 0x23357509, 0x3571d9d9, 
-	0x356aef08, 0x233ff2c8, 0x235f63dc, 0x35562239, 0x354f2f2c, 0x2369dc29, 0x23893cdd, 0x353a49b2, 
-	0x35334e6f, 0x2393afb2, 0x23b2fff3, 0x351e5056, 0x35174ce0, 0x23bd6d48, 0x23dcad03, 0x35023636, 
-	0x34fb2a92, 0x23e714d3, 0x240643f4, 0x34e5fb63, 0x34dee795, 0x2410a639, 0x242fc4ad, 0x34c99fef, 
-	0x34c283fb, 0x243a215f, 0x24592f13, 0x34ad23eb, 0x34a5ffd5, 0x2463862c, 0x2482830d, 0x34908768, 
-	0x34895b36, 0x248cd487, 0x24abc082, 0x3473ca79, 0x346c962f, 0x24b60c57, 0x24d4e757, 0x3456ed2f, 
-	0x344fb0d1, 0x24df2d81, 0x24fdf775, 0x3439ef9c, 0x3432ab2e, 0x250837ed, 0x2526f0c1, 0x341cd1d2, 
-	0x34158559, 0x25312b81, 0x254fd323, 0x33ff93e2, 0x33f83f62, 0x255a0823, 0x25789e80, 0x33e235df, 
-	0x33dad95e, 0x2582cdbc, 0x25a152c0, 0x33c4b7db, 0x33bd535c, 0x25ab7c30, 0x25c9efca, 0x33a719e8, 
-	0x339fad70, 0x25d41369, 0x25f27584, 0x33895c18, 0x3381e7ac, 0x25fc934b, 0x261ae3d6, 0x336b7e7e, 
-	0x33640223, 0x2624fbbf, 0x26433aa7, 0x334d812d, 0x3345fce6, 0x264d4cac, 0x266b79dd, 0x332f6435, 
-	0x3327d808, 0x267585f8, 0x2693a161, 0x331127ab, 0x3309939c, 0x269da78b, 0x26bbb119, 0x32f2cba1, 
-	0x32eb2fb5, 0x26c5b14c, 0x26e3a8ec, 0x32d45029, 0x32ccac64, 0x26eda322, 0x270b88c2, 0x32b5b557, 
-	0x32ae09be, 0x27157cf5, 0x27335082, 0x3296fb3d, 0x328f47d5, 0x273d3eac, 0x275b0014, 0x327821ee, 
-	0x327066bc, 0x2764e82f, 0x27829760, 0x3259297d, 0x32516686, 0x278c7965, 0x27aa164c, 0x323a11fe, 
-	0x32324746, 0x27b3f235, 0x27d17cc1, 0x321adb83, 0x3213090f, 0x27db5288, 0x27f8caa5, 0x31fb8620, 
-	0x31f3abf5, 0x28029a45, 0x281fffe2, 0x31dc11e8, 0x31d4300b, 0x2829c954, 0x28471c5e, 0x31bc7eee, 
-	0x31b49564, 0x2850df9d, 0x286e2002, 0x319ccd46, 0x3194dc14, 0x2877dd07, 0x28950ab6, 0x317cfd04, 
-	0x3175042e, 0x289ec17a, 0x28bbdc61, 0x315d0e3b, 0x31550dc6, 0x28c58cdf, 0x28e294eb, 0x313d00ff, 
-	0x3134f8f1, 0x28ec3f1e, 0x2909343e, 0x311cd564, 0x3114c5c0, 0x2912d81f, 0x292fba40, 0x30fc8b7d, 
-	0x30f47449, 0x293957c9, 0x295626da, 0x30dc235e, 0x30d404a0, 0x295fbe06, 0x297c79f5, 0x30bb9d1c, 
-	0x30b376d8, 0x29860abd, 0x29a2b378, 0x309af8ca, 0x3092cb05, 0x29ac3dd7, 0x29c8d34d, 0x307a367c, 
-	0x3072013c, 0x29d2573c, 0x29eed95b, 0x30595648, 0x30511991, 0x29f856d5, 0x2a14c58b, 0x30385840, 
-	0x30301418, 0x2a1e3c8a, 0x2a3a97c7, 0x30173c7a, 0x300ef0e5, 0x2a440844, 0x2a604ff5, 0x2ff6030a, 
-	0x2fedb00d, 0x2a69b9ec, 0x2a85ee00, 0x2fd4ac04, 0x2fcc51a5, 0x2a8f516b, 0x2aab71d0, 0x2fb3377c, 
-	0x2faad5c1, 0x2ab4cea9, 0x2ad0db4e, 0x2f91a589, 0x2f893c75, 0x2ada318e, 0x2af62a63, 0x2f6ff63d, 
-	0x2f6785d7, 0x2aff7a05, 0x2b1b5ef8, 0x2f4e29af, 0x2f45b1fb, 0x2b24a7f6, 0x2b4078f5, 0x2f2c3ff2, 
-	0x2f23c0f6, 0x2b49bb4a, 0x2b657844, 0x2f0a391d, 0x2f01b2de, 0x2b6eb3ea, 0x2b8a5cce, 0x2ee81543, 
-	0x2edf87c6, 0x2b9391c0, 0x2baf267d, 0x2ec5d479, 0x2ebd3fc4, 0x2bb854b4, 0x2bd3d53a, 0x2ea376d6, 
-	0x2e9adaee, 0x2bdcfcb0, 0x2bf868ed, 0x2e80fc6e, 0x2e785958, 0x2c01899e, 0x2c1ce181, 0x2e5e6556, 
-	0x2e55bb17, 0x2c25fb66, 0x2c413edf, 0x2e3bb1a4, 0x2e330042, 0x2c4a51f3, 0x2c6580f1, 0x2e18e16d, 
-	0x2e1028ed, 0x2c6e8d2e, 0x2c89a79f, 0x2df5f4c7, 0x2ded352f, 0x2c92ad01, 0x2cadb2d5, 0x2dd2ebc7, 
-	0x2dca251c, 0x2cb6b155, 0x2cd1a27b, 0x2dafc683, 0x2da6f8ca, 0x2cda9a14, 0x2cf5767c, 0x2d8c8510, 
-	0x2d83b04f, 0x2cfe6728, 0x2d192ec1, 0x2d692784, 0x2d604bc0, 0x2d22187a, 0x2d3ccb34, 0x2d45adf6
+/*
+ *  Q30 for 128 and 1024
+ *
+ * for (i = 0; i < num/4; i++) {
+ *   angle = (i + 0.125) * M_PI / num;
+ *   x = cos(angle) * (1 << 30);
+ *   x = sin(angle) * (1 << 30);
+ *
+ *   angle = (num/2 - 1 - i + 0.125) * M_PI / num;
+ *   x = cos(angle) * (1 << 30);
+ *   x = sin(angle) * (1 << 30);
+ * }
+ */
+const int cossintab[128 + 1024] = {
+	/* 128 */
+	0x3fffec43, 0x003243f1, 0x015fd4d2, 0x3ffc38d1, 0x3ff9c13a, 0x01c454f5, 0x02f1b755, 0x3feea776,
+	0x3fe9b8a9, 0x03562038, 0x0483259d, 0x3fd73a4a, 0x3fcfd50b, 0x04e767c5, 0x0613e1c5, 0x3fb5f4ea,
+	0x3fac1a5b, 0x0677edbb, 0x07a3adff, 0x3f8adc77, 0x3f7e8e1e, 0x08077457, 0x09324ca7, 0x3f55f796,
+	0x3f473759, 0x0995bdfd, 0x0abf8043, 0x3f174e70, 0x3f061e95, 0x0b228d42, 0x0c4b0b94, 0x3eceeaad,
+	0x3ebb4ddb, 0x0cada4f5, 0x0dd4b19a, 0x3e7cd778, 0x3e66d0b4, 0x0e36c82a, 0x0f5c35a3, 0x3e212179,
+	0x3e08b42a, 0x0fbdba40, 0x10e15b4e, 0x3dbbd6d4, 0x3da106bd, 0x11423ef0, 0x1263e699, 0x3d4d0728,
+	0x3d2fd86c, 0x12c41a4f, 0x13e39be9, 0x3cd4c38b, 0x3cb53aaa, 0x144310dd, 0x15604013, 0x3c531e88,
+	0x3c314060, 0x15bee78c, 0x16d99864, 0x3bc82c1f, 0x3ba3fde7, 0x173763c9, 0x184f6aab, 0x3b3401bb,
+	0x3b0d8909, 0x18ac4b87, 0x19c17d44, 0x3a96b636, 0x3a6df8f8, 0x1a1d6544, 0x1b2f971e, 0x39f061d2,
+	0x39c5664f, 0x1b8a7815, 0x1c997fc4, 0x39411e33, 0x3913eb0e, 0x1cf34baf, 0x1dfeff67, 0x38890663,
+	0x3859a292, 0x1e57a86d, 0x1f5fdee6, 0x37c836c2, 0x3796a996, 0x1fb7575c, 0x20bbe7d8, 0x36fecd0e,
+	0x36cb1e2a, 0x21122240, 0x2212e492, 0x362ce855, 0x35f71fb1, 0x2267d3a0, 0x2364a02e, 0x3552a8f4,
+	0x351acedd, 0x23b836ca, 0x24b0e699, 0x34703095, 0x34364da6, 0x250317df, 0x25f78497, 0x3385a222,
+	0x3349bf48, 0x264843d9, 0x273847c8, 0x329321c7, 0x32554840, 0x27878893, 0x2872feb6, 0x3198d4ea,
+	0x31590e3e, 0x28c0b4d2, 0x29a778db, 0x3096e223, 0x30553828, 0x29f3984c, 0x2ad586a3, 0x2f8d713a,
+	0x2f49ee0f, 0x2b2003ac, 0x2bfcf97c, 0x2e7cab1c, 0x2e37592c, 0x2c45c8a0, 0x2d1da3d5, 0x2d64b9da,
+	/* 1024 */
+	0x3fffffb1, 0x0006487f, 0x002bfb74, 0x3ffff0e3, 0x3fffe705, 0x00388c6e, 0x005e3f4c, 0x3fffba9b,
+	0x3fffa6de, 0x006ad03b, 0x009082ea, 0x3fff5cd8, 0x3fff3f3c, 0x009d13c5, 0x00c2c62f, 0x3ffed79b,
+	0x3ffeb021, 0x00cf56ef, 0x00f508fc, 0x3ffe2ae5, 0x3ffdf98c, 0x01019998, 0x01274b31, 0x3ffd56b5,
+	0x3ffd1b7e, 0x0133dba3, 0x01598cb1, 0x3ffc5b0c, 0x3ffc15f7, 0x01661cf0, 0x018bcd5b, 0x3ffb37ec,
+	0x3ffae8f9, 0x01985d60, 0x01be0d11, 0x3ff9ed53, 0x3ff99483, 0x01ca9cd4, 0x01f04bb4, 0x3ff87b44,
+	0x3ff81896, 0x01fcdb2e, 0x02228924, 0x3ff6e1bf, 0x3ff67534, 0x022f184d, 0x0254c544, 0x3ff520c5,
+	0x3ff4aa5d, 0x02615414, 0x0286fff3, 0x3ff33858, 0x3ff2b813, 0x02938e62, 0x02b93914, 0x3ff12878,
+	0x3ff09e56, 0x02c5c71a, 0x02eb7086, 0x3feef126, 0x3fee5d28, 0x02f7fe1c, 0x031da62b, 0x3fec9265,
+	0x3febf48b, 0x032a3349, 0x034fd9e5, 0x3fea0c35, 0x3fe96480, 0x035c6682, 0x03820b93, 0x3fe75e98,
+	0x3fe6ad08, 0x038e97a9, 0x03b43b17, 0x3fe48990, 0x3fe3ce26, 0x03c0c69e, 0x03e66852, 0x3fe18d1f,
+	0x3fe0c7da, 0x03f2f342, 0x04189326, 0x3fde6945, 0x3fdd9a27, 0x04251d77, 0x044abb73, 0x3fdb1e06,
+	0x3fda450f, 0x0457451d, 0x047ce11a, 0x3fd7ab64, 0x3fd6c894, 0x04896a16, 0x04af03fc, 0x3fd4115f,
+	0x3fd324b7, 0x04bb8c42, 0x04e123fa, 0x3fd04ffc, 0x3fcf597c, 0x04edab83, 0x051340f6, 0x3fcc673b,
+	0x3fcb66e4, 0x051fc7b9, 0x05455ad1, 0x3fc8571f, 0x3fc74cf3, 0x0551e0c7, 0x0577716b, 0x3fc41fac,
+	0x3fc30baa, 0x0583f68c, 0x05a984a6, 0x3fbfc0e3, 0x3fbea30c, 0x05b608eb, 0x05db9463, 0x3fbb3ac7,
+	0x3fba131b, 0x05e817c3, 0x060da083, 0x3fb68d5b, 0x3fb55bdc, 0x061a22f7, 0x063fa8e7, 0x3fb1b8a2,
+	0x3fb07d50, 0x064c2a67, 0x0671ad71, 0x3facbc9f, 0x3fab777b, 0x067e2df5, 0x06a3ae00, 0x3fa79954,
+	0x3fa64a5f, 0x06b02d81, 0x06d5aa77, 0x3fa24ec6, 0x3fa0f600, 0x06e228ee, 0x0707a2b7, 0x3f9cdcf7,
+	0x3f9b7a62, 0x0714201b, 0x073996a1, 0x3f9743eb, 0x3f95d787, 0x074612eb, 0x076b8616, 0x3f9183a5,
+	0x3f900d72, 0x0778013d, 0x079d70f7, 0x3f8b9c28, 0x3f8a1c29, 0x07a9eaf5, 0x07cf5726, 0x3f858d79,
+	0x3f8403ae, 0x07dbcff2, 0x08013883, 0x3f7f579b, 0x3f7dc405, 0x080db016, 0x083314f1, 0x3f78fa92,
+	0x3f775d31, 0x083f8b43, 0x0864ec4f, 0x3f727661, 0x3f70cf38, 0x08716159, 0x0896be80, 0x3f6bcb0e,
+	0x3f6a1a1c, 0x08a3323a, 0x08c88b65, 0x3f64f89b, 0x3f633de2, 0x08d4fdc6, 0x08fa52de, 0x3f5dff0e,
+	0x3f5c3a8f, 0x0906c3e0, 0x092c14ce, 0x3f56de6a, 0x3f551026, 0x09388469, 0x095dd116, 0x3f4f96b4,
+	0x3f4dbeac, 0x096a3f42, 0x098f8796, 0x3f4827f0, 0x3f464626, 0x099bf44c, 0x09c13831, 0x3f409223,
+	0x3f3ea697, 0x09cda368, 0x09f2e2c7, 0x3f38d552, 0x3f36e006, 0x09ff4c78, 0x0a24873a, 0x3f30f181,
+	0x3f2ef276, 0x0a30ef5e, 0x0a56256c, 0x3f28e6b6, 0x3f26ddec, 0x0a628bfa, 0x0a87bd3d, 0x3f20b4f5,
+	0x3f1ea26e, 0x0a94222f, 0x0ab94e8f, 0x3f185c43, 0x3f164001, 0x0ac5b1dc, 0x0aead944, 0x3f0fdca5,
+	0x3f0db6a9, 0x0af73ae5, 0x0b1c5d3d, 0x3f073621, 0x3f05066d, 0x0b28bd2a, 0x0b4dda5c, 0x3efe68bc,
+	0x3efc2f50, 0x0b5a388d, 0x0b7f5081, 0x3ef5747b, 0x3ef3315a, 0x0b8bacf0, 0x0bb0bf8f, 0x3eec5965,
+	0x3eea0c8e, 0x0bbd1a33, 0x0be22766, 0x3ee3177e, 0x3ee0c0f4, 0x0bee8038, 0x0c1387e9, 0x3ed9aecc,
+	0x3ed74e91, 0x0c1fdee1, 0x0c44e0f9, 0x3ed01f55, 0x3ecdb56a, 0x0c513610, 0x0c763278, 0x3ec66920,
+	0x3ec3f585, 0x0c8285a5, 0x0ca77c47, 0x3ebc8c31, 0x3eba0ee9, 0x0cb3cd84, 0x0cd8be47, 0x3eb2888f,
+	0x3eb0019c, 0x0ce50d8c, 0x0d09f85b, 0x3ea85e41, 0x3ea5cda3, 0x0d1645a0, 0x0d3b2a64, 0x3e9e0d4c,
+	0x3e9b7306, 0x0d4775a1, 0x0d6c5443, 0x3e9395b7, 0x3e90f1ca, 0x0d789d71, 0x0d9d75db, 0x3e88f788,
+	0x3e8649f5, 0x0da9bcf2, 0x0dce8f0d, 0x3e7e32c6, 0x3e7b7b90, 0x0ddad406, 0x0dff9fba, 0x3e734778,
+	0x3e70869f, 0x0e0be28e, 0x0e30a7c5, 0x3e6835a4, 0x3e656b2b, 0x0e3ce86b, 0x0e61a70f, 0x3e5cfd51,
+	0x3e5a2939, 0x0e6de580, 0x0e929d7a, 0x3e519e86, 0x3e4ec0d1, 0x0e9ed9af, 0x0ec38ae8, 0x3e46194a,
+	0x3e4331fa, 0x0ecfc4d9, 0x0ef46f3b, 0x3e3a6da4, 0x3e377cbb, 0x0f00a6df, 0x0f254a53, 0x3e2e9b9c,
+	0x3e2ba11b, 0x0f317fa5, 0x0f561c15, 0x3e22a338, 0x3e1f9f21, 0x0f624f0c, 0x0f86e460, 0x3e168480,
+	0x3e1376d5, 0x0f9314f5, 0x0fb7a317, 0x3e0a3f7b, 0x3e07283f, 0x0fc3d143, 0x0fe8581d, 0x3dfdd432,
+	0x3dfab365, 0x0ff483d7, 0x10190352, 0x3df142ab, 0x3dee1851, 0x10252c94, 0x1049a49a, 0x3de48aef,
+	0x3de15708, 0x1055cb5b, 0x107a3bd5, 0x3dd7ad05, 0x3dd46f94, 0x1086600e, 0x10aac8e6, 0x3dcaa8f5,
+	0x3dc761fc, 0x10b6ea90, 0x10db4baf, 0x3dbd7ec7, 0x3dba2e48, 0x10e76ac3, 0x110bc413, 0x3db02e84,
+	0x3dacd481, 0x1117e088, 0x113c31f3, 0x3da2b834, 0x3d9f54af, 0x11484bc2, 0x116c9531, 0x3d951bde,
+	0x3d91aed9, 0x1178ac53, 0x119cedaf, 0x3d87598c, 0x3d83e309, 0x11a9021d, 0x11cd3b50, 0x3d797145,
+	0x3d75f147, 0x11d94d02, 0x11fd7df6, 0x3d6b6313, 0x3d67d99b, 0x12098ce5, 0x122db583, 0x3d5d2efe,
+	0x3d599c0e, 0x1239c1a7, 0x125de1da, 0x3d4ed50f, 0x3d4b38aa, 0x1269eb2b, 0x128e02dc, 0x3d40554e,
+	0x3d3caf76, 0x129a0954, 0x12be186c, 0x3d31afc5, 0x3d2e007c, 0x12ca1c03, 0x12ee226c, 0x3d22e47c,
+	0x3d1f2bc5, 0x12fa231b, 0x131e20c0, 0x3d13f37e, 0x3d10315a, 0x132a1e7e, 0x134e1348, 0x3d04dcd2,
+	0x3d011145, 0x135a0e0e, 0x137df9e7, 0x3cf5a082, 0x3cf1cb8e, 0x1389f1af, 0x13add481, 0x3ce63e98,
+	0x3ce2603f, 0x13b9c943, 0x13dda2f7, 0x3cd6b71e, 0x3cd2cf62, 0x13e994ab, 0x140d652c, 0x3cc70a1c,
+	0x3cc318ff, 0x141953cb, 0x143d1b02, 0x3cb7379c, 0x3cb33d22, 0x14490685, 0x146cc45c, 0x3ca73fa9,
+	0x3ca33bd3, 0x1478acbc, 0x149c611d, 0x3c97224c, 0x3c93151d, 0x14a84652, 0x14cbf127, 0x3c86df8e,
+	0x3c82c909, 0x14d7d32a, 0x14fb745e, 0x3c76777b, 0x3c7257a2, 0x15075327, 0x152aeaa3, 0x3c65ea1c,
+	0x3c61c0f1, 0x1536c62b, 0x155a53d9, 0x3c55377b, 0x3c510501, 0x15662c18, 0x1589afe3, 0x3c445fa2,
+	0x3c4023dd, 0x159584d3, 0x15b8fea4, 0x3c33629d, 0x3c2f1d8e, 0x15c4d03e, 0x15e83fff, 0x3c224075,
+	0x3c1df21f, 0x15f40e3a, 0x161773d6, 0x3c10f935, 0x3c0ca19b, 0x16233eac, 0x16469a0d, 0x3bff8ce8,
+	0x3bfb2c0c, 0x16526176, 0x1675b286, 0x3bedfb99, 0x3be9917e, 0x1681767c, 0x16a4bd25, 0x3bdc4552,
+	0x3bd7d1fa, 0x16b07d9f, 0x16d3b9cc, 0x3bca6a1d, 0x3bc5ed8d, 0x16df76c3, 0x1702a85e, 0x3bb86a08,
+	0x3bb3e440, 0x170e61cc, 0x173188be, 0x3ba6451b, 0x3ba1b620, 0x173d3e9b, 0x17605ad0, 0x3b93fb63,
+	0x3b8f6337, 0x176c0d15, 0x178f1e76, 0x3b818ceb, 0x3b7ceb90, 0x179acd1c, 0x17bdd394, 0x3b6ef9be,
+	0x3b6a4f38, 0x17c97e93, 0x17ec7a0d, 0x3b5c41e8, 0x3b578e39, 0x17f8215e, 0x181b11c4, 0x3b496574,
+	0x3b44a8a0, 0x1826b561, 0x18499a9d, 0x3b36646e, 0x3b319e77, 0x18553a7d, 0x1878147a, 0x3b233ee1,
+	0x3b1e6fca, 0x1883b097, 0x18a67f3f, 0x3b0ff4d9, 0x3b0b1ca6, 0x18b21791, 0x18d4dad0, 0x3afc8663,
+	0x3af7a516, 0x18e06f50, 0x1903270f, 0x3ae8f38b, 0x3ae40926, 0x190eb7b7, 0x193163e1, 0x3ad53c5b,
+	0x3ad048e3, 0x193cf0a9, 0x195f9128, 0x3ac160e1, 0x3abc6458, 0x196b1a09, 0x198daec8, 0x3aad6129,
+	0x3aa85b92, 0x199933bb, 0x19bbbca6, 0x3a993d3e, 0x3a942e9d, 0x19c73da3, 0x19e9baa3, 0x3a84f52f,
+	0x3a7fdd86, 0x19f537a4, 0x1a17a8a5, 0x3a708906, 0x3a6b6859, 0x1a2321a2, 0x1a45868e, 0x3a5bf8d1,
+	0x3a56cf23, 0x1a50fb81, 0x1a735442, 0x3a47449c, 0x3a4211f0, 0x1a7ec524, 0x1aa111a6, 0x3a326c74,
+	0x3a2d30cd, 0x1aac7e6f, 0x1acebe9d, 0x3a1d7066, 0x3a182bc8, 0x1ada2746, 0x1afc5b0a, 0x3a08507f,
+	0x3a0302ed, 0x1b07bf8c, 0x1b29e6d2, 0x39f30ccc, 0x39edb649, 0x1b354727, 0x1b5761d8, 0x39dda55a,
+	0x39d845e9, 0x1b62bdf8, 0x1b84cc01, 0x39c81a36, 0x39c2b1da, 0x1b9023e5, 0x1bb22530, 0x39b26b6d,
+	0x39acfa2b, 0x1bbd78d2, 0x1bdf6d4a, 0x399c990d, 0x39971ee7, 0x1beabca1, 0x1c0ca432, 0x3986a324,
+	0x3981201e, 0x1c17ef39, 0x1c39c9cd, 0x397089bf, 0x396afddc, 0x1c45107c, 0x1c66ddfe, 0x395a4ceb,
+	0x3954b82e, 0x1c72204f, 0x1c93e0ab, 0x3943ecb6, 0x393e4f23, 0x1c9f1e96, 0x1cc0d1b6, 0x392d692f,
+	0x3927c2c9, 0x1ccc0b35, 0x1cedb106, 0x3916c262, 0x3911132d, 0x1cf8e611, 0x1d1a7e7d, 0x38fff85e,
+	0x38fa405e, 0x1d25af0d, 0x1d473a00, 0x38e90b31, 0x38e34a69, 0x1d52660f, 0x1d73e374, 0x38d1fae9,
+	0x38cc315d, 0x1d7f0afb, 0x1da07abc, 0x38bac795, 0x38b4f547, 0x1dab9db5, 0x1dccffbf, 0x38a37142,
+	0x389d9637, 0x1dd81e21, 0x1df9725f, 0x388bf7ff, 0x3886143b, 0x1e048c24, 0x1e25d282, 0x38745bdb,
+	0x386e6f60, 0x1e30e7a4, 0x1e52200c, 0x385c9ce3, 0x3856a7b6, 0x1e5d3084, 0x1e7e5ae2, 0x3844bb28,
+	0x383ebd4c, 0x1e8966a8, 0x1eaa82e9, 0x382cb6b7, 0x3826b030, 0x1eb589f7, 0x1ed69805, 0x38148f9f,
+	0x380e8071, 0x1ee19a54, 0x1f029a1c, 0x37fc45ef, 0x37f62e1d, 0x1f0d97a5, 0x1f2e8911, 0x37e3d9b7,
+	0x37ddb945, 0x1f3981ce, 0x1f5a64cb, 0x37cb4b04, 0x37c521f6, 0x1f6558b5, 0x1f862d2d, 0x37b299e7,
+	0x37ac6841, 0x1f911c3d, 0x1fb1e21d, 0x3799c66f, 0x37938c34, 0x1fbccc4d, 0x1fdd8381, 0x3780d0aa,
+	0x377a8ddf, 0x1fe868c8, 0x2009113c, 0x3767b8a9, 0x37616d51, 0x2013f196, 0x20348b35, 0x374e7e7b,
+	0x37482a9a, 0x203f6699, 0x205ff14f, 0x3735222f, 0x372ec5c9, 0x206ac7b8, 0x208b4372, 0x371ba3d4,
+	0x37153eee, 0x209614d9, 0x20b68181, 0x3702037c, 0x36fb9618, 0x20c14ddf, 0x20e1ab63, 0x36e84135,
+	0x36e1cb58, 0x20ec72b1, 0x210cc0fc, 0x36ce5d10, 0x36c7debd, 0x21178334, 0x2137c232, 0x36b4571b,
+	0x36add058, 0x21427f4d, 0x2162aeea, 0x369a2f69, 0x3693a038, 0x216d66e2, 0x218d870b, 0x367fe608,
+	0x36794e6e, 0x219839d8, 0x21b84a79, 0x36657b08, 0x365edb09, 0x21c2f815, 0x21e2f91a, 0x364aee7b,
+	0x3644461b, 0x21eda17f, 0x220d92d4, 0x36304070, 0x36298fb4, 0x221835fb, 0x2238178d, 0x361570f8,
+	0x360eb7e3, 0x2242b56f, 0x22628729, 0x35fa8023, 0x35f3beba, 0x226d1fc1, 0x228ce191, 0x35df6e03,
+	0x35d8a449, 0x229774d7, 0x22b726a8, 0x35c43aa7, 0x35bd68a1, 0x22c1b496, 0x22e15655, 0x35a8e621,
+	0x35a20bd3, 0x22ebdee5, 0x230b707e, 0x358d7081, 0x35868def, 0x2315f3a8, 0x23357509, 0x3571d9d9,
+	0x356aef08, 0x233ff2c8, 0x235f63dc, 0x35562239, 0x354f2f2c, 0x2369dc29, 0x23893cdd, 0x353a49b2,
+	0x35334e6f, 0x2393afb2, 0x23b2fff3, 0x351e5056, 0x35174ce0, 0x23bd6d48, 0x23dcad03, 0x35023636,
+	0x34fb2a92, 0x23e714d3, 0x240643f4, 0x34e5fb63, 0x34dee795, 0x2410a639, 0x242fc4ad, 0x34c99fef,
+	0x34c283fb, 0x243a215f, 0x24592f13, 0x34ad23eb, 0x34a5ffd5, 0x2463862c, 0x2482830d, 0x34908768,
+	0x34895b36, 0x248cd487, 0x24abc082, 0x3473ca79, 0x346c962f, 0x24b60c57, 0x24d4e757, 0x3456ed2f,
+	0x344fb0d1, 0x24df2d81, 0x24fdf775, 0x3439ef9c, 0x3432ab2e, 0x250837ed, 0x2526f0c1, 0x341cd1d2,
+	0x34158559, 0x25312b81, 0x254fd323, 0x33ff93e2, 0x33f83f62, 0x255a0823, 0x25789e80, 0x33e235df,
+	0x33dad95e, 0x2582cdbc, 0x25a152c0, 0x33c4b7db, 0x33bd535c, 0x25ab7c30, 0x25c9efca, 0x33a719e8,
+	0x339fad70, 0x25d41369, 0x25f27584, 0x33895c18, 0x3381e7ac, 0x25fc934b, 0x261ae3d6, 0x336b7e7e,
+	0x33640223, 0x2624fbbf, 0x26433aa7, 0x334d812d, 0x3345fce6, 0x264d4cac, 0x266b79dd, 0x332f6435,
+	0x3327d808, 0x267585f8, 0x2693a161, 0x331127ab, 0x3309939c, 0x269da78b, 0x26bbb119, 0x32f2cba1,
+	0x32eb2fb5, 0x26c5b14c, 0x26e3a8ec, 0x32d45029, 0x32ccac64, 0x26eda322, 0x270b88c2, 0x32b5b557,
+	0x32ae09be, 0x27157cf5, 0x27335082, 0x3296fb3d, 0x328f47d5, 0x273d3eac, 0x275b0014, 0x327821ee,
+	0x327066bc, 0x2764e82f, 0x27829760, 0x3259297d, 0x32516686, 0x278c7965, 0x27aa164c, 0x323a11fe,
+	0x32324746, 0x27b3f235, 0x27d17cc1, 0x321adb83, 0x3213090f, 0x27db5288, 0x27f8caa5, 0x31fb8620,
+	0x31f3abf5, 0x28029a45, 0x281fffe2, 0x31dc11e8, 0x31d4300b, 0x2829c954, 0x28471c5e, 0x31bc7eee,
+	0x31b49564, 0x2850df9d, 0x286e2002, 0x319ccd46, 0x3194dc14, 0x2877dd07, 0x28950ab6, 0x317cfd04,
+	0x3175042e, 0x289ec17a, 0x28bbdc61, 0x315d0e3b, 0x31550dc6, 0x28c58cdf, 0x28e294eb, 0x313d00ff,
+	0x3134f8f1, 0x28ec3f1e, 0x2909343e, 0x311cd564, 0x3114c5c0, 0x2912d81f, 0x292fba40, 0x30fc8b7d,
+	0x30f47449, 0x293957c9, 0x295626da, 0x30dc235e, 0x30d404a0, 0x295fbe06, 0x297c79f5, 0x30bb9d1c,
+	0x30b376d8, 0x29860abd, 0x29a2b378, 0x309af8ca, 0x3092cb05, 0x29ac3dd7, 0x29c8d34d, 0x307a367c,
+	0x3072013c, 0x29d2573c, 0x29eed95b, 0x30595648, 0x30511991, 0x29f856d5, 0x2a14c58b, 0x30385840,
+	0x30301418, 0x2a1e3c8a, 0x2a3a97c7, 0x30173c7a, 0x300ef0e5, 0x2a440844, 0x2a604ff5, 0x2ff6030a,
+	0x2fedb00d, 0x2a69b9ec, 0x2a85ee00, 0x2fd4ac04, 0x2fcc51a5, 0x2a8f516b, 0x2aab71d0, 0x2fb3377c,
+	0x2faad5c1, 0x2ab4cea9, 0x2ad0db4e, 0x2f91a589, 0x2f893c75, 0x2ada318e, 0x2af62a63, 0x2f6ff63d,
+	0x2f6785d7, 0x2aff7a05, 0x2b1b5ef8, 0x2f4e29af, 0x2f45b1fb, 0x2b24a7f6, 0x2b4078f5, 0x2f2c3ff2,
+	0x2f23c0f6, 0x2b49bb4a, 0x2b657844, 0x2f0a391d, 0x2f01b2de, 0x2b6eb3ea, 0x2b8a5cce, 0x2ee81543,
+	0x2edf87c6, 0x2b9391c0, 0x2baf267d, 0x2ec5d479, 0x2ebd3fc4, 0x2bb854b4, 0x2bd3d53a, 0x2ea376d6,
+	0x2e9adaee, 0x2bdcfcb0, 0x2bf868ed, 0x2e80fc6e, 0x2e785958, 0x2c01899e, 0x2c1ce181, 0x2e5e6556,
+	0x2e55bb17, 0x2c25fb66, 0x2c413edf, 0x2e3bb1a4, 0x2e330042, 0x2c4a51f3, 0x2c6580f1, 0x2e18e16d,
+	0x2e1028ed, 0x2c6e8d2e, 0x2c89a79f, 0x2df5f4c7, 0x2ded352f, 0x2c92ad01, 0x2cadb2d5, 0x2dd2ebc7,
+	0x2dca251c, 0x2cb6b155, 0x2cd1a27b, 0x2dafc683, 0x2da6f8ca, 0x2cda9a14, 0x2cf5767c, 0x2d8c8510,
+	0x2d83b04f, 0x2cfe6728, 0x2d192ec1, 0x2d692784, 0x2d604bc0, 0x2d22187a, 0x2d3ccb34, 0x2d45adf6
+};
+
+const int twidTab512[8*6 + 32*6 + 128*6] = {
+	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3b20d79e, 0x187de2a6,
+	0x3ec52f9f, 0x0c7c5c1e, 0x3536cc52, 0x238e7673, 0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6,
+	0x187de2a6, 0x3b20d79e, 0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673, 0xf383a3e2, 0x3ec52f9f,
+	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xe7821d5a, 0x3b20d79e,
+	0x238e7673, 0x3536cc52, 0xc13ad061, 0x0c7c5c1e, 0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e,
+	0xc4df2862, 0xe7821d5a, 0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f, 0xdc71898d, 0xcac933ae,
+
+	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3fb11b47, 0x0645e9af,
+	0x3fec43c6, 0x0323ecbe, 0x3f4eaafe, 0x09640837, 0x3ec52f9f, 0x0c7c5c1e, 0x3fb11b47, 0x0645e9af,
+	0x3d3e82ad, 0x1294062e, 0x3d3e82ad, 0x1294062e, 0x3f4eaafe, 0x09640837, 0x39daf5e8, 0x1b5d1009,
+	0x3b20d79e, 0x187de2a6, 0x3ec52f9f, 0x0c7c5c1e, 0x3536cc52, 0x238e7673, 0x387165e3, 0x1e2b5d38,
+	0x3e14fdf7, 0x0f8cfcbd, 0x2f6bbe44, 0x2afad269, 0x3536cc52, 0x238e7673, 0x3d3e82ad, 0x1294062e,
+	0x2899e64a, 0x317900d6, 0x317900d6, 0x2899e64a, 0x3c424209, 0x158f9a75, 0x20e70f32, 0x36e5068a,
+	0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x2899e64a, 0x317900d6,
+	0x39daf5e8, 0x1b5d1009, 0x0f8cfcbd, 0x3e14fdf7, 0x238e7673, 0x3536cc52, 0x387165e3, 0x1e2b5d38,
+	0x0645e9af, 0x3fb11b47, 0x1e2b5d38, 0x387165e3, 0x36e5068a, 0x20e70f32, 0xfcdc1342, 0x3fec43c6,
+	0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673, 0xf383a3e2, 0x3ec52f9f, 0x1294062e, 0x3d3e82ad,
+	0x3367c08f, 0x261feff9, 0xea70658b, 0x3c424209, 0x0c7c5c1e, 0x3ec52f9f, 0x317900d6, 0x2899e64a,
+	0xe1d4a2c8, 0x387165e3, 0x0645e9af, 0x3fb11b47, 0x2f6bbe44, 0x2afad269, 0xd9e01007, 0x3367c08f,
+	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xf9ba1651, 0x3fb11b47,
+	0x2afad269, 0x2f6bbe44, 0xcc983f71, 0x261feff9, 0xf383a3e2, 0x3ec52f9f, 0x2899e64a, 0x317900d6,
+	0xc78e9a1d, 0x1e2b5d38, 0xed6bf9d2, 0x3d3e82ad, 0x261feff9, 0x3367c08f, 0xc3bdbdf7, 0x158f9a75,
+	0xe7821d5a, 0x3b20d79e, 0x238e7673, 0x3536cc52, 0xc13ad061, 0x0c7c5c1e, 0xe1d4a2c8, 0x387165e3,
+	0x20e70f32, 0x36e5068a, 0xc013bc3a, 0x0323ecbe, 0xdc71898d, 0x3536cc52, 0x1e2b5d38, 0x387165e3,
+	0xc04ee4b9, 0xf9ba1651, 0xd76619b6, 0x317900d6, 0x1b5d1009, 0x39daf5e8, 0xc1eb0209, 0xf0730343,
+	0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a, 0xce86ff2a, 0x2899e64a,
+	0x158f9a75, 0x3c424209, 0xc91af976, 0xdf18f0ce, 0xcac933ae, 0x238e7673, 0x1294062e, 0x3d3e82ad,
+	0xce86ff2a, 0xd76619b6, 0xc78e9a1d, 0x1e2b5d38, 0x0f8cfcbd, 0x3e14fdf7, 0xd5052d97, 0xd09441bc,
+	0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f, 0xdc71898d, 0xcac933ae, 0xc2c17d53, 0x1294062e,
+	0x09640837, 0x3f4eaafe, 0xe4a2eff7, 0xc6250a18, 0xc13ad061, 0x0c7c5c1e, 0x0645e9af, 0x3fb11b47,
+	0xed6bf9d2, 0xc2c17d53, 0xc04ee4b9, 0x0645e9af, 0x0323ecbe, 0x3fec43c6, 0xf69bf7c9, 0xc0b15502,
+
+	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3ffb10c1, 0x0192155f,
+	0x3ffec42d, 0x00c90e8f, 0x3ff4e5df, 0x025b0cae, 0x3fec43c6, 0x0323ecbe, 0x3ffb10c1, 0x0192155f,
+	0x3fd39b5a, 0x04b54824, 0x3fd39b5a, 0x04b54824, 0x3ff4e5df, 0x025b0cae, 0x3f9c2bfa, 0x070de171,
+	0x3fb11b47, 0x0645e9af, 0x3fec43c6, 0x0323ecbe, 0x3f4eaafe, 0x09640837, 0x3f84c8e1, 0x07d59395,
+	0x3fe12acb, 0x03ecadcf, 0x3eeb3347, 0x0bb6ecef, 0x3f4eaafe, 0x09640837, 0x3fd39b5a, 0x04b54824,
+	0x3e71e758, 0x0e05c135, 0x3f0ec9f4, 0x0af10a22, 0x3fc395f9, 0x057db402, 0x3de2f147, 0x104fb80e,
+	0x3ec52f9f, 0x0c7c5c1e, 0x3fb11b47, 0x0645e9af, 0x3d3e82ad, 0x1294062e, 0x3e71e758, 0x0e05c135,
+	0x3f9c2bfa, 0x070de171, 0x3c84d496, 0x14d1e242, 0x3e14fdf7, 0x0f8cfcbd, 0x3f84c8e1, 0x07d59395,
+	0x3bb6276d, 0x17088530, 0x3dae81ce, 0x1111d262, 0x3f6af2e3, 0x089cf867, 0x3ad2c2e7, 0x19372a63,
+	0x3d3e82ad, 0x1294062e, 0x3f4eaafe, 0x09640837, 0x39daf5e8, 0x1b5d1009, 0x3cc511d8, 0x14135c94,
+	0x3f2ff249, 0x0a2abb58, 0x38cf1669, 0x1d79775b, 0x3c424209, 0x158f9a75, 0x3f0ec9f4, 0x0af10a22,
+	0x37af8158, 0x1f8ba4db, 0x3bb6276d, 0x17088530, 0x3eeb3347, 0x0bb6ecef, 0x367c9a7d, 0x2192e09a,
+	0x3b20d79e, 0x187de2a6, 0x3ec52f9f, 0x0c7c5c1e, 0x3536cc52, 0x238e7673, 0x3a8269a2, 0x19ef7943,
+	0x3e9cc076, 0x0d415012, 0x33de87de, 0x257db64b, 0x39daf5e8, 0x1b5d1009, 0x3e71e758, 0x0e05c135,
+	0x32744493, 0x275ff452, 0x392a9642, 0x1cc66e99, 0x3e44a5ee, 0x0ec9a7f2, 0x30f8801f, 0x29348937,
+	0x387165e3, 0x1e2b5d38, 0x3e14fdf7, 0x0f8cfcbd, 0x2f6bbe44, 0x2afad269, 0x37af8158, 0x1f8ba4db,
+	0x3de2f147, 0x104fb80e, 0x2dce88a9, 0x2cb2324b, 0x36e5068a, 0x20e70f32, 0x3dae81ce, 0x1111d262,
+	0x2c216eaa, 0x2e5a106f, 0x361214b0, 0x223d66a8, 0x3d77b191, 0x11d3443f, 0x2a650525, 0x2ff1d9c6,
+	0x3536cc52, 0x238e7673, 0x3d3e82ad, 0x1294062e, 0x2899e64a, 0x317900d6, 0x34534f40, 0x24da0a99,
+	0x3d02f756, 0x135410c2, 0x26c0b162, 0x32eefde9, 0x3367c08f, 0x261feff9, 0x3cc511d8, 0x14135c94,
+	0x24da0a99, 0x34534f40, 0x32744493, 0x275ff452, 0x3c84d496, 0x14d1e242, 0x22e69ac7, 0x35a5793c,
+	0x317900d6, 0x2899e64a, 0x3c424209, 0x158f9a75, 0x20e70f32, 0x36e5068a, 0x30761c17, 0x29cd9577,
+	0x3bfd5cc4, 0x164c7ddd, 0x1edc1952, 0x3811884c, 0x2f6bbe44, 0x2afad269, 0x3bb6276d, 0x17088530,
+	0x1cc66e99, 0x392a9642, 0x2e5a106f, 0x2c216eaa, 0x3b6ca4c4, 0x17c3a931, 0x1aa6c82b, 0x3a2fcee8,
+	0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x2c216eaa, 0x2e5a106f,
+	0x3ad2c2e7, 0x19372a63, 0x164c7ddd, 0x3bfd5cc4, 0x2afad269, 0x2f6bbe44, 0x3a8269a2, 0x19ef7943,
+	0x14135c94, 0x3cc511d8, 0x29cd9577, 0x30761c17, 0x3a2fcee8, 0x1aa6c82b, 0x11d3443f, 0x3d77b191,
+	0x2899e64a, 0x317900d6, 0x39daf5e8, 0x1b5d1009, 0x0f8cfcbd, 0x3e14fdf7, 0x275ff452, 0x32744493,
+	0x3983e1e7, 0x1c1249d8, 0x0d415012, 0x3e9cc076, 0x261feff9, 0x3367c08f, 0x392a9642, 0x1cc66e99,
+	0x0af10a22, 0x3f0ec9f4, 0x24da0a99, 0x34534f40, 0x38cf1669, 0x1d79775b, 0x089cf867, 0x3f6af2e3,
+	0x238e7673, 0x3536cc52, 0x387165e3, 0x1e2b5d38, 0x0645e9af, 0x3fb11b47, 0x223d66a8, 0x361214b0,
+	0x3811884c, 0x1edc1952, 0x03ecadcf, 0x3fe12acb, 0x20e70f32, 0x36e5068a, 0x37af8158, 0x1f8ba4db,
+	0x0192155f, 0x3ffb10c1, 0x1f8ba4db, 0x37af8158, 0x374b54ce, 0x2039f90e, 0xff36f171, 0x3ffec42d,
+	0x1e2b5d38, 0x387165e3, 0x36e5068a, 0x20e70f32, 0xfcdc1342, 0x3fec43c6, 0x1cc66e99, 0x392a9642,
+	0x367c9a7d, 0x2192e09a, 0xfa824bfe, 0x3fc395f9, 0x1b5d1009, 0x39daf5e8, 0x361214b0, 0x223d66a8,
+	0xf82a6c6b, 0x3f84c8e1, 0x19ef7943, 0x3a8269a2, 0x35a5793c, 0x22e69ac7, 0xf5d544a8, 0x3f2ff249,
+	0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673, 0xf383a3e2, 0x3ec52f9f, 0x17088530, 0x3bb6276d,
+	0x34c61236, 0x2434f332, 0xf136580e, 0x3e44a5ee, 0x158f9a75, 0x3c424209, 0x34534f40, 0x24da0a99,
+	0xeeee2d9e, 0x3dae81ce, 0x14135c94, 0x3cc511d8, 0x33de87de, 0x257db64b, 0xecabef3e, 0x3d02f756,
+	0x1294062e, 0x3d3e82ad, 0x3367c08f, 0x261feff9, 0xea70658b, 0x3c424209, 0x1111d262, 0x3dae81ce,
+	0x32eefde9, 0x26c0b162, 0xe83c56cf, 0x3b6ca4c4, 0x0f8cfcbd, 0x3e14fdf7, 0x32744493, 0x275ff452,
+	0xe61086bd, 0x3a8269a2, 0x0e05c135, 0x3e71e758, 0x31f79947, 0x27fdb2a6, 0xe3edb628, 0x3983e1e7,
+	0x0c7c5c1e, 0x3ec52f9f, 0x317900d6, 0x2899e64a, 0xe1d4a2c8, 0x387165e3, 0x0af10a22, 0x3f0ec9f4,
+	0x30f8801f, 0x29348937, 0xdfc606f2, 0x374b54ce, 0x09640837, 0x3f4eaafe, 0x30761c17, 0x29cd9577,
+	0xddc29958, 0x361214b0, 0x07d59395, 0x3f84c8e1, 0x2ff1d9c6, 0x2a650525, 0xdbcb0cce, 0x34c61236,
+	0x0645e9af, 0x3fb11b47, 0x2f6bbe44, 0x2afad269, 0xd9e01007, 0x3367c08f, 0x04b54824, 0x3fd39b5a,
+	0x2ee3cebe, 0x2b8ef77c, 0xd8024d5a, 0x31f79947, 0x0323ecbe, 0x3fec43c6, 0x2e5a106f, 0x2c216eaa,
+	0xd6326a89, 0x30761c17, 0x0192155f, 0x3ffb10c1, 0x2dce88a9, 0x2cb2324b, 0xd4710884, 0x2ee3cebe,
+	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xfe6deaa1, 0x3ffb10c1,
+	0x2cb2324b, 0x2dce88a9, 0xd11c3142, 0x2b8ef77c, 0xfcdc1342, 0x3fec43c6, 0x2c216eaa, 0x2e5a106f,
+	0xcf89e3e9, 0x29cd9577, 0xfb4ab7dc, 0x3fd39b5a, 0x2b8ef77c, 0x2ee3cebe, 0xce0866b9, 0x27fdb2a6,
+	0xf9ba1651, 0x3fb11b47, 0x2afad269, 0x2f6bbe44, 0xcc983f71, 0x261feff9, 0xf82a6c6b, 0x3f84c8e1,
+	0x2a650525, 0x2ff1d9c6, 0xcb39edca, 0x2434f332, 0xf69bf7c9, 0x3f4eaafe, 0x29cd9577, 0x30761c17,
+	0xc9edeb50, 0x223d66a8, 0xf50ef5de, 0x3f0ec9f4, 0x29348937, 0x30f8801f, 0xc8b4ab32, 0x2039f90e,
+	0xf383a3e2, 0x3ec52f9f, 0x2899e64a, 0x317900d6, 0xc78e9a1d, 0x1e2b5d38, 0xf1fa3ecb, 0x3e71e758,
+	0x27fdb2a6, 0x31f79947, 0xc67c1e19, 0x1c1249d8, 0xf0730343, 0x3e14fdf7, 0x275ff452, 0x32744493,
+	0xc57d965e, 0x19ef7943, 0xeeee2d9e, 0x3dae81ce, 0x26c0b162, 0x32eefde9, 0xc4935b3c, 0x17c3a931,
+	0xed6bf9d2, 0x3d3e82ad, 0x261feff9, 0x3367c08f, 0xc3bdbdf7, 0x158f9a75, 0xebeca36c, 0x3cc511d8,
+	0x257db64b, 0x33de87de, 0xc2fd08aa, 0x135410c2, 0xea70658b, 0x3c424209, 0x24da0a99, 0x34534f40,
+	0xc2517e32, 0x1111d262, 0xe8f77ad0, 0x3bb6276d, 0x2434f332, 0x34c61236, 0xc1bb5a12, 0x0ec9a7f2,
+	0xe7821d5a, 0x3b20d79e, 0x238e7673, 0x3536cc52, 0xc13ad061, 0x0c7c5c1e, 0xe61086bd, 0x3a8269a2,
+	0x22e69ac7, 0x35a5793c, 0xc0d00db7, 0x0a2abb58, 0xe4a2eff7, 0x39daf5e8, 0x223d66a8, 0x361214b0,
+	0xc07b371f, 0x07d59395, 0xe3399167, 0x392a9642, 0x2192e09a, 0x367c9a7d, 0xc03c6a07, 0x057db402,
+	0xe1d4a2c8, 0x387165e3, 0x20e70f32, 0x36e5068a, 0xc013bc3a, 0x0323ecbe, 0xe0745b25, 0x37af8158,
+	0x2039f90e, 0x374b54ce, 0xc0013bd3, 0x00c90e8f, 0xdf18f0ce, 0x36e5068a, 0x1f8ba4db, 0x37af8158,
+	0xc004ef3f, 0xfe6deaa1, 0xddc29958, 0x361214b0, 0x1edc1952, 0x3811884c, 0xc01ed535, 0xfc135231,
+	0xdc71898d, 0x3536cc52, 0x1e2b5d38, 0x387165e3, 0xc04ee4b9, 0xf9ba1651, 0xdb25f567, 0x34534f40,
+	0x1d79775b, 0x38cf1669, 0xc0950d1d, 0xf7630799, 0xd9e01007, 0x3367c08f, 0x1cc66e99, 0x392a9642,
+	0xc0f1360c, 0xf50ef5de, 0xd8a00bae, 0x32744493, 0x1c1249d8, 0x3983e1e7, 0xc1633f8a, 0xf2beafee,
+	0xd76619b6, 0x317900d6, 0x1b5d1009, 0x39daf5e8, 0xc1eb0209, 0xf0730343, 0xd6326a89, 0x30761c17,
+	0x1aa6c82b, 0x3a2fcee8, 0xc2884e6f, 0xee2cbbc1, 0xd5052d97, 0x2f6bbe44, 0x19ef7943, 0x3a8269a2,
+	0xc33aee28, 0xebeca36c, 0xd3de9156, 0x2e5a106f, 0x19372a63, 0x3ad2c2e7, 0xc402a33c, 0xe9b38223,
+	0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a, 0xd1a5ef91, 0x2c216eaa,
+	0x17c3a931, 0x3b6ca4c4, 0xc5d03118, 0xe55937d5, 0xd09441bc, 0x2afad269, 0x17088530, 0x3bb6276d,
+	0xc6d569be, 0xe3399167, 0xcf89e3e9, 0x29cd9577, 0x164c7ddd, 0x3bfd5cc4, 0xc7ee77b4, 0xe123e6ae,
+	0xce86ff2a, 0x2899e64a, 0x158f9a75, 0x3c424209, 0xc91af976, 0xdf18f0ce, 0xcd8bbb6d, 0x275ff452,
+	0x14d1e242, 0x3c84d496, 0xca5a86c4, 0xdd196539, 0xcc983f71, 0x261feff9, 0x14135c94, 0x3cc511d8,
+	0xcbacb0c0, 0xdb25f567, 0xcbacb0c0, 0x24da0a99, 0x135410c2, 0x3d02f756, 0xcd110217, 0xd93f4e9e,
+	0xcac933ae, 0x238e7673, 0x1294062e, 0x3d3e82ad, 0xce86ff2a, 0xd76619b6, 0xc9edeb50, 0x223d66a8,
+	0x11d3443f, 0x3d77b191, 0xd00e263a, 0xd59afadb, 0xc91af976, 0x20e70f32, 0x1111d262, 0x3dae81ce,
+	0xd1a5ef91, 0xd3de9156, 0xc8507ea8, 0x1f8ba4db, 0x104fb80e, 0x3de2f147, 0xd34dcdb5, 0xd2317757,
+	0xc78e9a1d, 0x1e2b5d38, 0x0f8cfcbd, 0x3e14fdf7, 0xd5052d97, 0xd09441bc, 0xc6d569be, 0x1cc66e99,
+	0x0ec9a7f2, 0x3e44a5ee, 0xd6cb76c9, 0xcf077fe1, 0xc6250a18, 0x1b5d1009, 0x0e05c135, 0x3e71e758,
+	0xd8a00bae, 0xcd8bbb6d, 0xc57d965e, 0x19ef7943, 0x0d415012, 0x3e9cc076, 0xda8249b5, 0xcc217822,
+	0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f, 0xdc71898d, 0xcac933ae, 0xc449d893, 0x17088530,
+	0x0bb6ecef, 0x3eeb3347, 0xde6d1f66, 0xc9836583, 0xc3bdbdf7, 0x158f9a75, 0x0af10a22, 0x3f0ec9f4,
+	0xe0745b25, 0xc8507ea8, 0xc33aee28, 0x14135c94, 0x0a2abb58, 0x3f2ff249, 0xe28688a5, 0xc730e997,
+	0xc2c17d53, 0x1294062e, 0x09640837, 0x3f4eaafe, 0xe4a2eff7, 0xc6250a18, 0xc2517e32, 0x1111d262,
+	0x089cf867, 0x3f6af2e3, 0xe6c8d59d, 0xc52d3d19, 0xc1eb0209, 0x0f8cfcbd, 0x07d59395, 0x3f84c8e1,
+	0xe8f77ad0, 0xc449d893, 0xc18e18a8, 0x0e05c135, 0x070de171, 0x3f9c2bfa, 0xeb2e1dbe, 0xc37b2b6a,
+	0xc13ad061, 0x0c7c5c1e, 0x0645e9af, 0x3fb11b47, 0xed6bf9d2, 0xc2c17d53, 0xc0f1360c, 0x0af10a22,
+	0x057db402, 0x3fc395f9, 0xefb047f2, 0xc21d0eb9, 0xc0b15502, 0x09640837, 0x04b54824, 0x3fd39b5a,
+	0xf1fa3ecb, 0xc18e18a8, 0xc07b371f, 0x07d59395, 0x03ecadcf, 0x3fe12acb, 0xf4491311, 0xc114ccb9,
+	0xc04ee4b9, 0x0645e9af, 0x0323ecbe, 0x3fec43c6, 0xf69bf7c9, 0xc0b15502, 0xc02c64a6, 0x04b54824,
+	0x025b0cae, 0x3ff4e5df, 0xf8f21e8f, 0xc063d406, 0xc013bc3a, 0x0323ecbe, 0x0192155f, 0x3ffb10c1,
+	0xfb4ab7dc, 0xc02c64a6, 0xc004ef3f, 0x0192155f, 0x00c90e8f, 0x3ffec42d, 0xfda4f352, 0xc00b1a21
+};
+
+const int twidTab64[4*6 + 16*6] = {
+	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x2d413ccc, 0x2d413ccc,
+	0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc,
+	0xd2bec334, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a,
+
+	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3ec52f9f, 0x0c7c5c1e,
+	0x3fb11b47, 0x0645e9af, 0x3d3e82ad, 0x1294062e, 0x3b20d79e, 0x187de2a6, 0x3ec52f9f, 0x0c7c5c1e,
+	0x3536cc52, 0x238e7673, 0x3536cc52, 0x238e7673, 0x3d3e82ad, 0x1294062e, 0x2899e64a, 0x317900d6,
+	0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x238e7673, 0x3536cc52,
+	0x387165e3, 0x1e2b5d38, 0x0645e9af, 0x3fb11b47, 0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673,
+	0xf383a3e2, 0x3ec52f9f, 0x0c7c5c1e, 0x3ec52f9f, 0x317900d6, 0x2899e64a, 0xe1d4a2c8, 0x387165e3,
+	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xf383a3e2, 0x3ec52f9f,
+	0x2899e64a, 0x317900d6, 0xc78e9a1d, 0x1e2b5d38, 0xe7821d5a, 0x3b20d79e, 0x238e7673, 0x3536cc52,
+	0xc13ad061, 0x0c7c5c1e, 0xdc71898d, 0x3536cc52, 0x1e2b5d38, 0x387165e3, 0xc04ee4b9, 0xf9ba1651,
+	0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a, 0xcac933ae, 0x238e7673,
+	0x1294062e, 0x3d3e82ad, 0xce86ff2a, 0xd76619b6, 0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f,
+	0xdc71898d, 0xcac933ae, 0xc13ad061, 0x0c7c5c1e, 0x0645e9af, 0x3fb11b47, 0xed6bf9d2, 0xc2c17d53
 };
+#endif  //ARMV5E
 
-const int twidTab512[8*6 + 32*6 + 128*6] = {
-	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3b20d79e, 0x187de2a6, 
-	0x3ec52f9f, 0x0c7c5c1e, 0x3536cc52, 0x238e7673, 0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6, 
-	0x187de2a6, 0x3b20d79e, 0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673, 0xf383a3e2, 0x3ec52f9f, 
-	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xe7821d5a, 0x3b20d79e, 
-	0x238e7673, 0x3536cc52, 0xc13ad061, 0x0c7c5c1e, 0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 
-	0xc4df2862, 0xe7821d5a, 0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f, 0xdc71898d, 0xcac933ae, 
-
-	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3fb11b47, 0x0645e9af, 
-	0x3fec43c6, 0x0323ecbe, 0x3f4eaafe, 0x09640837, 0x3ec52f9f, 0x0c7c5c1e, 0x3fb11b47, 0x0645e9af, 
-	0x3d3e82ad, 0x1294062e, 0x3d3e82ad, 0x1294062e, 0x3f4eaafe, 0x09640837, 0x39daf5e8, 0x1b5d1009, 
-	0x3b20d79e, 0x187de2a6, 0x3ec52f9f, 0x0c7c5c1e, 0x3536cc52, 0x238e7673, 0x387165e3, 0x1e2b5d38, 
-	0x3e14fdf7, 0x0f8cfcbd, 0x2f6bbe44, 0x2afad269, 0x3536cc52, 0x238e7673, 0x3d3e82ad, 0x1294062e, 
-	0x2899e64a, 0x317900d6, 0x317900d6, 0x2899e64a, 0x3c424209, 0x158f9a75, 0x20e70f32, 0x36e5068a, 
-	0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x2899e64a, 0x317900d6, 
-	0x39daf5e8, 0x1b5d1009, 0x0f8cfcbd, 0x3e14fdf7, 0x238e7673, 0x3536cc52, 0x387165e3, 0x1e2b5d38, 
-	0x0645e9af, 0x3fb11b47, 0x1e2b5d38, 0x387165e3, 0x36e5068a, 0x20e70f32, 0xfcdc1342, 0x3fec43c6, 
-	0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673, 0xf383a3e2, 0x3ec52f9f, 0x1294062e, 0x3d3e82ad, 
-	0x3367c08f, 0x261feff9, 0xea70658b, 0x3c424209, 0x0c7c5c1e, 0x3ec52f9f, 0x317900d6, 0x2899e64a, 
-	0xe1d4a2c8, 0x387165e3, 0x0645e9af, 0x3fb11b47, 0x2f6bbe44, 0x2afad269, 0xd9e01007, 0x3367c08f, 
-	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xf9ba1651, 0x3fb11b47, 
-	0x2afad269, 0x2f6bbe44, 0xcc983f71, 0x261feff9, 0xf383a3e2, 0x3ec52f9f, 0x2899e64a, 0x317900d6, 
-	0xc78e9a1d, 0x1e2b5d38, 0xed6bf9d2, 0x3d3e82ad, 0x261feff9, 0x3367c08f, 0xc3bdbdf7, 0x158f9a75, 
-	0xe7821d5a, 0x3b20d79e, 0x238e7673, 0x3536cc52, 0xc13ad061, 0x0c7c5c1e, 0xe1d4a2c8, 0x387165e3, 
-	0x20e70f32, 0x36e5068a, 0xc013bc3a, 0x0323ecbe, 0xdc71898d, 0x3536cc52, 0x1e2b5d38, 0x387165e3, 
-	0xc04ee4b9, 0xf9ba1651, 0xd76619b6, 0x317900d6, 0x1b5d1009, 0x39daf5e8, 0xc1eb0209, 0xf0730343, 
-	0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a, 0xce86ff2a, 0x2899e64a, 
-	0x158f9a75, 0x3c424209, 0xc91af976, 0xdf18f0ce, 0xcac933ae, 0x238e7673, 0x1294062e, 0x3d3e82ad, 
-	0xce86ff2a, 0xd76619b6, 0xc78e9a1d, 0x1e2b5d38, 0x0f8cfcbd, 0x3e14fdf7, 0xd5052d97, 0xd09441bc, 
-	0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f, 0xdc71898d, 0xcac933ae, 0xc2c17d53, 0x1294062e, 
-	0x09640837, 0x3f4eaafe, 0xe4a2eff7, 0xc6250a18, 0xc13ad061, 0x0c7c5c1e, 0x0645e9af, 0x3fb11b47, 
-	0xed6bf9d2, 0xc2c17d53, 0xc04ee4b9, 0x0645e9af, 0x0323ecbe, 0x3fec43c6, 0xf69bf7c9, 0xc0b15502, 
-
-	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3ffb10c1, 0x0192155f, 
-	0x3ffec42d, 0x00c90e8f, 0x3ff4e5df, 0x025b0cae, 0x3fec43c6, 0x0323ecbe, 0x3ffb10c1, 0x0192155f, 
-	0x3fd39b5a, 0x04b54824, 0x3fd39b5a, 0x04b54824, 0x3ff4e5df, 0x025b0cae, 0x3f9c2bfa, 0x070de171, 
-	0x3fb11b47, 0x0645e9af, 0x3fec43c6, 0x0323ecbe, 0x3f4eaafe, 0x09640837, 0x3f84c8e1, 0x07d59395, 
-	0x3fe12acb, 0x03ecadcf, 0x3eeb3347, 0x0bb6ecef, 0x3f4eaafe, 0x09640837, 0x3fd39b5a, 0x04b54824, 
-	0x3e71e758, 0x0e05c135, 0x3f0ec9f4, 0x0af10a22, 0x3fc395f9, 0x057db402, 0x3de2f147, 0x104fb80e, 
-	0x3ec52f9f, 0x0c7c5c1e, 0x3fb11b47, 0x0645e9af, 0x3d3e82ad, 0x1294062e, 0x3e71e758, 0x0e05c135, 
-	0x3f9c2bfa, 0x070de171, 0x3c84d496, 0x14d1e242, 0x3e14fdf7, 0x0f8cfcbd, 0x3f84c8e1, 0x07d59395, 
-	0x3bb6276d, 0x17088530, 0x3dae81ce, 0x1111d262, 0x3f6af2e3, 0x089cf867, 0x3ad2c2e7, 0x19372a63, 
-	0x3d3e82ad, 0x1294062e, 0x3f4eaafe, 0x09640837, 0x39daf5e8, 0x1b5d1009, 0x3cc511d8, 0x14135c94, 
-	0x3f2ff249, 0x0a2abb58, 0x38cf1669, 0x1d79775b, 0x3c424209, 0x158f9a75, 0x3f0ec9f4, 0x0af10a22, 
-	0x37af8158, 0x1f8ba4db, 0x3bb6276d, 0x17088530, 0x3eeb3347, 0x0bb6ecef, 0x367c9a7d, 0x2192e09a, 
-	0x3b20d79e, 0x187de2a6, 0x3ec52f9f, 0x0c7c5c1e, 0x3536cc52, 0x238e7673, 0x3a8269a2, 0x19ef7943, 
-	0x3e9cc076, 0x0d415012, 0x33de87de, 0x257db64b, 0x39daf5e8, 0x1b5d1009, 0x3e71e758, 0x0e05c135, 
-	0x32744493, 0x275ff452, 0x392a9642, 0x1cc66e99, 0x3e44a5ee, 0x0ec9a7f2, 0x30f8801f, 0x29348937, 
-	0x387165e3, 0x1e2b5d38, 0x3e14fdf7, 0x0f8cfcbd, 0x2f6bbe44, 0x2afad269, 0x37af8158, 0x1f8ba4db, 
-	0x3de2f147, 0x104fb80e, 0x2dce88a9, 0x2cb2324b, 0x36e5068a, 0x20e70f32, 0x3dae81ce, 0x1111d262, 
-	0x2c216eaa, 0x2e5a106f, 0x361214b0, 0x223d66a8, 0x3d77b191, 0x11d3443f, 0x2a650525, 0x2ff1d9c6, 
-	0x3536cc52, 0x238e7673, 0x3d3e82ad, 0x1294062e, 0x2899e64a, 0x317900d6, 0x34534f40, 0x24da0a99, 
-	0x3d02f756, 0x135410c2, 0x26c0b162, 0x32eefde9, 0x3367c08f, 0x261feff9, 0x3cc511d8, 0x14135c94, 
-	0x24da0a99, 0x34534f40, 0x32744493, 0x275ff452, 0x3c84d496, 0x14d1e242, 0x22e69ac7, 0x35a5793c, 
-	0x317900d6, 0x2899e64a, 0x3c424209, 0x158f9a75, 0x20e70f32, 0x36e5068a, 0x30761c17, 0x29cd9577, 
-	0x3bfd5cc4, 0x164c7ddd, 0x1edc1952, 0x3811884c, 0x2f6bbe44, 0x2afad269, 0x3bb6276d, 0x17088530, 
-	0x1cc66e99, 0x392a9642, 0x2e5a106f, 0x2c216eaa, 0x3b6ca4c4, 0x17c3a931, 0x1aa6c82b, 0x3a2fcee8, 
-	0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x2c216eaa, 0x2e5a106f, 
-	0x3ad2c2e7, 0x19372a63, 0x164c7ddd, 0x3bfd5cc4, 0x2afad269, 0x2f6bbe44, 0x3a8269a2, 0x19ef7943, 
-	0x14135c94, 0x3cc511d8, 0x29cd9577, 0x30761c17, 0x3a2fcee8, 0x1aa6c82b, 0x11d3443f, 0x3d77b191, 
-	0x2899e64a, 0x317900d6, 0x39daf5e8, 0x1b5d1009, 0x0f8cfcbd, 0x3e14fdf7, 0x275ff452, 0x32744493, 
-	0x3983e1e7, 0x1c1249d8, 0x0d415012, 0x3e9cc076, 0x261feff9, 0x3367c08f, 0x392a9642, 0x1cc66e99, 
-	0x0af10a22, 0x3f0ec9f4, 0x24da0a99, 0x34534f40, 0x38cf1669, 0x1d79775b, 0x089cf867, 0x3f6af2e3, 
-	0x238e7673, 0x3536cc52, 0x387165e3, 0x1e2b5d38, 0x0645e9af, 0x3fb11b47, 0x223d66a8, 0x361214b0, 
-	0x3811884c, 0x1edc1952, 0x03ecadcf, 0x3fe12acb, 0x20e70f32, 0x36e5068a, 0x37af8158, 0x1f8ba4db, 
-	0x0192155f, 0x3ffb10c1, 0x1f8ba4db, 0x37af8158, 0x374b54ce, 0x2039f90e, 0xff36f171, 0x3ffec42d, 
-	0x1e2b5d38, 0x387165e3, 0x36e5068a, 0x20e70f32, 0xfcdc1342, 0x3fec43c6, 0x1cc66e99, 0x392a9642, 
-	0x367c9a7d, 0x2192e09a, 0xfa824bfe, 0x3fc395f9, 0x1b5d1009, 0x39daf5e8, 0x361214b0, 0x223d66a8, 
-	0xf82a6c6b, 0x3f84c8e1, 0x19ef7943, 0x3a8269a2, 0x35a5793c, 0x22e69ac7, 0xf5d544a8, 0x3f2ff249, 
-	0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673, 0xf383a3e2, 0x3ec52f9f, 0x17088530, 0x3bb6276d, 
-	0x34c61236, 0x2434f332, 0xf136580e, 0x3e44a5ee, 0x158f9a75, 0x3c424209, 0x34534f40, 0x24da0a99, 
-	0xeeee2d9e, 0x3dae81ce, 0x14135c94, 0x3cc511d8, 0x33de87de, 0x257db64b, 0xecabef3e, 0x3d02f756, 
-	0x1294062e, 0x3d3e82ad, 0x3367c08f, 0x261feff9, 0xea70658b, 0x3c424209, 0x1111d262, 0x3dae81ce, 
-	0x32eefde9, 0x26c0b162, 0xe83c56cf, 0x3b6ca4c4, 0x0f8cfcbd, 0x3e14fdf7, 0x32744493, 0x275ff452, 
-	0xe61086bd, 0x3a8269a2, 0x0e05c135, 0x3e71e758, 0x31f79947, 0x27fdb2a6, 0xe3edb628, 0x3983e1e7, 
-	0x0c7c5c1e, 0x3ec52f9f, 0x317900d6, 0x2899e64a, 0xe1d4a2c8, 0x387165e3, 0x0af10a22, 0x3f0ec9f4, 
-	0x30f8801f, 0x29348937, 0xdfc606f2, 0x374b54ce, 0x09640837, 0x3f4eaafe, 0x30761c17, 0x29cd9577, 
-	0xddc29958, 0x361214b0, 0x07d59395, 0x3f84c8e1, 0x2ff1d9c6, 0x2a650525, 0xdbcb0cce, 0x34c61236, 
-	0x0645e9af, 0x3fb11b47, 0x2f6bbe44, 0x2afad269, 0xd9e01007, 0x3367c08f, 0x04b54824, 0x3fd39b5a, 
-	0x2ee3cebe, 0x2b8ef77c, 0xd8024d5a, 0x31f79947, 0x0323ecbe, 0x3fec43c6, 0x2e5a106f, 0x2c216eaa, 
-	0xd6326a89, 0x30761c17, 0x0192155f, 0x3ffb10c1, 0x2dce88a9, 0x2cb2324b, 0xd4710884, 0x2ee3cebe, 
-	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xfe6deaa1, 0x3ffb10c1, 
-	0x2cb2324b, 0x2dce88a9, 0xd11c3142, 0x2b8ef77c, 0xfcdc1342, 0x3fec43c6, 0x2c216eaa, 0x2e5a106f, 
-	0xcf89e3e9, 0x29cd9577, 0xfb4ab7dc, 0x3fd39b5a, 0x2b8ef77c, 0x2ee3cebe, 0xce0866b9, 0x27fdb2a6, 
-	0xf9ba1651, 0x3fb11b47, 0x2afad269, 0x2f6bbe44, 0xcc983f71, 0x261feff9, 0xf82a6c6b, 0x3f84c8e1, 
-	0x2a650525, 0x2ff1d9c6, 0xcb39edca, 0x2434f332, 0xf69bf7c9, 0x3f4eaafe, 0x29cd9577, 0x30761c17, 
-	0xc9edeb50, 0x223d66a8, 0xf50ef5de, 0x3f0ec9f4, 0x29348937, 0x30f8801f, 0xc8b4ab32, 0x2039f90e, 
-	0xf383a3e2, 0x3ec52f9f, 0x2899e64a, 0x317900d6, 0xc78e9a1d, 0x1e2b5d38, 0xf1fa3ecb, 0x3e71e758, 
-	0x27fdb2a6, 0x31f79947, 0xc67c1e19, 0x1c1249d8, 0xf0730343, 0x3e14fdf7, 0x275ff452, 0x32744493, 
-	0xc57d965e, 0x19ef7943, 0xeeee2d9e, 0x3dae81ce, 0x26c0b162, 0x32eefde9, 0xc4935b3c, 0x17c3a931, 
-	0xed6bf9d2, 0x3d3e82ad, 0x261feff9, 0x3367c08f, 0xc3bdbdf7, 0x158f9a75, 0xebeca36c, 0x3cc511d8, 
-	0x257db64b, 0x33de87de, 0xc2fd08aa, 0x135410c2, 0xea70658b, 0x3c424209, 0x24da0a99, 0x34534f40, 
-	0xc2517e32, 0x1111d262, 0xe8f77ad0, 0x3bb6276d, 0x2434f332, 0x34c61236, 0xc1bb5a12, 0x0ec9a7f2, 
-	0xe7821d5a, 0x3b20d79e, 0x238e7673, 0x3536cc52, 0xc13ad061, 0x0c7c5c1e, 0xe61086bd, 0x3a8269a2, 
-	0x22e69ac7, 0x35a5793c, 0xc0d00db7, 0x0a2abb58, 0xe4a2eff7, 0x39daf5e8, 0x223d66a8, 0x361214b0, 
-	0xc07b371f, 0x07d59395, 0xe3399167, 0x392a9642, 0x2192e09a, 0x367c9a7d, 0xc03c6a07, 0x057db402, 
-	0xe1d4a2c8, 0x387165e3, 0x20e70f32, 0x36e5068a, 0xc013bc3a, 0x0323ecbe, 0xe0745b25, 0x37af8158, 
-	0x2039f90e, 0x374b54ce, 0xc0013bd3, 0x00c90e8f, 0xdf18f0ce, 0x36e5068a, 0x1f8ba4db, 0x37af8158, 
-	0xc004ef3f, 0xfe6deaa1, 0xddc29958, 0x361214b0, 0x1edc1952, 0x3811884c, 0xc01ed535, 0xfc135231, 
-	0xdc71898d, 0x3536cc52, 0x1e2b5d38, 0x387165e3, 0xc04ee4b9, 0xf9ba1651, 0xdb25f567, 0x34534f40, 
-	0x1d79775b, 0x38cf1669, 0xc0950d1d, 0xf7630799, 0xd9e01007, 0x3367c08f, 0x1cc66e99, 0x392a9642, 
-	0xc0f1360c, 0xf50ef5de, 0xd8a00bae, 0x32744493, 0x1c1249d8, 0x3983e1e7, 0xc1633f8a, 0xf2beafee, 
-	0xd76619b6, 0x317900d6, 0x1b5d1009, 0x39daf5e8, 0xc1eb0209, 0xf0730343, 0xd6326a89, 0x30761c17, 
-	0x1aa6c82b, 0x3a2fcee8, 0xc2884e6f, 0xee2cbbc1, 0xd5052d97, 0x2f6bbe44, 0x19ef7943, 0x3a8269a2, 
-	0xc33aee28, 0xebeca36c, 0xd3de9156, 0x2e5a106f, 0x19372a63, 0x3ad2c2e7, 0xc402a33c, 0xe9b38223, 
-	0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a, 0xd1a5ef91, 0x2c216eaa, 
-	0x17c3a931, 0x3b6ca4c4, 0xc5d03118, 0xe55937d5, 0xd09441bc, 0x2afad269, 0x17088530, 0x3bb6276d, 
-	0xc6d569be, 0xe3399167, 0xcf89e3e9, 0x29cd9577, 0x164c7ddd, 0x3bfd5cc4, 0xc7ee77b4, 0xe123e6ae, 
-	0xce86ff2a, 0x2899e64a, 0x158f9a75, 0x3c424209, 0xc91af976, 0xdf18f0ce, 0xcd8bbb6d, 0x275ff452, 
-	0x14d1e242, 0x3c84d496, 0xca5a86c4, 0xdd196539, 0xcc983f71, 0x261feff9, 0x14135c94, 0x3cc511d8, 
-	0xcbacb0c0, 0xdb25f567, 0xcbacb0c0, 0x24da0a99, 0x135410c2, 0x3d02f756, 0xcd110217, 0xd93f4e9e, 
-	0xcac933ae, 0x238e7673, 0x1294062e, 0x3d3e82ad, 0xce86ff2a, 0xd76619b6, 0xc9edeb50, 0x223d66a8, 
-	0x11d3443f, 0x3d77b191, 0xd00e263a, 0xd59afadb, 0xc91af976, 0x20e70f32, 0x1111d262, 0x3dae81ce, 
-	0xd1a5ef91, 0xd3de9156, 0xc8507ea8, 0x1f8ba4db, 0x104fb80e, 0x3de2f147, 0xd34dcdb5, 0xd2317757, 
-	0xc78e9a1d, 0x1e2b5d38, 0x0f8cfcbd, 0x3e14fdf7, 0xd5052d97, 0xd09441bc, 0xc6d569be, 0x1cc66e99, 
-	0x0ec9a7f2, 0x3e44a5ee, 0xd6cb76c9, 0xcf077fe1, 0xc6250a18, 0x1b5d1009, 0x0e05c135, 0x3e71e758, 
-	0xd8a00bae, 0xcd8bbb6d, 0xc57d965e, 0x19ef7943, 0x0d415012, 0x3e9cc076, 0xda8249b5, 0xcc217822, 
-	0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f, 0xdc71898d, 0xcac933ae, 0xc449d893, 0x17088530, 
-	0x0bb6ecef, 0x3eeb3347, 0xde6d1f66, 0xc9836583, 0xc3bdbdf7, 0x158f9a75, 0x0af10a22, 0x3f0ec9f4, 
-	0xe0745b25, 0xc8507ea8, 0xc33aee28, 0x14135c94, 0x0a2abb58, 0x3f2ff249, 0xe28688a5, 0xc730e997, 
-	0xc2c17d53, 0x1294062e, 0x09640837, 0x3f4eaafe, 0xe4a2eff7, 0xc6250a18, 0xc2517e32, 0x1111d262, 
-	0x089cf867, 0x3f6af2e3, 0xe6c8d59d, 0xc52d3d19, 0xc1eb0209, 0x0f8cfcbd, 0x07d59395, 0x3f84c8e1, 
-	0xe8f77ad0, 0xc449d893, 0xc18e18a8, 0x0e05c135, 0x070de171, 0x3f9c2bfa, 0xeb2e1dbe, 0xc37b2b6a, 
-	0xc13ad061, 0x0c7c5c1e, 0x0645e9af, 0x3fb11b47, 0xed6bf9d2, 0xc2c17d53, 0xc0f1360c, 0x0af10a22, 
-	0x057db402, 0x3fc395f9, 0xefb047f2, 0xc21d0eb9, 0xc0b15502, 0x09640837, 0x04b54824, 0x3fd39b5a, 
-	0xf1fa3ecb, 0xc18e18a8, 0xc07b371f, 0x07d59395, 0x03ecadcf, 0x3fe12acb, 0xf4491311, 0xc114ccb9, 
-	0xc04ee4b9, 0x0645e9af, 0x0323ecbe, 0x3fec43c6, 0xf69bf7c9, 0xc0b15502, 0xc02c64a6, 0x04b54824, 
-	0x025b0cae, 0x3ff4e5df, 0xf8f21e8f, 0xc063d406, 0xc013bc3a, 0x0323ecbe, 0x0192155f, 0x3ffb10c1, 
-	0xfb4ab7dc, 0xc02c64a6, 0xc004ef3f, 0x0192155f, 0x00c90e8f, 0x3ffec42d, 0xfda4f352, 0xc00b1a21
-};
-
-const int twidTab64[4*6 + 16*6] = {
-	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x2d413ccc, 0x2d413ccc, 
-	0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 
-	0xd2bec334, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a, 
-
-	0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x40000000, 0x00000000, 0x3ec52f9f, 0x0c7c5c1e, 
-	0x3fb11b47, 0x0645e9af, 0x3d3e82ad, 0x1294062e, 0x3b20d79e, 0x187de2a6, 0x3ec52f9f, 0x0c7c5c1e, 
-	0x3536cc52, 0x238e7673, 0x3536cc52, 0x238e7673, 0x3d3e82ad, 0x1294062e, 0x2899e64a, 0x317900d6, 
-	0x2d413ccc, 0x2d413ccc, 0x3b20d79e, 0x187de2a6, 0x187de2a6, 0x3b20d79e, 0x238e7673, 0x3536cc52, 
-	0x387165e3, 0x1e2b5d38, 0x0645e9af, 0x3fb11b47, 0x187de2a6, 0x3b20d79e, 0x3536cc52, 0x238e7673, 
-	0xf383a3e2, 0x3ec52f9f, 0x0c7c5c1e, 0x3ec52f9f, 0x317900d6, 0x2899e64a, 0xe1d4a2c8, 0x387165e3, 
-	0x00000000, 0x40000000, 0x2d413ccc, 0x2d413ccc, 0xd2bec334, 0x2d413ccc, 0xf383a3e2, 0x3ec52f9f, 
-	0x2899e64a, 0x317900d6, 0xc78e9a1d, 0x1e2b5d38, 0xe7821d5a, 0x3b20d79e, 0x238e7673, 0x3536cc52, 
-	0xc13ad061, 0x0c7c5c1e, 0xdc71898d, 0x3536cc52, 0x1e2b5d38, 0x387165e3, 0xc04ee4b9, 0xf9ba1651, 
-	0xd2bec334, 0x2d413ccc, 0x187de2a6, 0x3b20d79e, 0xc4df2862, 0xe7821d5a, 0xcac933ae, 0x238e7673, 
-	0x1294062e, 0x3d3e82ad, 0xce86ff2a, 0xd76619b6, 0xc4df2862, 0x187de2a6, 0x0c7c5c1e, 0x3ec52f9f, 
-	0xdc71898d, 0xcac933ae, 0xc13ad061, 0x0c7c5c1e, 0x0645e9af, 0x3fb11b47, 0xed6bf9d2, 0xc2c17d53 
-};
-#endif  //ARMV5E
-
-const int ShortWindowSine[FRAME_LEN_SHORT/2] ={  
-	0x00c97fff, 0x025b7ffa, 0x03ed7ff1, 0x057f7fe2, 0x07117fce, 0x08a27fb5, 0x0a337f98, 0x0bc47f75, 
-	0x0d547f4e, 0x0ee47f22, 0x10737ef0, 0x12017eba, 0x138f7e7f, 0x151c7e3f, 0x16a87dfb, 0x18337db1, 
-	0x19be7d63, 0x1b477d0f, 0x1cd07cb7, 0x1e577c5a, 0x1fdd7bf9, 0x21627b92, 0x22e57b27, 0x24677ab7, 
-	0x25e87a42, 0x276879c9, 0x28e5794a, 0x2a6278c8, 0x2bdc7840, 0x2d5577b4, 0x2ecc7723, 0x3042768e, 
-	0x31b575f4, 0x33277556, 0x349774b3, 0x3604740b, 0x3770735f, 0x38d972af, 0x3a4071fa, 0x3ba57141, 
-	0x3d087083, 0x3e686fc2, 0x3fc66efb, 0x41216e31, 0x427a6d62, 0x43d16c8f, 0x45246bb8, 0x46756add, 
-	0x47c469fd, 0x490f691a, 0x4a586832, 0x4b9e6747, 0x4ce16657, 0x4e216564, 0x4f5e646c, 0x50986371, 
-	0x51cf6272, 0x5303616f, 0x54336068, 0x55605f5e, 0x568a5e50, 0x57b15d3e, 0x58d45c29, 0x59f45b10
+const int ShortWindowSine[FRAME_LEN_SHORT/2] ={
+	0x00c97fff, 0x025b7ffa, 0x03ed7ff1, 0x057f7fe2, 0x07117fce, 0x08a27fb5, 0x0a337f98, 0x0bc47f75,
+	0x0d547f4e, 0x0ee47f22, 0x10737ef0, 0x12017eba, 0x138f7e7f, 0x151c7e3f, 0x16a87dfb, 0x18337db1,
+	0x19be7d63, 0x1b477d0f, 0x1cd07cb7, 0x1e577c5a, 0x1fdd7bf9, 0x21627b92, 0x22e57b27, 0x24677ab7,
+	0x25e87a42, 0x276879c9, 0x28e5794a, 0x2a6278c8, 0x2bdc7840, 0x2d5577b4, 0x2ecc7723, 0x3042768e,
+	0x31b575f4, 0x33277556, 0x349774b3, 0x3604740b, 0x3770735f, 0x38d972af, 0x3a4071fa, 0x3ba57141,
+	0x3d087083, 0x3e686fc2, 0x3fc66efb, 0x41216e31, 0x427a6d62, 0x43d16c8f, 0x45246bb8, 0x46756add,
+	0x47c469fd, 0x490f691a, 0x4a586832, 0x4b9e6747, 0x4ce16657, 0x4e216564, 0x4f5e646c, 0x50986371,
+	0x51cf6272, 0x5303616f, 0x54336068, 0x55605f5e, 0x568a5e50, 0x57b15d3e, 0x58d45c29, 0x59f45b10
 };
 
-const int LongWindowKBD[FRAME_LEN_LONG/2]={  
-	0x000a7fff, 0x000e7fff, 0x00127fff, 0x00157fff, 0x00197fff, 0x001c7fff, 0x00207fff, 0x00237fff, 
-	0x00267fff, 0x002a7fff, 0x002d7fff, 0x00307fff, 0x00347fff, 0x00387fff, 0x003b7fff, 0x003f7fff, 
-	0x00437fff, 0x00477fff, 0x004b7fff, 0x004f7fff, 0x00537fff, 0x00577fff, 0x005b7fff, 0x00607fff, 
-	0x00647fff, 0x00697fff, 0x006d7fff, 0x00727fff, 0x00777fff, 0x007c7fff, 0x00817fff, 0x00867fff, 
-	0x008b7fff, 0x00917fff, 0x00967fff, 0x009c7fff, 0x00a17fff, 0x00a77fff, 0x00ad7fff, 0x00b37fff, 
-	0x00b97fff, 0x00bf7fff, 0x00c67fff, 0x00cc7fff, 0x00d37fff, 0x00da7fff, 0x00e07fff, 0x00e77fff, 
-	0x00ee7fff, 0x00f57fff, 0x00fd7fff, 0x01047fff, 0x010c7fff, 0x01137fff, 0x011b7fff, 0x01237fff, 
-	0x012b7fff, 0x01337fff, 0x013c7ffe, 0x01447ffe, 0x014d7ffe, 0x01567ffe, 0x015f7ffe, 0x01687ffe, 
-	0x01717ffe, 0x017a7ffe, 0x01837ffe, 0x018d7ffe, 0x01977ffd, 0x01a17ffd, 0x01ab7ffd, 0x01b57ffd, 
-	0x01bf7ffd, 0x01ca7ffd, 0x01d47ffd, 0x01df7ffc, 0x01ea7ffc, 0x01f57ffc, 0x02007ffc, 0x020c7ffc, 
-	0x02177ffc, 0x02237ffb, 0x022f7ffb, 0x023b7ffb, 0x02477ffb, 0x02537ffb, 0x02607ffa, 0x026d7ffa, 
-	0x027a7ffa, 0x02877ffa, 0x02947ff9, 0x02a17ff9, 0x02af7ff9, 0x02bc7ff9, 0x02ca7ff8, 0x02d87ff8, 
-	0x02e77ff8, 0x02f57ff7, 0x03047ff7, 0x03127ff7, 0x03217ff6, 0x03317ff6, 0x03407ff5, 0x034f7ff5, 
-	0x035f7ff5, 0x036f7ff4, 0x037f7ff4, 0x038f7ff3, 0x03a07ff3, 0x03b07ff2, 0x03c17ff2, 0x03d27ff1, 
-	0x03e37ff1, 0x03f57ff0, 0x04067ff0, 0x04187fef, 0x042a7fef, 0x043c7fee, 0x044f7fed, 0x04617fed, 
-	0x04747fec, 0x04877feb, 0x049a7feb, 0x04ae7fea, 0x04c17fe9, 0x04d57fe9, 0x04e97fe8, 0x04fd7fe7, 
-	0x05127fe6, 0x05277fe5, 0x053b7fe5, 0x05507fe4, 0x05667fe3, 0x057b7fe2, 0x05917fe1, 0x05a77fe0, 
-	0x05bd7fdf, 0x05d37fde, 0x05ea7fdd, 0x06017fdc, 0x06187fdb, 0x062f7fda, 0x06467fd9, 0x065e7fd7, 
-	0x06767fd6, 0x068e7fd5, 0x06a67fd4, 0x06bf7fd2, 0x06d87fd1, 0x06f17fd0, 0x070a7fce, 0x07237fcd, 
-	0x073d7fcc, 0x07577fca, 0x07717fc9, 0x078c7fc7, 0x07a67fc5, 0x07c17fc4, 0x07dc7fc2, 0x07f77fc0, 
-	0x08137fbf, 0x082f7fbd, 0x084b7fbb, 0x08677fb9, 0x08847fb7, 0x08a07fb6, 0x08bd7fb4, 0x08da7fb2, 
-	0x08f87faf, 0x09167fad, 0x09347fab, 0x09527fa9, 0x09707fa7, 0x098f7fa5, 0x09ae7fa2, 0x09cd7fa0, 
-	0x09ec7f9d, 0x0a0c7f9b, 0x0a2c7f98, 0x0a4c7f96, 0x0a6c7f93, 0x0a8d7f91, 0x0aae7f8e, 0x0acf7f8b, 
-	0x0af07f88, 0x0b127f85, 0x0b337f82, 0x0b557f7f, 0x0b787f7c, 0x0b9a7f79, 0x0bbd7f76, 0x0be07f73, 
-	0x0c047f6f, 0x0c277f6c, 0x0c4b7f69, 0x0c6f7f65, 0x0c937f61, 0x0cb87f5e, 0x0cdd7f5a, 0x0d027f56, 
-	0x0d277f53, 0x0d4d7f4f, 0x0d737f4b, 0x0d997f47, 0x0dbf7f43, 0x0de67f3e, 0x0e0c7f3a, 0x0e347f36, 
-	0x0e5b7f31, 0x0e837f2d, 0x0eaa7f28, 0x0ed37f24, 0x0efb7f1f, 0x0f237f1a, 0x0f4c7f15, 0x0f757f10, 
-	0x0f9f7f0b, 0x0fc87f06, 0x0ff27f01, 0x101c7efb, 0x10477ef6, 0x10717ef0, 0x109c7eeb, 0x10c87ee5, 
-	0x10f37edf, 0x111f7eda, 0x114a7ed4, 0x11777ece, 0x11a37ec7, 0x11d07ec1, 0x11fd7ebb, 0x122a7eb4, 
-	0x12577eae, 0x12857ea7, 0x12b37ea0, 0x12e17e9a, 0x130f7e93, 0x133e7e8c, 0x136d7e84, 0x139c7e7d, 
-	0x13cc7e76, 0x13fb7e6e, 0x142b7e67, 0x145b7e5f, 0x148c7e57, 0x14bc7e4f, 0x14ed7e47, 0x151e7e3f, 
-	0x15507e37, 0x15817e2e, 0x15b37e26, 0x15e57e1d, 0x16187e14, 0x164a7e0b, 0x167d7e02, 0x16b07df9, 
-	0x16e47df0, 0x17177de6, 0x174b7ddd, 0x177f7dd3, 0x17b37dc9, 0x17e87dbf, 0x181d7db5, 0x18527dab, 
-	0x18877da1, 0x18bc7d96, 0x18f27d8c, 0x19287d81, 0x195e7d76, 0x19957d6b, 0x19cb7d60, 0x1a027d54, 
-	0x1a397d49, 0x1a717d3d, 0x1aa87d31, 0x1ae07d26, 0x1b187d19, 0x1b507d0d, 0x1b897d01, 0x1bc27cf4, 
-	0x1bfb7ce8, 0x1c347cdb, 0x1c6d7cce, 0x1ca77cc1, 0x1ce17cb3, 0x1d1b7ca6, 0x1d557c98, 0x1d8f7c8a, 
-	0x1dca7c7c, 0x1e057c6e, 0x1e407c60, 0x1e7b7c51, 0x1eb77c43, 0x1ef37c34, 0x1f2f7c25, 0x1f6b7c16, 
-	0x1fa77c06, 0x1fe47bf7, 0x20217be7, 0x205e7bd7, 0x209b7bc7, 0x20d87bb7, 0x21167ba6, 0x21547b96, 
-	0x21927b85, 0x21d07b74, 0x220e7b63, 0x224d7b52, 0x228c7b40, 0x22cb7b2e, 0x230a7b1c, 0x23497b0a, 
-	0x23897af8, 0x23c87ae6, 0x24087ad3, 0x24487ac0, 0x24897aad, 0x24c97a9a, 0x250a7a86, 0x254b7a73, 
-	0x258c7a5f, 0x25cd7a4b, 0x260e7a36, 0x26507a22, 0x26917a0d, 0x26d379f8, 0x271579e3, 0x275779ce, 
-	0x279a79b8, 0x27dc79a3, 0x281f798d, 0x28627977, 0x28a57960, 0x28e8794a, 0x292b7933, 0x296f791c, 
-	0x29b27905, 0x29f678ed, 0x2a3a78d6, 0x2a7e78be, 0x2ac278a6, 0x2b07788d, 0x2b4b7875, 0x2b90785c, 
-	0x2bd47843, 0x2c19782a, 0x2c5e7810, 0x2ca477f7, 0x2ce977dd, 0x2d2e77c3, 0x2d7477a8, 0x2dba778e, 
-	0x2dff7773, 0x2e457758, 0x2e8b773d, 0x2ed27721, 0x2f187706, 0x2f5e76ea, 0x2fa576cd, 0x2fec76b1, 
-	0x30327694, 0x30797677, 0x30c0765a, 0x3107763d, 0x314e761f, 0x31967601, 0x31dd75e3, 0x322575c5, 
-	0x326c75a6, 0x32b47588, 0x32fc7569, 0x33447549, 0x338c752a, 0x33d4750a, 0x341c74ea, 0x346474ca, 
-	0x34ac74a9, 0x34f57488, 0x353d7467, 0x35857446, 0x35ce7424, 0x36177403, 0x365f73e1, 0x36a873be, 
-	0x36f1739c, 0x373a7379, 0x37837356, 0x37cc7333, 0x3815730f, 0x385e72ec, 0x38a772c8, 0x38f172a3, 
-	0x393a727f, 0x3983725a, 0x39cd7235, 0x3a167210, 0x3a6071ea, 0x3aa971c4, 0x3af3719e, 0x3b3c7178, 
-	0x3b867151, 0x3bd0712b, 0x3c197104, 0x3c6370dc, 0x3cad70b5, 0x3cf7708d, 0x3d407065, 0x3d8a703c, 
-	0x3dd47014, 0x3e1e6feb, 0x3e686fc2, 0x3eb16f98, 0x3efb6f6f, 0x3f456f45, 0x3f8f6f1b, 0x3fd96ef0, 
-	0x40236ec6, 0x406d6e9b, 0x40b66e70, 0x41006e44, 0x414a6e19, 0x41946ded, 0x41de6dc1, 0x42286d94, 
-	0x42716d68, 0x42bb6d3b, 0x43056d0d, 0x434f6ce0, 0x43986cb2, 0x43e26c84, 0x442c6c56, 0x44756c28, 
-	0x44bf6bf9, 0x45086bca, 0x45526b9b, 0x459b6b6b, 0x45e56b3c, 0x462e6b0c, 0x46786adb, 0x46c16aab, 
-	0x470a6a7a, 0x47536a49, 0x479c6a18, 0x47e569e7, 0x482e69b5, 0x48776983, 0x48c06951, 0x4909691e, 
-	0x495268ec, 0x499b68b9, 0x49e36885, 0x4a2c6852, 0x4a74681e, 0x4abd67ea, 0x4b0567b6, 0x4b4d6782, 
-	0x4b95674d, 0x4bde6718, 0x4c2666e3, 0x4c6d66ae, 0x4cb56678, 0x4cfd6642, 0x4d45660c, 0x4d8c65d6, 
-	0x4dd4659f, 0x4e1b6568, 0x4e626531, 0x4ea964fa, 0x4ef064c3, 0x4f37648b, 0x4f7e6453, 0x4fc5641b, 
-	0x500b63e2, 0x505263aa, 0x50986371, 0x50df6338, 0x512562fe, 0x516b62c5, 0x51b1628b, 0x51f66251, 
-	0x523c6217, 0x528161dc, 0x52c761a2, 0x530c6167, 0x5351612c, 0x539660f1, 0x53db60b5, 0x54206079, 
-	0x5464603d, 0x54a96001, 0x54ed5fc5, 0x55315f88, 0x55755f4b, 0x55b95f0e, 0x55fc5ed1, 0x56405e94, 
-	0x56835e56, 0x56c75e18, 0x570a5dda, 0x574d5d9c, 0x578f5d5e, 0x57d25d1f, 0x58145ce0, 0x58565ca1, 
+const int LongWindowKBD[FRAME_LEN_LONG/2]={
+	0x000a7fff, 0x000e7fff, 0x00127fff, 0x00157fff, 0x00197fff, 0x001c7fff, 0x00207fff, 0x00237fff,
+	0x00267fff, 0x002a7fff, 0x002d7fff, 0x00307fff, 0x00347fff, 0x00387fff, 0x003b7fff, 0x003f7fff,
+	0x00437fff, 0x00477fff, 0x004b7fff, 0x004f7fff, 0x00537fff, 0x00577fff, 0x005b7fff, 0x00607fff,
+	0x00647fff, 0x00697fff, 0x006d7fff, 0x00727fff, 0x00777fff, 0x007c7fff, 0x00817fff, 0x00867fff,
+	0x008b7fff, 0x00917fff, 0x00967fff, 0x009c7fff, 0x00a17fff, 0x00a77fff, 0x00ad7fff, 0x00b37fff,
+	0x00b97fff, 0x00bf7fff, 0x00c67fff, 0x00cc7fff, 0x00d37fff, 0x00da7fff, 0x00e07fff, 0x00e77fff,
+	0x00ee7fff, 0x00f57fff, 0x00fd7fff, 0x01047fff, 0x010c7fff, 0x01137fff, 0x011b7fff, 0x01237fff,
+	0x012b7fff, 0x01337fff, 0x013c7ffe, 0x01447ffe, 0x014d7ffe, 0x01567ffe, 0x015f7ffe, 0x01687ffe,
+	0x01717ffe, 0x017a7ffe, 0x01837ffe, 0x018d7ffe, 0x01977ffd, 0x01a17ffd, 0x01ab7ffd, 0x01b57ffd,
+	0x01bf7ffd, 0x01ca7ffd, 0x01d47ffd, 0x01df7ffc, 0x01ea7ffc, 0x01f57ffc, 0x02007ffc, 0x020c7ffc,
+	0x02177ffc, 0x02237ffb, 0x022f7ffb, 0x023b7ffb, 0x02477ffb, 0x02537ffb, 0x02607ffa, 0x026d7ffa,
+	0x027a7ffa, 0x02877ffa, 0x02947ff9, 0x02a17ff9, 0x02af7ff9, 0x02bc7ff9, 0x02ca7ff8, 0x02d87ff8,
+	0x02e77ff8, 0x02f57ff7, 0x03047ff7, 0x03127ff7, 0x03217ff6, 0x03317ff6, 0x03407ff5, 0x034f7ff5,
+	0x035f7ff5, 0x036f7ff4, 0x037f7ff4, 0x038f7ff3, 0x03a07ff3, 0x03b07ff2, 0x03c17ff2, 0x03d27ff1,
+	0x03e37ff1, 0x03f57ff0, 0x04067ff0, 0x04187fef, 0x042a7fef, 0x043c7fee, 0x044f7fed, 0x04617fed,
+	0x04747fec, 0x04877feb, 0x049a7feb, 0x04ae7fea, 0x04c17fe9, 0x04d57fe9, 0x04e97fe8, 0x04fd7fe7,
+	0x05127fe6, 0x05277fe5, 0x053b7fe5, 0x05507fe4, 0x05667fe3, 0x057b7fe2, 0x05917fe1, 0x05a77fe0,
+	0x05bd7fdf, 0x05d37fde, 0x05ea7fdd, 0x06017fdc, 0x06187fdb, 0x062f7fda, 0x06467fd9, 0x065e7fd7,
+	0x06767fd6, 0x068e7fd5, 0x06a67fd4, 0x06bf7fd2, 0x06d87fd1, 0x06f17fd0, 0x070a7fce, 0x07237fcd,
+	0x073d7fcc, 0x07577fca, 0x07717fc9, 0x078c7fc7, 0x07a67fc5, 0x07c17fc4, 0x07dc7fc2, 0x07f77fc0,
+	0x08137fbf, 0x082f7fbd, 0x084b7fbb, 0x08677fb9, 0x08847fb7, 0x08a07fb6, 0x08bd7fb4, 0x08da7fb2,
+	0x08f87faf, 0x09167fad, 0x09347fab, 0x09527fa9, 0x09707fa7, 0x098f7fa5, 0x09ae7fa2, 0x09cd7fa0,
+	0x09ec7f9d, 0x0a0c7f9b, 0x0a2c7f98, 0x0a4c7f96, 0x0a6c7f93, 0x0a8d7f91, 0x0aae7f8e, 0x0acf7f8b,
+	0x0af07f88, 0x0b127f85, 0x0b337f82, 0x0b557f7f, 0x0b787f7c, 0x0b9a7f79, 0x0bbd7f76, 0x0be07f73,
+	0x0c047f6f, 0x0c277f6c, 0x0c4b7f69, 0x0c6f7f65, 0x0c937f61, 0x0cb87f5e, 0x0cdd7f5a, 0x0d027f56,
+	0x0d277f53, 0x0d4d7f4f, 0x0d737f4b, 0x0d997f47, 0x0dbf7f43, 0x0de67f3e, 0x0e0c7f3a, 0x0e347f36,
+	0x0e5b7f31, 0x0e837f2d, 0x0eaa7f28, 0x0ed37f24, 0x0efb7f1f, 0x0f237f1a, 0x0f4c7f15, 0x0f757f10,
+	0x0f9f7f0b, 0x0fc87f06, 0x0ff27f01, 0x101c7efb, 0x10477ef6, 0x10717ef0, 0x109c7eeb, 0x10c87ee5,
+	0x10f37edf, 0x111f7eda, 0x114a7ed4, 0x11777ece, 0x11a37ec7, 0x11d07ec1, 0x11fd7ebb, 0x122a7eb4,
+	0x12577eae, 0x12857ea7, 0x12b37ea0, 0x12e17e9a, 0x130f7e93, 0x133e7e8c, 0x136d7e84, 0x139c7e7d,
+	0x13cc7e76, 0x13fb7e6e, 0x142b7e67, 0x145b7e5f, 0x148c7e57, 0x14bc7e4f, 0x14ed7e47, 0x151e7e3f,
+	0x15507e37, 0x15817e2e, 0x15b37e26, 0x15e57e1d, 0x16187e14, 0x164a7e0b, 0x167d7e02, 0x16b07df9,
+	0x16e47df0, 0x17177de6, 0x174b7ddd, 0x177f7dd3, 0x17b37dc9, 0x17e87dbf, 0x181d7db5, 0x18527dab,
+	0x18877da1, 0x18bc7d96, 0x18f27d8c, 0x19287d81, 0x195e7d76, 0x19957d6b, 0x19cb7d60, 0x1a027d54,
+	0x1a397d49, 0x1a717d3d, 0x1aa87d31, 0x1ae07d26, 0x1b187d19, 0x1b507d0d, 0x1b897d01, 0x1bc27cf4,
+	0x1bfb7ce8, 0x1c347cdb, 0x1c6d7cce, 0x1ca77cc1, 0x1ce17cb3, 0x1d1b7ca6, 0x1d557c98, 0x1d8f7c8a,
+	0x1dca7c7c, 0x1e057c6e, 0x1e407c60, 0x1e7b7c51, 0x1eb77c43, 0x1ef37c34, 0x1f2f7c25, 0x1f6b7c16,
+	0x1fa77c06, 0x1fe47bf7, 0x20217be7, 0x205e7bd7, 0x209b7bc7, 0x20d87bb7, 0x21167ba6, 0x21547b96,
+	0x21927b85, 0x21d07b74, 0x220e7b63, 0x224d7b52, 0x228c7b40, 0x22cb7b2e, 0x230a7b1c, 0x23497b0a,
+	0x23897af8, 0x23c87ae6, 0x24087ad3, 0x24487ac0, 0x24897aad, 0x24c97a9a, 0x250a7a86, 0x254b7a73,
+	0x258c7a5f, 0x25cd7a4b, 0x260e7a36, 0x26507a22, 0x26917a0d, 0x26d379f8, 0x271579e3, 0x275779ce,
+	0x279a79b8, 0x27dc79a3, 0x281f798d, 0x28627977, 0x28a57960, 0x28e8794a, 0x292b7933, 0x296f791c,
+	0x29b27905, 0x29f678ed, 0x2a3a78d6, 0x2a7e78be, 0x2ac278a6, 0x2b07788d, 0x2b4b7875, 0x2b90785c,
+	0x2bd47843, 0x2c19782a, 0x2c5e7810, 0x2ca477f7, 0x2ce977dd, 0x2d2e77c3, 0x2d7477a8, 0x2dba778e,
+	0x2dff7773, 0x2e457758, 0x2e8b773d, 0x2ed27721, 0x2f187706, 0x2f5e76ea, 0x2fa576cd, 0x2fec76b1,
+	0x30327694, 0x30797677, 0x30c0765a, 0x3107763d, 0x314e761f, 0x31967601, 0x31dd75e3, 0x322575c5,
+	0x326c75a6, 0x32b47588, 0x32fc7569, 0x33447549, 0x338c752a, 0x33d4750a, 0x341c74ea, 0x346474ca,
+	0x34ac74a9, 0x34f57488, 0x353d7467, 0x35857446, 0x35ce7424, 0x36177403, 0x365f73e1, 0x36a873be,
+	0x36f1739c, 0x373a7379, 0x37837356, 0x37cc7333, 0x3815730f, 0x385e72ec, 0x38a772c8, 0x38f172a3,
+	0x393a727f, 0x3983725a, 0x39cd7235, 0x3a167210, 0x3a6071ea, 0x3aa971c4, 0x3af3719e, 0x3b3c7178,
+	0x3b867151, 0x3bd0712b, 0x3c197104, 0x3c6370dc, 0x3cad70b5, 0x3cf7708d, 0x3d407065, 0x3d8a703c,
+	0x3dd47014, 0x3e1e6feb, 0x3e686fc2, 0x3eb16f98, 0x3efb6f6f, 0x3f456f45, 0x3f8f6f1b, 0x3fd96ef0,
+	0x40236ec6, 0x406d6e9b, 0x40b66e70, 0x41006e44, 0x414a6e19, 0x41946ded, 0x41de6dc1, 0x42286d94,
+	0x42716d68, 0x42bb6d3b, 0x43056d0d, 0x434f6ce0, 0x43986cb2, 0x43e26c84, 0x442c6c56, 0x44756c28,
+	0x44bf6bf9, 0x45086bca, 0x45526b9b, 0x459b6b6b, 0x45e56b3c, 0x462e6b0c, 0x46786adb, 0x46c16aab,
+	0x470a6a7a, 0x47536a49, 0x479c6a18, 0x47e569e7, 0x482e69b5, 0x48776983, 0x48c06951, 0x4909691e,
+	0x495268ec, 0x499b68b9, 0x49e36885, 0x4a2c6852, 0x4a74681e, 0x4abd67ea, 0x4b0567b6, 0x4b4d6782,
+	0x4b95674d, 0x4bde6718, 0x4c2666e3, 0x4c6d66ae, 0x4cb56678, 0x4cfd6642, 0x4d45660c, 0x4d8c65d6,
+	0x4dd4659f, 0x4e1b6568, 0x4e626531, 0x4ea964fa, 0x4ef064c3, 0x4f37648b, 0x4f7e6453, 0x4fc5641b,
+	0x500b63e2, 0x505263aa, 0x50986371, 0x50df6338, 0x512562fe, 0x516b62c5, 0x51b1628b, 0x51f66251,
+	0x523c6217, 0x528161dc, 0x52c761a2, 0x530c6167, 0x5351612c, 0x539660f1, 0x53db60b5, 0x54206079,
+	0x5464603d, 0x54a96001, 0x54ed5fc5, 0x55315f88, 0x55755f4b, 0x55b95f0e, 0x55fc5ed1, 0x56405e94,
+	0x56835e56, 0x56c75e18, 0x570a5dda, 0x574d5d9c, 0x578f5d5e, 0x57d25d1f, 0x58145ce0, 0x58565ca1,
 	0x58995c62, 0x58da5c23, 0x591c5be3, 0x595e5ba4, 0x599f5b64, 0x59e05b24, 0x5a215ae3, 0x5a625aa3
 };
 
@@ -1070,279 +1070,279 @@ const Word32 formfac_sqrttable[96] = {
 
   \brief   these tables are used for the non
            linear quantizer and inverse quantizer
-           
+
 */
 const Word32 mTab_3_4[512] = {
-	0x4c1bf829, 0x4c3880de, 0x4c550603, 0x4c71879c, 
-	0x4c8e05aa, 0x4caa8030, 0x4cc6f72f, 0x4ce36aab, 
-	0x4cffdaa4, 0x4d1c471d, 0x4d38b019, 0x4d55159a, 
-	0x4d7177a1, 0x4d8dd631, 0x4daa314b, 0x4dc688f3, 
-	0x4de2dd2a, 0x4dff2df2, 0x4e1b7b4d, 0x4e37c53d, 
-	0x4e540bc5, 0x4e704ee6, 0x4e8c8ea3, 0x4ea8cafd, 
-	0x4ec503f7, 0x4ee13992, 0x4efd6bd0, 0x4f199ab4, 
-	0x4f35c640, 0x4f51ee75, 0x4f6e1356, 0x4f8a34e4, 
-	0x4fa65321, 0x4fc26e10, 0x4fde85b2, 0x4ffa9a0a, 
-	0x5016ab18, 0x5032b8e0, 0x504ec362, 0x506acaa1, 
-	0x5086cea0, 0x50a2cf5e, 0x50becce0, 0x50dac725, 
-	0x50f6be31, 0x5112b205, 0x512ea2a3, 0x514a900d, 
-	0x51667a45, 0x5182614c, 0x519e4524, 0x51ba25cf, 
-	0x51d60350, 0x51f1dda7, 0x520db4d6, 0x522988e0, 
-	0x524559c6, 0x52612789, 0x527cf22d, 0x5298b9b1, 
-	0x52b47e19, 0x52d03f65, 0x52ebfd98, 0x5307b8b4, 
-	0x532370b9, 0x533f25aa, 0x535ad789, 0x53768656, 
-	0x53923215, 0x53addac6, 0x53c9806b, 0x53e52306, 
-	0x5400c298, 0x541c5f24, 0x5437f8ab, 0x54538f2e, 
-	0x546f22af, 0x548ab330, 0x54a640b3, 0x54c1cb38, 
-	0x54dd52c2, 0x54f8d753, 0x551458eb, 0x552fd78d, 
-	0x554b5339, 0x5566cbf3, 0x558241bb, 0x559db492, 
-	0x55b9247b, 0x55d49177, 0x55effb87, 0x560b62ad, 
-	0x5626c6eb, 0x56422842, 0x565d86b4, 0x5678e242, 
-	0x56943aee, 0x56af90b9, 0x56cae3a4, 0x56e633b2, 
-	0x570180e4, 0x571ccb3b, 0x573812b8, 0x5753575e, 
-	0x576e992e, 0x5789d829, 0x57a51450, 0x57c04da6, 
-	0x57db842b, 0x57f6b7e1, 0x5811e8c9, 0x582d16e6, 
-	0x58484238, 0x58636ac0, 0x587e9081, 0x5899b37c, 
-	0x58b4d3b1, 0x58cff123, 0x58eb0bd3, 0x590623c2, 
-	0x592138f2, 0x593c4b63, 0x59575b19, 0x59726812, 
-	0x598d7253, 0x59a879da, 0x59c37eab, 0x59de80c6, 
-	0x59f9802d, 0x5a147ce0, 0x5a2f76e2, 0x5a4a6e34, 
-	0x5a6562d6, 0x5a8054cb, 0x5a9b4414, 0x5ab630b2, 
-	0x5ad11aa6, 0x5aec01f1, 0x5b06e696, 0x5b21c895, 
-	0x5b3ca7ef, 0x5b5784a6, 0x5b725ebc, 0x5b8d3631, 
-	0x5ba80b06, 0x5bc2dd3e, 0x5bddacd9, 0x5bf879d8, 
-	0x5c13443d, 0x5c2e0c09, 0x5c48d13e, 0x5c6393dc, 
-	0x5c7e53e5, 0x5c99115a, 0x5cb3cc3c, 0x5cce848d, 
-	0x5ce93a4e, 0x5d03ed80, 0x5d1e9e24, 0x5d394c3b, 
-	0x5d53f7c7, 0x5d6ea0c9, 0x5d894742, 0x5da3eb33, 
-	0x5dbe8c9e, 0x5dd92b84, 0x5df3c7e5, 0x5e0e61c3, 
-	0x5e28f920, 0x5e438dfc, 0x5e5e2059, 0x5e78b037, 
-	0x5e933d99, 0x5eadc87e, 0x5ec850e9, 0x5ee2d6da, 
-	0x5efd5a53, 0x5f17db54, 0x5f3259e0, 0x5f4cd5f6, 
-	0x5f674f99, 0x5f81c6c8, 0x5f9c3b87, 0x5fb6add4, 
-	0x5fd11db3, 0x5feb8b23, 0x6005f626, 0x60205ebd, 
-	0x603ac4e9, 0x605528ac, 0x606f8a05, 0x6089e8f7, 
-	0x60a44583, 0x60be9fa9, 0x60d8f76b, 0x60f34cca, 
-	0x610d9fc7, 0x6127f062, 0x61423e9e, 0x615c8a7a, 
-	0x6176d3f9, 0x61911b1b, 0x61ab5fe1, 0x61c5a24d, 
-	0x61dfe25f, 0x61fa2018, 0x62145b7a, 0x622e9485, 
-	0x6248cb3b, 0x6262ff9d, 0x627d31ab, 0x62976167, 
-	0x62b18ed1, 0x62cbb9eb, 0x62e5e2b6, 0x63000933, 
-	0x631a2d62, 0x63344f45, 0x634e6edd, 0x63688c2b, 
-	0x6382a730, 0x639cbfec, 0x63b6d661, 0x63d0ea90, 
-	0x63eafc7a, 0x64050c1f, 0x641f1982, 0x643924a2, 
-	0x64532d80, 0x646d341f, 0x6487387e, 0x64a13a9e, 
-	0x64bb3a81, 0x64d53828, 0x64ef3393, 0x65092cc4, 
-	0x652323bb, 0x653d1879, 0x65570b00, 0x6570fb50, 
-	0x658ae96b, 0x65a4d550, 0x65bebf01, 0x65d8a680, 
-	0x65f28bcc, 0x660c6ee8, 0x66264fd3, 0x66402e8f, 
-	0x665a0b1c, 0x6673e57d, 0x668dbdb0, 0x66a793b8, 
-	0x66c16795, 0x66db3949, 0x66f508d4, 0x670ed636, 
-	0x6728a172, 0x67426a87, 0x675c3177, 0x6775f643, 
-	0x678fb8eb, 0x67a97971, 0x67c337d5, 0x67dcf418, 
-	0x67f6ae3b, 0x6810663f, 0x682a1c25, 0x6843cfed, 
-	0x685d8199, 0x68773129, 0x6890de9f, 0x68aa89fa, 
-	0x68c4333d, 0x68ddda67, 0x68f77f7a, 0x69112277, 
-	0x692ac35e, 0x69446230, 0x695dfeee, 0x6977999a, 
-	0x69913232, 0x69aac8ba, 0x69c45d31, 0x69ddef98, 
-	0x69f77ff0, 0x6a110e3a, 0x6a2a9a77, 0x6a4424a8, 
-	0x6a5daccc, 0x6a7732e6, 0x6a90b6f6, 0x6aaa38fd, 
-	0x6ac3b8fb, 0x6add36f2, 0x6af6b2e2, 0x6b102ccd, 
-	0x6b29a4b2, 0x6b431a92, 0x6b5c8e6f, 0x6b76004a, 
-	0x6b8f7022, 0x6ba8ddf9, 0x6bc249d0, 0x6bdbb3a7, 
-	0x6bf51b80, 0x6c0e815a, 0x6c27e537, 0x6c414718, 
-	0x6c5aa6fd, 0x6c7404e7, 0x6c8d60d7, 0x6ca6bace, 
-	0x6cc012cc, 0x6cd968d2, 0x6cf2bce1, 0x6d0c0ef9, 
-	0x6d255f1d, 0x6d3ead4b, 0x6d57f985, 0x6d7143cc, 
-	0x6d8a8c21, 0x6da3d283, 0x6dbd16f5, 0x6dd65976, 
-	0x6def9a08, 0x6e08d8ab, 0x6e221560, 0x6e3b5027, 
-	0x6e548902, 0x6e6dbff1, 0x6e86f4f5, 0x6ea0280e, 
-	0x6eb9593e, 0x6ed28885, 0x6eebb5e3, 0x6f04e15a, 
-	0x6f1e0aea, 0x6f373294, 0x6f505859, 0x6f697c39, 
-	0x6f829e35, 0x6f9bbe4e, 0x6fb4dc85, 0x6fcdf8d9, 
-	0x6fe7134d, 0x70002be0, 0x70194293, 0x70325767, 
-	0x704b6a5d, 0x70647b76, 0x707d8ab1, 0x70969811, 
-	0x70afa394, 0x70c8ad3d, 0x70e1b50c, 0x70fabb01, 
-	0x7113bf1d, 0x712cc161, 0x7145c1ce, 0x715ec064, 
-	0x7177bd24, 0x7190b80f, 0x71a9b124, 0x71c2a866, 
-	0x71db9dd4, 0x71f49170, 0x720d8339, 0x72267331, 
-	0x723f6159, 0x72584db0, 0x72713838, 0x728a20f1, 
-	0x72a307db, 0x72bbecf9, 0x72d4d049, 0x72edb1ce, 
-	0x73069187, 0x731f6f75, 0x73384b98, 0x735125f3, 
-	0x7369fe84, 0x7382d54d, 0x739baa4e, 0x73b47d89, 
-	0x73cd4efd, 0x73e61eab, 0x73feec94, 0x7417b8b8, 
-	0x74308319, 0x74494bb6, 0x74621291, 0x747ad7aa, 
-	0x74939b02, 0x74ac5c98, 0x74c51c6f, 0x74ddda86, 
-	0x74f696de, 0x750f5178, 0x75280a54, 0x7540c174, 
-	0x755976d7, 0x75722a7e, 0x758adc69, 0x75a38c9b, 
-	0x75bc3b12, 0x75d4e7cf, 0x75ed92d4, 0x76063c21, 
-	0x761ee3b6, 0x76378994, 0x76502dbc, 0x7668d02e, 
-	0x768170eb, 0x769a0ff3, 0x76b2ad47, 0x76cb48e7, 
-	0x76e3e2d5, 0x76fc7b10, 0x7715119a, 0x772da673, 
-	0x7746399b, 0x775ecb13, 0x77775adc, 0x778fe8f6, 
-	0x77a87561, 0x77c1001f, 0x77d98930, 0x77f21095, 
-	0x780a964d, 0x78231a5b, 0x783b9cbd, 0x78541d75, 
-	0x786c9c84, 0x788519e9, 0x789d95a6, 0x78b60fbb, 
-	0x78ce8828, 0x78e6feef, 0x78ff740f, 0x7917e78a, 
-	0x7930595f, 0x7948c990, 0x7961381d, 0x7979a506, 
-	0x7992104c, 0x79aa79f0, 0x79c2e1f1, 0x79db4852, 
-	0x79f3ad11, 0x7a0c1031, 0x7a2471b0, 0x7a3cd191, 
-	0x7a552fd3, 0x7a6d8c76, 0x7a85e77d, 0x7a9e40e6, 
-	0x7ab698b2, 0x7aceeee3, 0x7ae74378, 0x7aff9673, 
-	0x7b17e7d2, 0x7b303799, 0x7b4885c5, 0x7b60d259, 
-	0x7b791d55, 0x7b9166b9, 0x7ba9ae86, 0x7bc1f4bc, 
-	0x7bda395c, 0x7bf27c66, 0x7c0abddb, 0x7c22fdbb, 
-	0x7c3b3c07, 0x7c5378c0, 0x7c6bb3e5, 0x7c83ed78, 
-	0x7c9c2579, 0x7cb45be9, 0x7ccc90c7, 0x7ce4c414, 
-	0x7cfcf5d2, 0x7d152600, 0x7d2d549f, 0x7d4581b0, 
-	0x7d5dad32, 0x7d75d727, 0x7d8dff8f, 0x7da6266a, 
-	0x7dbe4bba, 0x7dd66f7d, 0x7dee91b6, 0x7e06b264, 
-	0x7e1ed188, 0x7e36ef22, 0x7e4f0b34, 0x7e6725bd, 
-	0x7e7f3ebd, 0x7e975636, 0x7eaf6c28, 0x7ec78093, 
-	0x7edf9378, 0x7ef7a4d7, 0x7f0fb4b1, 0x7f27c307, 
-	0x7f3fcfd8, 0x7f57db25, 0x7f6fe4ef, 0x7f87ed36, 
+	0x4c1bf829, 0x4c3880de, 0x4c550603, 0x4c71879c,
+	0x4c8e05aa, 0x4caa8030, 0x4cc6f72f, 0x4ce36aab,
+	0x4cffdaa4, 0x4d1c471d, 0x4d38b019, 0x4d55159a,
+	0x4d7177a1, 0x4d8dd631, 0x4daa314b, 0x4dc688f3,
+	0x4de2dd2a, 0x4dff2df2, 0x4e1b7b4d, 0x4e37c53d,
+	0x4e540bc5, 0x4e704ee6, 0x4e8c8ea3, 0x4ea8cafd,
+	0x4ec503f7, 0x4ee13992, 0x4efd6bd0, 0x4f199ab4,
+	0x4f35c640, 0x4f51ee75, 0x4f6e1356, 0x4f8a34e4,
+	0x4fa65321, 0x4fc26e10, 0x4fde85b2, 0x4ffa9a0a,
+	0x5016ab18, 0x5032b8e0, 0x504ec362, 0x506acaa1,
+	0x5086cea0, 0x50a2cf5e, 0x50becce0, 0x50dac725,
+	0x50f6be31, 0x5112b205, 0x512ea2a3, 0x514a900d,
+	0x51667a45, 0x5182614c, 0x519e4524, 0x51ba25cf,
+	0x51d60350, 0x51f1dda7, 0x520db4d6, 0x522988e0,
+	0x524559c6, 0x52612789, 0x527cf22d, 0x5298b9b1,
+	0x52b47e19, 0x52d03f65, 0x52ebfd98, 0x5307b8b4,
+	0x532370b9, 0x533f25aa, 0x535ad789, 0x53768656,
+	0x53923215, 0x53addac6, 0x53c9806b, 0x53e52306,
+	0x5400c298, 0x541c5f24, 0x5437f8ab, 0x54538f2e,
+	0x546f22af, 0x548ab330, 0x54a640b3, 0x54c1cb38,
+	0x54dd52c2, 0x54f8d753, 0x551458eb, 0x552fd78d,
+	0x554b5339, 0x5566cbf3, 0x558241bb, 0x559db492,
+	0x55b9247b, 0x55d49177, 0x55effb87, 0x560b62ad,
+	0x5626c6eb, 0x56422842, 0x565d86b4, 0x5678e242,
+	0x56943aee, 0x56af90b9, 0x56cae3a4, 0x56e633b2,
+	0x570180e4, 0x571ccb3b, 0x573812b8, 0x5753575e,
+	0x576e992e, 0x5789d829, 0x57a51450, 0x57c04da6,
+	0x57db842b, 0x57f6b7e1, 0x5811e8c9, 0x582d16e6,
+	0x58484238, 0x58636ac0, 0x587e9081, 0x5899b37c,
+	0x58b4d3b1, 0x58cff123, 0x58eb0bd3, 0x590623c2,
+	0x592138f2, 0x593c4b63, 0x59575b19, 0x59726812,
+	0x598d7253, 0x59a879da, 0x59c37eab, 0x59de80c6,
+	0x59f9802d, 0x5a147ce0, 0x5a2f76e2, 0x5a4a6e34,
+	0x5a6562d6, 0x5a8054cb, 0x5a9b4414, 0x5ab630b2,
+	0x5ad11aa6, 0x5aec01f1, 0x5b06e696, 0x5b21c895,
+	0x5b3ca7ef, 0x5b5784a6, 0x5b725ebc, 0x5b8d3631,
+	0x5ba80b06, 0x5bc2dd3e, 0x5bddacd9, 0x5bf879d8,
+	0x5c13443d, 0x5c2e0c09, 0x5c48d13e, 0x5c6393dc,
+	0x5c7e53e5, 0x5c99115a, 0x5cb3cc3c, 0x5cce848d,
+	0x5ce93a4e, 0x5d03ed80, 0x5d1e9e24, 0x5d394c3b,
+	0x5d53f7c7, 0x5d6ea0c9, 0x5d894742, 0x5da3eb33,
+	0x5dbe8c9e, 0x5dd92b84, 0x5df3c7e5, 0x5e0e61c3,
+	0x5e28f920, 0x5e438dfc, 0x5e5e2059, 0x5e78b037,
+	0x5e933d99, 0x5eadc87e, 0x5ec850e9, 0x5ee2d6da,
+	0x5efd5a53, 0x5f17db54, 0x5f3259e0, 0x5f4cd5f6,
+	0x5f674f99, 0x5f81c6c8, 0x5f9c3b87, 0x5fb6add4,
+	0x5fd11db3, 0x5feb8b23, 0x6005f626, 0x60205ebd,
+	0x603ac4e9, 0x605528ac, 0x606f8a05, 0x6089e8f7,
+	0x60a44583, 0x60be9fa9, 0x60d8f76b, 0x60f34cca,
+	0x610d9fc7, 0x6127f062, 0x61423e9e, 0x615c8a7a,
+	0x6176d3f9, 0x61911b1b, 0x61ab5fe1, 0x61c5a24d,
+	0x61dfe25f, 0x61fa2018, 0x62145b7a, 0x622e9485,
+	0x6248cb3b, 0x6262ff9d, 0x627d31ab, 0x62976167,
+	0x62b18ed1, 0x62cbb9eb, 0x62e5e2b6, 0x63000933,
+	0x631a2d62, 0x63344f45, 0x634e6edd, 0x63688c2b,
+	0x6382a730, 0x639cbfec, 0x63b6d661, 0x63d0ea90,
+	0x63eafc7a, 0x64050c1f, 0x641f1982, 0x643924a2,
+	0x64532d80, 0x646d341f, 0x6487387e, 0x64a13a9e,
+	0x64bb3a81, 0x64d53828, 0x64ef3393, 0x65092cc4,
+	0x652323bb, 0x653d1879, 0x65570b00, 0x6570fb50,
+	0x658ae96b, 0x65a4d550, 0x65bebf01, 0x65d8a680,
+	0x65f28bcc, 0x660c6ee8, 0x66264fd3, 0x66402e8f,
+	0x665a0b1c, 0x6673e57d, 0x668dbdb0, 0x66a793b8,
+	0x66c16795, 0x66db3949, 0x66f508d4, 0x670ed636,
+	0x6728a172, 0x67426a87, 0x675c3177, 0x6775f643,
+	0x678fb8eb, 0x67a97971, 0x67c337d5, 0x67dcf418,
+	0x67f6ae3b, 0x6810663f, 0x682a1c25, 0x6843cfed,
+	0x685d8199, 0x68773129, 0x6890de9f, 0x68aa89fa,
+	0x68c4333d, 0x68ddda67, 0x68f77f7a, 0x69112277,
+	0x692ac35e, 0x69446230, 0x695dfeee, 0x6977999a,
+	0x69913232, 0x69aac8ba, 0x69c45d31, 0x69ddef98,
+	0x69f77ff0, 0x6a110e3a, 0x6a2a9a77, 0x6a4424a8,
+	0x6a5daccc, 0x6a7732e6, 0x6a90b6f6, 0x6aaa38fd,
+	0x6ac3b8fb, 0x6add36f2, 0x6af6b2e2, 0x6b102ccd,
+	0x6b29a4b2, 0x6b431a92, 0x6b5c8e6f, 0x6b76004a,
+	0x6b8f7022, 0x6ba8ddf9, 0x6bc249d0, 0x6bdbb3a7,
+	0x6bf51b80, 0x6c0e815a, 0x6c27e537, 0x6c414718,
+	0x6c5aa6fd, 0x6c7404e7, 0x6c8d60d7, 0x6ca6bace,
+	0x6cc012cc, 0x6cd968d2, 0x6cf2bce1, 0x6d0c0ef9,
+	0x6d255f1d, 0x6d3ead4b, 0x6d57f985, 0x6d7143cc,
+	0x6d8a8c21, 0x6da3d283, 0x6dbd16f5, 0x6dd65976,
+	0x6def9a08, 0x6e08d8ab, 0x6e221560, 0x6e3b5027,
+	0x6e548902, 0x6e6dbff1, 0x6e86f4f5, 0x6ea0280e,
+	0x6eb9593e, 0x6ed28885, 0x6eebb5e3, 0x6f04e15a,
+	0x6f1e0aea, 0x6f373294, 0x6f505859, 0x6f697c39,
+	0x6f829e35, 0x6f9bbe4e, 0x6fb4dc85, 0x6fcdf8d9,
+	0x6fe7134d, 0x70002be0, 0x70194293, 0x70325767,
+	0x704b6a5d, 0x70647b76, 0x707d8ab1, 0x70969811,
+	0x70afa394, 0x70c8ad3d, 0x70e1b50c, 0x70fabb01,
+	0x7113bf1d, 0x712cc161, 0x7145c1ce, 0x715ec064,
+	0x7177bd24, 0x7190b80f, 0x71a9b124, 0x71c2a866,
+	0x71db9dd4, 0x71f49170, 0x720d8339, 0x72267331,
+	0x723f6159, 0x72584db0, 0x72713838, 0x728a20f1,
+	0x72a307db, 0x72bbecf9, 0x72d4d049, 0x72edb1ce,
+	0x73069187, 0x731f6f75, 0x73384b98, 0x735125f3,
+	0x7369fe84, 0x7382d54d, 0x739baa4e, 0x73b47d89,
+	0x73cd4efd, 0x73e61eab, 0x73feec94, 0x7417b8b8,
+	0x74308319, 0x74494bb6, 0x74621291, 0x747ad7aa,
+	0x74939b02, 0x74ac5c98, 0x74c51c6f, 0x74ddda86,
+	0x74f696de, 0x750f5178, 0x75280a54, 0x7540c174,
+	0x755976d7, 0x75722a7e, 0x758adc69, 0x75a38c9b,
+	0x75bc3b12, 0x75d4e7cf, 0x75ed92d4, 0x76063c21,
+	0x761ee3b6, 0x76378994, 0x76502dbc, 0x7668d02e,
+	0x768170eb, 0x769a0ff3, 0x76b2ad47, 0x76cb48e7,
+	0x76e3e2d5, 0x76fc7b10, 0x7715119a, 0x772da673,
+	0x7746399b, 0x775ecb13, 0x77775adc, 0x778fe8f6,
+	0x77a87561, 0x77c1001f, 0x77d98930, 0x77f21095,
+	0x780a964d, 0x78231a5b, 0x783b9cbd, 0x78541d75,
+	0x786c9c84, 0x788519e9, 0x789d95a6, 0x78b60fbb,
+	0x78ce8828, 0x78e6feef, 0x78ff740f, 0x7917e78a,
+	0x7930595f, 0x7948c990, 0x7961381d, 0x7979a506,
+	0x7992104c, 0x79aa79f0, 0x79c2e1f1, 0x79db4852,
+	0x79f3ad11, 0x7a0c1031, 0x7a2471b0, 0x7a3cd191,
+	0x7a552fd3, 0x7a6d8c76, 0x7a85e77d, 0x7a9e40e6,
+	0x7ab698b2, 0x7aceeee3, 0x7ae74378, 0x7aff9673,
+	0x7b17e7d2, 0x7b303799, 0x7b4885c5, 0x7b60d259,
+	0x7b791d55, 0x7b9166b9, 0x7ba9ae86, 0x7bc1f4bc,
+	0x7bda395c, 0x7bf27c66, 0x7c0abddb, 0x7c22fdbb,
+	0x7c3b3c07, 0x7c5378c0, 0x7c6bb3e5, 0x7c83ed78,
+	0x7c9c2579, 0x7cb45be9, 0x7ccc90c7, 0x7ce4c414,
+	0x7cfcf5d2, 0x7d152600, 0x7d2d549f, 0x7d4581b0,
+	0x7d5dad32, 0x7d75d727, 0x7d8dff8f, 0x7da6266a,
+	0x7dbe4bba, 0x7dd66f7d, 0x7dee91b6, 0x7e06b264,
+	0x7e1ed188, 0x7e36ef22, 0x7e4f0b34, 0x7e6725bd,
+	0x7e7f3ebd, 0x7e975636, 0x7eaf6c28, 0x7ec78093,
+	0x7edf9378, 0x7ef7a4d7, 0x7f0fb4b1, 0x7f27c307,
+	0x7f3fcfd8, 0x7f57db25, 0x7f6fe4ef, 0x7f87ed36,
 	0x7f9ff3fb, 0x7fb7f93e, 0x7fcffcff, 0x7fe7ff40
 };
 
 const Word32 mTab_4_3[512]={
-	0x32cbfd4a, 0x32eddd70, 0x330fc339, 0x3331aea3, 
-	0x33539fac, 0x33759652, 0x33979294, 0x33b99470, 
-	0x33db9be4, 0x33fda8ed, 0x341fbb8b, 0x3441d3bb, 
-	0x3463f17c, 0x348614cc, 0x34a83da8, 0x34ca6c10, 
-	0x34eca001, 0x350ed979, 0x35311877, 0x35535cfa, 
-	0x3575a6fe, 0x3597f683, 0x35ba4b87, 0x35dca607, 
-	0x35ff0603, 0x36216b78, 0x3643d665, 0x366646c7, 
-	0x3688bc9e, 0x36ab37e8, 0x36cdb8a2, 0x36f03ecb, 
-	0x3712ca62, 0x37355b64, 0x3757f1d1, 0x377a8da5, 
-	0x379d2ee0, 0x37bfd580, 0x37e28184, 0x380532e8, 
-	0x3827e9ad, 0x384aa5d0, 0x386d674f, 0x38902e2a, 
-	0x38b2fa5d, 0x38d5cbe9, 0x38f8a2ca, 0x391b7eff, 
-	0x393e6088, 0x39614761, 0x3984338a, 0x39a72501, 
-	0x39ca1bc4, 0x39ed17d1, 0x3a101928, 0x3a331fc6, 
-	0x3a562baa, 0x3a793cd2, 0x3a9c533d, 0x3abf6ee9, 
-	0x3ae28fd5, 0x3b05b5ff, 0x3b28e165, 0x3b4c1206, 
-	0x3b6f47e0, 0x3b9282f2, 0x3bb5c33a, 0x3bd908b7, 
-	0x3bfc5368, 0x3c1fa349, 0x3c42f85b, 0x3c66529c, 
-	0x3c89b209, 0x3cad16a2, 0x3cd08065, 0x3cf3ef51, 
-	0x3d176364, 0x3d3adc9c, 0x3d5e5af8, 0x3d81de77, 
-	0x3da56717, 0x3dc8f4d6, 0x3dec87b4, 0x3e101fae, 
-	0x3e33bcc3, 0x3e575ef2, 0x3e7b063a, 0x3e9eb298, 
-	0x3ec2640c, 0x3ee61a93, 0x3f09d62d, 0x3f2d96d8, 
-	0x3f515c93, 0x3f75275b, 0x3f98f731, 0x3fbccc11, 
-	0x3fe0a5fc, 0x400484ef, 0x402868ea, 0x404c51e9, 
-	0x40703fee, 0x409432f5, 0x40b82afd, 0x40dc2806, 
-	0x41002a0d, 0x41243111, 0x41483d12, 0x416c4e0d, 
-	0x41906401, 0x41b47eed, 0x41d89ecf, 0x41fcc3a7, 
-	0x4220ed72, 0x42451c30, 0x42694fde, 0x428d887d, 
-	0x42b1c609, 0x42d60883, 0x42fa4fe8, 0x431e9c37, 
-	0x4342ed70, 0x43674390, 0x438b9e96, 0x43affe82, 
-	0x43d46351, 0x43f8cd03, 0x441d3b95, 0x4441af08, 
-	0x44662758, 0x448aa487, 0x44af2690, 0x44d3ad75, 
-	0x44f83933, 0x451cc9c8, 0x45415f35, 0x4565f977, 
-	0x458a988d, 0x45af3c76, 0x45d3e531, 0x45f892bc, 
-	0x461d4516, 0x4641fc3e, 0x4666b832, 0x468b78f2, 
-	0x46b03e7c, 0x46d508cf, 0x46f9d7e9, 0x471eabca, 
-	0x47438470, 0x476861d9, 0x478d4406, 0x47b22af3, 
-	0x47d716a1, 0x47fc070e, 0x4820fc39, 0x4845f620, 
-	0x486af4c3, 0x488ff820, 0x48b50035, 0x48da0d03, 
-	0x48ff1e87, 0x492434c0, 0x49494fad, 0x496e6f4d, 
-	0x4993939f, 0x49b8bca2, 0x49ddea54, 0x4a031cb4, 
-	0x4a2853c1, 0x4a4d8f7a, 0x4a72cfde, 0x4a9814eb, 
-	0x4abd5ea1, 0x4ae2acfd, 0x4b080000, 0x4b2d57a8, 
-	0x4b52b3f3, 0x4b7814e1, 0x4b9d7a70, 0x4bc2e49f, 
-	0x4be8536e, 0x4c0dc6db, 0x4c333ee4, 0x4c58bb89, 
-	0x4c7e3cc9, 0x4ca3c2a2, 0x4cc94d14, 0x4ceedc1c, 
-	0x4d146fbb, 0x4d3a07ef, 0x4d5fa4b6, 0x4d854611, 
-	0x4daaebfd, 0x4dd09679, 0x4df64585, 0x4e1bf91f, 
-	0x4e41b146, 0x4e676dfa, 0x4e8d2f38, 0x4eb2f501, 
-	0x4ed8bf52, 0x4efe8e2b, 0x4f24618a, 0x4f4a3970, 
-	0x4f7015d9, 0x4f95f6c6, 0x4fbbdc36, 0x4fe1c626, 
-	0x5007b497, 0x502da787, 0x50539ef5, 0x50799ae1, 
-	0x509f9b48, 0x50c5a02a, 0x50eba985, 0x5111b75a, 
-	0x5137c9a6, 0x515de069, 0x5183fba2, 0x51aa1b4f, 
-	0x51d03f70, 0x51f66803, 0x521c9508, 0x5242c67d, 
-	0x5268fc62, 0x528f36b5, 0x52b57575, 0x52dbb8a2, 
-	0x5302003a, 0x53284c3c, 0x534e9ca8, 0x5374f17c, 
-	0x539b4ab7, 0x53c1a858, 0x53e80a5f, 0x540e70ca, 
-	0x5434db98, 0x545b4ac8, 0x5481be5a, 0x54a8364b, 
-	0x54ceb29c, 0x54f5334c, 0x551bb858, 0x554241c1, 
-	0x5568cf85, 0x558f61a3, 0x55b5f81b, 0x55dc92eb, 
-	0x56033212, 0x5629d590, 0x56507d63, 0x5677298a, 
-	0x569dda05, 0x56c48ed3, 0x56eb47f2, 0x57120562, 
-	0x5738c721, 0x575f8d2f, 0x5786578a, 0x57ad2633, 
-	0x57d3f927, 0x57fad066, 0x5821abef, 0x58488bc0, 
-	0x586f6fda, 0x5896583b, 0x58bd44e2, 0x58e435ce, 
-	0x590b2aff, 0x59322473, 0x59592229, 0x59802420, 
-	0x59a72a59, 0x59ce34d0, 0x59f54387, 0x5a1c567b, 
-	0x5a436dac, 0x5a6a8919, 0x5a91a8c1, 0x5ab8cca3, 
-	0x5adff4be, 0x5b072111, 0x5b2e519c, 0x5b55865e, 
-	0x5b7cbf54, 0x5ba3fc80, 0x5bcb3ddf, 0x5bf28371, 
-	0x5c19cd35, 0x5c411b2a, 0x5c686d4f, 0x5c8fc3a4, 
-	0x5cb71e27, 0x5cde7cd7, 0x5d05dfb4, 0x5d2d46bd, 
-	0x5d54b1f0, 0x5d7c214e, 0x5da394d4, 0x5dcb0c83, 
-	0x5df28859, 0x5e1a0856, 0x5e418c78, 0x5e6914be, 
-	0x5e90a129, 0x5eb831b7, 0x5edfc667, 0x5f075f38, 
-	0x5f2efc29, 0x5f569d3a, 0x5f7e426a, 0x5fa5ebb7, 
-	0x5fcd9921, 0x5ff54aa8, 0x601d004a, 0x6044ba06, 
-	0x606c77dc, 0x609439ca, 0x60bbffd0, 0x60e3c9ee, 
-	0x610b9821, 0x61336a6a, 0x615b40c8, 0x61831b39, 
-	0x61aaf9bd, 0x61d2dc53, 0x61fac2fa, 0x6222adb2, 
-	0x624a9c79, 0x62728f4f, 0x629a8633, 0x62c28123, 
-	0x62ea8020, 0x63128329, 0x633a8a3c, 0x63629559, 
-	0x638aa47f, 0x63b2b7ad, 0x63dacee2, 0x6402ea1e, 
-	0x642b0960, 0x64532ca6, 0x647b53f1, 0x64a37f3f, 
-	0x64cbae8f, 0x64f3e1e2, 0x651c1935, 0x65445488, 
-	0x656c93db, 0x6594d72c, 0x65bd1e7b, 0x65e569c7, 
-	0x660db90f, 0x66360c53, 0x665e6391, 0x6686bec9, 
-	0x66af1dfa, 0x66d78123, 0x66ffe844, 0x6728535b, 
-	0x6750c268, 0x6779356b, 0x67a1ac62, 0x67ca274c, 
-	0x67f2a629, 0x681b28f9, 0x6843afb9, 0x686c3a6a, 
-	0x6894c90b, 0x68bd5b9b, 0x68e5f219, 0x690e8c84, 
-	0x69372add, 0x695fcd21, 0x69887350, 0x69b11d6a, 
-	0x69d9cb6d, 0x6a027d5a, 0x6a2b332f, 0x6a53eceb, 
-	0x6a7caa8d, 0x6aa56c16, 0x6ace3184, 0x6af6fad6, 
-	0x6b1fc80c, 0x6b489925, 0x6b716e20, 0x6b9a46fd, 
-	0x6bc323bb, 0x6bec0458, 0x6c14e8d5, 0x6c3dd130, 
-	0x6c66bd69, 0x6c8fad80, 0x6cb8a172, 0x6ce19940, 
-	0x6d0a94e9, 0x6d33946d, 0x6d5c97ca, 0x6d859eff, 
-	0x6daeaa0d, 0x6dd7b8f1, 0x6e00cbad, 0x6e29e23e, 
-	0x6e52fca4, 0x6e7c1adf, 0x6ea53cee, 0x6ece62cf, 
-	0x6ef78c83, 0x6f20ba09, 0x6f49eb5f, 0x6f732085, 
-	0x6f9c597b, 0x6fc59640, 0x6feed6d3, 0x70181b33, 
-	0x70416360, 0x706aaf59, 0x7093ff1d, 0x70bd52ab, 
-	0x70e6aa04, 0x71100525, 0x7139640f, 0x7162c6c1, 
-	0x718c2d3a, 0x71b5977a, 0x71df057f, 0x72087749, 
-	0x7231ecd8, 0x725b662a, 0x7284e33f, 0x72ae6417, 
-	0x72d7e8b0, 0x7301710a, 0x732afd24, 0x73548cfe, 
-	0x737e2097, 0x73a7b7ee, 0x73d15303, 0x73faf1d5, 
-	0x74249462, 0x744e3aac, 0x7477e4b0, 0x74a1926e, 
-	0x74cb43e6, 0x74f4f917, 0x751eb201, 0x75486ea1, 
-	0x75722ef9, 0x759bf307, 0x75c5baca, 0x75ef8642, 
-	0x7619556f, 0x7643284f, 0x766cfee2, 0x7696d928, 
-	0x76c0b71f, 0x76ea98c7, 0x77147e20, 0x773e6728, 
-	0x776853df, 0x77924445, 0x77bc3858, 0x77e63019, 
-	0x78102b85, 0x783a2a9e, 0x78642d62, 0x788e33d1, 
-	0x78b83de9, 0x78e24bab, 0x790c5d15, 0x79367228, 
-	0x79608ae1, 0x798aa742, 0x79b4c748, 0x79deeaf4, 
-	0x7a091245, 0x7a333d3a, 0x7a5d6bd2, 0x7a879e0e, 
-	0x7ab1d3ec, 0x7adc0d6b, 0x7b064a8c, 0x7b308b4d, 
-	0x7b5acfae, 0x7b8517ae, 0x7baf634c, 0x7bd9b289, 
-	0x7c040563, 0x7c2e5bda, 0x7c58b5ec, 0x7c83139b, 
-	0x7cad74e4, 0x7cd7d9c7, 0x7d024244, 0x7d2cae5a, 
-	0x7d571e09, 0x7d81914f, 0x7dac082d, 0x7dd682a1, 
-	0x7e0100ac, 0x7e2b824b, 0x7e560780, 0x7e809048, 
-	0x7eab1ca5, 0x7ed5ac94, 0x7f004015, 0x7f2ad729, 
+	0x32cbfd4a, 0x32eddd70, 0x330fc339, 0x3331aea3,
+	0x33539fac, 0x33759652, 0x33979294, 0x33b99470,
+	0x33db9be4, 0x33fda8ed, 0x341fbb8b, 0x3441d3bb,
+	0x3463f17c, 0x348614cc, 0x34a83da8, 0x34ca6c10,
+	0x34eca001, 0x350ed979, 0x35311877, 0x35535cfa,
+	0x3575a6fe, 0x3597f683, 0x35ba4b87, 0x35dca607,
+	0x35ff0603, 0x36216b78, 0x3643d665, 0x366646c7,
+	0x3688bc9e, 0x36ab37e8, 0x36cdb8a2, 0x36f03ecb,
+	0x3712ca62, 0x37355b64, 0x3757f1d1, 0x377a8da5,
+	0x379d2ee0, 0x37bfd580, 0x37e28184, 0x380532e8,
+	0x3827e9ad, 0x384aa5d0, 0x386d674f, 0x38902e2a,
+	0x38b2fa5d, 0x38d5cbe9, 0x38f8a2ca, 0x391b7eff,
+	0x393e6088, 0x39614761, 0x3984338a, 0x39a72501,
+	0x39ca1bc4, 0x39ed17d1, 0x3a101928, 0x3a331fc6,
+	0x3a562baa, 0x3a793cd2, 0x3a9c533d, 0x3abf6ee9,
+	0x3ae28fd5, 0x3b05b5ff, 0x3b28e165, 0x3b4c1206,
+	0x3b6f47e0, 0x3b9282f2, 0x3bb5c33a, 0x3bd908b7,
+	0x3bfc5368, 0x3c1fa349, 0x3c42f85b, 0x3c66529c,
+	0x3c89b209, 0x3cad16a2, 0x3cd08065, 0x3cf3ef51,
+	0x3d176364, 0x3d3adc9c, 0x3d5e5af8, 0x3d81de77,
+	0x3da56717, 0x3dc8f4d6, 0x3dec87b4, 0x3e101fae,
+	0x3e33bcc3, 0x3e575ef2, 0x3e7b063a, 0x3e9eb298,
+	0x3ec2640c, 0x3ee61a93, 0x3f09d62d, 0x3f2d96d8,
+	0x3f515c93, 0x3f75275b, 0x3f98f731, 0x3fbccc11,
+	0x3fe0a5fc, 0x400484ef, 0x402868ea, 0x404c51e9,
+	0x40703fee, 0x409432f5, 0x40b82afd, 0x40dc2806,
+	0x41002a0d, 0x41243111, 0x41483d12, 0x416c4e0d,
+	0x41906401, 0x41b47eed, 0x41d89ecf, 0x41fcc3a7,
+	0x4220ed72, 0x42451c30, 0x42694fde, 0x428d887d,
+	0x42b1c609, 0x42d60883, 0x42fa4fe8, 0x431e9c37,
+	0x4342ed70, 0x43674390, 0x438b9e96, 0x43affe82,
+	0x43d46351, 0x43f8cd03, 0x441d3b95, 0x4441af08,
+	0x44662758, 0x448aa487, 0x44af2690, 0x44d3ad75,
+	0x44f83933, 0x451cc9c8, 0x45415f35, 0x4565f977,
+	0x458a988d, 0x45af3c76, 0x45d3e531, 0x45f892bc,
+	0x461d4516, 0x4641fc3e, 0x4666b832, 0x468b78f2,
+	0x46b03e7c, 0x46d508cf, 0x46f9d7e9, 0x471eabca,
+	0x47438470, 0x476861d9, 0x478d4406, 0x47b22af3,
+	0x47d716a1, 0x47fc070e, 0x4820fc39, 0x4845f620,
+	0x486af4c3, 0x488ff820, 0x48b50035, 0x48da0d03,
+	0x48ff1e87, 0x492434c0, 0x49494fad, 0x496e6f4d,
+	0x4993939f, 0x49b8bca2, 0x49ddea54, 0x4a031cb4,
+	0x4a2853c1, 0x4a4d8f7a, 0x4a72cfde, 0x4a9814eb,
+	0x4abd5ea1, 0x4ae2acfd, 0x4b080000, 0x4b2d57a8,
+	0x4b52b3f3, 0x4b7814e1, 0x4b9d7a70, 0x4bc2e49f,
+	0x4be8536e, 0x4c0dc6db, 0x4c333ee4, 0x4c58bb89,
+	0x4c7e3cc9, 0x4ca3c2a2, 0x4cc94d14, 0x4ceedc1c,
+	0x4d146fbb, 0x4d3a07ef, 0x4d5fa4b6, 0x4d854611,
+	0x4daaebfd, 0x4dd09679, 0x4df64585, 0x4e1bf91f,
+	0x4e41b146, 0x4e676dfa, 0x4e8d2f38, 0x4eb2f501,
+	0x4ed8bf52, 0x4efe8e2b, 0x4f24618a, 0x4f4a3970,
+	0x4f7015d9, 0x4f95f6c6, 0x4fbbdc36, 0x4fe1c626,
+	0x5007b497, 0x502da787, 0x50539ef5, 0x50799ae1,
+	0x509f9b48, 0x50c5a02a, 0x50eba985, 0x5111b75a,
+	0x5137c9a6, 0x515de069, 0x5183fba2, 0x51aa1b4f,
+	0x51d03f70, 0x51f66803, 0x521c9508, 0x5242c67d,
+	0x5268fc62, 0x528f36b5, 0x52b57575, 0x52dbb8a2,
+	0x5302003a, 0x53284c3c, 0x534e9ca8, 0x5374f17c,
+	0x539b4ab7, 0x53c1a858, 0x53e80a5f, 0x540e70ca,
+	0x5434db98, 0x545b4ac8, 0x5481be5a, 0x54a8364b,
+	0x54ceb29c, 0x54f5334c, 0x551bb858, 0x554241c1,
+	0x5568cf85, 0x558f61a3, 0x55b5f81b, 0x55dc92eb,
+	0x56033212, 0x5629d590, 0x56507d63, 0x5677298a,
+	0x569dda05, 0x56c48ed3, 0x56eb47f2, 0x57120562,
+	0x5738c721, 0x575f8d2f, 0x5786578a, 0x57ad2633,
+	0x57d3f927, 0x57fad066, 0x5821abef, 0x58488bc0,
+	0x586f6fda, 0x5896583b, 0x58bd44e2, 0x58e435ce,
+	0x590b2aff, 0x59322473, 0x59592229, 0x59802420,
+	0x59a72a59, 0x59ce34d0, 0x59f54387, 0x5a1c567b,
+	0x5a436dac, 0x5a6a8919, 0x5a91a8c1, 0x5ab8cca3,
+	0x5adff4be, 0x5b072111, 0x5b2e519c, 0x5b55865e,
+	0x5b7cbf54, 0x5ba3fc80, 0x5bcb3ddf, 0x5bf28371,
+	0x5c19cd35, 0x5c411b2a, 0x5c686d4f, 0x5c8fc3a4,
+	0x5cb71e27, 0x5cde7cd7, 0x5d05dfb4, 0x5d2d46bd,
+	0x5d54b1f0, 0x5d7c214e, 0x5da394d4, 0x5dcb0c83,
+	0x5df28859, 0x5e1a0856, 0x5e418c78, 0x5e6914be,
+	0x5e90a129, 0x5eb831b7, 0x5edfc667, 0x5f075f38,
+	0x5f2efc29, 0x5f569d3a, 0x5f7e426a, 0x5fa5ebb7,
+	0x5fcd9921, 0x5ff54aa8, 0x601d004a, 0x6044ba06,
+	0x606c77dc, 0x609439ca, 0x60bbffd0, 0x60e3c9ee,
+	0x610b9821, 0x61336a6a, 0x615b40c8, 0x61831b39,
+	0x61aaf9bd, 0x61d2dc53, 0x61fac2fa, 0x6222adb2,
+	0x624a9c79, 0x62728f4f, 0x629a8633, 0x62c28123,
+	0x62ea8020, 0x63128329, 0x633a8a3c, 0x63629559,
+	0x638aa47f, 0x63b2b7ad, 0x63dacee2, 0x6402ea1e,
+	0x642b0960, 0x64532ca6, 0x647b53f1, 0x64a37f3f,
+	0x64cbae8f, 0x64f3e1e2, 0x651c1935, 0x65445488,
+	0x656c93db, 0x6594d72c, 0x65bd1e7b, 0x65e569c7,
+	0x660db90f, 0x66360c53, 0x665e6391, 0x6686bec9,
+	0x66af1dfa, 0x66d78123, 0x66ffe844, 0x6728535b,
+	0x6750c268, 0x6779356b, 0x67a1ac62, 0x67ca274c,
+	0x67f2a629, 0x681b28f9, 0x6843afb9, 0x686c3a6a,
+	0x6894c90b, 0x68bd5b9b, 0x68e5f219, 0x690e8c84,
+	0x69372add, 0x695fcd21, 0x69887350, 0x69b11d6a,
+	0x69d9cb6d, 0x6a027d5a, 0x6a2b332f, 0x6a53eceb,
+	0x6a7caa8d, 0x6aa56c16, 0x6ace3184, 0x6af6fad6,
+	0x6b1fc80c, 0x6b489925, 0x6b716e20, 0x6b9a46fd,
+	0x6bc323bb, 0x6bec0458, 0x6c14e8d5, 0x6c3dd130,
+	0x6c66bd69, 0x6c8fad80, 0x6cb8a172, 0x6ce19940,
+	0x6d0a94e9, 0x6d33946d, 0x6d5c97ca, 0x6d859eff,
+	0x6daeaa0d, 0x6dd7b8f1, 0x6e00cbad, 0x6e29e23e,
+	0x6e52fca4, 0x6e7c1adf, 0x6ea53cee, 0x6ece62cf,
+	0x6ef78c83, 0x6f20ba09, 0x6f49eb5f, 0x6f732085,
+	0x6f9c597b, 0x6fc59640, 0x6feed6d3, 0x70181b33,
+	0x70416360, 0x706aaf59, 0x7093ff1d, 0x70bd52ab,
+	0x70e6aa04, 0x71100525, 0x7139640f, 0x7162c6c1,
+	0x718c2d3a, 0x71b5977a, 0x71df057f, 0x72087749,
+	0x7231ecd8, 0x725b662a, 0x7284e33f, 0x72ae6417,
+	0x72d7e8b0, 0x7301710a, 0x732afd24, 0x73548cfe,
+	0x737e2097, 0x73a7b7ee, 0x73d15303, 0x73faf1d5,
+	0x74249462, 0x744e3aac, 0x7477e4b0, 0x74a1926e,
+	0x74cb43e6, 0x74f4f917, 0x751eb201, 0x75486ea1,
+	0x75722ef9, 0x759bf307, 0x75c5baca, 0x75ef8642,
+	0x7619556f, 0x7643284f, 0x766cfee2, 0x7696d928,
+	0x76c0b71f, 0x76ea98c7, 0x77147e20, 0x773e6728,
+	0x776853df, 0x77924445, 0x77bc3858, 0x77e63019,
+	0x78102b85, 0x783a2a9e, 0x78642d62, 0x788e33d1,
+	0x78b83de9, 0x78e24bab, 0x790c5d15, 0x79367228,
+	0x79608ae1, 0x798aa742, 0x79b4c748, 0x79deeaf4,
+	0x7a091245, 0x7a333d3a, 0x7a5d6bd2, 0x7a879e0e,
+	0x7ab1d3ec, 0x7adc0d6b, 0x7b064a8c, 0x7b308b4d,
+	0x7b5acfae, 0x7b8517ae, 0x7baf634c, 0x7bd9b289,
+	0x7c040563, 0x7c2e5bda, 0x7c58b5ec, 0x7c83139b,
+	0x7cad74e4, 0x7cd7d9c7, 0x7d024244, 0x7d2cae5a,
+	0x7d571e09, 0x7d81914f, 0x7dac082d, 0x7dd682a1,
+	0x7e0100ac, 0x7e2b824b, 0x7e560780, 0x7e809048,
+	0x7eab1ca5, 0x7ed5ac94, 0x7f004015, 0x7f2ad729,
 	0x7f5571cd, 0x7f801003, 0x7faab1c8, 0x7fd5571d
 };
 
-
-const Word32 invSBF[24] = {
-  0x3FFD34FC, 0x2D3F8000, 0x24F18C7E, 0x1FFE9A7E, 
-  0x1C9DF10C, 0x1A1F851A, 0x182FE994, 0x169FC000, 
-  0x15542AAA, 0x143C31C2, 0x134B1B6C, 0x127920BE, 
-  0x11BF2FCC, 0x111A749E, 0x1085FC42, 0x0FFFA7BE, 
-  0x0F855818, 0x0F14EE56, 0x0EAE6A78, 0x0E4EF886, 
-  0x0DF69880, 0x0DA49568, 0x0D578542, 0x0D101D0C
-};
+
+const Word32 invSBF[24] = {
+  0x3FFD34FC, 0x2D3F8000, 0x24F18C7E, 0x1FFE9A7E,
+  0x1C9DF10C, 0x1A1F851A, 0x182FE994, 0x169FC000,
+  0x15542AAA, 0x143C31C2, 0x134B1B6C, 0x127920BE,
+  0x11BF2FCC, 0x111A749E, 0x1085FC42, 0x0FFFA7BE,
+  0x0F855818, 0x0F14EE56, 0x0EAE6A78, 0x0E4EF886,
+  0x0DF69880, 0x0DA49568, 0x0D578542, 0x0D101D0C
+};
 
 const Word16 pow2tominusNover16[17] = {
   0x7fff, 0x7a93, 0x7560, 0x7066,
@@ -1350,43 +1350,43 @@ const Word16 pow2tominusNover16[17] = {
   0x5a82, 0x56ac, 0x52ff, 0x4f7b,
   0x4c1c, 0x48e2, 0x45cb, 0x42d5,
   0x4000
-};
-
-const Word16 sideInfoTabLong[MAX_SFB_LONG + 1] = {
-  9, 9, 9, 9, 9, 9, 9, 9, 9, 
-  9, 9, 9, 9, 9, 9, 9, 9, 9, 
-  9, 9, 9, 9, 9, 9, 9, 9, 9, 
-  9, 9, 9, 9, 14, 14, 14, 14, 
-  14, 14, 14, 14, 14, 14, 14, 
-  14, 14, 14, 14, 14, 14, 14, 
-  14, 14, 14
-};
-
-const Word16 sideInfoTabShort[MAX_SFB_SHORT + 1] = {
-  7, 7, 7, 7, 7, 7, 7, 10, 10, 
-  10, 10, 10, 10, 10, 13, 13
+};
+
+const Word16 sideInfoTabLong[MAX_SFB_LONG + 1] = {
+  9, 9, 9, 9, 9, 9, 9, 9, 9,
+  9, 9, 9, 9, 9, 9, 9, 9, 9,
+  9, 9, 9, 9, 9, 9, 9, 9, 9,
+  9, 9, 9, 9, 14, 14, 14, 14,
+  14, 14, 14, 14, 14, 14, 14,
+  14, 14, 14, 14, 14, 14, 14,
+  14, 14, 14
+};
+
+const Word16 sideInfoTabShort[MAX_SFB_SHORT + 1] = {
+  7, 7, 7, 7, 7, 7, 7, 10, 10,
+  10, 10, 10, 10, 10, 13, 13
 };
 
 Word32 specExpMantTableComb_enc[4][14] =
 {
-  {0x40000000,  0x50a28be6,  0x6597fa95,  0x40000000, 
-   0x50a28be6,  0x6597fa95,  0x40000000,  0x50a28be6, 
-   0x6597fa95,  0x40000000,  0x50a28be6,  0x6597fa95, 
-   0x40000000,  0x50a28be6}, 
-
-  {0x4c1bf829,  0x5fe4435e,  0x78d0df9c,  0x4c1bf829, 
-   0x5fe4435e,  0x78d0df9c,  0x4c1bf829,  0x5fe4435e, 
-   0x78d0df9c,  0x4c1bf829,  0x5fe4435e,  0x78d0df9c, 
-   0x4c1bf829,  0x5fe4435e}, 
-
-  {0x5a82799a,  0x7208f81d,  0x47d66b0f,  0x5a82799a, 
-   0x7208f81d,  0x47d66b0f,  0x5a82799a,  0x7208f81d, 
-   0x47d66b0f,  0x5a82799a,  0x7208f81d,  0x47d66b0f, 
-   0x5a82799a,  0x7208f81d}, 
-
-  {0x6ba27e65,  0x43ce3e4b,  0x556e0424,  0x6ba27e65, 
-   0x43ce3e4b,  0x556e0424,  0x6ba27e65,  0x43ce3e4b, 
-   0x556e0424,  0x6ba27e65,  0x43ce3e4b,  0x556e0424, 
+  {0x40000000,  0x50a28be6,  0x6597fa95,  0x40000000,
+   0x50a28be6,  0x6597fa95,  0x40000000,  0x50a28be6,
+   0x6597fa95,  0x40000000,  0x50a28be6,  0x6597fa95,
+   0x40000000,  0x50a28be6},
+
+  {0x4c1bf829,  0x5fe4435e,  0x78d0df9c,  0x4c1bf829,
+   0x5fe4435e,  0x78d0df9c,  0x4c1bf829,  0x5fe4435e,
+   0x78d0df9c,  0x4c1bf829,  0x5fe4435e,  0x78d0df9c,
+   0x4c1bf829,  0x5fe4435e},
+
+  {0x5a82799a,  0x7208f81d,  0x47d66b0f,  0x5a82799a,
+   0x7208f81d,  0x47d66b0f,  0x5a82799a,  0x7208f81d,
+   0x47d66b0f,  0x5a82799a,  0x7208f81d,  0x47d66b0f,
+   0x5a82799a,  0x7208f81d},
+
+  {0x6ba27e65,  0x43ce3e4b,  0x556e0424,  0x6ba27e65,
+   0x43ce3e4b,  0x556e0424,  0x6ba27e65,  0x43ce3e4b,
+   0x556e0424,  0x6ba27e65,  0x43ce3e4b,  0x556e0424,
    0x6ba27e65,  0x43ce3e4b}
 };
 
@@ -1398,33 +1398,33 @@ const  UWord8 specExpTableComb_enc[4][14] =
   {1, 3, 4, 5, 7, 8, 9, 11, 12, 13, 15, 16, 17, 19}
 };
 
-const Word16 quantBorders[4][4] = {
-  /* pow(1.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
-  {0x0400, 0x0ee7, 0x1c86, 0x2c0d},
-  /* pow(2.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
-  {0x04c2, 0x11b9, 0x21eb, 0x3463},
-  /* pow(3.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
-  {0x05a8, 0x1514, 0x2856, 0x3e4c},
-  /* pow(4.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
-  {0x06ba, 0x1911, 0x2ff8, 0x4a16},
-};
-
-const Word16 quantRecon[4][3] = {
-  {0x0800, 0x1429, 0x229d},
-  {0x0983, 0x17f9, 0x292a},
-  {0x0b50, 0x1c82, 0x30f4},
-  {0x0d74, 0x21e7, 0x3a37},
+const Word16 quantBorders[4][4] = {
+  /* pow(1.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
+  {0x0400, 0x0ee7, 0x1c86, 0x2c0d},
+  /* pow(2.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
+  {0x04c2, 0x11b9, 0x21eb, 0x3463},
+  /* pow(3.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
+  {0x05a8, 0x1514, 0x2856, 0x3e4c},
+  /* pow(4.0-0.4054, 4/3)/16 * pow(2, (0..3)/4) */
+  {0x06ba, 0x1911, 0x2ff8, 0x4a16},
+};
+
+const Word16 quantRecon[4][3] = {
+  {0x0800, 0x1429, 0x229d},
+  {0x0983, 0x17f9, 0x292a},
+  {0x0b50, 0x1c82, 0x30f4},
+  {0x0d74, 0x21e7, 0x3a37},
 };
 
-const int sampRateTab[NUM_SAMPLE_RATES] = {
-    96000, 88200, 64000, 48000, 44100, 32000, 
-	24000, 22050, 16000, 12000, 11025,  8000
+const int sampRateTab[NUM_SAMPLE_RATES] = {
+    96000, 88200, 64000, 48000, 44100, 32000,
+	24000, 22050, 16000, 12000, 11025,  8000
 };
 
 
-const int	rates[8] = {		
-	160, 240, 320, 400, 480, 560, 640, 0
-};
+const int	rates[8] = {
+	160, 240, 320, 400, 480, 560, 640, 0
+};
 
 const int BandwithCoefTab[8][NUM_SAMPLE_RATES] = {
 	{ 7000,  7000,  4666,  3500,  3500,  2800,  2800,  2800,  2800,  2000,  2000,  2000},
@@ -1438,76 +1438,76 @@ const int BandwithCoefTab[8][NUM_SAMPLE_RATES] = {
 };
 
 
-/* total number of scale factor bands in one window */
-const UWord8 sfBandTotalShort[NUM_SAMPLE_RATES] = {
-    12, 12, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15
-};
-
-const UWord8 sfBandTotalLong[NUM_SAMPLE_RATES] = {
-    41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40
-};
-
-/* scale factor band tables */
-const int sfBandTabShortOffset[NUM_SAMPLE_RATES] = {0, 0, 0, 13, 13, 13, 28, 28, 44, 44, 44, 60};
-
-const short sfBandTabShort[76] = {
-	/* short block 64, 88, 96 kHz [13]  */
-	0,   4,   8,  12,  16,  20,  24,  32,  40,  48,  64,  92, 128,
-
-	/* short block 32, 44, 48 kHz [15]  */
-	0,   4,   8,  12,  16,  20,  28,  36,  44,  56,  68,  80,  96, 112, 128,
-
-	/* short block 22, 24 kHz [16]  */
-	0,   4,   8,  12,  16,  20,  24,  28,  36,  44,  52,  64,  76,  92, 108, 128,
-
-	/* short block 11, 12, 16 kHz [16] */
-	0,   4,   8,  12,  16,  20,  24,  28,  32,  40,  48,  60,  72,  88, 108, 128,
-
-	/* short block 8 kHz [16] */
-	0,   4,   8,  12,  16,  20,  24,  28,  36,  44,  52,  60,  72,  88, 108, 128
-};
-
-const int sfBandTabLongOffset[NUM_SAMPLE_RATES] = {0, 0, 42, 90, 90, 140, 192, 192, 240, 240, 240, 284};
-
-const short sfBandTabLong[325] = {
-	/* long block 88, 96 kHz [42]  */
-	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  44,  48,   52,
-	 56,  64,  72,  80,  88,  96, 108, 120, 132, 144, 156, 172, 188,  212,
-	240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024,
-
-	/* long block 64 kHz [48]  */
-	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  44,  48,  52,  56,   64,
-	 72,  80,  88, 100, 112, 124, 140, 156, 172, 192, 216, 240, 268, 304, 344,  384,
-	424, 464, 504, 544, 584, 624, 664, 704, 744, 784, 824, 864, 904, 944, 984, 1024,
-
-	/* long block 44, 48 kHz [50] */
-	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  48,  56,  64,  72,   80,  88,
-	 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384,  416, 448,
-	480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024,
-
-	/* long block 32 kHz [52] */
-	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  48,  56,  64,  72,   80,  88,  96,
-	108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416,  448, 480, 512,
-	544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, 1024,
-
-	/* long block 22, 24 kHz [48] */
-	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  44,  52,  60,  68,   76,
-	 84,  92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260,  284,
-	308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024,
-
-	/* long block 11, 12, 16 kHz [44] */
-	  0,   8,  16,  24,  32,  40,  48,  56,  64,  72,  80,  88, 100,  112, 124,
-	136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320,  344, 368,
-	396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024,
-
-	/* long block 8 kHz [41]  */
-	  0,  12,  24,  36,  48,  60,  72,  84,  96, 108, 120, 132,  144, 156,
-	172, 188, 204, 220, 236, 252, 268, 288, 308, 328, 348, 372,  396, 420,
-	448, 476, 508, 544, 580, 620, 664, 712, 764, 820, 880, 944, 1024
-};
+/* total number of scale factor bands in one window */
+const UWord8 sfBandTotalShort[NUM_SAMPLE_RATES] = {
+    12, 12, 12, 14, 14, 14, 15, 15, 15, 15, 15, 15
+};
+
+const UWord8 sfBandTotalLong[NUM_SAMPLE_RATES] = {
+    41, 41, 47, 49, 49, 51, 47, 47, 43, 43, 43, 40
+};
+
+/* scale factor band tables */
+const int sfBandTabShortOffset[NUM_SAMPLE_RATES] = {0, 0, 0, 13, 13, 13, 28, 28, 44, 44, 44, 60};
+
+const short sfBandTabShort[76] = {
+	/* short block 64, 88, 96 kHz [13]  */
+	0,   4,   8,  12,  16,  20,  24,  32,  40,  48,  64,  92, 128,
+
+	/* short block 32, 44, 48 kHz [15]  */
+	0,   4,   8,  12,  16,  20,  28,  36,  44,  56,  68,  80,  96, 112, 128,
+
+	/* short block 22, 24 kHz [16]  */
+	0,   4,   8,  12,  16,  20,  24,  28,  36,  44,  52,  64,  76,  92, 108, 128,
+
+	/* short block 11, 12, 16 kHz [16] */
+	0,   4,   8,  12,  16,  20,  24,  28,  32,  40,  48,  60,  72,  88, 108, 128,
+
+	/* short block 8 kHz [16] */
+	0,   4,   8,  12,  16,  20,  24,  28,  36,  44,  52,  60,  72,  88, 108, 128
+};
+
+const int sfBandTabLongOffset[NUM_SAMPLE_RATES] = {0, 0, 42, 90, 90, 140, 192, 192, 240, 240, 240, 284};
+
+const short sfBandTabLong[325] = {
+	/* long block 88, 96 kHz [42]  */
+	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  44,  48,   52,
+	 56,  64,  72,  80,  88,  96, 108, 120, 132, 144, 156, 172, 188,  212,
+	240, 276, 320, 384, 448, 512, 576, 640, 704, 768, 832, 896, 960, 1024,
+
+	/* long block 64 kHz [48]  */
+	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  44,  48,  52,  56,   64,
+	 72,  80,  88, 100, 112, 124, 140, 156, 172, 192, 216, 240, 268, 304, 344,  384,
+	424, 464, 504, 544, 584, 624, 664, 704, 744, 784, 824, 864, 904, 944, 984, 1024,
+
+	/* long block 44, 48 kHz [50] */
+	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  48,  56,  64,  72,   80,  88,
+	 96, 108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384,  416, 448,
+	480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 1024,
+
+	/* long block 32 kHz [52] */
+	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  48,  56,  64,  72,   80,  88,  96,
+	108, 120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416,  448, 480, 512,
+	544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928, 960, 992, 1024,
+
+	/* long block 22, 24 kHz [48] */
+	  0,   4,   8,  12,  16,  20,  24,  28,  32,  36,  40,  44,  52,  60,  68,   76,
+	 84,  92, 100, 108, 116, 124, 136, 148, 160, 172, 188, 204, 220, 240, 260,  284,
+	308, 336, 364, 396, 432, 468, 508, 552, 600, 652, 704, 768, 832, 896, 960, 1024,
+
+	/* long block 11, 12, 16 kHz [44] */
+	  0,   8,  16,  24,  32,  40,  48,  56,  64,  72,  80,  88, 100,  112, 124,
+	136, 148, 160, 172, 184, 196, 212, 228, 244, 260, 280, 300, 320,  344, 368,
+	396, 424, 456, 492, 532, 572, 616, 664, 716, 772, 832, 896, 960, 1024,
+
+	/* long block 8 kHz [41]  */
+	  0,  12,  24,  36,  48,  60,  72,  84,  96, 108, 120, 132,  144, 156,
+	172, 188, 204, 220, 236, 252, 268, 288, 308, 328, 348, 372,  396, 420,
+	448, 476, 508, 544, 580, 620, 664, 712, 764, 820, 880, 944, 1024
+};
 
 /*
-  these tables are used only for counting and 
+  these tables are used only for counting and
   are stored in packed format
 */
 const UWord16 huff_ltab1_2[3][3][3][3]=
@@ -2260,12 +2260,12 @@ const UWord32 huff_ctabscf[121]=
 };
 
 const Word32 m_log2_table[INT_BITS] = {
-  0x00000000,0x4ae00d00,0x2934f080,0x15c01a3f, 
-  0x0b31fb80,0x05aeb4e0,0x02dcf2d0,0x016fe50c, 
+  0x00000000,0x4ae00d00,0x2934f080,0x15c01a3f,
+  0x0b31fb80,0x05aeb4e0,0x02dcf2d0,0x016fe50c,
   0x00b84e23,0x005c3e10,0x002e24ca,0x001713d6,
   0x000b8a47,0x0005c53b,0x0002e2a3,0x00017153,
   0x0000b8aa,0x00005c55,0x00002e2b,0x00001715,
-  0x00000b8b,0x000005c5,0x000002e3,0x00000171, 
+  0x00000b8b,0x000005c5,0x000002e3,0x00000171,
   0x000000b9,0x0000005c,0x0000002e,0x00000017,
   0x0000000c,0x00000006,0x00000003,0x00000001
 };
@@ -2344,20 +2344,20 @@ const Word32 tnsCoeff4Borders[16]=
 };
 
 
-const unsigned char bitrevTab[17 + 129] = 
-{
-/* 64 */
-0x01, 0x08, 0x02, 0x04, 0x03, 0x0c, 0x05, 0x0a, 0x07, 0x0e, 0x0b, 0x0d, 0x00, 0x06, 0x09, 0x0f,
-0x00,
-
-/* 512 */
-0x01, 0x40, 0x02, 0x20, 0x03, 0x60, 0x04, 0x10, 0x05, 0x50, 0x06, 0x30, 0x07, 0x70, 0x09, 0x48,
-0x0a, 0x28, 0x0b, 0x68, 0x0c, 0x18, 0x0d, 0x58, 0x0e, 0x38, 0x0f, 0x78, 0x11, 0x44, 0x12, 0x24,
-0x13, 0x64, 0x15, 0x54, 0x16, 0x34, 0x17, 0x74, 0x19, 0x4c, 0x1a, 0x2c, 0x1b, 0x6c, 0x1d, 0x5c,
-0x1e, 0x3c, 0x1f, 0x7c, 0x21, 0x42, 0x23, 0x62, 0x25, 0x52, 0x26, 0x32, 0x27, 0x72, 0x29, 0x4a,
-0x2b, 0x6a, 0x2d, 0x5a, 0x2e, 0x3a, 0x2f, 0x7a, 0x31, 0x46, 0x33, 0x66, 0x35, 0x56, 0x37, 0x76,
-0x39, 0x4e, 0x3b, 0x6e, 0x3d, 0x5e, 0x3f, 0x7e, 0x43, 0x61, 0x45, 0x51, 0x47, 0x71, 0x4b, 0x69,
-0x4d, 0x59, 0x4f, 0x79, 0x53, 0x65, 0x57, 0x75, 0x5b, 0x6d, 0x5f, 0x7d, 0x67, 0x73, 0x6f, 0x7b,
-0x00, 0x08, 0x14, 0x1c, 0x22, 0x2a, 0x36, 0x3e, 0x41, 0x49, 0x55, 0x5d, 0x63, 0x6b, 0x77, 0x7f,
-0x00,
+const unsigned char bitrevTab[17 + 129] =
+{
+/* 64 */
+0x01, 0x08, 0x02, 0x04, 0x03, 0x0c, 0x05, 0x0a, 0x07, 0x0e, 0x0b, 0x0d, 0x00, 0x06, 0x09, 0x0f,
+0x00,
+
+/* 512 */
+0x01, 0x40, 0x02, 0x20, 0x03, 0x60, 0x04, 0x10, 0x05, 0x50, 0x06, 0x30, 0x07, 0x70, 0x09, 0x48,
+0x0a, 0x28, 0x0b, 0x68, 0x0c, 0x18, 0x0d, 0x58, 0x0e, 0x38, 0x0f, 0x78, 0x11, 0x44, 0x12, 0x24,
+0x13, 0x64, 0x15, 0x54, 0x16, 0x34, 0x17, 0x74, 0x19, 0x4c, 0x1a, 0x2c, 0x1b, 0x6c, 0x1d, 0x5c,
+0x1e, 0x3c, 0x1f, 0x7c, 0x21, 0x42, 0x23, 0x62, 0x25, 0x52, 0x26, 0x32, 0x27, 0x72, 0x29, 0x4a,
+0x2b, 0x6a, 0x2d, 0x5a, 0x2e, 0x3a, 0x2f, 0x7a, 0x31, 0x46, 0x33, 0x66, 0x35, 0x56, 0x37, 0x76,
+0x39, 0x4e, 0x3b, 0x6e, 0x3d, 0x5e, 0x3f, 0x7e, 0x43, 0x61, 0x45, 0x51, 0x47, 0x71, 0x4b, 0x69,
+0x4d, 0x59, 0x4f, 0x79, 0x53, 0x65, 0x57, 0x75, 0x5b, 0x6d, 0x5f, 0x7d, 0x67, 0x73, 0x6f, 0x7b,
+0x00, 0x08, 0x14, 0x1c, 0x22, 0x2a, 0x36, 0x3e, 0x41, 0x49, 0x55, 0x5d, 0x63, 0x6b, 0x77, 0x7f,
+0x00,
 };
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/aacenc.c b/media/libstagefright/codecs/aacenc/src/aacenc.c
index 552ae41..b5e8a9c 100644
--- a/media/libstagefright/codecs/aacenc/src/aacenc.c
+++ b/media/libstagefright/codecs/aacenc/src/aacenc.c
@@ -1,105 +1,105 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		aacenc.c
-
-	Content:	aac encoder interface functions
-
-*******************************************************************************/
-
-#include "voAAC.h"
-#include "typedef.h"
-#include "aacenc_core.h"
-#include "aac_rom.h"
-#include "cmnMemory.h"
-#include "memalign.h"
-
-/**
-* Init the audio codec module and return codec handle
-* \param phCodec [OUT] Return the video codec handle
-* \param vType	[IN] The codec type if the module support multi codec.
-* \param pUserData	[IN] The init param. It is memory operator or alloced memory
-* \retval VO_ERR_NONE Succeeded.
-*/
-VO_U32 VO_API voAACEncInit(VO_HANDLE * phCodec,VO_AUDIO_CODINGTYPE vType, VO_CODEC_INIT_USERDATA *pUserData)
-{
-	AAC_ENCODER*hAacEnc;
-	AACENC_CONFIG config;
-	int error;
-
-#ifdef USE_DEAULT_MEM
-	VO_MEM_OPERATOR voMemoprator;
-#endif
-	VO_MEM_OPERATOR *pMemOP;
-	int interMem;
-
-	interMem = 0;
-	error = 0;
-	
-	/* init the memory operator */
-	if(pUserData == NULL || pUserData->memflag != VO_IMF_USERMEMOPERATOR || pUserData->memData == NULL )
-	{
-#ifdef USE_DEAULT_MEM
-		voMemoprator.Alloc = cmnMemAlloc;
-		voMemoprator.Copy = cmnMemCopy;
-		voMemoprator.Free = cmnMemFree;
-		voMemoprator.Set = cmnMemSet;
-		voMemoprator.Check = cmnMemCheck;
-
-		interMem = 1;
-
-		pMemOP = &voMemoprator;
-#else
-		*phCodec = NULL;
-		return VO_ERR_INVALID_ARG;
-#endif
-	}
-	else
-	{
-		pMemOP = (VO_MEM_OPERATOR *)pUserData->memData;
-	}
-
-	/* init the aac encoder handle */
-	hAacEnc = (AAC_ENCODER*)mem_malloc(pMemOP, sizeof(AAC_ENCODER), 32, VO_INDEX_ENC_AAC);
-	if(NULL == hAacEnc)
-	{
-		error = 1;
-	}
-
-	if(!error)
-	{
-		/* init the aac encoder intra memory */
-		hAacEnc->intbuf = (short *)mem_malloc(pMemOP, AACENC_BLOCKSIZE*MAX_CHANNELS*sizeof(short), 32, VO_INDEX_ENC_AAC);
-		if(NULL == hAacEnc->intbuf)
-		{
-			error = 1;
-		}
-	}
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		aacenc.c
+
+	Content:	aac encoder interface functions
+
+*******************************************************************************/
+
+#include "voAAC.h"
+#include "typedef.h"
+#include "aacenc_core.h"
+#include "aac_rom.h"
+#include "cmnMemory.h"
+#include "memalign.h"
+
+/**
+* Init the audio codec module and return codec handle
+* \param phCodec [OUT] Return the video codec handle
+* \param vType	[IN] The codec type if the module support multi codec.
+* \param pUserData	[IN] The init param. It is memory operator or alloced memory
+* \retval VO_ERR_NONE Succeeded.
+*/
+VO_U32 VO_API voAACEncInit(VO_HANDLE * phCodec,VO_AUDIO_CODINGTYPE vType, VO_CODEC_INIT_USERDATA *pUserData)
+{
+	AAC_ENCODER*hAacEnc;
+	AACENC_CONFIG config;
+	int error;
+
+#ifdef USE_DEAULT_MEM
+	VO_MEM_OPERATOR voMemoprator;
+#endif
+	VO_MEM_OPERATOR *pMemOP;
+	int interMem;
+
+	interMem = 0;
+	error = 0;
+
+	/* init the memory operator */
+	if(pUserData == NULL || pUserData->memflag != VO_IMF_USERMEMOPERATOR || pUserData->memData == NULL )
+	{
+#ifdef USE_DEAULT_MEM
+		voMemoprator.Alloc = cmnMemAlloc;
+		voMemoprator.Copy = cmnMemCopy;
+		voMemoprator.Free = cmnMemFree;
+		voMemoprator.Set = cmnMemSet;
+		voMemoprator.Check = cmnMemCheck;
+
+		interMem = 1;
+
+		pMemOP = &voMemoprator;
+#else
+		*phCodec = NULL;
+		return VO_ERR_INVALID_ARG;
+#endif
+	}
+	else
+	{
+		pMemOP = (VO_MEM_OPERATOR *)pUserData->memData;
+	}
+
+	/* init the aac encoder handle */
+	hAacEnc = (AAC_ENCODER*)mem_malloc(pMemOP, sizeof(AAC_ENCODER), 32, VO_INDEX_ENC_AAC);
+	if(NULL == hAacEnc)
+	{
+		error = 1;
+	}
+
+	if(!error)
+	{
+		/* init the aac encoder intra memory */
+		hAacEnc->intbuf = (short *)mem_malloc(pMemOP, AACENC_BLOCKSIZE*MAX_CHANNELS*sizeof(short), 32, VO_INDEX_ENC_AAC);
+		if(NULL == hAacEnc->intbuf)
+		{
+			error = 1;
+		}
+	}
+
 	if (!error) {
 		/* init the aac encoder psychoacoustic */
 		error = (PsyNew(&hAacEnc->psyKernel, MAX_CHANNELS, pMemOP) ||
 			PsyOutNew(&hAacEnc->psyOut, pMemOP));
-	}
-
+	}
+
 	if (!error) {
 		/* init the aac encoder quantization elements */
 		error = QCOutNew(&hAacEnc->qcOut,MAX_CHANNELS, pMemOP);
-	}
-
+	}
+
 	if (!error) {
 		/* init the aac encoder quantization state */
 		error = QCNew(&hAacEnc->qcKernel, pMemOP);
@@ -113,383 +113,383 @@ VO_U32 VO_API voAACEncInit(VO_HANDLE * phCodec,VO_AUDIO_CODINGTYPE vType, VO_COD
 		{
 			mem_free(pMemOP, hAacEnc, VO_INDEX_ENC_AAC);
 			hAacEnc = NULL;
-		}		
+		}
 		*phCodec = NULL;
 		return VO_ERR_OUTOF_MEMORY;
-	}
-
-	/* init the aac encoder memory operator  */
-#ifdef USE_DEAULT_MEM
-	if(interMem)
-	{
-		hAacEnc->voMemoprator.Alloc = cmnMemAlloc;
-		hAacEnc->voMemoprator.Copy = cmnMemCopy;
-		hAacEnc->voMemoprator.Free = cmnMemFree;
-		hAacEnc->voMemoprator.Set = cmnMemSet;
-		hAacEnc->voMemoprator.Check = cmnMemCheck;
-
-		pMemOP = &hAacEnc->voMemoprator;
-	}
-#endif
-	/* init the aac encoder default parameter  */
-	if(hAacEnc->initOK == 0)
-	{
-		 AACENC_CONFIG config;
-		 config.adtsUsed = 1;
-		 config.bitRate = 128000;
-		 config.nChannelsIn = 2;
-		 config.nChannelsOut = 2;
-		 config.sampleRate = 44100;
-		 config.bandWidth = 20000;
-
-		 AacEncOpen(hAacEnc, config);
-	}
-
-	hAacEnc->voMemop = pMemOP;
-
-	*phCodec = hAacEnc;
-
-	return VO_ERR_NONE;
-}
-
-/**
-* Set input audio data.
-* \param hCodec [IN]] The Codec Handle which was created by Init function.
-* \param pInput [IN] The input buffer param.
-* \param pOutBuffer [OUT] The output buffer info.
-* \retval VO_ERR_NONE Succeeded.
-*/
-VO_U32 VO_API voAACEncSetInputData(VO_HANDLE hCodec, VO_CODECBUFFER * pInput)
-{
-	AAC_ENCODER *hAacEnc;
-	int  length;
-
-	if(NULL == hCodec || NULL == pInput || NULL == pInput->Buffer)
-	{
-		return VO_ERR_INVALID_ARG;
-	}
-	
-	hAacEnc = (AAC_ENCODER *)hCodec;
-	
-	/* init input pcm buffer and length*/
-	hAacEnc->inbuf = (short *)pInput->Buffer;
-	hAacEnc->inlen = pInput->Length / sizeof(short);
-	hAacEnc->uselength = 0;
-
-	hAacEnc->encbuf = hAacEnc->inbuf;
-	hAacEnc->enclen = hAacEnc->inlen;
-	
-	/* rebuild intra pcm buffer and length*/
-	if(hAacEnc->intlen)
-	{
-		length = min(hAacEnc->config.nChannelsIn*AACENC_BLOCKSIZE - hAacEnc->intlen, hAacEnc->inlen);
-		hAacEnc->voMemop->Copy(VO_INDEX_ENC_AAC, hAacEnc->intbuf + hAacEnc->intlen, 
-			hAacEnc->inbuf, length*sizeof(short));
-
-		hAacEnc->encbuf = hAacEnc->intbuf;
-		hAacEnc->enclen = hAacEnc->intlen + length;
-
-		hAacEnc->inbuf += length;
-		hAacEnc->inlen -= length;
-	}
-	
-	return VO_ERR_NONE;
-}
-
-/**
-* Get the outut audio data
-* \param hCodec [IN]] The Codec Handle which was created by Init function.
-* \param pOutBuffer [OUT] The output audio data
-* \param pOutInfo [OUT] The dec module filled audio format and used the input size.
-*						 pOutInfo->InputUsed is total used the input size.
-* \retval  VO_ERR_NONE Succeeded.
-*			VO_ERR_INPUT_BUFFER_SMALL. The input was finished or the input data was not enought.
-*/
-VO_U32 VO_API voAACEncGetOutputData(VO_HANDLE hCodec, VO_CODECBUFFER * pOutput, VO_AUDIO_OUTPUTINFO * pOutInfo)
-{
-	AAC_ENCODER* hAacEnc = (AAC_ENCODER*)hCodec;
-	Word16 numAncDataBytes=0;
-	Word32  inbuflen;
-	int ret, length;
-	if(NULL == hAacEnc)
-		return VO_ERR_INVALID_ARG;
-
-	 inbuflen = AACENC_BLOCKSIZE*hAacEnc->config.nChannelsIn;
-
-	 /* check the input pcm buffer and length*/
-	 if(NULL == hAacEnc->encbuf || hAacEnc->enclen < inbuflen)
-	 {
-		length = hAacEnc->enclen;		
-		if(hAacEnc->intlen == 0)
-		{	
-			hAacEnc->voMemop->Copy(VO_INDEX_ENC_AAC, hAacEnc->intbuf, 
-				hAacEnc->encbuf, length*sizeof(short));		
-			hAacEnc->uselength += length*sizeof(short);
-		}
-		else
-		{
-			hAacEnc->uselength += (length - hAacEnc->intlen)*sizeof(short);
-		}
-
-		hAacEnc->intlen = length;
-
-		pOutput->Length = 0;
-		if(pOutInfo)
-			pOutInfo->InputUsed = hAacEnc->uselength;
-		return VO_ERR_INPUT_BUFFER_SMALL;	
-	 }
-
-	 /* check the output aac buffer and length*/
-	 if(NULL == pOutput || NULL == pOutput->Buffer || pOutput->Length < (6144/8)*hAacEnc->config.nChannelsOut/(sizeof(Word32)))
-		 return VO_ERR_OUTPUT_BUFFER_SMALL;
-
-	 /* aac encoder core function */
-	 AacEncEncode( hAacEnc,
-			(Word16*)hAacEnc->encbuf,
-			NULL,
-			&numAncDataBytes,
-			pOutput->Buffer,
-			&pOutput->Length);
-
-	 /* update the input pcm buffer and length*/
-	 if(hAacEnc->intlen)
-	 {
-		length = inbuflen - hAacEnc->intlen;		
-		hAacEnc->encbuf = hAacEnc->inbuf;
-		hAacEnc->enclen = hAacEnc->inlen;
-		hAacEnc->uselength += length*sizeof(short);
-		hAacEnc->intlen = 0;
-	 }
-	 else
-	 {
-		 hAacEnc->encbuf = hAacEnc->encbuf + inbuflen;
-		 hAacEnc->enclen = hAacEnc->enclen - inbuflen;
-		 hAacEnc->uselength += inbuflen*sizeof(short);
-	 }	 
-
-	 /* update the output aac information */
-	if(pOutInfo)
-	{
-		pOutInfo->Format.Channels = hAacEnc->config.nChannelsOut;
-		pOutInfo->Format.SampleRate = hAacEnc->config.sampleRate;
-		pOutInfo->Format.SampleBits = 16;
-		pOutInfo->InputUsed = hAacEnc->uselength;
-	}
-
-	 return VO_ERR_NONE;
-}
-
-/**
-* Uninit the Codec.
-* \param hCodec [IN]] The Codec Handle which was created by Init function.
-* \retval VO_ERR_NONE Succeeded.
-*/
-VO_U32 VO_API voAACEncUninit(VO_HANDLE hCodec)
-{
-	AAC_ENCODER* hAacEnc = (AAC_ENCODER*)hCodec;
-	
-	if(NULL != hAacEnc)
-	{
-		/* close the aac encoder */
-		AacEncClose(hAacEnc, hAacEnc->voMemop);
-
-		/* free the aac encoder handle*/
-		mem_free(hAacEnc->voMemop, hAacEnc, VO_INDEX_ENC_AAC);
-		hAacEnc = NULL;
-	}	
-
-	return VO_ERR_NONE;
-}
-
-/**
-* Set the param for special target.
-* \param hCodec [IN]] The Codec Handle which was created by Init function.
-* \param uParamID [IN] The param ID.
-* \param pData [IN] The param value depend on the ID>
-* \retval VO_ERR_NONE Succeeded.
-*/
-VO_U32 VO_API voAACEncSetParam(VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData)
-{
-	AACENC_CONFIG config;
-	AACENC_PARAM* pAAC_param;
-	VO_AUDIO_FORMAT *pWAV_Format;
-	AAC_ENCODER* hAacEnc = (AAC_ENCODER*)hCodec;
-	int ret, i, bitrate, tmp;
-	int SampleRateIdx;
-
-	if(NULL == hAacEnc)
-		return VO_ERR_INVALID_ARG;
-	
-	switch(uParamID)
-	{
-	case VO_PID_AAC_ENCPARAM:  /* init aac encoder parameter*/
-		AacInitDefaultConfig(&config);
-		if(pData == NULL)
-			return VO_ERR_INVALID_ARG;
-		pAAC_param = (AACENC_PARAM*)pData;
-		config.adtsUsed = pAAC_param->adtsUsed;
-		config.bitRate = pAAC_param->bitRate;
-		config.nChannelsIn = pAAC_param->nChannels;
-		config.nChannelsOut = pAAC_param->nChannels;
-		config.sampleRate = pAAC_param->sampleRate;
-
-		/* check the channel */
-		if(config.nChannelsIn< 1  || config.nChannelsIn > MAX_CHANNELS  ||
-             config.nChannelsOut < 1 || config.nChannelsOut > MAX_CHANNELS || config.nChannelsIn < config.nChannelsOut)
-			 return VO_ERR_AUDIO_UNSCHANNEL;
-
-		/* check the samplerate */
-		ret = -1;
-		for(i = 0; i < NUM_SAMPLE_RATES; i++)
-		{
-			if(config.sampleRate == sampRateTab[i])
-			{
-				ret = 0;
-				break;
-			}
-		}
-		if(ret < 0)
-			return VO_ERR_AUDIO_UNSSAMPLERATE;
-
-		SampleRateIdx = i;
-
-		tmp = 441;
-		if(config.sampleRate%8000 == 0) 
-			tmp =480;
-		/* check the bitrate */
-		if(config.bitRate!=0 && (config.bitRate/config.nChannelsOut < 4000) ||
-           (config.bitRate/config.nChannelsOut > 160000) || 
-		   (config.bitRate > config.sampleRate*6*config.nChannelsOut))
-		{
-			config.bitRate = 640*config.sampleRate/tmp*config.nChannelsOut;
-
-			if(config.bitRate/config.nChannelsOut < 4000)
-				config.bitRate = 4000 * config.nChannelsOut;
-			else if(config.bitRate > config.sampleRate*6*config.nChannelsOut)
-				config.bitRate = config.sampleRate*6*config.nChannelsOut;
-			else if(config.bitRate/config.nChannelsOut > 160000)
-				config.bitRate = config.nChannelsOut*160000;
-		}
-
-		/* check the bandwidth */
-		bitrate = config.bitRate / config.nChannelsOut;
-		bitrate = bitrate * tmp / config.sampleRate;
-
-		for (i = 0; rates[i]; i++)
-		{
-			if (rates[i] >= bitrate)
-				break;
-		}
-
-		config.bandWidth = BandwithCoefTab[i][SampleRateIdx];
-
-		/* init aac encoder core */
-		ret = AacEncOpen(hAacEnc, config);
-		if(ret) 
-			return VO_ERR_AUDIO_UNSFEATURE;
-		break;
-	case VO_PID_AUDIO_FORMAT:	/* init pcm channel and samplerate*/
-		AacInitDefaultConfig(&config);
-		if(pData == NULL)
-			return VO_ERR_INVALID_ARG;
-		pWAV_Format = (VO_AUDIO_FORMAT*)pData;
-		config.adtsUsed = 1;
-		config.nChannelsIn = pWAV_Format->Channels;
-		config.nChannelsOut = pWAV_Format->Channels;
-		config.sampleRate = pWAV_Format->SampleRate;
-
-		/* check the channel */
-		if(config.nChannelsIn< 1  || config.nChannelsIn > MAX_CHANNELS  ||
-             config.nChannelsOut < 1 || config.nChannelsOut > MAX_CHANNELS || config.nChannelsIn < config.nChannelsOut)
-			 return VO_ERR_AUDIO_UNSCHANNEL;
-
-		/* check the samplebits */
-		if(pWAV_Format->SampleBits != 16)
-		{
-			return VO_ERR_AUDIO_UNSFEATURE;
-		}
-
-		/* check the samplerate */
-		ret = -1;
-		for(i = 0; i < NUM_SAMPLE_RATES; i++)
-		{
-			if(config.sampleRate == sampRateTab[i])
-			{
-				ret = 0;
-				break;
-			}
-		}
-		if(ret < 0)
-			return VO_ERR_AUDIO_UNSSAMPLERATE;
-
-		SampleRateIdx = i;
-
-		/* update the bitrates */
-		tmp = 441;
-		if(config.sampleRate%8000 == 0) 
-			tmp =480;
-
-		config.bitRate = 640*config.sampleRate/tmp*config.nChannelsOut;
-
-		if(config.bitRate/config.nChannelsOut < 4000)
-			config.bitRate = 4000 * config.nChannelsOut;
-		else if(config.bitRate > config.sampleRate*6*config.nChannelsOut)
-			config.bitRate = config.sampleRate*6*config.nChannelsOut;
-		else if(config.bitRate/config.nChannelsOut > 160000)
-			config.bitRate = config.nChannelsOut*160000;
-
-		/* check the bandwidth */
-		bitrate = config.bitRate / config.nChannelsOut;
-		bitrate = bitrate * tmp / config.sampleRate;
-
-		for (i = 0; rates[i]; i++)
-		{
-			if (rates[i] >= bitrate)
-				break;
-		}
-
-		config.bandWidth = BandwithCoefTab[i][SampleRateIdx];
-		
-		/* init aac encoder core */
-		ret = AacEncOpen(hAacEnc, config);
-		if(ret) 
-			return VO_ERR_AUDIO_UNSFEATURE;
-		break;
-	default:
-		return VO_ERR_WRONG_PARAM_ID;
-	}
-
-	return VO_ERR_NONE;
-}
-
-/**
-* Get the param for special target.
-* \param hCodec [IN]] The Codec Handle which was created by Init function.
-* \param uParamID [IN] The param ID.
-* \param pData [IN] The param value depend on the ID>
-* \retval VO_ERR_NONE Succeeded.
-*/
-VO_U32 VO_API voAACEncGetParam(VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData)
-{
-	return VO_ERR_NONE;
-}
-
-/**
- * Get audio codec API interface
- * \param pEncHandle [out] Return the AAC Encoder handle.
- * \retval VO_ERR_OK Succeeded.
- */
-VO_S32 VO_API voGetAACEncAPI(VO_AUDIO_CODECAPI * pDecHandle)
-{
-	if(pDecHandle == NULL)
-		return VO_ERR_INVALID_ARG;
-		
-	pDecHandle->Init = voAACEncInit;
-	pDecHandle->SetInputData = voAACEncSetInputData;
-	pDecHandle->GetOutputData = voAACEncGetOutputData;
-	pDecHandle->SetParam = voAACEncSetParam;
-	pDecHandle->GetParam = voAACEncGetParam;
-	pDecHandle->Uninit = voAACEncUninit;
-
-	return VO_ERR_NONE;
+	}
+
+	/* init the aac encoder memory operator  */
+#ifdef USE_DEAULT_MEM
+	if(interMem)
+	{
+		hAacEnc->voMemoprator.Alloc = cmnMemAlloc;
+		hAacEnc->voMemoprator.Copy = cmnMemCopy;
+		hAacEnc->voMemoprator.Free = cmnMemFree;
+		hAacEnc->voMemoprator.Set = cmnMemSet;
+		hAacEnc->voMemoprator.Check = cmnMemCheck;
+
+		pMemOP = &hAacEnc->voMemoprator;
+	}
+#endif
+	/* init the aac encoder default parameter  */
+	if(hAacEnc->initOK == 0)
+	{
+		 AACENC_CONFIG config;
+		 config.adtsUsed = 1;
+		 config.bitRate = 128000;
+		 config.nChannelsIn = 2;
+		 config.nChannelsOut = 2;
+		 config.sampleRate = 44100;
+		 config.bandWidth = 20000;
+
+		 AacEncOpen(hAacEnc, config);
+	}
+
+	hAacEnc->voMemop = pMemOP;
+
+	*phCodec = hAacEnc;
+
+	return VO_ERR_NONE;
+}
+
+/**
+* Set input audio data.
+* \param hCodec [IN]] The Codec Handle which was created by Init function.
+* \param pInput [IN] The input buffer param.
+* \param pOutBuffer [OUT] The output buffer info.
+* \retval VO_ERR_NONE Succeeded.
+*/
+VO_U32 VO_API voAACEncSetInputData(VO_HANDLE hCodec, VO_CODECBUFFER * pInput)
+{
+	AAC_ENCODER *hAacEnc;
+	int  length;
+
+	if(NULL == hCodec || NULL == pInput || NULL == pInput->Buffer)
+	{
+		return VO_ERR_INVALID_ARG;
+	}
+
+	hAacEnc = (AAC_ENCODER *)hCodec;
+
+	/* init input pcm buffer and length*/
+	hAacEnc->inbuf = (short *)pInput->Buffer;
+	hAacEnc->inlen = pInput->Length / sizeof(short);
+	hAacEnc->uselength = 0;
+
+	hAacEnc->encbuf = hAacEnc->inbuf;
+	hAacEnc->enclen = hAacEnc->inlen;
+
+	/* rebuild intra pcm buffer and length*/
+	if(hAacEnc->intlen)
+	{
+		length = min(hAacEnc->config.nChannelsIn*AACENC_BLOCKSIZE - hAacEnc->intlen, hAacEnc->inlen);
+		hAacEnc->voMemop->Copy(VO_INDEX_ENC_AAC, hAacEnc->intbuf + hAacEnc->intlen,
+			hAacEnc->inbuf, length*sizeof(short));
+
+		hAacEnc->encbuf = hAacEnc->intbuf;
+		hAacEnc->enclen = hAacEnc->intlen + length;
+
+		hAacEnc->inbuf += length;
+		hAacEnc->inlen -= length;
+	}
+
+	return VO_ERR_NONE;
+}
+
+/**
+* Get the outut audio data
+* \param hCodec [IN]] The Codec Handle which was created by Init function.
+* \param pOutBuffer [OUT] The output audio data
+* \param pOutInfo [OUT] The dec module filled audio format and used the input size.
+*						 pOutInfo->InputUsed is total used the input size.
+* \retval  VO_ERR_NONE Succeeded.
+*			VO_ERR_INPUT_BUFFER_SMALL. The input was finished or the input data was not enought.
+*/
+VO_U32 VO_API voAACEncGetOutputData(VO_HANDLE hCodec, VO_CODECBUFFER * pOutput, VO_AUDIO_OUTPUTINFO * pOutInfo)
+{
+	AAC_ENCODER* hAacEnc = (AAC_ENCODER*)hCodec;
+	Word16 numAncDataBytes=0;
+	Word32  inbuflen;
+	int ret, length;
+	if(NULL == hAacEnc)
+		return VO_ERR_INVALID_ARG;
+
+	 inbuflen = AACENC_BLOCKSIZE*hAacEnc->config.nChannelsIn;
+
+	 /* check the input pcm buffer and length*/
+	 if(NULL == hAacEnc->encbuf || hAacEnc->enclen < inbuflen)
+	 {
+		length = hAacEnc->enclen;
+		if(hAacEnc->intlen == 0)
+		{
+			hAacEnc->voMemop->Copy(VO_INDEX_ENC_AAC, hAacEnc->intbuf,
+				hAacEnc->encbuf, length*sizeof(short));
+			hAacEnc->uselength += length*sizeof(short);
+		}
+		else
+		{
+			hAacEnc->uselength += (length - hAacEnc->intlen)*sizeof(short);
+		}
+
+		hAacEnc->intlen = length;
+
+		pOutput->Length = 0;
+		if(pOutInfo)
+			pOutInfo->InputUsed = hAacEnc->uselength;
+		return VO_ERR_INPUT_BUFFER_SMALL;
+	 }
+
+	 /* check the output aac buffer and length*/
+	 if(NULL == pOutput || NULL == pOutput->Buffer || pOutput->Length < (6144/8)*hAacEnc->config.nChannelsOut/(sizeof(Word32)))
+		 return VO_ERR_OUTPUT_BUFFER_SMALL;
+
+	 /* aac encoder core function */
+	 AacEncEncode( hAacEnc,
+			(Word16*)hAacEnc->encbuf,
+			NULL,
+			&numAncDataBytes,
+			pOutput->Buffer,
+			&pOutput->Length);
+
+	 /* update the input pcm buffer and length*/
+	 if(hAacEnc->intlen)
+	 {
+		length = inbuflen - hAacEnc->intlen;
+		hAacEnc->encbuf = hAacEnc->inbuf;
+		hAacEnc->enclen = hAacEnc->inlen;
+		hAacEnc->uselength += length*sizeof(short);
+		hAacEnc->intlen = 0;
+	 }
+	 else
+	 {
+		 hAacEnc->encbuf = hAacEnc->encbuf + inbuflen;
+		 hAacEnc->enclen = hAacEnc->enclen - inbuflen;
+		 hAacEnc->uselength += inbuflen*sizeof(short);
+	 }
+
+	 /* update the output aac information */
+	if(pOutInfo)
+	{
+		pOutInfo->Format.Channels = hAacEnc->config.nChannelsOut;
+		pOutInfo->Format.SampleRate = hAacEnc->config.sampleRate;
+		pOutInfo->Format.SampleBits = 16;
+		pOutInfo->InputUsed = hAacEnc->uselength;
+	}
+
+	 return VO_ERR_NONE;
+}
+
+/**
+* Uninit the Codec.
+* \param hCodec [IN]] The Codec Handle which was created by Init function.
+* \retval VO_ERR_NONE Succeeded.
+*/
+VO_U32 VO_API voAACEncUninit(VO_HANDLE hCodec)
+{
+	AAC_ENCODER* hAacEnc = (AAC_ENCODER*)hCodec;
+
+	if(NULL != hAacEnc)
+	{
+		/* close the aac encoder */
+		AacEncClose(hAacEnc, hAacEnc->voMemop);
+
+		/* free the aac encoder handle*/
+		mem_free(hAacEnc->voMemop, hAacEnc, VO_INDEX_ENC_AAC);
+		hAacEnc = NULL;
+	}
+
+	return VO_ERR_NONE;
+}
+
+/**
+* Set the param for special target.
+* \param hCodec [IN]] The Codec Handle which was created by Init function.
+* \param uParamID [IN] The param ID.
+* \param pData [IN] The param value depend on the ID>
+* \retval VO_ERR_NONE Succeeded.
+*/
+VO_U32 VO_API voAACEncSetParam(VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData)
+{
+	AACENC_CONFIG config;
+	AACENC_PARAM* pAAC_param;
+	VO_AUDIO_FORMAT *pWAV_Format;
+	AAC_ENCODER* hAacEnc = (AAC_ENCODER*)hCodec;
+	int ret, i, bitrate, tmp;
+	int SampleRateIdx;
+
+	if(NULL == hAacEnc)
+		return VO_ERR_INVALID_ARG;
+
+	switch(uParamID)
+	{
+	case VO_PID_AAC_ENCPARAM:  /* init aac encoder parameter*/
+		AacInitDefaultConfig(&config);
+		if(pData == NULL)
+			return VO_ERR_INVALID_ARG;
+		pAAC_param = (AACENC_PARAM*)pData;
+		config.adtsUsed = pAAC_param->adtsUsed;
+		config.bitRate = pAAC_param->bitRate;
+		config.nChannelsIn = pAAC_param->nChannels;
+		config.nChannelsOut = pAAC_param->nChannels;
+		config.sampleRate = pAAC_param->sampleRate;
+
+		/* check the channel */
+		if(config.nChannelsIn< 1  || config.nChannelsIn > MAX_CHANNELS  ||
+             config.nChannelsOut < 1 || config.nChannelsOut > MAX_CHANNELS || config.nChannelsIn < config.nChannelsOut)
+			 return VO_ERR_AUDIO_UNSCHANNEL;
+
+		/* check the samplerate */
+		ret = -1;
+		for(i = 0; i < NUM_SAMPLE_RATES; i++)
+		{
+			if(config.sampleRate == sampRateTab[i])
+			{
+				ret = 0;
+				break;
+			}
+		}
+		if(ret < 0)
+			return VO_ERR_AUDIO_UNSSAMPLERATE;
+
+		SampleRateIdx = i;
+
+		tmp = 441;
+		if(config.sampleRate%8000 == 0)
+			tmp =480;
+		/* check the bitrate */
+		if(config.bitRate!=0 && (config.bitRate/config.nChannelsOut < 4000) ||
+           (config.bitRate/config.nChannelsOut > 160000) ||
+		   (config.bitRate > config.sampleRate*6*config.nChannelsOut))
+		{
+			config.bitRate = 640*config.sampleRate/tmp*config.nChannelsOut;
+
+			if(config.bitRate/config.nChannelsOut < 4000)
+				config.bitRate = 4000 * config.nChannelsOut;
+			else if(config.bitRate > config.sampleRate*6*config.nChannelsOut)
+				config.bitRate = config.sampleRate*6*config.nChannelsOut;
+			else if(config.bitRate/config.nChannelsOut > 160000)
+				config.bitRate = config.nChannelsOut*160000;
+		}
+
+		/* check the bandwidth */
+		bitrate = config.bitRate / config.nChannelsOut;
+		bitrate = bitrate * tmp / config.sampleRate;
+
+		for (i = 0; rates[i]; i++)
+		{
+			if (rates[i] >= bitrate)
+				break;
+		}
+
+		config.bandWidth = BandwithCoefTab[i][SampleRateIdx];
+
+		/* init aac encoder core */
+		ret = AacEncOpen(hAacEnc, config);
+		if(ret)
+			return VO_ERR_AUDIO_UNSFEATURE;
+		break;
+	case VO_PID_AUDIO_FORMAT:	/* init pcm channel and samplerate*/
+		AacInitDefaultConfig(&config);
+		if(pData == NULL)
+			return VO_ERR_INVALID_ARG;
+		pWAV_Format = (VO_AUDIO_FORMAT*)pData;
+		config.adtsUsed = 1;
+		config.nChannelsIn = pWAV_Format->Channels;
+		config.nChannelsOut = pWAV_Format->Channels;
+		config.sampleRate = pWAV_Format->SampleRate;
+
+		/* check the channel */
+		if(config.nChannelsIn< 1  || config.nChannelsIn > MAX_CHANNELS  ||
+             config.nChannelsOut < 1 || config.nChannelsOut > MAX_CHANNELS || config.nChannelsIn < config.nChannelsOut)
+			 return VO_ERR_AUDIO_UNSCHANNEL;
+
+		/* check the samplebits */
+		if(pWAV_Format->SampleBits != 16)
+		{
+			return VO_ERR_AUDIO_UNSFEATURE;
+		}
+
+		/* check the samplerate */
+		ret = -1;
+		for(i = 0; i < NUM_SAMPLE_RATES; i++)
+		{
+			if(config.sampleRate == sampRateTab[i])
+			{
+				ret = 0;
+				break;
+			}
+		}
+		if(ret < 0)
+			return VO_ERR_AUDIO_UNSSAMPLERATE;
+
+		SampleRateIdx = i;
+
+		/* update the bitrates */
+		tmp = 441;
+		if(config.sampleRate%8000 == 0)
+			tmp =480;
+
+		config.bitRate = 640*config.sampleRate/tmp*config.nChannelsOut;
+
+		if(config.bitRate/config.nChannelsOut < 4000)
+			config.bitRate = 4000 * config.nChannelsOut;
+		else if(config.bitRate > config.sampleRate*6*config.nChannelsOut)
+			config.bitRate = config.sampleRate*6*config.nChannelsOut;
+		else if(config.bitRate/config.nChannelsOut > 160000)
+			config.bitRate = config.nChannelsOut*160000;
+
+		/* check the bandwidth */
+		bitrate = config.bitRate / config.nChannelsOut;
+		bitrate = bitrate * tmp / config.sampleRate;
+
+		for (i = 0; rates[i]; i++)
+		{
+			if (rates[i] >= bitrate)
+				break;
+		}
+
+		config.bandWidth = BandwithCoefTab[i][SampleRateIdx];
+
+		/* init aac encoder core */
+		ret = AacEncOpen(hAacEnc, config);
+		if(ret)
+			return VO_ERR_AUDIO_UNSFEATURE;
+		break;
+	default:
+		return VO_ERR_WRONG_PARAM_ID;
+	}
+
+	return VO_ERR_NONE;
+}
+
+/**
+* Get the param for special target.
+* \param hCodec [IN]] The Codec Handle which was created by Init function.
+* \param uParamID [IN] The param ID.
+* \param pData [IN] The param value depend on the ID>
+* \retval VO_ERR_NONE Succeeded.
+*/
+VO_U32 VO_API voAACEncGetParam(VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData)
+{
+	return VO_ERR_NONE;
+}
+
+/**
+ * Get audio codec API interface
+ * \param pEncHandle [out] Return the AAC Encoder handle.
+ * \retval VO_ERR_OK Succeeded.
+ */
+VO_S32 VO_API voGetAACEncAPI(VO_AUDIO_CODECAPI * pDecHandle)
+{
+	if(pDecHandle == NULL)
+		return VO_ERR_INVALID_ARG;
+
+	pDecHandle->Init = voAACEncInit;
+	pDecHandle->SetInputData = voAACEncSetInputData;
+	pDecHandle->GetOutputData = voAACEncGetOutputData;
+	pDecHandle->SetParam = voAACEncSetParam;
+	pDecHandle->GetParam = voAACEncGetParam;
+	pDecHandle->Uninit = voAACEncUninit;
+
+	return VO_ERR_NONE;
 }
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/aacenc_core.c b/media/libstagefright/codecs/aacenc/src/aacenc_core.c
index 616475c..2b3bd48 100644
--- a/media/libstagefright/codecs/aacenc/src/aacenc_core.c
+++ b/media/libstagefright/codecs/aacenc/src/aacenc_core.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		aacenc_core.c
-
-	Content:	aac encoder core functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		aacenc_core.c
+
+	Content:	aac encoder core functions
+
 *******************************************************************************/
 
 #include "typedef.h"
@@ -43,8 +43,8 @@ void AacInitDefaultConfig(AACENC_CONFIG *config)
   config->adtsUsed        = 1;
   config->nChannelsIn     = 2;
   config->nChannelsOut    = 2;
-  config->bitRate         = 128000;                      
-  config->bandWidth       = 0;                           
+  config->bitRate         = 128000;
+  config->bandWidth       = 0;
 }
 
 /********************************************************************************
@@ -58,16 +58,16 @@ Word16  AacEncOpen(  AAC_ENCODER*      hAacEnc,        /* pointer to an encoder
                      const  AACENC_CONFIG     config   /* pre-initialized config struct */
                      )
 {
-  Word32 i;
+  Word32 i;
   Word32 error = 0;
-  Word16 profile = 1;
+  Word16 profile = 1;
 
   ELEMENT_INFO *elInfo = NULL;
-   
+
   if (hAacEnc==0) {
-    error=1;                                  
+    error=1;
   }
-   
+
   if (!error) {
     hAacEnc->config = config;
   }
@@ -76,14 +76,14 @@ Word16  AacEncOpen(  AAC_ENCODER*      hAacEnc,        /* pointer to an encoder
     error = InitElementInfo (config.nChannelsOut,
                              &hAacEnc->elInfo);
   }
-
+
   if (!error) {
     elInfo = &hAacEnc->elInfo;
   }
 
   if (!error) {
     /* use or not tns tool for long and short block */
-	 Word16 tnsMask=3;      
+	 Word16 tnsMask=3;
 
 	/* init encoder psychoacoustic */
     error = psyMainInit(&hAacEnc->psyKernel,
@@ -95,8 +95,8 @@ Word16  AacEncOpen(  AAC_ENCODER*      hAacEnc,        /* pointer to an encoder
   }
 
  /* use or not adts header */
-  if(!error) {
-	  hAacEnc->qcOut.qcElement.adtsUsed = config.adtsUsed;
+  if(!error) {
+	  hAacEnc->qcOut.qcElement.adtsUsed = config.adtsUsed;
   }
 
   /* init encoder quantization */
@@ -107,10 +107,10 @@ Word16  AacEncOpen(  AAC_ENCODER*      hAacEnc,        /* pointer to an encoder
     qcInit.elInfo = &hAacEnc->elInfo;
 
     qcInit.maxBits = (Word16) (MAXBITS_COEF*elInfo->nChannelsInEl);
-    qcInit.bitRes = qcInit.maxBits;                                      
+    qcInit.bitRes = qcInit.maxBits;
     qcInit.averageBits = (Word16) ((config.bitRate * FRAME_LEN_LONG) / config.sampleRate);
 
-    qcInit.padding.paddingRest = config.sampleRate;                          
+    qcInit.padding.paddingRest = config.sampleRate;
 
     qcInit.meanPe = (Word16) ((10 * FRAME_LEN_LONG * hAacEnc->config.bandWidth) /
                                               (config.sampleRate>>1));
@@ -118,17 +118,17 @@ Word16  AacEncOpen(  AAC_ENCODER*      hAacEnc,        /* pointer to an encoder
     qcInit.maxBitFac = (Word16) ((100 * (MAXBITS_COEF-MINBITS_COEF)* elInfo->nChannelsInEl)/
                                                  (qcInit.averageBits?qcInit.averageBits:1));
 
-    qcInit.bitrate = config.bitRate;                                     
+    qcInit.bitrate = config.bitRate;
 
     error = QCInit(&hAacEnc->qcKernel, &qcInit);
   }
 
   /* init bitstream encoder */
   if (!error) {
-    hAacEnc->bseInit.nChannels   = elInfo->nChannelsInEl;                
-    hAacEnc->bseInit.bitrate     = config.bitRate;                       
-    hAacEnc->bseInit.sampleRate  = config.sampleRate;                    
-    hAacEnc->bseInit.profile     = profile;                              
+    hAacEnc->bseInit.nChannels   = elInfo->nChannelsInEl;
+    hAacEnc->bseInit.bitrate     = config.bitRate;
+    hAacEnc->bseInit.sampleRate  = config.sampleRate;
+    hAacEnc->bseInit.profile     = profile;
   }
 
   return error;
@@ -152,14 +152,14 @@ Word16 AacEncEncode(AAC_ENCODER *aacEnc,		/*!< an encoder handle */
   ELEMENT_INFO *elInfo = &aacEnc->elInfo;
   Word16 globUsedBits;
   Word16 ancDataBytes, ancDataBytesLeft;
-  
-  ancDataBytes = ancDataBytesLeft = *numAncBytes;                          
+
+  ancDataBytes = ancDataBytesLeft = *numAncBytes;
 
   /* init output aac data buffer and length */
   aacEnc->hBitStream = CreateBitBuffer(&aacEnc->bitStream, outBytes, *numOutBytes);
 
   /* psychoacoustic process */
-  psyMain(aacEnc->config.nChannelsOut,    
+  psyMain(aacEnc->config.nChannelsOut,
           elInfo,
           timeSignal,
           &aacEnc->psyKernel.psyData[elInfo->ChannelIndex[0]],
@@ -175,9 +175,9 @@ Word16 AacEncEncode(AAC_ENCODER *aacEnc,		/*!< an encoder handle */
   AdjustBitrate(&aacEnc->qcKernel,
                 aacEnc->config.bitRate,
                 aacEnc->config.sampleRate);
-    
+
   /* quantization and coding process */
-  QCMain(&aacEnc->qcKernel,         
+  QCMain(&aacEnc->qcKernel,
          &aacEnc->qcKernel.elementBits,
          &aacEnc->qcKernel.adjThr.adjThrStateElem,
          &aacEnc->psyOut.psyOutChannel[elInfo->ChannelIndex[0]],
@@ -193,19 +193,19 @@ Word16 AacEncEncode(AAC_ENCODER *aacEnc,		/*!< an encoder handle */
                          &aacEnc->qcOut);
 
   /* write bitstream process */
-  WriteBitstream(aacEnc->hBitStream,				 
+  WriteBitstream(aacEnc->hBitStream,
                  *elInfo,
                  &aacEnc->qcOut,
                  &aacEnc->psyOut,
-                 &globUsedBits,				 
-                 ancBytes,
+                 &globUsedBits,
+                 ancBytes,
 				 aacEnc->psyKernel.sampleRateIdx);
 
   updateBitres(&aacEnc->qcKernel,
                &aacEnc->qcOut);
 
   /* write out the bitstream */
-  *numOutBytes = GetBitsAvail(aacEnc->hBitStream) >> 3;
+  *numOutBytes = GetBitsAvail(aacEnc->hBitStream) >> 3;
 
   return 0;
 }
@@ -219,7 +219,7 @@ Word16 AacEncEncode(AAC_ENCODER *aacEnc,		/*!< an encoder handle */
 **********************************************************************************/
 void AacEncClose (AAC_ENCODER* hAacEnc, VO_MEM_OPERATOR *pMemOP)
 {
-  if (hAacEnc) {  
+  if (hAacEnc) {
     QCDelete(&hAacEnc->qcKernel, pMemOP);
 
     QCOutDelete(&hAacEnc->qcOut, pMemOP);
diff --git a/media/libstagefright/codecs/aacenc/src/adj_thr.c b/media/libstagefright/codecs/aacenc/src/adj_thr.c
index 0dbd216..c656f65 100644
--- a/media/libstagefright/codecs/aacenc/src/adj_thr.c
+++ b/media/libstagefright/codecs/aacenc/src/adj_thr.c
@@ -1,26 +1,26 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		adj_thr.c
-
-	Content:	Threshold compensation functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		adj_thr.c
+
+	Content:	Threshold compensation functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "adj_thr_data.h"
 #include "adj_thr.h"
@@ -29,14 +29,14 @@
 
 
 #define  minSnrLimit    0x6666 /* 1 dB */
-#define  PEBITS_COEF	0x170a /* 0.18*(1 << 15)*/
-
-#define  HOLE_THR_LONG	0x2873	/* 0.316*(1 << 15) */
-#define  HOLE_THR_SHORT 0x4000  /* 0.5  *(1 << 15) */
-
-#define  MS_THRSPREAD_COEF 0x7333  /* 0.9 * (1 << 15) */
-
-#define	 MIN_SNR_COEF	   0x651f  /* 3.16* (1 << (15 - 2)) */
+#define  PEBITS_COEF	0x170a /* 0.18*(1 << 15)*/
+
+#define  HOLE_THR_LONG	0x2873	/* 0.316*(1 << 15) */
+#define  HOLE_THR_SHORT 0x4000  /* 0.5  *(1 << 15) */
+
+#define  MS_THRSPREAD_COEF 0x7333  /* 0.9 * (1 << 15) */
+
+#define	 MIN_SNR_COEF	   0x651f  /* 3.16* (1 << (15 - 2)) */
 
 /* values for avoid hole flag */
 enum _avoid_hole_state {
@@ -67,15 +67,15 @@ static void calcThreshExp(Word32 thrExp[MAX_CHANNELS][MAX_GROUPED_SFB],
                           PSY_OUT_CHANNEL psyOutChannel[MAX_CHANNELS],
                           const Word16 nChannels)
 {
-  Word16 ch, sfb, sfbGrp;
+  Word16 ch, sfb, sfbGrp;
   Word32 *pthrExp, *psfbThre;
   for (ch=0; ch<nChannels; ch++) {
-    PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
-	 for(sfbGrp = 0; sfbGrp < psyOutChan->sfbCnt; sfbGrp+= psyOutChan->sfbPerGroup)	 
-	  pthrExp = &(thrExp[ch][sfbGrp]);
-	  psfbThre = psyOutChan->sfbThreshold + sfbGrp;
+    PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
+	 for(sfbGrp = 0; sfbGrp < psyOutChan->sfbCnt; sfbGrp+= psyOutChan->sfbPerGroup)
+	  pthrExp = &(thrExp[ch][sfbGrp]);
+	  psfbThre = psyOutChan->sfbThreshold + sfbGrp;
 	  for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-		*pthrExp = rsqrt(rsqrt(*psfbThre,INT_BITS),INT_BITS);
+		*pthrExp = rsqrt(rsqrt(*psfbThre,INT_BITS),INT_BITS);
 		pthrExp++; psfbThre++;
       }
   }
@@ -96,29 +96,29 @@ static void adaptMinSnr(PSY_OUT_CHANNEL     psyOutChannel[MAX_CHANNELS],
   Word32 nSfb, avgEn;
   Word16 log_avgEn = 0;
   Word32 startRatio_x_avgEn = 0;
-                                                                           
+
 
   for (ch=0; ch<nChannels; ch++) {
     PSY_OUT_CHANNEL* psyOutChan = &psyOutChannel[ch];
 
     /* calc average energy per scalefactor band */
-    avgEn = 0;                                                           
-    nSfb = 0;                                                            
+    avgEn = 0;
+    nSfb = 0;
     for (sfbOffs=0; sfbOffs<psyOutChan->sfbCnt; sfbOffs+=psyOutChan->sfbPerGroup) {
       for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
         avgEn = L_add(avgEn, psyOutChan->sfbEnergy[sfbOffs+sfb]);
         nSfb = nSfb + 1;
       }
     }
-     
+
     if (nSfb > 0) {
-	  avgEn = avgEn / nSfb;
+	  avgEn = avgEn / nSfb;
 
       log_avgEn = iLog4(avgEn);
       startRatio_x_avgEn = fixmul(msaParam->startRatio, avgEn);
     }
 
-    
+
     /* reduce minSnr requirement by minSnr^minSnrRed dependent on avgEn/sfbEn */
     for (sfbOffs=0; sfbOffs<psyOutChan->sfbCnt; sfbOffs+=psyOutChan->sfbPerGroup) {
       for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
@@ -126,22 +126,22 @@ static void adaptMinSnr(PSY_OUT_CHANNEL     psyOutChannel[MAX_CHANNELS],
           Word16 dbRatio, minSnrRed;
           Word32 snrRed;
           Word16 newMinSnr;
-          
+
           dbRatio = log_avgEn - logSfbEnergy[ch][sfbOffs+sfb];
           dbRatio = dbRatio + (dbRatio << 1);
 
           minSnrRed = 110 - ((dbRatio + (dbRatio << 1)) >> 2);
-          minSnrRed = max(minSnrRed, 20); /* 110: (0.375(redOffs)+1)*80,  
+          minSnrRed = max(minSnrRed, 20); /* 110: (0.375(redOffs)+1)*80,
                                                3: 0.00375(redRatioFac)*80
                                                20: 0.25(maxRed) * 80 */
 
-          snrRed = minSnrRed * iLog4((psyOutChan->sfbMinSnr[sfbOffs+sfb] << 16)); 
-          /* 
+          snrRed = minSnrRed * iLog4((psyOutChan->sfbMinSnr[sfbOffs+sfb] << 16));
+          /*
              snrRedI si now scaled by 80 (minSnrRed) and 4 (ffr_iLog4)
           */
-        
+
           newMinSnr = round16(pow2_xy(snrRed,80*4));
-         
+
           psyOutChan->sfbMinSnr[sfbOffs+sfb] = min(newMinSnr, minSnrLimit);
         }
       }
@@ -169,21 +169,21 @@ static void initAvoidHoleFlag(Word16 ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
 
   for (ch=0; ch<nChannels; ch++) {
     PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
-     
+
     if (psyOutChan->windowSequence != SHORT_WINDOW) {
       for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
-         psfbSpreadEn = psyOutChan->sfbSpreadedEnergy + sfbGrp;
+         psfbSpreadEn = psyOutChan->sfbSpreadedEnergy + sfbGrp;
 		 for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-			*psfbSpreadEn = *psfbSpreadEn >> 1;  /* 0.5 */
+			*psfbSpreadEn = *psfbSpreadEn >> 1;  /* 0.5 */
 			++psfbSpreadEn;
         }
       }
     }
     else {
-      for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
+      for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
 		psfbSpreadEn = psyOutChan->sfbSpreadedEnergy + sfbGrp;
         for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-          *psfbSpreadEn = (*psfbSpreadEn >> 1) + (*psfbSpreadEn >> 3);  /* 0.63 */
+          *psfbSpreadEn = (*psfbSpreadEn >> 1) + (*psfbSpreadEn >> 3);  /* 0.63 */
 		  ++psfbSpreadEn;
         }
       }
@@ -194,55 +194,55 @@ static void initAvoidHoleFlag(Word16 ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
   if (ahParam->modifyMinSnr) {
     for(ch=0; ch<nChannels; ch++) {
       PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
-         
+
       if (psyOutChan->windowSequence != SHORT_WINDOW)
         threshold = HOLE_THR_LONG;
       else
         threshold = HOLE_THR_SHORT;
 
       for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
-        Word16 *psfbMinSnr = psyOutChan->sfbMinSnr + sfbGrp;
+        Word16 *psfbMinSnr = psyOutChan->sfbMinSnr + sfbGrp;
 		for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
           Word32 sfbEn, sfbEnm1, sfbEnp1, avgEn;
-             
+
           if (sfb > 0)
             sfbEnm1 = psyOutChan->sfbEnergy[sfbGrp+sfb-1];
           else
             sfbEnm1 = psyOutChan->sfbEnergy[sfbGrp];
-             
+
           if (sfb < (psyOutChan->maxSfbPerGroup-1))
             sfbEnp1 = psyOutChan->sfbEnergy[sfbGrp+sfb+1];
           else
             sfbEnp1 = psyOutChan->sfbEnergy[sfbGrp+sfb];
           avgEn = (sfbEnm1 + sfbEnp1) >> 1;
-          sfbEn = psyOutChan->sfbEnergy[sfbGrp+sfb];                             
-             
+          sfbEn = psyOutChan->sfbEnergy[sfbGrp+sfb];
+
           if (sfbEn > avgEn && avgEn > 0) {
             Word32 tmpMinSnr;
-            shift = norm_l(sfbEn);
+            shift = norm_l(sfbEn);
 			tmpMinSnr = Div_32(L_mpy_ls(avgEn, minSnrLimit) << shift, sfbEn << shift );
-            tmpMinSnr = max(tmpMinSnr, HOLE_THR_LONG);                  
+            tmpMinSnr = max(tmpMinSnr, HOLE_THR_LONG);
             tmpMinSnr = max(tmpMinSnr, threshold);
             *psfbMinSnr = min(*psfbMinSnr, tmpMinSnr);
           }
           /* valley ? */
-             
+
           if ((sfbEn < (avgEn >> 1)) && (sfbEn > 0)) {
             Word32 tmpMinSnr;
-            Word32 minSnrEn = L_mpy_wx(avgEn, *psfbMinSnr);                 
-             
-            if(minSnrEn < sfbEn) {
+            Word32 minSnrEn = L_mpy_wx(avgEn, *psfbMinSnr);
+
+            if(minSnrEn < sfbEn) {
 			  shift = norm_l(sfbEn);
               tmpMinSnr = Div_32( minSnrEn << shift, sfbEn<<shift);
             }
             else {
-              tmpMinSnr = MAX_16;                                             
+              tmpMinSnr = MAX_16;
             }
             tmpMinSnr = min(minSnrLimit, tmpMinSnr);
 
             *psfbMinSnr =
               (min((tmpMinSnr >>  2), mult(*psfbMinSnr, MIN_SNR_COEF)) << 2);
-          }
+          }
 		  psfbMinSnr++;
         }
       }
@@ -251,7 +251,7 @@ static void initAvoidHoleFlag(Word16 ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
 
   /* stereo: adapt the minimum requirements sfbMinSnr of mid and
      side channels */
-   
+
   if (nChannels == 2) {
     PSY_OUT_CHANNEL *psyOutChanM = &psyOutChannel[0];
     PSY_OUT_CHANNEL *psyOutChanS = &psyOutChannel[1];
@@ -260,30 +260,30 @@ static void initAvoidHoleFlag(Word16 ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
         Word32 sfbEnM = psyOutChanM->sfbEnergy[sfb];
         Word32 sfbEnS = psyOutChanS->sfbEnergy[sfb];
         Word32 maxSfbEn = max(sfbEnM, sfbEnS);
-        Word32 maxThr = L_mpy_wx(maxSfbEn, psyOutChanM->sfbMinSnr[sfb]) >> 1;        
-         
+        Word32 maxThr = L_mpy_wx(maxSfbEn, psyOutChanM->sfbMinSnr[sfb]) >> 1;
+
         if(maxThr >= sfbEnM) {
-          psyOutChanM->sfbMinSnr[sfb] = MAX_16;                                          
+          psyOutChanM->sfbMinSnr[sfb] = MAX_16;
         }
         else {
-          shift = norm_l(sfbEnM); 
-		  psyOutChanM->sfbMinSnr[sfb] = min(max(psyOutChanM->sfbMinSnr[sfb], 
+          shift = norm_l(sfbEnM);
+		  psyOutChanM->sfbMinSnr[sfb] = min(max(psyOutChanM->sfbMinSnr[sfb],
 			  round16(Div_32(maxThr<<shift, sfbEnM << shift))), minSnrLimit);
         }
-         
+
         if(maxThr >= sfbEnS) {
           psyOutChanS->sfbMinSnr[sfb] = MAX_16;
         }
-        else {
+        else {
 		  shift = norm_l(sfbEnS);
-          psyOutChanS->sfbMinSnr[sfb] = min(max(psyOutChanS->sfbMinSnr[sfb], 
+          psyOutChanS->sfbMinSnr[sfb] = min(max(psyOutChanS->sfbMinSnr[sfb],
 			  round16(Div_32(maxThr << shift, sfbEnS << shift))), minSnrLimit);
         }
 
-         
+
         if (sfbEnM > psyOutChanM->sfbSpreadedEnergy[sfb])
           psyOutChanS->sfbSpreadedEnergy[sfb] = L_mpy_ls(sfbEnS, MS_THRSPREAD_COEF);
-         
+
         if (sfbEnS > psyOutChanS->sfbSpreadedEnergy[sfb])
           psyOutChanM->sfbSpreadedEnergy[sfb] = L_mpy_ls(sfbEnM, MS_THRSPREAD_COEF);
       }
@@ -295,9 +295,9 @@ static void initAvoidHoleFlag(Word16 ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
   for(ch=0; ch<nChannels; ch++) {
     PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
     for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
-      Word16 *pahFlag = ahFlag[ch] + sfbGrp;
+      Word16 *pahFlag = ahFlag[ch] + sfbGrp;
 	  for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-               
+
         if ((psyOutChan->sfbSpreadedEnergy[sfbGrp+sfb] > psyOutChan->sfbEnergy[sfbGrp+sfb]) ||
             (psyOutChan->sfbEnergy[sfbGrp+sfb] <= psyOutChan->sfbThreshold[sfbGrp+sfb]) ||
             (psyOutChan->sfbMinSnr[sfbGrp+sfb] == MAX_16)) {
@@ -308,7 +308,7 @@ static void initAvoidHoleFlag(Word16 ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
         }
       }
       for (sfb=psyOutChan->maxSfbPerGroup; sfb<psyOutChan->sfbPerGroup; sfb++) {
-        *pahFlag++ = NO_AH;                                                          
+        *pahFlag++ = NO_AH;
       }
     }
   }
@@ -328,18 +328,18 @@ static void calcPeNoAH(Word16          *pe,
                        PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
                        const Word16     nChannels)
 {
-  Word16 ch, sfb, sfbGrp;
+  Word16 ch, sfb, sfbGrp;
   int ipe, iconstPart, inActiveLines;
 
-  ipe = 0;                                                       
-  iconstPart = 0;                                                
-  inActiveLines = 0;                                             
+  ipe = 0;
+  iconstPart = 0;
+  inActiveLines = 0;
   for(ch=0; ch<nChannels; ch++) {
     PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
     PE_CHANNEL_DATA *peChanData = &peData->peChannelData[ch];
     for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
       for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-         
+
         if (ahFlag[ch][sfbGrp+sfb] < AH_ACTIVE) {
           ipe = ipe + peChanData->sfbPe[sfbGrp+sfb];
           iconstPart = iconstPart + peChanData->sfbConstPart[sfbGrp+sfb];
@@ -347,11 +347,11 @@ static void calcPeNoAH(Word16          *pe,
         }
       }
     }
-  }
+  }
 
-  *pe = saturate(ipe);                                                       
-  *constPart = saturate(iconstPart);                                                
-  *nActiveLines = saturate(inActiveLines);  
+  *pe = saturate(ipe);
+  *constPart = saturate(iconstPart);
+  *nActiveLines = saturate(inActiveLines);
 }
 
 /********************************************************************************
@@ -367,16 +367,16 @@ static void reduceThresholds(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
                              const Word32     redVal)
 {
   Word32 sfbThrReduced;
-  Word32 *psfbEn, *psfbThr;     
-  Word16 ch, sfb, sfbGrp;
+  Word32 *psfbEn, *psfbThr;
+  Word16 ch, sfb, sfbGrp;
 
   for(ch=0; ch<nChannels; ch++) {
     PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
     for(sfbGrp=0; sfbGrp<psyOutChan->sfbCnt; sfbGrp+=psyOutChan->sfbPerGroup) {
- 	  psfbEn  = psyOutChan->sfbEnergy + sfbGrp;                                      
-      psfbThr = psyOutChan->sfbThreshold + sfbGrp;
+ 	  psfbEn  = psyOutChan->sfbEnergy + sfbGrp;
+      psfbThr = psyOutChan->sfbThreshold + sfbGrp;
 	  for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-         
+
         if (*psfbEn > *psfbThr) {
           /* threshold reduction formula */
           Word32 tmp = thrExp[ch][sfbGrp+sfb] + redVal;
@@ -384,15 +384,15 @@ static void reduceThresholds(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
           sfbThrReduced = fixmul(tmp, tmp);
           /* avoid holes */
           tmp = L_mpy_ls(*psfbEn, psyOutChan->sfbMinSnr[sfbGrp+sfb]);
-             
-          if ((sfbThrReduced > tmp) && 
+
+          if ((sfbThrReduced > tmp) &&
               (ahFlag[ch][sfbGrp+sfb] != NO_AH)){
             sfbThrReduced = max(tmp, *psfbThr);
-            ahFlag[ch][sfbGrp+sfb] = AH_ACTIVE;                                          
+            ahFlag[ch][sfbGrp+sfb] = AH_ACTIVE;
           }
 		  *psfbThr = sfbThrReduced;
-        }
-
+        }
+
 		psfbEn++;  psfbThr++;
       }
     }
@@ -419,52 +419,52 @@ static void correctThresh(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
   PSY_OUT_CHANNEL *psyOutChan;
   PE_CHANNEL_DATA *peChanData;
   Word32 deltaSfbPe;
-  Word32 normFactor;
-  Word32 *psfbPeFactors;
+  Word32 normFactor;
+  Word32 *psfbPeFactors;
   Word16 *psfbNActiveLines, *pahFlag;
   Word32 sfbEn, sfbThr;
   Word32 sfbThrReduced;
 
   /* for each sfb calc relative factors for pe changes */
-  normFactor = 1;                                                                        
+  normFactor = 1;
   for(ch=0; ch<nChannels; ch++) {
     psyOutChan = &psyOutChannel[ch];
     peChanData = &peData->peChannelData[ch];
     for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
-      psfbPeFactors = peData->sfbPeFactors[ch] + sfbGrp;
-	  psfbNActiveLines = peChanData->sfbNActiveLines + sfbGrp;
-	  pahFlag = ahFlag[ch] + sfbGrp;
+      psfbPeFactors = peData->sfbPeFactors[ch] + sfbGrp;
+	  psfbNActiveLines = peChanData->sfbNActiveLines + sfbGrp;
+	  pahFlag = ahFlag[ch] + sfbGrp;
 	  for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
         Word32 redThrExp = thrExp[ch][sfbGrp+sfb] + redVal;
-             
+
         if (((*pahFlag < AH_ACTIVE) || (deltaPe > 0)) && (redThrExp > 0) ) {
-            
+
           *psfbPeFactors = (*psfbNActiveLines) * (0x7fffffff / redThrExp);
           normFactor = L_add(normFactor, *psfbPeFactors);
         }
         else {
-          *psfbPeFactors = 0;                                              
-        }
-		psfbPeFactors++; 
+          *psfbPeFactors = 0;
+        }
+		psfbPeFactors++;
 		pahFlag++; psfbNActiveLines++;
       }
     }
   }
 
- 
+
   /* calculate new thresholds */
   for(ch=0; ch<nChannels; ch++) {
     psyOutChan = &psyOutChannel[ch];
     peChanData = &peData->peChannelData[ch];
     for(sfbGrp = 0;sfbGrp < psyOutChan->sfbCnt;sfbGrp+= psyOutChan->sfbPerGroup){
-      psfbPeFactors = peData->sfbPeFactors[ch] + sfbGrp;
-	  psfbNActiveLines = peChanData->sfbNActiveLines + sfbGrp;
-	  pahFlag = ahFlag[ch] + sfbGrp;
+      psfbPeFactors = peData->sfbPeFactors[ch] + sfbGrp;
+	  psfbNActiveLines = peChanData->sfbNActiveLines + sfbGrp;
+	  pahFlag = ahFlag[ch] + sfbGrp;
 	  for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
         /* pe difference for this sfb */
         deltaSfbPe = *psfbPeFactors * deltaPe;
 
-		/* thr3(n) = thr2(n)*2^deltaSfbPe/b(n) */         
+		/* thr3(n) = thr2(n)*2^deltaSfbPe/b(n) */
         if (*psfbNActiveLines > 0) {
           /* new threshold */
           Word32 thrFactor;
@@ -476,7 +476,7 @@ static void correctThresh(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
               reduce threshold
             */
             thrFactor = pow2_xy(L_negate(deltaSfbPe), (normFactor* (*psfbNActiveLines)));
-              
+
             sfbThrReduced = L_mpy_ls(sfbThr, round16(thrFactor));
           }
           else {
@@ -484,30 +484,30 @@ static void correctThresh(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
               increase threshold
             */
             thrFactor = pow2_xy(deltaSfbPe, (normFactor * (*psfbNActiveLines)));
-              
-             
+
+
             if(thrFactor > sfbThr) {
-              shift = norm_l(thrFactor);
+              shift = norm_l(thrFactor);
 			  sfbThrReduced = Div_32( sfbThr << shift, thrFactor<<shift );
             }
             else {
-              sfbThrReduced = MAX_32;                                                                            
+              sfbThrReduced = MAX_32;
             }
 
           }
-            
+
           /* avoid hole */
           sfbEn = L_mpy_ls(sfbEn, psyOutChan->sfbMinSnr[sfbGrp+sfb]);
-             
+
           if ((sfbThrReduced > sfbEn) &&
               (*pahFlag == AH_INACTIVE)) {
             sfbThrReduced = max(sfbEn, sfbThr);
-            *pahFlag = AH_ACTIVE;                                                                  
+            *pahFlag = AH_ACTIVE;
           }
 
-          psyOutChan->sfbThreshold[sfbGrp+sfb] = sfbThrReduced;  
-        }
-
+          psyOutChan->sfbThreshold[sfbGrp+sfb] = sfbThrReduced;
+        }
+
 		pahFlag++; psfbNActiveLines++; psfbPeFactors++;
       }
     }
@@ -521,8 +521,8 @@ static void correctThresh(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
 * description: if the desired pe can not be reached, reduce pe by reducing minSnr
 *
 **********************************************************************************/
-static void reduceMinSnr(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS], 
-                         PE_DATA         *peData, 
+static void reduceMinSnr(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
+                         PE_DATA         *peData,
                          Word16           ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
                          const Word16     nChannels,
                          const Word16     desiredPe)
@@ -531,20 +531,20 @@ static void reduceMinSnr(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
   Word16 deltaPe;
 
   /* start at highest freq down to 0 */
-  sfbSubWin = psyOutChannel[0].maxSfbPerGroup;                                                 
+  sfbSubWin = psyOutChannel[0].maxSfbPerGroup;
   while (peData->pe > desiredPe && sfbSubWin > 0) {
-       
+
     sfbSubWin = sfbSubWin - 1;
     /* loop over all subwindows */
     for (sfb=sfbSubWin; sfb<psyOutChannel[0].sfbCnt;
         sfb+=psyOutChannel[0].sfbPerGroup) {
       /* loop over all channels */
-		PE_CHANNEL_DATA* peChan = peData->peChannelData;
-		PSY_OUT_CHANNEL* psyOutCh = psyOutChannel;
-		for (ch=0; ch<nChannels; ch++) {           
+		PE_CHANNEL_DATA* peChan = peData->peChannelData;
+		PSY_OUT_CHANNEL* psyOutCh = psyOutChannel;
+		for (ch=0; ch<nChannels; ch++) {
         if (ahFlag[ch][sfb] != NO_AH &&
             psyOutCh->sfbMinSnr[sfb] < minSnrLimit) {
-          psyOutCh->sfbMinSnr[sfb] = minSnrLimit;                                      
+          psyOutCh->sfbMinSnr[sfb] = minSnrLimit;
           psyOutCh->sfbThreshold[sfb] =
             L_mpy_ls(psyOutCh->sfbEnergy[sfb], psyOutCh->sfbMinSnr[sfb]);
 
@@ -552,12 +552,12 @@ static void reduceMinSnr(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
           deltaPe = ((peChan->sfbNLines4[sfb] + (peChan->sfbNLines4[sfb] >> 1)) >> 2) -
               peChan->sfbPe[sfb];
           peData->pe = peData->pe + deltaPe;
-          peChan->pe = peChan->pe + deltaPe;		  
-        }
+          peChan->pe = peChan->pe + deltaPe;
+        }
 		peChan += 1; psyOutCh += 1;
       }
       /* stop if enough has been saved */
-       
+
       if (peData->pe <= desiredPe)
         break;
     }
@@ -567,13 +567,13 @@ static void reduceMinSnr(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
 /********************************************************************************
 *
 * function name:allowMoreHoles
-* description: if the desired pe can not be reached, some more scalefactor bands  
+* description: if the desired pe can not be reached, some more scalefactor bands
 *              have to be quantized to zero
 *
 **********************************************************************************/
-static void allowMoreHoles(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS], 
+static void allowMoreHoles(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
                            PSY_OUT_ELEMENT *psyOutElement,
-                           PE_DATA         *peData, 
+                           PE_DATA         *peData,
                            Word16           ahFlag[MAX_CHANNELS][MAX_GROUPED_SFB],
                            const AH_PARAM  *ahParam,
                            const Word16     nChannels,
@@ -582,46 +582,46 @@ static void allowMoreHoles(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
   Word16 ch, sfb;
   Word16 actPe, shift;
 
-  actPe = peData->pe;                                                                    
+  actPe = peData->pe;
 
   /* for MS allow hole in the channel with less energy */
-     
+
   if (nChannels==2 &&
       psyOutChannel[0].windowSequence==psyOutChannel[1].windowSequence) {
     PSY_OUT_CHANNEL *psyOutChanL = &psyOutChannel[0];
     PSY_OUT_CHANNEL *psyOutChanR = &psyOutChannel[1];
     for (sfb=0; sfb<psyOutChanL->sfbCnt; sfb++) {
       Word32 minEn;
-       
+
       if (psyOutElement->toolsInfo.msMask[sfb]) {
         /* allow hole in side channel ? */
         minEn = L_mpy_ls(psyOutChanL->sfbEnergy[sfb], (minSnrLimit * psyOutChanL->sfbMinSnr[sfb]) >> 16);
-           
+
         if (ahFlag[1][sfb] != NO_AH &&
             minEn > psyOutChanR->sfbEnergy[sfb]) {
-          ahFlag[1][sfb] = NO_AH;                                                                
+          ahFlag[1][sfb] = NO_AH;
           psyOutChanR->sfbThreshold[sfb] = L_add(psyOutChanR->sfbEnergy[sfb], psyOutChanR->sfbEnergy[sfb]);
           actPe = actPe - peData->peChannelData[1].sfbPe[sfb];
         }
         /* allow hole in mid channel ? */
         else {
         minEn = L_mpy_ls(psyOutChanR->sfbEnergy[sfb], (minSnrLimit * psyOutChanR->sfbMinSnr[sfb]) >> 16);
-             
+
           if (ahFlag[0][sfb]!= NO_AH &&
               minEn > psyOutChanL->sfbEnergy[sfb]) {
-            ahFlag[0][sfb] = NO_AH;                                                              
+            ahFlag[0][sfb] = NO_AH;
             psyOutChanL->sfbThreshold[sfb] = L_add(psyOutChanL->sfbEnergy[sfb], psyOutChanL->sfbEnergy[sfb]);
             actPe = actPe - peData->peChannelData[0].sfbPe[sfb];
           }
         }
-         
+
         if (actPe < desiredPe)
           break;
       }
     }
   }
 
-  /* subsequently erase bands */   
+  /* subsequently erase bands */
   if (actPe > desiredPe) {
     Word16 startSfb[2];
     Word32 avgEn, minEn;
@@ -634,20 +634,20 @@ static void allowMoreHoles(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
 
     /* do not go below startSfb */
     for (ch=0; ch<nChannels; ch++) {
-         
+
       if (psyOutChannel[ch].windowSequence != SHORT_WINDOW)
         startSfb[ch] = ahParam->startSfbL;
       else
         startSfb[ch] = ahParam->startSfbS;
     }
 
-    avgEn = 0;                                                           
-    minEn = MAX_32;                                                      
-    ahCnt = 0;                                                           
+    avgEn = 0;
+    minEn = MAX_32;
+    ahCnt = 0;
     for (ch=0; ch<nChannels; ch++) {
       PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
       for (sfb=startSfb[ch]; sfb<psyOutChan->sfbCnt; sfb++) {
-           
+
         if ((ahFlag[ch][sfb] != NO_AH) &&
             (psyOutChan->sfbEnergy[sfb] > psyOutChan->sfbThreshold[sfb])) {
           minEn = min(minEn, psyOutChan->sfbEnergy[sfb]);
@@ -656,10 +656,10 @@ static void allowMoreHoles(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
         }
       }
     }
-     
+
     if(ahCnt) {
       Word32 iahCnt;
-      shift = norm_l(ahCnt);
+      shift = norm_l(ahCnt);
 	  iahCnt = Div_32( 1 << shift, ahCnt << shift );
       avgEn = fixmul(avgEn, iahCnt);
     }
@@ -674,46 +674,46 @@ static void allowMoreHoles(PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],
 
     /* start with lowest energy border at highest sfb */
     maxSfb = psyOutChannel[0].sfbCnt - 1;
-    minSfb = startSfb[0];                                                                
-     
+    minSfb = startSfb[0];
+
     if (nChannels == 2) {
       maxSfb = max(maxSfb, (psyOutChannel[1].sfbCnt - 1));
       minSfb = min(minSfb, startSfb[1]);
     }
 
-    sfb = maxSfb;                                                                        
-    enIdx = 0;                                                                           
-    done = 0;                                                                            
+    sfb = maxSfb;
+    enIdx = 0;
+    done = 0;
     while (!done) {
-       
+
       for (ch=0; ch<nChannels; ch++) {
         PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
-           
+
         if (sfb>=startSfb[ch] && sfb<psyOutChan->sfbCnt) {
           /* sfb energy below border ? */
-             
+
           if (ahFlag[ch][sfb] != NO_AH && psyOutChan->sfbEnergy[sfb] < en[enIdx]){
             /* allow hole */
-            ahFlag[ch][sfb] = NO_AH;                                                     
+            ahFlag[ch][sfb] = NO_AH;
             psyOutChan->sfbThreshold[sfb] = L_add(psyOutChan->sfbEnergy[sfb], psyOutChan->sfbEnergy[sfb]);
             actPe = actPe - peData->peChannelData[ch].sfbPe[sfb];
           }
-           
+
           if (actPe < desiredPe) {
-            done = 1;                                                                    
+            done = 1;
             break;
           }
         }
       }
       sfb = sfb - 1;
-       
+
       if (sfb < minSfb) {
         /* restart with next energy border */
-        sfb = maxSfb;                                                                    
+        sfb = maxSfb;
         enIdx = enIdx + 1;
-         
+
         if (enIdx - 4 >= 0)
-          done = 1;                                                                      
+          done = 1;
       }
     }
   }
@@ -748,13 +748,13 @@ static void adaptThresholdsToPe(PSY_OUT_CHANNEL     psyOutChannel[MAX_CHANNELS],
 
   initAvoidHoleFlag(peData->ahFlag, psyOutChannel, psyOutElement, nChannels, ahParam);
 
-  noRedPe = peData->pe;                                                          
-  constPart = peData->constPart;                                                 
-  nActiveLines = peData->nActiveLines;       
+  noRedPe = peData->pe;
+  constPart = peData->constPart;
+  nActiveLines = peData->nActiveLines;
 
   /* first guess of reduction value t^0.25 = 2^((a-pen)/4*b) */
   avgThrExp = pow2_xy((constPart - noRedPe), (nActiveLines << 2));
-  
+
   /* r1 = 2^((a-per)/4*b) - t^0.25 */
   redVal = pow2_xy((constPart - desiredPe), (nActiveLines << 2)) - avgThrExp;
 
@@ -763,40 +763,40 @@ static void adaptThresholdsToPe(PSY_OUT_CHANNEL     psyOutChannel[MAX_CHANNELS],
 
   /* pe after first guess */
   calcSfbPe(peData, psyOutChannel, nChannels);
-  redPe = peData->pe;                                                            
+  redPe = peData->pe;
 
-  iter = 0;                                                                      
+  iter = 0;
   do {
     /* pe for bands where avoid hole is inactive */
     calcPeNoAH(&redPeNoAH, &constPartNoAH, &nActiveLinesNoAH,
                peData, peData->ahFlag, psyOutChannel, nChannels);
 
     desiredPeNoAH = desiredPe -(redPe - redPeNoAH);
-     
+
     if (desiredPeNoAH < 0) {
-      desiredPeNoAH = 0;                                                         
+      desiredPeNoAH = 0;
     }
 
     /* second guess */
-     
+
     if (nActiveLinesNoAH > 0) {
-		
+
 		avgThrExp = pow2_xy((constPartNoAH - redPeNoAH), (nActiveLinesNoAH << 2));
-		
+
 		redVal = (redVal + pow2_xy((constPartNoAH - desiredPeNoAH), (nActiveLinesNoAH << 2))) - avgThrExp;
-		
+
 		/* reduce thresholds */
 		reduceThresholds(psyOutChannel, peData->ahFlag, peData->thrExp, nChannels, redVal);
     }
 
     calcSfbPe(peData, psyOutChannel, nChannels);
-    redPe = peData->pe;                                                          
+    redPe = peData->pe;
 
     iter = iter+1;
-       
+
   } while ((20 * abs_s(redPe - desiredPe) > desiredPe) && (iter < 2));
 
-   
+
   if ((100 * redPe < 115 * desiredPe)) {
     correctThresh(psyOutChannel, peData->ahFlag, peData, peData->thrExp, redVal,
                   nChannels, desiredPe - redPe);
@@ -831,7 +831,7 @@ static Word16 calcBitSave(Word16 fillLevel,
   fillLevel = max(fillLevel, clipLow);
   fillLevel = min(fillLevel, clipHigh);
 
-  if(clipHigh-clipLow)
+  if(clipHigh-clipLow)
   bitsave = (maxBitSave - (((maxBitSave-minBitSave)*(fillLevel-clipLow))/
                               (clipHigh-clipLow)));
 
@@ -860,10 +860,10 @@ static Word16 calcBitSpend(Word16 fillLevel,
   fillLevel = max(fillLevel, clipLow);
   fillLevel = min(fillLevel, clipHigh);
 
-  if(clipHigh-clipLow)
+  if(clipHigh-clipLow)
   bitspend = (minBitSpend + ((maxBitSpend - minBitSpend)*(fillLevel - clipLow) /
                                 (clipHigh-clipLow)));
-                            
+
   return (bitspend);
 }
 
@@ -884,19 +884,19 @@ static void adjustPeMinMax(const Word16 currPe,
   Word16 minFacHi, maxFacHi, minFacLo, maxFacLo;
   Word16 diff;
   Word16 minDiff = extract_l(currPe / 6);
-  minFacHi = 30;                                                         
-  maxFacHi = 100;                                                        
-  minFacLo = 14;                                                         
-  maxFacLo = 7;                                                          
+  minFacHi = 30;
+  maxFacHi = 100;
+  minFacLo = 14;
+  maxFacLo = 7;
 
   diff = currPe - *peMax ;
-   
+
   if (diff > 0) {
     *peMin = *peMin + ((diff * minFacHi) / 100);
     *peMax = *peMax + ((diff * maxFacHi) / 100);
   } else {
     diff = *peMin - currPe;
-     
+
     if (diff > 0) {
       *peMin = *peMin - ((diff * minFacLo) / 100);
       *peMax = *peMax - ((diff * maxFacLo) / 100);
@@ -906,7 +906,7 @@ static void adjustPeMinMax(const Word16 currPe,
     }
   }
 
-   
+
   if ((*peMax - *peMin) < minDiff) {
     Word16 partLo, partHi;
 
@@ -964,12 +964,12 @@ static Word16 bitresCalcBitFac( const Word16   bitresBits,
                           bresParam->clipSpendLow, bresParam->clipSpendHigh,
                           bresParam->minBitSpend, bresParam->maxBitSpend);
 
-  if(adjThrChan->peMax != adjThrChan->peMin)
+  if(adjThrChan->peMax != adjThrChan->peMin)
 	bitresFac = (100 - bitSave) + extract_l(((bitSpend + bitSave) * (pex - adjThrChan->peMin)) /
                     (adjThrChan->peMax - adjThrChan->peMin));
   else
 	bitresFac = 0x7fff;
-               
+
   bitresFac = min(bitresFac,
                     (100-30 + extract_l((100 * bitresBits) / avgBits)));
 
@@ -995,23 +995,23 @@ void AdjThrInit(ADJ_THR_STATE *hAdjThr,
 
   /* common for all elements: */
   /* parameters for bitres control */
-  hAdjThr->bresParamLong.clipSaveLow   =  20;                    
-  hAdjThr->bresParamLong.clipSaveHigh  =  95;                    
-  hAdjThr->bresParamLong.minBitSave    =  -5;                    
-  hAdjThr->bresParamLong.maxBitSave    =  30;                    
-  hAdjThr->bresParamLong.clipSpendLow  =  20;                    
-  hAdjThr->bresParamLong.clipSpendHigh =  95;                    
-  hAdjThr->bresParamLong.minBitSpend   = -10;                    
-  hAdjThr->bresParamLong.maxBitSpend   =  40;                    
-
-  hAdjThr->bresParamShort.clipSaveLow   =  20;                   
-  hAdjThr->bresParamShort.clipSaveHigh  =  75;                   
-  hAdjThr->bresParamShort.minBitSave    =   0;                   
-  hAdjThr->bresParamShort.maxBitSave    =  20;                   
-  hAdjThr->bresParamShort.clipSpendLow  =  20;                   
-  hAdjThr->bresParamShort.clipSpendHigh =  75;                   
-  hAdjThr->bresParamShort.minBitSpend   = -5;                    
-  hAdjThr->bresParamShort.maxBitSpend   =  50;                   
+  hAdjThr->bresParamLong.clipSaveLow   =  20;
+  hAdjThr->bresParamLong.clipSaveHigh  =  95;
+  hAdjThr->bresParamLong.minBitSave    =  -5;
+  hAdjThr->bresParamLong.maxBitSave    =  30;
+  hAdjThr->bresParamLong.clipSpendLow  =  20;
+  hAdjThr->bresParamLong.clipSpendHigh =  95;
+  hAdjThr->bresParamLong.minBitSpend   = -10;
+  hAdjThr->bresParamLong.maxBitSpend   =  40;
+
+  hAdjThr->bresParamShort.clipSaveLow   =  20;
+  hAdjThr->bresParamShort.clipSaveHigh  =  75;
+  hAdjThr->bresParamShort.minBitSave    =   0;
+  hAdjThr->bresParamShort.maxBitSave    =  20;
+  hAdjThr->bresParamShort.clipSpendLow  =  20;
+  hAdjThr->bresParamShort.clipSpendHigh =  75;
+  hAdjThr->bresParamShort.minBitSpend   = -5;
+  hAdjThr->bresParamShort.maxBitSpend   =  50;
 
   /* specific for each element: */
 
@@ -1020,7 +1020,7 @@ void AdjThrInit(ADJ_THR_STATE *hAdjThr,
   atsElem->peMax = extract_l(((120*meanPe) / 100));
 
   /* additional pe offset to correct pe2bits for low bitrates */
-  atsElem->peOffset = 0;                             
+  atsElem->peOffset = 0;
   if (chBitrate < 32000) {
     atsElem->peOffset = max(50, (100 - extract_l((100 * chBitrate) / 32000)));
   }
@@ -1039,24 +1039,24 @@ void AdjThrInit(ADJ_THR_STATE *hAdjThr,
 
   /* minSnr adaptation */
   /* maximum reduction of minSnr goes down to minSnr^maxRed */
-  msaParam->maxRed = 0x20000000;     /* *0.25f /                        
+  msaParam->maxRed = 0x20000000;     /* *0.25f /
   /* start adaptation of minSnr for avgEn/sfbEn > startRatio */
-  msaParam->startRatio = 0x0ccccccd; /* 10 */                        
+  msaParam->startRatio = 0x0ccccccd; /* 10 */
   /* maximum minSnr reduction to minSnr^maxRed is reached for
      avgEn/sfbEn >= maxRatio */
-  msaParam->maxRatio =  0x0020c49c; /* 1000 */                         
+  msaParam->maxRatio =  0x0020c49c; /* 1000 */
   /* helper variables to interpolate minSnr reduction for
      avgEn/sfbEn between startRatio and maxRatio */
 
-  msaParam->redRatioFac = 0xfb333333; /* -0.75/20 */         
+  msaParam->redRatioFac = 0xfb333333; /* -0.75/20 */
+
+  msaParam->redOffs = 0x30000000;  /* msaParam->redRatioFac * 10*log10(msaParam->startRatio) */
 
-  msaParam->redOffs = 0x30000000;  /* msaParam->redRatioFac * 10*log10(msaParam->startRatio) */  
 
-       
   /* pe correction */
-  atsElem->peLast = 0;                                                 
-  atsElem->dynBitsLast = 0;                                            
-  atsElem->peCorrectionFactor = 100; /* 1.0 */                         
+  atsElem->peLast = 0;
+  atsElem->dynBitsLast = 0;
+  atsElem->peCorrectionFactor = 100; /* 1.0 */
 
 }
 
@@ -1069,20 +1069,20 @@ void AdjThrInit(ADJ_THR_STATE *hAdjThr,
 *****************************************************************************/
 static void calcPeCorrection(Word16 *correctionFac,
                              const Word16 peAct,
-                             const Word16 peLast, 
-                             const Word16 bitsLast) 
+                             const Word16 peLast,
+                             const Word16 bitsLast)
 {
   Word32 peAct100 = 100 * peAct;
   Word32 peLast100 = 100 * peLast;
   Word16 peBitsLast = bits2pe(bitsLast);
-           
+
   if ((bitsLast > 0) &&
       (peAct100 < (150 * peLast)) &&  (peAct100 > (70 * peLast)) &&
       ((120 * peBitsLast) > peLast100 ) && (( 65 * peBitsLast) < peLast100))
     {
       Word16 newFac = (100 * peLast) / peBitsLast;
       /* dead zone */
-       
+
       if (newFac < 100) {
         newFac = min(((110 * newFac) / 100), 100);
         newFac = max(newFac, 85);
@@ -1091,13 +1091,13 @@ static void calcPeCorrection(Word16 *correctionFac,
         newFac = max(((90 * newFac) / 100), 100);
         newFac = min(newFac, 115);
       }
-         
+
       if ((newFac > 100 && *correctionFac < 100) ||
           (newFac < 100 && *correctionFac > 100)) {
-        *correctionFac = 100;                                                    
+        *correctionFac = 100;
       }
       /* faster adaptation towards 1.0, slower in the other direction */
-             
+
       if ((*correctionFac < 100 && newFac < *correctionFac) ||
           (*correctionFac > 100 && newFac > *correctionFac))
         *correctionFac = (85 * *correctionFac + 15 * newFac) / 100;
@@ -1107,7 +1107,7 @@ static void calcPeCorrection(Word16 *correctionFac,
       *correctionFac = max(*correctionFac, 85);
     }
   else {
-    *correctionFac = 100;                                                        
+    *correctionFac = 100;
   }
 }
 
@@ -1123,40 +1123,40 @@ void AdjustThresholds(ADJ_THR_STATE   *adjThrState,
                       PSY_OUT_ELEMENT *psyOutElement,
                       Word16          *chBitDistribution,
                       Word16           logSfbEnergy[MAX_CHANNELS][MAX_GROUPED_SFB],
-                      Word16           sfbNRelevantLines[MAX_CHANNELS][MAX_GROUPED_SFB],                      
+                      Word16           sfbNRelevantLines[MAX_CHANNELS][MAX_GROUPED_SFB],
                       QC_OUT_ELEMENT  *qcOE,
 					  ELEMENT_BITS	  *elBits,
 					  const Word16     nChannels,
                       const Word16     maxBitFac)
 {
-  PE_DATA peData;  
+  PE_DATA peData;
   Word16 noRedPe, grantedPe, grantedPeCorr;
   Word16 curWindowSequence;
   Word16 bitFactor;
   Word16 avgBits = (elBits->averageBits - (qcOE->staticBitsUsed + qcOE->ancBitsUsed));
-  Word16 bitresBits = elBits->bitResLevel; 
+  Word16 bitresBits = elBits->bitResLevel;
   Word16 maxBitresBits = elBits->maxBits;
   Word16 sideInfoBits = (qcOE->staticBitsUsed + qcOE->ancBitsUsed);
   Word16 ch;
-   
+
   prepareSfbPe(&peData, psyOutChannel, logSfbEnergy, sfbNRelevantLines, nChannels, AdjThrStateElement->peOffset);
-   
+
   /* pe without reduction */
   calcSfbPe(&peData, psyOutChannel, nChannels);
-  noRedPe = peData.pe;                                                   
+  noRedPe = peData.pe;
+
 
+  curWindowSequence = LONG_WINDOW;
 
-  curWindowSequence = LONG_WINDOW;                                       
-   
   if (nChannels == 2) {
-       
+
     if ((psyOutChannel[0].windowSequence == SHORT_WINDOW) ||
         (psyOutChannel[1].windowSequence == SHORT_WINDOW)) {
-      curWindowSequence = SHORT_WINDOW;                                  
+      curWindowSequence = SHORT_WINDOW;
     }
   }
   else {
-    curWindowSequence = psyOutChannel[0].windowSequence;                 
+    curWindowSequence = psyOutChannel[0].windowSequence;
   }
 
 
@@ -1170,13 +1170,13 @@ void AdjustThresholds(ADJ_THR_STATE   *adjThrState,
   grantedPe = ((bitFactor * bits2pe(avgBits)) / 100);
 
   /* correction of pe value */
-  calcPeCorrection(&(AdjThrStateElement->peCorrectionFactor), 
+  calcPeCorrection(&(AdjThrStateElement->peCorrectionFactor),
                    min(grantedPe, noRedPe),
-                   AdjThrStateElement->peLast, 
+                   AdjThrStateElement->peLast,
                    AdjThrStateElement->dynBitsLast);
   grantedPeCorr = (grantedPe * AdjThrStateElement->peCorrectionFactor) / 100;
 
-     
+
   if (grantedPeCorr < noRedPe && noRedPe > peData.offset) {
     /* calc threshold necessary for desired pe */
     adaptThresholdsToPe(psyOutChannel,
@@ -1192,20 +1192,20 @@ void AdjustThresholds(ADJ_THR_STATE   *adjThrState,
   /* calculate relative distribution */
   for (ch=0; ch<nChannels; ch++) {
     Word16 peOffsDiff = peData.pe - peData.offset;
-    chBitDistribution[ch] = 200;                                                 
-     
+    chBitDistribution[ch] = 200;
+
     if (peOffsDiff > 0) {
       Word32 temp = 1000 - (nChannels * 200);
-      chBitDistribution[ch] = chBitDistribution[ch] +
+      chBitDistribution[ch] = chBitDistribution[ch] +
 		  (temp * peData.peChannelData[ch].pe) / peOffsDiff;
     }
   }
 
   /* store pe */
-  qcOE->pe = noRedPe;                                                            
+  qcOE->pe = noRedPe;
 
   /* update last pe */
-  AdjThrStateElement->peLast = grantedPe;                                        
+  AdjThrStateElement->peLast = grantedPe;
 }
 
 /********************************************************************************
@@ -1217,7 +1217,7 @@ void AdjustThresholds(ADJ_THR_STATE   *adjThrState,
 void AdjThrUpdate(ATS_ELEMENT *AdjThrStateElement,
                   const Word16 dynBitsUsed)
 {
-  AdjThrStateElement->dynBitsLast = dynBitsUsed;                                 
+  AdjThrStateElement->dynBitsLast = dynBitsUsed;
 }
 
 
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/AutoCorrelation_v5.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/AutoCorrelation_v5.s
index 48edd4f..e705197 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/AutoCorrelation_v5.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/AutoCorrelation_v5.s
@@ -1,167 +1,167 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		AutoCorrelation_v5.s
-@
-@	Content:	AutoCorrelation function armv5 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-
-	.section .text	
-	.global	AutoCorrelation
-
-AutoCorrelation:
-	stmdb     sp!, {r4 - r11, lr}
-
-  sub     r13, r13, #20                     
-
-  mov     r5, r0                            
-  mov     r7, r1                            
-  mov     r9, r3                            
-  mov     r2, r2, lsl #16                      
-  mov     r0, #0          
-  mov     r4, r2, asr #16                   
-  mov     r8, #0                            
-  cmp     r4, #0                            
-  ble     L136        
-	
-	cmp     r4, #8 
-	mov		  r2, #0 
-  blt     L133   
-
-	sub     r12, r4, #8                
-L132:  
-  ldr     r6, [r5, r2]  
-	add		  r2, r2, #4
-	smulbb  r3, r6, r6
-	ldr     r1, [r5, r2] 
-	smultt	r10, r6, r6
-	mov		  r3, r3, asr #9
-	smulbb	r6, r1, r1
-	mov		  r10, r10, asr #9
-	qadd	  r0, r0, r3
-	smultt	r11, r1, r1
-	add     r2, r2, #4
-	qadd	  r0, r0, r10
-	mov		  r6, r6, asr #9
-	mov		  r11, r11, asr #9
-	ldr		  r1, [r5, r2]
-	qadd	  r0, r0, r6
-	smulbb	r10, r1, r1
-	smultt	r6, r1, r1
-	qadd	  r0, r0, r11
-	mov		  r10, r10, asr #9
-	mov		  r6, r6, asr #9
-	qadd	  r0, r0, r10
-	add     r2, r2, #4
-	add     r8, r8, #6
-
-	qadd	  r0, r0, r6
-	cmp     r8, r12                            
-  blt     L132	                  
-L133:                         
-  ldrsh   r6, [r5, r2]                      
-  mul     r10, r6, r6   
-	add     r2, r2, #2                     
-  mov     r1, r10, asr #9                    
-  qadd    r0, r0, r1
-L134:                         
-  add     r8, r8, #1                        
-  cmp     r8, r4                            
-  blt     L133                            
-L135:                        
-L136:                         
-  str     r0, [r7, #0]                      
-  cmp     r0, #0                            
-  beq     L1320                           
-L137:                         
-  mov     r2, r9, lsl #16                   
-	mov     r8, #1                                
-  mov     r2, r2, asr #16                   
-  cmp     r2, #1                            
-  ble     L1319                           
-L138:                        
-L139:                         
-  sub     r4, r4, #1                        
-  mov     r14, #0                           
-  mov     r3, #0                            
-  cmp     r4, #0                            
-  ble     L1317                           
-L1310:                       
-  cmp     r4, #6                            
-  addlt   r6, r5, r8, lsl #1                
-  blt     L1314                           
-L1311:                        
-  add     r6, r5, r8, lsl #1                
-  sub     r12, r4, #6                       
-  str     r8, [r13, #8]                     
-  str     r7, [r13, #4]                     
-L1312:                        
-  mov     r1, r3, lsl #1                    
-  ldrsh   r7, [r6, r1]                      
-  ldrsh   r10, [r5, r1]  
-  add     r8, r1, r6 
-	add     r9, r5, r1                       
-	mul     r7, r10, r7
-  ldrsh   r1, [r8, #2] 
-	ldrsh   r10, [r8, #4]   
-  add     r7, r14, r7, asr #9  	                                             
-  ldrsh   r0, [r9, #2]                          
-  ldrsh   r11, [r9, #4]                   
-  mul     r1, r0, r1                        
-  ldrsh   r14, [r8, #6]                     
-  mul     r10, r11, r10          
-	add     r7, r7, r1, asr #9            
-  ldrsh   r8, [r8, #8] 
-	add     r3, r3, #5
-	ldrsh   r11, [r9, #6]                  
-  ldrsh   r1, [r9, #8]                      
-  mul     r14, r11, r14                     
-  add     r7, r7, r10, asr #9       
-  mul     r1, r1, r8                             
-  add     r14, r7, r14, asr #9              
-	cmp     r3, r12 
-  add     r14, r14, r1, asr #9              
-  ble     L1312                           
-L1313:                        
-  ldr     r8, [r13, #8]                     
-  ldr     r7, [r13, #4]                     
-L1314:                        
-L1315:                        
-  mov     r12, r3, lsl #1                   
-  ldrsh   r9, [r6, r12]                     
-  ldrsh   r12, [r5, r12]                    
-  add     r3, r3, #1                        
-  cmp     r3, r4                            
-  mul     r12, r12, r9                      
-  add     r14, r14, r12, asr #9             
-  blt     L1315                           
-L1316:                        
-L1317:                        
-  str     r14, [r7, +r8, lsl #2]            
-  add     r8, r8, #1                        
-  cmp     r8, r2                            
-  blt     L139   
-	                         
-L1319:
-L1320:
-	add     r13, r13, #20                    
-	ldmia   sp!, {r4 - r11, pc}
-
-	@ENDP  @ |AutoCorrelation|
-	.end
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		AutoCorrelation_v5.s
+@
+@	Content:	AutoCorrelation function armv5 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+
+	.section .text
+	.global	AutoCorrelation
+
+AutoCorrelation:
+	stmdb     sp!, {r4 - r11, lr}
+
+  sub     r13, r13, #20
+
+  mov     r5, r0
+  mov     r7, r1
+  mov     r9, r3
+  mov     r2, r2, lsl #16
+  mov     r0, #0
+  mov     r4, r2, asr #16
+  mov     r8, #0
+  cmp     r4, #0
+  ble     L136
+
+	cmp     r4, #8
+	mov		  r2, #0
+  blt     L133
+
+	sub     r12, r4, #8
+L132:
+  ldr     r6, [r5, r2]
+	add		  r2, r2, #4
+	smulbb  r3, r6, r6
+	ldr     r1, [r5, r2]
+	smultt	r10, r6, r6
+	mov		  r3, r3, asr #9
+	smulbb	r6, r1, r1
+	mov		  r10, r10, asr #9
+	qadd	  r0, r0, r3
+	smultt	r11, r1, r1
+	add     r2, r2, #4
+	qadd	  r0, r0, r10
+	mov		  r6, r6, asr #9
+	mov		  r11, r11, asr #9
+	ldr		  r1, [r5, r2]
+	qadd	  r0, r0, r6
+	smulbb	r10, r1, r1
+	smultt	r6, r1, r1
+	qadd	  r0, r0, r11
+	mov		  r10, r10, asr #9
+	mov		  r6, r6, asr #9
+	qadd	  r0, r0, r10
+	add     r2, r2, #4
+	add     r8, r8, #6
+
+	qadd	  r0, r0, r6
+	cmp     r8, r12
+  blt     L132
+L133:
+  ldrsh   r6, [r5, r2]
+  mul     r10, r6, r6
+	add     r2, r2, #2
+  mov     r1, r10, asr #9
+  qadd    r0, r0, r1
+L134:
+  add     r8, r8, #1
+  cmp     r8, r4
+  blt     L133
+L135:
+L136:
+  str     r0, [r7, #0]
+  cmp     r0, #0
+  beq     L1320
+L137:
+  mov     r2, r9, lsl #16
+	mov     r8, #1
+  mov     r2, r2, asr #16
+  cmp     r2, #1
+  ble     L1319
+L138:
+L139:
+  sub     r4, r4, #1
+  mov     r14, #0
+  mov     r3, #0
+  cmp     r4, #0
+  ble     L1317
+L1310:
+  cmp     r4, #6
+  addlt   r6, r5, r8, lsl #1
+  blt     L1314
+L1311:
+  add     r6, r5, r8, lsl #1
+  sub     r12, r4, #6
+  str     r8, [r13, #8]
+  str     r7, [r13, #4]
+L1312:
+  mov     r1, r3, lsl #1
+  ldrsh   r7, [r6, r1]
+  ldrsh   r10, [r5, r1]
+  add     r8, r1, r6
+	add     r9, r5, r1
+	mul     r7, r10, r7
+  ldrsh   r1, [r8, #2]
+	ldrsh   r10, [r8, #4]
+  add     r7, r14, r7, asr #9
+  ldrsh   r0, [r9, #2]
+  ldrsh   r11, [r9, #4]
+  mul     r1, r0, r1
+  ldrsh   r14, [r8, #6]
+  mul     r10, r11, r10
+	add     r7, r7, r1, asr #9
+  ldrsh   r8, [r8, #8]
+	add     r3, r3, #5
+	ldrsh   r11, [r9, #6]
+  ldrsh   r1, [r9, #8]
+  mul     r14, r11, r14
+  add     r7, r7, r10, asr #9
+  mul     r1, r1, r8
+  add     r14, r7, r14, asr #9
+	cmp     r3, r12
+  add     r14, r14, r1, asr #9
+  ble     L1312
+L1313:
+  ldr     r8, [r13, #8]
+  ldr     r7, [r13, #4]
+L1314:
+L1315:
+  mov     r12, r3, lsl #1
+  ldrsh   r9, [r6, r12]
+  ldrsh   r12, [r5, r12]
+  add     r3, r3, #1
+  cmp     r3, r4
+  mul     r12, r12, r9
+  add     r14, r14, r12, asr #9
+  blt     L1315
+L1316:
+L1317:
+  str     r14, [r7, +r8, lsl #2]
+  add     r8, r8, #1
+  cmp     r8, r2
+  blt     L139
+
+L1319:
+L1320:
+	add     r13, r13, #20
+	ldmia   sp!, {r4 - r11, pc}
+
+	@ENDP  @ |AutoCorrelation|
+	.end
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/CalcWindowEnergy_v5.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/CalcWindowEnergy_v5.s
index 7997e98..b30e8cb 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/CalcWindowEnergy_v5.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/CalcWindowEnergy_v5.s
@@ -1,112 +1,112 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		CalcWindowEnergy_v5.s
-@
-@	Content:	CalcWindowEnergy function armv5 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-	.section .text
-	
-	.global	CalcWindowEnergy
-
-CalcWindowEnergy:
-	stmdb   sp!, {r4 - r11, lr}
-	sub     r13, r13, #20 
-
-  mov     r3, r3, lsl #16                         
-	ldr     r10, [r0, #168]                    @ states0 = blockSwitchingControl->iirStates[0];
-  mov     r3, r3, asr #16 
-	ldr     r11, [r0, #172]                    @ states1 = blockSwitchingControl->iirStates[1];
-
-	mov     r2, r2, lsl #16
-	ldr     r12, hiPassCoeff                   @ Coeff0 = hiPassCoeff[0];      
-  mov     r2, r2, asr #16
-	ldr     r14, hiPassCoeff + 4			         @ Coeff1 = hiPassCoeff[1];
-	
-	mov			r8, #0							               @ w=0
-	mov			r5, #0							               @ wOffset = 0;
-	
-BLOCK_BEGIN:
-	mov			r6, #0                             @ accuUE = 0; 
-	mov			r7, #0								             @ accuFE = 0; 
-	mov			r4, #0							               @ i=0
-		                   
-	str			r8, [r13, #4]	
-	str			r0, [r13, #8]	
-	str			r3, [r13, #12]
-	
-ENERGY_BEG:	
-	mov     r9, r5, lsl #1  
-	ldrsh   r9, [r1, r9]											@ tempUnfiltered = timeSignal[tidx];
-
-	add			r5, r5, r2												@ tidx = tidx + chIncrement;
-	
-	smulwb	r3, r14, r9												@ accu1 = L_mpy_ls(Coeff1, tempUnfiltered);	
-	smull		r0, r8, r12, r11									@ accu2 = fixmul( Coeff0, states1 );
-	
-	mov			r3, r3, lsl #1
-	mov			r8, r8, lsl #1
-
-	sub			r0, r3, r10												@ accu3 = accu1 - states0;	
-	sub			r8,	r0, r8												@ out = accu3 - accu2;
-
-	mov		  r10, r3														@ states0 = accu1;
-	mov		  r11, r8														@ states1 = out;  
-	
-	mul		  r3, r9, r9	
-	mov     r8, r8, asr #16
-	
-	add		  r4, r4, #1
-	add     r6, r6, r3, asr #7
-
-	mul		  r9, r8, r8	
-	ldr		  r3, [r13, #12]
-
-	add		  r7, r7, r9, asr #7
-		
-	cmp     r4, r3                            
-  blt     ENERGY_BEG       
-	
-	ldr		  r0, [r13, #8]
-	ldr		  r8, [r13, #4]
-	
-ENERGY_END:
-	add		  r4, r0, r8, lsl #2
-
-	str     r6, [r4, #72]         
-	add		  r8, r8, #1	           
-  str     r7, [r4, #136]                   
-
-	cmp		  r8, #8
-	blt		  BLOCK_BEGIN                  	                        
-
-BLOCK_END:
-	str     r10, [r0, #168]                    
-  str     r11, [r0, #172]                    
-  mov     r0, #1            
-	                
-  add     r13, r13, #20   
-	ldmia   sp!, {r4 - r11, pc}                  
-
-hiPassCoeff:
-	.word 0xbec8b439
-	.word	0x609d4952
-		
-	@ENDP
-	.end
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		CalcWindowEnergy_v5.s
+@
+@	Content:	CalcWindowEnergy function armv5 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+	.section .text
+
+	.global	CalcWindowEnergy
+
+CalcWindowEnergy:
+	stmdb   sp!, {r4 - r11, lr}
+	sub     r13, r13, #20
+
+  mov     r3, r3, lsl #16
+	ldr     r10, [r0, #168]                    @ states0 = blockSwitchingControl->iirStates[0];
+  mov     r3, r3, asr #16
+	ldr     r11, [r0, #172]                    @ states1 = blockSwitchingControl->iirStates[1];
+
+	mov     r2, r2, lsl #16
+	ldr     r12, hiPassCoeff                   @ Coeff0 = hiPassCoeff[0];
+  mov     r2, r2, asr #16
+	ldr     r14, hiPassCoeff + 4			         @ Coeff1 = hiPassCoeff[1];
+
+	mov			r8, #0							               @ w=0
+	mov			r5, #0							               @ wOffset = 0;
+
+BLOCK_BEGIN:
+	mov			r6, #0                             @ accuUE = 0;
+	mov			r7, #0								             @ accuFE = 0;
+	mov			r4, #0							               @ i=0
+
+	str			r8, [r13, #4]
+	str			r0, [r13, #8]
+	str			r3, [r13, #12]
+
+ENERGY_BEG:
+	mov     r9, r5, lsl #1
+	ldrsh   r9, [r1, r9]											@ tempUnfiltered = timeSignal[tidx];
+
+	add			r5, r5, r2												@ tidx = tidx + chIncrement;
+
+	smulwb	r3, r14, r9												@ accu1 = L_mpy_ls(Coeff1, tempUnfiltered);
+	smull		r0, r8, r12, r11									@ accu2 = fixmul( Coeff0, states1 );
+
+	mov			r3, r3, lsl #1
+	mov			r8, r8, lsl #1
+
+	sub			r0, r3, r10												@ accu3 = accu1 - states0;
+	sub			r8,	r0, r8												@ out = accu3 - accu2;
+
+	mov		  r10, r3														@ states0 = accu1;
+	mov		  r11, r8														@ states1 = out;
+
+	mul		  r3, r9, r9
+	mov     r8, r8, asr #16
+
+	add		  r4, r4, #1
+	add     r6, r6, r3, asr #7
+
+	mul		  r9, r8, r8
+	ldr		  r3, [r13, #12]
+
+	add		  r7, r7, r9, asr #7
+
+	cmp     r4, r3
+  blt     ENERGY_BEG
+
+	ldr		  r0, [r13, #8]
+	ldr		  r8, [r13, #4]
+
+ENERGY_END:
+	add		  r4, r0, r8, lsl #2
+
+	str     r6, [r4, #72]
+	add		  r8, r8, #1
+  str     r7, [r4, #136]
+
+	cmp		  r8, #8
+	blt		  BLOCK_BEGIN
+
+BLOCK_END:
+	str     r10, [r0, #168]
+  str     r11, [r0, #172]
+  mov     r0, #1
+
+  add     r13, r13, #20
+	ldmia   sp!, {r4 - r11, pc}
+
+hiPassCoeff:
+	.word 0xbec8b439
+	.word	0x609d4952
+
+	@ENDP
+	.end
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/PrePostMDCT_v5.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/PrePostMDCT_v5.s
index d4d3edb..103cc91 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/PrePostMDCT_v5.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/PrePostMDCT_v5.s
@@ -1,131 +1,131 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		PrePostMDCT_v5.s
-@
-@	Content:	premdct and postmdct function armv5 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-	.section .text
-	.global	PreMDCT
-
-PreMDCT:
-	stmdb       sp!, {r4 - r11, lr}
-	
-	add         r9, r0, r1, lsl #2
-	sub         r3, r9, #8
-
-	movs        r1, r1, asr #2
-	beq         PreMDCT_END
-	
-PreMDCT_LOOP:
-	ldr					r8, [r2], #4
-	ldr					r9, [r2], #4
-	
-	ldrd				r4, [r0]
-	ldrd				r6, [r3]
-	
-	smull				r14, r11, r4, r8					@ MULHIGH(tr1, cosa)
-	smull    			r10, r12, r7, r8					@ MULHIGH(ti1, cosa)
-		
-	smull				r14, r8, r7, r9						@ MULHIGH(ti1, sina)
-	smull				r7, r10, r4, r9						@ MULHIGH(tr1, sina)	
-		
-	add					r11, r11, r8						@ MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@	
-	sub					r7, r12, r10						@ MULHIGH(ti1, cosa) - MULHIGH(tr1, sina)
-	
-	ldr					r8, [r2], #4
-	ldr					r9, [r2], #4
-	
-	smull				r14, r4, r6, r8						@ MULHIGH(tr2, cosa)
-	smull    			r10, r12, r5, r8					@ MULHIGH(ti2, cosa)
-		
-	smull				r14, r8, r5, r9						@ MULHIGH(ti2, sina)
-	smull				r5, r10, r6, r9						@ MULHIGH(tr2, sina)
-	
-	add					r8, r8, r4
-	sub					r9, r12, r10
-	
-	mov					r6, r11		
-
-	strd				r6, [r0]	
-	strd				r8, [r3]
-	
-	subs				r1, r1, #1
-	sub					r3, r3, #8
-	add 				r0, r0, #8
-	bne					PreMDCT_LOOP
-
-PreMDCT_END:
-	ldmia       sp!, {r4 - r11, pc}
-	@ENDP  @ |PreMDCT|
-	
-	.section .text
-	.global	PostMDCT
-
-PostMDCT:
-	stmdb       sp!, {r4 - r11, lr}
-	
-	add         r9, r0, r1, lsl #2
-	sub         r3, r9, #8
-
-	movs        r1, r1, asr #2
-	beq         PostMDCT_END
-	
-PostMDCT_LOOP:
-	ldr					r8, [r2], #4					
-	ldr					r9, [r2], #4
-	
-	ldrd				r4, [r0]
-	ldrd				r6, [r3]
-	
-	smull				r14, r11, r4, r8					@ MULHIGH(tr1, cosa)
-	smull    			r10, r12, r5, r8					@ MULHIGH(ti1, cosa)
-		
-	smull				r14, r8, r5, r9						@ MULHIGH(ti1, sina)
-	smull				r5, r10, r4, r9						@ MULHIGH(tr1, sina)	
-		
-	add					r4, r11, r8							@ MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@	
-	sub					r11, r10, r12						@ MULHIGH(ti1, cosa) - MULHIGH(tr1, sina)@
-	
-	ldr					r8, [r2], #4						@
-	ldr					r9, [r2], #4
-	
-	smull				r14, r5, r6, r8						@ MULHIGH(tr2, cosa)
-	smull    			r10, r12, r7, r8					@ MULHIGH(ti2, cosa)
-		
-	smull				r14, r8, r7, r9						@ MULHIGH(ti2, sina)
-	smull				r7, r10, r6, r9						@ MULHIGH(tr2, sina)
-	
-	add					r6, r8, r5							@ MULHIGH(cosb, tr2) + MULHIGH(sinb, ti2)@
-	sub					r5, r10, r12						@ MULHIGH(sinb, tr2) - MULHIGH(cosb, ti2)@
-	
-	mov					r7, r11				
-
-	strd				r4, [r0]
-	strd				r6, [r3]
-	
-	subs				r1, r1, #1
-	sub					r3, r3, #8
-	add 				r0, r0, #8
-	bne					PostMDCT_LOOP
-
-PostMDCT_END:
-	ldmia       sp!, {r4 - r11, pc}
-	@ENDP  @ |PostMDCT|
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		PrePostMDCT_v5.s
+@
+@	Content:	premdct and postmdct function armv5 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+	.section .text
+	.global	PreMDCT
+
+PreMDCT:
+	stmdb       sp!, {r4 - r11, lr}
+
+	add         r9, r0, r1, lsl #2
+	sub         r3, r9, #8
+
+	movs        r1, r1, asr #2
+	beq         PreMDCT_END
+
+PreMDCT_LOOP:
+	ldr					r8, [r2], #4
+	ldr					r9, [r2], #4
+
+	ldrd				r4, [r0]
+	ldrd				r6, [r3]
+
+	smull				r14, r11, r4, r8					@ MULHIGH(tr1, cosa)
+	smull    			r10, r12, r7, r8					@ MULHIGH(ti1, cosa)
+
+	smull				r14, r8, r7, r9						@ MULHIGH(ti1, sina)
+	smull				r7, r10, r4, r9						@ MULHIGH(tr1, sina)
+
+	add					r11, r11, r8						@ MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@
+	sub					r7, r12, r10						@ MULHIGH(ti1, cosa) - MULHIGH(tr1, sina)
+
+	ldr					r8, [r2], #4
+	ldr					r9, [r2], #4
+
+	smull				r14, r4, r6, r8						@ MULHIGH(tr2, cosa)
+	smull    			r10, r12, r5, r8					@ MULHIGH(ti2, cosa)
+
+	smull				r14, r8, r5, r9						@ MULHIGH(ti2, sina)
+	smull				r5, r10, r6, r9						@ MULHIGH(tr2, sina)
+
+	add					r8, r8, r4
+	sub					r9, r12, r10
+
+	mov					r6, r11
+
+	strd				r6, [r0]
+	strd				r8, [r3]
+
+	subs				r1, r1, #1
+	sub					r3, r3, #8
+	add 				r0, r0, #8
+	bne					PreMDCT_LOOP
+
+PreMDCT_END:
+	ldmia       sp!, {r4 - r11, pc}
+	@ENDP  @ |PreMDCT|
+
+	.section .text
+	.global	PostMDCT
+
+PostMDCT:
+	stmdb       sp!, {r4 - r11, lr}
+
+	add         r9, r0, r1, lsl #2
+	sub         r3, r9, #8
+
+	movs        r1, r1, asr #2
+	beq         PostMDCT_END
+
+PostMDCT_LOOP:
+	ldr					r8, [r2], #4
+	ldr					r9, [r2], #4
+
+	ldrd				r4, [r0]
+	ldrd				r6, [r3]
+
+	smull				r14, r11, r4, r8					@ MULHIGH(tr1, cosa)
+	smull    			r10, r12, r5, r8					@ MULHIGH(ti1, cosa)
+
+	smull				r14, r8, r5, r9						@ MULHIGH(ti1, sina)
+	smull				r5, r10, r4, r9						@ MULHIGH(tr1, sina)
+
+	add					r4, r11, r8							@ MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@
+	sub					r11, r10, r12						@ MULHIGH(ti1, cosa) - MULHIGH(tr1, sina)@
+
+	ldr					r8, [r2], #4						@
+	ldr					r9, [r2], #4
+
+	smull				r14, r5, r6, r8						@ MULHIGH(tr2, cosa)
+	smull    			r10, r12, r7, r8					@ MULHIGH(ti2, cosa)
+
+	smull				r14, r8, r7, r9						@ MULHIGH(ti2, sina)
+	smull				r7, r10, r6, r9						@ MULHIGH(tr2, sina)
+
+	add					r6, r8, r5							@ MULHIGH(cosb, tr2) + MULHIGH(sinb, ti2)@
+	sub					r5, r10, r12						@ MULHIGH(sinb, tr2) - MULHIGH(cosb, ti2)@
+
+	mov					r7, r11
+
+	strd				r4, [r0]
+	strd				r6, [r3]
+
+	subs				r1, r1, #1
+	sub					r3, r3, #8
+	add 				r0, r0, #8
+	bne					PostMDCT_LOOP
+
+PostMDCT_END:
+	ldmia       sp!, {r4 - r11, pc}
+	@ENDP  @ |PostMDCT|
 	.end
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/R4R8First_v5.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/R4R8First_v5.s
index 370daf4..72cb9a3 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/R4R8First_v5.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/R4R8First_v5.s
@@ -1,252 +1,252 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		R4R8First_v5.s
-@
-@	Content:	Radix8First and Radix4First function armv5 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-	.section .text
-	.global	Radix4First
-
-Radix4First:
-	stmdb       sp!, {r4 - r11, lr}
-	
-	movs				r10, r1
-	mov					r11, r0
-	beq					Radix4First_END
-		
-Radix4First_LOOP:
-	ldrd				r0, [r11]
-	ldrd				r2, [r11, #8]
-	ldrd				r4, [r11, #16]
-	ldrd				r6, [r11, #24]
-	
-	add					r8, r0, r2
-	add					r9, r1, r3
-	
-	sub					r0, r0, r2
-	sub					r1, r1, r3
-	
-	add					r2, r4, r6
-	add					r3, r5, r7
-	
-	sub					r4, r4, r6
-	sub					r5, r5, r7
-	
-	add					r6, r8, r2
-	add					r7, r9, r3
-	
-	sub					r8, r8, r2
-	sub					r9, r9, r3
-	
-	add					r2, r0, r5
-	sub					r3, r1, r4
-	
-	sub					r0, r0, r5
-	add					r1, r1, r4
-	
-	strd				r6, [r11]
-	strd				r2, [r11, #8]
-	strd				r8, [r11, #16]
-	strd				r0, [r11, #24]
-	
-	subs				r10, r10, #1
-	add					r11, r11, #32
-	bne					Radix4First_LOOP
-
-Radix4First_END:
-	ldmia       sp!, {r4 - r11, pc}
-	@ENDP  @ |Radix4First|
-	
-	.section .text
-	.global	Radix8First
-
-Radix8First:
-	stmdb       sp!, {r4 - r11, lr}
-	sub         sp, sp, #0x24
-	
-	mov				  r12, r1
-	mov					r14, r0
-	cmp					r12, #0
-	beq					Radix8First_END
-	
-Radix8First_LOOP:
-	ldrd				r0, [r14]		
-	ldrd				r2, [r14, #8]
-	ldrd				r4, [r14, #16]
-	ldrd				r6, [r14, #24]
-	
-	add					r8, r0, r2					@ r0 = buf[0] + buf[2]@
-	add					r9, r1, r3					@ i0 = buf[1] + buf[3]@
-	
-	sub					r0, r0, r2					@ r1 = buf[0] - buf[2]@
-	sub					r1, r1, r3					@ i1 = buf[1] - buf[3]@
-	
-	add					r2, r4, r6					@	r2 = buf[4] + buf[6]@
-	add					r3, r5, r7					@ i2 = buf[5] + buf[7]@
-	
-	sub					r4, r4, r6					@	r3 = buf[4] - buf[6]@
-	sub					r5, r5, r7					@ i3 = buf[5] - buf[7]@
-	
-	add					r6, r8, r2					@ r4 = (r0 + r2) >> 1@
-	add					r7, r9, r3					@ i4 = (i0 + i2) >> 1@
-	
-	sub					r8, r8, r2					@	r5 = (r0 - r2) >> 1@
-	sub					r9, r9, r3					@ i5 = (i0 - i2) >> 1@
-	
-	sub					r2, r0, r5					@ r6 = (r1 - i3) >> 1@
-	add					r3, r1, r4					@ i6 = (i1 + r3) >> 1@
-	
-	add					r0, r0, r5					@ r7 = (r1 + i3) >> 1@
-	sub					r1, r1, r4					@ i7 = (i1 - r3) >> 1@
-	
-	mov					r6, r6, asr #1			@
-	mov					r7, r7, asr #1			@
-	
-	mov					r8, r8, asr #1
-	mov					r9, r9, asr #1
-	
-	mov					r2, r2, asr #1
-	mov					r3, r3, asr #1
-	
-	mov					r0, r0, asr #1
-	mov					r1, r1, asr #1	
-	
-	str					r6, [sp]
-	str					r7, [sp, #4]
-	
-	str					r8, [sp, #8]
-	str					r9, [sp, #12]
-	
-	str					r2, [sp, #16]
-	str					r3, [sp, #20]	
-	
-	str					r0, [sp, #24]
-	str					r1, [sp, #28]	
-	
-	ldrd				r2, [r14, #32]		
-	ldrd				r4, [r14, #40]
-	ldrd				r6, [r14, #48]
-	ldrd				r8, [r14, #56]
-	
-	add					r0, r2, r4					@ r0 = buf[ 8] + buf[10]@
-	add					r1, r3, r5					@ i0 = buf[ 9] + buf[11]@
-	
-	sub					r2, r2, r4					@ r1 = buf[ 8] - buf[10]@
-	sub					r3, r3, r5					@ i1 = buf[ 9] - buf[11]@
-	
-	add					r4, r6, r8					@ r2 = buf[12] + buf[14]@
-	add					r5, r7, r9					@ i2 = buf[13] + buf[15]@
-	
-	sub					r6, r6, r8					@ r3 = buf[12] - buf[14]@
-	sub					r7, r7, r9					@	i3 = buf[13] - buf[15]@
-	
-	add					r8, r0, r4					@ t0 = (r0 + r2)
-	add					r9, r1, r5					@ t1 = (i0 + i2)
-	
-	sub					r0, r0, r4					@ t2 = (r0 - r2)
-	sub					r1, r1, r5					@ t3 = (i0 - i2)
-	
-	mov					r8, r8, asr #1
-	ldr					r4, [sp]
-	
-	mov					r9, r9, asr #1
-	ldr					r5, [sp, #4]
-	
-	mov					r0, r0, asr #1		
-	mov					r1, r1, asr #1
-	
-	add					r10, r4, r8					@ buf[ 0] = r4 + t0@
-	add					r11, r5, r9					@ buf[ 1] = i4 + t1@
-	
-	sub					r4,  r4, r8					@ buf[ 8] = r4 - t0@
-	sub					r5,  r5, r9					@	buf[ 9] = i4 - t1@
-	
- 	strd				r10, [r14]
- 	strd				r4,  [r14, #32]
- 	
- 	ldr					r10, [sp, #8]
- 	ldr					r11, [sp, #12]
- 	
- 	add					r4, r10, r1					@ buf[ 4] = r5 + t3@
- 	sub					r5, r11, r0					@	buf[ 5] = i5 - t2@
- 	
- 	sub					r10, r10, r1				@ buf[12] = r5 - t3@
- 	add					r11, r11, r0				@ buf[13] = i5 + t2@
- 	
- 	strd				r4,  [r14, #16]
- 	strd				r10, [r14, #48]
- 	
- 	sub					r0, r2, r7					@ r0 = r1 - i3@
- 	add					r1, r3, r6					@ i0 = i1 + r3@
- 
-  ldr					r11, DATATab
- 	
- 	add					r2, r2, r7					@ r2 = r1 + i3@
- 	sub					r3, r3, r6					@ i2 = i1 - r3@
- 	
-	sub					r4, r0, r1					@ r0 - i0
-	add					r5, r0, r1					@ r0 + i0
-	
-	sub					r0, r2, r3					@ r2 - i2
-	add					r1, r2, r3					@ r2 + i2
-	
-	smull				r8, r6, r4, r11								
-	smull				r9, r7, r5, r11								
-	
-	ldr					r2, [sp, #16]
-	ldr					r3, [sp, #20]
-	
-	smull				r8, r4, r0, r11								
-	smull				r9, r5, r1, r11								
-	
-	ldr					r10, [sp, #24]
-	ldr					r11, [sp, #28]
-	
-	sub					r8, r2, r6
-	sub					r9, r3, r7
-	
-	add					r2, r2, r6
-	add					r3, r3, r7
-	
-	add					r6, r10, r5
-	sub					r7, r11, r4
-	
-	sub					r0, r10, r5
-	add					r1, r11, r4
-	
-	strd				r6, [r14, #8]
-	strd				r8, [r14, #24]
-	strd				r0, [r14, #40]
-	strd				r2, [r14, #56]
-	
-	subs				r12, r12, #1
-	add					r14, r14, #64
-	
-	bne					Radix8First_LOOP
-	
-Radix8First_END:
-	add         sp, sp, #0x24
-	ldmia       sp!, {r4 - r11, pc}
-	
-DATATab:
-	.word       0x5a82799a
-	
-	@ENDP  @ |Radix8First|
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		R4R8First_v5.s
+@
+@	Content:	Radix8First and Radix4First function armv5 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+	.section .text
+	.global	Radix4First
+
+Radix4First:
+	stmdb       sp!, {r4 - r11, lr}
+
+	movs				r10, r1
+	mov					r11, r0
+	beq					Radix4First_END
+
+Radix4First_LOOP:
+	ldrd				r0, [r11]
+	ldrd				r2, [r11, #8]
+	ldrd				r4, [r11, #16]
+	ldrd				r6, [r11, #24]
+
+	add					r8, r0, r2
+	add					r9, r1, r3
+
+	sub					r0, r0, r2
+	sub					r1, r1, r3
+
+	add					r2, r4, r6
+	add					r3, r5, r7
+
+	sub					r4, r4, r6
+	sub					r5, r5, r7
+
+	add					r6, r8, r2
+	add					r7, r9, r3
+
+	sub					r8, r8, r2
+	sub					r9, r9, r3
+
+	add					r2, r0, r5
+	sub					r3, r1, r4
+
+	sub					r0, r0, r5
+	add					r1, r1, r4
+
+	strd				r6, [r11]
+	strd				r2, [r11, #8]
+	strd				r8, [r11, #16]
+	strd				r0, [r11, #24]
+
+	subs				r10, r10, #1
+	add					r11, r11, #32
+	bne					Radix4First_LOOP
+
+Radix4First_END:
+	ldmia       sp!, {r4 - r11, pc}
+	@ENDP  @ |Radix4First|
+
+	.section .text
+	.global	Radix8First
+
+Radix8First:
+	stmdb       sp!, {r4 - r11, lr}
+	sub         sp, sp, #0x24
+
+	mov				  r12, r1
+	mov					r14, r0
+	cmp					r12, #0
+	beq					Radix8First_END
+
+Radix8First_LOOP:
+	ldrd				r0, [r14]
+	ldrd				r2, [r14, #8]
+	ldrd				r4, [r14, #16]
+	ldrd				r6, [r14, #24]
+
+	add					r8, r0, r2					@ r0 = buf[0] + buf[2]@
+	add					r9, r1, r3					@ i0 = buf[1] + buf[3]@
+
+	sub					r0, r0, r2					@ r1 = buf[0] - buf[2]@
+	sub					r1, r1, r3					@ i1 = buf[1] - buf[3]@
+
+	add					r2, r4, r6					@	r2 = buf[4] + buf[6]@
+	add					r3, r5, r7					@ i2 = buf[5] + buf[7]@
+
+	sub					r4, r4, r6					@	r3 = buf[4] - buf[6]@
+	sub					r5, r5, r7					@ i3 = buf[5] - buf[7]@
+
+	add					r6, r8, r2					@ r4 = (r0 + r2) >> 1@
+	add					r7, r9, r3					@ i4 = (i0 + i2) >> 1@
+
+	sub					r8, r8, r2					@	r5 = (r0 - r2) >> 1@
+	sub					r9, r9, r3					@ i5 = (i0 - i2) >> 1@
+
+	sub					r2, r0, r5					@ r6 = (r1 - i3) >> 1@
+	add					r3, r1, r4					@ i6 = (i1 + r3) >> 1@
+
+	add					r0, r0, r5					@ r7 = (r1 + i3) >> 1@
+	sub					r1, r1, r4					@ i7 = (i1 - r3) >> 1@
+
+	mov					r6, r6, asr #1			@
+	mov					r7, r7, asr #1			@
+
+	mov					r8, r8, asr #1
+	mov					r9, r9, asr #1
+
+	mov					r2, r2, asr #1
+	mov					r3, r3, asr #1
+
+	mov					r0, r0, asr #1
+	mov					r1, r1, asr #1
+
+	str					r6, [sp]
+	str					r7, [sp, #4]
+
+	str					r8, [sp, #8]
+	str					r9, [sp, #12]
+
+	str					r2, [sp, #16]
+	str					r3, [sp, #20]
+
+	str					r0, [sp, #24]
+	str					r1, [sp, #28]
+
+	ldrd				r2, [r14, #32]
+	ldrd				r4, [r14, #40]
+	ldrd				r6, [r14, #48]
+	ldrd				r8, [r14, #56]
+
+	add					r0, r2, r4					@ r0 = buf[ 8] + buf[10]@
+	add					r1, r3, r5					@ i0 = buf[ 9] + buf[11]@
+
+	sub					r2, r2, r4					@ r1 = buf[ 8] - buf[10]@
+	sub					r3, r3, r5					@ i1 = buf[ 9] - buf[11]@
+
+	add					r4, r6, r8					@ r2 = buf[12] + buf[14]@
+	add					r5, r7, r9					@ i2 = buf[13] + buf[15]@
+
+	sub					r6, r6, r8					@ r3 = buf[12] - buf[14]@
+	sub					r7, r7, r9					@	i3 = buf[13] - buf[15]@
+
+	add					r8, r0, r4					@ t0 = (r0 + r2)
+	add					r9, r1, r5					@ t1 = (i0 + i2)
+
+	sub					r0, r0, r4					@ t2 = (r0 - r2)
+	sub					r1, r1, r5					@ t3 = (i0 - i2)
+
+	mov					r8, r8, asr #1
+	ldr					r4, [sp]
+
+	mov					r9, r9, asr #1
+	ldr					r5, [sp, #4]
+
+	mov					r0, r0, asr #1
+	mov					r1, r1, asr #1
+
+	add					r10, r4, r8					@ buf[ 0] = r4 + t0@
+	add					r11, r5, r9					@ buf[ 1] = i4 + t1@
+
+	sub					r4,  r4, r8					@ buf[ 8] = r4 - t0@
+	sub					r5,  r5, r9					@	buf[ 9] = i4 - t1@
+
+ 	strd				r10, [r14]
+ 	strd				r4,  [r14, #32]
+
+ 	ldr					r10, [sp, #8]
+ 	ldr					r11, [sp, #12]
+
+ 	add					r4, r10, r1					@ buf[ 4] = r5 + t3@
+ 	sub					r5, r11, r0					@	buf[ 5] = i5 - t2@
+
+ 	sub					r10, r10, r1				@ buf[12] = r5 - t3@
+ 	add					r11, r11, r0				@ buf[13] = i5 + t2@
+
+ 	strd				r4,  [r14, #16]
+ 	strd				r10, [r14, #48]
+
+ 	sub					r0, r2, r7					@ r0 = r1 - i3@
+ 	add					r1, r3, r6					@ i0 = i1 + r3@
+
+  ldr					r11, DATATab
+
+ 	add					r2, r2, r7					@ r2 = r1 + i3@
+ 	sub					r3, r3, r6					@ i2 = i1 - r3@
+
+	sub					r4, r0, r1					@ r0 - i0
+	add					r5, r0, r1					@ r0 + i0
+
+	sub					r0, r2, r3					@ r2 - i2
+	add					r1, r2, r3					@ r2 + i2
+
+	smull				r8, r6, r4, r11
+	smull				r9, r7, r5, r11
+
+	ldr					r2, [sp, #16]
+	ldr					r3, [sp, #20]
+
+	smull				r8, r4, r0, r11
+	smull				r9, r5, r1, r11
+
+	ldr					r10, [sp, #24]
+	ldr					r11, [sp, #28]
+
+	sub					r8, r2, r6
+	sub					r9, r3, r7
+
+	add					r2, r2, r6
+	add					r3, r3, r7
+
+	add					r6, r10, r5
+	sub					r7, r11, r4
+
+	sub					r0, r10, r5
+	add					r1, r11, r4
+
+	strd				r6, [r14, #8]
+	strd				r8, [r14, #24]
+	strd				r0, [r14, #40]
+	strd				r2, [r14, #56]
+
+	subs				r12, r12, #1
+	add					r14, r14, #64
+
+	bne					Radix8First_LOOP
+
+Radix8First_END:
+	add         sp, sp, #0x24
+	ldmia       sp!, {r4 - r11, pc}
+
+DATATab:
+	.word       0x5a82799a
+
+	@ENDP  @ |Radix8First|
 	.end
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/Radix4FFT_v5.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/Radix4FFT_v5.s
index db8e5d8..e81c82e 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/Radix4FFT_v5.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/Radix4FFT_v5.s
@@ -1,169 +1,169 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		Radix4FFT_v5.s
-@
-@	Content:	Radix4FFT armv5 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-	.section .text
-	.global	Radix4FFT
-
-Radix4FFT:
-	stmdb     sp!, {r4 - r11, lr}
-	sub       sp, sp, #32                     
-
-	mov			r1, r1, asr #2
-	cmp     r1, #0       
-	beq     Radix4FFT_END                            
-                       
-Radix4FFT_LOOP1:          
-	mov     r14, r0          							@ xptr = buf@          
-	mov		r10, r1 												@ i = num@
-	mov     r9, r2, lsl #3  							@ step = 2*bgn@
-	cmp     r10, #0  
-	str		r0, [sp] 
-	str		r1, [sp, #4]      
-	str		r2, [sp, #8]
-	str		r3, [sp, #12]  
-	beq     Radix4FFT_LOOP1_END                            	    
-     
-Radix4FFT_LOOP2:                       
-	mov     r12, r3				        				@ csptr = twidTab@
-	mov		r11, r2												@ j = bgn
-	cmp     r11, #0        
-	str		r10, [sp, #16]
-	beq     Radix4FFT_LOOP2_END                         
-	 
-Radix4FFT_LOOP3:                          
-	str			r11, [sp, #20]	 
-	
-	ldrd		r0, [r14, #0]									@ r0 = xptr[0]@ r1 = xptr[1]@
-	add			r14, r14, r9 	 								@ xptr += step@
-	
-	ldrd		r10,	[r14, #0]  					 			@ r2 = xptr[0]@ r3 = xptr[1]@	
-	ldr			r8, [r12], #4									@ cosxsinx = csptr[0]@
-	
-	smulwt	r4, r10, r8										@ L_mpy_wx(cosx, t0)
-	smulwt	r3, r11, r8										@ L_mpy_wx(cosx, t1)
-	
-	smlawb	r2, r11, r8, r4								@ r2 = L_mpy_wx(cosx, t0) + L_mpy_wx(sinx, t1)@
-	smulwb	r5, r10, r8										@ L_mpy_wx(sinx, t0)
-	
-	mov			r10, r0, asr #2								@ t0 = r0 >> 2@
-	mov			r11, r1, asr #2								@	t1 = r1 >> 2@
-		
-	sub			r3, r3, r5										@ r3 = L_mpy_wx(cosx, t1) - L_mpy_wx(sinx, t0)@
-	add     r14, r14, r9 	 								@ xptr += step@
-	
-	sub			r0, r10, r2										@ r0 = t0 - r2@
-	sub			r1, r11, r3									  @ r1 = t1 - r3@
-	
-	add			r2, r10, r2										@ r2 = t0 + r2@
-	add			r3, r11, r3										@ r3 = t1 + r3@
-	
-	str			r2, [sp, #24]
-	str			r3, [sp, #28]
-	
-	ldrd		r10, [r14, #0]								@ r4 = xptr[0]@ r5 = xptr[1]@
-	ldr			r8, [r12], #4									@ cosxsinx = csptr[1]@
-	
-	smulwt	r6, r10, r8										@ L_mpy_wx(cosx, t0)
-	smulwt	r5, r11, r8										@ L_mpy_wx(cosx, t1)
-	
-	smlawb	r4, r11, r8, r6								@ r4 = L_mpy_wx(cosx, t0) + L_mpy_wx(sinx, t1)@
-	smulwb	r7, r10, r8										@ L_mpy_wx(sinx, t0)
-	
-	add			r14, r14, r9									@ xptr += step@
-	sub			r5, r5, r7										@ r5 = L_mpy_wx(cosx, t1) - L_mpy_wx(sinx, t0)@
-		
-	ldrd		r10, [r14]										@ r6 = xptr[0]@ r7 = xptr[1]@
-	ldr			r8, [r12], #4									@ cosxsinx = csptr[1]@
-	
-	smulwt	r2, r10, r8										@ L_mpy_wx(cosx, t0)
-	smulwt	r7, r11, r8										@ L_mpy_wx(cosx, t1)
-	
-	smlawb	r6, r11, r8, r2								@ r4 = L_mpy_wx(cosx, t0) + L_mpy_wx(sinx, t1)@
-	smulwb	r3, r10, r8										@ L_mpy_wx(sinx, t0)
-	
-	mov			r10, r4												@ t0 = r4@
-	mov			r11, r5												@ t1 = r5@	
-	
-	sub			r7, r7, r3										@ r5 = L_mpy_wx(cosx, t1) - L_mpy_wx(sinx, t0)@
-	
-
-	add			r4,  r10, r6									@	r4 = t0 + r6@	
-	sub			r5, r7, r11										@ r5 = r7 - t1@
-	
-	sub			r6, r10, r6										@ r6 = t0 - r6@
-	add			r7, r7, r11										@ r7 = r7 + t1@
-	
-	ldr			r2, [sp, #24]
-	ldr			r3, [sp, #28]
-	
-	add			r10, r0, r5										@ xptr[0] = r0 + r5@
-	add			r11, r1, r6										@ xptr[0] = r1 + r6
-	
-	strd		r10, [r14]										
-	sub			r14, r14, r9									@ xptr -= step@
-	
-	sub			r10, r2, r4										@	xptr[0] = r2 - r4@
-	sub			r11, r3, r7										@ xptr[1] = r3 - r7@
-	
-	strd		r10, [r14]				
-	sub			r14, r14, r9									@ xptr -= step@
-	
-	sub			r10, r0, r5										@ xptr[0] = r0 - r5@
-	sub			r11, r1, r6										@ xptr[0] = r1 - r6
-	
-	strd		r10, [r14]										
-	sub			r14, r14, r9									@ xptr -= step@
-	
-	add			r10, r2, r4										@	xptr[0] = r2 - r4@
-	add			r11, r3, r7										@ xptr[1] = r3 - r7@
-	
-	strd		r10, [r14]				
-	add			r14, r14, #8									@ xptr += 2@
-	
-	ldr			r11, [sp, #20]
-	subs		r11, r11, #1
-	bne			Radix4FFT_LOOP3	
-	 
-Radix4FFT_LOOP2_END:           
-	ldr			r10, [sp, #16]
-	ldr			r3, [sp, #12]
-	ldr			r2, [sp, #8]
-	rsb			r8, r9, r9, lsl #2   
-	sub			r10, r10, #1
-	add			r14, r14, r8		      
-	cmp			r10, #0  
-	bhi     Radix4FFT_LOOP2           
-                        
-Radix4FFT_LOOP1_END:               
-	ldr     r0, [sp]    
-	ldr		r1, [sp, #4]
-	add     r3, r3, r8, asr #1
-	mov     r2, r2, lsl #2 
-	movs    r1, r1, asr #2 
-	bne     Radix4FFT_LOOP1          
-                        
-Radix4FFT_END:                        
-	add     sp, sp, #32                  
-	ldmia   sp!, {r4 - r11, pc}
-		
-	@ENDP  @ |Radix4FFT|
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		Radix4FFT_v5.s
+@
+@	Content:	Radix4FFT armv5 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+	.section .text
+	.global	Radix4FFT
+
+Radix4FFT:
+	stmdb     sp!, {r4 - r11, lr}
+	sub       sp, sp, #32
+
+	mov			r1, r1, asr #2
+	cmp     r1, #0
+	beq     Radix4FFT_END
+
+Radix4FFT_LOOP1:
+	mov     r14, r0          							@ xptr = buf@
+	mov		r10, r1 												@ i = num@
+	mov     r9, r2, lsl #3  							@ step = 2*bgn@
+	cmp     r10, #0
+	str		r0, [sp]
+	str		r1, [sp, #4]
+	str		r2, [sp, #8]
+	str		r3, [sp, #12]
+	beq     Radix4FFT_LOOP1_END
+
+Radix4FFT_LOOP2:
+	mov     r12, r3				        				@ csptr = twidTab@
+	mov		r11, r2												@ j = bgn
+	cmp     r11, #0
+	str		r10, [sp, #16]
+	beq     Radix4FFT_LOOP2_END
+
+Radix4FFT_LOOP3:
+	str			r11, [sp, #20]
+
+	ldrd		r0, [r14, #0]									@ r0 = xptr[0]@ r1 = xptr[1]@
+	add			r14, r14, r9 	 								@ xptr += step@
+
+	ldrd		r10,	[r14, #0]  					 			@ r2 = xptr[0]@ r3 = xptr[1]@
+	ldr			r8, [r12], #4									@ cosxsinx = csptr[0]@
+
+	smulwt	r4, r10, r8										@ L_mpy_wx(cosx, t0)
+	smulwt	r3, r11, r8										@ L_mpy_wx(cosx, t1)
+
+	smlawb	r2, r11, r8, r4								@ r2 = L_mpy_wx(cosx, t0) + L_mpy_wx(sinx, t1)@
+	smulwb	r5, r10, r8										@ L_mpy_wx(sinx, t0)
+
+	mov			r10, r0, asr #2								@ t0 = r0 >> 2@
+	mov			r11, r1, asr #2								@	t1 = r1 >> 2@
+
+	sub			r3, r3, r5										@ r3 = L_mpy_wx(cosx, t1) - L_mpy_wx(sinx, t0)@
+	add     r14, r14, r9 	 								@ xptr += step@
+
+	sub			r0, r10, r2										@ r0 = t0 - r2@
+	sub			r1, r11, r3									  @ r1 = t1 - r3@
+
+	add			r2, r10, r2										@ r2 = t0 + r2@
+	add			r3, r11, r3										@ r3 = t1 + r3@
+
+	str			r2, [sp, #24]
+	str			r3, [sp, #28]
+
+	ldrd		r10, [r14, #0]								@ r4 = xptr[0]@ r5 = xptr[1]@
+	ldr			r8, [r12], #4									@ cosxsinx = csptr[1]@
+
+	smulwt	r6, r10, r8										@ L_mpy_wx(cosx, t0)
+	smulwt	r5, r11, r8										@ L_mpy_wx(cosx, t1)
+
+	smlawb	r4, r11, r8, r6								@ r4 = L_mpy_wx(cosx, t0) + L_mpy_wx(sinx, t1)@
+	smulwb	r7, r10, r8										@ L_mpy_wx(sinx, t0)
+
+	add			r14, r14, r9									@ xptr += step@
+	sub			r5, r5, r7										@ r5 = L_mpy_wx(cosx, t1) - L_mpy_wx(sinx, t0)@
+
+	ldrd		r10, [r14]										@ r6 = xptr[0]@ r7 = xptr[1]@
+	ldr			r8, [r12], #4									@ cosxsinx = csptr[1]@
+
+	smulwt	r2, r10, r8										@ L_mpy_wx(cosx, t0)
+	smulwt	r7, r11, r8										@ L_mpy_wx(cosx, t1)
+
+	smlawb	r6, r11, r8, r2								@ r4 = L_mpy_wx(cosx, t0) + L_mpy_wx(sinx, t1)@
+	smulwb	r3, r10, r8										@ L_mpy_wx(sinx, t0)
+
+	mov			r10, r4												@ t0 = r4@
+	mov			r11, r5												@ t1 = r5@
+
+	sub			r7, r7, r3										@ r5 = L_mpy_wx(cosx, t1) - L_mpy_wx(sinx, t0)@
+
+
+	add			r4,  r10, r6									@	r4 = t0 + r6@
+	sub			r5, r7, r11										@ r5 = r7 - t1@
+
+	sub			r6, r10, r6										@ r6 = t0 - r6@
+	add			r7, r7, r11										@ r7 = r7 + t1@
+
+	ldr			r2, [sp, #24]
+	ldr			r3, [sp, #28]
+
+	add			r10, r0, r5										@ xptr[0] = r0 + r5@
+	add			r11, r1, r6										@ xptr[0] = r1 + r6
+
+	strd		r10, [r14]
+	sub			r14, r14, r9									@ xptr -= step@
+
+	sub			r10, r2, r4										@	xptr[0] = r2 - r4@
+	sub			r11, r3, r7										@ xptr[1] = r3 - r7@
+
+	strd		r10, [r14]
+	sub			r14, r14, r9									@ xptr -= step@
+
+	sub			r10, r0, r5										@ xptr[0] = r0 - r5@
+	sub			r11, r1, r6										@ xptr[0] = r1 - r6
+
+	strd		r10, [r14]
+	sub			r14, r14, r9									@ xptr -= step@
+
+	add			r10, r2, r4										@	xptr[0] = r2 - r4@
+	add			r11, r3, r7										@ xptr[1] = r3 - r7@
+
+	strd		r10, [r14]
+	add			r14, r14, #8									@ xptr += 2@
+
+	ldr			r11, [sp, #20]
+	subs		r11, r11, #1
+	bne			Radix4FFT_LOOP3
+
+Radix4FFT_LOOP2_END:
+	ldr			r10, [sp, #16]
+	ldr			r3, [sp, #12]
+	ldr			r2, [sp, #8]
+	rsb			r8, r9, r9, lsl #2
+	sub			r10, r10, #1
+	add			r14, r14, r8
+	cmp			r10, #0
+	bhi     Radix4FFT_LOOP2
+
+Radix4FFT_LOOP1_END:
+	ldr     r0, [sp]
+	ldr		r1, [sp, #4]
+	add     r3, r3, r8, asr #1
+	mov     r2, r2, lsl #2
+	movs    r1, r1, asr #2
+	bne     Radix4FFT_LOOP1
+
+Radix4FFT_END:
+	add     sp, sp, #32
+	ldmia   sp!, {r4 - r11, pc}
+
+	@ENDP  @ |Radix4FFT|
 	.end
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/band_nrg_v5.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/band_nrg_v5.s
index a463dfd..4789f6d 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/band_nrg_v5.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV5E/band_nrg_v5.s
@@ -1,204 +1,204 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		band_nrg_v5.s
-@
-@	Content:	CalcBandEnergy and CalcBandEnergyMS function armv5 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-	.section .text
-
-	.global	CalcBandEnergy
-
-CalcBandEnergy:
-	stmdb   sp!, {r4 - r11, lr}	
-                   
-  mov     r2, r2, lsl #16                   
-	ldr     r12, [r13, #36]
-	mov			r9, #0
-  mov     r5, r2, asr #16    
-	mov			r4, #0               
-  cmp     r5, #0	
-	ble     L212 
-
-L22:
-  mov     r2, r4, lsl #1                    
-  ldrsh   r10, [r1, r2]                     
-  add     r11, r1, r2                       
-  ldrsh   r2, [r11, #2]    
-	mov     r14, #0                 
-  cmp     r10, r2                           
-  bge     L28 
-	
-L23:
-	ldr     r11, [r0, +r10, lsl #2]	
-  add     r10, r10, #1    
-	ldr     r6, [r0, +r10, lsl #2]	
-	smull   r11, r7, r11, r11
-	add     r10, r10, #1 
-	smull	  r6, r8, r6, r6
-	ldr     r11, [r0, +r10, lsl #2]
-	qadd	  r14, r14, r7
-	add     r10, r10, #1
-	smull	  r11, r7, r11, r11
-	ldr     r6, [r0, +r10, lsl #2]
-	qadd	  r14, r14, r8
-	smull	  r6, r8, r6, r6
-  add     r10, r10, #1 
-	qadd	  r14, r14, r7
-	cmp     r10, r2
-	qadd	  r14, r14, r8
-	blt     L23   
-
-L28:	
-	qadd	  r14, r14, r14
-	str     r14, [r3, +r4, lsl #2]
-	add     r4, r4, #1 
-	qadd	  r9, r9, r14
-	cmp     r4, r5                          
-
-  blt     L22       	
-
-L212:	
-	str     r9, [r12, #0]                     
-	ldmia   sp!, {r4 - r11, pc}
-	
-	@ENDP  ; |CalcBandEnergy|
-	
-	.global	CalcBandEnergyMS
-
-CalcBandEnergyMS:
-	stmdb   sp!, {r4 - r11, lr}
-	sub     r13, r13, #24
-	
-	mov     r12, #0 
-  mov     r3, r3, lsl #16  
-  mov     r14, #0 
-	mov     r3, r3, asr #16      
-	cmp     r3, #0          
-	mov		  r4, #0                  
-  ble     L315    
-	
-L32:	
-	mov		  r5, r4, lsl #1
-	mov		  r6, #0
-	ldrsh   r10, [r2, r5]
-	add     r5, r2, r5
-	mov		  r7, #0
-	ldrsh	  r11, [r5, #2]                        
-	cmp     r10, r11                          
-  bge     L39    
-
-	str		  r3, [r13, #4]
-	str		  r4, [r13, #8]
-	str		  r12, [r13, #12]
-	str		  r14, [r13, #16]
-
-L33:	
-	ldr     r8, [r0, +r10, lsl #2]                    
-	ldr     r9, [r1, +r10, lsl #2]
-	mov		  r8, r8, asr #1
-	add		  r10, r10, #1
-	mov		  r9, r9, asr #1
-
-	ldr     r12, [r0, +r10, lsl #2]          
-	add		  r5, r8, r9	          
-	ldr     r14, [r1, +r10, lsl #2]
-	sub		  r8, r8, r9
-
-	smull   r5, r3, r5, r5 
-	mov		  r12, r12, asr #1
-	smull   r8, r4, r8, r8 
-	mov		  r14, r14, asr #1
-
-	qadd	  r6, r6, r3
-	add		  r5, r12, r14
-	qadd	  r7, r7, r4
-	sub		  r8, r12, r14
-
-	smull   r5, r3, r5, r5 
-	add		  r10, r10, #1
-	smull   r8, r4, r8, r8 
-		
-	qadd	  r6, r6, r3
-	qadd	  r7, r7, r4
-
-	ldr     r8, [r0, +r10, lsl #2]                    
-	ldr     r9, [r1, +r10, lsl #2]
-	mov		  r8, r8, asr #1
-	add		  r10, r10, #1
-	mov		  r9, r9, asr #1
-
-	ldr     r12, [r0, +r10, lsl #2]          
-	add		  r5, r8, r9	          
-	ldr     r14, [r1, +r10, lsl #2]
-	sub		  r8, r8, r9
-
-	smull   r5, r3, r5, r5 
-	mov		  r12, r12, asr #1
-	smull   r8, r4, r8, r8 
-	mov		  r14, r14, asr #1
-
-	qadd	  r6, r6, r3
-	add		  r5, r12, r14
-	qadd	  r7, r7, r4
-	sub		  r8, r12, r14
-
-	smull   r5, r3, r5, r5 
-	add		  r10, r10, #1
-	smull   r8, r4, r8, r8 
-		
-	qadd	  r6, r6, r3
-	qadd	  r7, r7, r4
-
-	cmp     r10, r11
-	
-	blt		  L33
-
-	ldr		  r3, [r13, #4]
-	ldr		  r4, [r13, #8]	
-	ldr		  r12, [r13, #12]
-	ldr		  r14, [r13, #16]
-L39:	
-	qadd	  r6, r6, r6
-	qadd	  r7, r7, r7	
-	
-	ldr		  r8, [r13, #60]
-	ldr		  r9, [r13, #68]
-
-	qadd	  r12, r12, r6
-	qadd	  r14, r14, r7
-	
-	str		  r6, [r8, +r4, lsl #2]       
-	str     r7, [r9, +r4, lsl #2]    
-	
-	add		  r4, r4, #1
-	cmp		  r4, r3
-	blt     L32            
-
-L315:
-	ldr		  r8, [r13, #64]
-	ldr		  r9, [r13, #72]
-	str		  r12, [r8, #0]
-	str		  r14, [r9, #0]
-
-	add     r13, r13, #24
-	ldmia   sp!, {r4 - r11, pc}
-	@ENDP  ; |CalcBandEnergyMS|
-
-	.end
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		band_nrg_v5.s
+@
+@	Content:	CalcBandEnergy and CalcBandEnergyMS function armv5 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+	.section .text
+
+	.global	CalcBandEnergy
+
+CalcBandEnergy:
+	stmdb   sp!, {r4 - r11, lr}
+
+  mov     r2, r2, lsl #16
+	ldr     r12, [r13, #36]
+	mov			r9, #0
+  mov     r5, r2, asr #16
+	mov			r4, #0
+  cmp     r5, #0
+	ble     L212
+
+L22:
+  mov     r2, r4, lsl #1
+  ldrsh   r10, [r1, r2]
+  add     r11, r1, r2
+  ldrsh   r2, [r11, #2]
+	mov     r14, #0
+  cmp     r10, r2
+  bge     L28
+
+L23:
+	ldr     r11, [r0, +r10, lsl #2]
+  add     r10, r10, #1
+	ldr     r6, [r0, +r10, lsl #2]
+	smull   r11, r7, r11, r11
+	add     r10, r10, #1
+	smull	  r6, r8, r6, r6
+	ldr     r11, [r0, +r10, lsl #2]
+	qadd	  r14, r14, r7
+	add     r10, r10, #1
+	smull	  r11, r7, r11, r11
+	ldr     r6, [r0, +r10, lsl #2]
+	qadd	  r14, r14, r8
+	smull	  r6, r8, r6, r6
+  add     r10, r10, #1
+	qadd	  r14, r14, r7
+	cmp     r10, r2
+	qadd	  r14, r14, r8
+	blt     L23
+
+L28:
+	qadd	  r14, r14, r14
+	str     r14, [r3, +r4, lsl #2]
+	add     r4, r4, #1
+	qadd	  r9, r9, r14
+	cmp     r4, r5
+
+  blt     L22
+
+L212:
+	str     r9, [r12, #0]
+	ldmia   sp!, {r4 - r11, pc}
+
+	@ENDP  ; |CalcBandEnergy|
+
+	.global	CalcBandEnergyMS
+
+CalcBandEnergyMS:
+	stmdb   sp!, {r4 - r11, lr}
+	sub     r13, r13, #24
+
+	mov     r12, #0
+  mov     r3, r3, lsl #16
+  mov     r14, #0
+	mov     r3, r3, asr #16
+	cmp     r3, #0
+	mov		  r4, #0
+  ble     L315
+
+L32:
+	mov		  r5, r4, lsl #1
+	mov		  r6, #0
+	ldrsh   r10, [r2, r5]
+	add     r5, r2, r5
+	mov		  r7, #0
+	ldrsh	  r11, [r5, #2]
+	cmp     r10, r11
+  bge     L39
+
+	str		  r3, [r13, #4]
+	str		  r4, [r13, #8]
+	str		  r12, [r13, #12]
+	str		  r14, [r13, #16]
+
+L33:
+	ldr     r8, [r0, +r10, lsl #2]
+	ldr     r9, [r1, +r10, lsl #2]
+	mov		  r8, r8, asr #1
+	add		  r10, r10, #1
+	mov		  r9, r9, asr #1
+
+	ldr     r12, [r0, +r10, lsl #2]
+	add		  r5, r8, r9
+	ldr     r14, [r1, +r10, lsl #2]
+	sub		  r8, r8, r9
+
+	smull   r5, r3, r5, r5
+	mov		  r12, r12, asr #1
+	smull   r8, r4, r8, r8
+	mov		  r14, r14, asr #1
+
+	qadd	  r6, r6, r3
+	add		  r5, r12, r14
+	qadd	  r7, r7, r4
+	sub		  r8, r12, r14
+
+	smull   r5, r3, r5, r5
+	add		  r10, r10, #1
+	smull   r8, r4, r8, r8
+
+	qadd	  r6, r6, r3
+	qadd	  r7, r7, r4
+
+	ldr     r8, [r0, +r10, lsl #2]
+	ldr     r9, [r1, +r10, lsl #2]
+	mov		  r8, r8, asr #1
+	add		  r10, r10, #1
+	mov		  r9, r9, asr #1
+
+	ldr     r12, [r0, +r10, lsl #2]
+	add		  r5, r8, r9
+	ldr     r14, [r1, +r10, lsl #2]
+	sub		  r8, r8, r9
+
+	smull   r5, r3, r5, r5
+	mov		  r12, r12, asr #1
+	smull   r8, r4, r8, r8
+	mov		  r14, r14, asr #1
+
+	qadd	  r6, r6, r3
+	add		  r5, r12, r14
+	qadd	  r7, r7, r4
+	sub		  r8, r12, r14
+
+	smull   r5, r3, r5, r5
+	add		  r10, r10, #1
+	smull   r8, r4, r8, r8
+
+	qadd	  r6, r6, r3
+	qadd	  r7, r7, r4
+
+	cmp     r10, r11
+
+	blt		  L33
+
+	ldr		  r3, [r13, #4]
+	ldr		  r4, [r13, #8]
+	ldr		  r12, [r13, #12]
+	ldr		  r14, [r13, #16]
+L39:
+	qadd	  r6, r6, r6
+	qadd	  r7, r7, r7
+
+	ldr		  r8, [r13, #60]
+	ldr		  r9, [r13, #68]
+
+	qadd	  r12, r12, r6
+	qadd	  r14, r14, r7
+
+	str		  r6, [r8, +r4, lsl #2]
+	str     r7, [r9, +r4, lsl #2]
+
+	add		  r4, r4, #1
+	cmp		  r4, r3
+	blt     L32
+
+L315:
+	ldr		  r8, [r13, #64]
+	ldr		  r9, [r13, #72]
+	str		  r12, [r8, #0]
+	str		  r14, [r9, #0]
+
+	add     r13, r13, #24
+	ldmia   sp!, {r4 - r11, pc}
+	@ENDP  ; |CalcBandEnergyMS|
+
+	.end
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV7/PrePostMDCT_v7.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV7/PrePostMDCT_v7.s
index bf7dcba..64d767a 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV7/PrePostMDCT_v7.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV7/PrePostMDCT_v7.s
@@ -1,135 +1,135 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		PrePostMDCT_v7.s
-@
-@	Content:	premdct and postmdct function armv7 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-	.section .text
-	.global	PreMDCT
-
-PreMDCT:
-	stmdb     sp!, {r4 - r11, lr}
-	
-	add         r9, r0, r1, lsl #2
-	sub         r3, r9, #32
-
-	movs        r1, r1, asr #2
-	beq         PreMDCT_END	
-	
-PreMDCT_LOOP:
-	VLD4.I32			{d0, d2, d4, d6}, [r2]!				@ cosa = *csptr++@ sina = *csptr++@
-	VLD4.I32			{d1, d3, d5, d7}, [r2]!				@ cosb = *csptr++@ sinb = *csptr++@
-	VLD2.I32			{d8, d9, d10, d11}, [r0]			@ tr1 = *(buf0 + 0)@ ti2 = *(buf0 + 1)@
-	VLD2.I32			{d13, d15}, [r3]!					@ tr2 = *(buf1 - 1)@ ti1 = *(buf1 + 0)@
-	VLD2.I32			{d12, d14}, [r3]!					@ tr2 = *(buf1 - 1)@ ti1 = *(buf1 + 0)@
-		
-	VREV64.32			Q8, Q7	
-	VREV64.32			Q9, Q6
-
-	
-	VQDMULH.S32		Q10, Q0, Q4								@ MULHIGH(cosa, tr1)
-	VQDMULH.S32		Q11, Q1, Q8								@ MULHIGH(sina, ti1)
-	VQDMULH.S32		Q12, Q0, Q8								@ MULHIGH(cosa, ti1)
-	VQDMULH.S32		Q13, Q1, Q4								@ MULHIGH(sina, tr1)
-		
-	VADD.S32			Q0, Q10, Q11						@ *buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@
-	VSUB.S32			Q1, Q12, Q13						@ *buf0++ = MULHIGH(cosa, ti1) - MULHIGH(sina, tr1)@
-	
-	VST2.I32			{d0, d1, d2, d3}, [r0]!
-	sub						r3, r3, #32
-	
-	VQDMULH.S32		Q10, Q2, Q9										@ MULHIGH(cosb, tr2)
-	VQDMULH.S32		Q11, Q3, Q5										@ MULHIGH(sinb, ti2)
-	VQDMULH.S32		Q12, Q2, Q5										@ MULHIGH(cosb, ti2)
-	VQDMULH.S32		Q13, Q3, Q9										@ MULHIGH(sinb, tr2)
-		
-	VADD.S32			Q0, Q10, Q11									@ MULHIGH(cosa, tr2) + MULHIGH(sina, ti2)@
-	VSUB.S32			Q1, Q12, Q13									@ MULHIGH(cosa, ti2) - MULHIGH(sina, tr2)@
-	
-	VREV64.32			Q3, Q1
-	VREV64.32			Q2, Q0
-		
-	VST2.I32		{d5, d7}, [r3]!	
-	VST2.I32		{d4, d6}, [r3]! 
-	
-	subs     		r1, r1, #4
-	sub		  		r3, r3, #64	
-	bne       	PreMDCT_LOOP
-	
-PreMDCT_END:
-	ldmia     sp!, {r4 - r11, pc}
-	@ENDP  @ |PreMDCT|
-
-	.section .text
-	.global	PostMDCT
-
-PostMDCT:
-	stmdb     sp!, {r4 - r11, lr}
-	
-	add         r9, r0, r1, lsl #2
-	sub         r3, r9, #32
-
-	movs        r1, r1, asr #2
-	beq         PostMDCT_END
-	
-PostMDCT_LOOP:
-	VLD4.I32			{d0, d2, d4, d6}, [r2]!				@ cosa = *csptr++@ sina = *csptr++@
-	VLD4.I32			{d1, d3, d5, d7}, [r2]!				@ cosb = *csptr++@ sinb = *csptr++@
-	VLD2.I32			{d8, d9, d10, d11}, [r0]			@ tr1 = *(zbuf1 + 0)@ ti1 = *(zbuf1 + 1)@
-	VLD2.I32			{d13, d15}, [r3]!							@ tr2 = *(zbuf2 - 1)@ ti2 = *(zbuf2 + 0)@
-	VLD2.I32			{d12, d14}, [r3]!							@ tr2 = *(zbuf2 - 1)@ ti2 = *(zbuf2 + 0)@	
-
-	VREV64.32			Q8, Q6	
-	VREV64.32			Q9, Q7			
-	
-	VQDMULH.S32		Q10, Q0, Q4										@ MULHIGH(cosa, tr1)
-	VQDMULH.S32		Q11, Q1, Q5										@ MULHIGH(sina, ti1)
-	VQDMULH.S32		Q12, Q0, Q5										@ MULHIGH(cosa, ti1)
-	VQDMULH.S32		Q13, Q1, Q4										@ MULHIGH(sina, tr1)
-		
-	VADD.S32			Q0, Q10, Q11									@ *buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@
-	VSUB.S32			Q5, Q13, Q12									@ *buf1-- = MULHIGH(sina, tr1) - MULHIGH(cosa, ti1)@
-	
-	VQDMULH.S32		Q10, Q2, Q8										@ MULHIGH(cosb, tr2)
-	VQDMULH.S32		Q11, Q3, Q9										@ MULHIGH(sinb, ti2)
-	VQDMULH.S32		Q12, Q2, Q9										@ MULHIGH(cosb, ti2)
-	VQDMULH.S32		Q13, Q3, Q8										@ MULHIGH(sinb, tr2)
-		
-	VADD.S32			Q4, Q10, Q11									@ *buf1-- = MULHIGH(cosa, tr2) + MULHIGH(sina, ti2)@
-	VSUB.S32			Q1, Q13, Q12									@ *buf0++ = MULHIGH(sina, tr2) - MULHIGH(cosa, ti2)@	
-	
-	VREV64.32			Q2, Q4
-	VREV64.32			Q3, Q5	
-	
-	sub						r3, r3, #32	
-	VST2.I32			{d0, d1, d2, d3}, [r0]!
-		
-	VST2.I32			{d5, d7}, [r3]!	
-	VST2.I32			{d4, d6}, [r3]! 
-	
-	subs     			r1, r1, #4
-	sub		  			r3, r3, #64		
-	bne       	PostMDCT_LOOP
-
-PostMDCT_END:
-	ldmia     sp!, {r4 - r11, pc}
-
-	@ENDP  		@ |PostMDCT|
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		PrePostMDCT_v7.s
+@
+@	Content:	premdct and postmdct function armv7 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+	.section .text
+	.global	PreMDCT
+
+PreMDCT:
+	stmdb     sp!, {r4 - r11, lr}
+
+	add         r9, r0, r1, lsl #2
+	sub         r3, r9, #32
+
+	movs        r1, r1, asr #2
+	beq         PreMDCT_END
+
+PreMDCT_LOOP:
+	VLD4.I32			{d0, d2, d4, d6}, [r2]!				@ cosa = *csptr++@ sina = *csptr++@
+	VLD4.I32			{d1, d3, d5, d7}, [r2]!				@ cosb = *csptr++@ sinb = *csptr++@
+	VLD2.I32			{d8, d9, d10, d11}, [r0]			@ tr1 = *(buf0 + 0)@ ti2 = *(buf0 + 1)@
+	VLD2.I32			{d13, d15}, [r3]!					@ tr2 = *(buf1 - 1)@ ti1 = *(buf1 + 0)@
+	VLD2.I32			{d12, d14}, [r3]!					@ tr2 = *(buf1 - 1)@ ti1 = *(buf1 + 0)@
+
+	VREV64.32			Q8, Q7
+	VREV64.32			Q9, Q6
+
+
+	VQDMULH.S32		Q10, Q0, Q4								@ MULHIGH(cosa, tr1)
+	VQDMULH.S32		Q11, Q1, Q8								@ MULHIGH(sina, ti1)
+	VQDMULH.S32		Q12, Q0, Q8								@ MULHIGH(cosa, ti1)
+	VQDMULH.S32		Q13, Q1, Q4								@ MULHIGH(sina, tr1)
+
+	VADD.S32			Q0, Q10, Q11						@ *buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@
+	VSUB.S32			Q1, Q12, Q13						@ *buf0++ = MULHIGH(cosa, ti1) - MULHIGH(sina, tr1)@
+
+	VST2.I32			{d0, d1, d2, d3}, [r0]!
+	sub						r3, r3, #32
+
+	VQDMULH.S32		Q10, Q2, Q9										@ MULHIGH(cosb, tr2)
+	VQDMULH.S32		Q11, Q3, Q5										@ MULHIGH(sinb, ti2)
+	VQDMULH.S32		Q12, Q2, Q5										@ MULHIGH(cosb, ti2)
+	VQDMULH.S32		Q13, Q3, Q9										@ MULHIGH(sinb, tr2)
+
+	VADD.S32			Q0, Q10, Q11									@ MULHIGH(cosa, tr2) + MULHIGH(sina, ti2)@
+	VSUB.S32			Q1, Q12, Q13									@ MULHIGH(cosa, ti2) - MULHIGH(sina, tr2)@
+
+	VREV64.32			Q3, Q1
+	VREV64.32			Q2, Q0
+
+	VST2.I32		{d5, d7}, [r3]!
+	VST2.I32		{d4, d6}, [r3]!
+
+	subs     		r1, r1, #4
+	sub		  		r3, r3, #64
+	bne       	PreMDCT_LOOP
+
+PreMDCT_END:
+	ldmia     sp!, {r4 - r11, pc}
+	@ENDP  @ |PreMDCT|
+
+	.section .text
+	.global	PostMDCT
+
+PostMDCT:
+	stmdb     sp!, {r4 - r11, lr}
+
+	add         r9, r0, r1, lsl #2
+	sub         r3, r9, #32
+
+	movs        r1, r1, asr #2
+	beq         PostMDCT_END
+
+PostMDCT_LOOP:
+	VLD4.I32			{d0, d2, d4, d6}, [r2]!				@ cosa = *csptr++@ sina = *csptr++@
+	VLD4.I32			{d1, d3, d5, d7}, [r2]!				@ cosb = *csptr++@ sinb = *csptr++@
+	VLD2.I32			{d8, d9, d10, d11}, [r0]			@ tr1 = *(zbuf1 + 0)@ ti1 = *(zbuf1 + 1)@
+	VLD2.I32			{d13, d15}, [r3]!							@ tr2 = *(zbuf2 - 1)@ ti2 = *(zbuf2 + 0)@
+	VLD2.I32			{d12, d14}, [r3]!							@ tr2 = *(zbuf2 - 1)@ ti2 = *(zbuf2 + 0)@
+
+	VREV64.32			Q8, Q6
+	VREV64.32			Q9, Q7
+
+	VQDMULH.S32		Q10, Q0, Q4										@ MULHIGH(cosa, tr1)
+	VQDMULH.S32		Q11, Q1, Q5										@ MULHIGH(sina, ti1)
+	VQDMULH.S32		Q12, Q0, Q5										@ MULHIGH(cosa, ti1)
+	VQDMULH.S32		Q13, Q1, Q4										@ MULHIGH(sina, tr1)
+
+	VADD.S32			Q0, Q10, Q11									@ *buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1)@
+	VSUB.S32			Q5, Q13, Q12									@ *buf1-- = MULHIGH(sina, tr1) - MULHIGH(cosa, ti1)@
+
+	VQDMULH.S32		Q10, Q2, Q8										@ MULHIGH(cosb, tr2)
+	VQDMULH.S32		Q11, Q3, Q9										@ MULHIGH(sinb, ti2)
+	VQDMULH.S32		Q12, Q2, Q9										@ MULHIGH(cosb, ti2)
+	VQDMULH.S32		Q13, Q3, Q8										@ MULHIGH(sinb, tr2)
+
+	VADD.S32			Q4, Q10, Q11									@ *buf1-- = MULHIGH(cosa, tr2) + MULHIGH(sina, ti2)@
+	VSUB.S32			Q1, Q13, Q12									@ *buf0++ = MULHIGH(sina, tr2) - MULHIGH(cosa, ti2)@
+
+	VREV64.32			Q2, Q4
+	VREV64.32			Q3, Q5
+
+	sub						r3, r3, #32
+	VST2.I32			{d0, d1, d2, d3}, [r0]!
+
+	VST2.I32			{d5, d7}, [r3]!
+	VST2.I32			{d4, d6}, [r3]!
+
+	subs     			r1, r1, #4
+	sub		  			r3, r3, #64
+	bne       	PostMDCT_LOOP
+
+PostMDCT_END:
+	ldmia     sp!, {r4 - r11, pc}
+
+	@ENDP  		@ |PostMDCT|
 	.end
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV7/R4R8First_v7.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV7/R4R8First_v7.s
index 99ee68b..7fc5520 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV7/R4R8First_v7.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV7/R4R8First_v7.s
@@ -1,146 +1,146 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		R4R8First_v7.s
-@
-@	Content:	Radix8First and Radix4First function armv7 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-	.section .text
-	.global	Radix8First
-
-Radix8First:
-	stmdb     		sp!, {r4 - r11, lr}
-
-	ldr       		r3, SQRT1_2
-	cmp       		r1, #0
-	
-	VDUP.I32  		Q15, r3	
-	beq       		Radix8First_END
-	
-Radix8First_LOOP:
-	VLD1.I32			{d0, d1, d2, d3},	[r0]!
-	VLD1.I32			{d8, d9, d10, d11},	[r0]!
-		
-	VADD.S32			d4, d0, d1		@ r0 = buf[0] + buf[2]@i0 = buf[1] + buf[3]@
-	VSUB.S32			d5, d0, d1		@ r1 = buf[0] - buf[2]@i1 = buf[1] - buf[3]@	
-	VSUB.S32			d7, d2, d3		@ r2 = buf[4] - buf[6]@i2 = buf[5] - buf[7]@	
-	VADD.S32			d6, d2, d3		@ r3 = buf[4] + buf[6]@i3 = buf[5] + buf[7]@
-	VREV64.I32			d7, d7	
-	
-	VADD.S32			Q0, Q2, Q3		@ r4 = (r0 + r2)@i4 = (i0 + i2)@i6 = (i1 + r3)@r7 = (r1 + i3)
-	VSUB.S32			Q1, Q2, Q3		@ r5 = (r0 - r2)@i5 = (i0 - i2)@r6 = (r1 - i3)@i7 = (i1 - r3)@
-
-	VREV64.I32			d3, d3	
-
-	VADD.S32			d4, d8, d9		@ r0 = buf[ 8] + buf[10]@i0 = buf[ 9] + buf[11]@
-	VSUB.S32			d7, d10, d11	@ r1 = buf[12] - buf[14]@i1 = buf[13] - buf[15]@	
-	VADD.S32			d6, d10, d11	@ r2 = buf[12] + buf[14]@i2 = buf[13] + buf[15]@
-	VREV64.I32			d7, d7	
-	VSUB.S32			d5, d8, d9		@ r3 = buf[ 8] - buf[10]@i3 = buf[ 9] - buf[11]@
-	
-	VTRN.32				d1, d3	
-	
-	VADD.S32			Q4, Q2, Q3		@ t0 = (r0 + r2) >> 1@t1 = (i0 + i2) >> 1@i0 = i1 + r3@r2 = r1 + i3@
-	VSUB.S32			Q5, Q2, Q3		@ t2 = (r0 - r2) >> 1@t3 = (i0 - i2) >> 1@r0 = r1 - i3@i2 = i1 - r3@
-	
-	VREV64.I32			d3, d3
-	
-	VSHR.S32			d8, d8, #1		 
-	VSHR.S32			Q0, Q0, #1
-	VREV64.I32			d10, d10
-	VTRN.32				d11, d9
-	VSHR.S32			Q1, Q1, #1
-	VSHR.S32			d10, d10, #1
-	VREV64.I32			d9, d9
-	
-	sub       			r0, r0, #0x40
-	
-	VADD.S32			d12, d0, d8
-	VSUB.S32			d16, d0, d8	
-	VADD.S32			d14, d2, d10
-	VSUB.S32			d18, d2, d10
-	
-	VSUB.S32			d4, d11, d9
-	VADD.S32			d5, d11, d9
-	
-	VREV64.I32			d18, d18
-	
-	VQDMULH.S32			Q3, Q2, Q15
-	VTRN.32				d14, d18
-	VTRN.32				d6, d7
-	VREV64.I32			d18, d18	
-	
-	VSUB.S32			d15, d3, d6
-	VREV64.I32			d7, d7
-	VADD.S32			d19, d3, d6
-	VADD.S32			d13, d1, d7
-	VSUB.S32			d17, d1, d7
-	
-	VREV64.I32			d17, d17
-	VTRN.32				d13, d17
-	VREV64.I32			d17, d17
-	
-	subs       			r1, r1, #1	
-	
-	VST1.I32			{d12, d13, d14, d15}, [r0]!
-	VST1.I32			{d16, d17, d18, d19}, [r0]!	
-	bne       			Radix8First_LOOP
-	
-Radix8First_END:
-	ldmia     sp!, {r4 - r11, pc}	
-SQRT1_2:
-	.word      0x2d413ccd
-	
-	@ENDP  @ |Radix8First|
-	
-	.section .text
-	.global	Radix4First
-
-Radix4First:
-	stmdb     	sp!, {r4 - r11, lr}
-
-	cmp       	r1, #0
-	beq       	Radix4First_END
-	
-Radix4First_LOOP:
-	VLD1.I32			{d0, d1, d2, d3}, [r0]					
-	
-	VADD.S32			d4, d0, d1							@ r0 = buf[0] + buf[2]@ r1 = buf[1] + buf[3]@		
-	VSUB.S32			d5, d0, d1							@ r2 = buf[0] - buf[2]@ r3 = buf[1] - buf[3]@
-	VSUB.S32			d7, d2, d3							@ r4 = buf[4] + buf[6]@ r5 = buf[5] + buf[7]@
-	VADD.S32			d6, d2, d3							@ r6 = buf[4] - buf[6]@ r7 = buf[5] - buf[7]@
-	
-	VREV64.I32		d7, d7									@ 
-	
-	VADD.S32			Q4, Q2, Q3
-	VSUB.S32			Q5, Q2, Q3
-	
-	VREV64.I32		d11, d11
-	VTRN.32				d9, d11
-	subs       		r1, r1, #1	
-	VREV64.I32		d11, d11
-	VST1.I32			{d8, d9, d10, d11}, [r0]!
-
-	bne       		Radix4First_LOOP
-	
-Radix4First_END:
-	ldmia    		sp!, {r4 - r11, pc}
-
-	@ENDP  @ |Radix4First|
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		R4R8First_v7.s
+@
+@	Content:	Radix8First and Radix4First function armv7 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+	.section .text
+	.global	Radix8First
+
+Radix8First:
+	stmdb     		sp!, {r4 - r11, lr}
+
+	ldr       		r3, SQRT1_2
+	cmp       		r1, #0
+
+	VDUP.I32  		Q15, r3
+	beq       		Radix8First_END
+
+Radix8First_LOOP:
+	VLD1.I32			{d0, d1, d2, d3},	[r0]!
+	VLD1.I32			{d8, d9, d10, d11},	[r0]!
+
+	VADD.S32			d4, d0, d1		@ r0 = buf[0] + buf[2]@i0 = buf[1] + buf[3]@
+	VSUB.S32			d5, d0, d1		@ r1 = buf[0] - buf[2]@i1 = buf[1] - buf[3]@
+	VSUB.S32			d7, d2, d3		@ r2 = buf[4] - buf[6]@i2 = buf[5] - buf[7]@
+	VADD.S32			d6, d2, d3		@ r3 = buf[4] + buf[6]@i3 = buf[5] + buf[7]@
+	VREV64.I32			d7, d7
+
+	VADD.S32			Q0, Q2, Q3		@ r4 = (r0 + r2)@i4 = (i0 + i2)@i6 = (i1 + r3)@r7 = (r1 + i3)
+	VSUB.S32			Q1, Q2, Q3		@ r5 = (r0 - r2)@i5 = (i0 - i2)@r6 = (r1 - i3)@i7 = (i1 - r3)@
+
+	VREV64.I32			d3, d3
+
+	VADD.S32			d4, d8, d9		@ r0 = buf[ 8] + buf[10]@i0 = buf[ 9] + buf[11]@
+	VSUB.S32			d7, d10, d11	@ r1 = buf[12] - buf[14]@i1 = buf[13] - buf[15]@
+	VADD.S32			d6, d10, d11	@ r2 = buf[12] + buf[14]@i2 = buf[13] + buf[15]@
+	VREV64.I32			d7, d7
+	VSUB.S32			d5, d8, d9		@ r3 = buf[ 8] - buf[10]@i3 = buf[ 9] - buf[11]@
+
+	VTRN.32				d1, d3
+
+	VADD.S32			Q4, Q2, Q3		@ t0 = (r0 + r2) >> 1@t1 = (i0 + i2) >> 1@i0 = i1 + r3@r2 = r1 + i3@
+	VSUB.S32			Q5, Q2, Q3		@ t2 = (r0 - r2) >> 1@t3 = (i0 - i2) >> 1@r0 = r1 - i3@i2 = i1 - r3@
+
+	VREV64.I32			d3, d3
+
+	VSHR.S32			d8, d8, #1
+	VSHR.S32			Q0, Q0, #1
+	VREV64.I32			d10, d10
+	VTRN.32				d11, d9
+	VSHR.S32			Q1, Q1, #1
+	VSHR.S32			d10, d10, #1
+	VREV64.I32			d9, d9
+
+	sub       			r0, r0, #0x40
+
+	VADD.S32			d12, d0, d8
+	VSUB.S32			d16, d0, d8
+	VADD.S32			d14, d2, d10
+	VSUB.S32			d18, d2, d10
+
+	VSUB.S32			d4, d11, d9
+	VADD.S32			d5, d11, d9
+
+	VREV64.I32			d18, d18
+
+	VQDMULH.S32			Q3, Q2, Q15
+	VTRN.32				d14, d18
+	VTRN.32				d6, d7
+	VREV64.I32			d18, d18
+
+	VSUB.S32			d15, d3, d6
+	VREV64.I32			d7, d7
+	VADD.S32			d19, d3, d6
+	VADD.S32			d13, d1, d7
+	VSUB.S32			d17, d1, d7
+
+	VREV64.I32			d17, d17
+	VTRN.32				d13, d17
+	VREV64.I32			d17, d17
+
+	subs       			r1, r1, #1
+
+	VST1.I32			{d12, d13, d14, d15}, [r0]!
+	VST1.I32			{d16, d17, d18, d19}, [r0]!
+	bne       			Radix8First_LOOP
+
+Radix8First_END:
+	ldmia     sp!, {r4 - r11, pc}
+SQRT1_2:
+	.word      0x2d413ccd
+
+	@ENDP  @ |Radix8First|
+
+	.section .text
+	.global	Radix4First
+
+Radix4First:
+	stmdb     	sp!, {r4 - r11, lr}
+
+	cmp       	r1, #0
+	beq       	Radix4First_END
+
+Radix4First_LOOP:
+	VLD1.I32			{d0, d1, d2, d3}, [r0]
+
+	VADD.S32			d4, d0, d1							@ r0 = buf[0] + buf[2]@ r1 = buf[1] + buf[3]@
+	VSUB.S32			d5, d0, d1							@ r2 = buf[0] - buf[2]@ r3 = buf[1] - buf[3]@
+	VSUB.S32			d7, d2, d3							@ r4 = buf[4] + buf[6]@ r5 = buf[5] + buf[7]@
+	VADD.S32			d6, d2, d3							@ r6 = buf[4] - buf[6]@ r7 = buf[5] - buf[7]@
+
+	VREV64.I32		d7, d7									@
+
+	VADD.S32			Q4, Q2, Q3
+	VSUB.S32			Q5, Q2, Q3
+
+	VREV64.I32		d11, d11
+	VTRN.32				d9, d11
+	subs       		r1, r1, #1
+	VREV64.I32		d11, d11
+	VST1.I32			{d8, d9, d10, d11}, [r0]!
+
+	bne       		Radix4First_LOOP
+
+Radix4First_END:
+	ldmia    		sp!, {r4 - r11, pc}
+
+	@ENDP  @ |Radix4First|
 	.end
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/asm/ARMV7/Radix4FFT_v7.s b/media/libstagefright/codecs/aacenc/src/asm/ARMV7/Radix4FFT_v7.s
index e1a8438..b8655ae 100644
--- a/media/libstagefright/codecs/aacenc/src/asm/ARMV7/Radix4FFT_v7.s
+++ b/media/libstagefright/codecs/aacenc/src/asm/ARMV7/Radix4FFT_v7.s
@@ -1,143 +1,143 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-@	File:		Radix4FFT_v7.s
-@
-@	Content:	Radix4FFT armv7 assemble
-@
-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
-
-	.section .text
-	.global	Radix4FFT
-
-Radix4FFT:
-	stmdb    sp!, {r4 - r11, lr}
-
-	mov			r1, r1, asr #2
-	cmp     	r1, #0                            
-	beq     	Radix4FFT_END                            
-                        
-Radix4FFT_LOOP1:                         
-	mov     	r5, r2, lsl #1  
-	mov     	r8, r0          
-	mov     	r7, r1  
-	mov     	r5, r5, lsl #2   
-	cmp     	r1, #0          
-	rsbeq   	r12, r5, r5, lsl #2 
-	beq     	Radix4FFT_LOOP1_END              
-                         
-	rsb     	r12, r5, r5, lsl #2   
-	 
-Radix4FFT_LOOP2:                        
-	mov     	r6, r3 
-	mov     	r4, r2  
-	cmp     	r2, #0        
-	beq     	Radix4FFT_LOOP2_END         
-  
-Radix4FFT_LOOP3:                          
-	@r0 = xptr[0]@
-	@r1 = xptr[1]@
-	VLD2.I32			{D0, D1, D2, D3}, [r8]				
-	VLD2.I32			{D28, D29, D30, D31}, [r6]!		@ cosx = csptr[0]@ sinx = csptr[1]@
-	
-	add					r8, r8, r5										@ xptr += step@	
-	VLD2.I32			{D4, D5, D6,D7}, [r8]					@ r2 = xptr[0]@ r3 = xptr[1]@
-	
-	VQDMULH.S32		Q10, Q2, Q14									@ MULHIGH(cosx, t0)
-	VQDMULH.S32		Q11, Q3, Q15									@ MULHIGH(sinx, t1)
-	VQDMULH.S32		Q12, Q3, Q14									@ MULHIGH(cosx, t1)
-	VQDMULH.S32		Q13, Q2, Q15									@ MULHIGH(sinx, t0)
-		
-	VADD.S32			Q2, Q10, Q11									@ MULHIGH(cosx, t0) + MULHIGH(sinx, t1)
-	VSUB.S32			Q3, Q12, Q13									@ MULHIGH(cosx, t1) - MULHIGH(sinx, t0)
-	
-	add					r8, r8, r5										@ xptr += step@
-	VSHR.S32			Q10, Q0, #2										@ t0 = r0 >> 2@
-	VSHR.S32			Q11, Q1, #2										@ t1 = r1 >> 2@
-	
-	VSUB.S32			Q0,	Q10, Q2										@ r0 = t0 - r2@
-	VSUB.S32			Q1,	Q11, Q3										@ r1 = t1 - r3@
-	VADD.S32			Q2, Q10, Q2										@ r2 = t0 + r2@
-	VADD.S32			Q3, Q11, Q3										@ r3 = t1 + r3@
-		
-	VLD2.I32			{D8, D9, D10, D11}, [r8]	
-	VLD2.I32			{D28, D29, D30, D31}, [r6]!	
-	add						r8, r8, r5
-
-	VQDMULH.S32		Q10, Q4, Q14									@ MULHIGH(cosx, t0)
-	VQDMULH.S32		Q11, Q5, Q15									@ MULHIGH(sinx, t1)
-	VQDMULH.S32		Q12, Q5, Q14									@ MULHIGH(cosx, t1)
-	VQDMULH.S32		Q13, Q4, Q15									@ MULHIGH(sinx, t0)
-		
-	VADD.S32			Q8, Q10, Q11									@ MULHIGH(cosx, t0) + MULHIGH(sinx, t1)
-	VSUB.S32			Q9, Q12, Q13									@ MULHIGH(cosx, t1) - MULHIGH(sinx, t0)	
-	
-	VLD2.I32		{D12, D13, D14, D15}, [r8]	
-	VLD2.I32		{D28, D29, D30, D31}, [r6]!
-	
-	VQDMULH.S32		Q10, Q6, Q14									@ MULHIGH(cosx, t0)
-	VQDMULH.S32		Q11, Q7, Q15									@ MULHIGH(sinx, t1)
-	VQDMULH.S32		Q12, Q7, Q14									@ MULHIGH(cosx, t1)
-	VQDMULH.S32		Q13, Q6, Q15									@ MULHIGH(sinx, t0)
-		
-	VADD.S32			Q6, Q10, Q11									@ MULHIGH(cosx, t0) + MULHIGH(sinx, t1)
-	VSUB.S32			Q7, Q12, Q13									@ MULHIGH(cosx, t1) - MULHIGH(sinx, t0)		
-	
-	VADD.S32			Q4, Q8, Q6										@ r4 = t0 + r6@
-	VSUB.S32			Q5, Q7, Q9										@ r5 = r7 - t1@
-	VSUB.S32			Q6, Q8, Q6										@ r6 = t0 - r6@
-	VADD.S32			Q7, Q7, Q9										@ r7 = r7 + t1@
-	
-	VADD.S32			Q8, Q0, Q5										@ xptr[0] = r0 + r5@
-	VADD.S32			Q9, Q1, Q6										@ xptr[1] = r1 + r6@
-	VST2.I32			{D16, D17, D18, D19}, [r8]
-	
-	VSUB.S32			Q10, Q2, Q4										@ xptr[0] = r2 - r4@
-	sub					r8, r8, r5										@ xptr -= step@
-	VSUB.S32			Q11, Q3, Q7										@ xptr[1] = r3 - r7@
-	VST2.I32			{D20, D21, D22, D23}, [r8]
-		
-	VSUB.S32			Q8, Q0, Q5										@ xptr[0] = r0 - r5@
-	sub					r8, r8, r5										@ xptr -= step@
-	VSUB.S32			Q9, Q1, Q6										@ xptr[1] = r1 - r6@
-	VST2.I32			{D16, D17, D18, D19}, [r8]
-		
-	VADD.S32			Q10, Q2, Q4										@ xptr[0] = r2 + r4@
-	sub					r8, r8, r5										@ xptr -= step@
-	VADD.S32			Q11, Q3, Q7										@ xptr[1] = r3 + r7@
-	VST2.I32			{D20, D21, D22, D23}, [r8]!
-		
-	subs    			r4, r4, #4 
-	bne     			Radix4FFT_LOOP3 
-	                         
-Radix4FFT_LOOP2_END:                         
-	add     			r8, r8, r12    
-	sub    				r7, r7, #1     
-	cmp					r7, #0
-	bhi     			Radix4FFT_LOOP2           
-                        
-Radix4FFT_LOOP1_END:                        
-	add     			r3, r12, r3    
-	mov     			r2, r2, lsl #2 
-	movs    			r1, r1, asr #2 
-	bne     			Radix4FFT_LOOP1          
-                        
-Radix4FFT_END:        
-	ldmia   			sp!, {r4 - r11, pc}
-		
-	@ENDP  @ |Radix4FFT|
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+@	File:		Radix4FFT_v7.s
+@
+@	Content:	Radix4FFT armv7 assemble
+@
+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+
+	.section .text
+	.global	Radix4FFT
+
+Radix4FFT:
+	stmdb    sp!, {r4 - r11, lr}
+
+	mov			r1, r1, asr #2
+	cmp     	r1, #0
+	beq     	Radix4FFT_END
+
+Radix4FFT_LOOP1:
+	mov     	r5, r2, lsl #1
+	mov     	r8, r0
+	mov     	r7, r1
+	mov     	r5, r5, lsl #2
+	cmp     	r1, #0
+	rsbeq   	r12, r5, r5, lsl #2
+	beq     	Radix4FFT_LOOP1_END
+
+	rsb     	r12, r5, r5, lsl #2
+
+Radix4FFT_LOOP2:
+	mov     	r6, r3
+	mov     	r4, r2
+	cmp     	r2, #0
+	beq     	Radix4FFT_LOOP2_END
+
+Radix4FFT_LOOP3:
+	@r0 = xptr[0]@
+	@r1 = xptr[1]@
+	VLD2.I32			{D0, D1, D2, D3}, [r8]
+	VLD2.I32			{D28, D29, D30, D31}, [r6]!		@ cosx = csptr[0]@ sinx = csptr[1]@
+
+	add					r8, r8, r5										@ xptr += step@
+	VLD2.I32			{D4, D5, D6,D7}, [r8]					@ r2 = xptr[0]@ r3 = xptr[1]@
+
+	VQDMULH.S32		Q10, Q2, Q14									@ MULHIGH(cosx, t0)
+	VQDMULH.S32		Q11, Q3, Q15									@ MULHIGH(sinx, t1)
+	VQDMULH.S32		Q12, Q3, Q14									@ MULHIGH(cosx, t1)
+	VQDMULH.S32		Q13, Q2, Q15									@ MULHIGH(sinx, t0)
+
+	VADD.S32			Q2, Q10, Q11									@ MULHIGH(cosx, t0) + MULHIGH(sinx, t1)
+	VSUB.S32			Q3, Q12, Q13									@ MULHIGH(cosx, t1) - MULHIGH(sinx, t0)
+
+	add					r8, r8, r5										@ xptr += step@
+	VSHR.S32			Q10, Q0, #2										@ t0 = r0 >> 2@
+	VSHR.S32			Q11, Q1, #2										@ t1 = r1 >> 2@
+
+	VSUB.S32			Q0,	Q10, Q2										@ r0 = t0 - r2@
+	VSUB.S32			Q1,	Q11, Q3										@ r1 = t1 - r3@
+	VADD.S32			Q2, Q10, Q2										@ r2 = t0 + r2@
+	VADD.S32			Q3, Q11, Q3										@ r3 = t1 + r3@
+
+	VLD2.I32			{D8, D9, D10, D11}, [r8]
+	VLD2.I32			{D28, D29, D30, D31}, [r6]!
+	add						r8, r8, r5
+
+	VQDMULH.S32		Q10, Q4, Q14									@ MULHIGH(cosx, t0)
+	VQDMULH.S32		Q11, Q5, Q15									@ MULHIGH(sinx, t1)
+	VQDMULH.S32		Q12, Q5, Q14									@ MULHIGH(cosx, t1)
+	VQDMULH.S32		Q13, Q4, Q15									@ MULHIGH(sinx, t0)
+
+	VADD.S32			Q8, Q10, Q11									@ MULHIGH(cosx, t0) + MULHIGH(sinx, t1)
+	VSUB.S32			Q9, Q12, Q13									@ MULHIGH(cosx, t1) - MULHIGH(sinx, t0)
+
+	VLD2.I32		{D12, D13, D14, D15}, [r8]
+	VLD2.I32		{D28, D29, D30, D31}, [r6]!
+
+	VQDMULH.S32		Q10, Q6, Q14									@ MULHIGH(cosx, t0)
+	VQDMULH.S32		Q11, Q7, Q15									@ MULHIGH(sinx, t1)
+	VQDMULH.S32		Q12, Q7, Q14									@ MULHIGH(cosx, t1)
+	VQDMULH.S32		Q13, Q6, Q15									@ MULHIGH(sinx, t0)
+
+	VADD.S32			Q6, Q10, Q11									@ MULHIGH(cosx, t0) + MULHIGH(sinx, t1)
+	VSUB.S32			Q7, Q12, Q13									@ MULHIGH(cosx, t1) - MULHIGH(sinx, t0)
+
+	VADD.S32			Q4, Q8, Q6										@ r4 = t0 + r6@
+	VSUB.S32			Q5, Q7, Q9										@ r5 = r7 - t1@
+	VSUB.S32			Q6, Q8, Q6										@ r6 = t0 - r6@
+	VADD.S32			Q7, Q7, Q9										@ r7 = r7 + t1@
+
+	VADD.S32			Q8, Q0, Q5										@ xptr[0] = r0 + r5@
+	VADD.S32			Q9, Q1, Q6										@ xptr[1] = r1 + r6@
+	VST2.I32			{D16, D17, D18, D19}, [r8]
+
+	VSUB.S32			Q10, Q2, Q4										@ xptr[0] = r2 - r4@
+	sub					r8, r8, r5										@ xptr -= step@
+	VSUB.S32			Q11, Q3, Q7										@ xptr[1] = r3 - r7@
+	VST2.I32			{D20, D21, D22, D23}, [r8]
+
+	VSUB.S32			Q8, Q0, Q5										@ xptr[0] = r0 - r5@
+	sub					r8, r8, r5										@ xptr -= step@
+	VSUB.S32			Q9, Q1, Q6										@ xptr[1] = r1 - r6@
+	VST2.I32			{D16, D17, D18, D19}, [r8]
+
+	VADD.S32			Q10, Q2, Q4										@ xptr[0] = r2 + r4@
+	sub					r8, r8, r5										@ xptr -= step@
+	VADD.S32			Q11, Q3, Q7										@ xptr[1] = r3 + r7@
+	VST2.I32			{D20, D21, D22, D23}, [r8]!
+
+	subs    			r4, r4, #4
+	bne     			Radix4FFT_LOOP3
+
+Radix4FFT_LOOP2_END:
+	add     			r8, r8, r12
+	sub    				r7, r7, #1
+	cmp					r7, #0
+	bhi     			Radix4FFT_LOOP2
+
+Radix4FFT_LOOP1_END:
+	add     			r3, r12, r3
+	mov     			r2, r2, lsl #2
+	movs    			r1, r1, asr #2
+	bne     			Radix4FFT_LOOP1
+
+Radix4FFT_END:
+	ldmia   			sp!, {r4 - r11, pc}
+
+	@ENDP  @ |Radix4FFT|
 	.end
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/band_nrg.c b/media/libstagefright/codecs/aacenc/src/band_nrg.c
index 666c4ca..7501af1 100644
--- a/media/libstagefright/codecs/aacenc/src/band_nrg.c
+++ b/media/libstagefright/codecs/aacenc/src/band_nrg.c
@@ -1,35 +1,35 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		band_nrg.c
-
-	Content:	Band/Line energy calculations functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		band_nrg.c
+
+	Content:	Band/Line energy calculations functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
+#include "basic_op.h"
 #include "band_nrg.h"
 
-#ifndef ARMV5E
+#ifndef ARMV5E
 /********************************************************************************
 *
 * function name: CalcBandEnergy
 * description:   Calc sfb-bandwise mdct-energies for left and right channel
 *
-**********************************************************************************/
+**********************************************************************************/
 void CalcBandEnergy(const Word32 *mdctSpectrum,
                     const Word16 *bandOffset,
                     const Word16  numBands,
@@ -37,18 +37,18 @@ void CalcBandEnergy(const Word32 *mdctSpectrum,
                     Word32       *bandEnergySum)
 {
   Word32 i, j;
-  Word32 accuSum = 0;                                            
+  Word32 accuSum = 0;
 
   for (i=0; i<numBands; i++) {
-    Word32 accu = 0;                                             
+    Word32 accu = 0;
     for (j=bandOffset[i]; j<bandOffset[i+1]; j++)
-      accu = L_add(accu, MULHIGH(mdctSpectrum[j], mdctSpectrum[j]));
-
+      accu = L_add(accu, MULHIGH(mdctSpectrum[j], mdctSpectrum[j]));
+
 	accu = L_add(accu, accu);
     accuSum = L_add(accuSum, accu);
-    bandEnergy[i] = accu;                                        
+    bandEnergy[i] = accu;
   }
-  *bandEnergySum = accuSum;                                      
+  *bandEnergySum = accuSum;
 }
 
 /********************************************************************************
@@ -68,15 +68,15 @@ void CalcBandEnergyMS(const Word32 *mdctSpectrumLeft,
 {
 
   Word32 i, j;
-  Word32 accuMidSum = 0;        
-  Word32 accuSideSum = 0;                                          
- 
+  Word32 accuMidSum = 0;
+  Word32 accuSideSum = 0;
+
 
   for(i=0; i<numBands; i++) {
     Word32 accuMid = 0;
-    Word32 accuSide = 0;                                           
+    Word32 accuSide = 0;
     for (j=bandOffset[i]; j<bandOffset[i+1]; j++) {
-      Word32 specm, specs; 
+      Word32 specm, specs;
       Word32 l, r;
 
       l = mdctSpectrumLeft[j] >> 1;
@@ -86,17 +86,17 @@ void CalcBandEnergyMS(const Word32 *mdctSpectrumLeft,
       accuMid = L_add(accuMid, MULHIGH(specm, specm));
       accuSide = L_add(accuSide, MULHIGH(specs, specs));
     }
-    
-	accuMid = L_add(accuMid, accuMid);
-	accuSide = L_add(accuSide, accuSide);
-	bandEnergyMid[i] = accuMid;                                  
+
+	accuMid = L_add(accuMid, accuMid);
+	accuSide = L_add(accuSide, accuSide);
+	bandEnergyMid[i] = accuMid;
     accuMidSum = L_add(accuMidSum, accuMid);
-    bandEnergySide[i] = accuSide;                                
+    bandEnergySide[i] = accuSide;
     accuSideSum = L_add(accuSideSum, accuSide);
-    
+
   }
-  *bandEnergyMidSum = accuMidSum;                                
-  *bandEnergySideSum = accuSideSum;                              
+  *bandEnergyMidSum = accuMidSum;
+  *bandEnergySideSum = accuSideSum;
 }
 
 #endif
\ No newline at end of file
diff --git a/media/libstagefright/codecs/aacenc/src/bit_cnt.c b/media/libstagefright/codecs/aacenc/src/bit_cnt.c
index 24837e8..9fe511c 100644
--- a/media/libstagefright/codecs/aacenc/src/bit_cnt.c
+++ b/media/libstagefright/codecs/aacenc/src/bit_cnt.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		bit_cnt.c
-
-	Content:	Huffman Bitcounter & coder functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		bit_cnt.c
+
+	Content:	Huffman Bitcounter & coder functions
+
 *******************************************************************************/
 
 #include "bit_cnt.h"
@@ -26,14 +26,14 @@
 #define HI_LTAB(a) (a>>8)
 #define LO_LTAB(a) (a & 0xff)
 
-#define EXPAND(a)  ((((Word32)(a&0xff00)) << 8)|(Word32)(a&0xff)) 
+#define EXPAND(a)  ((((Word32)(a&0xff00)) << 8)|(Word32)(a&0xff))
 
 
 /*****************************************************************************
 *
 * function name: count1_2_3_4_5_6_7_8_9_10_11
-* description:  counts tables 1-11 
-* returns:      
+* description:  counts tables 1-11
+* returns:
 * input:        quantized spectrum
 * output:       bitCount for tables 1-11
 *
@@ -45,52 +45,52 @@ static void count1_2_3_4_5_6_7_8_9_10_11(const Word16 *values,
 {
   Word32 t0,t1,t2,t3,i;
   Word32 bc1_2,bc3_4,bc5_6,bc7_8,bc9_10;
-  Word16 bc11,sc;
-  
-  bc1_2=0;                               
-  bc3_4=0;                               
-  bc5_6=0;                               
-  bc7_8=0;                               
-  bc9_10=0;                              
-  bc11=0;                                
-  sc=0;                                  
+  Word16 bc11,sc;
+
+  bc1_2=0;
+  bc3_4=0;
+  bc5_6=0;
+  bc7_8=0;
+  bc9_10=0;
+  bc11=0;
+  sc=0;
 
   for(i=0;i<width;i+=4){
-    
-    t0= values[i+0];                     
-    t1= values[i+1];                     
-    t2= values[i+2];                     
-    t3= values[i+3];                     
-  
+
+    t0= values[i+0];
+    t1= values[i+1];
+    t2= values[i+2];
+    t3= values[i+3];
+
     /* 1,2 */
 
-    bc1_2 = bc1_2 + EXPAND(huff_ltab1_2[t0+1][t1+1][t2+1][t3+1]);              
+    bc1_2 = bc1_2 + EXPAND(huff_ltab1_2[t0+1][t1+1][t2+1][t3+1]);
 
     /* 5,6 */
-    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t0+4][t1+4]);                          
-    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t2+4][t3+4]);                          
+    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t0+4][t1+4]);
+    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t2+4][t3+4]);
 
     t0=ABS(t0);
     t1=ABS(t1);
     t2=ABS(t2);
     t3=ABS(t3);
 
-    
-    bc3_4 = bc3_4 + EXPAND(huff_ltab3_4[t0][t1][t2][t3]);                      
-    
-    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);                              
-    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t2][t3]);                              
-    
-    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);                           
-    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t2][t3]);                           
-    
+
+    bc3_4 = bc3_4 + EXPAND(huff_ltab3_4[t0][t1][t2][t3]);
+
+    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);
+    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t2][t3]);
+
+    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);
+    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t2][t3]);
+
     bc11 = bc11 + huff_ltab11[t0][t1];
     bc11 = bc11 + huff_ltab11[t2][t3];
-   
-           
+
+
     sc = sc + (t0>0) + (t1>0) + (t2>0) + (t3>0);
   }
-  
+
   bitCount[1]=extract_h(bc1_2);
   bitCount[2]=extract_l(bc1_2);
   bitCount[3]=extract_h(bc3_4) + sc;
@@ -108,8 +108,8 @@ static void count1_2_3_4_5_6_7_8_9_10_11(const Word16 *values,
 /*****************************************************************************
 *
 * function name: count3_4_5_6_7_8_9_10_11
-* description:  counts tables 3-11 
-* returns:      
+* description:  counts tables 3-11
+* returns:
 * input:        quantized spectrum
 * output:       bitCount for tables 3-11
 *
@@ -122,26 +122,26 @@ static void count3_4_5_6_7_8_9_10_11(const Word16 *values,
   Word32 t0,t1,t2,t3, i;
   Word32 bc3_4,bc5_6,bc7_8,bc9_10;
   Word16 bc11,sc;
-    
-  bc3_4=0;                               
-  bc5_6=0;                               
-  bc7_8=0;                               
-  bc9_10=0;                              
-  bc11=0;                                
-  sc=0;                                  
+
+  bc3_4=0;
+  bc5_6=0;
+  bc7_8=0;
+  bc9_10=0;
+  bc11=0;
+  sc=0;
 
   for(i=0;i<width;i+=4){
 
-    t0= values[i+0];                     
-    t1= values[i+1];                     
-    t2= values[i+2];                     
-    t3= values[i+3];                     
-    
+    t0= values[i+0];
+    t1= values[i+1];
+    t2= values[i+2];
+    t3= values[i+3];
+
     /*
       5,6
     */
-    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t0+4][t1+4]);                          
-    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t2+4][t3+4]);                          
+    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t0+4][t1+4]);
+    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t2+4][t3+4]);
 
     t0=ABS(t0);
     t1=ABS(t1);
@@ -149,23 +149,23 @@ static void count3_4_5_6_7_8_9_10_11(const Word16 *values,
     t3=ABS(t3);
 
 
-    bc3_4 = bc3_4 + EXPAND(huff_ltab3_4[t0][t1][t2][t3]);                      
-                                                                                                                
-    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);                              
-    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t2][t3]);                              
-    
-    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);                           
-    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t2][t3]);                           
-                                                                                                                
+    bc3_4 = bc3_4 + EXPAND(huff_ltab3_4[t0][t1][t2][t3]);
+
+    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);
+    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t2][t3]);
+
+    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);
+    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t2][t3]);
+
     bc11 = bc11 + huff_ltab11[t0][t1];
     bc11 = bc11 + huff_ltab11[t2][t3];
 
-           
-    sc = sc + (t0>0) + (t1>0) + (t2>0) + (t3>0);   
-  }
-  
-  bitCount[1]=INVALID_BITCOUNT;                          
-  bitCount[2]=INVALID_BITCOUNT;                          
+
+    sc = sc + (t0>0) + (t1>0) + (t2>0) + (t3>0);
+  }
+
+  bitCount[1]=INVALID_BITCOUNT;
+  bitCount[2]=INVALID_BITCOUNT;
   bitCount[3]=extract_h(bc3_4) + sc;
   bitCount[4]=extract_l(bc3_4) + sc;
   bitCount[5]=extract_h(bc5_6);
@@ -175,7 +175,7 @@ static void count3_4_5_6_7_8_9_10_11(const Word16 *values,
   bitCount[9]=extract_h(bc9_10) + sc;
   bitCount[10]=extract_l(bc9_10) + sc;
   bitCount[11]=bc11 + sc;
-  
+
 }
 
 
@@ -183,8 +183,8 @@ static void count3_4_5_6_7_8_9_10_11(const Word16 *values,
 /*****************************************************************************
 *
 * function name: count5_6_7_8_9_10_11
-* description:  counts tables 5-11 
-* returns:      
+* description:  counts tables 5-11
+* returns:
 * input:        quantized spectrum
 * output:       bitCount for tables 5-11
 *
@@ -196,35 +196,35 @@ static void count5_6_7_8_9_10_11(const Word16 *values,
 
   Word32 t0,t1,i;
   Word32 bc5_6,bc7_8,bc9_10;
-  Word16 bc11,sc;
+  Word16 bc11,sc;
 
-  bc5_6=0;                               
-  bc7_8=0;                               
-  bc9_10=0;                              
-  bc11=0;                                
-  sc=0;                                  
+  bc5_6=0;
+  bc7_8=0;
+  bc9_10=0;
+  bc11=0;
+  sc=0;
 
   for(i=0;i<width;i+=2){
 
-    t0 = values[i+0];                    
-    t1 = values[i+1];                    
+    t0 = values[i+0];
+    t1 = values[i+1];
 
-    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t0+4][t1+4]);                  
+    bc5_6 = bc5_6 + EXPAND(huff_ltab5_6[t0+4][t1+4]);
 
     t0=ABS(t0);
     t1=ABS(t1);
-     
-    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);                      
-    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);                   
+
+    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);
+    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);
     bc11 = bc11 + huff_ltab11[t0][t1];
-    
-       
+
+
     sc = sc + (t0>0) + (t1>0);
   }
-  bitCount[1]=INVALID_BITCOUNT;                          
-  bitCount[2]=INVALID_BITCOUNT;                          
-  bitCount[3]=INVALID_BITCOUNT;                          
-  bitCount[4]=INVALID_BITCOUNT;                          
+  bitCount[1]=INVALID_BITCOUNT;
+  bitCount[2]=INVALID_BITCOUNT;
+  bitCount[3]=INVALID_BITCOUNT;
+  bitCount[4]=INVALID_BITCOUNT;
   bitCount[5]=extract_h(bc5_6);
   bitCount[6]=extract_l(bc5_6);
   bitCount[7]=extract_h(bc7_8) + sc;
@@ -232,15 +232,15 @@ static void count5_6_7_8_9_10_11(const Word16 *values,
   bitCount[9]=extract_h(bc9_10) + sc;
   bitCount[10]=extract_l(bc9_10) + sc;
   bitCount[11]=bc11 + sc;
-  
+
 }
 
 
 /*****************************************************************************
 *
 * function name: count7_8_9_10_11
-* description:  counts tables 7-11 
-* returns:      
+* description:  counts tables 7-11
+* returns:
 * input:        quantized spectrum
 * output:       bitCount for tables 7-11
 *
@@ -253,184 +253,184 @@ static void count7_8_9_10_11(const Word16 *values,
   Word32 t0,t1, i;
   Word32 bc7_8,bc9_10;
   Word16 bc11,sc;
-    
-  bc7_8=0;                       
-  bc9_10=0;                      
-  bc11=0;                        
-  sc=0;                          
+
+  bc7_8=0;
+  bc9_10=0;
+  bc11=0;
+  sc=0;
 
   for(i=0;i<width;i+=2){
 
     t0=ABS(values[i+0]);
     t1=ABS(values[i+1]);
 
-    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);                      
-    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);                   
+    bc7_8 = bc7_8 + EXPAND(huff_ltab7_8[t0][t1]);
+    bc9_10 = bc9_10 + EXPAND(huff_ltab9_10[t0][t1]);
     bc11 = bc11 + huff_ltab11[t0][t1];
-   
-       
+
+
     sc = sc + (t0>0) + (t1>0);
   }
-  bitCount[1]=INVALID_BITCOUNT;                  
-  bitCount[2]=INVALID_BITCOUNT;                  
-  bitCount[3]=INVALID_BITCOUNT;                  
-  bitCount[4]=INVALID_BITCOUNT;                  
-  bitCount[5]=INVALID_BITCOUNT;                  
-  bitCount[6]=INVALID_BITCOUNT;                  
+  bitCount[1]=INVALID_BITCOUNT;
+  bitCount[2]=INVALID_BITCOUNT;
+  bitCount[3]=INVALID_BITCOUNT;
+  bitCount[4]=INVALID_BITCOUNT;
+  bitCount[5]=INVALID_BITCOUNT;
+  bitCount[6]=INVALID_BITCOUNT;
   bitCount[7]=extract_h(bc7_8) + sc;
   bitCount[8]=extract_l(bc7_8) + sc;
   bitCount[9]=extract_h(bc9_10) + sc;
   bitCount[10]=extract_l(bc9_10) + sc;
   bitCount[11]=bc11 + sc;
-  
+
 }
 
 /*****************************************************************************
 *
 * function name: count9_10_11
-* description:  counts tables 9-11 
-* returns:      
+* description:  counts tables 9-11
+* returns:
 * input:        quantized spectrum
 * output:       bitCount for tables 9-11
 *
 *****************************************************************************/
-static void count9_10_11(const Word16 *values,
-                         const Word16  width,
-                         Word16       *bitCount)
-{
-
-  Word32 t0,t1,i;  
-  Word32 bc9_10;
-  Word16 bc11,sc;
-
-  bc9_10=0;                              
-  bc11=0;                                
-  sc=0;                                  
-
-  for(i=0;i<width;i+=2){
-
-    t0=ABS(values[i+0]);
-    t1=ABS(values[i+1]);
-    
-
-    bc9_10 += EXPAND(huff_ltab9_10[t0][t1]);           
-    bc11 = bc11 + huff_ltab11[t0][t1];
-
-       
-    sc = sc + (t0>0) + (t1>0);
-  }
-  bitCount[1]=INVALID_BITCOUNT;          
-  bitCount[2]=INVALID_BITCOUNT;          
-  bitCount[3]=INVALID_BITCOUNT;          
-  bitCount[4]=INVALID_BITCOUNT;          
-  bitCount[5]=INVALID_BITCOUNT;          
-  bitCount[6]=INVALID_BITCOUNT;          
-  bitCount[7]=INVALID_BITCOUNT;          
-  bitCount[8]=INVALID_BITCOUNT;          
-  bitCount[9]=extract_h(bc9_10) + sc;
-  bitCount[10]=extract_l(bc9_10) + sc;
-  bitCount[11]=bc11 + sc;
-  
+static void count9_10_11(const Word16 *values,
+                         const Word16  width,
+                         Word16       *bitCount)
+{
+
+  Word32 t0,t1,i;
+  Word32 bc9_10;
+  Word16 bc11,sc;
+
+  bc9_10=0;
+  bc11=0;
+  sc=0;
+
+  for(i=0;i<width;i+=2){
+
+    t0=ABS(values[i+0]);
+    t1=ABS(values[i+1]);
+
+
+    bc9_10 += EXPAND(huff_ltab9_10[t0][t1]);
+    bc11 = bc11 + huff_ltab11[t0][t1];
+
+
+    sc = sc + (t0>0) + (t1>0);
+  }
+  bitCount[1]=INVALID_BITCOUNT;
+  bitCount[2]=INVALID_BITCOUNT;
+  bitCount[3]=INVALID_BITCOUNT;
+  bitCount[4]=INVALID_BITCOUNT;
+  bitCount[5]=INVALID_BITCOUNT;
+  bitCount[6]=INVALID_BITCOUNT;
+  bitCount[7]=INVALID_BITCOUNT;
+  bitCount[8]=INVALID_BITCOUNT;
+  bitCount[9]=extract_h(bc9_10) + sc;
+  bitCount[10]=extract_l(bc9_10) + sc;
+  bitCount[11]=bc11 + sc;
+
 }
- 
+
 /*****************************************************************************
 *
 * function name: count11
-* description:  counts table 11 
-* returns:      
+* description:  counts table 11
+* returns:
 * input:        quantized spectrum
 * output:       bitCount for table 11
 *
 *****************************************************************************/
- static void count11(const Word16 *values,
-                    const Word16  width,
-                    Word16        *bitCount)
-{
-  Word32 t0,t1,i;
-  Word16 bc11,sc;  
-
-  bc11=0;                        
-  sc=0;                          
-  for(i=0;i<width;i+=2){
-    t0=ABS(values[i+0]);
-    t1=ABS(values[i+1]);
-    bc11 = bc11 + huff_ltab11[t0][t1];
-
-       
-    sc = sc + (t0>0) + (t1>0);
-  }
-
-  bitCount[1]=INVALID_BITCOUNT;                  
-  bitCount[2]=INVALID_BITCOUNT;                  
-  bitCount[3]=INVALID_BITCOUNT;                  
-  bitCount[4]=INVALID_BITCOUNT;                  
-  bitCount[5]=INVALID_BITCOUNT;                  
-  bitCount[6]=INVALID_BITCOUNT;                  
-  bitCount[7]=INVALID_BITCOUNT;                  
-  bitCount[8]=INVALID_BITCOUNT;                  
-  bitCount[9]=INVALID_BITCOUNT;                  
-  bitCount[10]=INVALID_BITCOUNT;                 
-  bitCount[11]=bc11 + sc;
+ static void count11(const Word16 *values,
+                    const Word16  width,
+                    Word16        *bitCount)
+{
+  Word32 t0,t1,i;
+  Word16 bc11,sc;
+
+  bc11=0;
+  sc=0;
+  for(i=0;i<width;i+=2){
+    t0=ABS(values[i+0]);
+    t1=ABS(values[i+1]);
+    bc11 = bc11 + huff_ltab11[t0][t1];
+
+
+    sc = sc + (t0>0) + (t1>0);
+  }
+
+  bitCount[1]=INVALID_BITCOUNT;
+  bitCount[2]=INVALID_BITCOUNT;
+  bitCount[3]=INVALID_BITCOUNT;
+  bitCount[4]=INVALID_BITCOUNT;
+  bitCount[5]=INVALID_BITCOUNT;
+  bitCount[6]=INVALID_BITCOUNT;
+  bitCount[7]=INVALID_BITCOUNT;
+  bitCount[8]=INVALID_BITCOUNT;
+  bitCount[9]=INVALID_BITCOUNT;
+  bitCount[10]=INVALID_BITCOUNT;
+  bitCount[11]=bc11 + sc;
 }
 
 /*****************************************************************************
 *
 * function name: countEsc
-* description:  counts table 11 (with Esc) 
-* returns:      
+* description:  counts table 11 (with Esc)
+* returns:
 * input:        quantized spectrum
 * output:       bitCount for tables 11 (with Esc)
 *
 *****************************************************************************/
 
-static void countEsc(const Word16 *values,
-                     const Word16  width,
-                     Word16       *bitCount)
-{
-  Word32 t0,t1,t00,t01,i;
-  Word16 bc11,ec,sc;  
-
-  bc11=0;                                
-  sc=0;                                  
-  ec=0;                                  
-  for(i=0;i<width;i+=2){
-    t0=ABS(values[i+0]);
-    t1=ABS(values[i+1]);
-    
-       
-    sc = sc + (t0>0) + (t1>0);
-
-    t00 = min(t0,16);
-    t01 = min(t1,16);
-    bc11 = bc11 + huff_ltab11[t00][t01];
-    
-     
-    if(t0 >= 16){
-      ec = ec + 5;
-      while(sub(t0=(t0 >> 1), 16) >= 0) {
-        ec = ec + 2;
-      }
-    }
-    
-     
-    if(t1 >= 16){
-      ec = ec + 5;
-      while(sub(t1=(t1 >> 1), 16) >= 0) {
-        ec = ec + 2;
-      }
-    }
-  }
-  bitCount[1]=INVALID_BITCOUNT;          
-  bitCount[2]=INVALID_BITCOUNT;          
-  bitCount[3]=INVALID_BITCOUNT;          
-  bitCount[4]=INVALID_BITCOUNT;          
-  bitCount[5]=INVALID_BITCOUNT;          
-  bitCount[6]=INVALID_BITCOUNT;          
-  bitCount[7]=INVALID_BITCOUNT;          
-  bitCount[8]=INVALID_BITCOUNT;          
-  bitCount[9]=INVALID_BITCOUNT;          
-  bitCount[10]=INVALID_BITCOUNT;         
-  bitCount[11]=bc11 + sc + ec;
+static void countEsc(const Word16 *values,
+                     const Word16  width,
+                     Word16       *bitCount)
+{
+  Word32 t0,t1,t00,t01,i;
+  Word16 bc11,ec,sc;
+
+  bc11=0;
+  sc=0;
+  ec=0;
+  for(i=0;i<width;i+=2){
+    t0=ABS(values[i+0]);
+    t1=ABS(values[i+1]);
+
+
+    sc = sc + (t0>0) + (t1>0);
+
+    t00 = min(t0,16);
+    t01 = min(t1,16);
+    bc11 = bc11 + huff_ltab11[t00][t01];
+
+
+    if(t0 >= 16){
+      ec = ec + 5;
+      while(sub(t0=(t0 >> 1), 16) >= 0) {
+        ec = ec + 2;
+      }
+    }
+
+
+    if(t1 >= 16){
+      ec = ec + 5;
+      while(sub(t1=(t1 >> 1), 16) >= 0) {
+        ec = ec + 2;
+      }
+    }
+  }
+  bitCount[1]=INVALID_BITCOUNT;
+  bitCount[2]=INVALID_BITCOUNT;
+  bitCount[3]=INVALID_BITCOUNT;
+  bitCount[4]=INVALID_BITCOUNT;
+  bitCount[5]=INVALID_BITCOUNT;
+  bitCount[6]=INVALID_BITCOUNT;
+  bitCount[7]=INVALID_BITCOUNT;
+  bitCount[8]=INVALID_BITCOUNT;
+  bitCount[9]=INVALID_BITCOUNT;
+  bitCount[10]=INVALID_BITCOUNT;
+  bitCount[11]=bc11 + sc + ec;
 }
 
 
@@ -463,7 +463,7 @@ static COUNT_FUNCTION countFuncTable[CODE_BOOK_ESC_LAV+1] =
 /*****************************************************************************
 *
 * function name: bitCount
-* description:  count bits 
+* description:  count bits
 *
 *****************************************************************************/
 Word16 bitCount(const Word16 *values,
@@ -474,7 +474,7 @@ Word16 bitCount(const Word16 *values,
   /*
     check if we can use codebook 0
   */
-     
+
   if(maxVal == 0)
     bitCount[0] = 0;
   else
@@ -489,379 +489,379 @@ Word16 bitCount(const Word16 *values,
 /*****************************************************************************
 *
 * function name: codeValues
-* description:  write huffum bits 
+* description:  write huffum bits
 *
 *****************************************************************************/
-Word16 codeValues(Word16 *values, Word16 width, Word16 codeBook, HANDLE_BIT_BUF hBitstream)
-{
-
-  Word32 i, t0, t1, t2, t3, t00, t01;
-  Word16 codeWord, codeLength;
-  Word16 sign, signLength;
-
-   
-  switch (codeBook) {
-    case CODE_BOOK_ZERO_NO:
-      break;
-
-    case CODE_BOOK_1_NO:
-      for(i=0; i<width; i+=4) {
-        t0         = values[i+0];                                        
-        t1         = values[i+1];                                        
-        t2         = values[i+2];                                        
-        t3         = values[i+3];                                        
-        codeWord   = huff_ctab1[t0+1][t1+1][t2+1][t3+1];                 
-        codeLength = HI_LTAB(huff_ltab1_2[t0+1][t1+1][t2+1][t3+1]);      
-        WriteBits(hBitstream, codeWord, codeLength);        
-      }
-      break;
-
-    case CODE_BOOK_2_NO:
-      for(i=0; i<width; i+=4) {
-        t0         = values[i+0];                                        
-        t1         = values[i+1];                                        
-        t2         = values[i+2];                                        
-        t3         = values[i+3];                                        
-        codeWord   = huff_ctab2[t0+1][t1+1][t2+1][t3+1];                 
-        codeLength = LO_LTAB(huff_ltab1_2[t0+1][t1+1][t2+1][t3+1]);      
-        WriteBits(hBitstream,codeWord,codeLength);
-      }
-      break;
-
-    case CODE_BOOK_3_NO:
-      for(i=0; i<width; i+=4) {
-        sign=0;                                                          
-        signLength=0;                                                    
-        t0 = values[i+0];                                                
-         
-        if(t0 != 0){
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t0 < 0){
-            sign|=1;                                                     
-            t0=-t0;
-          }
-        }
-        t1 = values[i+1];                                                
-         
-        if(t1 != 0){
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t1 < 0){
-            sign|=1;                                                     
-            t1=-t1;
-          }
-        }
-        t2 = values[i+2];                                                
-         
-        if(t2 != 0){
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t2 < 0){
-            sign|=1;                                                     
-            t2=-t2;
-          }
-        }
-        t3 = values[i+3];                                                
-        if(t3 != 0){
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t3 < 0){
-            sign|=1;                                                     
-            t3=-t3;
-          }
-        }
-
-        codeWord   = huff_ctab3[t0][t1][t2][t3];                         
-        codeLength = HI_LTAB(huff_ltab3_4[t0][t1][t2][t3]);              
-        WriteBits(hBitstream,codeWord,codeLength);
-        WriteBits(hBitstream,sign,signLength);
-      }
-      break;
-
-    case CODE_BOOK_4_NO:
-      for(i=0; i<width; i+=4) {
-        sign=0;                                                          
-        signLength=0;                                                    
-        t0 = values[i+0];                                                
-         
-        if(t0 != 0){                                                             
-          signLength = signLength + 1;
-          sign = sign << 1; 
-          if(t0 < 0){                                                            
-            sign|=1;                                                     
-            t0=-t0;                                                          
-          }
-        }                                                                        
-        t1 = values[i+1];                                                
-         
-        if(t1 != 0){                                                             
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t1 < 0){                                                            
-            sign|=1;                                                     
-            t1=-t1;                                                          
-          }                                                                      
-        }                                                                        
-        t2 = values[i+2];                                                
-         
-        if(t2 != 0){                                                    
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t2 < 0){                                                   
-            sign|=1;                                                     
-            t2=-t2;                                                 
-          }                                                             
-        }                                                               
-        t3 = values[i+3];                                                
-         
-        if(t3 != 0){                                                    
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t3 < 0){                                                   
-            sign|=1;                                                     
-            t3=-t3;                                                 
-          }                                                             
-        }                                                               
-        codeWord   = huff_ctab4[t0][t1][t2][t3];                         
-        codeLength = LO_LTAB(huff_ltab3_4[t0][t1][t2][t3]);              
-        WriteBits(hBitstream,codeWord,codeLength);                      
-        WriteBits(hBitstream,sign,signLength);                          
-      }                                                                 
-      break;                                                            
-                                                                        
-    case CODE_BOOK_5_NO:                                                
-      for(i=0; i<width; i+=2) {                                         
-        t0         = values[i+0];                                         
-        t1         = values[i+1];                                        
-        codeWord   = huff_ctab5[t0+4][t1+4];                             
-        codeLength = HI_LTAB(huff_ltab5_6[t0+4][t1+4]);                  
-        WriteBits(hBitstream,codeWord,codeLength);
-      }
-      break;
-
-    case CODE_BOOK_6_NO:
-      for(i=0; i<width; i+=2) {
-        t0         = values[i+0];                                        
-        t1         = values[i+1];                                        
-        codeWord   = huff_ctab6[t0+4][t1+4];                             
-        codeLength = LO_LTAB(huff_ltab5_6[t0+4][t1+4]);                  
-        WriteBits(hBitstream,codeWord,codeLength);
-      }
-      break;
-
-    case CODE_BOOK_7_NO:
-      for(i=0; i<width; i+=2){
-        sign=0;                                                          
-        signLength=0;                                                    
-        t0 = values[i+0];                                                
-         
-        if(t0 != 0){
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t0 < 0){
-            sign|=1;                                                     
-            t0=-t0;
-          }
-        }
-
-        t1 = values[i+1];                                                
-         
-        if(t1 != 0){
-          signLength = signLength + 1;
-          sign = sign << 1; 
-           
-          if(t1 < 0){
-            sign|=1;                                                     
-            t1=-t1;
-          }
-        }
-        codeWord   = huff_ctab7[t0][t1];                                 
-        codeLength = HI_LTAB(huff_ltab7_8[t0][t1]);                      
-        WriteBits(hBitstream,codeWord,codeLength);
-        WriteBits(hBitstream,sign,signLength);
-      }
-      break;
-
-    case CODE_BOOK_8_NO:
-      for(i=0; i<width; i+=2) {
-        sign=0;                                                          
-        signLength=0;                                                    
-        t0 = values[i+0];                                                
-                                                                           
-        if(t0 != 0){                                                             
-          signLength = signLength + 1;                                       
-          sign = sign << 1;                                                   
-                                                                           
-          if(t0 < 0){                                                            
-            sign|=1;                                                     
-            t0=-t0;                                                        
-          }                                                                      
-        }                                                                        
-                                                                                 
-        t1 = values[i+1];                                                
-                                                                           
-        if(t1 != 0){                                                             
-          signLength = signLength + 1;                                       
-          sign = sign << 1;                                                   
-                                                                           
-          if(t1 < 0){                                                            
-            sign|=1;                                                     
-            t1=-t1;                                                        
-          }                                                                      
-        }                                                                        
-        codeWord   = huff_ctab8[t0][t1];                                 
-        codeLength = LO_LTAB(huff_ltab7_8[t0][t1]);                      
-        WriteBits(hBitstream,codeWord,codeLength);
-        WriteBits(hBitstream,sign,signLength);
-      }
-      break;
-
-    case CODE_BOOK_9_NO:
-      for(i=0; i<width; i+=2) {
-        sign=0;                                                          
-        signLength=0;                                                    
-        t0 = values[i+0];                                                
-                                                                           
-        if(t0 != 0){                                                             
-          signLength = signLength + 1;                                       
-          sign = sign << 1;                                                   
-                                                                           
-          if(t0 < 0){                                                            
-            sign|=1;                                                     
-            t0=-t0;                                                        
-          }                                                                      
-        }                                                                        
-                                                                                 
-        t1 = values[i+1];                                                
-                                                                           
-        if(t1 != 0){                                                             
-          signLength = signLength + 1;                                       
-          sign = sign << 1;                                                   
-                                                                           
-          if(t1 < 0){                                                            
-            sign|=1;                                                     
-            t1=-t1;                                                        
-          }                                                                      
-        }                                                                        
-        codeWord   = huff_ctab9[t0][t1];                                 
-        codeLength = HI_LTAB(huff_ltab9_10[t0][t1]);                     
-        WriteBits(hBitstream,codeWord,codeLength);
-        WriteBits(hBitstream,sign,signLength);
-      }
-      break;
-
-    case CODE_BOOK_10_NO:
-      for(i=0; i<width; i+=2) {
-        sign=0;                                                          
-        signLength=0;                                                    
-        t0 = values[i+0];                                                
-                                                                           
-        if(t0 != 0){                                                             
-          signLength = signLength + 1;                                       
-          sign = sign << 1;                                                   
-                                                                           
-          if(t0 < 0){                                                            
-            sign|=1;                                                     
-            t0=-t0;                                                        
-          }                                                                      
-        }                                                                        
-                                                                                 
-        t1 = values[i+1];                                                
-                                                                           
-        if(t1 != 0){                                                             
-          signLength = signLength + 1;                                       
-          sign = sign << 1;                                                   
-                                                                           
-          if(t1 < 0){                                                            
-            sign|=1;                                                     
-            t1=-t1;                                                        
-          }                                                                      
-        }                                                                        
-        codeWord   = huff_ctab10[t0][t1];                                
-        codeLength = LO_LTAB(huff_ltab9_10[t0][t1]);                     
-        WriteBits(hBitstream,codeWord,codeLength);
-        WriteBits(hBitstream,sign,signLength);
-      }
-      break;
-
-    case CODE_BOOK_ESC_NO:
-      for(i=0; i<width; i+=2) {
-        sign=0;                                                  
-        signLength=0;                                            
-        t0 = values[i+0];                                        
-                                                                   
-        if(t0 != 0){                                                     
-          signLength = signLength + 1;                               
-          sign = sign << 1;                                           
-                                                                   
-          if(t0 < 0){                                                    
-            sign|=1;                                             
-            t0=-t0;                                                
-          }                                                              
-        }                                                                
-                                                                         
-        t1 = values[i+1];                                        
-                                                                   
-        if(t1 != 0){                                                     
-          signLength = signLength + 1;                               
-          sign = sign << 1;                                           
-                                                                   
-          if(t1 < 0){                                                    
-            sign|=1;                                             
-            t1=-t1;                                                
-          }                                                              
-        }                                                                
-        t00 = min(t0,16);
-        t01 = min(t1,16);
-
-        codeWord   = huff_ctab11[t00][t01];                      
-        codeLength = huff_ltab11[t00][t01];                      
-        WriteBits(hBitstream,codeWord,codeLength);
-        WriteBits(hBitstream,sign,signLength);
-         
-        if(t0 >= 16){
-          Word16 n, p;
-          n=0;                                                   
-          p=t0;                                                  
-          while(sub(p=(p >> 1), 16) >= 0){
-             
-            WriteBits(hBitstream,1,1);
-            n = n + 1;
-          }
-          WriteBits(hBitstream,0,1);
-          n = n + 4;
-          WriteBits(hBitstream,(t0 - (1 << n)),n);
-        }
-         
-        if(t1 >= 16){
-          Word16 n, p;
-          n=0;                                                   
-          p=t1;                                                  
-          while(sub(p=(p >> 1), 16) >= 0){
-             
-            WriteBits(hBitstream,1,1);
-            n = n + 1;
-          }
-          WriteBits(hBitstream,0,1);
-          n = n + 4;
-          WriteBits(hBitstream,(t1 - (1 << n)),n);
-        }
-      }
-      break;
-
-    default:
-      break;
-  }
-  return(0);
+Word16 codeValues(Word16 *values, Word16 width, Word16 codeBook, HANDLE_BIT_BUF hBitstream)
+{
+
+  Word32 i, t0, t1, t2, t3, t00, t01;
+  UWord16 codeWord, codeLength;
+  Word16 sign, signLength;
+
+
+  switch (codeBook) {
+    case CODE_BOOK_ZERO_NO:
+      break;
+
+    case CODE_BOOK_1_NO:
+      for(i=0; i<width; i+=4) {
+        t0         = values[i+0];
+        t1         = values[i+1];
+        t2         = values[i+2];
+        t3         = values[i+3];
+        codeWord   = huff_ctab1[t0+1][t1+1][t2+1][t3+1];
+        codeLength = HI_LTAB(huff_ltab1_2[t0+1][t1+1][t2+1][t3+1]);
+        WriteBits(hBitstream, codeWord, codeLength);
+      }
+      break;
+
+    case CODE_BOOK_2_NO:
+      for(i=0; i<width; i+=4) {
+        t0         = values[i+0];
+        t1         = values[i+1];
+        t2         = values[i+2];
+        t3         = values[i+3];
+        codeWord   = huff_ctab2[t0+1][t1+1][t2+1][t3+1];
+        codeLength = LO_LTAB(huff_ltab1_2[t0+1][t1+1][t2+1][t3+1]);
+        WriteBits(hBitstream,codeWord,codeLength);
+      }
+      break;
+
+    case CODE_BOOK_3_NO:
+      for(i=0; i<width; i+=4) {
+        sign=0;
+        signLength=0;
+        t0 = values[i+0];
+
+        if(t0 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t0 < 0){
+            sign|=1;
+            t0=-t0;
+          }
+        }
+        t1 = values[i+1];
+
+        if(t1 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t1 < 0){
+            sign|=1;
+            t1=-t1;
+          }
+        }
+        t2 = values[i+2];
+
+        if(t2 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t2 < 0){
+            sign|=1;
+            t2=-t2;
+          }
+        }
+        t3 = values[i+3];
+        if(t3 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t3 < 0){
+            sign|=1;
+            t3=-t3;
+          }
+        }
+
+        codeWord   = huff_ctab3[t0][t1][t2][t3];
+        codeLength = HI_LTAB(huff_ltab3_4[t0][t1][t2][t3]);
+        WriteBits(hBitstream,codeWord,codeLength);
+        WriteBits(hBitstream,sign,signLength);
+      }
+      break;
+
+    case CODE_BOOK_4_NO:
+      for(i=0; i<width; i+=4) {
+        sign=0;
+        signLength=0;
+        t0 = values[i+0];
+
+        if(t0 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+          if(t0 < 0){
+            sign|=1;
+            t0=-t0;
+          }
+        }
+        t1 = values[i+1];
+
+        if(t1 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t1 < 0){
+            sign|=1;
+            t1=-t1;
+          }
+        }
+        t2 = values[i+2];
+
+        if(t2 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t2 < 0){
+            sign|=1;
+            t2=-t2;
+          }
+        }
+        t3 = values[i+3];
+
+        if(t3 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t3 < 0){
+            sign|=1;
+            t3=-t3;
+          }
+        }
+        codeWord   = huff_ctab4[t0][t1][t2][t3];
+        codeLength = LO_LTAB(huff_ltab3_4[t0][t1][t2][t3]);
+        WriteBits(hBitstream,codeWord,codeLength);
+        WriteBits(hBitstream,sign,signLength);
+      }
+      break;
+
+    case CODE_BOOK_5_NO:
+      for(i=0; i<width; i+=2) {
+        t0         = values[i+0];
+        t1         = values[i+1];
+        codeWord   = huff_ctab5[t0+4][t1+4];
+        codeLength = HI_LTAB(huff_ltab5_6[t0+4][t1+4]);
+        WriteBits(hBitstream,codeWord,codeLength);
+      }
+      break;
+
+    case CODE_BOOK_6_NO:
+      for(i=0; i<width; i+=2) {
+        t0         = values[i+0];
+        t1         = values[i+1];
+        codeWord   = huff_ctab6[t0+4][t1+4];
+        codeLength = LO_LTAB(huff_ltab5_6[t0+4][t1+4]);
+        WriteBits(hBitstream,codeWord,codeLength);
+      }
+      break;
+
+    case CODE_BOOK_7_NO:
+      for(i=0; i<width; i+=2){
+        sign=0;
+        signLength=0;
+        t0 = values[i+0];
+
+        if(t0 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t0 < 0){
+            sign|=1;
+            t0=-t0;
+          }
+        }
+
+        t1 = values[i+1];
+
+        if(t1 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t1 < 0){
+            sign|=1;
+            t1=-t1;
+          }
+        }
+        codeWord   = huff_ctab7[t0][t1];
+        codeLength = HI_LTAB(huff_ltab7_8[t0][t1]);
+        WriteBits(hBitstream,codeWord,codeLength);
+        WriteBits(hBitstream,sign,signLength);
+      }
+      break;
+
+    case CODE_BOOK_8_NO:
+      for(i=0; i<width; i+=2) {
+        sign=0;
+        signLength=0;
+        t0 = values[i+0];
+
+        if(t0 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t0 < 0){
+            sign|=1;
+            t0=-t0;
+          }
+        }
+
+        t1 = values[i+1];
+
+        if(t1 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t1 < 0){
+            sign|=1;
+            t1=-t1;
+          }
+        }
+        codeWord   = huff_ctab8[t0][t1];
+        codeLength = LO_LTAB(huff_ltab7_8[t0][t1]);
+        WriteBits(hBitstream,codeWord,codeLength);
+        WriteBits(hBitstream,sign,signLength);
+      }
+      break;
+
+    case CODE_BOOK_9_NO:
+      for(i=0; i<width; i+=2) {
+        sign=0;
+        signLength=0;
+        t0 = values[i+0];
+
+        if(t0 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t0 < 0){
+            sign|=1;
+            t0=-t0;
+          }
+        }
+
+        t1 = values[i+1];
+
+        if(t1 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t1 < 0){
+            sign|=1;
+            t1=-t1;
+          }
+        }
+        codeWord   = huff_ctab9[t0][t1];
+        codeLength = HI_LTAB(huff_ltab9_10[t0][t1]);
+        WriteBits(hBitstream,codeWord,codeLength);
+        WriteBits(hBitstream,sign,signLength);
+      }
+      break;
+
+    case CODE_BOOK_10_NO:
+      for(i=0; i<width; i+=2) {
+        sign=0;
+        signLength=0;
+        t0 = values[i+0];
+
+        if(t0 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t0 < 0){
+            sign|=1;
+            t0=-t0;
+          }
+        }
+
+        t1 = values[i+1];
+
+        if(t1 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t1 < 0){
+            sign|=1;
+            t1=-t1;
+          }
+        }
+        codeWord   = huff_ctab10[t0][t1];
+        codeLength = LO_LTAB(huff_ltab9_10[t0][t1]);
+        WriteBits(hBitstream,codeWord,codeLength);
+        WriteBits(hBitstream,sign,signLength);
+      }
+      break;
+
+    case CODE_BOOK_ESC_NO:
+      for(i=0; i<width; i+=2) {
+        sign=0;
+        signLength=0;
+        t0 = values[i+0];
+
+        if(t0 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t0 < 0){
+            sign|=1;
+            t0=-t0;
+          }
+        }
+
+        t1 = values[i+1];
+
+        if(t1 != 0){
+          signLength = signLength + 1;
+          sign = sign << 1;
+
+          if(t1 < 0){
+            sign|=1;
+            t1=-t1;
+          }
+        }
+        t00 = min(t0,16);
+        t01 = min(t1,16);
+
+        codeWord   = huff_ctab11[t00][t01];
+        codeLength = huff_ltab11[t00][t01];
+        WriteBits(hBitstream,codeWord,codeLength);
+        WriteBits(hBitstream,sign,signLength);
+
+        if(t0 >= 16){
+          Word16 n, p;
+          n=0;
+          p=t0;
+          while(sub(p=(p >> 1), 16) >= 0){
+
+            WriteBits(hBitstream,1,1);
+            n = n + 1;
+          }
+          WriteBits(hBitstream,0,1);
+          n = n + 4;
+          WriteBits(hBitstream,(t0 - (1 << n)),n);
+        }
+
+        if(t1 >= 16){
+          Word16 n, p;
+          n=0;
+          p=t1;
+          while(sub(p=(p >> 1), 16) >= 0){
+
+            WriteBits(hBitstream,1,1);
+            n = n + 1;
+          }
+          WriteBits(hBitstream,0,1);
+          n = n + 4;
+          WriteBits(hBitstream,(t1 - (1 << n)),n);
+        }
+      }
+      break;
+
+    default:
+      break;
+  }
+  return(0);
 }
 
 Word16 bitCountScalefactorDelta(Word16 delta)
@@ -871,15 +871,15 @@ Word16 bitCountScalefactorDelta(Word16 delta)
 
 Word16 codeScalefactorDelta(Word16 delta, HANDLE_BIT_BUF hBitstream)
 {
-  Word32 codeWord; 
+  Word32 codeWord;
   Word16 codeLength;
-  
-   
+
+
   if(delta > CODE_BOOK_SCF_LAV || delta < -CODE_BOOK_SCF_LAV)
     return(1);
-  
-  codeWord   = huff_ctabscf[delta + CODE_BOOK_SCF_LAV];            
-  codeLength = huff_ltabscf[delta + CODE_BOOK_SCF_LAV];            
+
+  codeWord   = huff_ctabscf[delta + CODE_BOOK_SCF_LAV];
+  codeLength = huff_ltabscf[delta + CODE_BOOK_SCF_LAV];
   WriteBits(hBitstream,codeWord,codeLength);
   return(0);
 }
diff --git a/media/libstagefright/codecs/aacenc/src/bitbuffer.c b/media/libstagefright/codecs/aacenc/src/bitbuffer.c
index 3248f0b..5615ac3 100644
--- a/media/libstagefright/codecs/aacenc/src/bitbuffer.c
+++ b/media/libstagefright/codecs/aacenc/src/bitbuffer.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		bitbuffer.c
-
-	Content:	Bit Buffer Management functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		bitbuffer.c
+
+	Content:	Bit Buffer Management functions
+
 *******************************************************************************/
 
 #include "bitbuffer.h"
@@ -32,15 +32,15 @@ static void updateBitBufWordPtr(HANDLE_BIT_BUF hBitBuf,
                                 UWord8 **pBitBufWord,
                                 Word16   cnt)
 {
-  *pBitBufWord += cnt;                                                                  
+  *pBitBufWord += cnt;
+
 
-                                                                                        
   if(*pBitBufWord > hBitBuf->pBitBufEnd) {
-    *pBitBufWord -= (hBitBuf->pBitBufEnd - hBitBuf->pBitBufBase + 1);                   
+    *pBitBufWord -= (hBitBuf->pBitBufEnd - hBitBuf->pBitBufBase + 1);
   }
-                                                                                        
+
   if(*pBitBufWord < hBitBuf->pBitBufBase) {
-    *pBitBufWord += (hBitBuf->pBitBufEnd - hBitBuf->pBitBufBase + 1);                   
+    *pBitBufWord += (hBitBuf->pBitBufEnd - hBitBuf->pBitBufBase + 1);
   }
 }
 
@@ -57,18 +57,18 @@ HANDLE_BIT_BUF CreateBitBuffer(HANDLE_BIT_BUF hBitBuf,
 {
   assert(bitBufSize*8 <= 32768);
 
-  hBitBuf->pBitBufBase = pBitBufBase;                                                    
-  hBitBuf->pBitBufEnd  = pBitBufBase + bitBufSize - 1;                                  
+  hBitBuf->pBitBufBase = pBitBufBase;
+  hBitBuf->pBitBufEnd  = pBitBufBase + bitBufSize - 1;
 
-  hBitBuf->pWriteNext  = pBitBufBase;                                                    
+  hBitBuf->pWriteNext  = pBitBufBase;
 
   hBitBuf->cache       = 0;
-  
-  hBitBuf->wBitPos     = 0;                                                              
-  hBitBuf->cntBits     = 0;   
-  
-  hBitBuf->size        = (bitBufSize << 3);                                             
-  hBitBuf->isValid     = 1;                                                              
+
+  hBitBuf->wBitPos     = 0;
+  hBitBuf->cntBits     = 0;
+
+  hBitBuf->size        = (bitBufSize << 3);
+  hBitBuf->isValid     = 1;
 
   return hBitBuf;
 }
@@ -81,9 +81,9 @@ HANDLE_BIT_BUF CreateBitBuffer(HANDLE_BIT_BUF hBitBuf,
 *****************************************************************************/
 void DeleteBitBuffer(HANDLE_BIT_BUF *hBitBuf)
 {
-  if(*hBitBuf)
-	(*hBitBuf)->isValid = 0;                                                               
-  *hBitBuf = NULL;                                                                       
+  if(*hBitBuf)
+	(*hBitBuf)->isValid = 0;
+  *hBitBuf = NULL;
 }
 
 /*****************************************************************************
@@ -96,15 +96,15 @@ void ResetBitBuf(HANDLE_BIT_BUF hBitBuf,
                  UWord8 *pBitBufBase,
                  Word16  bitBufSize)
 {
-  hBitBuf->pBitBufBase = pBitBufBase;                                                    
-  hBitBuf->pBitBufEnd  = pBitBufBase + bitBufSize - 1;                                  
+  hBitBuf->pBitBufBase = pBitBufBase;
+  hBitBuf->pBitBufEnd  = pBitBufBase + bitBufSize - 1;
+
 
-                                                 
-  hBitBuf->pWriteNext  = pBitBufBase;                                                    
+  hBitBuf->pWriteNext  = pBitBufBase;
+
+  hBitBuf->wBitPos     = 0;
+  hBitBuf->cntBits     = 0;
 
-  hBitBuf->wBitPos     = 0;    
-  hBitBuf->cntBits     = 0;    
-  
   hBitBuf->cache	   = 0;
 }
 
@@ -117,7 +117,7 @@ void ResetBitBuf(HANDLE_BIT_BUF hBitBuf,
 void CopyBitBuf(HANDLE_BIT_BUF hBitBufSrc,
                 HANDLE_BIT_BUF hBitBufDst)
 {
-  *hBitBufDst = *hBitBufSrc;                                                             
+  *hBitBufDst = *hBitBufSrc;
 }
 
 /*****************************************************************************
@@ -148,25 +148,25 @@ Word16 WriteBits(HANDLE_BIT_BUF hBitBuf,
   if(noBitsToWrite == 0)
 	  return noBitsToWrite;
 
-  hBitBuf->cntBits += noBitsToWrite;   
+  hBitBuf->cntBits += noBitsToWrite;
 
   wBitPos = hBitBuf->wBitPos;
   wBitPos += noBitsToWrite;
-  writeValue <<= 32 - wBitPos;	
+  writeValue <<= 32 - wBitPos;
   writeValue |= hBitBuf->cache;
-  
-  while (wBitPos >= 8) 
+
+  while (wBitPos >= 8)
   {
 	  UWord8 tmp;
 	  tmp = (UWord8)((writeValue >> 24) & 0xFF);
-	  
-	  *hBitBuf->pWriteNext++ = tmp;		
+
+	  *hBitBuf->pWriteNext++ = tmp;
 	  writeValue <<= 8;
 	  wBitPos -= 8;
   }
-  
+
   hBitBuf->wBitPos = wBitPos;
   hBitBuf->cache = writeValue;
-                                                                                     
+
   return noBitsToWrite;
 }
diff --git a/media/libstagefright/codecs/aacenc/src/bitenc.c b/media/libstagefright/codecs/aacenc/src/bitenc.c
index 588c2da..fcc12dd 100644
--- a/media/libstagefright/codecs/aacenc/src/bitenc.c
+++ b/media/libstagefright/codecs/aacenc/src/bitenc.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		bitenc.c
-
-	Content:	Bitstream encoder functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		bitenc.c
+
+	Content:	Bitstream encoder functions
+
 *******************************************************************************/
 
 #include "bitenc.h"
@@ -46,10 +46,10 @@ static Word32 encodeSpectralData(Word16             *sfbOffset,
   Word16 i,sfb;
   Word16 dbgVal;
   SECTION_INFO* psectioninfo;
-  dbgVal = GetBitsAvail(hBitStream);                                     
+  dbgVal = GetBitsAvail(hBitStream);
 
   for(i=0; i<sectionData->noOfSections; i++) {
-    psectioninfo = &(sectionData->sectionInfo[i]);
+    psectioninfo = &(sectionData->sectionInfo[i]);
 	/*
        huffencode spectral data for this section
     */
@@ -100,7 +100,7 @@ static void encodeIcsInfo(Word16 blockType,
   WriteBits(hBitStream,blockType,2);
   WriteBits(hBitStream,windowShape,1);
 
-   
+
   switch(blockType){
     case LONG_WINDOW:
     case START_WINDOW:
@@ -137,30 +137,30 @@ static Word32 encodeSectionData(SECTION_DATA *sectionData,
   Word16 sectLen;
   Word16 i;
   Word16 dbgVal=GetBitsAvail(hBitStream);
-       
 
-   
+
+
   switch(sectionData->blockType)
   {
     case LONG_WINDOW:
     case START_WINDOW:
     case STOP_WINDOW:
-      sectEscapeVal = SECT_ESC_VAL_LONG;                 
-      sectLenBits   = SECT_BITS_LONG;                    
+      sectEscapeVal = SECT_ESC_VAL_LONG;
+      sectLenBits   = SECT_BITS_LONG;
       break;
 
     case SHORT_WINDOW:
-      sectEscapeVal = SECT_ESC_VAL_SHORT;                
-      sectLenBits   = SECT_BITS_SHORT;                   
+      sectEscapeVal = SECT_ESC_VAL_SHORT;
+      sectLenBits   = SECT_BITS_SHORT;
       break;
   }
 
   for(i=0;i<sectionData->noOfSections;i++) {
     WriteBits(hBitStream,sectionData->sectionInfo[i].codeBook,4);
-    sectLen = sectionData->sectionInfo[i].sfbCnt;        
+    sectLen = sectionData->sectionInfo[i].sfbCnt;
 
     while(sectLen >= sectEscapeVal) {
-       
+
       WriteBits(hBitStream,sectEscapeVal,sectLenBits);
       sectLen = sectLen - sectEscapeVal;
     }
@@ -183,24 +183,24 @@ static Word32 encodeScaleFactorData(UWord16        *maxValueInSfb,
 {
   Word16 i,j,lastValScf,deltaScf;
   Word16 dbgVal = GetBitsAvail(hBitStream);
-  SECTION_INFO* psectioninfo; 
+  SECTION_INFO* psectioninfo;
 
-  lastValScf=scalefac[sectionData->firstScf];                    
+  lastValScf=scalefac[sectionData->firstScf];
 
   for(i=0;i<sectionData->noOfSections;i++){
-    psectioninfo = &(sectionData->sectionInfo[i]); 
+    psectioninfo = &(sectionData->sectionInfo[i]);
     if (psectioninfo->codeBook != CODE_BOOK_ZERO_NO){
       for (j=psectioninfo->sfbStart;
            j<psectioninfo->sfbStart+psectioninfo->sfbCnt; j++){
-         
+
         if(maxValueInSfb[j] == 0) {
-          deltaScf = 0;                                          
+          deltaScf = 0;
         }
         else {
           deltaScf = lastValScf - scalefac[j];
-          lastValScf = scalefac[j];                              
+          lastValScf = scalefac[j];
         }
-         
+
         if(codeScalefactorDelta(deltaScf,hBitStream)){
           return(1);
         }
@@ -227,7 +227,7 @@ static void encodeMSInfo(Word16          sfbCnt,
 {
   Word16 sfb, sfbOff;
 
-   
+
   switch(msDigest)
   {
     case MS_NONE:
@@ -242,7 +242,7 @@ static void encodeMSInfo(Word16          sfbCnt,
       WriteBits(hBitStream,SI_MS_MASK_SOME,2);
       for(sfbOff = 0; sfbOff < sfbCnt; sfbOff+=grpSfb) {
         for(sfb=0; sfb<maxSfb; sfb++) {
-             
+
           if(jsFlags[sfbOff+sfb] & MS_ON) {
             WriteBits(hBitStream,1,1);
           }
@@ -272,7 +272,7 @@ static void encodeTnsData(TNS_INFO tnsInfo,
   Word16 coefBits;
   Flag isShort;
 
-       
+
   if (blockType==2) {
     isShort = 1;
     numOfWindows = TRANS_FAC;
@@ -282,52 +282,52 @@ static void encodeTnsData(TNS_INFO tnsInfo,
     numOfWindows = 1;
   }
 
-  tnsPresent=0;                                                  
+  tnsPresent=0;
   for (i=0; i<numOfWindows; i++) {
-     
+
     if (tnsInfo.tnsActive[i]) {
-      tnsPresent=1;                                              
+      tnsPresent=1;
     }
   }
-   
+
   if (tnsPresent==0) {
     WriteBits(hBitStream,0,1);
   }
   else{ /* there is data to be written*/
     WriteBits(hBitStream,1,1); /*data_present */
     for (i=0; i<numOfWindows; i++) {
-       
+
       WriteBits(hBitStream,tnsInfo.tnsActive[i],(isShort?1:2));
-       
+
       if (tnsInfo.tnsActive[i]) {
-         
+
         WriteBits(hBitStream,((tnsInfo.coefRes[i] - 4)==0?1:0),1);
-         
+
         WriteBits(hBitStream,tnsInfo.length[i],(isShort?4:6));
-         
+
         WriteBits(hBitStream,tnsInfo.order[i],(isShort?3:5));
-         
+
         if (tnsInfo.order[i]){
           WriteBits(hBitStream, FILTER_DIRECTION, 1);
-           
+
           if(tnsInfo.coefRes[i] == 4) {
-            coefBits = 3;                                                
+            coefBits = 3;
             for(k=0; k<tnsInfo.order[i]; k++) {
-                 
+
               if (tnsInfo.coef[i*TNS_MAX_ORDER_SHORT+k] > 3 ||
                   tnsInfo.coef[i*TNS_MAX_ORDER_SHORT+k] < -4) {
-                coefBits = 4;                                            
+                coefBits = 4;
                 break;
               }
             }
           }
           else {
-            coefBits = 2;                                                
+            coefBits = 2;
             for(k=0; k<tnsInfo.order[i]; k++) {
-                 
+
               if (tnsInfo.coef[i*TNS_MAX_ORDER_SHORT+k] > 1 ||
                   tnsInfo.coef[i*TNS_MAX_ORDER_SHORT+k] < -2) {
-                coefBits = 3;                                            
+                coefBits = 3;
                 break;
               }
             }
@@ -335,7 +335,7 @@ static void encodeTnsData(TNS_INFO tnsInfo,
           WriteBits(hBitStream, tnsInfo.coefRes[i] - coefBits, 1); /*coef_compres*/
           for (k=0; k<tnsInfo.order[i]; k++ ) {
             static const Word16 rmask[] = {0,1,3,7,15};
-             
+
             WriteBits(hBitStream,tnsInfo.coef[i*TNS_MAX_ORDER_SHORT+k] & rmask[coefBits],coefBits);
           }
         }
@@ -397,7 +397,7 @@ writeIndividualChannelStream(Flag   commonWindow,
 
   encodeGlobalGain(globalGain, logNorm,scf[sectionData->firstScf], hBitStream);
 
-   
+
   if(!commonWindow) {
     encodeIcsInfo(sectionData->blockType, windowShape, groupingMask, sectionData, hBitStream);
   }
@@ -536,7 +536,7 @@ static void writeFillElement( const UWord8 *ancBytes,
     Write fill Element(s):
     amount of a fill element can be 7+X*8 Bits, X element of [0..270]
   */
-    
+
   while(totFillBits >= (3+4)) {
     cnt = min(((totFillBits - (3+4)) >> 3), ((1<<4)-1));
 
@@ -545,7 +545,7 @@ static void writeFillElement( const UWord8 *ancBytes,
 
     totFillBits = totFillBits - (3+4);
 
-     
+
     if ((cnt == (1<<4)-1)) {
 
       esc_count = min( ((totFillBits >> 3) - ((1<<4)-1)), (1<<8)-1);
@@ -555,7 +555,7 @@ static void writeFillElement( const UWord8 *ancBytes,
     }
 
     for(i=0;i<cnt;i++) {
-       
+
       if(ancBytes)
         WriteBits(hBitStream, *ancBytes++,8);
       else
@@ -564,7 +564,7 @@ static void writeFillElement( const UWord8 *ancBytes,
     }
   }
 }
-
+
 /*****************************************************************************
 *
 * function name: WriteBitStream
@@ -576,48 +576,48 @@ Word16 WriteBitstream (HANDLE_BIT_BUF hBitStream,
                        ELEMENT_INFO elInfo,
                        QC_OUT *qcOut,
                        PSY_OUT *psyOut,
-                       Word16 *globUsedBits,					   
-                       const UWord8 *ancBytes,
+                       Word16 *globUsedBits,
+                       const UWord8 *ancBytes,
 					   Word16 sampindex
                        ) /* returns error code */
 {
   Word16 bitMarkUp;
   Word16 elementUsedBits;
-  Word16 frameBits=0;
-
-  /*   struct bitbuffer bsWriteCopy; */
-  bitMarkUp = GetBitsAvail(hBitStream); 
-  if(qcOut->qcElement.adtsUsed)  /*  write adts header*/
-  {
-	  WriteBits(hBitStream, 0xFFF, 12); /* 12 bit Syncword */
-	  WriteBits(hBitStream, 1, 1); /* ID == 0 for MPEG4 AAC, 1 for MPEG2 AAC */
-	  WriteBits(hBitStream, 0, 2); /* layer == 0 */
-	  WriteBits(hBitStream, 1, 1); /* protection absent */
-	  WriteBits(hBitStream, 1, 2); /* profile */
-	  WriteBits(hBitStream, sampindex, 4); /* sampling rate */
-	  WriteBits(hBitStream, 0, 1); /* private bit */
-	  WriteBits(hBitStream, elInfo.nChannelsInEl, 3); /* ch. config (must be > 0) */
-								   /* simply using numChannels only works for
-									6 channels or less, else a channel
-									configuration should be written */
-	  WriteBits(hBitStream, 0, 1); /* original/copy */
-	  WriteBits(hBitStream, 0, 1); /* home */	  
-	  
-	  /* Variable ADTS header */
-	  WriteBits(hBitStream, 0, 1); /* copyr. id. bit */
-	  WriteBits(hBitStream, 0, 1); /* copyr. id. start */
-	  WriteBits(hBitStream, *globUsedBits >> 3, 13);
-	  WriteBits(hBitStream, 0x7FF, 11); /* buffer fullness (0x7FF for VBR) */
-	  WriteBits(hBitStream, 0, 2); /* raw data blocks (0+1=1) */  
-  }
-
-  *globUsedBits=0;                                               
+  Word16 frameBits=0;
+
+  /*   struct bitbuffer bsWriteCopy; */
+  bitMarkUp = GetBitsAvail(hBitStream);
+  if(qcOut->qcElement.adtsUsed)  /*  write adts header*/
+  {
+	  WriteBits(hBitStream, 0xFFF, 12); /* 12 bit Syncword */
+	  WriteBits(hBitStream, 1, 1); /* ID == 0 for MPEG4 AAC, 1 for MPEG2 AAC */
+	  WriteBits(hBitStream, 0, 2); /* layer == 0 */
+	  WriteBits(hBitStream, 1, 1); /* protection absent */
+	  WriteBits(hBitStream, 1, 2); /* profile */
+	  WriteBits(hBitStream, sampindex, 4); /* sampling rate */
+	  WriteBits(hBitStream, 0, 1); /* private bit */
+	  WriteBits(hBitStream, elInfo.nChannelsInEl, 3); /* ch. config (must be > 0) */
+								   /* simply using numChannels only works for
+									6 channels or less, else a channel
+									configuration should be written */
+	  WriteBits(hBitStream, 0, 1); /* original/copy */
+	  WriteBits(hBitStream, 0, 1); /* home */
+
+	  /* Variable ADTS header */
+	  WriteBits(hBitStream, 0, 1); /* copyr. id. bit */
+	  WriteBits(hBitStream, 0, 1); /* copyr. id. start */
+	  WriteBits(hBitStream, *globUsedBits >> 3, 13);
+	  WriteBits(hBitStream, 0x7FF, 11); /* buffer fullness (0x7FF for VBR) */
+	  WriteBits(hBitStream, 0, 2); /* raw data blocks (0+1=1) */
+  }
+
+  *globUsedBits=0;
 
   {
 
     Word16 *sfbOffset[2];
     TNS_INFO tnsInfo[2];
-    elementUsedBits = 0;                                         
+    elementUsedBits = 0;
 
     switch (elInfo.elType) {
 
@@ -636,7 +636,7 @@ Word16 WriteBitstream (HANDLE_BIT_BUF hBitStream,
         {
           Word16 msDigest;
           Word16 *msFlags = psyOut->psyOutElement.toolsInfo.msMask;
-          msDigest = psyOut->psyOutElement.toolsInfo.msDigest;                        
+          msDigest = psyOut->psyOutElement.toolsInfo.msDigest;
           sfbOffset[0] =
             psyOut->psyOutChannel[elInfo.ChannelIndex[0]].sfbOffsets;
           sfbOffset[1] =
@@ -668,20 +668,20 @@ Word16 WriteBitstream (HANDLE_BIT_BUF hBitStream,
   }
 
   writeFillElement(NULL,
-                   qcOut->totFillBits, 
+                   qcOut->totFillBits,
                    hBitStream);
 
   WriteBits(hBitStream,ID_END,3);
 
   /* byte alignement */
-  WriteBits(hBitStream,0, (8 - (hBitStream->cntBits & 7)) & 7);          
-  
+  WriteBits(hBitStream,0, (8 - (hBitStream->cntBits & 7)) & 7);
+
   *globUsedBits = *globUsedBits- bitMarkUp;
-  bitMarkUp = GetBitsAvail(hBitStream);                                  
+  bitMarkUp = GetBitsAvail(hBitStream);
   *globUsedBits = *globUsedBits + bitMarkUp;
   frameBits = frameBits + *globUsedBits;
 
-   
+
   if (frameBits !=  (qcOut->totStaticBitsUsed+qcOut->totDynBitsUsed + qcOut->totAncBitsUsed +
                      qcOut->totFillBits + qcOut->alignBits)) {
     return(-1);
diff --git a/media/libstagefright/codecs/aacenc/src/block_switch.c b/media/libstagefright/codecs/aacenc/src/block_switch.c
index c0054f7..47fd15e 100644
--- a/media/libstagefright/codecs/aacenc/src/block_switch.c
+++ b/media/libstagefright/codecs/aacenc/src/block_switch.c
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		block_switch.c
-
-	Content:	Block switching functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		block_switch.c
+
+	Content:	Block switching functions
+
 *******************************************************************************/
 
-#include "typedef.h"
-#include "basic_op.h"
+#include "typedef.h"
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "psy_const.h"
 #include "block_switch.h"
@@ -52,7 +52,7 @@ CalcWindowEnergy(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
   IIR high pass coeffs
 */
 Word32 hiPassCoeff[BLOCK_SWITCHING_IIR_LEN] = {
-  0xbec8b439, 0x609d4952  /* -0.5095f, 0.7548f */ 
+  0xbec8b439, 0x609d4952  /* -0.5095f, 0.7548f */
 };
 
 static const Word32 accWindowNrgFac = 0x26666666;                   /* factor for accumulating filtered window energies 0.3 */
@@ -76,8 +76,8 @@ Word16 InitBlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
                           const Word32 bitRate, const Word16 nChannels)
 {
   /* select attackRatio */
-           
-  if ((sub(nChannels,1)==0 && L_sub(bitRate, 24000) > 0) || 
+
+  if ((sub(nChannels,1)==0 && L_sub(bitRate, 24000) > 0) ||
       (sub(nChannels,1)>0 && bitRate > (nChannels * 16000))) {
     blockSwitchingControl->invAttackRatio = invAttackRatioHighBr;
   }
@@ -116,7 +116,7 @@ Word16 BlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
 
   /* Reset grouping info */
   for (i=0; i<TRANS_FAC; i++) {
-    blockSwitchingControl->groupLen[i] = 0;                                      
+    blockSwitchingControl->groupLen[i] = 0;
   }
 
 
@@ -125,21 +125,21 @@ Word16 BlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
                                                           &blockSwitchingControl->attackIndex,
                                                           BLOCK_SWITCH_WINDOWS);
 
-  blockSwitchingControl->attackIndex = blockSwitchingControl->lastAttackIndex;   
+  blockSwitchingControl->attackIndex = blockSwitchingControl->lastAttackIndex;
 
   /* Set grouping info */
-  blockSwitchingControl->noOfGroups = MAX_NO_OF_GROUPS;                          
+  blockSwitchingControl->noOfGroups = MAX_NO_OF_GROUPS;
 
   for (i=0; i<MAX_NO_OF_GROUPS; i++) {
-    blockSwitchingControl->groupLen[i] = suggestedGroupingTable[blockSwitchingControl->attackIndex][i];  
-  }
-	
+    blockSwitchingControl->groupLen[i] = suggestedGroupingTable[blockSwitchingControl->attackIndex][i];
+  }
+
   /* if the samplerate is less than 16000, it should be all the short block, avoid pre&post echo */
   if(sampleRate >= 16000) {
 	  /* Save current window energy as last window energy */
 	  for (w=0; w<BLOCK_SWITCH_WINDOWS; w++) {
-		  blockSwitchingControl->windowNrg[0][w] = blockSwitchingControl->windowNrg[1][w];             
-		  blockSwitchingControl->windowNrgF[0][w] = blockSwitchingControl->windowNrgF[1][w];           
+		  blockSwitchingControl->windowNrg[0][w] = blockSwitchingControl->windowNrg[1][w];
+		  blockSwitchingControl->windowNrgF[0][w] = blockSwitchingControl->windowNrgF[1][w];
 	  }
 
 
@@ -147,10 +147,10 @@ Word16 BlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
 	  CalcWindowEnergy(blockSwitchingControl, timeSignal, chIncrement, BLOCK_SWITCH_WINDOW_LEN);
 
 	  /* reset attack */
-	  blockSwitchingControl->attack = FALSE;                                         
+	  blockSwitchingControl->attack = FALSE;
 
-	  enMax = 0;                                                                     
-	  enM1 = blockSwitchingControl->windowNrgF[0][BLOCK_SWITCH_WINDOWS-1];           
+	  enMax = 0;
+	  enM1 = blockSwitchingControl->windowNrgF[0][BLOCK_SWITCH_WINDOWS-1];
 
 	  for (w=0; w<BLOCK_SWITCH_WINDOWS; w++) {
 		  Word32 enM1_Tmp, accWindowNrg_Tmp, windowNrgF_Tmp;
@@ -172,15 +172,15 @@ Word16 BlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
 		  /* if the energy with the ratio is bigger than the average, and the attack and short block  */
 		  if ((fixmul(windowNrgF_Tmp, blockSwitchingControl->invAttackRatio) >> windowNrgF_Shf) >
 			  blockSwitchingControl->accWindowNrg ) {
-				  blockSwitchingControl->attack = TRUE;                                      
-				  blockSwitchingControl->lastAttackIndex = w;                                
+				  blockSwitchingControl->attack = TRUE;
+				  blockSwitchingControl->lastAttackIndex = w;
 		  }
-		  enM1 = blockSwitchingControl->windowNrgF[1][w];                              
+		  enM1 = blockSwitchingControl->windowNrgF[1][w];
 		  enMax = max(enMax, enM1);
 	  }
 
 	  if (enMax < minAttackNrg) {
-		  blockSwitchingControl->attack = FALSE;                                       
+		  blockSwitchingControl->attack = FALSE;
 	  }
   }
   else
@@ -188,22 +188,22 @@ Word16 BlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
 	  blockSwitchingControl->attack = TRUE;
   }
 
-  /* Check if attack spreads over frame border */     
+  /* Check if attack spreads over frame border */
   if ((!blockSwitchingControl->attack) && (blockSwitchingControl->lastattack)) {
-     
+
     if (blockSwitchingControl->attackIndex == TRANS_FAC-1) {
-      blockSwitchingControl->attack = TRUE;                                      
+      blockSwitchingControl->attack = TRUE;
     }
 
-    blockSwitchingControl->lastattack = FALSE;                                   
+    blockSwitchingControl->lastattack = FALSE;
   }
   else {
-    blockSwitchingControl->lastattack = blockSwitchingControl->attack;           
+    blockSwitchingControl->lastattack = blockSwitchingControl->attack;
   }
 
-  blockSwitchingControl->windowSequence =  blockSwitchingControl->nextwindowSequence;    
+  blockSwitchingControl->windowSequence =  blockSwitchingControl->nextwindowSequence;
+
 
-     
   if (blockSwitchingControl->attack) {
     blockSwitchingControl->nextwindowSequence = SHORT_WINDOW;
   }
@@ -211,27 +211,27 @@ Word16 BlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
     blockSwitchingControl->nextwindowSequence = LONG_WINDOW;
   }
 
-  /* update short block group */ 
+  /* update short block group */
   if (blockSwitchingControl->nextwindowSequence == SHORT_WINDOW) {
-     
+
     if (blockSwitchingControl->windowSequence== LONG_WINDOW) {
-      blockSwitchingControl->windowSequence = START_WINDOW;                      
+      blockSwitchingControl->windowSequence = START_WINDOW;
     }
-     
+
     if (blockSwitchingControl->windowSequence == STOP_WINDOW) {
-      blockSwitchingControl->windowSequence = SHORT_WINDOW;                      
-      blockSwitchingControl->noOfGroups = 3;                                     
-      blockSwitchingControl->groupLen[0] = 3;                                    
-      blockSwitchingControl->groupLen[1] = 3;                                    
-      blockSwitchingControl->groupLen[2] = 2;                                    
+      blockSwitchingControl->windowSequence = SHORT_WINDOW;
+      blockSwitchingControl->noOfGroups = 3;
+      blockSwitchingControl->groupLen[0] = 3;
+      blockSwitchingControl->groupLen[1] = 3;
+      blockSwitchingControl->groupLen[2] = 2;
     }
   }
 
-  /* update block type */  
+  /* update block type */
   if (blockSwitchingControl->nextwindowSequence == LONG_WINDOW) {
-     
+
     if (blockSwitchingControl->windowSequence == SHORT_WINDOW) {
-      blockSwitchingControl->nextwindowSequence = STOP_WINDOW;                   
+      blockSwitchingControl->nextwindowSequence = STOP_WINDOW;
     }
   }
 
@@ -252,17 +252,17 @@ static Word32 SrchMaxWithIndex(const Word32 in[], Word16 *index, Word16 n)
   Word32 i, idx;
 
   /* Search maximum value in array and return index and value */
-  max = 0;                                                       
-  idx = 0;                                                       
+  max = 0;
+  idx = 0;
 
   for (i = 0; i < n; i++) {
-     
+
     if (in[i+1]  > max) {
-      max = in[i+1];                                             
-      idx = i;                                                   
+      max = in[i+1];
+      idx = i;
     }
   }
-  *index = idx;                                                  
+  *index = idx;
 
   return(max);
 }
@@ -274,7 +274,7 @@ static Word32 SrchMaxWithIndex(const Word32 in[], Word16 *index, Word16 n)
 * returns:      TRUE if success
 *
 **********************************************************************************/
-#ifndef ARMV5E
+#ifndef ARMV5E
 Word32 CalcWindowEnergy(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
                         Word16 *timeSignal,
                         Word16 chIncrement,
@@ -283,46 +283,46 @@ Word32 CalcWindowEnergy(BLOCK_SWITCHING_CONTROL *blockSwitchingControl,
   Word32 w, i, wOffset, tidx, ch;
   Word32 accuUE, accuFE;
   Word32 tempUnfiltered;
-  Word32 tempFiltered;
-  Word32 states0, states1;
-  Word32 Coeff0, Coeff1;
-
-
-  states0 = blockSwitchingControl->iirStates[0];
-  states1 = blockSwitchingControl->iirStates[1];
-  Coeff0 = hiPassCoeff[0];
+  Word32 tempFiltered;
+  Word32 states0, states1;
+  Word32 Coeff0, Coeff1;
+
+
+  states0 = blockSwitchingControl->iirStates[0];
+  states1 = blockSwitchingControl->iirStates[1];
+  Coeff0 = hiPassCoeff[0];
   Coeff1 = hiPassCoeff[1];
-  tidx = 0;                                                   
+  tidx = 0;
   for (w=0; w < BLOCK_SWITCH_WINDOWS; w++) {
 
-    accuUE = 0;                                                  
-    accuFE = 0;                                                  
+    accuUE = 0;
+    accuFE = 0;
 
     for(i=0; i<windowLen; i++) {
-	  Word32 accu1, accu2, accu3;
-	  Word32 out;
+	  Word32 accu1, accu2, accu3;
+	  Word32 out;
 	  tempUnfiltered = timeSignal[tidx];
       tidx = tidx + chIncrement;
-
-	  accu1 = L_mpy_ls(Coeff1, tempUnfiltered);
-	  accu2 = fixmul( Coeff0, states1 );
-	  accu3 = accu1 - states0;
-	  out = accu3 - accu2;
-
-	  states0 = accu1;             
-	  states1 = out;               
-
-      tempFiltered = extract_h(out);	  
+
+	  accu1 = L_mpy_ls(Coeff1, tempUnfiltered);
+	  accu2 = fixmul( Coeff0, states1 );
+	  accu3 = accu1 - states0;
+	  out = accu3 - accu2;
+
+	  states0 = accu1;
+	  states1 = out;
+
+      tempFiltered = extract_h(out);
       accuUE += (tempUnfiltered * tempUnfiltered) >> ENERGY_SHIFT;
       accuFE += (tempFiltered * tempFiltered) >> ENERGY_SHIFT;
     }
 
-    blockSwitchingControl->windowNrg[1][w] = accuUE;             
-    blockSwitchingControl->windowNrgF[1][w] = accuFE;            
+    blockSwitchingControl->windowNrg[1][w] = accuUE;
+    blockSwitchingControl->windowNrgF[1][w] = accuFE;
+
+  }
 
-  }
-
-  blockSwitchingControl->iirStates[0] = states0;
+  blockSwitchingControl->iirStates[0] = states0;
   blockSwitchingControl->iirStates[1] = states1;
 
   return(TRUE);
@@ -346,8 +346,8 @@ static Word16 IIRFilter(const Word16 in, const Word32 coeff[], Word32 states[])
   accu2 = fixmul( coeff[0], states[1] );
   out = accu3 - accu2;
 
-  states[0] = accu1;             
-  states[1] = out;               
+  states[0] = accu1;
+  states[1] = out;
 
   return round16(out);
 }
@@ -374,54 +374,54 @@ Word16 SyncBlockSwitching(BLOCK_SWITCHING_CONTROL *blockSwitchingControlLeft,
                           const Word16 nChannels)
 {
   Word16 i;
-  Word16 patchType = LONG_WINDOW;                
+  Word16 patchType = LONG_WINDOW;
+
 
-   
   if (nChannels == 1) { /* Mono */
     if (blockSwitchingControlLeft->windowSequence != SHORT_WINDOW) {
-      blockSwitchingControlLeft->noOfGroups = 1;                         
-      blockSwitchingControlLeft->groupLen[0] = 1;                        
+      blockSwitchingControlLeft->noOfGroups = 1;
+      blockSwitchingControlLeft->groupLen[0] = 1;
 
       for (i=1; i<TRANS_FAC; i++) {
-        blockSwitchingControlLeft->groupLen[i] = 0;                      
+        blockSwitchingControlLeft->groupLen[i] = 0;
       }
     }
   }
   else { /* Stereo common Window */
-    patchType = synchronizedBlockTypeTable[patchType][blockSwitchingControlLeft->windowSequence];        
-    patchType = synchronizedBlockTypeTable[patchType][blockSwitchingControlRight->windowSequence];       
+    patchType = synchronizedBlockTypeTable[patchType][blockSwitchingControlLeft->windowSequence];
+    patchType = synchronizedBlockTypeTable[patchType][blockSwitchingControlRight->windowSequence];
 
     /* Set synchronized Blocktype */
-    blockSwitchingControlLeft->windowSequence = patchType;               
-    blockSwitchingControlRight->windowSequence = patchType;              
+    blockSwitchingControlLeft->windowSequence = patchType;
+    blockSwitchingControlRight->windowSequence = patchType;
 
-    /* Synchronize grouping info */     
+    /* Synchronize grouping info */
     if(patchType != SHORT_WINDOW) { /* Long Blocks */
       /* Set grouping info */
-      blockSwitchingControlLeft->noOfGroups = 1;                         
-      blockSwitchingControlRight->noOfGroups = 1;                        
-      blockSwitchingControlLeft->groupLen[0] = 1;                        
-      blockSwitchingControlRight->groupLen[0] = 1;                       
+      blockSwitchingControlLeft->noOfGroups = 1;
+      blockSwitchingControlRight->noOfGroups = 1;
+      blockSwitchingControlLeft->groupLen[0] = 1;
+      blockSwitchingControlRight->groupLen[0] = 1;
 
       for (i=1; i<TRANS_FAC; i++) {
-        blockSwitchingControlLeft->groupLen[i] = 0;                      
-        blockSwitchingControlRight->groupLen[i] = 0;                     
+        blockSwitchingControlLeft->groupLen[i] = 0;
+        blockSwitchingControlRight->groupLen[i] = 0;
       }
     }
     else {
-       
+
       if (blockSwitchingControlLeft->maxWindowNrg > blockSwitchingControlRight->maxWindowNrg) {
         /* Left Channel wins */
-        blockSwitchingControlRight->noOfGroups = blockSwitchingControlLeft->noOfGroups;          
+        blockSwitchingControlRight->noOfGroups = blockSwitchingControlLeft->noOfGroups;
         for (i=0; i<TRANS_FAC; i++) {
-          blockSwitchingControlRight->groupLen[i] = blockSwitchingControlLeft->groupLen[i];      
+          blockSwitchingControlRight->groupLen[i] = blockSwitchingControlLeft->groupLen[i];
         }
       }
       else {
         /* Right Channel wins */
-        blockSwitchingControlLeft->noOfGroups = blockSwitchingControlRight->noOfGroups;          
+        blockSwitchingControlLeft->noOfGroups = blockSwitchingControlRight->noOfGroups;
         for (i=0; i<TRANS_FAC; i++) {
-          blockSwitchingControlLeft->groupLen[i] = blockSwitchingControlRight->groupLen[i];      
+          blockSwitchingControlLeft->groupLen[i] = blockSwitchingControlRight->groupLen[i];
         }
       }
     }
diff --git a/media/libstagefright/codecs/aacenc/src/channel_map.c b/media/libstagefright/codecs/aacenc/src/channel_map.c
index 247293b..f6552ed 100644
--- a/media/libstagefright/codecs/aacenc/src/channel_map.c
+++ b/media/libstagefright/codecs/aacenc/src/channel_map.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		channel_map.c
-
-	Content:	channel mapping functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		channel_map.c
+
+	Content:	channel mapping functions
+
 *******************************************************************************/
 
 #include "channel_map.h"
@@ -29,32 +29,32 @@ static const Word16 maxChannelBits = MAXBITS_COEF;
 
 static Word16 initElement(ELEMENT_INFO* elInfo, ELEMENT_TYPE elType)
 {
-  Word16 error=0;                                    
+  Word16 error=0;
 
-  elInfo->elType=elType;                             
+  elInfo->elType=elType;
 
   switch(elInfo->elType) {
 
     case ID_SCE:
-      elInfo->nChannelsInEl=1;                       
+      elInfo->nChannelsInEl=1;
 
-      elInfo->ChannelIndex[0]=0;                     
+      elInfo->ChannelIndex[0]=0;
 
-      elInfo->instanceTag=0;                         
+      elInfo->instanceTag=0;
       break;
 
     case ID_CPE:
 
-      elInfo->nChannelsInEl=2;                        
+      elInfo->nChannelsInEl=2;
 
-      elInfo->ChannelIndex[0]=0;                      
-      elInfo->ChannelIndex[1]=1;                      
+      elInfo->ChannelIndex[0]=0;
+      elInfo->ChannelIndex[1]=1;
 
-      elInfo->instanceTag=0;                    
+      elInfo->instanceTag=0;
       break;
 
     default:
-      error=1;                                  
+      error=1;
   }
 
   return error;
@@ -64,11 +64,11 @@ static Word16 initElement(ELEMENT_INFO* elInfo, ELEMENT_TYPE elType)
 Word16 InitElementInfo (Word16 nChannels, ELEMENT_INFO* elInfo)
 {
   Word16 error;
-  error = 0;                                        
+  error = 0;
 
   switch(nChannels) {
 
-    case 1: 
+    case 1:
       initElement(elInfo, ID_SCE);
       break;
 
@@ -77,7 +77,7 @@ Word16 InitElementInfo (Word16 nChannels, ELEMENT_INFO* elInfo)
       break;
 
     default:
-      error=4;                                         
+      error=4;
   }
 
   return error;
@@ -91,18 +91,18 @@ Word16 InitElementBits(ELEMENT_BITS *elementBits,
                        Word16 staticBitsTot)
 {
   Word16 error;
-  error = 0;                                    
+  error = 0;
 
    switch(elInfo.nChannelsInEl) {
     case 1:
-      elementBits->chBitrate = bitrateTot;                     
+      elementBits->chBitrate = bitrateTot;
       elementBits->averageBits = averageBitsTot - staticBitsTot;
-      elementBits->maxBits = maxChannelBits;                   
+      elementBits->maxBits = maxChannelBits;
 
       elementBits->maxBitResBits = maxChannelBits - averageBitsTot;
-      elementBits->maxBitResBits = elementBits->maxBitResBits - (elementBits->maxBitResBits & 7); 
-      elementBits->bitResLevel = elementBits->maxBitResBits;   
-      elementBits->relativeBits  = 0x4000; /* 1.0f/2 */        
+      elementBits->maxBitResBits = elementBits->maxBitResBits - (elementBits->maxBitResBits & 7);
+      elementBits->bitResLevel = elementBits->maxBitResBits;
+      elementBits->relativeBits  = 0x4000; /* 1.0f/2 */
       break;
 
     case 2:
@@ -111,13 +111,13 @@ Word16 InitElementBits(ELEMENT_BITS *elementBits,
       elementBits->maxBits     = maxChannelBits << 1;
 
       elementBits->maxBitResBits = (maxChannelBits << 1) - averageBitsTot;
-      elementBits->maxBitResBits = elementBits->maxBitResBits - (elementBits->maxBitResBits & 7);   
-      elementBits->bitResLevel = elementBits->maxBitResBits;     
-      elementBits->relativeBits = 0x4000; /* 1.0f/2 */           
+      elementBits->maxBitResBits = elementBits->maxBitResBits - (elementBits->maxBitResBits & 7);
+      elementBits->bitResLevel = elementBits->maxBitResBits;
+      elementBits->relativeBits = 0x4000; /* 1.0f/2 */
       break;
 
     default:
-      error = 1;                                                 
+      error = 1;
   }
   return error;
 }
diff --git a/media/libstagefright/codecs/aacenc/src/dyn_bits.c b/media/libstagefright/codecs/aacenc/src/dyn_bits.c
index 3deacca..3d2efdc 100644
--- a/media/libstagefright/codecs/aacenc/src/dyn_bits.c
+++ b/media/libstagefright/codecs/aacenc/src/dyn_bits.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		dyn_bits.c
-
-	Content:	Noiseless coder module functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		dyn_bits.c
+
+	Content:	Noiseless coder module functions
+
 *******************************************************************************/
 
 #include "aac_rom.h"
@@ -45,12 +45,12 @@ buildBitLookUp(const Word16 *quantSpectrum,
   for (i=0; i<maxSfb; i++) {
     Word16 sfbWidth, maxVal;
 
-    sectionInfo[i].sfbCnt = 1;                                   
-    sectionInfo[i].sfbStart = i;                                 
-    sectionInfo[i].sectionBits = INVALID_BITCOUNT;               
-    sectionInfo[i].codeBook = -1;                                
-    sfbWidth = sfbOffset[i + 1] - sfbOffset[i];              
-    maxVal = sfbMax[i];                                          
+    sectionInfo[i].sfbCnt = 1;
+    sectionInfo[i].sfbStart = i;
+    sectionInfo[i].sectionBits = INVALID_BITCOUNT;
+    sectionInfo[i].codeBook = -1;
+    sfbWidth = sfbOffset[i + 1] - sfbOffset[i];
+    maxVal = sfbMax[i];
     bitCount(quantSpectrum + sfbOffset[i], sfbWidth, maxVal, bitLookUp[i]);
   }
 }
@@ -66,13 +66,13 @@ static Word16
 findBestBook(const Word16 *bc, Word16 *book)
 {
   Word32 minBits, j;
-  minBits = INVALID_BITCOUNT;                                    
+  minBits = INVALID_BITCOUNT;
 
   for (j=0; j<=CODE_BOOK_ESC_NDX; j++) {
-     
+
     if (bc[j] < minBits) {
-      minBits = bc[j];                                           
-      *book = j;                                                 
+      minBits = bc[j];
+      *book = j;
     }
   }
   return extract_l(minBits);
@@ -82,12 +82,12 @@ static Word16
 findMinMergeBits(const Word16 *bc1, const Word16 *bc2)
 {
   Word32 minBits, j, sum;
-  minBits = INVALID_BITCOUNT;                                    
+  minBits = INVALID_BITCOUNT;
 
   for (j=0; j<=CODE_BOOK_ESC_NDX; j++) {
     sum = bc1[j] + bc2[j];
     if (sum < minBits) {
-      minBits = sum;                                             
+      minBits = sum;
     }
   }
   return extract_l(minBits);
@@ -109,13 +109,13 @@ findMaxMerge(const Word16 mergeGainLookUp[MAX_SFB_LONG],
              const Word16 maxSfb, Word16 *maxNdx)
 {
   Word32 i, maxMergeGain;
-  maxMergeGain = 0;                                              
+  maxMergeGain = 0;
 
   for (i=0; i+sectionInfo[i].sfbCnt < maxSfb; i += sectionInfo[i].sfbCnt) {
-     
+
     if (mergeGainLookUp[i] > maxMergeGain) {
-      maxMergeGain = mergeGainLookUp[i];                         
-      *maxNdx = i;                                               
+      maxMergeGain = mergeGainLookUp[i];
+      *maxNdx = i;
     }
   }
   return extract_l(maxMergeGain);
@@ -159,7 +159,7 @@ gmStage0(SECTION_INFO * sectionInfo,
 
   for (i=0; i<maxSfb; i++) {
     /* Side-Info bits will be calculated in Stage 1!  */
-     
+
     if (sectionInfo[i].sectionBits == INVALID_BITCOUNT) {
       sectionInfo[i].sectionBits = findBestBook(bitLookUp[i], &(sectionInfo[i].codeBook));
     }
@@ -177,16 +177,16 @@ gmStage1(SECTION_INFO * sectionInfo,
          const Word16 maxSfb,
          const Word16 *sideInfoTab)
 {
-  SECTION_INFO * sectionInfo_s;
-  SECTION_INFO * sectionInfo_e;
+  SECTION_INFO * sectionInfo_s;
+  SECTION_INFO * sectionInfo_e;
   Word32 mergeStart, mergeEnd;
-  mergeStart = 0;                                                        
+  mergeStart = 0;
 
   do {
 
-    sectionInfo_s = sectionInfo + mergeStart;
+    sectionInfo_s = sectionInfo + mergeStart;
 	for (mergeEnd=mergeStart+1; mergeEnd<maxSfb; mergeEnd++) {
-      sectionInfo_e = sectionInfo + mergeEnd; 
+      sectionInfo_e = sectionInfo + mergeEnd;
       if (sectionInfo_s->codeBook != sectionInfo_e->codeBook)
         break;
       sectionInfo_s->sfbCnt += 1;
@@ -196,11 +196,11 @@ gmStage1(SECTION_INFO * sectionInfo,
     }
 
     sectionInfo_s->sectionBits += sideInfoTab[sectionInfo_s->sfbCnt];
-    sectionInfo[mergeEnd - 1].sfbStart = sectionInfo_s->sfbStart;      /* speed up prev search */  
+    sectionInfo[mergeEnd - 1].sfbStart = sectionInfo_s->sfbStart;      /* speed up prev search */
+
+    mergeStart = mergeEnd;
 
-    mergeStart = mergeEnd;                                               
 
-     
   } while (mergeStart - maxSfb < 0);
 }
 
@@ -230,7 +230,7 @@ gmStage2(SECTION_INFO *sectionInfo,
 
     maxMergeGain = findMaxMerge(mergeGainLookUp, sectionInfo, maxSfb, &maxNdx);
 
-     
+
     if (maxMergeGain <= 0)
       break;
 
@@ -244,7 +244,7 @@ gmStage2(SECTION_INFO *sectionInfo,
 
     mergeBitLookUp(bitLookUp[maxNdx], bitLookUp[maxNdxNext]);
 
-     
+
     if (maxNdx != 0) {
       maxNdxLast = sectionInfo[maxNdx - 1].sfbStart;
       mergeGainLookUp[maxNdxLast] = CalcMergeGain(sectionInfo,
@@ -255,9 +255,9 @@ gmStage2(SECTION_INFO *sectionInfo,
     }
     maxNdxNext = maxNdx + sectionInfo[maxNdx].sfbCnt;
 
-    sectionInfo[maxNdxNext - 1].sfbStart = sectionInfo[maxNdx].sfbStart;             
+    sectionInfo[maxNdxNext - 1].sfbStart = sectionInfo[maxNdx].sfbStart;
+
 
-     
     if (maxNdxNext - maxSfb < 0) {
       mergeGainLookUp[maxNdx] = CalcMergeGain(sectionInfo,
                                               bitLookUp,
@@ -286,7 +286,7 @@ noiselessCounter(SECTION_DATA *sectionData,
 
   /*
     use appropriate side info table
-  */   
+  */
   switch (blockType)
   {
     case LONG_WINDOW:
@@ -300,11 +300,11 @@ noiselessCounter(SECTION_DATA *sectionData,
   }
 
 
-  sectionData->noOfSections = 0;                                         
-  sectionData->huffmanBits = 0;                                          
-  sectionData->sideInfoBits = 0;                                         
+  sectionData->noOfSections = 0;
+  sectionData->huffmanBits = 0;
+  sectionData->sideInfoBits = 0;
+
 
-   
   if (sectionData->maxSfbPerGroup == 0)
     return;
 
@@ -353,7 +353,7 @@ noiselessCounter(SECTION_DATA *sectionData,
       sectionData->huffmanBits = (sectionData->huffmanBits +
                                      (sectionInfo[i].sectionBits - sideInfoTab[sectionInfo[i].sfbCnt]));
       sectionData->sideInfoBits = (sectionData->sideInfoBits + sideInfoTab[sectionInfo[i].sfbCnt]);
-      sectionData->sectionInfo[sectionData->noOfSections] = sectionInfo[i];             
+      sectionData->sectionInfo[sectionData->noOfSections] = sectionInfo[i];
       sectionData->noOfSections = sectionData->noOfSections + 1;
     }
   }
@@ -372,9 +372,9 @@ static void scfCount(const Word16 *scalefacGain,
                      SECTION_DATA * sectionData)
 
 {
-  SECTION_INFO *psectionInfo;
-  SECTION_INFO *psectionInfom;
-
+  SECTION_INFO *psectionInfo;
+  SECTION_INFO *psectionInfom;
+
   /* counter */
   Word32 i = 0; /* section counter */
   Word32 j = 0; /* sfb counter */
@@ -386,64 +386,64 @@ static void scfCount(const Word16 *scalefacGain,
   Word32 lastValScf     = 0;
   Word32 deltaScf       = 0;
   Flag found            = 0;
-  Word32 scfSkipCounter = 0;           
-         
+  Word32 scfSkipCounter = 0;
+
+
+  sectionData->scalefacBits = 0;
 
-  sectionData->scalefacBits = 0;                                 
 
-   
   if (scalefacGain == NULL) {
     return;
   }
 
-  lastValScf = 0;                                                
-  sectionData->firstScf = 0;        
-  
+  lastValScf = 0;
+  sectionData->firstScf = 0;
+
   psectionInfo = sectionData->sectionInfo;
   for (i=0; i<sectionData->noOfSections; i++) {
-     
+
     if (psectionInfo->codeBook != CODE_BOOK_ZERO_NO) {
-      sectionData->firstScf = psectionInfo->sfbStart;      
-      lastValScf = scalefacGain[sectionData->firstScf];                  
+      sectionData->firstScf = psectionInfo->sfbStart;
+      lastValScf = scalefacGain[sectionData->firstScf];
       break;
-    }
+    }
 	psectionInfo += 1;
-  }
+  }
 
   psectionInfo = sectionData->sectionInfo;
   for (i=0; i<sectionData->noOfSections; i++, psectionInfo += 1) {
-       
+
     if (psectionInfo->codeBook != CODE_BOOK_ZERO_NO
         && psectionInfo->codeBook != CODE_BOOK_PNS_NO) {
       for (j = psectionInfo->sfbStart;
            j < (psectionInfo->sfbStart + psectionInfo->sfbCnt); j++) {
         /* check if we can repeat the last value to save bits */
-         
+
         if (maxValueInSfb[j] == 0) {
-          found = 0;                                                     
-           
+          found = 0;
+
           if (scfSkipCounter == 0) {
             /* end of section */
-             
+
             if (j - ((psectionInfo->sfbStart + psectionInfo->sfbCnt) - 1) == 0) {
-              found = 0;                                                 
+              found = 0;
             }
             else {
               for (k = j + 1; k < psectionInfo->sfbStart + psectionInfo->sfbCnt; k++) {
-                 
+
                 if (maxValueInSfb[k] != 0) {
                   int tmp = L_abs(scalefacGain[k] - lastValScf);
-				  found = 1;                                             
-                   
+				  found = 1;
+
                   if ( tmp < CODE_BOOK_SCF_LAV) {
                     /* save bits */
-                    deltaScf = 0;                                        
+                    deltaScf = 0;
                   }
                   else {
                     /* do not save bits */
                     deltaScf = lastValScf - scalefacGain[j];
-                    lastValScf = scalefacGain[j];                        
-                    scfSkipCounter = 0;                                  
+                    lastValScf = scalefacGain[j];
+                    scfSkipCounter = 0;
                   }
                   break;
                 }
@@ -451,50 +451,50 @@ static void scfCount(const Word16 *scalefacGain,
                 scfSkipCounter = scfSkipCounter + 1;
               }
             }
-			
+
 			psectionInfom = psectionInfo + 1;
             /* search for the next maxValueInSfb[] != 0 in all other sections */
             for (m = i + 1; (m < sectionData->noOfSections) && (found == 0); m++) {
-                 
+
               if ((psectionInfom->codeBook != CODE_BOOK_ZERO_NO) &&
                   (psectionInfom->codeBook != CODE_BOOK_PNS_NO)) {
                 for (n = psectionInfom->sfbStart;
                      n < (psectionInfom->sfbStart + psectionInfom->sfbCnt); n++) {
-                   
+
                   if (maxValueInSfb[n] != 0) {
-                    found = 1;                                           
-                     
+                    found = 1;
+
                     if ( (abs_s(scalefacGain[n] - lastValScf) < CODE_BOOK_SCF_LAV)) {
-                      deltaScf = 0;                                      
+                      deltaScf = 0;
                     }
                     else {
                       deltaScf = (lastValScf - scalefacGain[j]);
-                      lastValScf = scalefacGain[j];                      
-                      scfSkipCounter = 0;                                
+                      lastValScf = scalefacGain[j];
+                      scfSkipCounter = 0;
                     }
                     break;
                   }
                   /* count scalefactor skip */
                   scfSkipCounter = scfSkipCounter + 1;
                 }
-              }
-
+              }
+
 			  psectionInfom += 1;
             }
-             
+
             if (found == 0) {
-              deltaScf = 0;                                              
-              scfSkipCounter = 0;                                        
+              deltaScf = 0;
+              scfSkipCounter = 0;
             }
           }
           else {
-            deltaScf = 0;                                                
+            deltaScf = 0;
             scfSkipCounter = scfSkipCounter - 1;
-          }
+          }
         }
         else {
           deltaScf = lastValScf - scalefacGain[j];
-          lastValScf = scalefacGain[j];                                  
+          lastValScf = scalefacGain[j];
         }
         sectionData->scalefacBits += bitCountScalefactorDelta(deltaScf);
       }
@@ -517,14 +517,14 @@ dynBitCount(const Word16  *quantSpectrum,
             const Word16  *sfbOffset,
             SECTION_DATA  *sectionData)
 {
-  sectionData->blockType      = blockType;                       
-  sectionData->sfbCnt         = sfbCnt;                          
-  sectionData->sfbPerGroup    = sfbPerGroup;           
+  sectionData->blockType      = blockType;
+  sectionData->sfbCnt         = sfbCnt;
+  sectionData->sfbPerGroup    = sfbPerGroup;
   if(sfbPerGroup)
-	sectionData->noOfGroups   = sfbCnt/sfbPerGroup; 
+	sectionData->noOfGroups   = sfbCnt/sfbPerGroup;
   else
 	sectionData->noOfGroups   = 0x7fff;
-  sectionData->maxSfbPerGroup = maxSfbPerGroup;                  
+  sectionData->maxSfbPerGroup = maxSfbPerGroup;
 
   noiselessCounter(sectionData,
                    sectionData->mergeGainLookUp,
@@ -539,7 +539,7 @@ dynBitCount(const Word16  *quantSpectrum,
            sectionData);
 
 
-  return (sectionData->huffmanBits + sectionData->sideInfoBits + 
+  return (sectionData->huffmanBits + sectionData->sideInfoBits +
 	      sectionData->scalefacBits);
 }
 
diff --git a/media/libstagefright/codecs/aacenc/src/grp_data.c b/media/libstagefright/codecs/aacenc/src/grp_data.c
index 08d9a76..7861e1c 100644
--- a/media/libstagefright/codecs/aacenc/src/grp_data.c
+++ b/media/libstagefright/codecs/aacenc/src/grp_data.c
@@ -1,26 +1,26 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		grp_data.c
-
-	Content:	Short block grouping function
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		grp_data.c
+
+	Content:	Short block grouping function
+
 *******************************************************************************/
 
-#include "basic_op.h"
+#include "basic_op.h"
 #include "psy_const.h"
 #include "interface.h"
 #include "grp_data.h"
@@ -57,29 +57,29 @@ groupShortData(Word32        *mdctSpectrum,
 
   /* for short: regroup and  */
   /* cumulate energies und thresholds group-wise . */
-  
+
   /* calculate sfbCnt */
-  highestSfb = 0;                                        
+  highestSfb = 0;
   for (wnd=0; wnd<TRANS_FAC; wnd++) {
     for (sfb=sfbCnt - 1; sfb>=highestSfb; sfb--) {
       for (line=(sfbOffset[sfb + 1] - 1); line>=sfbOffset[sfb]; line--) {
-        
-        if (mdctSpectrum[wnd*FRAME_LEN_SHORT+line] != 0) break; 
+
+        if (mdctSpectrum[wnd*FRAME_LEN_SHORT+line] != 0) break;
       }
-      
+
       if (line >= sfbOffset[sfb]) break;
     }
     highestSfb = max(highestSfb, sfb);
   }
-  
+
   if (highestSfb < 0) {
-    highestSfb = 0;                                      
+    highestSfb = 0;
   }
   *maxSfbPerGroup = highestSfb + 1;
 
   /* calculate sfbOffset */
-  i = 0;                                                 
-  offset = 0;                                            
+  i = 0;
+  offset = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     for (sfb = 0; sfb < sfbCnt; sfb++) {
       groupedSfbOffset[i] = offset + sfbOffset[sfb] * groupLen[grp];
@@ -87,15 +87,15 @@ groupShortData(Word32        *mdctSpectrum,
     }
     offset += groupLen[grp] * FRAME_LEN_SHORT;
   }
-  groupedSfbOffset[i] = FRAME_LEN_LONG;                  
+  groupedSfbOffset[i] = FRAME_LEN_LONG;
   i += 1;
 
   /* calculate minSnr */
-  i = 0;                                                 
-  offset = 0;                                            
+  i = 0;
+  offset = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     for (sfb = 0; sfb < sfbCnt; sfb++) {
-      groupedSfbMinSnr[i] = sfbMinSnr[sfb];              
+      groupedSfbMinSnr[i] = sfbMinSnr[sfb];
       i += 1;
     }
     offset += groupLen[grp] * FRAME_LEN_SHORT;
@@ -103,74 +103,74 @@ groupShortData(Word32        *mdctSpectrum,
 
 
   /* sum up sfbThresholds */
-  wnd = 0;                                                       
-  i = 0;                                                         
+  wnd = 0;
+  i = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     for (sfb = 0; sfb < sfbCnt; sfb++) {
-      Word32 thresh = sfbThreshold->sfbShort[wnd][sfb];          
+      Word32 thresh = sfbThreshold->sfbShort[wnd][sfb];
       for (j=1; j<groupLen[grp]; j++) {
         thresh = L_add(thresh, sfbThreshold->sfbShort[wnd+j][sfb]);
       }
-      sfbThreshold->sfbLong[i] = thresh;                         
+      sfbThreshold->sfbLong[i] = thresh;
       i += 1;
     }
     wnd += groupLen[grp];
   }
 
   /* sum up sfbEnergies left/right */
-  wnd = 0;                                                       
-  i = 0;                                                         
+  wnd = 0;
+  i = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     for (sfb = 0; sfb < sfbCnt; sfb++) {
-      Word32 energy = sfbEnergy->sfbShort[wnd][sfb];             
+      Word32 energy = sfbEnergy->sfbShort[wnd][sfb];
       for (j=1; j<groupLen[grp]; j++) {
         energy = L_add(energy, sfbEnergy->sfbShort[wnd+j][sfb]);
       }
-      sfbEnergy->sfbLong[i] = energy;                            
+      sfbEnergy->sfbLong[i] = energy;
       i += 1;
     }
     wnd += groupLen[grp];
   }
 
   /* sum up sfbEnergies mid/side */
-  wnd = 0;                                                       
-  i = 0;                                                         
+  wnd = 0;
+  i = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     for (sfb = 0; sfb < sfbCnt; sfb++) {
-      Word32 energy = sfbEnergyMS->sfbShort[wnd][sfb];           
+      Word32 energy = sfbEnergyMS->sfbShort[wnd][sfb];
       for (j=1; j<groupLen[grp]; j++) {
         energy = L_add(energy, sfbEnergyMS->sfbShort[wnd+j][sfb]);
       }
-      sfbEnergyMS->sfbLong[i] = energy;                          
+      sfbEnergyMS->sfbLong[i] = energy;
       i += 1;
     }
     wnd += groupLen[grp];
   }
 
   /* sum up sfbSpreadedEnergies */
-  wnd = 0;                                                       
-  i = 0;                                                         
+  wnd = 0;
+  i = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     for (sfb = 0; sfb < sfbCnt; sfb++) {
-      Word32 energy = sfbSpreadedEnergy->sfbShort[wnd][sfb];     
+      Word32 energy = sfbSpreadedEnergy->sfbShort[wnd][sfb];
       for (j=1; j<groupLen[grp]; j++) {
         energy = L_add(energy, sfbSpreadedEnergy->sfbShort[wnd+j][sfb]);
       }
-      sfbSpreadedEnergy->sfbLong[i] = energy;                    
+      sfbSpreadedEnergy->sfbLong[i] = energy;
       i += 1;
     }
     wnd += groupLen[grp];
   }
 
   /* re-group spectrum */
-  wnd = 0;                                                       
-  i = 0;                                                         
+  wnd = 0;
+  i = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     for (sfb = 0; sfb < sfbCnt; sfb++) {
       for (j = 0; j < groupLen[grp]; j++) {
         Word16 lineOffset = FRAME_LEN_SHORT * (wnd + j);
         for (line = lineOffset + sfbOffset[sfb]; line < lineOffset + sfbOffset[sfb+1]; line++) {
-          tmpSpectrum[i] = mdctSpectrum[line];                   
+          tmpSpectrum[i] = mdctSpectrum[line];
           i = i + 1;
         }
       }
@@ -179,10 +179,10 @@ groupShortData(Word32        *mdctSpectrum,
   }
 
   for(i=0;i<FRAME_LEN_LONG;i+=4) {
-    mdctSpectrum[i] = tmpSpectrum[i];  
-	mdctSpectrum[i+1] = tmpSpectrum[i+1];  
-	mdctSpectrum[i+2] = tmpSpectrum[i+2];  
-	mdctSpectrum[i+3] = tmpSpectrum[i+3];  	
+    mdctSpectrum[i] = tmpSpectrum[i];
+	mdctSpectrum[i+1] = tmpSpectrum[i+1];
+	mdctSpectrum[i+2] = tmpSpectrum[i+2];
+	mdctSpectrum[i+3] = tmpSpectrum[i+3];
   }
 }
 
diff --git a/media/libstagefright/codecs/aacenc/src/interface.c b/media/libstagefright/codecs/aacenc/src/interface.c
index 304b1d4..f2472d8 100644
--- a/media/libstagefright/codecs/aacenc/src/interface.c
+++ b/media/libstagefright/codecs/aacenc/src/interface.c
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		interface.c
-
-	Content:	Interface psychoaccoustic/quantizer functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		interface.c
+
+	Content:	Interface psychoaccoustic/quantizer functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
-#include "oper_32b.h"
+#include "basic_op.h"
+#include "oper_32b.h"
 #include "psy_const.h"
 #include "interface.h"
 
@@ -49,64 +49,64 @@ void BuildInterface(Word32                  *groupedMdctSpectrum,
                     PSY_OUT_CHANNEL         *psyOutCh)
 {
   Word32 j;
-  Word32 grp; 
-  Word32 mask;
+  Word32 grp;
+  Word32 mask;
   Word16 *tmpV;
 
   /*
   copy values to psyOut
   */
-  psyOutCh->maxSfbPerGroup    = maxSfbPerGroup;                             
-  psyOutCh->sfbCnt            = groupedSfbCnt;   
+  psyOutCh->maxSfbPerGroup    = maxSfbPerGroup;
+  psyOutCh->sfbCnt            = groupedSfbCnt;
   if(noOfGroups)
 	psyOutCh->sfbPerGroup     = groupedSfbCnt/ noOfGroups;
   else
 	psyOutCh->sfbPerGroup     = 0x7fff;
-  psyOutCh->windowSequence    = windowSequence;                             
-  psyOutCh->windowShape       = windowShape;                                
-  psyOutCh->mdctScale         = mdctScale;                                  
+  psyOutCh->windowSequence    = windowSequence;
+  psyOutCh->windowShape       = windowShape;
+  psyOutCh->mdctScale         = mdctScale;
   psyOutCh->mdctSpectrum      = groupedMdctSpectrum;
   psyOutCh->sfbEnergy         = groupedSfbEnergy->sfbLong;
   psyOutCh->sfbThreshold      = groupedSfbThreshold->sfbLong;
   psyOutCh->sfbSpreadedEnergy = groupedSfbSpreadedEnergy->sfbLong;
-  
-  tmpV = psyOutCh->sfbOffsets;
+
+  tmpV = psyOutCh->sfbOffsets;
   for(j=0; j<groupedSfbCnt + 1; j++) {
       *tmpV++ = groupedSfbOffset[j];
   }
-  
+
   tmpV = psyOutCh->sfbMinSnr;
   for(j=0;j<groupedSfbCnt; j++) {
 	  *tmpV++ =   groupedSfbMinSnr[j];
   }
-  
+
   /* generate grouping mask */
-  mask = 0;                                                                      
+  mask = 0;
   for (grp = 0; grp < noOfGroups; grp++) {
     mask = mask << 1;
     for (j=1; j<groupLen[grp]; j++) {
       mask = mask << 1;
-      mask |= 1;                                                                 
+      mask |= 1;
     }
   }
-  psyOutCh->groupingMask = mask; 
-  
+  psyOutCh->groupingMask = mask;
+
   if (windowSequence != SHORT_WINDOW) {
-    psyOutCh->sfbEnSumLR =  sfbEnergySumLR.sfbLong;                              
-    psyOutCh->sfbEnSumMS =  sfbEnergySumMS.sfbLong;                              
+    psyOutCh->sfbEnSumLR =  sfbEnergySumLR.sfbLong;
+    psyOutCh->sfbEnSumMS =  sfbEnergySumMS.sfbLong;
   }
   else {
     Word32 i;
     Word32 accuSumMS=0;
-    Word32 accuSumLR=0;        
-	Word32 *pSumMS = sfbEnergySumMS.sfbShort;
+    Word32 accuSumLR=0;
+	Word32 *pSumMS = sfbEnergySumMS.sfbShort;
 	Word32 *pSumLR = sfbEnergySumLR.sfbShort;
 
     for (i=TRANS_FAC; i; i--) {
       accuSumLR = L_add(accuSumLR, *pSumLR); pSumLR++;
       accuSumMS = L_add(accuSumMS, *pSumMS); pSumMS++;
     }
-    psyOutCh->sfbEnSumMS = accuSumMS;                                            
-    psyOutCh->sfbEnSumLR = accuSumLR;                                            
+    psyOutCh->sfbEnSumMS = accuSumMS;
+    psyOutCh->sfbEnSumLR = accuSumLR;
   }
 }
diff --git a/media/libstagefright/codecs/aacenc/src/line_pe.c b/media/libstagefright/codecs/aacenc/src/line_pe.c
index da57647..480dc28 100644
--- a/media/libstagefright/codecs/aacenc/src/line_pe.c
+++ b/media/libstagefright/codecs/aacenc/src/line_pe.c
@@ -1,26 +1,26 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		line_pe.c
-
-	Content:	Perceptual entropie module functions
-
-*******************************************************************************/
-
-#include "basic_op.h"
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		line_pe.c
+
+	Content:	Perceptual entropie module functions
+
+*******************************************************************************/
+
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "typedef.h"
 #include "line_pe.h"
@@ -45,20 +45,20 @@ void prepareSfbPe(PE_DATA *peData,
                   const Word16 peOffset)
 {
   Word32 sfbGrp, sfb;
-  Word32 ch;     
+  Word32 ch;
 
   for(ch=0; ch<nChannels; ch++) {
     PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
     PE_CHANNEL_DATA *peChanData=&peData->peChannelData[ch];
     for(sfbGrp=0;sfbGrp<psyOutChan->sfbCnt; sfbGrp+=psyOutChan->sfbPerGroup){
       for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-	    peChanData->sfbNLines4[sfbGrp+sfb] = sfbNRelevantLines[ch][sfbGrp+sfb];          
-        sfbNRelevantLines[ch][sfbGrp+sfb] = sfbNRelevantLines[ch][sfbGrp+sfb] >> 2;    
-	    peChanData->sfbLdEnergy[sfbGrp+sfb] = logSfbEnergy[ch][sfbGrp+sfb];              
+	    peChanData->sfbNLines4[sfbGrp+sfb] = sfbNRelevantLines[ch][sfbGrp+sfb];
+        sfbNRelevantLines[ch][sfbGrp+sfb] = sfbNRelevantLines[ch][sfbGrp+sfb] >> 2;
+	    peChanData->sfbLdEnergy[sfbGrp+sfb] = logSfbEnergy[ch][sfbGrp+sfb];
       }
     }
   }
-  peData->offset = peOffset;                                                             
+  peData->offset = peOffset;
 }
 
 
@@ -75,35 +75,35 @@ void calcSfbPe(PE_DATA *peData,
   Word32 ch;
   Word32 sfbGrp, sfb;
   Word32 nLines4;
-  Word32 ldThr, ldRatio;
+  Word32 ldThr, ldRatio;
   Word32 pe, constPart, nActiveLines;
 
-  peData->pe = peData->offset;                                           
-  peData->constPart = 0;                                                 
-  peData->nActiveLines = 0;                                              
+  peData->pe = peData->offset;
+  peData->constPart = 0;
+  peData->nActiveLines = 0;
   for(ch=0; ch<nChannels; ch++) {
     PSY_OUT_CHANNEL *psyOutChan = &psyOutChannel[ch];
     PE_CHANNEL_DATA *peChanData = &peData->peChannelData[ch];
     const Word32 *sfbEnergy = psyOutChan->sfbEnergy;
     const Word32 *sfbThreshold = psyOutChan->sfbThreshold;
 
-    pe = 0;                                                  
-    constPart = 0;                                           
-    nActiveLines = 0;                                        
+    pe = 0;
+    constPart = 0;
+    nActiveLines = 0;
 
     for(sfbGrp=0; sfbGrp<psyOutChan->sfbCnt; sfbGrp+=psyOutChan->sfbPerGroup) {
       for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-        Word32 nrg = sfbEnergy[sfbGrp+sfb];                             
-        Word32 thres = sfbThreshold[sfbGrp+sfb];                           
-        Word32 sfbLDEn = peChanData->sfbLdEnergy[sfbGrp+sfb];
+        Word32 nrg = sfbEnergy[sfbGrp+sfb];
+        Word32 thres = sfbThreshold[sfbGrp+sfb];
+        Word32 sfbLDEn = peChanData->sfbLdEnergy[sfbGrp+sfb];
 
         if (nrg > thres) {
           ldThr = iLog4(thres);
 
           ldRatio = sfbLDEn - ldThr;
 
-          nLines4 = peChanData->sfbNLines4[sfbGrp+sfb];                    
-           
+          nLines4 = peChanData->sfbNLines4[sfbGrp+sfb];
+
           /* sfbPe = nl*log2(en/thr)*/
 		  if (ldRatio >= C1_I) {
             peChanData->sfbPe[sfbGrp+sfb] = (nLines4*ldRatio + 8) >> 4;
@@ -111,35 +111,35 @@ void calcSfbPe(PE_DATA *peData,
           }
           else {
 		  /* sfbPe = nl*(c2 + c3*log2(en/thr))*/
-            peChanData->sfbPe[sfbGrp+sfb] = extract_l((L_mpy_wx(
-                    (C2_I + C3_I * ldRatio * 2) << 4, nLines4) + 4) >> 3);
-            peChanData->sfbConstPart[sfbGrp+sfb] = extract_l(( L_mpy_wx(
-                    (C2_I + C3_I * sfbLDEn * 2) << 4, nLines4) + 4) >> 3);
+            peChanData->sfbPe[sfbGrp+sfb] = extract_l((L_mpy_wx(
+                    (C2_I + C3_I * ldRatio * 2) << 4, nLines4) + 4) >> 3);
+            peChanData->sfbConstPart[sfbGrp+sfb] = extract_l(( L_mpy_wx(
+                    (C2_I + C3_I * sfbLDEn * 2) << 4, nLines4) + 4) >> 3);
             nLines4 = (nLines4 * C3_I + (1024<<1)) >> 10;
           }
           peChanData->sfbNActiveLines[sfbGrp+sfb] = nLines4 >> 2;
         }
         else {
-          peChanData->sfbPe[sfbGrp+sfb] = 0;                             
-          peChanData->sfbConstPart[sfbGrp+sfb] = 0;                      
-          peChanData->sfbNActiveLines[sfbGrp+sfb] = 0;                   
+          peChanData->sfbPe[sfbGrp+sfb] = 0;
+          peChanData->sfbConstPart[sfbGrp+sfb] = 0;
+          peChanData->sfbNActiveLines[sfbGrp+sfb] = 0;
         }
         pe = pe + peChanData->sfbPe[sfbGrp+sfb];
         constPart = constPart + peChanData->sfbConstPart[sfbGrp+sfb];
         nActiveLines = nActiveLines + peChanData->sfbNActiveLines[sfbGrp+sfb];
       }
     }
-	
-	peChanData->pe = saturate(pe);                                                  
-    peChanData->constPart = saturate(constPart);                                           
-    peChanData->nActiveLines = saturate(nActiveLines);                                        
 
-    
+	peChanData->pe = saturate(pe);
+    peChanData->constPart = saturate(constPart);
+    peChanData->nActiveLines = saturate(nActiveLines);
+
+
 	pe += peData->pe;
-	peData->pe = saturate(pe); 
+	peData->pe = saturate(pe);
     constPart += peData->constPart;
-	peData->constPart = saturate(constPart); 
+	peData->constPart = saturate(constPart);
     nActiveLines += peData->nActiveLines;
 	peData->nActiveLines = saturate(nActiveLines);
-  } 
+  }
 }
diff --git a/media/libstagefright/codecs/aacenc/src/memalign.c b/media/libstagefright/codecs/aacenc/src/memalign.c
index 7d20352..bb266dc 100644
--- a/media/libstagefright/codecs/aacenc/src/memalign.c
+++ b/media/libstagefright/codecs/aacenc/src/memalign.c
@@ -23,11 +23,16 @@
 
 
 #include	"memalign.h"
+#ifdef _MSC_VER
+#include	<stddef.h>
+#else
+#include	<stdint.h>
+#endif
 
 /*****************************************************************************
 *
 * function name: mem_malloc
-* description:  malloc the alignments memory 
+* description:  malloc the alignments memory
 * returns:      the point of the memory
 *
 **********************************************************************************/
@@ -66,8 +71,8 @@ mem_malloc(VO_MEM_OPERATOR *pMemop, unsigned int size, unsigned char alignment,
 		pMemop->Set(CodecID, tmp, 0, size + alignment);
 
 		mem_ptr =
-			(unsigned char *) ((unsigned int) (tmp + alignment - 1) &
-					(~((unsigned int) (alignment - 1))));
+			(unsigned char *) ((intptr_t) (tmp + alignment - 1) &
+					(~((intptr_t) (alignment - 1))));
 
 		if (mem_ptr == tmp)
 			mem_ptr += alignment;
diff --git a/media/libstagefright/codecs/aacenc/src/ms_stereo.c b/media/libstagefright/codecs/aacenc/src/ms_stereo.c
index c83d07b..2e34f14 100644
--- a/media/libstagefright/codecs/aacenc/src/ms_stereo.c
+++ b/media/libstagefright/codecs/aacenc/src/ms_stereo.c
@@ -1,26 +1,26 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		ms_stereo.c
-
-	Content:	MS stereo processing function
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		ms_stereo.c
+
+	Content:	MS stereo processing function
+
 *******************************************************************************/
 
-#include "basic_op.h"
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "psy_const.h"
 #include "ms_stereo.h"
@@ -30,7 +30,7 @@
 *
 * function name: MsStereoProcessing
 * description:  detect use ms stereo or not
-*				if ((min(thrLn, thrRn)*min(thrLn, thrRn))/(enMn*enSn)) 
+*				if ((min(thrLn, thrRn)*min(thrLn, thrRn))/(enMn*enSn))
 *				>= ((thrLn *thrRn)/(enLn*enRn)) then ms stereo
 *
 **********************************************************************************/
@@ -51,7 +51,7 @@ void MsStereoProcessing(Word32       *sfbEnergyLeft,
                         const Word16  maxSfbPerGroup,
                         const Word16 *sfbOffset) {
   Word32 temp;
-  Word32 sfb,sfboffs, j; 
+  Word32 sfb,sfboffs, j;
   Word32 msMaskTrueSomewhere = 0;
   Word32 msMaskFalseSomewhere = 0;
 
@@ -64,75 +64,75 @@ void MsStereoProcessing(Word32       *sfbEnergyLeft,
       Word32 thrL, thrR, nrgL, nrgR;
       Word32 idx, shift;
 
-      idx = sfb + sfboffs;                                                                       
+      idx = sfb + sfboffs;
 
-      thrL = sfbThresholdLeft[idx];                                                                 
-      thrR = sfbThresholdRight[idx];                                                                
-      nrgL = sfbEnergyLeft[idx];                                                                    
-      nrgR = sfbEnergyRight[idx];                                                                   
+      thrL = sfbThresholdLeft[idx];
+      thrR = sfbThresholdRight[idx];
+      nrgL = sfbEnergyLeft[idx];
+      nrgR = sfbEnergyRight[idx];
 
       minThreshold = min(thrL, thrR);
 
       nrgL = max(nrgL,thrL) + 1;
-      shift = norm_l(nrgL);
+      shift = norm_l(nrgL);
 	  nrgL = Div_32(thrL << shift, nrgL << shift);
       nrgR = max(nrgR,thrR) + 1;
-      shift = norm_l(nrgR);
+      shift = norm_l(nrgR);
 	  nrgR = Div_32(thrR << shift, nrgR << shift);
 
 	  pnlr = fixmul(nrgL, nrgR);
 
-      nrgL = sfbEnergyMid[idx];                                                                     
-      nrgR = sfbEnergySide[idx];                                                                    
+      nrgL = sfbEnergyMid[idx];
+      nrgR = sfbEnergySide[idx];
 
       nrgL = max(nrgL,minThreshold) + 1;
-      shift = norm_l(nrgL);
+      shift = norm_l(nrgL);
 	  nrgL = Div_32(minThreshold << shift, nrgL << shift);
 
       nrgR = max(nrgR,minThreshold) + 1;
-      shift = norm_l(nrgR);
+      shift = norm_l(nrgR);
 	  nrgR = Div_32(minThreshold << shift, nrgR << shift);
 
       pnms = fixmul(nrgL, nrgR);
 
       temp = (pnlr + 1) / ((pnms >> 8) + 1);
 
-      temp = pnms - pnlr;                                                                     
+      temp = pnms - pnlr;
       if( temp > 0 ){
 
-        msMask[idx] = 1;                                                                            
-        msMaskTrueSomewhere = 1;                                                                    
+        msMask[idx] = 1;
+        msMaskTrueSomewhere = 1;
 
         for (j=sfbOffset[idx]; j<sfbOffset[idx+1]; j++) {
           Word32 left, right;
           left  = (mdctSpectrumLeft[j] >>  1);
           right = (mdctSpectrumRight[j] >> 1);
-          mdctSpectrumLeft[j] =  left + right;                                               
-          mdctSpectrumRight[j] =  left - right;                                              
+          mdctSpectrumLeft[j] =  left + right;
+          mdctSpectrumRight[j] =  left - right;
         }
-        
-        sfbThresholdLeft[idx] = minThreshold;                                                       
-        sfbThresholdRight[idx] = minThreshold;                                                      
-        sfbEnergyLeft[idx] = sfbEnergyMid[idx];                                                     
-        sfbEnergyRight[idx] = sfbEnergySide[idx];                                                   
-
-        sfbSpreadedEnRight[idx] = min(sfbSpreadedEnLeft[idx],sfbSpreadedEnRight[idx]) >> 1;  
-        sfbSpreadedEnLeft[idx] = sfbSpreadedEnRight[idx];                                           
-        
+
+        sfbThresholdLeft[idx] = minThreshold;
+        sfbThresholdRight[idx] = minThreshold;
+        sfbEnergyLeft[idx] = sfbEnergyMid[idx];
+        sfbEnergyRight[idx] = sfbEnergySide[idx];
+
+        sfbSpreadedEnRight[idx] = min(sfbSpreadedEnLeft[idx],sfbSpreadedEnRight[idx]) >> 1;
+        sfbSpreadedEnLeft[idx] = sfbSpreadedEnRight[idx];
+
       }
       else {
-        msMask[idx]  = 0;                                                                           
-        msMaskFalseSomewhere = 1;                                                                   
+        msMask[idx]  = 0;
+        msMaskFalseSomewhere = 1;
       }
-    }                                                                                               
-    if ( msMaskTrueSomewhere ) {                                                                    
+    }
+    if ( msMaskTrueSomewhere ) {
       if(msMaskFalseSomewhere ) {
-        *msDigest = SI_MS_MASK_SOME;                                                                
+        *msDigest = SI_MS_MASK_SOME;
       } else {
-        *msDigest = SI_MS_MASK_ALL;                                                                 
+        *msDigest = SI_MS_MASK_ALL;
       }
     } else {
-      *msDigest = SI_MS_MASK_NONE;                                                                  
+      *msDigest = SI_MS_MASK_NONE;
     }
   }
 
diff --git a/media/libstagefright/codecs/aacenc/src/pre_echo_control.c b/media/libstagefright/codecs/aacenc/src/pre_echo_control.c
index f59216e..1406e11 100644
--- a/media/libstagefright/codecs/aacenc/src/pre_echo_control.c
+++ b/media/libstagefright/codecs/aacenc/src/pre_echo_control.c
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		pre_echo_control.c
-
-	Content:	Pre echo control functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		pre_echo_control.c
+
+	Content:	Pre echo control functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
-#include "oper_32b.h"
+#include "basic_op.h"
+#include "oper_32b.h"
 
 #include "oper_32b.h"
 #include "pre_echo_control.h"
@@ -29,7 +29,7 @@
 
 /*****************************************************************************
 *
-* function name:InitPreEchoControl 
+* function name:InitPreEchoControl
 * description: init pre echo control parameter
 *
 *****************************************************************************/
@@ -40,13 +40,13 @@ void InitPreEchoControl(Word32 *pbThresholdNm1,
   Word16 pb;
 
   for(pb=0; pb<numPb; pb++) {
-    pbThresholdNm1[pb] = pbThresholdQuiet[pb];                                   
+    pbThresholdNm1[pb] = pbThresholdQuiet[pb];
   }
 }
 
 /*****************************************************************************
 *
-* function name:PreEchoControl 
+* function name:PreEchoControl
 * description: update shreshold to avoid pre echo
 *			   thr(n) = max(rpmin*thrq(n), min(thrq(n), rpelev*thrq1(n)))
 *
@@ -68,22 +68,22 @@ void PreEchoControl(Word32 *pbThresholdNm1,
   (void)maxAllowedIncreaseFactor;
 
   scaling = ((mdctScale - mdctScalenm1) << 1);
-   
+
   if ( scaling > 0 ) {
     for(i = 0; i < numPb; i++) {
       tmpThreshold1 = pbThresholdNm1[i] >> (scaling-1);
       tmpThreshold2 = L_mpy_ls(pbThreshold[i], minRemainingThresholdFactor);
 
       /* copy thresholds to internal memory */
-      pbThresholdNm1[i] = pbThreshold[i];                                        
+      pbThresholdNm1[i] = pbThreshold[i];
+
 
-       
       if(pbThreshold[i] > tmpThreshold1) {
-        pbThreshold[i] = tmpThreshold1;                                          
+        pbThreshold[i] = tmpThreshold1;
       }
-       
+
       if(tmpThreshold2 > pbThreshold[i]) {
-        pbThreshold[i] = tmpThreshold2;                                          
+        pbThreshold[i] = tmpThreshold2;
       }
 
     }
@@ -96,15 +96,15 @@ void PreEchoControl(Word32 *pbThresholdNm1,
       tmpThreshold2 = L_mpy_ls(pbThreshold[i], minRemainingThresholdFactor);
 
       /* copy thresholds to internal memory */
-      pbThresholdNm1[i] = pbThreshold[i];                                        
+      pbThresholdNm1[i] = pbThreshold[i];
+
 
-       
       if(((pbThreshold[i] >> scaling) > tmpThreshold1)) {
         pbThreshold[i] = tmpThreshold1 << scaling;
       }
-       
+
       if(tmpThreshold2 > pbThreshold[i]) {
-        pbThreshold[i] = tmpThreshold2;                                          
+        pbThreshold[i] = tmpThreshold2;
       }
 
     }
diff --git a/media/libstagefright/codecs/aacenc/src/psy_configuration.c b/media/libstagefright/codecs/aacenc/src/psy_configuration.c
index 586e00f..02d92ab 100644
--- a/media/libstagefright/codecs/aacenc/src/psy_configuration.c
+++ b/media/libstagefright/codecs/aacenc/src/psy_configuration.c
@@ -1,26 +1,26 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		psy_configuration.c
-
-	Content:	Psychoaccoustic configuration functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		psy_configuration.c
+
+	Content:	Psychoaccoustic configuration functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "psy_configuration.h"
 #include "adj_thr.h"
@@ -29,10 +29,10 @@
 
 
 #define BARC_SCALE	100 /* integer barc values are scaled with 100 */
-#define LOG2_1000	301 /* log2*1000 */
-#define PI2_1000	1571 /* pi/2*1000*/
-#define ATAN_COEF1	3560 /* 1000/0.280872f*/
-#define ATAN_COEF2	281 /* 1000*0.280872f*/
+#define LOG2_1000	301 /* log2*1000 */
+#define PI2_1000	1571 /* pi/2*1000*/
+#define ATAN_COEF1	3560 /* 1000/0.280872f*/
+#define ATAN_COEF2	281 /* 1000*0.280872f*/
 
 
 typedef struct{
@@ -57,30 +57,30 @@ static const Word16 maskLowSprEnLong = 30;       /* in 1dB/bark */
 static const Word16 maskHighSprEnLong = 20;      /* in 1dB/bark */
 static const Word16 maskHighSprEnLongLowBr = 15; /* in 1dB/bark */
 static const Word16 maskLowSprEnShort = 20;      /* in 1dB/bark */
-static const Word16 maskHighSprEnShort = 15;     /* in 1dB/bark */
-static const Word16 c_minRemainingThresholdFactor = 0x0148;    /* 0.01 *(1 << 15)*/
-static const Word32 c_maxsnr = 0x66666666;		 /* upper limit is -1 dB */
-static const Word32 c_minsnr = 0x00624dd3;		 /* lower limit is -25 dB */
-
-static const Word32 c_maxClipEnergyLong = 0x77359400;  /* 2.0e9f*/
-static const Word32 c_maxClipEnergyShort = 0x01dcd650; /* 2.0e9f/(AACENC_TRANS_FAC*AACENC_TRANS_FAC)*/
-
-
-Word32 GetSRIndex(Word32 sampleRate)
-{
-    if (92017 <= sampleRate) return 0;
-    if (75132 <= sampleRate) return 1;
-    if (55426 <= sampleRate) return 2;
-    if (46009 <= sampleRate) return 3;
-    if (37566 <= sampleRate) return 4;
-    if (27713 <= sampleRate) return 5;
-    if (23004 <= sampleRate) return 6;
-    if (18783 <= sampleRate) return 7;
-    if (13856 <= sampleRate) return 8;
-    if (11502 <= sampleRate) return 9;
-    if (9391 <= sampleRate) return 10;
-
-    return 11;
+static const Word16 maskHighSprEnShort = 15;     /* in 1dB/bark */
+static const Word16 c_minRemainingThresholdFactor = 0x0148;    /* 0.01 *(1 << 15)*/
+static const Word32 c_maxsnr = 0x66666666;		 /* upper limit is -1 dB */
+static const Word32 c_minsnr = 0x00624dd3;		 /* lower limit is -25 dB */
+
+static const Word32 c_maxClipEnergyLong = 0x77359400;  /* 2.0e9f*/
+static const Word32 c_maxClipEnergyShort = 0x01dcd650; /* 2.0e9f/(AACENC_TRANS_FAC*AACENC_TRANS_FAC)*/
+
+
+Word32 GetSRIndex(Word32 sampleRate)
+{
+    if (92017 <= sampleRate) return 0;
+    if (75132 <= sampleRate) return 1;
+    if (55426 <= sampleRate) return 2;
+    if (46009 <= sampleRate) return 3;
+    if (37566 <= sampleRate) return 4;
+    if (27713 <= sampleRate) return 5;
+    if (23004 <= sampleRate) return 6;
+    if (18783 <= sampleRate) return 7;
+    if (13856 <= sampleRate) return 8;
+    if (11502 <= sampleRate) return 9;
+    if (9391 <= sampleRate) return 10;
+
+    return 11;
 }
 
 
@@ -88,17 +88,17 @@ Word32 GetSRIndex(Word32 sampleRate)
 *
 * function name: atan_1000
 * description:  calculates 1000*atan(x/1000)
-*               based on atan approx for x > 0				
-*				atan(x) = x/((float)1.0f+(float)0.280872f*x*x)  if x < 1
-*						= pi/2 - x/((float)0.280872f +x*x)	    if x >= 1
+*               based on atan approx for x > 0
+*				atan(x) = x/((float)1.0f+(float)0.280872f*x*x)  if x < 1
+*						= pi/2 - x/((float)0.280872f +x*x)	    if x >= 1
 * return:       1000*atan(x/1000)
 *
 **********************************************************************************/
-static Word16 atan_1000(Word32 val) 
+static Word16 atan_1000(Word32 val)
 {
   Word32 y;
 
-   
+
   if(L_sub(val, 1000) < 0) {
     y = extract_l(((1000 * val) / (1000 + ((val * val) / ATAN_COEF1))));
   }
@@ -126,9 +126,9 @@ static Word16 BarcLineValue(Word16 noOfLines, Word16 fftLine, Word32 samplingFre
   /* center frequency of fft line */
   center_freq = (fftLine * samplingFreq) / (noOfLines << 1);
   temp =  atan_1000((center_freq << 2) / (3*10));
-  bvalFFTLine = 
+  bvalFFTLine =
     (26600 * atan_1000((center_freq*76) / 100) + 7*temp*temp) / (2*1000*1000 / BARC_SCALE);
-  
+
   return saturate(bvalFFTLine);
 }
 
@@ -148,17 +148,17 @@ static void initThrQuiet(Word16  numPb,
   for(i=0; i<numPb; i++) {
     Word16 bv1, bv2;
 
-     
+
     if (i>0)
       bv1 = (pbBarcVal[i] + pbBarcVal[i-1]) >> 1;
     else
       bv1 = pbBarcVal[i] >> 1;
 
-     
+
     if (i < (numPb - 1))
       bv2 = (pbBarcVal[i] + pbBarcVal[i+1]) >> 1;
     else {
-      bv2 = pbBarcVal[i];                                        
+      bv2 = pbBarcVal[i];
     }
 
     bv1 = min((bv1 / BARC_SCALE), max_bark);
@@ -166,9 +166,9 @@ static void initThrQuiet(Word16  numPb,
 
     barcThrQuiet = min(BARC_THR_QUIET[bv1], BARC_THR_QUIET[bv2]);
 
-    
+
     /*
-      we calculate 
+      we calculate
       pow(10.0f,(float)(barcThrQuiet - ABS_LEV)*0.1)*(float)ABS_LOW*(pbOffset[i+1] - pbOffset[i]);
     */
 
@@ -196,47 +196,47 @@ static void initSpreading(Word16  numPb,
   Word16 i;
   Word16 maskLowSprEn, maskHighSprEn;
 
-   
+
   if (sub(blockType, SHORT_WINDOW) != 0) {
-    maskLowSprEn = maskLowSprEnLong;                                     
-       
+    maskLowSprEn = maskLowSprEnLong;
+
     if (bitrate > 22000)
       maskHighSprEn = maskHighSprEnLong;
     else
       maskHighSprEn = maskHighSprEnLongLowBr;
   }
   else {
-    maskLowSprEn = maskLowSprEnShort;            
-    maskHighSprEn = maskHighSprEnShort;          
+    maskLowSprEn = maskLowSprEnShort;
+    maskHighSprEn = maskHighSprEnShort;
   }
 
   for(i=0; i<numPb; i++) {
-     
+
     if (i > 0) {
       Word32 dbVal;
       Word16 dbark = pbBarcValue[i] - pbBarcValue[i-1];
 
       /*
-        we calulate pow(10.0f, -0.1*dbVal/BARC_SCALE) 
+        we calulate pow(10.0f, -0.1*dbVal/BARC_SCALE)
       */
       dbVal = (maskHigh * dbark);
       pbMaskHiFactor[i] = round16(pow2_xy(L_negate(dbVal), (Word32)LOG2_1000));             /* 0.301 log10(2) */
-       
+
       dbVal = (maskLow * dbark);
-      pbMaskLoFactor[i-1] = round16(pow2_xy(L_negate(dbVal),(Word32)LOG2_1000)); 
-       
-      
+      pbMaskLoFactor[i-1] = round16(pow2_xy(L_negate(dbVal),(Word32)LOG2_1000));
+
+
       dbVal = (maskHighSprEn * dbark);
-      pbMaskHiFactorSprEn[i] =  round16(pow2_xy(L_negate(dbVal),(Word32)LOG2_1000)); 
+      pbMaskHiFactorSprEn[i] =  round16(pow2_xy(L_negate(dbVal),(Word32)LOG2_1000));
       dbVal = (maskLowSprEn * dbark);
       pbMaskLoFactorSprEn[i-1] = round16(pow2_xy(L_negate(dbVal),(Word32)LOG2_1000));
     }
     else {
-      pbMaskHiFactor[i] = 0;                     
-      pbMaskLoFactor[numPb-1] = 0;               
+      pbMaskHiFactor[i] = 0;
+      pbMaskLoFactor[numPb-1] = 0;
 
-      pbMaskHiFactorSprEn[i] = 0;                
-      pbMaskLoFactorSprEn[numPb-1] = 0;          
+      pbMaskHiFactorSprEn[i] = 0;
+      pbMaskLoFactorSprEn[numPb-1] = 0;
     }
   }
 
@@ -258,12 +258,12 @@ static void initBarcValues(Word16  numPb,
   Word16 i;
   Word16 pbBval0, pbBval1;
 
-  pbBval0 = 0;                                       
+  pbBval0 = 0;
 
   for(i=0; i<numPb; i++){
     pbBval1 = BarcLineValue(numLines, pbOffset[i+1], samplingFrequency);
     pbBval[i] = (pbBval0 + pbBval1) >> 1;
-    pbBval0 = pbBval1;                              
+    pbBval0 = pbBval1;
   }
 }
 
@@ -272,7 +272,7 @@ static void initBarcValues(Word16  numPb,
 *
 * function name: initMinSnr
 * description:  calculate min snr parameter
-*				minSnr(n) = 1/(2^sfbPemin(n)/w(n) - 1.5)
+*				minSnr(n) = 1/(2^sfbPemin(n)/w(n) - 1.5)
 *
 *****************************************************************************/
 static void initMinSnr(const Word32  bitrate,
@@ -295,38 +295,38 @@ static void initMinSnr(const Word32  bitrate,
 
   pePerWindow = bits2pe(extract_l((bitrate * numLines) / samplerate));
 
-  pbVal0 = 0;                                                    
+  pbVal0 = 0;
 
   for (sfb=0; sfb<sfbActive; sfb++) {
 
     pbVal1 = (pbBarcVal[sfb] << 1) - pbVal0;
     barcWidth = pbVal1 - pbVal0;
-    pbVal0 = pbVal1;                                             
+    pbVal0 = pbVal1;
 
-    /* allow at least 2.4% of pe for each active barc */
+    /* allow at least 2.4% of pe for each active barc */
 	pePart = ((pePerWindow * 24) * (max_bark * barcWidth)) /
         (pbBarcVal[sfbActive-1] * (sfbOffset[sfb+1] - sfbOffset[sfb]));
-   
-      
-    pePart = min(pePart, 8400); 
+
+
+    pePart = min(pePart, 8400);
     pePart = max(pePart, 1400);
 
-    /* minSnr(n) = 1/(2^sfbPemin(n)/w(n) - 1.5)*/
+    /* minSnr(n) = 1/(2^sfbPemin(n)/w(n) - 1.5)*/
 	/* we add an offset of 2^16 to the pow functions */
-	/* 0xc000 = 1.5*(1 << 15)*/
-      
+	/* 0xc000 = 1.5*(1 << 15)*/
+
     snr = pow2_xy((pePart - 16*1000),1000) - 0x0000c000;
-      
-    if(snr > 0x00008000)
-	{
-		shift = norm_l(snr);
-		snr = Div_32(0x00008000 << shift, snr << shift);  
+
+    if(snr > 0x00008000)
+	{
+		shift = norm_l(snr);
+		snr = Div_32(0x00008000 << shift, snr << shift);
 	}
 	else
 	{
 		snr = 0x7fffffff;
 	}
-      
+
     /* upper limit is -1 dB */
     snr = min(snr, c_maxsnr);
     /* lower limit is -25 dB */
@@ -347,16 +347,16 @@ Word16 InitPsyConfigurationLong(Word32 bitrate,
                                 Word16 bandwidth,
                                 PSY_CONFIGURATION_LONG *psyConf)
 {
-  Word32 samplerateindex;
-  Word16 sfbBarcVal[MAX_SFB_LONG];
+  Word32 samplerateindex;
+  Word16 sfbBarcVal[MAX_SFB_LONG];
   Word16 sfb;
 
   /*
     init sfb table
-  */
-  samplerateindex = GetSRIndex(samplerate);  
-  psyConf->sfbCnt = sfBandTotalLong[samplerateindex];
-  psyConf->sfbOffset = sfBandTabLong + sfBandTabLongOffset[samplerateindex];
+  */
+  samplerateindex = GetSRIndex(samplerate);
+  psyConf->sfbCnt = sfBandTotalLong[samplerateindex];
+  psyConf->sfbOffset = sfBandTabLong + sfBandTabLongOffset[samplerateindex];
   psyConf->sampRateIdx = samplerateindex;
 
   /*
@@ -391,19 +391,19 @@ Word16 InitPsyConfigurationLong(Word32 bitrate,
   /*
     init ratio
   */
-  psyConf->ratio = c_ratio;      
+  psyConf->ratio = c_ratio;
 
-  psyConf->maxAllowedIncreaseFactor = 2;              
-  psyConf->minRemainingThresholdFactor = c_minRemainingThresholdFactor;    /* 0.01 *(1 << 15)*/  
+  psyConf->maxAllowedIncreaseFactor = 2;
+  psyConf->minRemainingThresholdFactor = c_minRemainingThresholdFactor;    /* 0.01 *(1 << 15)*/
 
-  psyConf->clipEnergy = c_maxClipEnergyLong;                   
+  psyConf->clipEnergy = c_maxClipEnergyLong;
   psyConf->lowpassLine = extract_l((bandwidth<<1) * FRAME_LEN_LONG / samplerate);
 
   for (sfb = 0; sfb < psyConf->sfbCnt; sfb++) {
     if (sub(psyConf->sfbOffset[sfb], psyConf->lowpassLine) >= 0)
       break;
   }
-  psyConf->sfbActive = sfb;                 
+  psyConf->sfbActive = sfb;
 
   /*
     calculate minSnr
@@ -429,7 +429,7 @@ Word16 InitPsyConfigurationLong(Word32 bitrate,
 Word16 InitPsyConfigurationShort(Word32 bitrate,
                                  Word32 samplerate,
                                  Word16 bandwidth,
-                                 PSY_CONFIGURATION_SHORT *psyConf) 
+                                 PSY_CONFIGURATION_SHORT *psyConf)
 {
   Word32 samplerateindex;
   Word16 sfbBarcVal[MAX_SFB_SHORT];
@@ -437,8 +437,8 @@ Word16 InitPsyConfigurationShort(Word32 bitrate,
   /*
     init sfb table
   */
-  samplerateindex = GetSRIndex(samplerate);  
-  psyConf->sfbCnt = sfBandTotalShort[samplerateindex];
+  samplerateindex = GetSRIndex(samplerate);
+  psyConf->sfbCnt = sfBandTotalShort[samplerateindex];
   psyConf->sfbOffset = sfBandTabShort + sfBandTabShortOffset[samplerateindex];
   psyConf->sampRateIdx = samplerateindex;
   /*
@@ -473,21 +473,21 @@ Word16 InitPsyConfigurationShort(Word32 bitrate,
   /*
     init ratio
   */
-  psyConf->ratio = c_ratio;                                                      
+  psyConf->ratio = c_ratio;
 
-  psyConf->maxAllowedIncreaseFactor = 2;                                         
-  psyConf->minRemainingThresholdFactor = c_minRemainingThresholdFactor;                            	 
+  psyConf->maxAllowedIncreaseFactor = 2;
+  psyConf->minRemainingThresholdFactor = c_minRemainingThresholdFactor;
 
-  psyConf->clipEnergy = c_maxClipEnergyShort;                                    
+  psyConf->clipEnergy = c_maxClipEnergyShort;
 
   psyConf->lowpassLine = extract_l(((bandwidth << 1) * FRAME_LEN_SHORT) / samplerate);
- 
+
   for (sfb = 0; sfb < psyConf->sfbCnt; sfb++) {
-     
+
     if (psyConf->sfbOffset[sfb] >= psyConf->lowpassLine)
       break;
   }
-  psyConf->sfbActive = sfb;                                                      
+  psyConf->sfbActive = sfb;
 
   /*
     calculate minSnr
diff --git a/media/libstagefright/codecs/aacenc/src/psy_main.c b/media/libstagefright/codecs/aacenc/src/psy_main.c
index 8746a72..085acb8 100644
--- a/media/libstagefright/codecs/aacenc/src/psy_main.c
+++ b/media/libstagefright/codecs/aacenc/src/psy_main.c
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		psy_main.c
-
-	Content:	Psychoacoustic major functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		psy_main.c
+
+	Content:	Psychoacoustic major functions
+
 *******************************************************************************/
 
-#include "typedef.h"
-#include "basic_op.h"
+#include "typedef.h"
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "psy_const.h"
 #include "block_switch.h"
@@ -77,29 +77,29 @@ static Word16 advancePsychShortMS (PSY_DATA  psyData[MAX_CHANNELS],
 *****************************************************************************/
 Word16 PsyNew(PSY_KERNEL *hPsy, Word32 nChan, VO_MEM_OPERATOR *pMemOP)
 {
-  Word16 i;
-  Word32 *mdctSpectrum;
-  Word32 *scratchTNS;
-  Word16 *mdctDelayBuffer;
-  
-  mdctSpectrum = (Word32 *)mem_malloc(pMemOP, nChan * FRAME_LEN_LONG * sizeof(Word32), 32, VO_INDEX_ENC_AAC);
-  if(NULL == mdctSpectrum)
-	  return 1;
-
-  scratchTNS = (Word32 *)mem_malloc(pMemOP, nChan * FRAME_LEN_LONG * sizeof(Word32), 32, VO_INDEX_ENC_AAC);
-  if(NULL == scratchTNS)
-  {
-	  return 1;
-  }
-
-  mdctDelayBuffer = (Word16 *)mem_malloc(pMemOP, nChan * BLOCK_SWITCHING_OFFSET * sizeof(Word16), 32, VO_INDEX_ENC_AAC);
-  if(NULL == mdctDelayBuffer)
-  {
+  Word16 i;
+  Word32 *mdctSpectrum;
+  Word32 *scratchTNS;
+  Word16 *mdctDelayBuffer;
+
+  mdctSpectrum = (Word32 *)mem_malloc(pMemOP, nChan * FRAME_LEN_LONG * sizeof(Word32), 32, VO_INDEX_ENC_AAC);
+  if(NULL == mdctSpectrum)
+	  return 1;
+
+  scratchTNS = (Word32 *)mem_malloc(pMemOP, nChan * FRAME_LEN_LONG * sizeof(Word32), 32, VO_INDEX_ENC_AAC);
+  if(NULL == scratchTNS)
+  {
+	  return 1;
+  }
+
+  mdctDelayBuffer = (Word16 *)mem_malloc(pMemOP, nChan * BLOCK_SWITCHING_OFFSET * sizeof(Word16), 32, VO_INDEX_ENC_AAC);
+  if(NULL == mdctDelayBuffer)
+  {
 	  return 1;
-  }
-
+  }
+
   for (i=0; i<nChan; i++){
-    hPsy->psyData[i].mdctDelayBuffer = mdctDelayBuffer + i*BLOCK_SWITCHING_OFFSET;      
+    hPsy->psyData[i].mdctDelayBuffer = mdctDelayBuffer + i*BLOCK_SWITCHING_OFFSET;
     hPsy->psyData[i].mdctSpectrum = mdctSpectrum + i*FRAME_LEN_LONG;
   }
 
@@ -118,27 +118,27 @@ Word16 PsyNew(PSY_KERNEL *hPsy, Word32 nChan, VO_MEM_OPERATOR *pMemOP)
 *****************************************************************************/
 Word16 PsyDelete(PSY_KERNEL  *hPsy, VO_MEM_OPERATOR *pMemOP)
 {
-  Word32 nch;
-
-  if(hPsy)
-  {
-	if(hPsy->psyData[0].mdctDelayBuffer)
-		mem_free(pMemOP, hPsy->psyData[0].mdctDelayBuffer, VO_INDEX_ENC_AAC);
-      
-    if(hPsy->psyData[0].mdctSpectrum)
-		mem_free(pMemOP, hPsy->psyData[0].mdctSpectrum, VO_INDEX_ENC_AAC);
-
-    for (nch=0; nch<MAX_CHANNELS; nch++){
-	  hPsy->psyData[nch].mdctDelayBuffer = NULL;      
-	  hPsy->psyData[nch].mdctSpectrum = NULL;
-	}
-
-	if(hPsy->pScratchTns)
-	{
-		mem_free(pMemOP, hPsy->pScratchTns, VO_INDEX_ENC_AAC);
-		hPsy->pScratchTns = NULL;
-	}
-  }
+  Word32 nch;
+
+  if(hPsy)
+  {
+	if(hPsy->psyData[0].mdctDelayBuffer)
+		mem_free(pMemOP, hPsy->psyData[0].mdctDelayBuffer, VO_INDEX_ENC_AAC);
+
+    if(hPsy->psyData[0].mdctSpectrum)
+		mem_free(pMemOP, hPsy->psyData[0].mdctSpectrum, VO_INDEX_ENC_AAC);
+
+    for (nch=0; nch<MAX_CHANNELS; nch++){
+	  hPsy->psyData[nch].mdctDelayBuffer = NULL;
+	  hPsy->psyData[nch].mdctSpectrum = NULL;
+	}
+
+	if(hPsy->pScratchTns)
+	{
+		mem_free(pMemOP, hPsy->pScratchTns, VO_INDEX_ENC_AAC);
+		hPsy->pScratchTns = NULL;
+	}
+  }
 
   return 0;
 }
@@ -196,10 +196,10 @@ Word16 psyMainInit(PSY_KERNEL *hPsy,
   err = InitPsyConfigurationLong(channelBitRate,
                                  sampleRate,
                                  bandwidth,
-                                 &(hPsy->psyConfLong));
-
+                                 &(hPsy->psyConfLong));
+
   if (!err) {
-      hPsy->sampleRateIdx = hPsy->psyConfLong.sampRateIdx;
+      hPsy->sampleRateIdx = hPsy->psyConfLong.sampRateIdx;
 	  err = InitTnsConfigurationLong(bitRate, sampleRate, channels,
                                    &hPsy->psyConfLong.tnsConf, &hPsy->psyConfLong, tnsMask&2);
   }
@@ -216,14 +216,14 @@ Word16 psyMainInit(PSY_KERNEL *hPsy,
 
   if (!err)
     for(ch=0;ch < channels;ch++){
-  
+
       InitBlockSwitching(&hPsy->psyData[ch].blockSwitchingControl,
                          bitRate, channels);
 
       InitPreEchoControl(hPsy->psyData[ch].sfbThresholdnm1,
                          hPsy->psyConfLong.sfbCnt,
                          hPsy->psyConfLong.sfbThresholdQuiet);
-      hPsy->psyData[ch].mdctScalenm1 = 0;                                
+      hPsy->psyData[ch].mdctScalenm1 = 0;
     }
 
 	return(err);
@@ -241,7 +241,7 @@ Word16 psyMainInit(PSY_KERNEL *hPsy,
 
 Word16 psyMain(Word16                   nChannels,
                ELEMENT_INFO            *elemInfo,
-               Word16                  *timeSignal, 
+               Word16                  *timeSignal,
                PSY_DATA                 psyData[MAX_CHANNELS],
                TNS_DATA                 tnsData[MAX_CHANNELS],
                PSY_CONFIGURATION_LONG  *hPsyConfLong,
@@ -260,10 +260,10 @@ Word16 psyMain(Word16                   nChannels,
   Word16 channels;
   Word16 maxScale;
 
-  channels = elemInfo->nChannelsInEl;                            
-  maxScale = 0;                                                  
+  channels = elemInfo->nChannelsInEl;
+  maxScale = 0;
 
-  /* block switching */
+  /* block switching */
   for(ch = 0; ch < channels; ch++) {
     BlockSwitching(&psyData[ch].blockSwitchingControl,
                    timeSignal+elemInfo->ChannelIndex[ch],
@@ -291,7 +291,7 @@ Word16 psyMain(Word16                   nChannels,
   /* common scaling for all channels */
   for (ch=0; ch<channels; ch++) {
     Word16 scaleDiff = maxScale - mdctScalingArray[ch];
-     
+
     if (scaleDiff > 0) {
       Word32 *Spectrum = psyData[ch].mdctSpectrum;
 	  for(line=0; line<FRAME_LEN_LONG; line++) {
@@ -299,11 +299,11 @@ Word16 psyMain(Word16                   nChannels,
 		Spectrum++;
       }
     }
-    psyData[ch].mdctScale = maxScale;                                    
+    psyData[ch].mdctScale = maxScale;
   }
 
   for (ch=0; ch<channels; ch++) {
-     
+
     if(psyData[ch].blockSwitchingControl.windowSequence != SHORT_WINDOW) {
       /* update long block parameter */
 	  advancePsychLong(&psyData[ch],
@@ -317,7 +317,7 @@ Word16 psyMain(Word16                   nChannels,
       /* determine maxSfb */
       for (sfb=hPsyConfLong->sfbCnt-1; sfb>=0; sfb--) {
         for (line=hPsyConfLong->sfbOffset[sfb+1] - 1; line>=hPsyConfLong->sfbOffset[sfb]; line--) {
-           
+
           if (psyData[ch].mdctSpectrum[line] != 0) break;
         }
         if (line >= hPsyConfLong->sfbOffset[sfb]) break;
@@ -326,7 +326,7 @@ Word16 psyMain(Word16                   nChannels,
 
       /* Calc bandwise energies for mid and side channel
          Do it only if 2 channels exist */
-       
+
       if (ch == 1)
         advancePsychLongMS(psyData, hPsyConfLong);
     }
@@ -341,7 +341,7 @@ Word16 psyMain(Word16                   nChannels,
 
       /* Calc bandwise energies for mid and side channel
          Do it only if 2 channels exist */
-       
+
       if (ch == 1)
         advancePsychShortMS (psyData, hPsyConfShort);
     }
@@ -349,7 +349,7 @@ Word16 psyMain(Word16                   nChannels,
 
   /* group short data */
   for(ch=0; ch<channels; ch++) {
-     
+
     if (psyData[ch].blockSwitchingControl.windowSequence == SHORT_WINDOW) {
       groupShortData(psyData[ch].mdctSpectrum,
                      pScratchTns,
@@ -374,10 +374,10 @@ Word16 psyMain(Word16                   nChannels,
     stereo Processing
   */
   if (channels == 2) {
-    psyOutElement->toolsInfo.msDigest = MS_NONE;                 
+    psyOutElement->toolsInfo.msDigest = MS_NONE;
     maxSfbPerGroup[0] = maxSfbPerGroup[1] = max(maxSfbPerGroup[0], maxSfbPerGroup[1]);
 
-     
+
     if (psyData[0].blockSwitchingControl.windowSequence != SHORT_WINDOW)
       MsStereoProcessing(psyData[0].sfbEnergy.sfbLong,
                          psyData[1].sfbEnergy.sfbLong,
@@ -420,7 +420,7 @@ Word16 psyMain(Word16                   nChannels,
     build output
   */
   for(ch=0;ch<channels;ch++) {
-     
+
     if (psyData[ch].blockSwitchingControl.windowSequence != SHORT_WINDOW)
       BuildInterface(psyData[ch].mdctSpectrum,
                      psyData[ch].mdctScale,
@@ -477,13 +477,13 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
 {
   Word32 i;
   Word32 normEnergyShift = (psyData->mdctScale + 1) << 1; /* in reference code, mdct spectrum must be multipied with 2, so +1 */
-  Word32 clipEnergy = hPsyConfLong->clipEnergy >> normEnergyShift;
+  Word32 clipEnergy = hPsyConfLong->clipEnergy >> normEnergyShift;
   Word32 *data0, *data1, tdata;
 
   /* low pass */
-  data0 = psyData->mdctSpectrum + hPsyConfLong->lowpassLine;
+  data0 = psyData->mdctSpectrum + hPsyConfLong->lowpassLine;
   for(i=hPsyConfLong->lowpassLine; i<FRAME_LEN_LONG; i++) {
-    *data0++ = 0;                                
+    *data0++ = 0;
   }
 
   /* Calc sfb-bandwise mdct-energies for left and right channel */
@@ -505,7 +505,7 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
             psyData->blockSwitchingControl.windowSequence,
             psyData->sfbEnergy.sfbLong);
 
-  /*  TnsSync */   
+  /*  TnsSync */
   if (ch == 1) {
     TnsSync(tnsData,
             tnsData2,
@@ -514,7 +514,7 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
             psyData->blockSwitchingControl.windowSequence);
   }
 
-  /*  Tns Encoder */ 
+  /*  Tns Encoder */
   TnsEncode(&psyOutChannel->tnsInfo,
             tnsData,
             hPsyConfLong->sfbCnt,
@@ -525,27 +525,27 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
             psyData->blockSwitchingControl.windowSequence);
 
   /* first part of threshold calculation */
-  data0 = psyData->sfbEnergy.sfbLong;
-  data1 = psyData->sfbThreshold.sfbLong;
+  data0 = psyData->sfbEnergy.sfbLong;
+  data1 = psyData->sfbThreshold.sfbLong;
   for (i=hPsyConfLong->sfbCnt; i; i--) {
     tdata = L_mpy_ls(*data0++, hPsyConfLong->ratio);
-    *data1++ = min(tdata, clipEnergy);
+    *data1++ = min(tdata, clipEnergy);
   }
 
-  /* Calc sfb-bandwise mdct-energies for left and right channel again */   
+  /* Calc sfb-bandwise mdct-energies for left and right channel again */
   if (tnsData->dataRaw.tnsLong.subBlockInfo.tnsActive!=0) {
-    Word16 tnsStartBand = hPsyConfLong->tnsConf.tnsStartBand;                            
+    Word16 tnsStartBand = hPsyConfLong->tnsConf.tnsStartBand;
     CalcBandEnergy( psyData->mdctSpectrum,
                     hPsyConfLong->sfbOffset+tnsStartBand,
                     hPsyConfLong->sfbActive - tnsStartBand,
                     psyData->sfbEnergy.sfbLong+tnsStartBand,
                     &psyData->sfbEnergySum.sfbLong);
-    
-	data0 = psyData->sfbEnergy.sfbLong;
-	tdata = psyData->sfbEnergySum.sfbLong;
+
+	data0 = psyData->sfbEnergy.sfbLong;
+	tdata = psyData->sfbEnergySum.sfbLong;
 	for (i=0; i<tnsStartBand; i++)
-      tdata += *data0++;
-
+      tdata += *data0++;
+
 	psyData->sfbEnergySum.sfbLong = tdata;
   }
 
@@ -557,21 +557,21 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
                psyData->sfbThreshold.sfbLong);
 
   /* threshold in quiet */
-  data0 = psyData->sfbThreshold.sfbLong;
-  data1 = hPsyConfLong->sfbThresholdQuiet;
+  data0 = psyData->sfbThreshold.sfbLong;
+  data1 = hPsyConfLong->sfbThresholdQuiet;
   for (i=hPsyConfLong->sfbCnt; i; i--)
-  {
-	  *data0 = max(*data0, (*data1 >> normEnergyShift));
-	  data0++; data1++;
+  {
+	  *data0 = max(*data0, (*data1 >> normEnergyShift));
+	  data0++; data1++;
   }
 
-  /* preecho control */   
+  /* preecho control */
   if (psyData->blockSwitchingControl.windowSequence == STOP_WINDOW) {
-    data0 = psyData->sfbThresholdnm1;
-	for (i=hPsyConfLong->sfbCnt; i; i--) {
-      *data0++ = MAX_32;                              
-    }
-    psyData->mdctScalenm1 = 0;                                           
+    data0 = psyData->sfbThresholdnm1;
+	for (i=hPsyConfLong->sfbCnt; i; i--) {
+      *data0++ = MAX_32;
+    }
+    psyData->mdctScalenm1 = 0;
   }
 
   PreEchoControl( psyData->sfbThresholdnm1,
@@ -581,15 +581,15 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
                   psyData->sfbThreshold.sfbLong,
                   psyData->mdctScale,
                   psyData->mdctScalenm1);
-  psyData->mdctScalenm1 = psyData->mdctScale;                            
+  psyData->mdctScalenm1 = psyData->mdctScale;
+
 
-   
   if (psyData->blockSwitchingControl.windowSequence== START_WINDOW) {
-    data0 = psyData->sfbThresholdnm1;
+    data0 = psyData->sfbThresholdnm1;
 	for (i=hPsyConfLong->sfbCnt; i; i--) {
-      *data0++ = MAX_32;                              
+      *data0++ = MAX_32;
     }
-    psyData->mdctScalenm1 = 0;                                           
+    psyData->mdctScalenm1 = 0;
   }
 
   /* apply tns mult table on cb thresholds */
@@ -600,16 +600,16 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
 
 
   /* spreaded energy */
-  data0 = psyData->sfbSpreadedEnergy.sfbLong;
-  data1 = psyData->sfbEnergy.sfbLong;
+  data0 = psyData->sfbSpreadedEnergy.sfbLong;
+  data1 = psyData->sfbEnergy.sfbLong;
   for (i=hPsyConfLong->sfbCnt; i; i--) {
-    //psyData->sfbSpreadedEnergy.sfbLong[i] = psyData->sfbEnergy.sfbLong[i];       
+    //psyData->sfbSpreadedEnergy.sfbLong[i] = psyData->sfbEnergy.sfbLong[i];
 	  *data0++ = *data1++;
   }
 
   /* spreading energy */
   SpreadingMax(hPsyConfLong->sfbCnt,
-               hPsyConfLong->sfbMaskLowFactorSprEn, 
+               hPsyConfLong->sfbMaskLowFactorSprEn,
                hPsyConfLong->sfbMaskHighFactorSprEn,
                psyData->sfbSpreadedEnergy.sfbLong);
 
@@ -619,7 +619,7 @@ static Word16 advancePsychLong(PSY_DATA* psyData,
 /*****************************************************************************
 *
 * function name: advancePsychLongMS
-* description:   update mdct-energies for left add or minus right channel 
+* description:   update mdct-energies for left add or minus right channel
 *				for long block
 *
 *****************************************************************************/
@@ -657,16 +657,16 @@ static Word16 advancePsychShort(PSY_DATA* psyData,
   Word32 w;
   Word32 normEnergyShift = (psyData->mdctScale + 1) << 1; /* in reference code, mdct spectrum must be multipied with 2, so +1 */
   Word32 clipEnergy = hPsyConfShort->clipEnergy >> normEnergyShift;
-  Word32 wOffset = 0;     
+  Word32 wOffset = 0;
   Word32 *data0, *data1;
 
   for(w = 0; w < TRANS_FAC; w++) {
     Word32 i, tdata;
 
     /* low pass */
-    data0 = psyData->mdctSpectrum + wOffset + hPsyConfShort->lowpassLine;
+    data0 = psyData->mdctSpectrum + wOffset + hPsyConfShort->lowpassLine;
 	for(i=hPsyConfShort->lowpassLine; i<FRAME_LEN_SHORT; i++){
-      *data0++ = 0;                                      
+      *data0++ = 0;
     }
 
     /* Calc sfb-bandwise mdct-energies for left and right channel */
@@ -706,27 +706,27 @@ static Word16 advancePsychShort(PSY_DATA* psyData,
               psyData->blockSwitchingControl.windowSequence);
 
     /* first part of threshold calculation */
-    data0 = psyData->sfbThreshold.sfbShort[w];
-	data1 = psyData->sfbEnergy.sfbShort[w];
+    data0 = psyData->sfbThreshold.sfbShort[w];
+	data1 = psyData->sfbEnergy.sfbShort[w];
 	for (i=hPsyConfShort->sfbCnt; i; i--) {
       tdata = L_mpy_ls(*data1++, hPsyConfShort->ratio);
-      *data0++ = min(tdata, clipEnergy);
+      *data0++ = min(tdata, clipEnergy);
     }
 
-    /* Calc sfb-bandwise mdct-energies for left and right channel again */     
+    /* Calc sfb-bandwise mdct-energies for left and right channel again */
     if (tnsData->dataRaw.tnsShort.subBlockInfo[w].tnsActive != 0) {
-      Word16 tnsStartBand = hPsyConfShort->tnsConf.tnsStartBand;                            
+      Word16 tnsStartBand = hPsyConfShort->tnsConf.tnsStartBand;
       CalcBandEnergy( psyData->mdctSpectrum+wOffset,
                       hPsyConfShort->sfbOffset+tnsStartBand,
                       (hPsyConfShort->sfbActive - tnsStartBand),
                       psyData->sfbEnergy.sfbShort[w]+tnsStartBand,
-                      &psyData->sfbEnergySum.sfbShort[w]);
+                      &psyData->sfbEnergySum.sfbShort[w]);
 
-      tdata = psyData->sfbEnergySum.sfbShort[w];
-	  data0 = psyData->sfbEnergy.sfbShort[w];
+      tdata = psyData->sfbEnergySum.sfbShort[w];
+	  data0 = psyData->sfbEnergy.sfbShort[w];
 	  for (i=tnsStartBand; i; i--)
-        tdata += *data0++;
-
+        tdata += *data0++;
+
 	  psyData->sfbEnergySum.sfbShort[w] = tdata;
     }
 
@@ -738,17 +738,17 @@ static Word16 advancePsychShort(PSY_DATA* psyData,
 
 
     /* threshold in quiet */
-    data0 = psyData->sfbThreshold.sfbShort[w];
-	data1 = hPsyConfShort->sfbThresholdQuiet;
+    data0 = psyData->sfbThreshold.sfbShort[w];
+	data1 = hPsyConfShort->sfbThresholdQuiet;
 	for (i=hPsyConfShort->sfbCnt; i; i--)
-    {
-		*data0 = max(*data0, (*data1 >> normEnergyShift));
-
-		data0++; data1++;
-	}
+    {
+		*data0 = max(*data0, (*data1 >> normEnergyShift));
+
+		data0++; data1++;
+	}
 
 
-    /* preecho */     
+    /* preecho */
     PreEchoControl( psyData->sfbThresholdnm1,
                     hPsyConfShort->sfbCnt,
                     hPsyConfShort->maxAllowedIncreaseFactor,
@@ -764,20 +764,20 @@ static Word16 advancePsychShort(PSY_DATA* psyData,
                                psyData->sfbThreshold.sfbShort[w]);
 
     /* spreaded energy */
-    data0 = psyData->sfbSpreadedEnergy.sfbShort[w];
-	data1 = psyData->sfbEnergy.sfbShort[w];
+    data0 = psyData->sfbSpreadedEnergy.sfbShort[w];
+	data1 = psyData->sfbEnergy.sfbShort[w];
 	for (i=hPsyConfShort->sfbCnt; i; i--) {
 	  *data0++ = *data1++;
     }
     SpreadingMax(hPsyConfShort->sfbCnt,
-                 hPsyConfShort->sfbMaskLowFactorSprEn, 
+                 hPsyConfShort->sfbMaskLowFactorSprEn,
                  hPsyConfShort->sfbMaskHighFactorSprEn,
                  psyData->sfbSpreadedEnergy.sfbShort[w]);
 
     wOffset += FRAME_LEN_SHORT;
   } /* for TRANS_FAC */
 
-  psyData->mdctScalenm1 = psyData->mdctScale;              
+  psyData->mdctScalenm1 = psyData->mdctScale;
 
   return 0;
 }
@@ -785,7 +785,7 @@ static Word16 advancePsychShort(PSY_DATA* psyData,
 /*****************************************************************************
 *
 * function name: advancePsychShortMS
-* description:   update mdct-energies for left add or minus right channel 
+* description:   update mdct-energies for left add or minus right channel
 *				for short block
 *
 *****************************************************************************/
@@ -793,7 +793,7 @@ static Word16 advancePsychShortMS (PSY_DATA psyData[MAX_CHANNELS],
                                    const PSY_CONFIGURATION_SHORT *hPsyConfShort)
 {
   Word32 w, wOffset;
-  wOffset = 0;                                   
+  wOffset = 0;
   for(w=0; w<TRANS_FAC; w++) {
     CalcBandEnergyMS(psyData[0].mdctSpectrum+wOffset,
                      psyData[1].mdctSpectrum+wOffset,
diff --git a/media/libstagefright/codecs/aacenc/src/qc_main.c b/media/libstagefright/codecs/aacenc/src/qc_main.c
index a568020..df6d46e 100644
--- a/media/libstagefright/codecs/aacenc/src/qc_main.c
+++ b/media/libstagefright/codecs/aacenc/src/qc_main.c
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		qc_main.c
-
-	Content:	Quantizing & coding functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		qc_main.c
+
+	Content:	Quantizing & coding functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
-#include "oper_32b.h"
+#include "basic_op.h"
+#include "oper_32b.h"
 #include "qc_main.h"
 #include "quantize.h"
 #include "interface.h"
@@ -68,12 +68,12 @@ static Word16 calcFrameLen(Word32 bitRate,
   result = (FRAME_LEN_LONG >> 3) * bitRate;
   quot = result / sampleRate;
 
-   
+
   if (mode == FRAME_LEN_BYTES_MODULO) {
     result -= quot * sampleRate;
   }
   else { /* FRAME_LEN_BYTES_INT */
-    result = quot;                                      
+    result = quot;
   }
 
   return result;
@@ -83,7 +83,7 @@ static Word16 calcFrameLen(Word32 bitRate,
 *
 *  function name:framePadding
 *  description: Calculates if padding is needed for actual frame
-*  returns: paddingOn or not 
+*  returns: paddingOn or not
 *
 *****************************************************************************/
 static Word16 framePadding(Word32 bitRate,
@@ -93,16 +93,16 @@ static Word16 framePadding(Word32 bitRate,
   Word16 paddingOn;
   Word16 difference;
 
-  paddingOn = 0;                                                 
+  paddingOn = 0;
 
   difference = calcFrameLen( bitRate,
                              sampleRate,
                              FRAME_LEN_BYTES_MODULO );
   *paddingRest = *paddingRest - difference;
 
-   
+
   if (*paddingRest <= 0 ) {
-    paddingOn = 1;                                               
+    paddingOn = 1;
     *paddingRest = *paddingRest + sampleRate;
   }
 
@@ -120,33 +120,33 @@ static Word16 framePadding(Word32 bitRate,
 
 Word16 QCOutNew(QC_OUT *hQC, Word16 nChannels, VO_MEM_OPERATOR *pMemOP)
 {
-  Word32 i;
-  Word16 *quantSpec;
-  Word16 *scf;
-  UWord16 *maxValueInSfb;	
-	
-  quantSpec = (Word16 *)mem_malloc(pMemOP, nChannels * FRAME_LEN_LONG * sizeof(Word16), 32, VO_INDEX_ENC_AAC);
-  if(NULL == quantSpec)
+  Word32 i;
+  Word16 *quantSpec;
+  Word16 *scf;
+  UWord16 *maxValueInSfb;
+
+  quantSpec = (Word16 *)mem_malloc(pMemOP, nChannels * FRAME_LEN_LONG * sizeof(Word16), 32, VO_INDEX_ENC_AAC);
+  if(NULL == quantSpec)
+	  return 1;
+  scf = (Word16 *)mem_malloc(pMemOP, nChannels * MAX_GROUPED_SFB * sizeof(Word16), 32, VO_INDEX_ENC_AAC);
+  if(NULL == scf)
+  {
 	  return 1;
-  scf = (Word16 *)mem_malloc(pMemOP, nChannels * MAX_GROUPED_SFB * sizeof(Word16), 32, VO_INDEX_ENC_AAC);     
-  if(NULL == scf)
-  {
-	  return 1;
   }
-  maxValueInSfb = (UWord16 *)mem_malloc(pMemOP, nChannels * MAX_GROUPED_SFB * sizeof(UWord16), 32, VO_INDEX_ENC_AAC);
-  if(NULL == maxValueInSfb)
-  {
-	  return 1;
-  }
-
+  maxValueInSfb = (UWord16 *)mem_malloc(pMemOP, nChannels * MAX_GROUPED_SFB * sizeof(UWord16), 32, VO_INDEX_ENC_AAC);
+  if(NULL == maxValueInSfb)
+  {
+	  return 1;
+  }
+
   for (i=0; i<nChannels; i++) {
     hQC->qcChannel[i].quantSpec = quantSpec + i*FRAME_LEN_LONG;
-    
+
     hQC->qcChannel[i].maxValueInSfb = maxValueInSfb + i*MAX_GROUPED_SFB;
-    
+
     hQC->qcChannel[i].scf = scf + i*MAX_GROUPED_SFB;
   }
- 
+
   return 0;
 }
 
@@ -160,26 +160,26 @@ Word16 QCOutNew(QC_OUT *hQC, Word16 nChannels, VO_MEM_OPERATOR *pMemOP)
 **********************************************************************************/
 void QCOutDelete(QC_OUT* hQC, VO_MEM_OPERATOR *pMemOP)
 {
-   Word32 i;
-   if(hQC)
-   {
-      if(hQC->qcChannel[0].quantSpec);
-		 mem_free(pMemOP, hQC->qcChannel[0].quantSpec, VO_INDEX_ENC_AAC);
-    
-      if(hQC->qcChannel[0].maxValueInSfb)
-		  mem_free(pMemOP, hQC->qcChannel[0].maxValueInSfb, VO_INDEX_ENC_AAC);
-    
-	  if(hQC->qcChannel[0].scf)
-		  mem_free(pMemOP, hQC->qcChannel[0].scf, VO_INDEX_ENC_AAC);
-
-	  for (i=0; i<MAX_CHANNELS; i++) {
-		  hQC->qcChannel[i].quantSpec = NULL;
-		  
-		  hQC->qcChannel[i].maxValueInSfb = NULL;
-		  
-		  hQC->qcChannel[i].scf = NULL;
-	  }
-   } 
+   Word32 i;
+   if(hQC)
+   {
+      if(hQC->qcChannel[0].quantSpec);
+		 mem_free(pMemOP, hQC->qcChannel[0].quantSpec, VO_INDEX_ENC_AAC);
+
+      if(hQC->qcChannel[0].maxValueInSfb)
+		  mem_free(pMemOP, hQC->qcChannel[0].maxValueInSfb, VO_INDEX_ENC_AAC);
+
+	  if(hQC->qcChannel[0].scf)
+		  mem_free(pMemOP, hQC->qcChannel[0].scf, VO_INDEX_ENC_AAC);
+
+	  for (i=0; i<MAX_CHANNELS; i++) {
+		  hQC->qcChannel[i].quantSpec = NULL;
+
+		  hQC->qcChannel[i].maxValueInSfb = NULL;
+
+		  hQC->qcChannel[i].scf = NULL;
+	  }
+   }
 }
 
 /*********************************************************************************
@@ -204,8 +204,8 @@ Word16 QCNew(QC_STATE *hQC, VO_MEM_OPERATOR *pMemOP)
 **********************************************************************************/
 void QCDelete(QC_STATE *hQC, VO_MEM_OPERATOR *pMemOP)
 {
- 
-  /* 
+
+  /*
      nothing to do
   */
   hQC=NULL;
@@ -221,15 +221,15 @@ void QCDelete(QC_STATE *hQC, VO_MEM_OPERATOR *pMemOP)
 Word16 QCInit(QC_STATE *hQC,
               struct QC_INIT *init)
 {
-  hQC->nChannels       = init->elInfo->nChannelsInEl;              
-  hQC->maxBitsTot      = init->maxBits;                            
+  hQC->nChannels       = init->elInfo->nChannelsInEl;
+  hQC->maxBitsTot      = init->maxBits;
   hQC->bitResTot       = sub(init->bitRes, init->averageBits);
-  hQC->averageBitsTot  = init->averageBits;                        
-  hQC->maxBitFac       = init->maxBitFac;                          
+  hQC->averageBitsTot  = init->averageBits;
+  hQC->maxBitFac       = init->maxBitFac;
 
-  hQC->padding.paddingRest = init->padding.paddingRest;            
+  hQC->padding.paddingRest = init->padding.paddingRest;
 
-  hQC->globStatBits    = 3;                          /* for ID_END */ 
+  hQC->globStatBits    = 3;                          /* for ID_END */
 
   /* channel elements init */
   InitElementBits(&hQC->elementBits,
@@ -248,13 +248,13 @@ Word16 QCInit(QC_STATE *hQC,
 
 
 /*********************************************************************************
-* 
+*
 * function name: QCMain
 * description:  quantization and coding the spectrum
 * returns:      0 if success
 *
 **********************************************************************************/
-Word16 QCMain(QC_STATE* hQC,              
+Word16 QCMain(QC_STATE* hQC,
               ELEMENT_BITS* elBits,
               ATS_ELEMENT* adjThrStateElement,
               PSY_OUT_CHANNEL  psyOutChannel[MAX_CHANNELS],  /* may be modified in-place */
@@ -262,34 +262,34 @@ Word16 QCMain(QC_STATE* hQC,
               QC_OUT_CHANNEL  qcOutChannel[MAX_CHANNELS],    /* out                      */
               QC_OUT_ELEMENT* qcOutElement,
               Word16 nChannels,
-			  Word16 ancillaryDataBytes)      
+			  Word16 ancillaryDataBytes)
 {
   Word16 maxChDynBits[MAX_CHANNELS];
-  Word16 chBitDistribution[MAX_CHANNELS];  
+  Word16 chBitDistribution[MAX_CHANNELS];
   Word32 ch;
-   
+
   if (elBits->bitResLevel < 0) {
     return -1;
   }
-   
+
   if (elBits->bitResLevel > elBits->maxBitResBits) {
     return -1;
   }
 
   qcOutElement->staticBitsUsed = countStaticBitdemand(psyOutChannel,
                                                       psyOutElement,
-                                                      nChannels, 
+                                                      nChannels,
 													  qcOutElement->adtsUsed);
 
-   
+
   if (ancillaryDataBytes) {
     qcOutElement->ancBitsUsed = 7 + (ancillaryDataBytes << 3);
-     
+
     if (ancillaryDataBytes >= 15)
       qcOutElement->ancBitsUsed = qcOutElement->ancBitsUsed + 8;
   }
   else {
-    qcOutElement->ancBitsUsed = 0; 
+    qcOutElement->ancBitsUsed = 0;
   }
 
   CalcFormFactor(hQC->logSfbFormFactor, hQC->sfbNRelevantLines, hQC->logSfbEnergy, psyOutChannel, nChannels);
@@ -301,7 +301,7 @@ Word16 QCMain(QC_STATE* hQC,
                    psyOutElement,
                    chBitDistribution,
                    hQC->logSfbEnergy,
-                   hQC->sfbNRelevantLines,                   
+                   hQC->sfbNRelevantLines,
                    qcOutElement,
 				   elBits,
 				   nChannels,
@@ -323,14 +323,14 @@ Word16 QCMain(QC_STATE* hQC,
     maxChDynBits[ch] = extract_l(chBitDistribution[ch] * maxDynBits / 1000);
   }
 
-  qcOutElement->dynBitsUsed = 0;                                         
+  qcOutElement->dynBitsUsed = 0;
   for (ch = 0; ch < nChannels; ch++) {
     Word32 chDynBits;
     Flag   constraintsFulfilled;
     Word32 iter;
-    iter = 0;                                                          
+    iter = 0;
     do {
-      constraintsFulfilled = 1;                                        
+      constraintsFulfilled = 1;
 
       QuantizeSpectrum(psyOutChannel[ch].sfbCnt,
                        psyOutChannel[ch].maxSfbPerGroup,
@@ -340,14 +340,14 @@ Word16 QCMain(QC_STATE* hQC,
                        qcOutChannel[ch].globalGain,
                        qcOutChannel[ch].scf,
                        qcOutChannel[ch].quantSpec);
-       
+
       if (calcMaxValueInSfb(psyOutChannel[ch].sfbCnt,
                             psyOutChannel[ch].maxSfbPerGroup,
                             psyOutChannel[ch].sfbPerGroup,
                             psyOutChannel[ch].sfbOffsets,
                             qcOutChannel[ch].quantSpec,
                             qcOutChannel[ch].maxValueInSfb) > MAX_QUANT) {
-        constraintsFulfilled = 0;                                        
+        constraintsFulfilled = 0;
       }
 
       chDynBits = dynBitCount(qcOutChannel[ch].quantSpec,
@@ -359,24 +359,24 @@ Word16 QCMain(QC_STATE* hQC,
                               psyOutChannel[ch].sfbPerGroup,
                               psyOutChannel[ch].sfbOffsets,
                               &qcOutChannel[ch].sectionData);
-       
+
       if (chDynBits >= maxChDynBits[ch]) {
-        constraintsFulfilled = 0;                                        
+        constraintsFulfilled = 0;
       }
-       
+
       if (!constraintsFulfilled) {
         qcOutChannel[ch].globalGain = qcOutChannel[ch].globalGain + 1;
       }
 
       iter = iter + 1;
-       
+
     } while(!constraintsFulfilled);
 
     qcOutElement->dynBitsUsed = qcOutElement->dynBitsUsed + chDynBits;
 
-    qcOutChannel[ch].mdctScale    = psyOutChannel[ch].mdctScale;         
-    qcOutChannel[ch].groupingMask = psyOutChannel[ch].groupingMask;      
-    qcOutChannel[ch].windowShape  = psyOutChannel[ch].windowShape;       
+    qcOutChannel[ch].mdctScale    = psyOutChannel[ch].mdctScale;
+    qcOutChannel[ch].groupingMask = psyOutChannel[ch].groupingMask;
+    qcOutChannel[ch].windowShape  = psyOutChannel[ch].windowShape;
   }
 
   /* save dynBitsUsed for correction of bits2pe relation */
@@ -411,13 +411,13 @@ static Word16 calcMaxValueInSfb(Word16 sfbCnt,
   Word16 sfbOffs, sfb;
   Word16 maxValueAll;
 
-  maxValueAll = 0;                                       
+  maxValueAll = 0;
 
   for(sfbOffs=0;sfbOffs<sfbCnt;sfbOffs+=sfbPerGroup) {
     for (sfb = 0; sfb < maxSfbPerGroup; sfb++) {
       Word16 line;
       Word16 maxThisSfb;
-      maxThisSfb = 0;                                    
+      maxThisSfb = 0;
 
       for (line = sfbOffset[sfbOffs+sfb]; line < sfbOffset[sfbOffs+sfb+1]; line++) {
         Word16 absVal;
@@ -425,7 +425,7 @@ static Word16 calcMaxValueInSfb(Word16 sfbCnt,
         maxThisSfb = max(maxThisSfb, absVal);
       }
 
-      maxValue[sfbOffs+sfb] = maxThisSfb;                
+      maxValue[sfbOffs+sfb] = maxThisSfb;
       maxValueAll = max(maxValueAll, maxThisSfb);
     }
   }
@@ -441,15 +441,15 @@ static Word16 calcMaxValueInSfb(Word16 sfbCnt,
 **********************************************************************************/
 void updateBitres(QC_STATE* qcKernel,
                   QC_OUT*   qcOut)
-                  
+
 {
   ELEMENT_BITS *elBits;
- 
-  qcKernel->bitResTot = 0;                               
+
+  qcKernel->bitResTot = 0;
 
   elBits = &qcKernel->elementBits;
 
-   
+
   if (elBits->averageBits > 0) {
     /* constant bitrate */
     Word16 bitsUsed;
@@ -460,8 +460,8 @@ void updateBitres(QC_STATE* qcKernel,
   }
   else {
     /* variable bitrate */
-    elBits->bitResLevel = elBits->maxBits;           
-    qcKernel->bitResTot = qcKernel->maxBitsTot;      
+    elBits->bitResLevel = elBits->maxBits;
+    qcKernel->bitResTot = qcKernel->maxBitsTot;
   }
 }
 
@@ -474,57 +474,57 @@ void updateBitres(QC_STATE* qcKernel,
 Word16 FinalizeBitConsumption(QC_STATE *qcKernel,
                               QC_OUT* qcOut)
 {
-  Word32 nFullFillElem;
-  Word32 totFillBits;
-  Word16 diffBits;  
+  Word32 nFullFillElem;
+  Word32 totFillBits;
+  Word16 diffBits;
   Word16 bitsUsed;
 
-  totFillBits = 0;                                       
+  totFillBits = 0;
 
-  qcOut->totStaticBitsUsed = qcKernel->globStatBits;     
+  qcOut->totStaticBitsUsed = qcKernel->globStatBits;
   qcOut->totStaticBitsUsed += qcOut->qcElement.staticBitsUsed;
   qcOut->totDynBitsUsed    = qcOut->qcElement.dynBitsUsed;
   qcOut->totAncBitsUsed    = qcOut->qcElement.ancBitsUsed;
   qcOut->totFillBits       = qcOut->qcElement.fillBits;
-   
+
   if (qcOut->qcElement.fillBits) {
     totFillBits += qcOut->qcElement.fillBits;
   }
 
-  nFullFillElem = (max((qcOut->totFillBits - 1), 0) / maxFillElemBits) * maxFillElemBits;
-  
+  nFullFillElem = (max((qcOut->totFillBits - 1), 0) / maxFillElemBits) * maxFillElemBits;
+
   qcOut->totFillBits = qcOut->totFillBits - nFullFillElem;
 
   /* check fill elements */
-   
+
   if (qcOut->totFillBits > 0) {
     /* minimum Fillelement contains 7 (TAG + byte cnt) bits */
     qcOut->totFillBits = max(7, qcOut->totFillBits);
     /* fill element size equals n*8 + 7 */
-    qcOut->totFillBits = qcOut->totFillBits + ((8 - ((qcOut->totFillBits - 7) & 0x0007)) & 0x0007);     
+    qcOut->totFillBits = qcOut->totFillBits + ((8 - ((qcOut->totFillBits - 7) & 0x0007)) & 0x0007);
   }
 
   qcOut->totFillBits = qcOut->totFillBits + nFullFillElem;
 
   /* now distribute extra fillbits and alignbits over channel elements */
   qcOut->alignBits = 7 - ((qcOut->totDynBitsUsed + qcOut->totStaticBitsUsed +
-                           qcOut->totAncBitsUsed + qcOut->totFillBits - 1) & 0x0007);             
+                           qcOut->totAncBitsUsed + qcOut->totFillBits - 1) & 0x0007);
+
 
-     
   if ( (qcOut->alignBits + qcOut->totFillBits - totFillBits == 8) &&
        (qcOut->totFillBits > 8))
     qcOut->totFillBits = qcOut->totFillBits - 8;
 
-   
+
   diffBits = qcOut->alignBits + qcOut->totFillBits - totFillBits;
-   
+
   if(diffBits>=0) {
     qcOut->qcElement.fillBits += diffBits;
   }
 
   bitsUsed = qcOut->totDynBitsUsed + qcOut->totStaticBitsUsed + qcOut->totAncBitsUsed;
   bitsUsed = bitsUsed + qcOut->totFillBits + qcOut->alignBits;
-   
+
   if (bitsUsed > qcKernel->maxBitsTot) {
     return -1;
   }
@@ -564,9 +564,9 @@ Word16 AdjustBitrate(QC_STATE        *hQC,
   codeBitsLast = hQC->averageBitsTot - hQC->globStatBits;
   codeBits     = frameLen - hQC->globStatBits;
 
-  /* calculate bits for every channel element */   
+  /* calculate bits for every channel element */
   if (codeBits != codeBitsLast) {
-    Word16 totalBits = 0;                                       
+    Word16 totalBits = 0;
 
     hQC->elementBits.averageBits = (hQC->elementBits.relativeBits * codeBits) >> 16; /* relativeBits was scaled down by 2 */
     totalBits += hQC->elementBits.averageBits;
@@ -574,7 +574,7 @@ Word16 AdjustBitrate(QC_STATE        *hQC,
     hQC->elementBits.averageBits = hQC->elementBits.averageBits + (codeBits - totalBits);
   }
 
-  hQC->averageBitsTot = frameLen;                        
+  hQC->averageBitsTot = frameLen;
 
   return 0;
 }
diff --git a/media/libstagefright/codecs/aacenc/src/quantize.c b/media/libstagefright/codecs/aacenc/src/quantize.c
index 205f167..54add2f 100644
--- a/media/libstagefright/codecs/aacenc/src/quantize.c
+++ b/media/libstagefright/codecs/aacenc/src/quantize.c
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		quantize.c
-
-	Content:	quantization functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		quantize.c
+
+	Content:	quantization functions
+
 *******************************************************************************/
 
-#include "typedef.h"
-#include "basic_op.h"
+#include "typedef.h"
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "quantize.h"
 #include "aac_rom.h"
@@ -34,32 +34,32 @@ static const Word32 XROUND = 0x33e425af; /* final rounding constant (-0.0946f+ 0
 
 /*****************************************************************************
 *
-* function name:pow34 
-* description: calculate $x^{\frac{3}{4}}, for 0.5 < x < 1.0$.  
+* function name:pow34
+* description: calculate $x^{\frac{3}{4}}, for 0.5 < x < 1.0$.
 *
 *****************************************************************************/
 __inline Word32 pow34(Word32 x)
 {
   /* index table using MANT_DIGITS bits, but mask out the sign bit and the MSB
-     which is always one */   
+     which is always one */
   return mTab_3_4[(x >> (INT_BITS-2-MANT_DIGITS)) & (MANT_SIZE-1)];
 }
 
 
 /*****************************************************************************
 *
-* function name:quantizeSingleLine 
-* description: quantizes spectrum  
-*              quaSpectrum = mdctSpectrum^3/4*2^(-(3/16)*gain)    
+* function name:quantizeSingleLine
+* description: quantizes spectrum
+*              quaSpectrum = mdctSpectrum^3/4*2^(-(3/16)*gain)
 *
 *****************************************************************************/
 static Word16 quantizeSingleLine(const Word16 gain, const Word32 absSpectrum)
 {
   Word32 e, minusFinalExp, finalShift;
   Word32 x;
-  Word16 qua = 0;                        
+  Word16 qua = 0;
+
 
-   
   if (absSpectrum) {
     e = norm_l(absSpectrum);
     x = pow34(absSpectrum << e);
@@ -71,20 +71,20 @@ static Word16 quantizeSingleLine(const Word16 gain, const Word32 absSpectrum)
 
     /* separate the exponent into a shift, and a multiply */
     finalShift = minusFinalExp >> 4;
-     
+
     if (finalShift < INT_BITS) {
       x = L_mpy_wx(x, pow2tominusNover16[minusFinalExp & 15]);
 
       x += XROUND >> (INT_BITS - finalShift);
 
-      /* shift and quantize */
-	  finalShift--;
-
-	  if(finalShift >= 0)
-		  x >>= finalShift;
-	  else
-		  x <<= (-finalShift);
-		
+      /* shift and quantize */
+	  finalShift--;
+
+	  if(finalShift >= 0)
+		  x >>= finalShift;
+	  else
+		  x <<= (-finalShift);
+
 	  qua = saturate(x);
     }
   }
@@ -94,10 +94,10 @@ static Word16 quantizeSingleLine(const Word16 gain, const Word32 absSpectrum)
 
 /*****************************************************************************
 *
-* function name:quantizeLines 
-* description: quantizes spectrum lines  
-*              quaSpectrum = mdctSpectrum^3/4*2^(-(3/16)*gain)    
-*  input: global gain, number of lines to process, spectral data         
+* function name:quantizeLines
+* description: quantizes spectrum lines
+*              quaSpectrum = mdctSpectrum^3/4*2^(-(3/16)*gain)
+*  input: global gain, number of lines to process, spectral data
 *  output: quantized spectrum
 *
 *****************************************************************************/
@@ -108,53 +108,100 @@ static void quantizeLines(const Word16 gain,
 {
   Word32 line;
   Word32 m = gain&3;
-  Word32 g = (gain >> 2) + 4;
-  Word32 mdctSpeL;
+  Word32 g = (gain >> 2) + 4;
+  Word32 mdctSpeL;
   Word16 *pquat;
-    /* gain&3 */
-
-  pquat = quantBorders[m];
-
-  g += 16;
-  
-  if(g >= 0)
-  {
+    /* gain&3 */
+
+  pquat = quantBorders[m];
+
+  g += 16;
+
+  if(g >= 0)
+  {
 	for (line=0; line<noOfLines; line++) {
 	  Word32 qua;
-	  qua = 0;                                                     
-    
-	  mdctSpeL = mdctSpectrum[line];
-	
+	  qua = 0;
+
+	  mdctSpeL = mdctSpectrum[line];
+
 	  if (mdctSpeL) {
 		Word32 sa;
 		Word32 saShft;
 
         sa = L_abs(mdctSpeL);
-        //saShft = L_shr(sa, 16 + g);
+        //saShft = L_shr(sa, 16 + g);
 	    saShft = sa >> g;
 
         if (saShft > pquat[0]) {
-         
+
+          if (saShft < pquat[1]) {
+
+            qua = mdctSpeL>0 ? 1 : -1;
+		  }
+          else {
+
+            if (saShft < pquat[2]) {
+
+              qua = mdctSpeL>0 ? 2 : -2;
+			}
+            else {
+
+              if (saShft < pquat[3]) {
+
+                qua = mdctSpeL>0 ? 3 : -3;
+			  }
+              else {
+                qua = quantizeSingleLine(gain, sa);
+                /* adjust the sign. Since 0 < qua < 1, this cannot overflow. */
+
+                if (mdctSpeL < 0)
+                  qua = -qua;
+			  }
+			}
+		  }
+		}
+	  }
+      quaSpectrum[line] = qua ;
+	}
+  }
+  else
+  {
+	for (line=0; line<noOfLines; line++) {
+	  Word32 qua;
+	  qua = 0;
+
+	  mdctSpeL = mdctSpectrum[line];
+
+	  if (mdctSpeL) {
+		Word32 sa;
+		Word32 saShft;
+
+        sa = L_abs(mdctSpeL);
+        saShft = sa << g;
+
+        if (saShft > pquat[0]) {
+
           if (saShft < pquat[1]) {
-             
+
             qua = mdctSpeL>0 ? 1 : -1;
 		  }
           else {
-           
+
             if (saShft < pquat[2]) {
-               
+
               qua = mdctSpeL>0 ? 2 : -2;
 			}
             else {
-             
+
               if (saShft < pquat[3]) {
-                 
+
                 qua = mdctSpeL>0 ? 3 : -3;
 			  }
               else {
                 qua = quantizeSingleLine(gain, sa);
                 /* adjust the sign. Since 0 < qua < 1, this cannot overflow. */
-               
+
                 if (mdctSpeL < 0)
                   qua = -qua;
 			  }
@@ -162,55 +209,8 @@ static void quantizeLines(const Word16 gain,
 		  }
 		}
 	  }
-      quaSpectrum[line] = qua ;                                    
-	}
-  }
-  else
-  {
-	for (line=0; line<noOfLines; line++) {
-	  Word32 qua;
-	  qua = 0;                                                     
-    
-	  mdctSpeL = mdctSpectrum[line];
-	
-	  if (mdctSpeL) {
-		Word32 sa;
-		Word32 saShft;
-
-        sa = L_abs(mdctSpeL);
-        saShft = sa << g;
-
-        if (saShft > pquat[0]) {
-         
-          if (saShft < pquat[1]) {
-             
-            qua = mdctSpeL>0 ? 1 : -1;
-		  }
-          else {
-           
-            if (saShft < pquat[2]) {
-               
-              qua = mdctSpeL>0 ? 2 : -2;
-			}
-            else {
-             
-              if (saShft < pquat[3]) {
-                 
-                qua = mdctSpeL>0 ? 3 : -3;
-			  }
-              else {
-                qua = quantizeSingleLine(gain, sa);
-                /* adjust the sign. Since 0 < qua < 1, this cannot overflow. */
-               
-                if (mdctSpeL < 0)
-                  qua = -qua;
-			  }
-			}
-		  }
-		}
-	  }
-      quaSpectrum[line] = qua ;                                    
-	}	  
+      quaSpectrum[line] = qua ;
+	}
   }
 
 }
@@ -218,10 +218,10 @@ static void quantizeLines(const Word16 gain,
 
 /*****************************************************************************
 *
-* function name:iquantizeLines 
+* function name:iquantizeLines
 * description: iquantizes spectrum lines without sign
-*              mdctSpectrum = iquaSpectrum^4/3 *2^(0.25*gain) 
-* input: global gain, number of lines to process,quantized spectrum        
+*              mdctSpectrum = iquaSpectrum^4/3 *2^(0.25*gain)
+* input: global gain, number of lines to process,quantized spectrum
 * output: spectral data
 *
 *****************************************************************************/
@@ -234,11 +234,11 @@ static void iquantizeLines(const Word16 gain,
   Word32   iquantizershift;
   Word32   line;
 
-  iquantizermod = gain & 3;                              
+  iquantizermod = gain & 3;
   iquantizershift = gain >> 2;
 
   for (line=0; line<noOfLines; line++) {
-     
+
     if( quantSpectrum[line] != 0 ) {
       Word32 accu;
       Word32 ex;
@@ -252,28 +252,28 @@ static void iquantizeLines(const Word16 gain,
       accu = accu << ex;
       specExp = INT_BITS-1 - ex;
 
-      tabIndex = (accu >> (INT_BITS-2-MANT_DIGITS)) & (~MANT_SIZE);        
+      tabIndex = (accu >> (INT_BITS-2-MANT_DIGITS)) & (~MANT_SIZE);
 
       /* calculate "mantissa" ^4/3 */
-      s = mTab_4_3[tabIndex];                                                    
+      s = mTab_4_3[tabIndex];
 
       /* get approperiate exponent multiplier for specExp^3/4 combined with scfMod */
-      t = specExpMantTableComb_enc[iquantizermod][specExp];                      
+      t = specExpMantTableComb_enc[iquantizermod][specExp];
 
       /* multiply "mantissa" ^4/3 with exponent multiplier */
       accu = MULHIGH(s, t);
 
       /* get approperiate exponent shifter */
-      specExp = specExpTableComb_enc[iquantizermod][specExp];                    
+      specExp = specExpTableComb_enc[iquantizermod][specExp];
 
-      specExp += iquantizershift + 1;
-	  if(specExp >= 0)
-		  mdctSpectrum[line] = accu << specExp;
-	  else
+      specExp += iquantizershift + 1;
+	  if(specExp >= 0)
+		  mdctSpectrum[line] = accu << specExp;
+	  else
 		  mdctSpectrum[line] = accu >> (-specExp);
     }
     else {
-      mdctSpectrum[line] = 0;                                                    
+      mdctSpectrum[line] = 0;
     }
   }
 }
@@ -301,7 +301,7 @@ void QuantizeSpectrum(Word16 sfbCnt,
   for(sfbOffs=0;sfbOffs<sfbCnt;sfbOffs+=sfbPerGroup) {
     Word32 sfbNext ;
     for (sfb = 0; sfb < maxSfbPerGroup; sfb = sfbNext) {
-      Word16 scalefactor = scalefactors[sfbOffs+sfb];                          
+      Word16 scalefactor = scalefactors[sfbOffs+sfb];
       /* coalesce sfbs with the same scalefactor */
       for (sfbNext = sfb+1;
            sfbNext < maxSfbPerGroup && scalefactor == scalefactors[sfbOffs+sfbNext];
@@ -318,7 +318,7 @@ void QuantizeSpectrum(Word16 sfbCnt,
 
 /*****************************************************************************
 *
-* function name:calcSfbDist 
+* function name:calcSfbDist
 * description: quantizes and requantizes lines to calculate distortion
 * input:  number of lines to be quantized, ...
 * output: distortion
@@ -331,114 +331,114 @@ Word32 calcSfbDist(const Word32 *spec,
   Word32 line;
   Word32 dist;
   Word32 m = gain&3;
-  Word32 g = (gain >> 2) + 4;
-  Word32 g2 = (g << 1) + 1;
-  Word16 *pquat, *repquat;
+  Word32 g = (gain >> 2) + 4;
+  Word32 g2 = (g << 1) + 1;
+  Word16 *pquat, *repquat;
     /* gain&3 */
-
-  pquat = quantBorders[m];
+
+  pquat = quantBorders[m];
   repquat = quantRecon[m];
-	
-  dist = 0;  
-  g += 16;
-  if(g2 < 0 && g >= 0)
-  {	  
-	  g2 = -g2;
-	  for(line=0; line<sfbWidth; line++) {		  
-		  if (spec[line]) {			  
+
+  dist = 0;
+  g += 16;
+  if(g2 < 0 && g >= 0)
+  {
+	  g2 = -g2;
+	  for(line=0; line<sfbWidth; line++) {
+		  if (spec[line]) {
 			  Word32 diff;
 			  Word32 distSingle;
 			  Word32 sa;
 			  Word32 saShft;
 			  sa = L_abs(spec[line]);
 			  //saShft = round16(L_shr(sa, g));
-			  //saShft = L_shr(sa, 16+g);
-			  saShft = sa >> g;
-
-			  if (saShft < pquat[0]) {
-				  distSingle = (saShft * saShft) >> g2;
-			  }
-			  else {
-				  
-				  if (saShft < pquat[1]) {
-					  diff = saShft - repquat[0];
-					  distSingle = (diff * diff) >> g2;
-				  }
-				  else {
-					  
-					  if (saShft < pquat[2]) {
-						  diff = saShft - repquat[1];
-						  distSingle = (diff * diff) >> g2;
-					  }
-					  else {
-						  
-						  if (saShft < pquat[3]) {
-							  diff = saShft - repquat[2];
-							  distSingle = (diff * diff) >> g2;
-						  }
-						  else {
-							  Word16 qua = quantizeSingleLine(gain, sa);
-							  Word32 iqval, diff32;
-							  /* now that we have quantized x, re-quantize it. */
-							  iquantizeLines(gain, 1, &qua, &iqval);
-							  diff32 = sa - iqval;
-							  distSingle = fixmul(diff32, diff32);
-						  }
-					  }
-				  }
-			  }
-			  
-			  dist = L_add(dist, distSingle);
+			  //saShft = L_shr(sa, 16+g);
+			  saShft = sa >> g;
+
+			  if (saShft < pquat[0]) {
+				  distSingle = (saShft * saShft) >> g2;
+			  }
+			  else {
+
+				  if (saShft < pquat[1]) {
+					  diff = saShft - repquat[0];
+					  distSingle = (diff * diff) >> g2;
+				  }
+				  else {
+
+					  if (saShft < pquat[2]) {
+						  diff = saShft - repquat[1];
+						  distSingle = (diff * diff) >> g2;
+					  }
+					  else {
+
+						  if (saShft < pquat[3]) {
+							  diff = saShft - repquat[2];
+							  distSingle = (diff * diff) >> g2;
+						  }
+						  else {
+							  Word16 qua = quantizeSingleLine(gain, sa);
+							  Word32 iqval, diff32;
+							  /* now that we have quantized x, re-quantize it. */
+							  iquantizeLines(gain, 1, &qua, &iqval);
+							  diff32 = sa - iqval;
+							  distSingle = fixmul(diff32, diff32);
+						  }
+					  }
+				  }
+			  }
+
+			  dist = L_add(dist, distSingle);
 		  }
-	  }
-  }
-  else
-  {
-	  for(line=0; line<sfbWidth; line++) {		  
-		  if (spec[line]) {			  
-			  Word32 diff;
-			  Word32 distSingle;
-			  Word32 sa;
-			  Word32 saShft;
-			  sa = L_abs(spec[line]);
-			  //saShft = round16(L_shr(sa, g));
-			  saShft = L_shr(sa, g);
-
-			  if (saShft < pquat[0]) {
-				  distSingle = L_shl((saShft * saShft), g2);
-			  }
-			  else {
-				  
-				  if (saShft < pquat[1]) {
-					  diff = saShft - repquat[0];
-					  distSingle = L_shl((diff * diff), g2);
-				  }
-				  else {
-					  
-					  if (saShft < pquat[2]) {
-						  diff = saShft - repquat[1];
-						  distSingle = L_shl((diff * diff), g2);
-					  }
-					  else {
-						  
-						  if (saShft < pquat[3]) {
-							  diff = saShft - repquat[2];
-							  distSingle = L_shl((diff * diff), g2);
-						  }
-						  else {
-							  Word16 qua = quantizeSingleLine(gain, sa);
-							  Word32 iqval, diff32;
-							  /* now that we have quantized x, re-quantize it. */
-							  iquantizeLines(gain, 1, &qua, &iqval);
-							  diff32 = sa - iqval;
-							  distSingle = fixmul(diff32, diff32);
-						  }
-					  }
-				  }
-			  }
-			  dist = L_add(dist, distSingle);
-		  }
-	  }	  
+	  }
+  }
+  else
+  {
+	  for(line=0; line<sfbWidth; line++) {
+		  if (spec[line]) {
+			  Word32 diff;
+			  Word32 distSingle;
+			  Word32 sa;
+			  Word32 saShft;
+			  sa = L_abs(spec[line]);
+			  //saShft = round16(L_shr(sa, g));
+			  saShft = L_shr(sa, g);
+
+			  if (saShft < pquat[0]) {
+				  distSingle = L_shl((saShft * saShft), g2);
+			  }
+			  else {
+
+				  if (saShft < pquat[1]) {
+					  diff = saShft - repquat[0];
+					  distSingle = L_shl((diff * diff), g2);
+				  }
+				  else {
+
+					  if (saShft < pquat[2]) {
+						  diff = saShft - repquat[1];
+						  distSingle = L_shl((diff * diff), g2);
+					  }
+					  else {
+
+						  if (saShft < pquat[3]) {
+							  diff = saShft - repquat[2];
+							  distSingle = L_shl((diff * diff), g2);
+						  }
+						  else {
+							  Word16 qua = quantizeSingleLine(gain, sa);
+							  Word32 iqval, diff32;
+							  /* now that we have quantized x, re-quantize it. */
+							  iquantizeLines(gain, 1, &qua, &iqval);
+							  diff32 = sa - iqval;
+							  distSingle = fixmul(diff32, diff32);
+						  }
+					  }
+				  }
+			  }
+			  dist = L_add(dist, distSingle);
+		  }
+	  }
   }
 
   return dist;
diff --git a/media/libstagefright/codecs/aacenc/src/sf_estim.c b/media/libstagefright/codecs/aacenc/src/sf_estim.c
index d34b365..fe40137 100644
--- a/media/libstagefright/codecs/aacenc/src/sf_estim.c
+++ b/media/libstagefright/codecs/aacenc/src/sf_estim.c
@@ -1,26 +1,26 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		sf_estim.c
-
-	Content:	Scale factor estimation functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		sf_estim.c
+
+	Content:	Scale factor estimation functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
+#include "basic_op.h"
 #include "oper_32b.h"
 #include "sf_estim.h"
 #include "quantize.h"
@@ -30,56 +30,56 @@
 static const Word16 MAX_SCF_DELTA = 60;
 
 /*!
-constants reference in comments 
+constants reference in comments
 
  C0 = 6.75f;
- C1 = -69.33295f;   -16/3*log(MAX_QUANT+0.5-logCon)/log(2) 
+ C1 = -69.33295f;   -16/3*log(MAX_QUANT+0.5-logCon)/log(2)
  C2 = 4.0f;
  C3 = 2.66666666f;
- 
-  PE_C1 = 3.0f;        log(8.0)/log(2) 
-  PE_C2 = 1.3219281f;  log(2.5)/log(2) 
-  PE_C3 = 0.5593573f;  1-C2/C1 
-  
+
+  PE_C1 = 3.0f;        log(8.0)/log(2)
+  PE_C2 = 1.3219281f;  log(2.5)/log(2)
+  PE_C3 = 0.5593573f;  1-C2/C1
+
 */
 
 #define FF_SQRT_BITS                    7
 #define FF_SQRT_TABLE_SIZE              (1<<FF_SQRT_BITS - 1<<(FF_SQRT_BITS-2))
-#define COEF08_31		0x66666666		/* 0.8*(1 << 31) */
-#define PE_C1_8			24				/* PE_C1*8 */
-#define PE_C2_16		21				/* PE_C2*8/PE_C3 */
-#define PE_SCALE		0x059a			/* 0.7 * (1 << (15 - 1 - 3))*/
-
-#define SCALE_ESTIMATE_COEF	0x5555		/* (8.8585/(4*log2(10))) * (1 << 15)*/
+#define COEF08_31		0x66666666		/* 0.8*(1 << 31) */
+#define PE_C1_8			24				/* PE_C1*8 */
+#define PE_C2_16		21				/* PE_C2*8/PE_C3 */
+#define PE_SCALE		0x059a			/* 0.7 * (1 << (15 - 1 - 3))*/
+
+#define SCALE_ESTIMATE_COEF	0x5555		/* (8.8585/(4*log2(10))) * (1 << 15)*/
 
 /*********************************************************************************
 *
 * function name: formfac_sqrt
-* description:  calculates sqrt(x)/256 
+* description:  calculates sqrt(x)/256
 *
 **********************************************************************************/
 __inline Word32 formfac_sqrt(Word32 x)
 {
 	Word32 y;
 	Word32 preshift, postshift;
-	
-	
+
+
 	if (x==0) return 0;
 	preshift  = norm_l(x) - (INT_BITS-1-FF_SQRT_BITS);
 	postshift = preshift >> 1;
 	preshift  = postshift << 1;
 	postshift = postshift + 8;	  /* sqrt/256 */
-	if(preshift >= 0)
-		y = x << preshift;        /* now 1/4 <= y < 1 */
-	else
-		y = x >> (-preshift);
-	y = formfac_sqrttable[y-32];
-	
-	if(postshift >= 0)
-		y = y >> postshift;
-	else
-		y = y << (-postshift);
-	
+	if(preshift >= 0)
+		y = x << preshift;        /* now 1/4 <= y < 1 */
+	else
+		y = x >> (-preshift);
+	y = formfac_sqrttable[y-32];
+
+	if(postshift >= 0)
+		y = y >> postshift;
+	else
+		y = y << (-postshift);
+
 	return y;
 }
 
@@ -97,25 +97,25 @@ CalcFormFactorChannel(Word16 *logSfbFormFactor,
                       Word16 *logSfbEnergy,
                       PSY_OUT_CHANNEL *psyOutChan)
 {
-	Word32 sfbw, sfbw1;
+	Word32 sfbw, sfbw1;
 	Word32 i, j;
 	Word32 sfbOffs, sfb, shift;
-	
-	sfbw = sfbw1 = 0;
+
+	sfbw = sfbw1 = 0;
 	for (sfbOffs=0; sfbOffs<psyOutChan->sfbCnt; sfbOffs+=psyOutChan->sfbPerGroup){
 		for (sfb=0; sfb<psyOutChan->maxSfbPerGroup; sfb++) {
-			i = sfbOffs+sfb;      
-			
+			i = sfbOffs+sfb;
+
 			if (psyOutChan->sfbEnergy[i] > psyOutChan->sfbThreshold[i]) {
-				Word32 accu, avgFormFactor,iSfbWidth;
+				Word32 accu, avgFormFactor,iSfbWidth;
 				Word32 *mdctSpec;
-				sfbw = psyOutChan->sfbOffsets[i+1] - psyOutChan->sfbOffsets[i];
-				iSfbWidth = invSBF[(sfbw >> 2) - 1];
+				sfbw = psyOutChan->sfbOffsets[i+1] - psyOutChan->sfbOffsets[i];
+				iSfbWidth = invSBF[(sfbw >> 2) - 1];
 				mdctSpec = psyOutChan->mdctSpectrum + psyOutChan->sfbOffsets[i];
-				accu = 0;                                                                       
+				accu = 0;
 				/* calc sum of sqrt(spec) */
-				for (j=sfbw; j; j--) {
-					accu += formfac_sqrt(L_abs(*mdctSpec)); mdctSpec++;
+				for (j=sfbw; j; j--) {
+					accu += formfac_sqrt(L_abs(*mdctSpec)); mdctSpec++;
 				}
 				logSfbFormFactor[i] = iLog4(accu);
 				logSfbEnergy[i] = iLog4(psyOutChan->sfbEnergy[i]);
@@ -129,7 +129,7 @@ CalcFormFactorChannel(Word16 *logSfbFormFactor,
 			}
 			else {
 				/* set number of lines to zero */
-				sfbNRelevantLines[i] = 0;                                                       
+				sfbNRelevantLines[i] = 0;
 			}
 		}
 	}
@@ -141,68 +141,68 @@ CalcFormFactorChannel(Word16 *logSfbFormFactor,
 * description:  find better scalefactor with analysis by synthesis
 *
 **********************************************************************************/
-static Word16 improveScf(Word32 *spec, 
-                         Word16  sfbWidth, 
-                         Word32  thresh, 
+static Word16 improveScf(Word32 *spec,
+                         Word16  sfbWidth,
+                         Word32  thresh,
                          Word16  scf,
                          Word16  minScf,
-                         Word32 *dist, 
+                         Word32 *dist,
                          Word16 *minScfCalculated)
 {
 	Word32 cnt;
 	Word32 sfbDist;
 	Word32 scfBest;
 	Word32 thresh125 = L_add(thresh, (thresh >> 2));
-	
-	scfBest = scf;                                                       
-	
+
+	scfBest = scf;
+
 	/* calc real distortion */
 	sfbDist = calcSfbDist(spec, sfbWidth, scf);
-	*minScfCalculated = scf;     
-	if(!sfbDist)
+	*minScfCalculated = scf;
+	if(!sfbDist)
 	  return scfBest;
-	
+
 	if (sfbDist > thresh125) {
 		Word32 scfEstimated;
 		Word32 sfbDistBest;
-		scfEstimated = scf;                                               
-		sfbDistBest = sfbDist;                                            
-		
-		cnt = 0;                                                          
+		scfEstimated = scf;
+		sfbDistBest = sfbDist;
+
+		cnt = 0;
 		while (sfbDist > thresh125 && (cnt < 3)) {
-			
+
 			scf = scf + 1;
 			sfbDist = calcSfbDist(spec, sfbWidth, scf);
-			
+
 			if (sfbDist < sfbDistBest) {
-				scfBest = scf;                                              
-				sfbDistBest = sfbDist;                                      
+				scfBest = scf;
+				sfbDistBest = sfbDist;
 			}
 			cnt = cnt + 1;
 		}
-		cnt = 0;                                                          
-		scf = scfEstimated;                                               
-		sfbDist = sfbDistBest;                                            
+		cnt = 0;
+		scf = scfEstimated;
+		sfbDist = sfbDistBest;
 		while ((sfbDist > thresh125) && (cnt < 1) && (scf > minScf)) {
-			
+
 			scf = scf - 1;
 			sfbDist = calcSfbDist(spec, sfbWidth, scf);
-			
+
 			if (sfbDist < sfbDistBest) {
-				scfBest = scf;                                              
-				sfbDistBest = sfbDist;                                      
+				scfBest = scf;
+				sfbDistBest = sfbDist;
 			}
-			*minScfCalculated = scf;                                       
+			*minScfCalculated = scf;
 			cnt = cnt + 1;
-		}
-		*dist = sfbDistBest;                                              
+		}
+		*dist = sfbDistBest;
 	}
 	else {
-		Word32 sfbDistBest; 
+		Word32 sfbDistBest;
 		Word32 sfbDistAllowed;
 		Word32 thresh08 = fixmul(COEF08_31, thresh);
-		sfbDistBest = sfbDist;                                            
-		
+		sfbDistBest = sfbDist;
+
 		if (sfbDist < thresh08)
 			sfbDistAllowed = sfbDist;
 		else
@@ -210,16 +210,16 @@ static Word16 improveScf(Word32 *spec,
 		for (cnt=0; cnt<3; cnt++) {
 			scf = scf + 1;
 			sfbDist = calcSfbDist(spec, sfbWidth, scf);
-			
+
 			if (fixmul(COEF08_31,sfbDist) < sfbDistAllowed) {
 				*minScfCalculated = scfBest + 1;
-				scfBest = scf;                                              
-				sfbDistBest = sfbDist;                                      
+				scfBest = scf;
+				sfbDistBest = sfbDist;
 			}
 		}
-		*dist = sfbDistBest;                                              
+		*dist = sfbDistBest;
 	}
-	
+
 	/* return best scalefactor */
 	return scfBest;
 }
@@ -233,10 +233,10 @@ static Word16 improveScf(Word32 *spec,
 static Word16 countSingleScfBits(Word16 scf, Word16 scfLeft, Word16 scfRight)
 {
 	Word16 scfBits;
-	
+
 	scfBits = bitCountScalefactorDelta(scfLeft - scf) +
 		bitCountScalefactorDelta(scf - scfRight);
-	
+
 	return scfBits;
 }
 
@@ -245,7 +245,7 @@ static Word16 countSingleScfBits(Word16 scf, Word16 scfLeft, Word16 scfRight)
 * function name: calcSingleSpecPe
 * description:  ldRatio = log2(en(n)) - 0,375*scfGain(n)
 *				nbits = 0.7*nLines*ldRation for ldRation >= c1
-*				nbits = 0.7*nLines*(c2 + c3*ldRatio) for ldRation < c1 
+*				nbits = 0.7*nLines*(c2 + c3*ldRatio) for ldRation < c1
 *
 **********************************************************************************/
 static Word16 calcSingleSpecPe(Word16 scf, Word16 sfbConstPePart, Word16 nLines)
@@ -253,18 +253,18 @@ static Word16 calcSingleSpecPe(Word16 scf, Word16 sfbConstPePart, Word16 nLines)
 	Word32 specPe;
 	Word32 ldRatio;
 	Word32 scf3;
-	
+
 	ldRatio = sfbConstPePart << 3; /*  (sfbConstPePart -0.375*scf)*8 */
 	scf3 = scf + scf + scf;
 	ldRatio = ldRatio - scf3;
-    
+
 	if (ldRatio < PE_C1_8) {
-		/* 21 : 2*8*PE_C2, 2*PE_C3 ~ 1*/ 
+		/* 21 : 2*8*PE_C2, 2*PE_C3 ~ 1*/
 		ldRatio = (ldRatio + PE_C2_16) >> 1;
 	}
 	specPe = nLines * ldRatio;
 	specPe = (specPe * PE_SCALE) >> 14;
-	
+
 	return saturate(specPe);
 }
 
@@ -275,53 +275,53 @@ static Word16 calcSingleSpecPe(Word16 scf, Word16 sfbConstPePart, Word16 nLines)
 * description:  count different scf bits used
 *
 **********************************************************************************/
-static Word16 countScfBitsDiff(Word16 *scfOld, Word16 *scfNew, 
+static Word16 countScfBitsDiff(Word16 *scfOld, Word16 *scfNew,
                                Word16 sfbCnt, Word16 startSfb, Word16 stopSfb)
 {
 	Word32 scfBitsDiff;
 	Word32 sfb, sfbLast;
 	Word32 sfbPrev, sfbNext;
-	
-	scfBitsDiff = 0;                                                      
-	sfb = 0;                                                              
-	
+
+	scfBitsDiff = 0;
+	sfb = 0;
+
 	/* search for first relevant sfb */
-	sfbLast = startSfb;                                                   
+	sfbLast = startSfb;
 	while (sfbLast < stopSfb && scfOld[sfbLast] == VOAAC_SHRT_MIN) {
-		
+
 		sfbLast = sfbLast + 1;
 	}
 	/* search for previous relevant sfb and count diff */
 	sfbPrev = startSfb - 1;
 	while ((sfbPrev>=0) && scfOld[sfbPrev] == VOAAC_SHRT_MIN) {
-		
+
 		sfbPrev = sfbPrev - 1;
 	}
-	
+
 	if (sfbPrev>=0) {
 		scfBitsDiff += bitCountScalefactorDelta(scfNew[sfbPrev] - scfNew[sfbLast]) -
 			bitCountScalefactorDelta(scfOld[sfbPrev] - scfOld[sfbLast]);
 	}
 	/* now loop through all sfbs and count diffs of relevant sfbs */
 	for (sfb=sfbLast+1; sfb<stopSfb; sfb++) {
-		
+
 		if (scfOld[sfb] != VOAAC_SHRT_MIN) {
 			scfBitsDiff += bitCountScalefactorDelta(scfNew[sfbLast] - scfNew[sfb]) -
 				bitCountScalefactorDelta(scfOld[sfbLast] - scfOld[sfb]);
-			sfbLast = sfb;                                                    
+			sfbLast = sfb;
 		}
 	}
 	/* search for next relevant sfb and count diff */
-	sfbNext = stopSfb;                                                    
+	sfbNext = stopSfb;
 	while (sfbNext < sfbCnt && scfOld[sfbNext] == VOAAC_SHRT_MIN) {
-		
+
 		sfbNext = sfbNext + 1;
 	}
-	
+
 	if (sfbNext < sfbCnt)
 		scfBitsDiff += bitCountScalefactorDelta(scfNew[sfbLast] - scfNew[sfbNext]) -
 		bitCountScalefactorDelta(scfOld[sfbLast] - scfOld[sfbNext]);
-	
+
 	return saturate(scfBitsDiff);
 }
 
@@ -331,52 +331,52 @@ static Word16 calcSpecPeDiff(Word16 *scfOld,
                              Word16 *logSfbEnergy,
                              Word16 *logSfbFormFactor,
                              Word16 *sfbNRelevantLines,
-                             Word16 startSfb, 
+                             Word16 startSfb,
                              Word16 stopSfb)
 {
 	Word32 specPeDiff;
 	Word32 sfb;
-	
-	specPeDiff = 0;                                                       
-	
+
+	specPeDiff = 0;
+
 	/* loop through all sfbs and count pe difference */
 	for (sfb=startSfb; sfb<stopSfb; sfb++) {
-		
-		
+
+
 		if (scfOld[sfb] != VOAAC_SHRT_MIN) {
 			Word32 ldRatioOld, ldRatioNew;
 			Word32 scf3;
-			
-			
+
+
 			if (sfbConstPePart[sfb] == MIN_16) {
 				sfbConstPePart[sfb] = ((logSfbEnergy[sfb] -
 					logSfbFormFactor[sfb]) + 11-8*4+3) >> 2;
 			}
-			
-			
+
+
 			ldRatioOld = sfbConstPePart[sfb] << 3;
 			scf3 = scfOld[sfb] + scfOld[sfb] + scfOld[sfb];
 			ldRatioOld = ldRatioOld - scf3;
 			ldRatioNew = sfbConstPePart[sfb] << 3;
 			scf3 = scfNew[sfb] + scfNew[sfb] + scfNew[sfb];
 			ldRatioNew = ldRatioNew - scf3;
-			
+
 			if (ldRatioOld < PE_C1_8) {
 				/* 21 : 2*8*PE_C2, 2*PE_C3 ~ 1*/
 				ldRatioOld = (ldRatioOld + PE_C2_16) >> 1;
 			}
-			
+
 			if (ldRatioNew < PE_C1_8) {
 				/* 21 : 2*8*PE_C2, 2*PE_C3 ~ 1*/
 				ldRatioNew = (ldRatioNew + PE_C2_16) >> 1;
 			}
-			
+
 			specPeDiff +=  sfbNRelevantLines[sfb] * (ldRatioNew - ldRatioOld);
 		}
 	}
-	
+
 	specPeDiff = (specPeDiff * PE_SCALE) >> 14;
-	
+
 	return saturate(specPeDiff);
 }
 
@@ -390,9 +390,9 @@ static Word16 calcSpecPeDiff(Word16 *scfOld,
 *
 **********************************************************************************/
 static void assimilateSingleScf(PSY_OUT_CHANNEL *psyOutChan,
-                                Word16 *scf, 
+                                Word16 *scf,
                                 Word16 *minScf,
-                                Word32 *sfbDist, 
+                                Word32 *sfbDist,
                                 Word16 *sfbConstPePart,
                                 Word16 *logSfbEnergy,
                                 Word16 *logSfbFormFactor,
@@ -411,94 +411,94 @@ static void assimilateSingleScf(PSY_OUT_CHANNEL *psyOutChan,
 	Word16 *prevScfNext = psyOutChan->prevScfNext;
 	Word16 *deltaPeLast = psyOutChan->deltaPeLast;
 	Flag   updateMinScfCalculated;
-	
-	success = 0;                                                                  
-	deltaPe = 0;                                                                  
-	
+
+	success = 0;
+	deltaPe = 0;
+
 	for(j=0;j<psyOutChan->sfbCnt;j++){
-		prevScfLast[j] = MAX_16;                                                    
-		prevScfNext[j] = MAX_16;                                                    
-		deltaPeLast[j] = MAX_16;                                                    
-	}
-	
-	sfbLast = -1;                                                                 
-	sfbAct = -1;                                                                  
-	sfbNext = -1;                                                                 
+		prevScfLast[j] = MAX_16;
+		prevScfNext[j] = MAX_16;
+		deltaPeLast[j] = MAX_16;
+	}
+
+	sfbLast = -1;
+	sfbAct = -1;
+	sfbNext = -1;
 	scfLast = 0;
 	scfNext = 0;
-	scfMin = MAX_16;                                                              
+	scfMin = MAX_16;
 	do {
 		/* search for new relevant sfb */
 		sfbNext = sfbNext + 1;
 		while (sfbNext < psyOutChan->sfbCnt && scf[sfbNext] == MIN_16) {
-			
+
 			sfbNext = sfbNext + 1;
 		}
-		
+
 		if ((sfbLast>=0) && (sfbAct>=0) && sfbNext < psyOutChan->sfbCnt) {
 			/* relevant scfs to the left and to the right */
-			scfAct  = scf[sfbAct];                                                    
+			scfAct  = scf[sfbAct];
 			scfLast = scf + sfbLast;
 			scfNext = scf + sfbNext;
 			scfMin  = min(*scfLast, *scfNext);
 		}
 		else {
-			
+
 			if (sfbLast == -1 && (sfbAct>=0) && sfbNext < psyOutChan->sfbCnt) {
 				/* first relevant scf */
-				scfAct  = scf[sfbAct];                                                  
+				scfAct  = scf[sfbAct];
 				scfLast = &scfAct;
 				scfNext = scf + sfbNext;
-				scfMin  = *scfNext;                                                     
+				scfMin  = *scfNext;
 			}
 			else {
-				
+
 				if ((sfbLast>=0) && (sfbAct>=0) && sfbNext == psyOutChan->sfbCnt) {
 					/* last relevant scf */
-					scfAct  = scf[sfbAct];                                                
+					scfAct  = scf[sfbAct];
 					scfLast = scf + sfbLast;
 					scfNext = &scfAct;
-					scfMin  = *scfLast;                                                   
+					scfMin  = *scfLast;
 				}
 			}
 		}
-		
+
 		if (sfbAct>=0)
 			scfMin = max(scfMin, minScf[sfbAct]);
-		
-		if ((sfbAct >= 0) && 
-			(sfbLast>=0 || sfbNext < psyOutChan->sfbCnt) && 
-			scfAct > scfMin && 
-			(*scfLast != prevScfLast[sfbAct] || 
-			*scfNext != prevScfNext[sfbAct] || 
+
+		if ((sfbAct >= 0) &&
+			(sfbLast>=0 || sfbNext < psyOutChan->sfbCnt) &&
+			scfAct > scfMin &&
+			(*scfLast != prevScfLast[sfbAct] ||
+			*scfNext != prevScfNext[sfbAct] ||
 			deltaPe < deltaPeLast[sfbAct])) {
-			success = 0;                                                              
-			
-			/* estimate required bits for actual scf */			
+			success = 0;
+
+			/* estimate required bits for actual scf */
 			if (sfbConstPePart[sfbAct] == MIN_16) {
 				sfbConstPePart[sfbAct] = logSfbEnergy[sfbAct] -
 					logSfbFormFactor[sfbAct] + 11-8*4; /* 4*log2(6.75) - 32 */
-				
+
 				if (sfbConstPePart[sfbAct] < 0)
 					sfbConstPePart[sfbAct] = sfbConstPePart[sfbAct] + 3;
 				sfbConstPePart[sfbAct] = sfbConstPePart[sfbAct] >> 2;
 			}
-			
+
 			sfbPeOld = calcSingleSpecPe(scfAct, sfbConstPePart[sfbAct], sfbNRelevantLines[sfbAct]) +
 				countSingleScfBits(scfAct, *scfLast, *scfNext);
-			deltaPeNew = deltaPe;                                                     
-			updateMinScfCalculated = 1;                                               
+			deltaPeNew = deltaPe;
+			updateMinScfCalculated = 1;
 			do {
 				scfAct = scfAct - 1;
 				/* check only if the same check was not done before */
-				
+
 				if (scfAct < minScfCalculated[sfbAct]) {
 					sfbPeNew = calcSingleSpecPe(scfAct, sfbConstPePart[sfbAct], sfbNRelevantLines[sfbAct]) +
 						countSingleScfBits(scfAct, *scfLast, *scfNext);
-					/* use new scf if no increase in pe and 
+					/* use new scf if no increase in pe and
 					quantization error is smaller */
 					deltaPeTmp = deltaPe + sfbPeNew - sfbPeOld;
-					
+
 					if (deltaPeTmp < 10) {
 						sfbDistNew = calcSfbDist(psyOutChan->mdctSpectrum+
 							psyOutChan->sfbOffsets[sfbAct],
@@ -506,46 +506,46 @@ static void assimilateSingleScf(PSY_OUT_CHANNEL *psyOutChan,
 							scfAct);
 						if (sfbDistNew < sfbDist[sfbAct]) {
 							/* success, replace scf by new one */
-							scf[sfbAct] = scfAct;                                     
-							sfbDist[sfbAct] = sfbDistNew;                             
-							deltaPeNew = deltaPeTmp;                                  
-							success = 1;                                              
+							scf[sfbAct] = scfAct;
+							sfbDist[sfbAct] = sfbDistNew;
+							deltaPeNew = deltaPeTmp;
+							success = 1;
 						}
 						/* mark as already checked */
-						
+
 						if (updateMinScfCalculated) {
-							minScfCalculated[sfbAct] = scfAct;                        
+							minScfCalculated[sfbAct] = scfAct;
 						}
 					}
 					else {
-						updateMinScfCalculated = 0;                                 
+						updateMinScfCalculated = 0;
 					}
 				}
-				
+
 			} while (scfAct > scfMin);
-			deltaPe = deltaPeNew;                                             
+			deltaPe = deltaPeNew;
 			/* save parameters to avoid multiple computations of the same sfb */
-			prevScfLast[sfbAct] = *scfLast;                                   
-			prevScfNext[sfbAct] = *scfNext;                                   
-			deltaPeLast[sfbAct] = deltaPe;                                    
+			prevScfLast[sfbAct] = *scfLast;
+			prevScfNext[sfbAct] = *scfNext;
+			deltaPeLast[sfbAct] = deltaPe;
 		}
-		
+
 		if (success && restartOnSuccess) {
 			/* start again at first sfb */
-			sfbLast = -1;                                                     
-			sfbAct  = -1;                                                     
-			sfbNext = -1;                                                     
+			sfbLast = -1;
+			sfbAct  = -1;
+			sfbNext = -1;
 			scfLast = 0;
 			scfNext = 0;
-			scfMin  = MAX_16;                                                 
-			success = 0;                                                      
+			scfMin  = MAX_16;
+			success = 0;
 		}
 		else {
 			/* shift sfbs for next band */
-			sfbLast = sfbAct;                                                 
-			sfbAct  = sfbNext;                                                
+			sfbLast = sfbAct;
+			sfbAct  = sfbNext;
 		}
-		
+
   } while (sfbNext < psyOutChan->sfbCnt);
 }
 
@@ -557,9 +557,9 @@ static void assimilateSingleScf(PSY_OUT_CHANNEL *psyOutChan,
 *
 **********************************************************************************/
 static void assimilateMultipleScf(PSY_OUT_CHANNEL *psyOutChan,
-                                  Word16 *scf, 
+                                  Word16 *scf,
                                   Word16 *minScf,
-                                  Word32 *sfbDist, 
+                                  Word32 *sfbDist,
                                   Word16 *sfbConstPePart,
                                   Word16 *logSfbEnergy,
                                   Word16 *logSfbFormFactor,
@@ -574,95 +574,95 @@ static void assimilateMultipleScf(PSY_OUT_CHANNEL *psyOutChan,
 	Word32 *sfbDistNew = psyOutChan->sfbDistNew;
 	Word16 *scfTmp = psyOutChan->prevScfLast;
 
-	deltaPe = 0;                                                          
-	sfbCnt = psyOutChan->sfbCnt;                                          
-	
+	deltaPe = 0;
+	sfbCnt = psyOutChan->sfbCnt;
+
 	/* calc min and max scalfactors */
-	scfMin = MAX_16;                                                      
-	scfMax = MIN_16;                                                      
+	scfMin = MAX_16;
+	scfMax = MIN_16;
 	for (sfb=0; sfb<sfbCnt; sfb++) {
-		
+
 		if (scf[sfb] != MIN_16) {
 			scfMin = min(scfMin, scf[sfb]);
 			scfMax = max(scfMax, scf[sfb]);
 		}
 	}
-	
+
 	if (scfMax !=  MIN_16) {
-		
-		scfAct = scfMax;                                             
-		
+
+		scfAct = scfMax;
+
 		do {
 			scfAct = scfAct - 1;
 			for (sfb=0; sfb<sfbCnt; sfb++) {
-				scfTmp[sfb] = scf[sfb];                                         
+				scfTmp[sfb] = scf[sfb];
 			}
-			stopSfb = 0;                                                      
+			stopSfb = 0;
 			do {
-				sfb = stopSfb;                                                  
-				
+				sfb = stopSfb;
+
 				while (sfb < sfbCnt && (scf[sfb] == MIN_16 || scf[sfb] <= scfAct)) {
 					sfb = sfb + 1;
 				}
-				startSfb = sfb;                                                 
+				startSfb = sfb;
 				sfb = sfb + 1;
-				
+
 				while (sfb < sfbCnt && (scf[sfb] == MIN_16 || scf[sfb] > scfAct)) {
 					sfb = sfb + 1;
 				}
-				stopSfb = sfb;                                                  
-				
-				possibleRegionFound = 0;                                        
-				
+				stopSfb = sfb;
+
+				possibleRegionFound = 0;
+
 				if (startSfb < sfbCnt) {
-					possibleRegionFound = 1;                                      
+					possibleRegionFound = 1;
 					for (sfb=startSfb; sfb<stopSfb; sfb++) {
-						
+
 						if (scf[sfb]!=MIN_16) {
-							
+
 							if (scfAct < minScf[sfb]) {
-								possibleRegionFound = 0;                                
+								possibleRegionFound = 0;
 								break;
 							}
 						}
 					}
 				}
-				
-				
+
+
 				if (possibleRegionFound) { /* region found */
-					
+
 					/* replace scfs in region by scfAct */
 					for (sfb=startSfb; sfb<stopSfb; sfb++) {
-						
+
 						if (scfTmp[sfb]!=MIN_16)
-							scfTmp[sfb] = scfAct;                                     
+							scfTmp[sfb] = scfAct;
 					}
-					
+
 					/* estimate change in bit demand for new scfs */
 					deltaScfBits = countScfBitsDiff(scf,scfTmp,sfbCnt,startSfb,stopSfb);
 					deltaSpecPe = calcSpecPeDiff(scf, scfTmp, sfbConstPePart,
-						logSfbEnergy, logSfbFormFactor, sfbNRelevantLines, 
+						logSfbEnergy, logSfbFormFactor, sfbNRelevantLines,
 						startSfb, stopSfb);
 					deltaPeNew = deltaPe + deltaScfBits + deltaSpecPe;
-					
-					
+
+
 					if (deltaPeNew < 10) {
 						Word32 distOldSum, distNewSum;
-						
+
 						/* quantize and calc sum of new distortion */
-						distOldSum = 0;                                                     
-						distNewSum = 0;                                                     
+						distOldSum = 0;
+						distNewSum = 0;
 						for (sfb=startSfb; sfb<stopSfb; sfb++) {
-							
+
 							if (scfTmp[sfb] != MIN_16) {
 								distOldSum = L_add(distOldSum, sfbDist[sfb]);
-								
+
 								sfbDistNew[sfb] = calcSfbDist(psyOutChan->mdctSpectrum +
-									psyOutChan->sfbOffsets[sfb], 
+									psyOutChan->sfbOffsets[sfb],
 									(psyOutChan->sfbOffsets[sfb+1] - psyOutChan->sfbOffsets[sfb]),
 									scfAct);
-								
-								
+
+
 								if (sfbDistNew[sfb] > psyOutChan->sfbThreshold[sfb]) {
 									distNewSum = distOldSum << 1;
 									break;
@@ -670,20 +670,20 @@ static void assimilateMultipleScf(PSY_OUT_CHANNEL *psyOutChan,
 								distNewSum = L_add(distNewSum, sfbDistNew[sfb]);
 							}
 						}
-						
+
 						if (distNewSum < distOldSum) {
-							deltaPe = deltaPeNew;                                             
+							deltaPe = deltaPeNew;
 							for (sfb=startSfb; sfb<stopSfb; sfb++) {
-								
+
 								if (scf[sfb]!=MIN_16) {
-									scf[sfb] = scfAct;                                            
-									sfbDist[sfb] = sfbDistNew[sfb];                               
+									scf[sfb] = scfAct;
+									sfbDist[sfb] = sfbDistNew[sfb];
 								}
 							}
 						}
 					}
-				}        
-			} while (stopSfb <= sfbCnt);      
+				}
+			} while (stopSfb <= sfbCnt);
 		} while (scfAct > scfMin);
 	}
 }
@@ -710,125 +710,125 @@ EstimateScaleFactorsChannel(PSY_OUT_CHANNEL *psyOutChan,
 	Word32 *sfbDist = psyOutChan->sfbDist;
 	Word16 *minSfMaxQuant = psyOutChan->minSfMaxQuant;
 	Word16 *minScfCalculated = psyOutChan->minScfCalculated;
-	
-	
+
+
 	for (i=0; i<psyOutChan->sfbCnt; i++) {
-		Word32 sbfwith, sbfStart;
+		Word32 sbfwith, sbfStart;
 		Word32 *mdctSpec;
-		thresh = psyOutChan->sfbThreshold[i];                                       
-		energy = psyOutChan->sfbEnergy[i];                                          
-		
-		sbfStart = psyOutChan->sfbOffsets[i];
-		sbfwith = psyOutChan->sfbOffsets[i+1] - sbfStart;
-		mdctSpec = psyOutChan->mdctSpectrum+sbfStart;
-		
-		maxSpec = 0;                                                                
+		thresh = psyOutChan->sfbThreshold[i];
+		energy = psyOutChan->sfbEnergy[i];
+
+		sbfStart = psyOutChan->sfbOffsets[i];
+		sbfwith = psyOutChan->sfbOffsets[i+1] - sbfStart;
+		mdctSpec = psyOutChan->mdctSpectrum+sbfStart;
+
+		maxSpec = 0;
 		/* maximum of spectrum */
-		for (j=sbfwith; j; j-- ) {
-			Word32 absSpec = L_abs(*mdctSpec); mdctSpec++;
-			maxSpec |= absSpec;                                                       
+		for (j=sbfwith; j; j-- ) {
+			Word32 absSpec = L_abs(*mdctSpec); mdctSpec++;
+			maxSpec |= absSpec;
 		}
-		
+
 		/* scfs without energy or with thresh>energy are marked with MIN_16 */
-		scf[i] = MIN_16;                                                            
-		minSfMaxQuant[i] = MIN_16;    
-		
+		scf[i] = MIN_16;
+		minSfMaxQuant[i] = MIN_16;
+
 		if ((maxSpec > 0) && (energy > thresh)) {
-			
-			energyPart = logSfbFormFactor[i];                                         
-			thresholdPart = iLog4(thresh);  
-			/* -20 = 4*log2(6.75) - 32 */
+
+			energyPart = logSfbFormFactor[i];
+			thresholdPart = iLog4(thresh);
+			/* -20 = 4*log2(6.75) - 32 */
 			scfInt = ((thresholdPart - energyPart - 20) * SCALE_ESTIMATE_COEF) >> 15;
-			
+
 			minSfMaxQuant[i] = iLog4(maxSpec) - 68; /* 68  -16/3*log(MAX_QUANT+0.5-logCon)/log(2) + 1 */
-			
-			
+
+
 			if (minSfMaxQuant[i] > scfInt) {
-				scfInt = minSfMaxQuant[i];                                              
+				scfInt = minSfMaxQuant[i];
 			}
-			
+
 			/* find better scalefactor with analysis by synthesis */
-			scfInt = improveScf(psyOutChan->mdctSpectrum+sbfStart,
-				sbfwith,
-				thresh, scfInt, minSfMaxQuant[i], 
+			scfInt = improveScf(psyOutChan->mdctSpectrum+sbfStart,
+				sbfwith,
+				thresh, scfInt, minSfMaxQuant[i],
 				&sfbDist[i], &minScfCalculated[i]);
-			
-			scf[i] = scfInt;                                                          
+
+			scf[i] = scfInt;
 		}
 	}
-	
-	
+
+
 	/* scalefactor differece reduction  */
 	{
 		Word16 sfbConstPePart[MAX_GROUPED_SFB];
 		for(i=0;i<psyOutChan->sfbCnt;i++) {
-			sfbConstPePart[i] = MIN_16;                                               
+			sfbConstPePart[i] = MIN_16;
 		}
-		
-		assimilateSingleScf(psyOutChan, scf, 
+
+		assimilateSingleScf(psyOutChan, scf,
 			minSfMaxQuant, sfbDist, sfbConstPePart, logSfbEnergy,
 			logSfbFormFactor, sfbNRelevantLines, minScfCalculated, 1);
-		
-		assimilateMultipleScf(psyOutChan, scf, 
+
+		assimilateMultipleScf(psyOutChan, scf,
 			minSfMaxQuant, sfbDist, sfbConstPePart, logSfbEnergy,
 			logSfbFormFactor, sfbNRelevantLines);
 	}
 
 	/* get max scalefac for global gain */
-	maxScf = MIN_16;                                                              
-	minScf = MAX_16;                                                              
+	maxScf = MIN_16;
+	minScf = MAX_16;
 	for (i=0; i<psyOutChan->sfbCnt; i++) {
-		
+
 		if (maxScf < scf[i]) {
-			maxScf = scf[i];                                                          
+			maxScf = scf[i];
 		}
-		
+
 		if ((scf[i] != MIN_16) && (minScf > scf[i])) {
-			minScf = scf[i];                                                          
+			minScf = scf[i];
 		}
 	}
 	/* limit scf delta */
 	maxAllowedScf = minScf + MAX_SCF_DELTA;
 	for(i=0; i<psyOutChan->sfbCnt; i++) {
-		
+
 		if ((scf[i] != MIN_16) && (maxAllowedScf < scf[i])) {
-			scf[i] = maxAllowedScf;                                                   
+			scf[i] = maxAllowedScf;
 		}
 	}
 	/* new maxScf if any scf has been limited */
-	
+
 	if (maxAllowedScf < maxScf) {
-		maxScf = maxAllowedScf;                                                     
+		maxScf = maxAllowedScf;
 	}
-	
+
 	/* calc loop scalefactors */
-	
+
 	if (maxScf > MIN_16) {
-		*globalGain = maxScf;                                                       
-		lastSf = 0;                                                                 
-		
+		*globalGain = maxScf;
+		lastSf = 0;
+
 		for(i=0; i<psyOutChan->sfbCnt; i++) {
-			
+
 			if (scf[i] == MIN_16) {
-				scf[i] = lastSf;                                                        
+				scf[i] = lastSf;
 				/* set band explicitely to zero */
 				for (j=psyOutChan->sfbOffsets[i]; j<psyOutChan->sfbOffsets[i+1]; j++) {
-					psyOutChan->mdctSpectrum[j] = 0;                                      
+					psyOutChan->mdctSpectrum[j] = 0;
 				}
 			}
 			else {
 				scf[i] = maxScf - scf[i];
-				lastSf = scf[i];                                                        
+				lastSf = scf[i];
 			}
 		}
 	}
 	else{
-		*globalGain = 0;                                                            
+		*globalGain = 0;
 		/* set spectrum explicitely to zero */
 		for(i=0; i<psyOutChan->sfbCnt; i++) {
-			scf[i] = 0;                                                               
+			scf[i] = 0;
 			for (j=psyOutChan->sfbOffsets[i]; j<psyOutChan->sfbOffsets[i+1]; j++) {
-				psyOutChan->mdctSpectrum[j] = 0;                                        
+				psyOutChan->mdctSpectrum[j] = 0;
 			}
 		}
 	}
@@ -848,7 +848,7 @@ CalcFormFactor(Word16 logSfbFormFactor[MAX_CHANNELS][MAX_GROUPED_SFB],
                const Word16 nChannels)
 {
 	Word16 j;
-	
+
 	for (j=0; j<nChannels; j++) {
 		CalcFormFactorChannel(logSfbFormFactor[j], sfbNRelevantLines[j], logSfbEnergy[j], &psyOutChannel[j]);
 	}
@@ -869,7 +869,7 @@ EstimateScaleFactors(PSY_OUT_CHANNEL psyOutChannel[MAX_CHANNELS],
                      const Word16    nChannels)
 {
 	Word16 j;
-	
+
 	for (j=0; j<nChannels; j++) {
 		EstimateScaleFactorsChannel(&psyOutChannel[j],
 			qcOutChannel[j].scf,
diff --git a/media/libstagefright/codecs/aacenc/src/spreading.c b/media/libstagefright/codecs/aacenc/src/spreading.c
index e6fc7da..aaf2fff 100644
--- a/media/libstagefright/codecs/aacenc/src/spreading.c
+++ b/media/libstagefright/codecs/aacenc/src/spreading.c
@@ -1,29 +1,29 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		spreading.c
-
-	Content:	Spreading of energy function
-
-*******************************************************************************/
-
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "spreading.h"
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		spreading.c
+
+	Content:	Spreading of energy function
+
+*******************************************************************************/
+
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "spreading.h"
+
 /*********************************************************************************
 *
 * function name: SpreadingMax
@@ -31,22 +31,22 @@
 *				 higher frequencies thr(n) = max(thr(n), sh(n)*thr(n-1))
 *				 lower frequencies  thr(n) = max(thr(n), sl(n)*thr(n+1))
 *
-**********************************************************************************/
-void SpreadingMax(const Word16 pbCnt,
-                  const Word16 *maskLowFactor,
-                  const Word16 *maskHighFactor,
-                  Word32       *pbSpreadedEnergy)
-{
-  Word32 i;
-
-  /* slope to higher frequencies */
-  for (i=1; i<pbCnt; i++) {
-    pbSpreadedEnergy[i] = max(pbSpreadedEnergy[i],
-                                L_mpy_ls(pbSpreadedEnergy[i-1], maskHighFactor[i]));
-  }
-  /* slope to lower frequencies */
-  for (i=pbCnt - 2; i>=0; i--) {
-    pbSpreadedEnergy[i] = max(pbSpreadedEnergy[i],
-                                L_mpy_ls(pbSpreadedEnergy[i+1], maskLowFactor[i]));
-  }
-}
+**********************************************************************************/
+void SpreadingMax(const Word16 pbCnt,
+                  const Word16 *maskLowFactor,
+                  const Word16 *maskHighFactor,
+                  Word32       *pbSpreadedEnergy)
+{
+  Word32 i;
+
+  /* slope to higher frequencies */
+  for (i=1; i<pbCnt; i++) {
+    pbSpreadedEnergy[i] = max(pbSpreadedEnergy[i],
+                                L_mpy_ls(pbSpreadedEnergy[i-1], maskHighFactor[i]));
+  }
+  /* slope to lower frequencies */
+  for (i=pbCnt - 2; i>=0; i--) {
+    pbSpreadedEnergy[i] = max(pbSpreadedEnergy[i],
+                                L_mpy_ls(pbSpreadedEnergy[i+1], maskLowFactor[i]));
+  }
+}
diff --git a/media/libstagefright/codecs/aacenc/src/stat_bits.c b/media/libstagefright/codecs/aacenc/src/stat_bits.c
index 556104e..c2bd8bd 100644
--- a/media/libstagefright/codecs/aacenc/src/stat_bits.c
+++ b/media/libstagefright/codecs/aacenc/src/stat_bits.c
@@ -1,23 +1,23 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		stat_bits.c
-
-	Content:	Static bit counter functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		stat_bits.c
+
+	Content:	Static bit counter functions
+
 *******************************************************************************/
 
 #include "stat_bits.h"
@@ -52,9 +52,9 @@ static Word16 countMsMaskBits(Word16   sfbCnt,
                               struct TOOLSINFO *toolsInfo)
 {
   Word16 msBits, sfbOff, sfb;
-  msBits = 0;                                            
+  msBits = 0;
+
 
-   
   switch(toolsInfo->msDigest) {
     case MS_NONE:
     case MS_ALL:
@@ -82,37 +82,37 @@ static Word16 tnsCount(TNS_INFO *tnsInfo, Word16 blockType)
   Flag tnsPresent;
   Word32 numOfWindows;
   Word32 count;
-  Word32 coefBits;
+  Word32 coefBits;
   Word16 *ptcoef;
 
-  count = 0;       
-  
+  count = 0;
+
   if (blockType == 2)
     numOfWindows = 8;
   else
     numOfWindows = 1;
-  tnsPresent = 0;                                        
+  tnsPresent = 0;
 
   for (i=0; i<numOfWindows; i++) {
-     
+
     if (tnsInfo->tnsActive[i]!=0) {
-      tnsPresent = 1;                                    
+      tnsPresent = 1;
     }
   }
-   
+
   if (tnsPresent) {
     /* there is data to be written*/
     /*count += 1; */
     for (i=0; i<numOfWindows; i++) {
-       
+
       if (blockType == 2)
         count += 1;
       else
         count += 2;
-       
+
       if (tnsInfo->tnsActive[i]) {
         count += 1;
-         
+
         if (blockType == 2) {
           count += 4;
           count += 3;
@@ -121,29 +121,29 @@ static Word16 tnsCount(TNS_INFO *tnsInfo, Word16 blockType)
           count += 6;
           count += 5;
         }
-         
+
         if (tnsInfo->order[i]) {
           count += 1; /*direction*/
-          count += 1; /*coef_compression */	
-           
+          count += 1; /*coef_compression */
+
           if (tnsInfo->coefRes[i] == 4) {
-            ptcoef = tnsInfo->coef + i*TNS_MAX_ORDER_SHORT;
-			coefBits = 3;                                        
+            ptcoef = tnsInfo->coef + i*TNS_MAX_ORDER_SHORT;
+			coefBits = 3;
             for(k=0; k<tnsInfo->order[i]; k++) {
-                 
+
               if ((ptcoef[k] > 3) || (ptcoef[k] < -4)) {
-                coefBits = 4;                                    
+                coefBits = 4;
                 break;
               }
             }
           }
           else {
-            coefBits = 2;                                        
-            ptcoef = tnsInfo->coef + i*TNS_MAX_ORDER_SHORT;
+            coefBits = 2;
+            ptcoef = tnsInfo->coef + i*TNS_MAX_ORDER_SHORT;
 			for(k=0; k<tnsInfo->order[i]; k++) {
-                 
+
               if ((ptcoef[k] > 1) || (ptcoef[k] < -2)) {
-                coefBits = 3;                                    
+                coefBits = 3;
                 break;
               }
             }
@@ -154,15 +154,15 @@ static Word16 tnsCount(TNS_INFO *tnsInfo, Word16 blockType)
         }
       }
     }
-  }
-  
+  }
+
   return count;
 }
 
 /**********************************************************************************
 *
 * function name: countTnsBits
-* description:   count tns bit demand  
+* description:   count tns bit demand
 *
 **********************************************************************************/
 static Word16 countTnsBits(TNS_INFO *tnsInfo,Word16 blockType)
@@ -173,29 +173,29 @@ static Word16 countTnsBits(TNS_INFO *tnsInfo,Word16 blockType)
 /*********************************************************************************
 *
 * function name: countStaticBitdemand
-* description:   count static bit demand include tns  
+* description:   count static bit demand include tns
 *
 **********************************************************************************/
 Word16 countStaticBitdemand(PSY_OUT_CHANNEL psyOutChannel[MAX_CHANNELS],
                             PSY_OUT_ELEMENT *psyOutElement,
-                            Word16 channels, 
+                            Word16 channels,
 							Word16 adtsUsed)
 {
   Word32 statBits;
   Word32 ch;
-  
-  statBits = 0;                                                  
-
+
+  statBits = 0;
+
   /* if adts used, add 56 bits */
   if(adtsUsed) statBits += 56;
 
-   
+
   switch (channels) {
     case 1:
       statBits += SI_ID_BITS+SI_SCE_BITS+SI_ICS_BITS;
       statBits += countTnsBits(&(psyOutChannel[0].tnsInfo),
                                psyOutChannel[0].windowSequence);
-       
+
       switch(psyOutChannel[0].windowSequence){
         case LONG_WINDOW:
         case START_WINDOW:
@@ -215,7 +215,7 @@ Word16 countStaticBitdemand(PSY_OUT_CHANNEL psyOutChannel[MAX_CHANNELS],
 								  psyOutChannel[0].sfbPerGroup,
 								  psyOutChannel[0].maxSfbPerGroup,
 								  &psyOutElement->toolsInfo);
-       
+
       switch (psyOutChannel[0].windowSequence) {
         case LONG_WINDOW:
         case START_WINDOW:
diff --git a/media/libstagefright/codecs/aacenc/src/tns.c b/media/libstagefright/codecs/aacenc/src/tns.c
index 96d890e..455a864 100644
--- a/media/libstagefright/codecs/aacenc/src/tns.c
+++ b/media/libstagefright/codecs/aacenc/src/tns.c
@@ -1,27 +1,27 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		tns.c
-
-	Content:	Definition TNS tools functions
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		tns.c
+
+	Content:	Definition TNS tools functions
+
 *******************************************************************************/
 
-#include "basic_op.h"
-#include "oper_32b.h"
+#include "basic_op.h"
+#include "oper_32b.h"
 #include "assert.h"
 #include "aac_rom.h"
 #include "psy_const.h"
@@ -32,23 +32,23 @@
 
 #define TNS_MODIFY_BEGIN         2600  /* Hz */
 #define RATIO_PATCH_LOWER_BORDER 380   /* Hz */
-#define TNS_GAIN_THRESH			 141   /* 1.41*100 */
-#define NORM_COEF				 0x028f5c28
-
-static const Word32 TNS_PARCOR_THRESH = 0x0ccccccd; /* 0.1*(1 << 31) */
-/* Limit bands to > 2.0 kHz */
-static unsigned short tnsMinBandNumberLong[12] =
-{ 11, 12, 15, 16, 17, 20, 25, 26, 24, 28, 30, 31 };
-static unsigned short tnsMinBandNumberShort[12] =
-{ 2, 2, 2, 3, 3, 4, 6, 6, 8, 10, 10, 12 };
-
-/**************************************/
-/* Main/Low Profile TNS Parameters    */
-/**************************************/
-static unsigned short tnsMaxBandsLongMainLow[12] =
-{ 31, 31, 34, 40, 42, 51, 46, 46, 42, 42, 42, 39 };
-
-static unsigned short tnsMaxBandsShortMainLow[12] =
+#define TNS_GAIN_THRESH			 141   /* 1.41*100 */
+#define NORM_COEF				 0x028f5c28
+
+static const Word32 TNS_PARCOR_THRESH = 0x0ccccccd; /* 0.1*(1 << 31) */
+/* Limit bands to > 2.0 kHz */
+static unsigned short tnsMinBandNumberLong[12] =
+{ 11, 12, 15, 16, 17, 20, 25, 26, 24, 28, 30, 31 };
+static unsigned short tnsMinBandNumberShort[12] =
+{ 2, 2, 2, 3, 3, 4, 6, 6, 8, 10, 10, 12 };
+
+/**************************************/
+/* Main/Low Profile TNS Parameters    */
+/**************************************/
+static unsigned short tnsMaxBandsLongMainLow[12] =
+{ 31, 31, 34, 40, 42, 51, 46, 46, 42, 42, 42, 39 };
+
+static unsigned short tnsMaxBandsShortMainLow[12] =
 { 9, 9, 10, 14, 14, 14, 14, 14, 14, 14, 14, 14 };
 
 
@@ -100,20 +100,20 @@ static Word16 FreqToBandWithRounding(Word32 freq,                   /*!< frequen
   /*  assert(freq >= 0);  */
   shift = norm_l(fs);
   lineNumber = (extract_l(fixmul((bandStartOffset[numOfBands] << 2),Div_32(freq << shift,fs << shift))) + 1) >> 1;
- 
+
   /* freq > fs/2 */
-  temp = lineNumber - bandStartOffset[numOfBands] ;                                            
+  temp = lineNumber - bandStartOffset[numOfBands] ;
   if (temp >= 0)
     return numOfBands;
 
   /* find band the line number lies in */
   for (band=0; band<numOfBands; band++) {
-    temp = bandStartOffset[band + 1] - lineNumber;                                           
+    temp = bandStartOffset[band + 1] - lineNumber;
     if (temp > 0) break;
   }
 
   temp = (lineNumber - bandStartOffset[band]);
-  temp = (temp - (bandStartOffset[band + 1] - lineNumber));                                   
+  temp = (temp - (bandStartOffset[band + 1] - lineNumber));
   if ( temp > 0 )
   {
     band = band + 1;
@@ -139,25 +139,25 @@ Word16 InitTnsConfigurationLong(Word32 bitRate,          /*!< bitrate */
 {
 
   Word32 bitratePerChannel;
-  tC->maxOrder     = TNS_MAX_ORDER;                                           
+  tC->maxOrder     = TNS_MAX_ORDER;
   tC->tnsStartFreq = 1275;
-  tC->coefRes      = 4;                                                                                 
-  
+  tC->coefRes      = 4;
+
   /* to avoid integer division */
-  if ( sub(channels,2) == 0 ) { 
-    bitratePerChannel = bitRate >> 1;    
+  if ( sub(channels,2) == 0 ) {
+    bitratePerChannel = bitRate >> 1;
   }
   else {
-    bitratePerChannel = bitRate;                                                                    
+    bitratePerChannel = bitRate;
   }
 
   tC->tnsMaxSfb = tnsMaxBandsLongMainLow[pC->sampRateIdx];
 
-  tC->tnsActive = active;                                                                           
+  tC->tnsActive = active;
 
   /* now calc band and line borders */
   tC->tnsStopBand = min(pC->sfbCnt, tC->tnsMaxSfb);
-  tC->tnsStopLine = pC->sfbOffset[tC->tnsStopBand];                                                 
+  tC->tnsStopLine = pC->sfbOffset[tC->tnsStopBand];
 
   tC->tnsStartBand = FreqToBandWithRounding(tC->tnsStartFreq, sampleRate,
                                             pC->sfbCnt, (const Word16*)pC->sfbOffset);
@@ -173,18 +173,18 @@ Word16 InitTnsConfigurationLong(Word32 bitRate,          /*!< bitrate */
                                                      (const Word16*)pC->sfbOffset);
 
 
-  tC->tnsStartLine = pC->sfbOffset[tC->tnsStartBand];                                                                                                             
+  tC->tnsStartLine = pC->sfbOffset[tC->tnsStartBand];
 
   tC->lpcStopBand = tnsMaxBandsLongMainLow[pC->sampRateIdx];
   tC->lpcStopBand = min(tC->lpcStopBand, pC->sfbActive);
 
-  tC->lpcStopLine = pC->sfbOffset[tC->lpcStopBand];   
-  
+  tC->lpcStopLine = pC->sfbOffset[tC->lpcStopBand];
+
   tC->lpcStartBand = tnsMinBandNumberLong[pC->sampRateIdx];
 
-  tC->lpcStartLine = pC->sfbOffset[tC->lpcStartBand];                                               
+  tC->lpcStartLine = pC->sfbOffset[tC->lpcStartBand];
 
-  tC->threshold = TNS_GAIN_THRESH;                                                             
+  tC->threshold = TNS_GAIN_THRESH;
 
 
   return(0);
@@ -207,23 +207,23 @@ Word16 InitTnsConfigurationShort(Word32 bitRate,              /*!< bitrate */
   Word32 bitratePerChannel;
   tC->maxOrder     = TNS_MAX_ORDER_SHORT;
   tC->tnsStartFreq = 2750;
-  tC->coefRes      = 3;                                                                                 
-  
+  tC->coefRes      = 3;
+
   /* to avoid integer division */
   if ( sub(channels,2) == 0 ) {
-    bitratePerChannel = L_shr(bitRate,1);    
+    bitratePerChannel = L_shr(bitRate,1);
   }
   else {
-    bitratePerChannel = bitRate;                                                                    
+    bitratePerChannel = bitRate;
   }
 
   tC->tnsMaxSfb = tnsMaxBandsShortMainLow[pC->sampRateIdx];
 
-  tC->tnsActive = active;                                                                           
+  tC->tnsActive = active;
 
   /* now calc band and line borders */
   tC->tnsStopBand = min(pC->sfbCnt, tC->tnsMaxSfb);
-  tC->tnsStopLine = pC->sfbOffset[tC->tnsStopBand];                                                 
+  tC->tnsStopLine = pC->sfbOffset[tC->tnsStopBand];
 
   tC->tnsStartBand=FreqToBandWithRounding(tC->tnsStartFreq, sampleRate,
                                           pC->sfbCnt, (const Word16*)pC->sfbOffset);
@@ -239,19 +239,19 @@ Word16 InitTnsConfigurationShort(Word32 bitRate,              /*!< bitrate */
                                                      (const Word16*)pC->sfbOffset);
 
 
-  tC->tnsStartLine = pC->sfbOffset[tC->tnsStartBand];                                               
+  tC->tnsStartLine = pC->sfbOffset[tC->tnsStartBand];
 
-  tC->lpcStopBand = tnsMaxBandsShortMainLow[pC->sampRateIdx];
+  tC->lpcStopBand = tnsMaxBandsShortMainLow[pC->sampRateIdx];
 
   tC->lpcStopBand = min(tC->lpcStopBand, pC->sfbActive);
 
-  tC->lpcStopLine = pC->sfbOffset[tC->lpcStopBand];                                                 
+  tC->lpcStopLine = pC->sfbOffset[tC->lpcStopBand];
 
-  tC->lpcStartBand = tnsMinBandNumberShort[pC->sampRateIdx];
+  tC->lpcStartBand = tnsMinBandNumberShort[pC->sampRateIdx];
 
-  tC->lpcStartLine = pC->sfbOffset[tC->lpcStartBand];                                               
+  tC->lpcStartLine = pC->sfbOffset[tC->lpcStartBand];
 
-  tC->threshold = TNS_GAIN_THRESH;                                                             
+  tC->threshold = TNS_GAIN_THRESH;
 
   return(0);
 }
@@ -259,7 +259,7 @@ Word16 InitTnsConfigurationShort(Word32 bitRate,              /*!< bitrate */
 /**
 *
 * function name: TnsDetect
-* description:  Calculate TNS filter and decide on TNS usage 
+* description:  Calculate TNS filter and decide on TNS usage
 * returns:		0 if success
 *
 */
@@ -278,7 +278,7 @@ Word32 TnsDetect(TNS_DATA* tnsData,        /*!< tns data structure (modified) */
   Word32* pWork32 = &pScratchTns[subBlockNumber >> 8];
   Word16* pWeightedSpectrum = (Word16 *)&pScratchTns[subBlockNumber >> 8];
 
-                                                                                                    
+
   if (tC.tnsActive) {
     CalcWeightedSpectrum(spectrum,
                          pWeightedSpectrum,
@@ -290,7 +290,7 @@ Word32 TnsDetect(TNS_DATA* tnsData,        /*!< tns data structure (modified) */
                          tC.lpcStopBand,
                          pWork32);
 
-    temp = blockType - SHORT_WINDOW;                                                          
+    temp = blockType - SHORT_WINDOW;
     if ( temp != 0 ) {
         predictionGain = CalcTnsFilter( &pWeightedSpectrum[tC.lpcStartLine],
                                         tC.acfWindow,
@@ -299,15 +299,15 @@ Word32 TnsDetect(TNS_DATA* tnsData,        /*!< tns data structure (modified) */
                                         tnsData->dataRaw.tnsLong.subBlockInfo.parcor);
 
 
-        temp = predictionGain - tC.threshold;                                                  
+        temp = predictionGain - tC.threshold;
         if ( temp > 0 ) {
-          tnsData->dataRaw.tnsLong.subBlockInfo.tnsActive = 1;                                      
+          tnsData->dataRaw.tnsLong.subBlockInfo.tnsActive = 1;
         }
         else {
-          tnsData->dataRaw.tnsLong.subBlockInfo.tnsActive = 0;                                      
+          tnsData->dataRaw.tnsLong.subBlockInfo.tnsActive = 0;
         }
 
-        tnsData->dataRaw.tnsLong.subBlockInfo.predictionGain = predictionGain;                      
+        tnsData->dataRaw.tnsLong.subBlockInfo.predictionGain = predictionGain;
     }
     else{
 
@@ -317,28 +317,28 @@ Word32 TnsDetect(TNS_DATA* tnsData,        /*!< tns data structure (modified) */
                                         tC.maxOrder,
                                         tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].parcor);
 
-        temp = predictionGain - tC.threshold;                                                 
+        temp = predictionGain - tC.threshold;
         if ( temp > 0 ) {
-          tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].tnsActive = 1;                     
+          tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].tnsActive = 1;
         }
         else {
-          tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].tnsActive = 0;                     
+          tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].tnsActive = 0;
         }
 
-        tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].predictionGain = predictionGain;     
+        tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].predictionGain = predictionGain;
     }
 
   }
   else{
 
-    temp = blockType - SHORT_WINDOW;                                                          
+    temp = blockType - SHORT_WINDOW;
     if ( temp != 0 ) {
-        tnsData->dataRaw.tnsLong.subBlockInfo.tnsActive = 0;                                        
-        tnsData->dataRaw.tnsLong.subBlockInfo.predictionGain = 0;                                   
+        tnsData->dataRaw.tnsLong.subBlockInfo.tnsActive = 0;
+        tnsData->dataRaw.tnsLong.subBlockInfo.predictionGain = 0;
     }
     else {
-        tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].tnsActive = 0;                       
-        tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].predictionGain = 0;                  
+        tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].tnsActive = 0;
+        tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber].predictionGain = 0;
     }
   }
 
@@ -362,21 +362,21 @@ void TnsSync(TNS_DATA *tnsDataDest,
    const TNS_SUBBLOCK_INFO *sbInfoSrc;
    Word32 i, temp;
 
-   temp =  blockType - SHORT_WINDOW;                                                           
+   temp =  blockType - SHORT_WINDOW;
    if ( temp != 0 ) {
-      sbInfoDest = &tnsDataDest->dataRaw.tnsLong.subBlockInfo;                                      
-      sbInfoSrc  = &tnsDataSrc->dataRaw.tnsLong.subBlockInfo;                                       
+      sbInfoDest = &tnsDataDest->dataRaw.tnsLong.subBlockInfo;
+      sbInfoSrc  = &tnsDataSrc->dataRaw.tnsLong.subBlockInfo;
    }
    else {
-      sbInfoDest = &tnsDataDest->dataRaw.tnsShort.subBlockInfo[subBlockNumber];                     
-      sbInfoSrc  = &tnsDataSrc->dataRaw.tnsShort.subBlockInfo[subBlockNumber];                      
+      sbInfoDest = &tnsDataDest->dataRaw.tnsShort.subBlockInfo[subBlockNumber];
+      sbInfoSrc  = &tnsDataSrc->dataRaw.tnsShort.subBlockInfo[subBlockNumber];
    }
 
    if (100*abs_s(sbInfoDest->predictionGain - sbInfoSrc->predictionGain) <
        (3 * sbInfoDest->predictionGain)) {
-      sbInfoDest->tnsActive = sbInfoSrc->tnsActive;                                                 
+      sbInfoDest->tnsActive = sbInfoSrc->tnsActive;
       for ( i=0; i< tC.maxOrder; i++) {
-        sbInfoDest->parcor[i] = sbInfoSrc->parcor[i];                                               
+        sbInfoDest->parcor[i] = sbInfoSrc->parcor[i];
       }
    }
 }
@@ -399,14 +399,14 @@ Word16 TnsEncode(TNS_INFO* tnsInfo,     /*!< tns info structure (modified) */
 {
   Word32 i;
   Word32 temp_s;
-  Word32 temp;
+  Word32 temp;
   TNS_SUBBLOCK_INFO *psubBlockInfo;
 
-  temp_s = blockType - SHORT_WINDOW;                                                             
-  if ( temp_s != 0) {                                                                               
-    psubBlockInfo = &tnsData->dataRaw.tnsLong.subBlockInfo;
+  temp_s = blockType - SHORT_WINDOW;
+  if ( temp_s != 0) {
+    psubBlockInfo = &tnsData->dataRaw.tnsLong.subBlockInfo;
 	if (psubBlockInfo->tnsActive == 0) {
-      tnsInfo->tnsActive[subBlockNumber] = 0;                                                       
+      tnsInfo->tnsActive[subBlockNumber] = 0;
       return(0);
     }
     else {
@@ -422,22 +422,22 @@ Word16 TnsEncode(TNS_INFO* tnsInfo,     /*!< tns info structure (modified) */
                    tC.coefRes);
 
       for (i=tC.maxOrder - 1; i>=0; i--)  {
-        temp = psubBlockInfo->parcor[i] - TNS_PARCOR_THRESH;         
+        temp = psubBlockInfo->parcor[i] - TNS_PARCOR_THRESH;
         if ( temp > 0 )
           break;
-        temp = psubBlockInfo->parcor[i] + TNS_PARCOR_THRESH;         
+        temp = psubBlockInfo->parcor[i] + TNS_PARCOR_THRESH;
         if ( temp < 0 )
           break;
       }
-      tnsInfo->order[subBlockNumber] = i + 1;                                                    
+      tnsInfo->order[subBlockNumber] = i + 1;
 
 
-      tnsInfo->tnsActive[subBlockNumber] = 1;                                                       
+      tnsInfo->tnsActive[subBlockNumber] = 1;
       for (i=subBlockNumber+1; i<TRANS_FAC; i++) {
-        tnsInfo->tnsActive[i] = 0;                                                                  
+        tnsInfo->tnsActive[i] = 0;
       }
-      tnsInfo->coefRes[subBlockNumber] = tC.coefRes;                                                
-      tnsInfo->length[subBlockNumber] = numOfSfb - tC.tnsStartBand;                                 
+      tnsInfo->coefRes[subBlockNumber] = tC.coefRes;
+      tnsInfo->length[subBlockNumber] = numOfSfb - tC.tnsStartBand;
 
 
       AnalysisFilterLattice(&(spectrum[tC.tnsStartLine]),
@@ -448,10 +448,10 @@ Word16 TnsEncode(TNS_INFO* tnsInfo,     /*!< tns info structure (modified) */
 
     }
   }     /* if (blockType!=SHORT_WINDOW) */
-  else /*short block*/ {                                                                            
-    psubBlockInfo = &tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber];
+  else /*short block*/ {
+    psubBlockInfo = &tnsData->dataRaw.tnsShort.subBlockInfo[subBlockNumber];
 	if (psubBlockInfo->tnsActive == 0) {
-      tnsInfo->tnsActive[subBlockNumber] = 0;                                                       
+      tnsInfo->tnsActive[subBlockNumber] = 0;
       return(0);
     }
     else {
@@ -466,19 +466,19 @@ Word16 TnsEncode(TNS_INFO* tnsInfo,     /*!< tns info structure (modified) */
                    tC.maxOrder,
                    tC.coefRes);
       for (i=(tC.maxOrder - 1); i>=0; i--)  {
-        temp = psubBlockInfo->parcor[i] - TNS_PARCOR_THRESH;    
+        temp = psubBlockInfo->parcor[i] - TNS_PARCOR_THRESH;
          if ( temp > 0 )
           break;
 
-        temp = psubBlockInfo->parcor[i] + TNS_PARCOR_THRESH;    
+        temp = psubBlockInfo->parcor[i] + TNS_PARCOR_THRESH;
         if ( temp < 0 )
           break;
       }
-      tnsInfo->order[subBlockNumber] = i + 1;                                                    
+      tnsInfo->order[subBlockNumber] = i + 1;
 
-      tnsInfo->tnsActive[subBlockNumber] = 1;                                                       
-      tnsInfo->coefRes[subBlockNumber] = tC.coefRes;                                                
-      tnsInfo->length[subBlockNumber] = numOfSfb - tC.tnsStartBand;                             
+      tnsInfo->tnsActive[subBlockNumber] = 1;
+      tnsInfo->coefRes[subBlockNumber] = tC.coefRes;
+      tnsInfo->length[subBlockNumber] = numOfSfb - tC.tnsStartBand;
 
 
       AnalysisFilterLattice(&(spectrum[tC.tnsStartLine]), (tC.tnsStopLine - tC.tnsStartLine),
@@ -507,14 +507,14 @@ static Word32 m_pow2_cordic(Word32 x, Word16 scale)
 {
   Word32 k;
 
-  Word32 accu_y = 0x40000000;                                                                     
+  Word32 accu_y = 0x40000000;
   accu_y = L_shr(accu_y,scale);
 
   for(k=1; k<INT_BITS; k++) {
-    const Word32 z = m_log2_table[k];                                                             
+    const Word32 z = m_log2_table[k];
 
     while(L_sub(x,z) >= 0) {
-       
+
       x = L_sub(x, z);
       accu_y = L_add(accu_y, (accu_y >> k));
     }
@@ -548,43 +548,43 @@ static void CalcWeightedSpectrum(const Word32  spectrum[],         /*!< input sp
     Word32 maxWS;
     Word32 tnsSfbMean[MAX_SFB];    /* length [lpcStopBand-lpcStartBand] should be sufficient here */
 
-    maxWS = 0;                                                                                   
-  
+    maxWS = 0;
+
     /* calc 1.0*2^-INT_BITS/2/sqrt(en) */
     for( sfb = lpcStartBand; sfb < lpcStopBand; sfb++) {
 
-      tmp2 = sfbEnergy[sfb] - 2;                                                            
+      tmp2 = sfbEnergy[sfb] - 2;
       if( tmp2 > 0) {
         tmp = rsqrt(sfbEnergy[sfb], INT_BITS);
-		if(tmp > INT_BITS_SCAL) 
-		{
-			shift =  norm_l(tmp);
-			tmp = Div_32( INT_BITS_SCAL << shift, tmp << shift ); 
+		if(tmp > INT_BITS_SCAL)
+		{
+			shift =  norm_l(tmp);
+			tmp = Div_32( INT_BITS_SCAL << shift, tmp << shift );
 		}
 		else
 		{
-			tmp = 0x7fffffff; 
+			tmp = 0x7fffffff;
 		}
       }
       else {
-        tmp = 0x7fffffff;                                                                           
-      } 
-      tnsSfbMean[sfb] = tmp;                                                                        
+        tmp = 0x7fffffff;
+      }
+      tnsSfbMean[sfb] = tmp;
     }
 
     /* spread normalized values from sfbs to lines */
-    sfb = lpcStartBand;                                                                             
-    tmp = tnsSfbMean[sfb];                                                                          
+    sfb = lpcStartBand;
+    tmp = tnsSfbMean[sfb];
     for ( i=lpcStartLine; i<lpcStopLine; i++){
-      tmp_s = sfbOffset[sfb + 1] - i;                                                      
+      tmp_s = sfbOffset[sfb + 1] - i;
       if ( tmp_s == 0 ) {
         sfb = sfb + 1;
-        tmp2_s = sfb + 1 - lpcStopBand;                                                       
+        tmp2_s = sfb + 1 - lpcStopBand;
         if (tmp2_s <= 0) {
-          tmp = tnsSfbMean[sfb];                                                                    
+          tmp = tnsSfbMean[sfb];
         }
       }
-      pWork32[i] = tmp;                                                                    
+      pWork32[i] = tmp;
     }
     /*filter down*/
     for (i=(lpcStopLine - 2); i>=lpcStartLine; i--){
@@ -597,24 +597,24 @@ static void CalcWeightedSpectrum(const Word32  spectrum[],         /*!< input sp
 
     /* weight and normalize */
     for (i=lpcStartLine; i<lpcStopLine; i++){
-      pWork32[i] = MULHIGH(pWork32[i], spectrum[i]);                               
-      maxWS |= L_abs(pWork32[i]);                                                          
+      pWork32[i] = MULHIGH(pWork32[i], spectrum[i]);
+      maxWS |= L_abs(pWork32[i]);
     }
     maxShift = norm_l(maxWS);
-
-	maxShift = 16 - maxShift;
-    if(maxShift >= 0)
-	{
-		for (i=lpcStartLine; i<lpcStopLine; i++){
-			weightedSpectrum[i] = pWork32[i] >> maxShift;
-		}
-    }
-	else
-	{
-		maxShift = -maxShift;
-		for (i=lpcStartLine; i<lpcStopLine; i++){
-			weightedSpectrum[i] = saturate(pWork32[i] << maxShift);
-		}
+
+	maxShift = 16 - maxShift;
+    if(maxShift >= 0)
+	{
+		for (i=lpcStartLine; i<lpcStopLine; i++){
+			weightedSpectrum[i] = pWork32[i] >> maxShift;
+		}
+    }
+	else
+	{
+		maxShift = -maxShift;
+		for (i=lpcStartLine; i<lpcStopLine; i++){
+			weightedSpectrum[i] = saturate(pWork32[i] << maxShift);
+		}
 	}
 }
 
@@ -646,7 +646,7 @@ static Word16 CalcTnsFilter(const Word16 *signal,
   assert(tnsOrder <= TNS_MAX_ORDER);      /* remove asserts later? (btg) */
 
   for(i=0;i<tnsOrder;i++) {
-    parcor[i] = 0;                               
+    parcor[i] = 0;
   }
 
   AutoCorrelation(signal, parcorWorkBuffer, numOfLines, tnsOrderPlus1);
@@ -669,7 +669,7 @@ static Word16 CalcTnsFilter(const Word16 *signal,
 * output:       acf values
 *
 *****************************************************************************/
-#ifndef ARMV5E
+#ifndef ARMV5E
 void AutoCorrelation(const Word16		 input[],
                             Word32       corr[],
                             Word16       samples,
@@ -678,15 +678,15 @@ void AutoCorrelation(const Word16		 input[],
   Word32 accu;
   Word32 scf;
 
-  scf = 10 - 1;                                                                                      
-
+  scf = 10 - 1;
+
   isamples = samples;
   /* calc first corrCoef:  R[0] = sum { t[i] * t[i] } ; i = 0..N-1 */
-  accu = 0;                                                                                      
+  accu = 0;
   for(j=0; j<isamples; j++) {
-    accu = L_add(accu, ((input[j] * input[j]) >> scf));
+    accu = L_add(accu, ((input[j] * input[j]) >> scf));
   }
-  corr[0] = accu;                                                                                
+  corr[0] = accu;
 
   /* early termination if all corr coeffs are likely going to be zero */
   if(corr[0] == 0) return ;
@@ -694,13 +694,13 @@ void AutoCorrelation(const Word16		 input[],
   /* calc all other corrCoef:  R[j] = sum { t[i] * t[i+j] } ; i = 0..(N-j-1), j=1..p */
   for(i=1; i<corrCoeff; i++) {
     isamples = isamples - 1;
-    accu = 0;                                                                                    
+    accu = 0;
     for(j=0; j<isamples; j++) {
-      accu = L_add(accu, ((input[j] * input[j+i]) >> scf));
+      accu = L_add(accu, ((input[j] * input[j+i]) >> scf));
     }
-    corr[i] = accu;                                                                              
+    corr[i] = accu;
   }
-}    
+}
 #endif
 
 /*****************************************************************************
@@ -720,46 +720,46 @@ static Word16 AutoToParcor(Word32 workBuffer[], Word32 reflCoeff[], Word16 numOf
   Word32 predictionGain = 0;
   Word32 num, denom;
   Word32 temp, workBuffer0;
-   
 
-  num = workBuffer[0];                                                                           
-  temp = workBuffer[numOfCoeff];                                                                 
+
+  num = workBuffer[0];
+  temp = workBuffer[numOfCoeff];
 
   for(i=0; i<numOfCoeff-1; i++) {
-    workBuffer[i + numOfCoeff] = workBuffer[i + 1];                                        
+    workBuffer[i + numOfCoeff] = workBuffer[i + 1];
   }
-  workBuffer[i + numOfCoeff] = temp;                                                                           
-  
+  workBuffer[i + numOfCoeff] = temp;
+
   for(i=0; i<numOfCoeff; i++) {
     Word32 refc;
 
-     
+
     if (workBuffer[0] < L_abs(workBuffer[i + numOfCoeff])) {
       return 0 ;
     }
-	shift = norm_l(workBuffer[0]);
+	shift = norm_l(workBuffer[0]);
 	workBuffer0 = Div_32(1 << shift, workBuffer[0] << shift);
     /* calculate refc = -workBuffer[numOfCoeff+i] / workBuffer[0]; -1 <= refc < 1 */
 	refc = L_negate(fixmul(workBuffer[numOfCoeff + i], workBuffer0));
 
-    reflCoeff[i] = refc;                                                                           
+    reflCoeff[i] = refc;
 
-    pWorkBuffer = &(workBuffer[numOfCoeff]);                                                        
+    pWorkBuffer = &(workBuffer[numOfCoeff]);
 
     for(j=i; j<numOfCoeff; j++) {
       Word32 accu1, accu2;
       accu1 = L_add(pWorkBuffer[j], fixmul(refc, workBuffer[j - i]));
       accu2 = L_add(workBuffer[j - i], fixmul(refc, pWorkBuffer[j]));
-      pWorkBuffer[j] = accu1;                                                                       
-      workBuffer[j - i] = accu2;                                                                 
+      pWorkBuffer[j] = accu1;
+      workBuffer[j - i] = accu2;
     }
   }
 
   denom = MULHIGH(workBuffer[0], NORM_COEF);
-   
+
   if (denom != 0) {
-    Word32 temp;
-	shift = norm_l(denom);
+    Word32 temp;
+	shift = norm_l(denom);
 	temp = Div_32(1 << shift, denom << shift);
     predictionGain = fixmul(num, temp);
   }
@@ -774,11 +774,11 @@ static Word16 Search3(Word32 parcor)
   Word32 index = 0;
   Word32 i;
   Word32 temp;
-   
+
   for (i=0;i<8;i++) {
-    temp = L_sub( parcor, tnsCoeff3Borders[i]);                                                     
+    temp = L_sub( parcor, tnsCoeff3Borders[i]);
     if (temp > 0)
-      index=i;                                                                                      
+      index=i;
   }
   return extract_l(index - 4);
 }
@@ -788,12 +788,12 @@ static Word16 Search4(Word32 parcor)
   Word32 index = 0;
   Word32 i;
   Word32 temp;
-   
+
 
   for (i=0;i<16;i++) {
-    temp = L_sub(parcor, tnsCoeff4Borders[i]);                                                      
+    temp = L_sub(parcor, tnsCoeff4Borders[i]);
     if (temp > 0)
-      index=i;                                                                                      
+      index=i;
   }
   return extract_l(index - 8);
 }
@@ -814,12 +814,12 @@ static void Parcor2Index(const Word32 parcor[],   /*!< parcor coefficients */
   Word32 temp;
 
   for(i=0; i<order; i++) {
-    temp = bitsPerCoeff - 3;                                                                    
+    temp = bitsPerCoeff - 3;
     if (temp == 0) {
-      index[i] = Search3(parcor[i]);                                                                
-    } 
+      index[i] = Search3(parcor[i]);
+    }
     else {
-      index[i] = Search4(parcor[i]);                                                                
+      index[i] = Search4(parcor[i]);
     }
   }
 }
@@ -839,12 +839,12 @@ static void Index2Parcor(const Word16 index[],  /*!< quantized values */
   Word32 temp;
 
   for (i=0; i<order; i++) {
-    temp = bitsPerCoeff - 4;                                                                     
+    temp = bitsPerCoeff - 4;
     if ( temp == 0 ) {
-        parcor[i] = tnsCoeff4[index[i] + 8];                                                     
+        parcor[i] = tnsCoeff4[index[i] + 8];
     }
     else {
-        parcor[i] = tnsCoeff3[index[i] + 4];                                                  
+        parcor[i] = tnsCoeff3[index[i] + 4];
     }
   }
 }
@@ -865,20 +865,20 @@ static Word32 FIRLattice(Word16 order,           /*!< filter order */
    Word32 accu,tmp,tmpSave;
 
    x = x >> 1;
-   tmpSave = x;                                                                                     
+   tmpSave = x;
 
    for (i=0; i<(order - 1); i++) {
 
      tmp = L_add(fixmul(coef_par[i], x), state_par[i]);
      x   = L_add(fixmul(coef_par[i], state_par[i]), x);
 
-     state_par[i] = tmpSave;                                                                        
-     tmpSave = tmp;                                                                                 
+     state_par[i] = tmpSave;
+     tmpSave = tmp;
   }
 
   /* last stage: only need half operations */
   accu = fixmul(state_par[order - 1], coef_par[(order - 1)]);
-  state_par[(order - 1)] = tmpSave;                                                                
+  state_par[(order - 1)] = tmpSave;
 
   x = L_add(accu, x);
   x = L_add(x, x);
@@ -903,11 +903,11 @@ static void AnalysisFilterLattice(const  Word32 signal[],  /*!< input spectrum *
   Word32 j;
 
   for ( j=0; j<TNS_MAX_ORDER; j++ ) {
-    state_par[j] = 0;                                                                               
+    state_par[j] = 0;
   }
 
   for(j=0; j<numOfLines; j++) {
-    output[j] = FIRLattice(order,signal[j],state_par,parCoeff);                                     
+    output[j] = FIRLattice(order,signal[j],state_par,parCoeff);
   }
 }
 
@@ -922,11 +922,11 @@ void ApplyTnsMultTableToRatios(Word16 startCb,
                                TNS_SUBBLOCK_INFO subInfo, /*!< TNS subblock info */
                                Word32 *thresholds)        /*!< thresholds (modified) */
 {
-  Word32 i;                                                                                         
+  Word32 i;
   if (subInfo.tnsActive) {
     for(i=startCb; i<stopCb; i++) {
       /* thresholds[i] * 0.25 */
-      thresholds[i] = (thresholds[i] >> 2);                                                      
+      thresholds[i] = (thresholds[i] >> 2);
     }
   }
 }
diff --git a/media/libstagefright/codecs/aacenc/src/transform.c b/media/libstagefright/codecs/aacenc/src/transform.c
index af17b5a..a154a2f 100644
--- a/media/libstagefright/codecs/aacenc/src/transform.c
+++ b/media/libstagefright/codecs/aacenc/src/transform.c
@@ -1,37 +1,37 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		transform.c
-
-	Content:	MDCT Transform functionss
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		transform.c
+
+	Content:	MDCT Transform functionss
+
 *******************************************************************************/
 
-#include "basic_op.h"
+#include "basic_op.h"
 #include "psy_const.h"
 #include "transform.h"
 #include "aac_rom.h"
-
-
-#define LS_TRANS ((FRAME_LEN_LONG-FRAME_LEN_SHORT)/2) /* 448 */
-#define SQRT1_2 0x5a82799a	/* sqrt(1/2) in Q31 */
-#define swap2(p0,p1) \
-	t = p0; t1 = *(&(p0)+1);	\
-	p0 = p1; *(&(p0)+1) = *(&(p1)+1);	\
-	p1 = t; *(&(p1)+1) = t1	
+
+
+#define LS_TRANS ((FRAME_LEN_LONG-FRAME_LEN_SHORT)/2) /* 448 */
+#define SQRT1_2 0x5a82799a	/* sqrt(1/2) in Q31 */
+#define swap2(p0,p1) \
+	t = p0; t1 = *(&(p0)+1);	\
+	p0 = p1; *(&(p0)+1) = *(&(p1)+1);	\
+	p1 = t; *(&(p1)+1) = t1
 
 /*********************************************************************************
 *
@@ -39,350 +39,350 @@
 * description:  Shuffle points prepared function for fft
 *
 **********************************************************************************/
-static void Shuffle(int *buf, int num, const unsigned char* bitTab)
-{
-    int *part0, *part1;
-	int i, j;
-	int t, t1;
-
-	part0 = buf;
-    part1 = buf + num;
-	
-	while ((i = *bitTab++) != 0) {
-        j = *bitTab++;
-
-        swap2(part0[4*i+0], part0[4*j+0]);	
-        swap2(part0[4*i+2], part1[4*j+0]);	
-        swap2(part1[4*i+0], part0[4*j+2]);	
-        swap2(part1[4*i+2], part1[4*j+2]);	
-    }
-
-    do {
-        swap2(part0[4*i+2], part1[4*i+0]);	
-    } while ((i = *bitTab++) != 0);
-}
-
-#if !defined(ARMV5E) && !defined(ARMV7Neon)
+static void Shuffle(int *buf, int num, const unsigned char* bitTab)
+{
+    int *part0, *part1;
+	int i, j;
+	int t, t1;
+
+	part0 = buf;
+    part1 = buf + num;
+
+	while ((i = *bitTab++) != 0) {
+        j = *bitTab++;
+
+        swap2(part0[4*i+0], part0[4*j+0]);
+        swap2(part0[4*i+2], part1[4*j+0]);
+        swap2(part1[4*i+0], part0[4*j+2]);
+        swap2(part1[4*i+2], part1[4*j+2]);
+    }
+
+    do {
+        swap2(part0[4*i+2], part1[4*i+0]);
+    } while ((i = *bitTab++) != 0);
+}
+
+#if !defined(ARMV5E) && !defined(ARMV7Neon)
 
 /*****************************************************************************
 *
 * function name: Radix4First
 * description:  Radix 4 point prepared function for fft
 *
-**********************************************************************************/
-static void Radix4First(int *buf, int num)
-{
-    int r0, r1, r2, r3;
-	int r4, r5, r6, r7;
-	
-	for (; num != 0; num--) 
-	{
-		r0 = buf[0] + buf[2];
-		r1 = buf[1] + buf[3];
-		r2 = buf[0] - buf[2];
-		r3 = buf[1] - buf[3];
-		r4 = buf[4] + buf[6];
-		r5 = buf[5] + buf[7];
-		r6 = buf[4] - buf[6];
-		r7 = buf[5] - buf[7];
-
-		buf[0] = r0 + r4;
-		buf[1] = r1 + r5;
-		buf[4] = r0 - r4;
-		buf[5] = r1 - r5;
-		buf[2] = r2 + r7;
-		buf[3] = r3 - r6;
-		buf[6] = r2 - r7;
-		buf[7] = r3 + r6;
-
-		buf += 8;
-	}
-}
-
+**********************************************************************************/
+static void Radix4First(int *buf, int num)
+{
+    int r0, r1, r2, r3;
+	int r4, r5, r6, r7;
+
+	for (; num != 0; num--)
+	{
+		r0 = buf[0] + buf[2];
+		r1 = buf[1] + buf[3];
+		r2 = buf[0] - buf[2];
+		r3 = buf[1] - buf[3];
+		r4 = buf[4] + buf[6];
+		r5 = buf[5] + buf[7];
+		r6 = buf[4] - buf[6];
+		r7 = buf[5] - buf[7];
+
+		buf[0] = r0 + r4;
+		buf[1] = r1 + r5;
+		buf[4] = r0 - r4;
+		buf[5] = r1 - r5;
+		buf[2] = r2 + r7;
+		buf[3] = r3 - r6;
+		buf[6] = r2 - r7;
+		buf[7] = r3 + r6;
+
+		buf += 8;
+	}
+}
+
 /*****************************************************************************
 *
 * function name: Radix8First
 * description:  Radix 8 point prepared function for fft
 *
-**********************************************************************************/
-static void Radix8First(int *buf, int num)
-{
-   int r0, r1, r2, r3;
-   int i0, i1, i2, i3;
-   int r4, r5, r6, r7;
-   int i4, i5, i6, i7;
-   int t0, t1, t2, t3;
-
-	for ( ; num != 0; num--) 
-	{
-		r0 = buf[0] + buf[2];
-		i0 = buf[1] + buf[3];
-		r1 = buf[0] - buf[2];
-		i1 = buf[1] - buf[3];
-		r2 = buf[4] + buf[6];
-		i2 = buf[5] + buf[7];
-		r3 = buf[4] - buf[6];
-		i3 = buf[5] - buf[7];
-
-		r4 = (r0 + r2) >> 1;
-		i4 = (i0 + i2) >> 1;
-		r5 = (r0 - r2) >> 1;
-		i5 = (i0 - i2) >> 1;
-		r6 = (r1 - i3) >> 1;
-		i6 = (i1 + r3) >> 1;
-		r7 = (r1 + i3) >> 1;
-		i7 = (i1 - r3) >> 1;
-
-		r0 = buf[ 8] + buf[10];
-		i0 = buf[ 9] + buf[11];
-		r1 = buf[ 8] - buf[10];
-		i1 = buf[ 9] - buf[11];
-		r2 = buf[12] + buf[14];
-		i2 = buf[13] + buf[15];
-		r3 = buf[12] - buf[14];
-		i3 = buf[13] - buf[15];
-
-		t0 = (r0 + r2) >> 1;
-		t1 = (i0 + i2) >> 1;
-		t2 = (r0 - r2) >> 1;
-		t3 = (i0 - i2) >> 1;
-
-		buf[ 0] = r4 + t0;
-		buf[ 1] = i4 + t1;
-		buf[ 8] = r4 - t0;
-		buf[ 9] = i4 - t1;
-		buf[ 4] = r5 + t3;
-		buf[ 5] = i5 - t2;
-		buf[12] = r5 - t3;
-		buf[13] = i5 + t2;
-
-		r0 = r1 - i3;
-		i0 = i1 + r3;
-		r2 = r1 + i3;
-		i2 = i1 - r3;
-
-		t0 = MULHIGH(SQRT1_2, r0 - i0);
-		t1 = MULHIGH(SQRT1_2, r0 + i0);
-		t2 = MULHIGH(SQRT1_2, r2 - i2);
-		t3 = MULHIGH(SQRT1_2, r2 + i2);
-
-		buf[ 6] = r6 - t0;
-		buf[ 7] = i6 - t1;
-		buf[14] = r6 + t0;
-		buf[15] = i6 + t1;
-		buf[ 2] = r7 + t3;
-		buf[ 3] = i7 - t2;
-		buf[10] = r7 - t3;
-		buf[11] = i7 + t2;
-
-		buf += 16;
-	}
-}
-
+**********************************************************************************/
+static void Radix8First(int *buf, int num)
+{
+   int r0, r1, r2, r3;
+   int i0, i1, i2, i3;
+   int r4, r5, r6, r7;
+   int i4, i5, i6, i7;
+   int t0, t1, t2, t3;
+
+	for ( ; num != 0; num--)
+	{
+		r0 = buf[0] + buf[2];
+		i0 = buf[1] + buf[3];
+		r1 = buf[0] - buf[2];
+		i1 = buf[1] - buf[3];
+		r2 = buf[4] + buf[6];
+		i2 = buf[5] + buf[7];
+		r3 = buf[4] - buf[6];
+		i3 = buf[5] - buf[7];
+
+		r4 = (r0 + r2) >> 1;
+		i4 = (i0 + i2) >> 1;
+		r5 = (r0 - r2) >> 1;
+		i5 = (i0 - i2) >> 1;
+		r6 = (r1 - i3) >> 1;
+		i6 = (i1 + r3) >> 1;
+		r7 = (r1 + i3) >> 1;
+		i7 = (i1 - r3) >> 1;
+
+		r0 = buf[ 8] + buf[10];
+		i0 = buf[ 9] + buf[11];
+		r1 = buf[ 8] - buf[10];
+		i1 = buf[ 9] - buf[11];
+		r2 = buf[12] + buf[14];
+		i2 = buf[13] + buf[15];
+		r3 = buf[12] - buf[14];
+		i3 = buf[13] - buf[15];
+
+		t0 = (r0 + r2) >> 1;
+		t1 = (i0 + i2) >> 1;
+		t2 = (r0 - r2) >> 1;
+		t3 = (i0 - i2) >> 1;
+
+		buf[ 0] = r4 + t0;
+		buf[ 1] = i4 + t1;
+		buf[ 8] = r4 - t0;
+		buf[ 9] = i4 - t1;
+		buf[ 4] = r5 + t3;
+		buf[ 5] = i5 - t2;
+		buf[12] = r5 - t3;
+		buf[13] = i5 + t2;
+
+		r0 = r1 - i3;
+		i0 = i1 + r3;
+		r2 = r1 + i3;
+		i2 = i1 - r3;
+
+		t0 = MULHIGH(SQRT1_2, r0 - i0);
+		t1 = MULHIGH(SQRT1_2, r0 + i0);
+		t2 = MULHIGH(SQRT1_2, r2 - i2);
+		t3 = MULHIGH(SQRT1_2, r2 + i2);
+
+		buf[ 6] = r6 - t0;
+		buf[ 7] = i6 - t1;
+		buf[14] = r6 + t0;
+		buf[15] = i6 + t1;
+		buf[ 2] = r7 + t3;
+		buf[ 3] = i7 - t2;
+		buf[10] = r7 - t3;
+		buf[11] = i7 + t2;
+
+		buf += 16;
+	}
+}
+
 /*****************************************************************************
 *
 * function name: Radix4FFT
 * description:  Radix 4 point fft core function
 *
-**********************************************************************************/
-static void Radix4FFT(int *buf, int num, int bgn, int *twidTab)
-{
-	int r0, r1, r2, r3;
-	int r4, r5, r6, r7;
-	int t0, t1;
-	int sinx, cosx;
-	int i, j, step;
-	int *xptr, *csptr;
-
-	for (num >>= 2; num != 0; num >>= 2) 
-	{
-		step = 2*bgn;
-		xptr = buf;
-
-    	for (i = num; i != 0; i--) 
-		{
-			csptr = twidTab;
-
-			for (j = bgn; j != 0; j--) 
-			{
-				r0 = xptr[0];
-				r1 = xptr[1];
-				xptr += step;
-				
-				t0 = xptr[0];
-				t1 = xptr[1];				
-				cosx = csptr[0];
-				sinx = csptr[1];
-				r2 = MULHIGH(cosx, t0) + MULHIGH(sinx, t1);		/* cos*br + sin*bi */
-				r3 = MULHIGH(cosx, t1) - MULHIGH(sinx, t0);		/* cos*bi - sin*br */
-				xptr += step;
-
-				t0 = r0 >> 2;
-				t1 = r1 >> 2;
-				r0 = t0 - r2;
-				r1 = t1 - r3;
-				r2 = t0 + r2;
-				r3 = t1 + r3;
-				
-				t0 = xptr[0];
-				t1 = xptr[1];
-				cosx = csptr[2];
-				sinx = csptr[3];
-				r4 = MULHIGH(cosx, t0) + MULHIGH(sinx, t1);		/* cos*cr + sin*ci */
-				r5 = MULHIGH(cosx, t1) - MULHIGH(sinx, t0);		/* cos*ci - sin*cr */
-				xptr += step;
-				
-				t0 = xptr[0];
-				t1 = xptr[1];
-				cosx = csptr[4];
-				sinx = csptr[5];
-				r6 = MULHIGH(cosx, t0) + MULHIGH(sinx, t1);		/* cos*cr + sin*ci */
-				r7 = MULHIGH(cosx, t1) - MULHIGH(sinx, t0);		/* cos*ci - sin*cr */
-				csptr += 6;
-
-				t0 = r4;
-				t1 = r5;
-				r4 = t0 + r6;
-				r5 = r7 - t1;
-				r6 = t0 - r6;
-				r7 = r7 + t1;
-
-				xptr[0] = r0 + r5;
-				xptr[1] = r1 + r6;
-				xptr -= step;
-
-				xptr[0] = r2 - r4;
-				xptr[1] = r3 - r7;
-				xptr -= step;
-
-				xptr[0] = r0 - r5;
-				xptr[1] = r1 - r6;
-				xptr -= step;
-
-				xptr[0] = r2 + r4;
-				xptr[1] = r3 + r7;
-				xptr += 2;
-			}
-			xptr += 3*step;
-		}
-		twidTab += 3*step;
-		bgn <<= 2;
-	}
-}
-
+**********************************************************************************/
+static void Radix4FFT(int *buf, int num, int bgn, int *twidTab)
+{
+	int r0, r1, r2, r3;
+	int r4, r5, r6, r7;
+	int t0, t1;
+	int sinx, cosx;
+	int i, j, step;
+	int *xptr, *csptr;
+
+	for (num >>= 2; num != 0; num >>= 2)
+	{
+		step = 2*bgn;
+		xptr = buf;
+
+    	for (i = num; i != 0; i--)
+		{
+			csptr = twidTab;
+
+			for (j = bgn; j != 0; j--)
+			{
+				r0 = xptr[0];
+				r1 = xptr[1];
+				xptr += step;
+
+				t0 = xptr[0];
+				t1 = xptr[1];
+				cosx = csptr[0];
+				sinx = csptr[1];
+				r2 = MULHIGH(cosx, t0) + MULHIGH(sinx, t1);		/* cos*br + sin*bi */
+				r3 = MULHIGH(cosx, t1) - MULHIGH(sinx, t0);		/* cos*bi - sin*br */
+				xptr += step;
+
+				t0 = r0 >> 2;
+				t1 = r1 >> 2;
+				r0 = t0 - r2;
+				r1 = t1 - r3;
+				r2 = t0 + r2;
+				r3 = t1 + r3;
+
+				t0 = xptr[0];
+				t1 = xptr[1];
+				cosx = csptr[2];
+				sinx = csptr[3];
+				r4 = MULHIGH(cosx, t0) + MULHIGH(sinx, t1);		/* cos*cr + sin*ci */
+				r5 = MULHIGH(cosx, t1) - MULHIGH(sinx, t0);		/* cos*ci - sin*cr */
+				xptr += step;
+
+				t0 = xptr[0];
+				t1 = xptr[1];
+				cosx = csptr[4];
+				sinx = csptr[5];
+				r6 = MULHIGH(cosx, t0) + MULHIGH(sinx, t1);		/* cos*cr + sin*ci */
+				r7 = MULHIGH(cosx, t1) - MULHIGH(sinx, t0);		/* cos*ci - sin*cr */
+				csptr += 6;
+
+				t0 = r4;
+				t1 = r5;
+				r4 = t0 + r6;
+				r5 = r7 - t1;
+				r6 = t0 - r6;
+				r7 = r7 + t1;
+
+				xptr[0] = r0 + r5;
+				xptr[1] = r1 + r6;
+				xptr -= step;
+
+				xptr[0] = r2 - r4;
+				xptr[1] = r3 - r7;
+				xptr -= step;
+
+				xptr[0] = r0 - r5;
+				xptr[1] = r1 - r6;
+				xptr -= step;
+
+				xptr[0] = r2 + r4;
+				xptr[1] = r3 + r7;
+				xptr += 2;
+			}
+			xptr += 3*step;
+		}
+		twidTab += 3*step;
+		bgn <<= 2;
+	}
+}
+
 /*********************************************************************************
 *
 * function name: PreMDCT
 * description:  prepare MDCT process for next FFT compute
 *
-**********************************************************************************/
-static void PreMDCT(int *buf0, int num, const int *csptr)
-{
-	int i;
-	int tr1, ti1, tr2, ti2;
-	int cosa, sina, cosb, sinb;
-	int *buf1;
-	
-	buf1 = buf0 + num - 1;
-
-	for(i = num >> 2; i != 0; i--)
-	{
-		cosa = *csptr++;	
-		sina = *csptr++;	
-		cosb = *csptr++;	
-		sinb = *csptr++;		
-
-		tr1 = *(buf0 + 0);
-		ti2 = *(buf0 + 1);
-		tr2 = *(buf1 - 1);
-		ti1 = *(buf1 + 0);
-		
-		*buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1);
-		*buf0++ = MULHIGH(cosa, ti1) - MULHIGH(sina, tr1);		
-		
-		*buf1-- = MULHIGH(cosb, ti2) - MULHIGH(sinb, tr2);		
-		*buf1-- = MULHIGH(cosb, tr2) + MULHIGH(sinb, ti2);
-	}
-}
-
+**********************************************************************************/
+static void PreMDCT(int *buf0, int num, const int *csptr)
+{
+	int i;
+	int tr1, ti1, tr2, ti2;
+	int cosa, sina, cosb, sinb;
+	int *buf1;
+
+	buf1 = buf0 + num - 1;
+
+	for(i = num >> 2; i != 0; i--)
+	{
+		cosa = *csptr++;
+		sina = *csptr++;
+		cosb = *csptr++;
+		sinb = *csptr++;
+
+		tr1 = *(buf0 + 0);
+		ti2 = *(buf0 + 1);
+		tr2 = *(buf1 - 1);
+		ti1 = *(buf1 + 0);
+
+		*buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1);
+		*buf0++ = MULHIGH(cosa, ti1) - MULHIGH(sina, tr1);
+
+		*buf1-- = MULHIGH(cosb, ti2) - MULHIGH(sinb, tr2);
+		*buf1-- = MULHIGH(cosb, tr2) + MULHIGH(sinb, ti2);
+	}
+}
+
 /*********************************************************************************
 *
 * function name: PostMDCT
 * description:   post MDCT process after next FFT for MDCT
 *
-**********************************************************************************/
-static void PostMDCT(int *buf0, int num, const int *csptr)
-{
-	int i;
-	int tr1, ti1, tr2, ti2;
-	int cosa, sina, cosb, sinb;
-	int *buf1;
-
-	buf1 = buf0 + num - 1;
-	
-	for(i = num >> 2; i != 0; i--)
-	{
-		cosa = *csptr++;	
-		sina = *csptr++;	
-		cosb = *csptr++;	
-		sinb = *csptr++;
-
-		tr1 = *(buf0 + 0);
-		ti1 = *(buf0 + 1);
-		ti2 = *(buf1 + 0);
-		tr2 = *(buf1 - 1);
-
-		*buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1);
-		*buf1-- = MULHIGH(sina, tr1) - MULHIGH(cosa, ti1);		
-		
-		*buf0++ = MULHIGH(sinb, tr2) - MULHIGH(cosb, ti2);
-		*buf1-- = MULHIGH(cosb, tr2) + MULHIGH(sinb, ti2);	
-	}
-}
-#endif
-
-
+**********************************************************************************/
+static void PostMDCT(int *buf0, int num, const int *csptr)
+{
+	int i;
+	int tr1, ti1, tr2, ti2;
+	int cosa, sina, cosb, sinb;
+	int *buf1;
+
+	buf1 = buf0 + num - 1;
+
+	for(i = num >> 2; i != 0; i--)
+	{
+		cosa = *csptr++;
+		sina = *csptr++;
+		cosb = *csptr++;
+		sinb = *csptr++;
+
+		tr1 = *(buf0 + 0);
+		ti1 = *(buf0 + 1);
+		ti2 = *(buf1 + 0);
+		tr2 = *(buf1 - 1);
+
+		*buf0++ = MULHIGH(cosa, tr1) + MULHIGH(sina, ti1);
+		*buf1-- = MULHIGH(sina, tr1) - MULHIGH(cosa, ti1);
+
+		*buf0++ = MULHIGH(sinb, tr2) - MULHIGH(cosb, ti2);
+		*buf1-- = MULHIGH(cosb, tr2) + MULHIGH(sinb, ti2);
+	}
+}
+#endif
+
+
 /**********************************************************************************
 *
 * function name: Mdct_Long
 * description:  the long block mdct, include long_start block, end_long block
 *
-**********************************************************************************/
-void Mdct_Long(int *buf)
-{
-	PreMDCT(buf, 1024, cossintab + 128);
-
-	Shuffle(buf, 512, bitrevTab + 17);
-	Radix8First(buf, 512 >> 3);						
-	Radix4FFT(buf, 512 >> 3, 8, (int *)twidTab512);
-
-	PostMDCT(buf, 1024, cossintab + 128);	
-}
-
-
+**********************************************************************************/
+void Mdct_Long(int *buf)
+{
+	PreMDCT(buf, 1024, cossintab + 128);
+
+	Shuffle(buf, 512, bitrevTab + 17);
+	Radix8First(buf, 512 >> 3);
+	Radix4FFT(buf, 512 >> 3, 8, (int *)twidTab512);
+
+	PostMDCT(buf, 1024, cossintab + 128);
+}
+
+
 /**********************************************************************************
 *
 * function name: Mdct_Short
-* description:  the short block mdct 
+* description:  the short block mdct
 *
-**********************************************************************************/
-void Mdct_Short(int *buf)
-{
-	PreMDCT(buf, 128, cossintab);
-
-	Shuffle(buf, 64, bitrevTab);
-	Radix4First(buf, 64 >> 2);						
-	Radix4FFT(buf, 64 >> 2, 4, (int *)twidTab64);	
-
-	PostMDCT(buf, 128, cossintab);	
-}
+**********************************************************************************/
+void Mdct_Short(int *buf)
+{
+	PreMDCT(buf, 128, cossintab);
+
+	Shuffle(buf, 64, bitrevTab);
+	Radix4First(buf, 64 >> 2);
+	Radix4FFT(buf, 64 >> 2, 4, (int *)twidTab64);
+
+	PostMDCT(buf, 128, cossintab);
+}
 
 
 /*****************************************************************************
 *
 * function name: shiftMdctDelayBuffer
 * description:    the mdct delay buffer has a size of 1600,
-*  so the calculation of LONG,STOP must be  spilt in two 
+*  so the calculation of LONG,STOP must be  spilt in two
 *  passes with 1024 samples and a mid shift,
 *  the SHORT transforms can be completed in the delay buffer,
 *  and afterwards a shift
@@ -409,7 +409,7 @@ static void shiftMdctDelayBuffer(Word16 *mdctDelayBuffer, /*! start of mdct dela
 	dsBuf = timeSignal;
 
 	for(i=0; i<FRAME_LEN_LONG; i+=8)
-	{   
+	{
 		*srBuf++ = *dsBuf; dsBuf += chIncrement;
 		*srBuf++ = *dsBuf; dsBuf += chIncrement;
 		*srBuf++ = *dsBuf; dsBuf += chIncrement;
@@ -419,31 +419,31 @@ static void shiftMdctDelayBuffer(Word16 *mdctDelayBuffer, /*! start of mdct dela
 		*srBuf++ = *dsBuf; dsBuf += chIncrement;
 		*srBuf++ = *dsBuf; dsBuf += chIncrement;
 	}
-}
-
-
+}
+
+
 /*****************************************************************************
 *
 * function name: getScalefactorOfShortVectorStride
 * description:  Calculate max possible scale factor for input vector of shorts
 * returns:      Maximum scale factor
 *
-**********************************************************************************/
-static Word16 getScalefactorOfShortVectorStride(const Word16 *vector, /*!< Pointer to input vector */
-												Word16 len,           /*!< Length of input vector */
-												Word16 stride)        /*!< Stride of input vector */
-{
-	Word16 maxVal = 0;
-	Word16 absVal;
-	Word16 i;
-
-	for(i=0; i<len; i++){
-		absVal = abs_s(vector[i*stride]);
-		maxVal |= absVal;
-	}
-
-	return( maxVal ? norm_s(maxVal) : 15);
-}
+**********************************************************************************/
+static Word16 getScalefactorOfShortVectorStride(const Word16 *vector, /*!< Pointer to input vector */
+												Word16 len,           /*!< Length of input vector */
+												Word16 stride)        /*!< Stride of input vector */
+{
+	Word16 maxVal = 0;
+	Word16 absVal;
+	Word16 i;
+
+	for(i=0; i<len; i++){
+		absVal = abs_s(vector[i*stride]);
+		maxVal |= absVal;
+	}
+
+	return( maxVal ? norm_s(maxVal) : 15);
+}
 
 
 /*****************************************************************************
@@ -464,16 +464,16 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 	Word32 i,w;
 	Word32 timeSignalSample;
 	Word32 ws1,ws2;
-	Word16 *dctIn0, *dctIn1;
-	Word32 *outData0, *outData1;
+	Word16 *dctIn0, *dctIn1;
+	Word32 *outData0, *outData1;
 	Word32 *winPtr;
 
 	Word32 delayBufferSf,timeSignalSf,minSf;
 	Word32 headRoom=0;
-	
+
 	switch(blockType){
-		
-		
+
+
 	case LONG_WINDOW:
 		/*
 		we access BLOCK_SWITCHING_OFFSET (1600 ) delay buffer samples + 448 new timeSignal samples
@@ -483,15 +483,15 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 		timeSignalSf  = getScalefactorOfShortVectorStride(timeSignal,2*FRAME_LEN_LONG-BLOCK_SWITCHING_OFFSET,chIncrement);
 		minSf = min(delayBufferSf,timeSignalSf);
 		minSf = min(minSf,14);
-		
+
 		dctIn0 = mdctDelayBuffer;
 		dctIn1 = mdctDelayBuffer + FRAME_LEN_LONG - 1;
 		outData0 = realOut + FRAME_LEN_LONG/2;
-		
+
 		/* add windows and pre add for mdct to last buffer*/
 		winPtr = (int *)LongWindowKBD;
 		for(i=0;i<FRAME_LEN_LONG/2;i++){
-			timeSignalSample = (*dctIn0++) << minSf; 
+			timeSignalSample = (*dctIn0++) << minSf;
 			ws1 = timeSignalSample * (*winPtr >> 16);
 			timeSignalSample = (*dctIn1--) << minSf;
 			ws2 = timeSignalSample * (*winPtr & 0xffff);
@@ -499,30 +499,30 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 			/* shift 2 to avoid overflow next */
 			*outData0++ = (ws1 >> 2) - (ws2 >> 2);
 		}
-		
+
 		shiftMdctDelayBuffer(mdctDelayBuffer,timeSignal,chIncrement);
-		
+
 		/* add windows and pre add for mdct to new buffer*/
 		dctIn0 = mdctDelayBuffer;
 		dctIn1 = mdctDelayBuffer + FRAME_LEN_LONG - 1;
-		outData0 = realOut + FRAME_LEN_LONG/2 - 1; 
+		outData0 = realOut + FRAME_LEN_LONG/2 - 1;
 		winPtr = (int *)LongWindowKBD;
-		for(i=0;i<FRAME_LEN_LONG/2;i++){    
+		for(i=0;i<FRAME_LEN_LONG/2;i++){
 			timeSignalSample = (*dctIn0++) << minSf;
 			ws1 = timeSignalSample * (*winPtr & 0xffff);
 			timeSignalSample = (*dctIn1--) << minSf;
 			ws2 = timeSignalSample * (*winPtr >> 16);
 			winPtr++;
 			/* shift 2 to avoid overflow next */
-			*outData0-- = -((ws1 >> 2) + (ws2 >> 2)); 
+			*outData0-- = -((ws1 >> 2) + (ws2 >> 2));
 		}
 
-		Mdct_Long(realOut);
-		/* update scale factor */
+		Mdct_Long(realOut);
+		/* update scale factor */
 		minSf = 14 - minSf;
-		*mdctScale=minSf; 
+		*mdctScale=minSf;
 		break;
-		
+
 	case START_WINDOW:
 		/*
 		we access BLOCK_SWITCHING_OFFSET (1600 ) delay buffer samples + no timeSignal samples
@@ -533,7 +533,7 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 
 		dctIn0 = mdctDelayBuffer;
 		dctIn1 = mdctDelayBuffer + FRAME_LEN_LONG - 1;
-		outData0 = realOut + FRAME_LEN_LONG/2; 		
+		outData0 = realOut + FRAME_LEN_LONG/2;
 		winPtr = (int *)LongWindowKBD;
 
 		/* add windows and pre add for mdct to last buffer*/
@@ -543,20 +543,20 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 			timeSignalSample = (*dctIn1--) << minSf;
 			ws2 = timeSignalSample * (*winPtr & 0xffff);
 			winPtr ++;
-			*outData0++ = (ws1 >> 2) - (ws2 >> 2);  /* shift 2 to avoid overflow next */
+			*outData0++ = (ws1 >> 2) - (ws2 >> 2);  /* shift 2 to avoid overflow next */
 		}
-		
+
 		shiftMdctDelayBuffer(mdctDelayBuffer,timeSignal,chIncrement);
-		
-		outData0 = realOut + FRAME_LEN_LONG/2 - 1; 
+
+		outData0 = realOut + FRAME_LEN_LONG/2 - 1;
 		for(i=0;i<LS_TRANS;i++){
-			*outData0-- = -mdctDelayBuffer[i] << (15 - 2 + minSf);  
+			*outData0-- = -mdctDelayBuffer[i] << (15 - 2 + minSf);
 		}
-		
+
 		/* add windows and pre add for mdct to new buffer*/
 		dctIn0 = mdctDelayBuffer + LS_TRANS;
 		dctIn1 = mdctDelayBuffer + FRAME_LEN_LONG - 1 - LS_TRANS;
-		outData0 = realOut + FRAME_LEN_LONG/2 - 1 -LS_TRANS; 
+		outData0 = realOut + FRAME_LEN_LONG/2 - 1 -LS_TRANS;
 		winPtr = (int *)ShortWindowSine;
 		for(i=0;i<FRAME_LEN_SHORT/2;i++){
 			timeSignalSample= (*dctIn0++) << minSf;
@@ -564,7 +564,7 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 			timeSignalSample= (*dctIn1--) << minSf;
 			ws2 = timeSignalSample * (*winPtr >> 16);
 			winPtr++;
-			*outData0-- =  -((ws1 >> 2) + (ws2 >> 2));  /* shift 2 to avoid overflow next */
+			*outData0-- =  -((ws1 >> 2) + (ws2 >> 2));  /* shift 2 to avoid overflow next */
 		}
 
 		Mdct_Long(realOut);
@@ -572,7 +572,7 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 		minSf = 14 - minSf;
 		*mdctScale= minSf;
 		break;
-		
+
 	case STOP_WINDOW:
 		/*
 		we access BLOCK_SWITCHING_OFFSET-LS_TRANS (1600-448 ) delay buffer samples + 448 new timeSignal samples
@@ -580,19 +580,19 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 		*/
 		delayBufferSf = getScalefactorOfShortVectorStride(mdctDelayBuffer+LS_TRANS,BLOCK_SWITCHING_OFFSET-LS_TRANS,1);
 		timeSignalSf  = getScalefactorOfShortVectorStride(timeSignal,2*FRAME_LEN_LONG-BLOCK_SWITCHING_OFFSET,chIncrement);
-		minSf = min(delayBufferSf,timeSignalSf);    
+		minSf = min(delayBufferSf,timeSignalSf);
 		minSf = min(minSf,13);
-		
+
 		outData0 = realOut + FRAME_LEN_LONG/2;
 		dctIn1 = mdctDelayBuffer + FRAME_LEN_LONG - 1;
 		for(i=0;i<LS_TRANS;i++){
-			*outData0++ = -(*dctIn1--) << (15 - 2 + minSf);    
+			*outData0++ = -(*dctIn1--) << (15 - 2 + minSf);
 		}
-		
+
 		/* add windows and pre add for mdct to last buffer*/
 		dctIn0 = mdctDelayBuffer + LS_TRANS;
 		dctIn1 = mdctDelayBuffer + FRAME_LEN_LONG - 1 - LS_TRANS;
-		outData0 = realOut + FRAME_LEN_LONG/2 + LS_TRANS; 
+		outData0 = realOut + FRAME_LEN_LONG/2 + LS_TRANS;
 		winPtr = (int *)ShortWindowSine;
 		for(i=0;i<FRAME_LEN_SHORT/2;i++){
 			timeSignalSample = (*dctIn0++) << minSf;
@@ -600,44 +600,44 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 			timeSignalSample= (*dctIn1--) << minSf;
 			ws2 = timeSignalSample * (*winPtr & 0xffff);
 			winPtr++;
-			*outData0++ = (ws1 >> 2) - (ws2 >> 2);  /* shift 2 to avoid overflow next */
+			*outData0++ = (ws1 >> 2) - (ws2 >> 2);  /* shift 2 to avoid overflow next */
 		}
-		
+
 		shiftMdctDelayBuffer(mdctDelayBuffer,timeSignal,chIncrement);
-		
+
 		/* add windows and pre add for mdct to new buffer*/
 		dctIn0 = mdctDelayBuffer;
 		dctIn1 = mdctDelayBuffer + FRAME_LEN_LONG - 1;
-		outData0 = realOut + FRAME_LEN_LONG/2 - 1; 
+		outData0 = realOut + FRAME_LEN_LONG/2 - 1;
 		winPtr = (int *)LongWindowKBD;
 		for(i=0;i<FRAME_LEN_LONG/2;i++){
 			timeSignalSample= (*dctIn0++) << minSf;
 			ws1 = timeSignalSample *(*winPtr & 0xffff);
 			timeSignalSample= (*dctIn1--) << minSf;
 			ws2 = timeSignalSample * (*winPtr >> 16);
-			*outData0-- =  -((ws1 >> 2) + (ws2 >> 2));  /* shift 2 to avoid overflow next */
-			winPtr++;
+			*outData0-- =  -((ws1 >> 2) + (ws2 >> 2));  /* shift 2 to avoid overflow next */
+			winPtr++;
 		}
-		
+
 		Mdct_Long(realOut);
 		minSf = 14 - minSf;
 		*mdctScale= minSf; /* update scale factor */
 		break;
-		
+
 	case SHORT_WINDOW:
 		/*
 		we access BLOCK_SWITCHING_OFFSET (1600 ) delay buffer samples + no new timeSignal samples
 		and get the biggest scale factor for next calculate more precise
-		*/		
+		*/
 		minSf = getScalefactorOfShortVectorStride(mdctDelayBuffer+TRANSFORM_OFFSET_SHORT,9*FRAME_LEN_SHORT,1);
 		minSf = min(minSf,10);
-		
-		
+
+
 		for(w=0;w<TRANS_FAC;w++){
 			dctIn0 = mdctDelayBuffer+w*FRAME_LEN_SHORT+TRANSFORM_OFFSET_SHORT;
 			dctIn1 = mdctDelayBuffer+w*FRAME_LEN_SHORT+TRANSFORM_OFFSET_SHORT + FRAME_LEN_SHORT-1;
-			outData0 = realOut + FRAME_LEN_SHORT/2; 
-			outData1 = realOut + FRAME_LEN_SHORT/2 - 1; 
+			outData0 = realOut + FRAME_LEN_SHORT/2;
+			outData1 = realOut + FRAME_LEN_SHORT/2 - 1;
 
 			winPtr = (int *)ShortWindowSine;
 			for(i=0;i<FRAME_LEN_SHORT/2;i++){
@@ -645,26 +645,26 @@ void Transform_Real(Word16 *mdctDelayBuffer,
 				ws1 = timeSignalSample * (*winPtr >> 16);
 				timeSignalSample= *dctIn1 << minSf;
 				ws2 = timeSignalSample * (*winPtr & 0xffff);
-				*outData0++ = (ws1 >> 2) - (ws2 >> 2);  /* shift 2 to avoid overflow next */
-				
+				*outData0++ = (ws1 >> 2) - (ws2 >> 2);  /* shift 2 to avoid overflow next */
+
 				timeSignalSample= *(dctIn0 + FRAME_LEN_SHORT) << minSf;
 				ws1 = timeSignalSample * (*winPtr & 0xffff);
 				timeSignalSample= *(dctIn1 + FRAME_LEN_SHORT) << minSf;
 				ws2 = timeSignalSample * (*winPtr >> 16);
-				*outData1-- =  -((ws1 >> 2) + (ws2 >> 2));  /* shift 2 to avoid overflow next */
-
-				winPtr++;
-				dctIn0++;
-				dctIn1--;
+				*outData1-- =  -((ws1 >> 2) + (ws2 >> 2));  /* shift 2 to avoid overflow next */
+
+				winPtr++;
+				dctIn0++;
+				dctIn1--;
 			}
 
 			Mdct_Short(realOut);
 			realOut += FRAME_LEN_SHORT;
 		}
-		
+
 		minSf = 11 - minSf;
 		*mdctScale = minSf; /* update scale factor */
-		
+
 		shiftMdctDelayBuffer(mdctDelayBuffer,timeSignal,chIncrement);
 		break;
   }
diff --git a/media/libstagefright/codecs/amrnb/dec/AMRNBDecoder.cpp b/media/libstagefright/codecs/amrnb/dec/AMRNBDecoder.cpp
index fb300da..342236d 100644
--- a/media/libstagefright/codecs/amrnb/dec/AMRNBDecoder.cpp
+++ b/media/libstagefright/codecs/amrnb/dec/AMRNBDecoder.cpp
@@ -122,7 +122,8 @@ status_t AMRNBDecoder::read(
         CHECK(seekTimeUs >= 0);
 
         mNumSamplesOutput = 0;
-
+        //Reset decoder in case of seek to 0
+        Speech_Decode_Frame_reset(mState);
         if (mInputBuffer) {
             mInputBuffer->release();
             mInputBuffer = NULL;
@@ -161,6 +162,11 @@ status_t AMRNBDecoder::read(
           static_cast<int16_t *>(buffer->data()),
           MIME_IETF);
 
+    if (numBytesRead == -1 ) {
+        buffer->release();
+        buffer = NULL;
+        return ERROR_MALFORMED;
+    }
     ++numBytesRead;  // Include the frame type header byte.
 
     buffer->set_range(0, kNumSamplesPerFrame * sizeof(int16_t));
diff --git a/media/libstagefright/codecs/amrwb/AMRWBDecoder.cpp b/media/libstagefright/codecs/amrwb/AMRWBDecoder.cpp
index 2a21472..baaf3f5 100644
--- a/media/libstagefright/codecs/amrwb/AMRWBDecoder.cpp
+++ b/media/libstagefright/codecs/amrwb/AMRWBDecoder.cpp
@@ -116,15 +116,26 @@ sp<MetaData> AMRWBDecoder::getFormat() {
 }
 
 static size_t getFrameSize(unsigned FT) {
-    static const size_t kFrameSizeWB[9] = {
-        132, 177, 253, 285, 317, 365, 397, 461, 477
+    static const size_t kFrameSizeWB[16] = { 18      // AMR-WB 6.60 Kbps
+          , 24        // AMR-WB 8.85 Kbps
+          , 33        // AMR-WB 12.65 Kbps
+          , 37        // AMR-WB 14.25 Kbps
+          , 41        // AMR-WB 15.85 Kbps
+          , 47        // AMR-WB 18.25 Kbps
+          , 51        // AMR-WB 19.85 Kbps
+          , 59        // AMR-WB 23.05 Kbps
+          , 61        // AMR-WB 23.85 Kbps
+          , 6     // AMR-WB SID
+          , 1
+          , 1
+          , 1
+          , 1
+          , 1     // WBAMR Frame No Data
+          , 1     // WBAMR Frame No Data
     };
 
     size_t frameSize = kFrameSizeWB[FT];
 
-    // Round up bits to bytes and add 1 for the header byte.
-    frameSize = (frameSize + 7) / 8 + 1;
-
     return frameSize;
 }
 
diff --git a/media/libstagefright/codecs/amrwbenc/Android.mk b/media/libstagefright/codecs/amrwbenc/Android.mk
index 4293287..7141cba 100644
--- a/media/libstagefright/codecs/amrwbenc/Android.mk
+++ b/media/libstagefright/codecs/amrwbenc/Android.mk
@@ -3,7 +3,7 @@ include $(CLEAR_VARS)
 include frameworks/base/media/libstagefright/codecs/common/Config.mk
 
 LOCAL_PRELINK_MODULE := false
- 	
+
 LOCAL_SRC_FILES := \
 	AMRWBEncoder.cpp \
 	src/autocorr.c \
@@ -91,7 +91,7 @@ LOCAL_MODULE := libstagefright_amrwbenc
 
 LOCAL_ARM_MODE := arm
 
-LOCAL_STATIC_LIBRARIES := 
+LOCAL_STATIC_LIBRARIES :=
 
 LOCAL_SHARED_LIBRARIES :=
 
diff --git a/media/libstagefright/codecs/amrwbenc/SampleCode/AMRWB_E_SAMPLE.c b/media/libstagefright/codecs/amrwbenc/SampleCode/AMRWB_E_SAMPLE.c
index 792d3cc..c094d41 100644
--- a/media/libstagefright/codecs/amrwbenc/SampleCode/AMRWB_E_SAMPLE.c
+++ b/media/libstagefright/codecs/amrwbenc/SampleCode/AMRWB_E_SAMPLE.c
@@ -1,364 +1,364 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-#ifdef LINUX
-#include <dlfcn.h>
-#endif
-
-#include      <stdio.h>
-#include      <stdlib.h>
-#include      <time.h>
-#include      "voAMRWB.h"
-#include      "cmnMemory.h"
-
-#define VOAMRWB_RFC3267_HEADER_INFO "#!AMR-WB\n"
-
-#define  INPUT_SIZE   640
-#define  OUTPUT_SIZE  1024
-unsigned char  InputBuf[INPUT_SIZE];
-unsigned char  OutputBuf[OUTPUT_SIZE];
-
-void usage (void) {
-	printf ("AMR_WB Encoder HELP   Displays this text\n");
-	printf ("\n");
-	printf ("Usage:\n");
-	printf ("AMRWBEnc [options] Input_file output_file \n");
-	printf ("\n");
-	printf ("Options +M* +F* +DTX \n");
-	printf ("Support \n");
-	printf ("Options +M* for seting compression bitrate mode, default is 23.85kbps\n");
-	printf (" +M0 = 6.6kbps \n");
-	printf (" +M1 = 8.85kbps \n");
-	printf (" +M2 = 12.65kbps \n");
-	printf (" +M3 = 14.25kbps \n");
-	printf (" +M4 = 15.58kbps \n");
-	printf (" +M5 = 18.25kbps \n");
-	printf (" +M6 = 19.85kbps \n");
-	printf (" +M7 = 23.05kbps \n");
-	printf (" +M8 = 23.85kbps \n");
-	printf ("\n");
-	printf ("Options +F* for setting output frame Type, default is RFC3267 \n");
-	printf ("+F0 for AMR_WB Defualt bit extern short data frame type \n");
-	printf ("+F1 for AMR_WB_ITU bit extern short data frame type \n");
-	printf ("+F2 for RFC3267\n ");
-	printf ("\n");
-	printf ("Options +DTX enable DTX mode, default is disable.\n");
-	printf ("File names, input raw PCM data, and output is AMR_WB bit-stream file.\n");
-	printf ("\n");
-}
-
-int  GetNextBuf(FILE* inFile,unsigned char* dst,int size)
-{
-	int size2 = (int)fread(dst, sizeof(signed char), size,inFile);
-	return size2;
-}
-
-typedef int (VO_API * VOGETAUDIOENCAPI) (VO_AUDIO_CODECAPI * pEncHandle);
-
-int encode(
-		   int mode, 
-		   short   allow_dtx,
-		   VOAMRWBFRAMETYPE frameType,
-		   const char* srcfile, 
-		   const char* dstfile
-		   )
-{
-	int			ret = 0;
-	int         returnCode;
-	FILE		*fsrc = NULL;
-	FILE		*fdst = NULL;
-	int         framenum = 0;
-	int         eofFile = 0;
-	int         size1 = 0;
-	int         Relens;
-
-	VO_AUDIO_CODECAPI       AudioAPI;
-	VO_MEM_OPERATOR         moper;
-	VO_CODEC_INIT_USERDATA  useData;
-	VO_HANDLE               hCodec;
-	VO_CODECBUFFER          inData;
-	VO_CODECBUFFER          outData;
-	VO_AUDIO_OUTPUTINFO     outFormat;
-
-	unsigned char *inBuf = InputBuf;
-	unsigned char *outBuf = OutputBuf;
-
-
-#ifdef LINUX
-	void  *handle = NULL;
-	void  *pfunc;
-	VOGETAUDIOENCAPI pGetAPI;
-#endif
-
-	clock_t   start, finish;
-	double    duration = 0.0;
-
-	if ((fsrc = fopen (srcfile, "rb")) == NULL)
-	{
-		ret = -1;
-		goto safe_exit;
-	}
-
-	if ((fdst = fopen (dstfile, "wb")) == NULL)
-	{
-		ret = -1;
-		goto safe_exit;
-	}
-
-	moper.Alloc = cmnMemAlloc;
-	moper.Copy = cmnMemCopy;
-	moper.Free = cmnMemFree;
-	moper.Set = cmnMemSet;
-	moper.Check = cmnMemCheck;
-
-	useData.memflag = VO_IMF_USERMEMOPERATOR;
-	useData.memData = (VO_PTR)(&moper);
-
-#ifdef LINUX
-	handle = dlopen("/data/local/tmp/voAMRWBEnc.so", RTLD_NOW);
-	if(handle == 0)
-	{
-		printf("open dll error......");
-		return -1;
-	}
-
-	pfunc = dlsym(handle, "voGetAMRWBEncAPI");	
-	if(pfunc == 0)
-	{
-		printf("open function error......");
-		return -1;
-	}
-
-	pGetAPI = (VOGETAUDIOENCAPI)pfunc;
-
-	returnCode  = pGetAPI(&AudioAPI);
-	if(returnCode)
-	{
-		printf("get APIs error......");
-		return -1;
-	}
-#else
-	ret = voGetAMRWBEncAPI(&AudioAPI);
-	if(ret)
-	{
-		ret = -1;
-		printf("get APIs error......");
-		goto safe_exit;
-	}
-#endif 
-
-	//#######################################   Init Encoding Section   #########################################
-	ret = AudioAPI.Init(&hCodec, VO_AUDIO_CodingAMRWB, &useData);
-
-	if(ret)
-	{
-		ret = -1;
-		printf("APIs init error......");
-		goto safe_exit;
-	}
-
-	Relens = GetNextBuf(fsrc,InputBuf,INPUT_SIZE);
-	if(Relens!=INPUT_SIZE && !feof(fsrc))
-	{
-		ret = -1; //Invalid magic number
-		printf("get next buffer error......");
-		goto safe_exit;
-	}
-
-	//###################################### set encode Mode ##################################################
-	ret = AudioAPI.SetParam(hCodec, VO_PID_AMRWB_FRAMETYPE, &frameType);
-	ret = AudioAPI.SetParam(hCodec, VO_PID_AMRWB_MODE, &mode);
-	ret = AudioAPI.SetParam(hCodec, VO_PID_AMRWB_DTX, &allow_dtx);
-
-	if(frameType == VOAMRWB_RFC3267)
-	{
-		/* write RFC3267 Header info to indicate single channel AMR file storage format */
-		size1 = (int)strlen(VOAMRWB_RFC3267_HEADER_INFO);
-		memcpy(outBuf, VOAMRWB_RFC3267_HEADER_INFO, size1);
-		outBuf += size1;
-	}
-
-	//#######################################   Encoding Section   #########################################
-	printf(" \n ---------------- Running -------------------------\n ");
-
-	do{
-		inData.Buffer = (unsigned char *)inBuf;
-		inData.Length = Relens;
-		outData.Buffer = outBuf;
-
-		start = clock();
-
-		/* decode one amr block */
-		returnCode = AudioAPI.SetInputData(hCodec,&inData);
-
-		do {
-			returnCode = AudioAPI.GetOutputData(hCodec,&outData, &outFormat);
-			if(returnCode == 0)
-			{
-				framenum++;
-				printf(" Frames processed: %hd\r", framenum);
-				if(framenum == 1)
-				{
-					fwrite(OutputBuf, 1, outData.Length + size1, fdst);
-					fflush(fdst);	
-				}
-				else
-				{
-					fwrite(outData.Buffer, 1, outData.Length, fdst);
-					fflush(fdst);
-				}
-			}
-			else if(returnCode == VO_ERR_LICENSE_ERROR)
-			{
-		        printf("Encoder time reach upper limit......");
-		        goto safe_exit;
-			}
-		} while(returnCode != VO_ERR_INPUT_BUFFER_SMALL);
-
-		finish = clock();
-		duration += finish - start;
-
-		if (!eofFile) {
-			Relens = GetNextBuf(fsrc, InputBuf, INPUT_SIZE);
-			inBuf = InputBuf;
-			if (feof(fsrc) && Relens == 0)
-				eofFile = 1;
-		}
-	} while (!eofFile && returnCode);
-	//#######################################   End Encoding Section   #########################################
-
-safe_exit:
-	returnCode = AudioAPI.Uninit(hCodec);
-
-	printf( "\n%2.5f seconds\n", (double)duration/CLOCKS_PER_SEC);
-
-	if (fsrc)
-		fclose(fsrc);
-	if (fdst)
-		fclose(fdst);
-
-#ifdef LINUX
-	dlclose(handle);
-#endif
-
-	return ret;
-}
-
-int main(int argc, char **argv)  // for gcc compiler;
-{
-	int     mode, r;
-	int     arg, filename=0;
-	char    *inFileName = NULL;
-	char    *outFileName = NULL;
-	short   allow_dtx;
-	VOAMRWBFRAMETYPE frameType;
-
-	printf("\n");
-	printf("************************Adaptive Multi-Rate Wide Band Encoder (AMR-WB)*******************************\n");
-	printf("***********************************DEFINITIONS:*******************************************************\n");
-	printf("AMR-WB encoder scheme is based on the principle of Algebraic Code Excited Linear Prediction algorithm\n");
-	printf("The AMR-WB encoder compression MONO liner PCM speech input data at 16kHz sampling rate\n");
-	printf("to one of nine data rate modes-6.60, 8.85, 12.65, 14.25, 15.85, 18.25, 19.25, 23.05 and 23.85kbps.\n");
-	printf("The encoder supports output format AMRWB ITU, AMRWB RFC3267.\n");
-	printf("\n");
-
-	/*Encoder Default setting */
-	mode = VOAMRWB_MD2385;
-	allow_dtx = 0;
-	frameType = VOAMRWB_RFC3267;
-
-	if(argc < 3){
-		usage();
-		return 0;
-	}else{
-		for (arg = 1; arg < argc; arg++) {
-			if (argv [arg] [0] == '+') {
-				if(argv[arg][1] == 'M')
-				{
-					switch(argv[arg][2])
-					{
-					case '0': mode = VOAMRWB_MD66;
-						break;
-					case '1': mode = VOAMRWB_MD885;
-						break;
-					case '2': mode = VOAMRWB_MD1265;
-						break;
-					case '3': mode = VOAMRWB_MD1425;
-						break;
-					case '4': mode = VOAMRWB_MD1585;
-						break;
-					case '5': mode = VOAMRWB_MD1825;
-						break;
-					case '6': mode = VOAMRWB_MD1985;
-						break;
-					case '7': mode = VOAMRWB_MD2305;
-						break;
-					case '8': mode = VOAMRWB_MD2385;
-						break;
-					default:
-						usage();
-						printf ("Invalid parameter '%s'.\n", argv [arg]);
-						break;
-					}
-				}else if(argv[arg][1] == 'F')
-				{
-					switch(argv[arg][2])
-					{
-					case '0': frameType = VOAMRWB_DEFAULT;
-						break;
-					case '1': frameType = VOAMRWB_ITU;
-						break;
-					case '2': frameType = VOAMRWB_RFC3267 ;
-						break; 
-					default:
-						usage();
-						printf ("Invalid parameter '%s'.\n", argv [arg]);
-						break;
-
-
-					}
-				}else if(strcmp (argv[arg], "+DTX") == 0)
-				{
-					allow_dtx = 1;
-				}
-
-			} else {
-				switch (filename) {
-						case 0: 
-							inFileName  = argv[arg];
-							break;
-						case 1: 
-							outFileName = argv[arg]; 
-							break;
-						default:
-							usage ();
-							fprintf (stderr, "Invalid parameter '%s'.\n", argv [arg]);
-							return 0;
-				}
-				filename++;
-			}
-		}
-	}
-
-	r = encode(mode, allow_dtx, frameType, inFileName, outFileName);
-	if(r)
-	{
-		fprintf(stderr, "error: %d\n", r);
-	}
-	return r;
-}
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+#ifdef LINUX
+#include <dlfcn.h>
+#endif
+
+#include      <stdio.h>
+#include      <stdlib.h>
+#include      <time.h>
+#include      "voAMRWB.h"
+#include      "cmnMemory.h"
+
+#define VOAMRWB_RFC3267_HEADER_INFO "#!AMR-WB\n"
+
+#define  INPUT_SIZE   640
+#define  OUTPUT_SIZE  1024
+unsigned char  InputBuf[INPUT_SIZE];
+unsigned char  OutputBuf[OUTPUT_SIZE];
+
+void usage (void) {
+	printf ("AMR_WB Encoder HELP   Displays this text\n");
+	printf ("\n");
+	printf ("Usage:\n");
+	printf ("AMRWBEnc [options] Input_file output_file \n");
+	printf ("\n");
+	printf ("Options +M* +F* +DTX \n");
+	printf ("Support \n");
+	printf ("Options +M* for seting compression bitrate mode, default is 23.85kbps\n");
+	printf (" +M0 = 6.6kbps \n");
+	printf (" +M1 = 8.85kbps \n");
+	printf (" +M2 = 12.65kbps \n");
+	printf (" +M3 = 14.25kbps \n");
+	printf (" +M4 = 15.58kbps \n");
+	printf (" +M5 = 18.25kbps \n");
+	printf (" +M6 = 19.85kbps \n");
+	printf (" +M7 = 23.05kbps \n");
+	printf (" +M8 = 23.85kbps \n");
+	printf ("\n");
+	printf ("Options +F* for setting output frame Type, default is RFC3267 \n");
+	printf ("+F0 for AMR_WB Defualt bit extern short data frame type \n");
+	printf ("+F1 for AMR_WB_ITU bit extern short data frame type \n");
+	printf ("+F2 for RFC3267\n ");
+	printf ("\n");
+	printf ("Options +DTX enable DTX mode, default is disable.\n");
+	printf ("File names, input raw PCM data, and output is AMR_WB bit-stream file.\n");
+	printf ("\n");
+}
+
+int  GetNextBuf(FILE* inFile,unsigned char* dst,int size)
+{
+	int size2 = (int)fread(dst, sizeof(signed char), size,inFile);
+	return size2;
+}
+
+typedef int (VO_API * VOGETAUDIOENCAPI) (VO_AUDIO_CODECAPI * pEncHandle);
+
+int encode(
+		   int mode,
+		   short   allow_dtx,
+		   VOAMRWBFRAMETYPE frameType,
+		   const char* srcfile,
+		   const char* dstfile
+		   )
+{
+	int			ret = 0;
+	int         returnCode;
+	FILE		*fsrc = NULL;
+	FILE		*fdst = NULL;
+	int         framenum = 0;
+	int         eofFile = 0;
+	int         size1 = 0;
+	int         Relens;
+
+	VO_AUDIO_CODECAPI       AudioAPI;
+	VO_MEM_OPERATOR         moper;
+	VO_CODEC_INIT_USERDATA  useData;
+	VO_HANDLE               hCodec;
+	VO_CODECBUFFER          inData;
+	VO_CODECBUFFER          outData;
+	VO_AUDIO_OUTPUTINFO     outFormat;
+
+	unsigned char *inBuf = InputBuf;
+	unsigned char *outBuf = OutputBuf;
+
+
+#ifdef LINUX
+	void  *handle = NULL;
+	void  *pfunc;
+	VOGETAUDIOENCAPI pGetAPI;
+#endif
+
+	clock_t   start, finish;
+	double    duration = 0.0;
+
+	if ((fsrc = fopen (srcfile, "rb")) == NULL)
+	{
+		ret = -1;
+		goto safe_exit;
+	}
+
+	if ((fdst = fopen (dstfile, "wb")) == NULL)
+	{
+		ret = -1;
+		goto safe_exit;
+	}
+
+	moper.Alloc = cmnMemAlloc;
+	moper.Copy = cmnMemCopy;
+	moper.Free = cmnMemFree;
+	moper.Set = cmnMemSet;
+	moper.Check = cmnMemCheck;
+
+	useData.memflag = VO_IMF_USERMEMOPERATOR;
+	useData.memData = (VO_PTR)(&moper);
+
+#ifdef LINUX
+	handle = dlopen("/data/local/tmp/voAMRWBEnc.so", RTLD_NOW);
+	if(handle == 0)
+	{
+		printf("open dll error......");
+		return -1;
+	}
+
+	pfunc = dlsym(handle, "voGetAMRWBEncAPI");
+	if(pfunc == 0)
+	{
+		printf("open function error......");
+		return -1;
+	}
+
+	pGetAPI = (VOGETAUDIOENCAPI)pfunc;
+
+	returnCode  = pGetAPI(&AudioAPI);
+	if(returnCode)
+	{
+		printf("get APIs error......");
+		return -1;
+	}
+#else
+	ret = voGetAMRWBEncAPI(&AudioAPI);
+	if(ret)
+	{
+		ret = -1;
+		printf("get APIs error......");
+		goto safe_exit;
+	}
+#endif
+
+	//#######################################   Init Encoding Section   #########################################
+	ret = AudioAPI.Init(&hCodec, VO_AUDIO_CodingAMRWB, &useData);
+
+	if(ret)
+	{
+		ret = -1;
+		printf("APIs init error......");
+		goto safe_exit;
+	}
+
+	Relens = GetNextBuf(fsrc,InputBuf,INPUT_SIZE);
+	if(Relens!=INPUT_SIZE && !feof(fsrc))
+	{
+		ret = -1; //Invalid magic number
+		printf("get next buffer error......");
+		goto safe_exit;
+	}
+
+	//###################################### set encode Mode ##################################################
+	ret = AudioAPI.SetParam(hCodec, VO_PID_AMRWB_FRAMETYPE, &frameType);
+	ret = AudioAPI.SetParam(hCodec, VO_PID_AMRWB_MODE, &mode);
+	ret = AudioAPI.SetParam(hCodec, VO_PID_AMRWB_DTX, &allow_dtx);
+
+	if(frameType == VOAMRWB_RFC3267)
+	{
+		/* write RFC3267 Header info to indicate single channel AMR file storage format */
+		size1 = (int)strlen(VOAMRWB_RFC3267_HEADER_INFO);
+		memcpy(outBuf, VOAMRWB_RFC3267_HEADER_INFO, size1);
+		outBuf += size1;
+	}
+
+	//#######################################   Encoding Section   #########################################
+	printf(" \n ---------------- Running -------------------------\n ");
+
+	do{
+		inData.Buffer = (unsigned char *)inBuf;
+		inData.Length = Relens;
+		outData.Buffer = outBuf;
+
+		start = clock();
+
+		/* decode one amr block */
+		returnCode = AudioAPI.SetInputData(hCodec,&inData);
+
+		do {
+			returnCode = AudioAPI.GetOutputData(hCodec,&outData, &outFormat);
+			if(returnCode == 0)
+			{
+				framenum++;
+				printf(" Frames processed: %hd\r", framenum);
+				if(framenum == 1)
+				{
+					fwrite(OutputBuf, 1, outData.Length + size1, fdst);
+					fflush(fdst);
+				}
+				else
+				{
+					fwrite(outData.Buffer, 1, outData.Length, fdst);
+					fflush(fdst);
+				}
+			}
+			else if(returnCode == VO_ERR_LICENSE_ERROR)
+			{
+		        printf("Encoder time reach upper limit......");
+		        goto safe_exit;
+			}
+		} while(returnCode != VO_ERR_INPUT_BUFFER_SMALL);
+
+		finish = clock();
+		duration += finish - start;
+
+		if (!eofFile) {
+			Relens = GetNextBuf(fsrc, InputBuf, INPUT_SIZE);
+			inBuf = InputBuf;
+			if (feof(fsrc) && Relens == 0)
+				eofFile = 1;
+		}
+	} while (!eofFile && returnCode);
+	//#######################################   End Encoding Section   #########################################
+
+safe_exit:
+	returnCode = AudioAPI.Uninit(hCodec);
+
+	printf( "\n%2.5f seconds\n", (double)duration/CLOCKS_PER_SEC);
+
+	if (fsrc)
+		fclose(fsrc);
+	if (fdst)
+		fclose(fdst);
+
+#ifdef LINUX
+	dlclose(handle);
+#endif
+
+	return ret;
+}
+
+int main(int argc, char **argv)  // for gcc compiler;
+{
+	int     mode, r;
+	int     arg, filename=0;
+	char    *inFileName = NULL;
+	char    *outFileName = NULL;
+	short   allow_dtx;
+	VOAMRWBFRAMETYPE frameType;
+
+	printf("\n");
+	printf("************************Adaptive Multi-Rate Wide Band Encoder (AMR-WB)*******************************\n");
+	printf("***********************************DEFINITIONS:*******************************************************\n");
+	printf("AMR-WB encoder scheme is based on the principle of Algebraic Code Excited Linear Prediction algorithm\n");
+	printf("The AMR-WB encoder compression MONO liner PCM speech input data at 16kHz sampling rate\n");
+	printf("to one of nine data rate modes-6.60, 8.85, 12.65, 14.25, 15.85, 18.25, 19.25, 23.05 and 23.85kbps.\n");
+	printf("The encoder supports output format AMRWB ITU, AMRWB RFC3267.\n");
+	printf("\n");
+
+	/*Encoder Default setting */
+	mode = VOAMRWB_MD2385;
+	allow_dtx = 0;
+	frameType = VOAMRWB_RFC3267;
+
+	if(argc < 3){
+		usage();
+		return 0;
+	}else{
+		for (arg = 1; arg < argc; arg++) {
+			if (argv [arg] [0] == '+') {
+				if(argv[arg][1] == 'M')
+				{
+					switch(argv[arg][2])
+					{
+					case '0': mode = VOAMRWB_MD66;
+						break;
+					case '1': mode = VOAMRWB_MD885;
+						break;
+					case '2': mode = VOAMRWB_MD1265;
+						break;
+					case '3': mode = VOAMRWB_MD1425;
+						break;
+					case '4': mode = VOAMRWB_MD1585;
+						break;
+					case '5': mode = VOAMRWB_MD1825;
+						break;
+					case '6': mode = VOAMRWB_MD1985;
+						break;
+					case '7': mode = VOAMRWB_MD2305;
+						break;
+					case '8': mode = VOAMRWB_MD2385;
+						break;
+					default:
+						usage();
+						printf ("Invalid parameter '%s'.\n", argv [arg]);
+						break;
+					}
+				}else if(argv[arg][1] == 'F')
+				{
+					switch(argv[arg][2])
+					{
+					case '0': frameType = VOAMRWB_DEFAULT;
+						break;
+					case '1': frameType = VOAMRWB_ITU;
+						break;
+					case '2': frameType = VOAMRWB_RFC3267 ;
+						break;
+					default:
+						usage();
+						printf ("Invalid parameter '%s'.\n", argv [arg]);
+						break;
+
+
+					}
+				}else if(strcmp (argv[arg], "+DTX") == 0)
+				{
+					allow_dtx = 1;
+				}
+
+			} else {
+				switch (filename) {
+						case 0:
+							inFileName  = argv[arg];
+							break;
+						case 1:
+							outFileName = argv[arg];
+							break;
+						default:
+							usage ();
+							fprintf (stderr, "Invalid parameter '%s'.\n", argv [arg]);
+							return 0;
+				}
+				filename++;
+			}
+		}
+	}
+
+	r = encode(mode, allow_dtx, frameType, inFileName, outFileName);
+	if(r)
+	{
+		fprintf(stderr, "error: %d\n", r);
+	}
+	return r;
+}
+
diff --git a/media/libstagefright/codecs/amrwbenc/SampleCode/Android.mk b/media/libstagefright/codecs/amrwbenc/SampleCode/Android.mk
index 7edb166..149e591 100644
--- a/media/libstagefright/codecs/amrwbenc/SampleCode/Android.mk
+++ b/media/libstagefright/codecs/amrwbenc/SampleCode/Android.mk
@@ -2,15 +2,15 @@ LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := 	AMRWB_E_SAMPLE.c
-	
+
 LOCAL_SRC_FILES += 	\
-	../../../Common/cmnMemory.c 
+	../../../Common/cmnMemory.c
 
 LOCAL_MODULE := TestvoAMRWBEnc
 
 LOCAL_ARM_MODE := arm
 
-LOCAL_STATIC_LIBRARIES := 
+LOCAL_STATIC_LIBRARIES :=
 
 LOCAL_SHARED_LIBRARIES := libvoAMRWBEnc
 
@@ -20,7 +20,7 @@ LOCAL_C_INCLUDES := \
 	$(LOCAL_PATH)/../../../Include \
 
 LOCAL_CFLAGS := $(VO_CFLAGS)
-	
+
 include $(BUILD_EXECUTABLE)
 
 
diff --git a/media/libstagefright/codecs/amrwbenc/SampleCode/eclair/Makefile b/media/libstagefright/codecs/amrwbenc/SampleCode/eclair/Makefile
index 55b876a..148b941 100644
--- a/media/libstagefright/codecs/amrwbenc/SampleCode/eclair/Makefile
+++ b/media/libstagefright/codecs/amrwbenc/SampleCode/eclair/Makefile
@@ -1,56 +1,56 @@
-#/*
-# ** Copyright 2003-2010, VisualOn, Inc.
-# **
-# ** Licensed under the Apache License, Version 2.0 (the "License");
-# ** you may not use this file except in compliance with the License.
-# ** You may obtain a copy of the License at
-# **
-# **     http://www.apache.org/licenses/LICENSE-2.0
-# **
-# ** Unless required by applicable law or agreed to in writing, software
-# ** distributed under the License is distributed on an "AS IS" BASIS,
-# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# ** See the License for the specific language governing permissions and
-# ** limitations under the License.
-# */
-
-# target6
-# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
-VOTT:= v6
-
-
-# module type
-# please specify the type of your module: lib or exe
-VOMT:= exe
-
-
-# module macros
-# please append the additional macro definitions here for your module if necessary. 
-# e.g. -DVISUALON, macro VISUALON defined for your module 
-VOMM:= #ARMV5E
-
-
-
-# please specify the name of your module
-VOTARGET:= voAMRWBEnc_Test
-
-
-# please modify here to be sure to see the g1.mk
-include ../../../../Tools/eclair.mk 
-
-# dependent libraries.
-VODEPLIBS:=-ldl
-
-
-# module source
-# please modify here to be sure to see the ms.mk which specifies all source info of your module
-include ../ms.mk
-
-
-# please specify where is the voRelease on your PC, relative path is suggested
-VORELDIR:=../
-
-
-# please modify here to be sure to see the doit.mk
-include ../../../../Tools/doit.mk 
-
+#/*
+# ** Copyright 2003-2010, VisualOn, Inc.
+# **
+# ** Licensed under the Apache License, Version 2.0 (the "License");
+# ** you may not use this file except in compliance with the License.
+# ** You may obtain a copy of the License at
+# **
+# **     http://www.apache.org/licenses/LICENSE-2.0
+# **
+# ** Unless required by applicable law or agreed to in writing, software
+# ** distributed under the License is distributed on an "AS IS" BASIS,
+# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# ** See the License for the specific language governing permissions and
+# ** limitations under the License.
+# */
+
+# target6
+# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
+VOTT:= v6
+
+
+# module type
+# please specify the type of your module: lib or exe
+VOMT:= exe
+
+
+# module macros
+# please append the additional macro definitions here for your module if necessary.
+# e.g. -DVISUALON, macro VISUALON defined for your module
+VOMM:= #ARMV5E
+
+
+
+# please specify the name of your module
+VOTARGET:= voAMRWBEnc_Test
+
+
+# please modify here to be sure to see the g1.mk
+include ../../../../Tools/eclair.mk
+
+# dependent libraries.
+VODEPLIBS:=-ldl
+
+
+# module source
+# please modify here to be sure to see the ms.mk which specifies all source info of your module
+include ../ms.mk
+
+
+# please specify where is the voRelease on your PC, relative path is suggested
+VORELDIR:=../
+
+
+# please modify here to be sure to see the doit.mk
+include ../../../../Tools/doit.mk
+
diff --git a/media/libstagefright/codecs/amrwbenc/SampleCode/ms.mk b/media/libstagefright/codecs/amrwbenc/SampleCode/ms.mk
index 74e8913..a550cee 100644
--- a/media/libstagefright/codecs/amrwbenc/SampleCode/ms.mk
+++ b/media/libstagefright/codecs/amrwbenc/SampleCode/ms.mk
@@ -1,24 +1,24 @@
-#/*
-# ** Copyright 2003-2010, VisualOn, Inc.
-# **
-# ** Licensed under the Apache License, Version 2.0 (the "License");
-# ** you may not use this file except in compliance with the License.
-# ** You may obtain a copy of the License at
-# **
-# **     http://www.apache.org/licenses/LICENSE-2.0
-# **
-# ** Unless required by applicable law or agreed to in writing, software
-# ** distributed under the License is distributed on an "AS IS" BASIS,
-# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# ** See the License for the specific language governing permissions and
-# ** limitations under the License.
-# */
-# please list all objects needed by your target here
-OBJS:=AMRWB_E_SAMPLE.o cmnMemory.o
-			
-# please list all directories that all source files relative with your module(.h .c .cpp) locate 
-VOSRCDIR:=../ \
-          ../../../../Common \
-	  ../../../../Include
-					
-				
+#/*
+# ** Copyright 2003-2010, VisualOn, Inc.
+# **
+# ** Licensed under the Apache License, Version 2.0 (the "License");
+# ** you may not use this file except in compliance with the License.
+# ** You may obtain a copy of the License at
+# **
+# **     http://www.apache.org/licenses/LICENSE-2.0
+# **
+# ** Unless required by applicable law or agreed to in writing, software
+# ** distributed under the License is distributed on an "AS IS" BASIS,
+# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# ** See the License for the specific language governing permissions and
+# ** limitations under the License.
+# */
+# please list all objects needed by your target here
+OBJS:=AMRWB_E_SAMPLE.o cmnMemory.o
+
+# please list all directories that all source files relative with your module(.h .c .cpp) locate
+VOSRCDIR:=../ \
+          ../../../../Common \
+	  ../../../../Include
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV5E/Makefile b/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV5E/Makefile
index 58fda29..67ec74e 100644
--- a/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV5E/Makefile
+++ b/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV5E/Makefile
@@ -1,53 +1,53 @@
-#/*
-# ** Copyright 2003-2010, VisualOn, Inc.
-# **
-# ** Licensed under the Apache License, Version 2.0 (the "License");
-# ** you may not use this file except in compliance with the License.
-# ** You may obtain a copy of the License at
-# **
-# **     http://www.apache.org/licenses/LICENSE-2.0
-# **
-# ** Unless required by applicable law or agreed to in writing, software
-# ** distributed under the License is distributed on an "AS IS" BASIS,
-# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# ** See the License for the specific language governing permissions and
-# ** limitations under the License.
-# */
-
-# target type
-# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
-VOTT:= v5
-
-
-# module type
-# please specify the type of your module: lib or exe
-VOMT:= lib
-
-
-# module macros
-# please append the additional macro definitions here for your module if necessary. 
-ifeq ($(VOTT), v5)
-VOMM:=-DARM -DASM_OPT
-endif
-
-# please specify the name of your module
-VOTARGET:= libvoAMRWBEncv5
-
-
-# please modify here to be sure to see the g1.mk
-include ../../../../../Tools/eclair.mk 
-
-# dependent libraries.
-VODEPLIBS:=-ldl -lstdc++ -lcutils
-
-# module source
-# please modify here to be sure to see the ms.mk which specifies all source info of your module
-include ../ms.mk
-
-
-# please specify where is the voRelease on your PC, relative path is suggested
-VORELDIR:=../../../../../../Release
-
-# please modify here to be sure to see the doit.mk
-include ../../../../../Tools/doit.mk 
-
+#/*
+# ** Copyright 2003-2010, VisualOn, Inc.
+# **
+# ** Licensed under the Apache License, Version 2.0 (the "License");
+# ** you may not use this file except in compliance with the License.
+# ** You may obtain a copy of the License at
+# **
+# **     http://www.apache.org/licenses/LICENSE-2.0
+# **
+# ** Unless required by applicable law or agreed to in writing, software
+# ** distributed under the License is distributed on an "AS IS" BASIS,
+# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# ** See the License for the specific language governing permissions and
+# ** limitations under the License.
+# */
+
+# target type
+# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
+VOTT:= v5
+
+
+# module type
+# please specify the type of your module: lib or exe
+VOMT:= lib
+
+
+# module macros
+# please append the additional macro definitions here for your module if necessary.
+ifeq ($(VOTT), v5)
+VOMM:=-DARM -DASM_OPT
+endif
+
+# please specify the name of your module
+VOTARGET:= libvoAMRWBEncv5
+
+
+# please modify here to be sure to see the g1.mk
+include ../../../../../Tools/eclair.mk
+
+# dependent libraries.
+VODEPLIBS:=-ldl -lstdc++ -lcutils
+
+# module source
+# please modify here to be sure to see the ms.mk which specifies all source info of your module
+include ../ms.mk
+
+
+# please specify where is the voRelease on your PC, relative path is suggested
+VORELDIR:=../../../../../../Release
+
+# please modify here to be sure to see the doit.mk
+include ../../../../../Tools/doit.mk
+
diff --git a/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV7/Makefile b/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV7/Makefile
index 5686411..9a036a5 100644
--- a/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV7/Makefile
+++ b/media/libstagefright/codecs/amrwbenc/build/eclair/ARMV7/Makefile
@@ -1,53 +1,53 @@
-#/*
-# ** Copyright 2003-2010, VisualOn, Inc.
-# **
-# ** Licensed under the Apache License, Version 2.0 (the "License");
-# ** you may not use this file except in compliance with the License.
-# ** You may obtain a copy of the License at
-# **
-# **     http://www.apache.org/licenses/LICENSE-2.0
-# **
-# ** Unless required by applicable law or agreed to in writing, software
-# ** distributed under the License is distributed on an "AS IS" BASIS,
-# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# ** See the License for the specific language governing permissions and
-# ** limitations under the License.
-# */
-
-# target type
-# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
-VOTT:= v7
-
-
-# module type
-# please specify the type of your module: lib or exe
-VOMT:= lib
-
-
-# module macros
-# please append the additional macro definitions here for your module if necessary. 
-ifeq ($(VOTT), v7)
-VOMM:=-DARM -DARMV7 -DASM_OPT
-endif
-
-# please specify the name of your module
-VOTARGET:= libvoAMRWBEncv7
-
-
-# please modify here to be sure to see the g1.mk
-include ../../../../../Tools/eclair.mk 
-
-# dependent libraries.
-VODEPLIBS:=-ldl -lstdc++ -lcutils
-
-# module source
-# please modify here to be sure to see the ms.mk which specifies all source info of your module
-include ../ms.mk
-
-
-# please specify where is the voRelease on your PC, relative path is suggested
-VORELDIR:=../../../../../../Release
-
-# please modify here to be sure to see the doit.mk
-include ../../../../../Tools/doit.mk 
-
+#/*
+# ** Copyright 2003-2010, VisualOn, Inc.
+# **
+# ** Licensed under the Apache License, Version 2.0 (the "License");
+# ** you may not use this file except in compliance with the License.
+# ** You may obtain a copy of the License at
+# **
+# **     http://www.apache.org/licenses/LICENSE-2.0
+# **
+# ** Unless required by applicable law or agreed to in writing, software
+# ** distributed under the License is distributed on an "AS IS" BASIS,
+# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# ** See the License for the specific language governing permissions and
+# ** limitations under the License.
+# */
+
+# target type
+# available: pc, v4(armv4), v5(armv5), v5x(armv5 xscale), v6(armv6), v7(cortex-a8 neon)
+VOTT:= v7
+
+
+# module type
+# please specify the type of your module: lib or exe
+VOMT:= lib
+
+
+# module macros
+# please append the additional macro definitions here for your module if necessary.
+ifeq ($(VOTT), v7)
+VOMM:=-DARM -DARMV7 -DASM_OPT
+endif
+
+# please specify the name of your module
+VOTARGET:= libvoAMRWBEncv7
+
+
+# please modify here to be sure to see the g1.mk
+include ../../../../../Tools/eclair.mk
+
+# dependent libraries.
+VODEPLIBS:=-ldl -lstdc++ -lcutils
+
+# module source
+# please modify here to be sure to see the ms.mk which specifies all source info of your module
+include ../ms.mk
+
+
+# please specify where is the voRelease on your PC, relative path is suggested
+VORELDIR:=../../../../../../Release
+
+# please modify here to be sure to see the doit.mk
+include ../../../../../Tools/doit.mk
+
diff --git a/media/libstagefright/codecs/amrwbenc/build/eclair/makefile b/media/libstagefright/codecs/amrwbenc/build/eclair/makefile
index 3473a1a..34981fb 100644
--- a/media/libstagefright/codecs/amrwbenc/build/eclair/makefile
+++ b/media/libstagefright/codecs/amrwbenc/build/eclair/makefile
@@ -15,7 +15,7 @@
 # */
 # Just acting as Father Makefile of Modules
 # please keep the name 'makefile' unchanged
- 
+
 # Module Subdirs
 VOMSD:=$(dir $(shell find . -name 'Makefile'))
 
diff --git a/media/libstagefright/codecs/amrwbenc/build/eclair/ms.mk b/media/libstagefright/codecs/amrwbenc/build/eclair/ms.mk
index bd6620c..942ec9a 100644
--- a/media/libstagefright/codecs/amrwbenc/build/eclair/ms.mk
+++ b/media/libstagefright/codecs/amrwbenc/build/eclair/ms.mk
@@ -1,43 +1,43 @@
-#/*
-# ** Copyright 2003-2010, VisualOn, Inc.
-# **
-# ** Licensed under the Apache License, Version 2.0 (the "License");
-# ** you may not use this file except in compliance with the License.
-# ** You may obtain a copy of the License at
-# **
-# **     http://www.apache.org/licenses/LICENSE-2.0
-# **
-# ** Unless required by applicable law or agreed to in writing, software
-# ** distributed under the License is distributed on an "AS IS" BASIS,
-# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# ** See the License for the specific language governing permissions and
-# ** limitations under the License.
-# */
-# please list all directories that all source files relative with your module(.h .c .cpp) locate 
-VOSRCDIR:=../../../inc \
-          ../../../src \
-	  ../../../../../Include 
-
-# please list all objects needed by your target here
-OBJS:= autocorr.o az_isp.o bits.o c2t64fx.o c4t64fx.o convolve.o cor_h_x.o decim54.o \
-       deemph.o dtx.o g_pitch.o gpclip.o homing.o hp400.o hp50.o hp6k.o hp_wsp.o \
-       int_lpc.o isp_az.o isp_isf.o lag_wind.o levinson.o log2.o lp_dec2.o math_op.o mem_align.o \
-       oper_32b.o p_med_ol.o pit_shrp.o pitch_f4.o pred_lt4.o preemph.o q_gain2.o q_pulse.o \
-       qisf_ns.o qpisf_2s.o random.o residu.o scale.o stream.o syn_filt.o updt_tar.o util.o \
-       voAMRWBEnc.o voicefac.o wb_vad.o weight_a.o
-			
-
-ifeq ($(VOTT), v5)
-OBJS += cor_h_vec_opt.o Deemph_32_opt.o Dot_p_opt.o Filt_6k_7k_opt.o residu_asm_opt.o \
-       scale_sig_opt.o Syn_filt_32_opt.o syn_filt_opt.o pred_lt4_1_opt.o convolve_opt.o \
-       Norm_Corr_opt.o
-VOSRCDIR+= ../../../src/asm/ARMV5E
-endif
-
-ifeq ($(VOTT), v7)
-OBJS+= cor_h_vec_neon.o Deemph_32_neon.o Dot_p_neon.o Filt_6k_7k_neon.o residu_asm_neon.o \
-       scale_sig_neon.o Syn_filt_32_neon.o syn_filt_neon.o pred_lt4_1_neon.o convolve_neon.o \
-       Norm_Corr_neon.o
-VOSRCDIR+= ../../../src/asm/ARMV7
-endif
-
+#/*
+# ** Copyright 2003-2010, VisualOn, Inc.
+# **
+# ** Licensed under the Apache License, Version 2.0 (the "License");
+# ** you may not use this file except in compliance with the License.
+# ** You may obtain a copy of the License at
+# **
+# **     http://www.apache.org/licenses/LICENSE-2.0
+# **
+# ** Unless required by applicable law or agreed to in writing, software
+# ** distributed under the License is distributed on an "AS IS" BASIS,
+# ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# ** See the License for the specific language governing permissions and
+# ** limitations under the License.
+# */
+# please list all directories that all source files relative with your module(.h .c .cpp) locate
+VOSRCDIR:=../../../inc \
+          ../../../src \
+	  ../../../../../Include
+
+# please list all objects needed by your target here
+OBJS:= autocorr.o az_isp.o bits.o c2t64fx.o c4t64fx.o convolve.o cor_h_x.o decim54.o \
+       deemph.o dtx.o g_pitch.o gpclip.o homing.o hp400.o hp50.o hp6k.o hp_wsp.o \
+       int_lpc.o isp_az.o isp_isf.o lag_wind.o levinson.o log2.o lp_dec2.o math_op.o mem_align.o \
+       oper_32b.o p_med_ol.o pit_shrp.o pitch_f4.o pred_lt4.o preemph.o q_gain2.o q_pulse.o \
+       qisf_ns.o qpisf_2s.o random.o residu.o scale.o stream.o syn_filt.o updt_tar.o util.o \
+       voAMRWBEnc.o voicefac.o wb_vad.o weight_a.o
+
+
+ifeq ($(VOTT), v5)
+OBJS += cor_h_vec_opt.o Deemph_32_opt.o Dot_p_opt.o Filt_6k_7k_opt.o residu_asm_opt.o \
+       scale_sig_opt.o Syn_filt_32_opt.o syn_filt_opt.o pred_lt4_1_opt.o convolve_opt.o \
+       Norm_Corr_opt.o
+VOSRCDIR+= ../../../src/asm/ARMV5E
+endif
+
+ifeq ($(VOTT), v7)
+OBJS+= cor_h_vec_neon.o Deemph_32_neon.o Dot_p_neon.o Filt_6k_7k_neon.o residu_asm_neon.o \
+       scale_sig_neon.o Syn_filt_32_neon.o syn_filt_neon.o pred_lt4_1_neon.o convolve_neon.o \
+       Norm_Corr_neon.o
+VOSRCDIR+= ../../../src/asm/ARMV7
+endif
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/acelp.h b/media/libstagefright/codecs/amrwbenc/inc/acelp.h
index 4cb38a1..5a1e536 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/acelp.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/acelp.h
@@ -1,521 +1,521 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
- *                         ACELP.H                                          *
- *--------------------------------------------------------------------------*
- *       Function			 			             *
- *--------------------------------------------------------------------------*/
-#ifndef __ACELP_H__
-#define __ACELP_H__
-
-#include "typedef.h"
-#include "cod_main.h"
-
-/*-----------------------------------------------------------------*
- *                        LPC prototypes                           *
- *-----------------------------------------------------------------*/
-
-Word16 median5(Word16 x[]);
-
-void Autocorr(
-		Word16 x[],                           /* (i)    : Input signal                      */
-		Word16 m,                             /* (i)    : LPC order                         */
-		Word16 r_h[],                         /* (o)    : Autocorrelations  (msb)           */
-		Word16 r_l[]                          /* (o)    : Autocorrelations  (lsb)           */
-	     );
-
-void Lag_window(
-		Word16 r_h[],                         /* (i/o)   : Autocorrelations  (msb)          */
-		Word16 r_l[]                          /* (i/o)   : Autocorrelations  (lsb)          */
-	       );
-
-void Init_Levinson(
-		Word16 * mem                          /* output  :static memory (18 words) */
-		);
-
-void Levinson(
-		Word16 Rh[],                          /* (i)     : Rh[M+1] Vector of autocorrelations (msb) */
-		Word16 Rl[],                          /* (i)     : Rl[M+1] Vector of autocorrelations (lsb) */
-		Word16 A[],                           /* (o) Q12 : A[M]    LPC coefficients  (m = 16)       */
-		Word16 rc[],                          /* (o) Q15 : rc[M]   Reflection coefficients.         */
-		Word16 * mem                          /* (i/o)   :static memory (18 words)                  */
-	     );
-
-void Az_isp(
-		Word16 a[],                           /* (i) Q12 : predictor coefficients                 */
-		Word16 isp[],                         /* (o) Q15 : Immittance spectral pairs              */
-		Word16 old_isp[]                      /* (i)     : old isp[] (in case not found M roots)  */
-	   );
-
-void Isp_Az(
-		Word16 isp[],                         /* (i) Q15 : Immittance spectral pairs            */
-		Word16 a[],                           /* (o) Q12 : predictor coefficients (order = M)   */
-		Word16 m,
-		Word16 adaptive_scaling               /* (i) 0   : adaptive scaling disabled */
-		/*     1   : adaptive scaling enabled  */
-	   );
-
-void Isp_isf(
-		Word16 isp[],                         /* (i) Q15 : isp[m] (range: -1<=val<1)                */
-		Word16 isf[],                         /* (o) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
-		Word16 m                              /* (i)     : LPC order                                */
-	    );
-
-void Isf_isp(
-		Word16 isf[],                         /* (i) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
-		Word16 isp[],                         /* (o) Q15 : isp[m] (range: -1<=val<1)                */
-		Word16 m                              /* (i)     : LPC order                                */
-	    );
-
-void Int_isp(
-		Word16 isp_old[],                     /* input : isps from past frame              */
-		Word16 isp_new[],                     /* input : isps from present frame           */
-		Word16 frac[],                        /* input : fraction for 3 first subfr (Q15)  */
-		Word16 Az[]                           /* output: LP coefficients in 4 subframes    */
-	    );
-
-void Weight_a(
-		Word16 a[],                           /* (i) Q12 : a[m+1]  LPC coefficients             */
-		Word16 ap[],                          /* (o) Q12 : Spectral expanded LPC coefficients   */
-		Word16 gamma,                         /* (i) Q15 : Spectral expansion factor.           */
-		Word16 m                              /* (i)     : LPC order.                           */
-	     );
-
-
-/*-----------------------------------------------------------------*
- *                        isf quantizers                           *
- *-----------------------------------------------------------------*/
-
-void Qpisf_2s_46b(
-		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
-		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
-		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
-		Word16 * indice,                      /* (o)     : quantization indices                 */
-		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
-		);
-
-void Qpisf_2s_36b(
-		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
-		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
-		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
-		Word16 * indice,                      /* (o)     : quantization indices                 */
-		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
-		);
-
-void Dpisf_2s_46b(
-		Word16 * indice,                      /* input:  quantization indices                       */
-		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
-		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
-		Word16 * isfold,                      /* input : past quantized ISF                    */
-		Word16 * isf_buf,                     /* input : isf buffer                                                        */
-		Word16 bfi,                           /* input : Bad frame indicator                   */
-		Word16 enc_dec
-		);
-
-void Dpisf_2s_36b(
-		Word16 * indice,                      /* input:  quantization indices                       */
-		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
-		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
-		Word16 * isfold,                      /* input : past quantized ISF                    */
-		Word16 * isf_buf,                     /* input : isf buffer                                                        */
-		Word16 bfi,                           /* input : Bad frame indicator                   */
-		Word16 enc_dec
-		);
-
-void Qisf_ns(
-		Word16 * isf1,                        /* input : ISF in the frequency domain (0..0.5) */
-		Word16 * isf_q,                       /* output: quantized ISF                        */
-		Word16 * indice                       /* output: quantization indices                 */
-	    );
-
-void Disf_ns(
-		Word16 * indice,                      /* input:  quantization indices                  */
-		Word16 * isf_q                        /* input : ISF in the frequency domain (0..0.5)  */
-	    );
-
-Word16 Sub_VQ(                             /* output: return quantization index     */
-		Word16 * x,                           /* input : ISF residual vector           */
-		Word16 * dico,                        /* input : quantization codebook         */
-		Word16 dim,                           /* input : dimention of vector           */
-		Word16 dico_size,                     /* input : size of quantization codebook */
-		Word32 * distance                     /* output: error of quantization         */
-	     );
-
-void Reorder_isf(
-		Word16 * isf,                         /* (i/o) Q15: ISF in the frequency domain (0..0.5) */
-		Word16 min_dist,                      /* (i) Q15  : minimum distance to keep             */
-		Word16 n                              /* (i)      : number of ISF                        */
-		);
-
-/*-----------------------------------------------------------------*
- *                       filter prototypes                         *
- *-----------------------------------------------------------------*/
-
-void Init_Decim_12k8(
-		Word16 mem[]                          /* output: memory (2*NB_COEF_DOWN) set to zeros */
-		);
-void Decim_12k8(
-		Word16 sig16k[],                      /* input:  signal to downsampling  */
-		Word16 lg,                            /* input:  length of input         */
-		Word16 sig12k8[],                     /* output: decimated signal        */
-		Word16 mem[]                          /* in/out: memory (2*NB_COEF_DOWN) */
-	       );
-
-void Init_HP50_12k8(Word16 mem[]);
-void HP50_12k8(
-		Word16 signal[],                      /* input/output signal */
-		Word16 lg,                            /* lenght of signal    */
-		Word16 mem[]                          /* filter memory [6]   */
-	      );
-void Init_HP400_12k8(Word16 mem[]);
-void HP400_12k8(
-		Word16 signal[],                      /* input/output signal */
-		Word16 lg,                            /* lenght of signal    */
-		Word16 mem[]                          /* filter memory [6]   */
-	       );
-
-void Init_Filt_6k_7k(Word16 mem[]);
-void Filt_6k_7k(
-		Word16 signal[],                      /* input:  signal                  */
-		Word16 lg,                            /* input:  length of input         */
-		Word16 mem[]                          /* in/out: memory (size=30)        */
-	       );
-void Filt_6k_7k_asm(
-		Word16 signal[],                      /* input:  signal                  */
-		Word16 lg,                            /* input:  length of input         */
-		Word16 mem[]                          /* in/out: memory (size=30)        */
-	       );
-
-void LP_Decim2(
-		Word16 x[],                           /* in/out: signal to process         */
-		Word16 l,                             /* input : size of filtering         */
-		Word16 mem[]                          /* in/out: memory (size=3)           */
-	      );
-
-void Preemph(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
-		Word16 lg,                            /* (i)     : lenght of filtering                    */
-		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
-	    );
-void Preemph2(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
-		Word16 lg,                            /* (i)     : lenght of filtering                    */
-		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
-	     );
-void Deemph(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
-		Word16 L,                             /* (i)     : vector size                            */
-		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
-	   );
-void Deemph2(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
-		Word16 L,                             /* (i)     : vector size                            */
-		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
-	    );
-void Deemph_32(
-		Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
-		Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
-		Word16 y[],                           /* (o)     : output signal (x16)      */
-		Word16 mu,                            /* (i) Q15 : deemphasis factor        */
-		Word16 L,                             /* (i)     : vector size              */
-		Word16 * mem                          /* (i/o)   : memory (y[-1])           */
-	      );
-
-void Deemph_32_asm(
-		Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
-		Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
-		Word16 y[],                           /* (o)     : output signal (x16)      */
-		Word16 * mem                          /* (i/o)   : memory (y[-1])           */
-	      );
-
-void Convolve(
-		Word16 x[],                           /* (i)     : input vector                              */
-		Word16 h[],                           /* (i) Q15    : impulse response                       */
-		Word16 y[],                           /* (o) 12 bits: output vector                          */
-		Word16 L                              /* (i)     : vector size                               */
-	     );
-
-void Convolve_asm(
-		Word16 x[],                           /* (i)     : input vector                              */
-		Word16 h[],                           /* (i) Q15    : impulse response                       */
-		Word16 y[],                           /* (o) 12 bits: output vector                          */
-		Word16 L                              /* (i)     : vector size                               */
-	     );
-
-void Residu(
-		Word16 a[],                           /* (i) Q12 : prediction coefficients                     */
-		Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed         */
-		Word16 y[],                           /* (o)     : residual signal                             */
-		Word16 lg                             /* (i)     : size of filtering                           */
-		);
-
-void Residu_opt(
-		Word16 a[],                           /* (i) Q12 : prediction coefficients                     */
-		Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed         */
-		Word16 y[],                           /* (o)     : residual signal                             */
-		Word16 lg                             /* (i)     : size of filtering                           */
-		);
-
-void Syn_filt(
-	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
-	Word16 x[],                           /* (i)     : input signal                             */
-	Word16 y[],                           /* (o)     : output signal                            */
-	Word16 lg,                            /* (i)     : size of filtering                        */
-	Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
-	Word16 update                         /* (i)     : 0=no update, 1=update of memory.         */
-	);
-
-void Syn_filt_asm(
-	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
-	Word16 x[],                           /* (i)     : input signal                             */
-	Word16 y[],                           /* (o)     : output signal                            */
-	Word16 mem[]                          /* (i/o)   : memory associated with this filtering.   */
-	);
-
-void Syn_filt_32(
-	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
-	Word16 m,                             /* (i)     : order of LP filter             */
-	Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
-	Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
-	Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
-	Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
-	Word16 lg                             /* (i)     : size of filtering              */
-	);
-
-void Syn_filt_32_asm(
-	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
-	Word16 m,                             /* (i)     : order of LP filter             */
-	Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
-	Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
-	Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
-	Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
-	Word16 lg                             /* (i)     : size of filtering              */
-	);
-/*-----------------------------------------------------------------*
- *                       pitch prototypes                          *
- *-----------------------------------------------------------------*/
-
-Word16 Pitch_ol(                           /* output: open loop pitch lag                        */
-     Word16 signal[],                      /* input : signal used to compute the open loop pitch */
-/* signal[-pit_max] to signal[-1] should be known */
-     Word16 pit_min,                       /* input : minimum pitch lag                          */
-     Word16 pit_max,                       /* input : maximum pitch lag                          */
-     Word16 L_frame                        /* input : length of frame to compute pitch           */
-);
-
-Word16 Pitch_med_ol(                       /* output: open loop pitch lag                        */
-     Word16 wsp[],                         /* input : signal used to compute the open loop pitch */
-                                           /* wsp[-pit_max] to wsp[-1] should be known   */
-     Coder_State *st,                      /* i/o : global codec structure */
-     Word16 L_frame                        /* input : length of frame to compute pitch           */
-);
-
-Word16 Med_olag(                           /* output : median of  5 previous open-loop lags       */
-     Word16 prev_ol_lag,                   /* input  : previous open-loop lag                     */
-     Word16 old_ol_lag[5]
-);
-
-void Init_Hp_wsp(Word16 mem[]);
-void scale_mem_Hp_wsp(Word16 mem[], Word16 exp);
-void Hp_wsp(
-     Word16 wsp[],                         /* i   : wsp[]  signal       */
-     Word16 hp_wsp[],                      /* o   : hypass wsp[]        */
-     Word16 lg,                            /* i   : lenght of signal    */
-     Word16 mem[]                          /* i/o : filter memory [9]   */
-);
-
-Word16 Pitch_fr4(                          /* (o)     : pitch period.                         */
-     Word16 exc[],                         /* (i)     : excitation buffer                     */
-     Word16 xn[],                          /* (i)     : target vector                         */
-     Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
-     Word16 t0_min,                        /* (i)     : minimum value in the searched range.  */
-     Word16 t0_max,                        /* (i)     : maximum value in the searched range.  */
-     Word16 * pit_frac,                    /* (o)     : chosen fraction (0, 1, 2 or 3).       */
-     Word16 i_subfr,                       /* (i)     : indicator for first subframe.         */
-     Word16 t0_fr2,                        /* (i)     : minimum value for resolution 1/2      */
-     Word16 t0_fr1,                        /* (i)     : minimum value for resolution 1        */
-     Word16 L_subfr                        /* (i)     : Length of subframe                    */
-);
-void Pred_lt4(
-     Word16 exc[],                         /* in/out: excitation buffer */
-     Word16 T0,                            /* input : integer pitch lag */
-     Word16 frac,                          /* input : fraction of lag   */
-     Word16 L_subfr                        /* input : subframe size     */
-);
-
-void pred_lt4_asm(
-     Word16 exc[],                         /* in/out: excitation buffer */
-     Word16 T0,                            /* input : integer pitch lag */
-     Word16 frac,                          /* input : fraction of lag   */
-     Word16 L_subfr                        /* input : subframe size     */
-);
-
-/*-----------------------------------------------------------------*
- *                       gain prototypes                           *
- *-----------------------------------------------------------------*/
-
-Word16 G_pitch(                            /* (o) Q14 : Gain of pitch lag saturated to 1.2   */
-     Word16 xn[],                          /* (i)     : Pitch target.                        */
-     Word16 y1[],                          /* (i)     : filtered adaptive codebook.          */
-     Word16 g_coeff[],                     /* : Correlations need for gain quantization. */
-     Word16 L_subfr                        /* : Length of subframe.                  */
-);
-void Init_Q_gain2(
-     Word16 * mem                          /* output  :static memory (2 words)      */
-);
-Word16 Q_gain2(                            /* Return index of quantization.        */
-     Word16 xn[],                          /* (i) Q_xn:Target vector.               */
-     Word16 y1[],                          /* (i) Q_xn:Adaptive codebook.           */
-     Word16 Q_xn,                          /* (i)     :xn and y1 format             */
-     Word16 y2[],                          /* (i) Q9  :Filtered innovative vector.  */
-     Word16 code[],                        /* (i) Q9  :Innovative vector.           */
-     Word16 g_coeff[],                     /* (i)     :Correlations <xn y1> <y1 y1> */
-/* Compute in G_pitch().        */
-     Word16 L_subfr,                       /* (i)     :Subframe lenght.             */
-     Word16 nbits,                         /* (i)     : number of bits (6 or 7)     */
-     Word16 * gain_pit,                    /* (i/o)Q14:Pitch gain.                  */
-     Word32 * gain_cod,                    /* (o) Q16 :Code gain.                   */
-     Word16 gp_clip,                       /* (i)     : Gp Clipping flag            */
-     Word16 * mem                          /* (i/o)   :static memory (2 words)      */
-);
-
-void Init_D_gain2(
-     Word16 * mem                          /* output  :static memory (4 words)      */
-);
-void D_gain2(
-     Word16 index,                         /* (i)     :index of quantization.       */
-     Word16 nbits,                         /* (i)     : number of bits (6 or 7)     */
-     Word16 code[],                        /* (i) Q9  :Innovative vector.           */
-     Word16 L_subfr,                       /* (i)     :Subframe lenght.             */
-     Word16 * gain_pit,                    /* (o) Q14 :Pitch gain.                  */
-     Word32 * gain_cod,                    /* (o) Q16 :Code gain.                   */
-     Word16 bfi,                           /* (i)     :bad frame indicator          */
-     Word16 prev_bfi,                      /* (i) : Previous BF indicator      */
-     Word16 state,                         /* (i) : State of BFH               */
-     Word16 unusable_frame,                /* (i) : UF indicator            */
-     Word16 vad_hist,                      /* (i)         :number of non-speech frames  */
-     Word16 * mem                          /* (i/o)   :static memory (4 words)      */
-);
-
-/*-----------------------------------------------------------------*
- *                       acelp prototypes                          *
- *-----------------------------------------------------------------*/
-
-void cor_h_x(
-     Word16 h[],                           /* (i) Q12 : impulse response of weighted synthesis filter */
-     Word16 x[],                           /* (i) Q0  : target vector                                 */
-     Word16 dn[]                           /* (o) <12bit : correlation between target and h[]         */
-);
-void ACELP_2t64_fx(
-     Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
-     Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
-     Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
-     Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
-     Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
-     Word16 * index                        /* (o) : index (12): 5+1+5+1 = 11 bits.                     */
-);
-
-void ACELP_4t64_fx(
-     Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
-     Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
-     Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
-     Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
-     Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
-     Word16 nbbits,                        /* (i) : 20, 36, 44, 52, 64, 72 or 88 bits                */
-     Word16 ser_size,                      /* (i) : bit rate                                         */
-     Word16 _index[]                       /* (o) : index (20): 5+5+5+5 = 20 bits.                   */
-					   /* (o) : index (36): 9+9+9+9 = 36 bits.                   */
-					   /* (o) : index (44): 13+9+13+9 = 44 bits.                 */
-					   /* (o) : index (52): 13+13+13+13 = 52 bits.               */
-					   /* (o) : index (64): 2+2+2+2+14+14+14+14 = 64 bits.       */
-					   /* (o) : index (72): 10+2+10+2+10+14+10+14 = 72 bits.     */
-					   /* (o) : index (88): 11+11+11+11+11+11+11+11 = 88 bits.   */
-);
-
-void Pit_shrp(
-     Word16 * x,                           /* in/out: impulse response (or algebraic code) */
-     Word16 pit_lag,                       /* input : pitch lag                            */
-     Word16 sharp,                         /* input : pitch sharpening factor (Q15)        */
-     Word16 L_subfr                        /* input : subframe size                        */
-);
-
-
-/*-----------------------------------------------------------------*
- *                        others prototypes                        *
- *-----------------------------------------------------------------*/
-
-void Copy(
-     Word16 x[],                           /* (i)   : input vector   */
-     Word16 y[],                           /* (o)   : output vector  */
-     Word16 L                              /* (i)   : vector length  */
-);
-void Set_zero(
-     Word16 x[],                           /* (o)    : vector to clear     */
-     Word16 L                              /* (i)    : length of vector    */
-);
-void Updt_tar(
-     Word16 * x,                           /* (i) Q0  : old target (for pitch search)     */
-     Word16 * x2,                          /* (o) Q0  : new target (for codebook search)  */
-     Word16 * y,                           /* (i) Q0  : filtered adaptive codebook vector */
-     Word16 gain,                          /* (i) Q14 : adaptive codebook gain            */
-     Word16 L                              /* (i)     : subframe size                     */
-);
-Word16 voice_factor(                       /* (o) Q15 : factor (-1=unvoiced to 1=voiced) */
-     Word16 exc[],                         /* (i) Q_exc: pitch excitation                */
-     Word16 Q_exc,                         /* (i)     : exc format                       */
-     Word16 gain_pit,                      /* (i) Q14 : gain of pitch                    */
-     Word16 code[],                        /* (i) Q9  : Fixed codebook excitation        */
-     Word16 gain_code,                     /* (i) Q0  : gain of code                     */
-     Word16 L_subfr                        /* (i)     : subframe length                  */
-);
-void Scale_sig(
-     Word16 x[],                           /* (i/o) : signal to scale               */
-     Word16 lg,                            /* (i)   : size of x[]                   */
-     Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
-);
-
-void Scale_sig_opt(
-     Word16 x[],                           /* (i/o) : signal to scale               */
-     Word16 lg,                            /* (i)   : size of x[]                   */
-     Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
-);
-
-Word16 Random(Word16 * seed);
-
-void Init_gp_clip(
-     Word16 mem[]                          /* (o) : memory of gain of pitch clipping algorithm */
-);
-Word16 Gp_clip(
-     Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
-);
-void Gp_clip_test_isf(
-     Word16 isf[],                         /* (i)   : isf values (in frequency domain)           */
-     Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
-);
-void Gp_clip_test_gain_pit(
-     Word16 gain_pit,                      /* (i)   : gain of quantized pitch                    */
-     Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
-);
-
-
-#endif   //__ACELP_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+ *                         ACELP.H                                          *
+ *--------------------------------------------------------------------------*
+ *       Function			 			             *
+ *--------------------------------------------------------------------------*/
+#ifndef __ACELP_H__
+#define __ACELP_H__
+
+#include "typedef.h"
+#include "cod_main.h"
+
+/*-----------------------------------------------------------------*
+ *                        LPC prototypes                           *
+ *-----------------------------------------------------------------*/
+
+Word16 median5(Word16 x[]);
+
+void Autocorr(
+		Word16 x[],                           /* (i)    : Input signal                      */
+		Word16 m,                             /* (i)    : LPC order                         */
+		Word16 r_h[],                         /* (o)    : Autocorrelations  (msb)           */
+		Word16 r_l[]                          /* (o)    : Autocorrelations  (lsb)           */
+	     );
+
+void Lag_window(
+		Word16 r_h[],                         /* (i/o)   : Autocorrelations  (msb)          */
+		Word16 r_l[]                          /* (i/o)   : Autocorrelations  (lsb)          */
+	       );
+
+void Init_Levinson(
+		Word16 * mem                          /* output  :static memory (18 words) */
+		);
+
+void Levinson(
+		Word16 Rh[],                          /* (i)     : Rh[M+1] Vector of autocorrelations (msb) */
+		Word16 Rl[],                          /* (i)     : Rl[M+1] Vector of autocorrelations (lsb) */
+		Word16 A[],                           /* (o) Q12 : A[M]    LPC coefficients  (m = 16)       */
+		Word16 rc[],                          /* (o) Q15 : rc[M]   Reflection coefficients.         */
+		Word16 * mem                          /* (i/o)   :static memory (18 words)                  */
+	     );
+
+void Az_isp(
+		Word16 a[],                           /* (i) Q12 : predictor coefficients                 */
+		Word16 isp[],                         /* (o) Q15 : Immittance spectral pairs              */
+		Word16 old_isp[]                      /* (i)     : old isp[] (in case not found M roots)  */
+	   );
+
+void Isp_Az(
+		Word16 isp[],                         /* (i) Q15 : Immittance spectral pairs            */
+		Word16 a[],                           /* (o) Q12 : predictor coefficients (order = M)   */
+		Word16 m,
+		Word16 adaptive_scaling               /* (i) 0   : adaptive scaling disabled */
+		/*     1   : adaptive scaling enabled  */
+	   );
+
+void Isp_isf(
+		Word16 isp[],                         /* (i) Q15 : isp[m] (range: -1<=val<1)                */
+		Word16 isf[],                         /* (o) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
+		Word16 m                              /* (i)     : LPC order                                */
+	    );
+
+void Isf_isp(
+		Word16 isf[],                         /* (i) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
+		Word16 isp[],                         /* (o) Q15 : isp[m] (range: -1<=val<1)                */
+		Word16 m                              /* (i)     : LPC order                                */
+	    );
+
+void Int_isp(
+		Word16 isp_old[],                     /* input : isps from past frame              */
+		Word16 isp_new[],                     /* input : isps from present frame           */
+		Word16 frac[],                        /* input : fraction for 3 first subfr (Q15)  */
+		Word16 Az[]                           /* output: LP coefficients in 4 subframes    */
+	    );
+
+void Weight_a(
+		Word16 a[],                           /* (i) Q12 : a[m+1]  LPC coefficients             */
+		Word16 ap[],                          /* (o) Q12 : Spectral expanded LPC coefficients   */
+		Word16 gamma,                         /* (i) Q15 : Spectral expansion factor.           */
+		Word16 m                              /* (i)     : LPC order.                           */
+	     );
+
+
+/*-----------------------------------------------------------------*
+ *                        isf quantizers                           *
+ *-----------------------------------------------------------------*/
+
+void Qpisf_2s_46b(
+		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
+		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
+		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
+		Word16 * indice,                      /* (o)     : quantization indices                 */
+		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
+		);
+
+void Qpisf_2s_36b(
+		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
+		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
+		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
+		Word16 * indice,                      /* (o)     : quantization indices                 */
+		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
+		);
+
+void Dpisf_2s_46b(
+		Word16 * indice,                      /* input:  quantization indices                       */
+		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
+		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
+		Word16 * isfold,                      /* input : past quantized ISF                    */
+		Word16 * isf_buf,                     /* input : isf buffer                                                        */
+		Word16 bfi,                           /* input : Bad frame indicator                   */
+		Word16 enc_dec
+		);
+
+void Dpisf_2s_36b(
+		Word16 * indice,                      /* input:  quantization indices                       */
+		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
+		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
+		Word16 * isfold,                      /* input : past quantized ISF                    */
+		Word16 * isf_buf,                     /* input : isf buffer                                                        */
+		Word16 bfi,                           /* input : Bad frame indicator                   */
+		Word16 enc_dec
+		);
+
+void Qisf_ns(
+		Word16 * isf1,                        /* input : ISF in the frequency domain (0..0.5) */
+		Word16 * isf_q,                       /* output: quantized ISF                        */
+		Word16 * indice                       /* output: quantization indices                 */
+	    );
+
+void Disf_ns(
+		Word16 * indice,                      /* input:  quantization indices                  */
+		Word16 * isf_q                        /* input : ISF in the frequency domain (0..0.5)  */
+	    );
+
+Word16 Sub_VQ(                             /* output: return quantization index     */
+		Word16 * x,                           /* input : ISF residual vector           */
+		Word16 * dico,                        /* input : quantization codebook         */
+		Word16 dim,                           /* input : dimention of vector           */
+		Word16 dico_size,                     /* input : size of quantization codebook */
+		Word32 * distance                     /* output: error of quantization         */
+	     );
+
+void Reorder_isf(
+		Word16 * isf,                         /* (i/o) Q15: ISF in the frequency domain (0..0.5) */
+		Word16 min_dist,                      /* (i) Q15  : minimum distance to keep             */
+		Word16 n                              /* (i)      : number of ISF                        */
+		);
+
+/*-----------------------------------------------------------------*
+ *                       filter prototypes                         *
+ *-----------------------------------------------------------------*/
+
+void Init_Decim_12k8(
+		Word16 mem[]                          /* output: memory (2*NB_COEF_DOWN) set to zeros */
+		);
+void Decim_12k8(
+		Word16 sig16k[],                      /* input:  signal to downsampling  */
+		Word16 lg,                            /* input:  length of input         */
+		Word16 sig12k8[],                     /* output: decimated signal        */
+		Word16 mem[]                          /* in/out: memory (2*NB_COEF_DOWN) */
+	       );
+
+void Init_HP50_12k8(Word16 mem[]);
+void HP50_12k8(
+		Word16 signal[],                      /* input/output signal */
+		Word16 lg,                            /* lenght of signal    */
+		Word16 mem[]                          /* filter memory [6]   */
+	      );
+void Init_HP400_12k8(Word16 mem[]);
+void HP400_12k8(
+		Word16 signal[],                      /* input/output signal */
+		Word16 lg,                            /* lenght of signal    */
+		Word16 mem[]                          /* filter memory [6]   */
+	       );
+
+void Init_Filt_6k_7k(Word16 mem[]);
+void Filt_6k_7k(
+		Word16 signal[],                      /* input:  signal                  */
+		Word16 lg,                            /* input:  length of input         */
+		Word16 mem[]                          /* in/out: memory (size=30)        */
+	       );
+void Filt_6k_7k_asm(
+		Word16 signal[],                      /* input:  signal                  */
+		Word16 lg,                            /* input:  length of input         */
+		Word16 mem[]                          /* in/out: memory (size=30)        */
+	       );
+
+void LP_Decim2(
+		Word16 x[],                           /* in/out: signal to process         */
+		Word16 l,                             /* input : size of filtering         */
+		Word16 mem[]                          /* in/out: memory (size=3)           */
+	      );
+
+void Preemph(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
+		Word16 lg,                            /* (i)     : lenght of filtering                    */
+		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
+	    );
+void Preemph2(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
+		Word16 lg,                            /* (i)     : lenght of filtering                    */
+		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
+	     );
+void Deemph(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
+		Word16 L,                             /* (i)     : vector size                            */
+		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
+	   );
+void Deemph2(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
+		Word16 L,                             /* (i)     : vector size                            */
+		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
+	    );
+void Deemph_32(
+		Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
+		Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
+		Word16 y[],                           /* (o)     : output signal (x16)      */
+		Word16 mu,                            /* (i) Q15 : deemphasis factor        */
+		Word16 L,                             /* (i)     : vector size              */
+		Word16 * mem                          /* (i/o)   : memory (y[-1])           */
+	      );
+
+void Deemph_32_asm(
+		Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
+		Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
+		Word16 y[],                           /* (o)     : output signal (x16)      */
+		Word16 * mem                          /* (i/o)   : memory (y[-1])           */
+	      );
+
+void Convolve(
+		Word16 x[],                           /* (i)     : input vector                              */
+		Word16 h[],                           /* (i) Q15    : impulse response                       */
+		Word16 y[],                           /* (o) 12 bits: output vector                          */
+		Word16 L                              /* (i)     : vector size                               */
+	     );
+
+void Convolve_asm(
+		Word16 x[],                           /* (i)     : input vector                              */
+		Word16 h[],                           /* (i) Q15    : impulse response                       */
+		Word16 y[],                           /* (o) 12 bits: output vector                          */
+		Word16 L                              /* (i)     : vector size                               */
+	     );
+
+void Residu(
+		Word16 a[],                           /* (i) Q12 : prediction coefficients                     */
+		Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed         */
+		Word16 y[],                           /* (o)     : residual signal                             */
+		Word16 lg                             /* (i)     : size of filtering                           */
+		);
+
+void Residu_opt(
+		Word16 a[],                           /* (i) Q12 : prediction coefficients                     */
+		Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed         */
+		Word16 y[],                           /* (o)     : residual signal                             */
+		Word16 lg                             /* (i)     : size of filtering                           */
+		);
+
+void Syn_filt(
+	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
+	Word16 x[],                           /* (i)     : input signal                             */
+	Word16 y[],                           /* (o)     : output signal                            */
+	Word16 lg,                            /* (i)     : size of filtering                        */
+	Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
+	Word16 update                         /* (i)     : 0=no update, 1=update of memory.         */
+	);
+
+void Syn_filt_asm(
+	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
+	Word16 x[],                           /* (i)     : input signal                             */
+	Word16 y[],                           /* (o)     : output signal                            */
+	Word16 mem[]                          /* (i/o)   : memory associated with this filtering.   */
+	);
+
+void Syn_filt_32(
+	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
+	Word16 m,                             /* (i)     : order of LP filter             */
+	Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
+	Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
+	Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
+	Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
+	Word16 lg                             /* (i)     : size of filtering              */
+	);
+
+void Syn_filt_32_asm(
+	Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
+	Word16 m,                             /* (i)     : order of LP filter             */
+	Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
+	Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
+	Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
+	Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
+	Word16 lg                             /* (i)     : size of filtering              */
+	);
+/*-----------------------------------------------------------------*
+ *                       pitch prototypes                          *
+ *-----------------------------------------------------------------*/
+
+Word16 Pitch_ol(                           /* output: open loop pitch lag                        */
+     Word16 signal[],                      /* input : signal used to compute the open loop pitch */
+/* signal[-pit_max] to signal[-1] should be known */
+     Word16 pit_min,                       /* input : minimum pitch lag                          */
+     Word16 pit_max,                       /* input : maximum pitch lag                          */
+     Word16 L_frame                        /* input : length of frame to compute pitch           */
+);
+
+Word16 Pitch_med_ol(                       /* output: open loop pitch lag                        */
+     Word16 wsp[],                         /* input : signal used to compute the open loop pitch */
+                                           /* wsp[-pit_max] to wsp[-1] should be known   */
+     Coder_State *st,                      /* i/o : global codec structure */
+     Word16 L_frame                        /* input : length of frame to compute pitch           */
+);
+
+Word16 Med_olag(                           /* output : median of  5 previous open-loop lags       */
+     Word16 prev_ol_lag,                   /* input  : previous open-loop lag                     */
+     Word16 old_ol_lag[5]
+);
+
+void Init_Hp_wsp(Word16 mem[]);
+void scale_mem_Hp_wsp(Word16 mem[], Word16 exp);
+void Hp_wsp(
+     Word16 wsp[],                         /* i   : wsp[]  signal       */
+     Word16 hp_wsp[],                      /* o   : hypass wsp[]        */
+     Word16 lg,                            /* i   : lenght of signal    */
+     Word16 mem[]                          /* i/o : filter memory [9]   */
+);
+
+Word16 Pitch_fr4(                          /* (o)     : pitch period.                         */
+     Word16 exc[],                         /* (i)     : excitation buffer                     */
+     Word16 xn[],                          /* (i)     : target vector                         */
+     Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
+     Word16 t0_min,                        /* (i)     : minimum value in the searched range.  */
+     Word16 t0_max,                        /* (i)     : maximum value in the searched range.  */
+     Word16 * pit_frac,                    /* (o)     : chosen fraction (0, 1, 2 or 3).       */
+     Word16 i_subfr,                       /* (i)     : indicator for first subframe.         */
+     Word16 t0_fr2,                        /* (i)     : minimum value for resolution 1/2      */
+     Word16 t0_fr1,                        /* (i)     : minimum value for resolution 1        */
+     Word16 L_subfr                        /* (i)     : Length of subframe                    */
+);
+void Pred_lt4(
+     Word16 exc[],                         /* in/out: excitation buffer */
+     Word16 T0,                            /* input : integer pitch lag */
+     Word16 frac,                          /* input : fraction of lag   */
+     Word16 L_subfr                        /* input : subframe size     */
+);
+
+void pred_lt4_asm(
+     Word16 exc[],                         /* in/out: excitation buffer */
+     Word16 T0,                            /* input : integer pitch lag */
+     Word16 frac,                          /* input : fraction of lag   */
+     Word16 L_subfr                        /* input : subframe size     */
+);
+
+/*-----------------------------------------------------------------*
+ *                       gain prototypes                           *
+ *-----------------------------------------------------------------*/
+
+Word16 G_pitch(                            /* (o) Q14 : Gain of pitch lag saturated to 1.2   */
+     Word16 xn[],                          /* (i)     : Pitch target.                        */
+     Word16 y1[],                          /* (i)     : filtered adaptive codebook.          */
+     Word16 g_coeff[],                     /* : Correlations need for gain quantization. */
+     Word16 L_subfr                        /* : Length of subframe.                  */
+);
+void Init_Q_gain2(
+     Word16 * mem                          /* output  :static memory (2 words)      */
+);
+Word16 Q_gain2(                            /* Return index of quantization.        */
+     Word16 xn[],                          /* (i) Q_xn:Target vector.               */
+     Word16 y1[],                          /* (i) Q_xn:Adaptive codebook.           */
+     Word16 Q_xn,                          /* (i)     :xn and y1 format             */
+     Word16 y2[],                          /* (i) Q9  :Filtered innovative vector.  */
+     Word16 code[],                        /* (i) Q9  :Innovative vector.           */
+     Word16 g_coeff[],                     /* (i)     :Correlations <xn y1> <y1 y1> */
+/* Compute in G_pitch().        */
+     Word16 L_subfr,                       /* (i)     :Subframe lenght.             */
+     Word16 nbits,                         /* (i)     : number of bits (6 or 7)     */
+     Word16 * gain_pit,                    /* (i/o)Q14:Pitch gain.                  */
+     Word32 * gain_cod,                    /* (o) Q16 :Code gain.                   */
+     Word16 gp_clip,                       /* (i)     : Gp Clipping flag            */
+     Word16 * mem                          /* (i/o)   :static memory (2 words)      */
+);
+
+void Init_D_gain2(
+     Word16 * mem                          /* output  :static memory (4 words)      */
+);
+void D_gain2(
+     Word16 index,                         /* (i)     :index of quantization.       */
+     Word16 nbits,                         /* (i)     : number of bits (6 or 7)     */
+     Word16 code[],                        /* (i) Q9  :Innovative vector.           */
+     Word16 L_subfr,                       /* (i)     :Subframe lenght.             */
+     Word16 * gain_pit,                    /* (o) Q14 :Pitch gain.                  */
+     Word32 * gain_cod,                    /* (o) Q16 :Code gain.                   */
+     Word16 bfi,                           /* (i)     :bad frame indicator          */
+     Word16 prev_bfi,                      /* (i) : Previous BF indicator      */
+     Word16 state,                         /* (i) : State of BFH               */
+     Word16 unusable_frame,                /* (i) : UF indicator            */
+     Word16 vad_hist,                      /* (i)         :number of non-speech frames  */
+     Word16 * mem                          /* (i/o)   :static memory (4 words)      */
+);
+
+/*-----------------------------------------------------------------*
+ *                       acelp prototypes                          *
+ *-----------------------------------------------------------------*/
+
+void cor_h_x(
+     Word16 h[],                           /* (i) Q12 : impulse response of weighted synthesis filter */
+     Word16 x[],                           /* (i) Q0  : target vector                                 */
+     Word16 dn[]                           /* (o) <12bit : correlation between target and h[]         */
+);
+void ACELP_2t64_fx(
+     Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
+     Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
+     Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
+     Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
+     Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
+     Word16 * index                        /* (o) : index (12): 5+1+5+1 = 11 bits.                     */
+);
+
+void ACELP_4t64_fx(
+     Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
+     Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
+     Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
+     Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
+     Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
+     Word16 nbbits,                        /* (i) : 20, 36, 44, 52, 64, 72 or 88 bits                */
+     Word16 ser_size,                      /* (i) : bit rate                                         */
+     Word16 _index[]                       /* (o) : index (20): 5+5+5+5 = 20 bits.                   */
+					   /* (o) : index (36): 9+9+9+9 = 36 bits.                   */
+					   /* (o) : index (44): 13+9+13+9 = 44 bits.                 */
+					   /* (o) : index (52): 13+13+13+13 = 52 bits.               */
+					   /* (o) : index (64): 2+2+2+2+14+14+14+14 = 64 bits.       */
+					   /* (o) : index (72): 10+2+10+2+10+14+10+14 = 72 bits.     */
+					   /* (o) : index (88): 11+11+11+11+11+11+11+11 = 88 bits.   */
+);
+
+void Pit_shrp(
+     Word16 * x,                           /* in/out: impulse response (or algebraic code) */
+     Word16 pit_lag,                       /* input : pitch lag                            */
+     Word16 sharp,                         /* input : pitch sharpening factor (Q15)        */
+     Word16 L_subfr                        /* input : subframe size                        */
+);
+
+
+/*-----------------------------------------------------------------*
+ *                        others prototypes                        *
+ *-----------------------------------------------------------------*/
+
+void Copy(
+     Word16 x[],                           /* (i)   : input vector   */
+     Word16 y[],                           /* (o)   : output vector  */
+     Word16 L                              /* (i)   : vector length  */
+);
+void Set_zero(
+     Word16 x[],                           /* (o)    : vector to clear     */
+     Word16 L                              /* (i)    : length of vector    */
+);
+void Updt_tar(
+     Word16 * x,                           /* (i) Q0  : old target (for pitch search)     */
+     Word16 * x2,                          /* (o) Q0  : new target (for codebook search)  */
+     Word16 * y,                           /* (i) Q0  : filtered adaptive codebook vector */
+     Word16 gain,                          /* (i) Q14 : adaptive codebook gain            */
+     Word16 L                              /* (i)     : subframe size                     */
+);
+Word16 voice_factor(                       /* (o) Q15 : factor (-1=unvoiced to 1=voiced) */
+     Word16 exc[],                         /* (i) Q_exc: pitch excitation                */
+     Word16 Q_exc,                         /* (i)     : exc format                       */
+     Word16 gain_pit,                      /* (i) Q14 : gain of pitch                    */
+     Word16 code[],                        /* (i) Q9  : Fixed codebook excitation        */
+     Word16 gain_code,                     /* (i) Q0  : gain of code                     */
+     Word16 L_subfr                        /* (i)     : subframe length                  */
+);
+void Scale_sig(
+     Word16 x[],                           /* (i/o) : signal to scale               */
+     Word16 lg,                            /* (i)   : size of x[]                   */
+     Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
+);
+
+void Scale_sig_opt(
+     Word16 x[],                           /* (i/o) : signal to scale               */
+     Word16 lg,                            /* (i)   : size of x[]                   */
+     Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
+);
+
+Word16 Random(Word16 * seed);
+
+void Init_gp_clip(
+     Word16 mem[]                          /* (o) : memory of gain of pitch clipping algorithm */
+);
+Word16 Gp_clip(
+     Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
+);
+void Gp_clip_test_isf(
+     Word16 isf[],                         /* (i)   : isf values (in frequency domain)           */
+     Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
+);
+void Gp_clip_test_gain_pit(
+     Word16 gain_pit,                      /* (i)   : gain of quantized pitch                    */
+     Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
+);
+
+
+#endif   //__ACELP_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/basic_op.h b/media/libstagefright/codecs/amrwbenc/inc/basic_op.h
index 6a2f860..c23dce6 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/basic_op.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/basic_op.h
@@ -1,1094 +1,1094 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-#ifndef __BASIC_OP_H__
-#define __BASIC_OP_H__
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "typedef.h"
-
-#define MAX_32 (Word32)0x7fffffffL
-#define MIN_32 (Word32)0x80000000L
-
-#define MAX_16 (Word16)+32767	/* 0x7fff */
-#define MIN_16 (Word16)-32768	/* 0x8000 */
-
-
-#ifdef LINUX
-#define  static_vo  static __inline__
-#else
-#define  static_vo  static __inline
-#endif 
-
-#define saturate(L_var1) (((L_var1) > 0X00007fffL) ? (MAX_16): (((L_var1) < (Word32) 0xffff8000L) ? (MIN_16): ((L_var1) & 0xffff)))
-
-#define abs_s(x)       ((Word16)(((x) != MIN_16) ? (((x) >= 0) ? (x) : (-(x))) : MAX_16))  /* Short abs,           1   */
-#define L_deposit_h(x) (((Word32)(x)) << 16)                                               /* 16 bit var1 -> MSB,     2 */
-#define L_deposit_l(x) ((Word32)(x))                                                       /* 16 bit var1 -> LSB,     2 */
-#define L_abs(x) (((x) != MIN_32) ? (((x) >= 0) ? (x) : (-(x))) : MAX_32)                  /* Long abs,              3*/
-#define negate(var1) ((Word16)(((var1) == MIN_16) ? MAX_16 : (-(var1))))                   /* Short negate,        1*/
-#define L_negate(L_var1) (((L_var1) == (MIN_32)) ? (MAX_32) : (-(L_var1)))                 /* Long negate,     2*/
-
-
-#define extract_h(a)			((Word16)(a >> 16))
-#define extract_l(x)            	(Word16)((x))
-#define add1(a,b)			(a + b)
-#define vo_L_msu(a,b,c)			( a - (( b * c ) << 1) )
-#define vo_mult32(a, b)         ((a) * (b))
-#define vo_mult(a,b)			(( a * b ) >> 15 )
-#define	vo_L_mult(a,b)	    		(((a) * (b)) << 1)
-#define vo_shr_r(var1, var2)   		((var1+((Word16)(1L<<(var2-1))))>>var2)
-#define vo_sub(a,b)			(a - b)
-#define vo_L_deposit_h(a)		((Word32)((a) << 16))
-#define vo_round(a)			((a + 0x00008000) >> 16)
-#define vo_extract_l(a)			((Word16)(a))
-#define vo_L_add(a,b)			(a + b)
-#define vo_L_sub(a,b)			(a - b)
-#define vo_mult_r(a,b)			((( a * b ) + 0x4000 ) >> 15 )
-#define vo_negate(a)		        (-a)
-#define vo_L_shr_r(L_var1, var2)        ((L_var1+((Word32)(1L<<(var2-1))))>>var2)
-
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Prototypes for basic arithmetic operators                               |
-|___________________________________________________________________________|
-*/
-static_vo Word16 add (Word16 var1, Word16 var2);				/* Short add,1 */
-static_vo Word16 sub (Word16 var1, Word16 var2);				/* Short sub,1 */
-static_vo Word16 shl (Word16 var1, Word16 var2);                                /* Short shift left,    1   */
-static_vo Word16 shr (Word16 var1, Word16 var2);                                /* Short shift right,   1   */
-static_vo Word16 mult (Word16 var1, Word16 var2);                               /* Short mult,          1   */
-static_vo Word32 L_mult (Word16 var1, Word16 var2);                             /* Long mult,           1   */
-static_vo Word16 voround (Word32 L_var1);                                       /* Round,               1   */
-static_vo Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);            	/* Mac,  1  */
-static_vo Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);   		/* Msu,  1  */
-static_vo Word32 L_add (Word32 L_var1, Word32 L_var2);   		 	/* Long add,        2 */
-static_vo Word32 L_sub (Word32 L_var1, Word32 L_var2);   			/* Long sub,        2 */
-static_vo Word16 mult_r (Word16 var1, Word16 var2);      		 	/* Mult with round, 2 */
-static_vo Word32 L_shl2(Word32 L_var1, Word16 var2);             		/* var2 > 0*/
-static_vo Word32 L_shl (Word32 L_var1, Word16 var2);    	 	 	/* Long shift left, 2 */
-static_vo Word32 L_shr (Word32 L_var1, Word16 var2);    	 	 	/* Long shift right, 2*/
-static_vo Word32 L_shr_r (Word32 L_var1, Word16 var2); 				/* Long shift right with round,  3   */
-static_vo Word16 norm_s (Word16 var1);             				/* Short norm,           15  */
-static_vo Word16 div_s (Word16 var1, Word16 var2); 				/* Short division,       18  */
-static_vo Word16 norm_l (Word32 L_var1);           				/* Long norm,            30  */   
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Functions                                                               |
-|___________________________________________________________________________|
-*/
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : add                                                     |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|    Performs the addition (var1+var2) with overflow control and saturation;|
-|    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
-|    when underflow occurs.                                                 |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
-|___________________________________________________________________________|
-*/
-static_vo Word16 add (Word16 var1, Word16 var2)
-{
-	Word16 var_out;
-	Word32 L_sum;
-	L_sum = (Word32) var1 + var2;
-	var_out = saturate (L_sum);
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : sub                                                     |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|    Performs the subtraction (var1+var2) with overflow control and satu-   |
-|    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
-|    -32768 when underflow occurs.                                          |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 sub (Word16 var1, Word16 var2)
-{
-	Word16 var_out;
-	Word32 L_diff;
-	L_diff = (Word32) var1 - var2;
-	var_out = saturate (L_diff);
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : shl                                                     |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
-|   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
-|   var1 right by -var2 with sign extension. Saturate the result in case of |
-|   underflows or overflows.                                                |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 shl (Word16 var1, Word16 var2)
-{
-	Word16 var_out;
-	Word32 result;
-	if (var2 < 0)
-	{
-		if (var2 < -16)
-			var2 = -16;
-		var_out = var1 >> ((Word16)-var2);
-	}
-	else
-	{
-		result = (Word32) var1 *((Word32) 1 << var2);
-		if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
-		{
-			var_out = (Word16)((var1 > 0) ? MAX_16 : MIN_16);
-		}
-		else
-		{
-			var_out = extract_l (result);
-		}
-	}
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : shr                                                     |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Arithmetically shift the 16 bit input var1 right var2 positions with    |
-|   sign extension. If var2 is negative, arithmetically shift var1 left by  |
-|   -var2 with sign extension. Saturate the result in case of underflows or |
-|   overflows.                                                              |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 shr (Word16 var1, Word16 var2)
-{
-	Word16 var_out;
-	if (var2 < 0)
-	{
-		if (var2 < -16)
-			var2 = -16;
-		var_out = shl(var1, (Word16)-var2);
-	}
-	else
-	{
-		if (var2 >= 15)
-		{
-			var_out = (Word16)((var1 < 0) ? -1 : 0);
-		}
-		else
-		{
-			if (var1 < 0)
-			{
-				var_out = (Word16)(~((~var1) >> var2));
-			}
-			else
-			{
-				var_out = (Word16)(var1 >> var2);
-			}
-		}
-	}
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : mult                                                    |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
-|    which is scaled i.e.:                                                  |
-|             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
-|             mult(-32768,-32768) = 32767.                                  |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 mult (Word16 var1, Word16 var2)
-{
-	Word16 var_out;
-	Word32 L_product;
-	L_product = (Word32) var1 *(Word32) var2;
-	L_product = (L_product & (Word32) 0xffff8000L) >> 15;
-	if (L_product & (Word32) 0x00010000L)
-		L_product = L_product | (Word32) 0xffff0000L;
-	var_out = saturate (L_product);
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_mult                                                  |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   L_mult is the 32 bit result of the multiplication of var1 times var2    |
-|   with one shift left i.e.:                                               |
-|        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
-|        L_mult(-32768,-32768) = 2147483647.                                |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_mult (Word16 var1, Word16 var2)
-{
-	Word32 L_var_out;
-	L_var_out = (Word32) var1 *(Word32) var2;
-	if (L_var_out != (Word32) 0x40000000L)
-	{
-		L_var_out *= 2;
-	}
-	else
-	{
-		L_var_out = MAX_32;
-	}
-	return (L_var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : round                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
-|   with saturation. Shift the resulting bits right by 16 and return the 16 |
-|   bit number:                                                             |
-|               round(L_var1) = extract_h(L_add(L_var1,32768))              |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var1                                                                 |
-|             32 bit long signed integer (Word32 ) whose value falls in the |
-|             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 voround (Word32 L_var1)
-{
-	Word16 var_out;
-	Word32 L_rounded;
-	L_rounded = L_add (L_var1, (Word32) 0x00008000L);
-	var_out = extract_h (L_rounded);
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_mac                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
-|   result to L_var3 with saturation, return a 32 bit result:               |
-|        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
-{
-	Word32 L_var_out;
-	Word32 L_product;
-	L_product = ((var1 * var2) << 1);
-	L_var_out = L_add (L_var3, L_product);
-	return (L_var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_msu                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
-|   bit result to L_var3 with saturation, return a 32 bit result:           |
-|        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
-|                                                                           |
-|   Complexity weight : 1                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
-{
-	Word32 L_var_out;
-	Word32 L_product;
-	L_product = (var1 * var2)<<1;
-	L_var_out = L_sub (L_var3, L_product);
-	return (L_var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_add                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
-|   overflow control and saturation; the result is set at +2147483647 when  |
-|   overflow occurs or at -2147483648 when underflow occurs.                |
-|                                                                           |
-|   Complexity weight : 2                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_add (Word32 L_var1, Word32 L_var2)
-{
-	Word32 L_var_out;
-	L_var_out = L_var1 + L_var2;
-	if (((L_var1 ^ L_var2) & MIN_32) == 0)
-	{
-		if ((L_var_out ^ L_var1) & MIN_32)
-		{
-			L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
-		}
-	}
-	return (L_var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_sub                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
-|   overflow control and saturation; the result is set at +2147483647 when  |
-|   overflow occurs or at -2147483648 when underflow occurs.                |
-|                                                                           |
-|   Complexity weight : 2                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_sub (Word32 L_var1, Word32 L_var2)
-{
-	Word32 L_var_out;
-	L_var_out = L_var1 - L_var2;
-	if (((L_var1 ^ L_var2) & MIN_32) != 0)
-	{
-		if ((L_var_out ^ L_var1) & MIN_32)
-		{
-			L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
-		}
-	}
-	return (L_var_out);
-}
-
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : mult_r                                                  |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Same as mult with rounding, i.e.:                                       |
-|     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
-|     mult_r(-32768,-32768) = 32767.                                        |
-|                                                                           |
-|   Complexity weight : 2                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 mult_r (Word16 var1, Word16 var2)
-{
-	Word16 var_out;
-	Word32 L_product_arr;
-	L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
-	L_product_arr += (Word32) 0x00004000L;      /* round */
-	L_product_arr &= (Word32) 0xffff8000L;
-	L_product_arr >>= 15;       /* shift */
-	if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
-	{
-		L_product_arr |= (Word32) 0xffff0000L;
-	}
-	var_out = saturate (L_product_arr);
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_shl                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
-|   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
-|   shift L_var1 right by -var2 with sign extension. Saturate the result in |
-|   case of underflows or overflows.                                        |
-|                                                                           |
-|   Complexity weight : 2                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_shl (Word32 L_var1, Word16 var2)
-{
-	Word32 L_var_out = 0L;
-	if (var2 <= 0)
-	{
-		if (var2 < -32)
-			var2 = -32;
-		L_var_out = (L_var1 >> (Word16)-var2);
-	}
-	else
-	{
-		for (; var2 > 0; var2--)
-		{
-			if (L_var1 > (Word32) 0X3fffffffL)
-			{
-				L_var_out = MAX_32;
-				break;
-			}
-			else
-			{
-				if (L_var1 < (Word32) 0xc0000000L)
-				{
-					//Overflow = 1;
-					L_var_out = MIN_32;
-					break;
-				}
-			}
-			L_var1 *= 2;
-			L_var_out = L_var1;
-		}
-	}
-	return (L_var_out);
-}
-
-static_vo Word32 L_shl2(Word32 L_var1, Word16 var2)
-{
-	Word32 L_var_out = 0L;
-
-	for (; var2 > 0; var2--)
-	{
-		if (L_var1 > (Word32) 0X3fffffffL)
-		{
-			L_var_out = MAX_32;
-			break;
-		}
-		else
-		{
-			if (L_var1 < (Word32) 0xc0000000L)
-			{
-				L_var_out = MIN_32;
-				break;
-			}
-		}
-		L_var1 <<=1 ;
-		L_var_out = L_var1;
-	}
-	return (L_var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_shr                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
-|   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
-|   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
-|   in case of underflows or overflows.                                     |
-|                                                                           |
-|   Complexity weight : 2                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_shr (Word32 L_var1, Word16 var2)
-{
-	Word32 L_var_out;
-	if (var2 < 0)
-	{
-		if (var2 < -32)
-			var2 = -32;
-		L_var_out = L_shl2(L_var1, (Word16)-var2);
-	}
-	else
-	{
-		if (var2 >= 31)
-		{
-			L_var_out = (L_var1 < 0L) ? -1 : 0;
-		}
-		else
-		{
-			if (L_var1 < 0)
-			{
-				L_var_out = ~((~L_var1) >> var2);
-			}
-			else
-			{
-				L_var_out = L_var1 >> var2;
-			}
-		}
-	}
-	return (L_var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : L_shr_r                                                 |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
-|   case of underflows or overflows :                                       |
-|    - If var2 is greater than zero :                                       |
-|          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
-|          is equal to zero                                                 |
-|                     then                                                  |
-|                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
-|                     else                                                  |
-|                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
-|    - If var2 is less than or equal to zero :                              |
-|                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
-|                                                                           |
-|   Complexity weight : 3                                                   |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var1                                                                 |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    L_var_out                                                              |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word32 L_shr_r (Word32 L_var1, Word16 var2)
-{
-	Word32 L_var_out;
-	if (var2 > 31)
-	{
-		L_var_out = 0;
-	}
-	else
-	{
-		L_var_out = L_shr (L_var1, var2);
-		if (var2 > 0)
-		{
-			if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)
-			{
-				L_var_out++;
-			}
-		}
-	}
-	return (L_var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : norm_s                                                  |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Produces the number of left shift needed to normalize the 16 bit varia- |
-|   ble var1 for positive values on the interval with minimum of 16384 and  |
-|   maximum of 32767, and for negative values on the interval with minimum  |
-|   of -32768 and maximum of -16384; in order to normalize the result, the  |
-|   following operation must be done :                                      |
-|                    norm_var1 = shl(var1,norm_s(var1)).                    |
-|                                                                           |
-|   Complexity weight : 15                                                  |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0x0000 0000 <= var_out <= 0x0000 000f.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 norm_s (Word16 var1)
-{
-	Word16 var_out = 0;
-	if (var1 == 0)
-	{
-		var_out = 0;
-	}
-	else
-	{
-		if (var1 == -1)
-		{
-			var_out = 15;
-		}
-		else
-		{
-			if (var1 < 0)
-			{
-				var1 = (Word16)~var1;
-			}
-			for (var_out = 0; var1 < 0x4000; var_out++)
-			{
-				var1 <<= 1;
-			}
-		}
-	}
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : div_s                                                   |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Produces a result which is the fractional integer division of var1  by  |
-|   var2; var1 and var2 must be positive and var2 must be greater or equal  |
-|   to var1; the result is positive (leading bit equal to 0) and truncated  |
-|   to 16 bits.                                                             |
-|   If var1 = var2 then div(var1,var2) = 32767.                             |
-|                                                                           |
-|   Complexity weight : 18                                                  |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    var1                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0x0000 0000 <= var1 <= var2 and var2 != 0.            |
-|                                                                           |
-|    var2                                                                   |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : var1 <= var2 <= 0x0000 7fff and var2 != 0.            |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
-|             It's a Q15 value (point between b15 and b14).                 |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 div_s (Word16 var1, Word16 var2)
-{
-	Word16 var_out = 0;
-	Word16 iteration;
-	Word32 L_num;
-	Word32 L_denom;
-	if ((var1 < 0) || (var2 < 0))
-	{
-		var_out = MAX_16;
-		return var_out;
-	}
-	if (var2 == 0)
-	{
-		var_out = MAX_16;
-		return var_out;
-	}
-	if (var1 == 0)
-	{
-		var_out = 0;
-	}
-	else
-	{
-		if (var1 == var2)
-		{
-			var_out = MAX_16;
-		}
-		else
-		{
-			L_num = L_deposit_l (var1);
-			L_denom = L_deposit_l(var2);
-			for (iteration = 0; iteration < 15; iteration++)
-			{
-				var_out <<= 1;
-				L_num <<= 1;
-				if (L_num >= L_denom)
-				{
-					L_num -= L_denom;      
-					var_out += 1;          
-				}
-			}
-		}
-	}
-	return (var_out);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : norm_l                                                  |
-|                                                                           |
-|   Purpose :                                                               |
-|                                                                           |
-|   Produces the number of left shifts needed to normalize the 32 bit varia-|
-|   ble L_var1 for positive values on the interval with minimum of          |
-|   1073741824 and maximum of 2147483647, and for negative values on the in-|
-|   terval with minimum of -2147483648 and maximum of -1073741824; in order |
-|   to normalize the result, the following operation must be done :         |
-|                   norm_L_var1 = L_shl(L_var1,norm_l(L_var1)).             |
-|                                                                           |
-|   Complexity weight : 30                                                  |
-|                                                                           |
-|   Inputs :                                                                |
-|                                                                           |
-|    L_var1                                                                 |
-|             32 bit long signed integer (Word32) whose value falls in the  |
-|             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
-|                                                                           |
-|   Outputs :                                                               |
-|                                                                           |
-|    none                                                                   |
-|                                                                           |
-|   Return Value :                                                          |
-|                                                                           |
-|    var_out                                                                |
-|             16 bit short signed integer (Word16) whose value falls in the |
-|             range : 0x0000 0000 <= var_out <= 0x0000 001f.                |
-|___________________________________________________________________________|
-*/
-
-static_vo Word16 norm_l (Word32 L_var1)
-{
-	Word16 var_out = 0;
-	if (L_var1 != 0)
-	{
-		var_out = 31;
-		if (L_var1 != (Word32) 0xffffffffL)
-		{
-			L_var1 ^= (L_var1 >>31);
-			for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)
-			{
-				L_var1 <<= 1;
-			}
-		}
-	}
-	return (var_out);
-}
-
-#endif //__BASIC_OP_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+#ifndef __BASIC_OP_H__
+#define __BASIC_OP_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+
+#define MAX_32 (Word32)0x7fffffffL
+#define MIN_32 (Word32)0x80000000L
+
+#define MAX_16 (Word16)+32767	/* 0x7fff */
+#define MIN_16 (Word16)-32768	/* 0x8000 */
+
+
+#ifdef LINUX
+#define  static_vo  static __inline__
+#else
+#define  static_vo  static __inline
+#endif
+
+#define saturate(L_var1) (((L_var1) > 0X00007fffL) ? (MAX_16): (((L_var1) < (Word32) 0xffff8000L) ? (MIN_16): ((L_var1) & 0xffff)))
+
+#define abs_s(x)       ((Word16)(((x) != MIN_16) ? (((x) >= 0) ? (x) : (-(x))) : MAX_16))  /* Short abs,           1   */
+#define L_deposit_h(x) (((Word32)(x)) << 16)                                               /* 16 bit var1 -> MSB,     2 */
+#define L_deposit_l(x) ((Word32)(x))                                                       /* 16 bit var1 -> LSB,     2 */
+#define L_abs(x) (((x) != MIN_32) ? (((x) >= 0) ? (x) : (-(x))) : MAX_32)                  /* Long abs,              3*/
+#define negate(var1) ((Word16)(((var1) == MIN_16) ? MAX_16 : (-(var1))))                   /* Short negate,        1*/
+#define L_negate(L_var1) (((L_var1) == (MIN_32)) ? (MAX_32) : (-(L_var1)))                 /* Long negate,     2*/
+
+
+#define extract_h(a)			((Word16)(a >> 16))
+#define extract_l(x)            	(Word16)((x))
+#define add1(a,b)			(a + b)
+#define vo_L_msu(a,b,c)			( a - (( b * c ) << 1) )
+#define vo_mult32(a, b)         ((a) * (b))
+#define vo_mult(a,b)			(( a * b ) >> 15 )
+#define	vo_L_mult(a,b)	    		(((a) * (b)) << 1)
+#define vo_shr_r(var1, var2)   		((var1+((Word16)(1L<<(var2-1))))>>var2)
+#define vo_sub(a,b)			(a - b)
+#define vo_L_deposit_h(a)		((Word32)((a) << 16))
+#define vo_round(a)			((a + 0x00008000) >> 16)
+#define vo_extract_l(a)			((Word16)(a))
+#define vo_L_add(a,b)			(a + b)
+#define vo_L_sub(a,b)			(a - b)
+#define vo_mult_r(a,b)			((( a * b ) + 0x4000 ) >> 15 )
+#define vo_negate(a)		        (-a)
+#define vo_L_shr_r(L_var1, var2)        ((L_var1+((Word32)(1L<<(var2-1))))>>var2)
+
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Prototypes for basic arithmetic operators                               |
+|___________________________________________________________________________|
+*/
+static_vo Word16 add (Word16 var1, Word16 var2);				/* Short add,1 */
+static_vo Word16 sub (Word16 var1, Word16 var2);				/* Short sub,1 */
+static_vo Word16 shl (Word16 var1, Word16 var2);                                /* Short shift left,    1   */
+static_vo Word16 shr (Word16 var1, Word16 var2);                                /* Short shift right,   1   */
+static_vo Word16 mult (Word16 var1, Word16 var2);                               /* Short mult,          1   */
+static_vo Word32 L_mult (Word16 var1, Word16 var2);                             /* Long mult,           1   */
+static_vo Word16 voround (Word32 L_var1);                                       /* Round,               1   */
+static_vo Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);            	/* Mac,  1  */
+static_vo Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);   		/* Msu,  1  */
+static_vo Word32 L_add (Word32 L_var1, Word32 L_var2);   		 	/* Long add,        2 */
+static_vo Word32 L_sub (Word32 L_var1, Word32 L_var2);   			/* Long sub,        2 */
+static_vo Word16 mult_r (Word16 var1, Word16 var2);      		 	/* Mult with round, 2 */
+static_vo Word32 L_shl2(Word32 L_var1, Word16 var2);             		/* var2 > 0*/
+static_vo Word32 L_shl (Word32 L_var1, Word16 var2);    	 	 	/* Long shift left, 2 */
+static_vo Word32 L_shr (Word32 L_var1, Word16 var2);    	 	 	/* Long shift right, 2*/
+static_vo Word32 L_shr_r (Word32 L_var1, Word16 var2); 				/* Long shift right with round,  3   */
+static_vo Word16 norm_s (Word16 var1);             				/* Short norm,           15  */
+static_vo Word16 div_s (Word16 var1, Word16 var2); 				/* Short division,       18  */
+static_vo Word16 norm_l (Word32 L_var1);           				/* Long norm,            30  */
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Functions                                                               |
+|___________________________________________________________________________|
+*/
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : add                                                     |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|    Performs the addition (var1+var2) with overflow control and saturation;|
+|    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
+|    when underflow occurs.                                                 |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+|___________________________________________________________________________|
+*/
+static_vo Word16 add (Word16 var1, Word16 var2)
+{
+	Word16 var_out;
+	Word32 L_sum;
+	L_sum = (Word32) var1 + var2;
+	var_out = saturate (L_sum);
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : sub                                                     |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|    Performs the subtraction (var1+var2) with overflow control and satu-   |
+|    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
+|    -32768 when underflow occurs.                                          |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 sub (Word16 var1, Word16 var2)
+{
+	Word16 var_out;
+	Word32 L_diff;
+	L_diff = (Word32) var1 - var2;
+	var_out = saturate (L_diff);
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : shl                                                     |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
+|   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
+|   var1 right by -var2 with sign extension. Saturate the result in case of |
+|   underflows or overflows.                                                |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 shl (Word16 var1, Word16 var2)
+{
+	Word16 var_out;
+	Word32 result;
+	if (var2 < 0)
+	{
+		if (var2 < -16)
+			var2 = -16;
+		var_out = var1 >> ((Word16)-var2);
+	}
+	else
+	{
+		result = (Word32) var1 *((Word32) 1 << var2);
+		if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
+		{
+			var_out = (Word16)((var1 > 0) ? MAX_16 : MIN_16);
+		}
+		else
+		{
+			var_out = extract_l (result);
+		}
+	}
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : shr                                                     |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Arithmetically shift the 16 bit input var1 right var2 positions with    |
+|   sign extension. If var2 is negative, arithmetically shift var1 left by  |
+|   -var2 with sign extension. Saturate the result in case of underflows or |
+|   overflows.                                                              |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 shr (Word16 var1, Word16 var2)
+{
+	Word16 var_out;
+	if (var2 < 0)
+	{
+		if (var2 < -16)
+			var2 = -16;
+		var_out = shl(var1, (Word16)-var2);
+	}
+	else
+	{
+		if (var2 >= 15)
+		{
+			var_out = (Word16)((var1 < 0) ? -1 : 0);
+		}
+		else
+		{
+			if (var1 < 0)
+			{
+				var_out = (Word16)(~((~var1) >> var2));
+			}
+			else
+			{
+				var_out = (Word16)(var1 >> var2);
+			}
+		}
+	}
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : mult                                                    |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
+|    which is scaled i.e.:                                                  |
+|             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
+|             mult(-32768,-32768) = 32767.                                  |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 mult (Word16 var1, Word16 var2)
+{
+	Word16 var_out;
+	Word32 L_product;
+	L_product = (Word32) var1 *(Word32) var2;
+	L_product = (L_product & (Word32) 0xffff8000L) >> 15;
+	if (L_product & (Word32) 0x00010000L)
+		L_product = L_product | (Word32) 0xffff0000L;
+	var_out = saturate (L_product);
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_mult                                                  |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   L_mult is the 32 bit result of the multiplication of var1 times var2    |
+|   with one shift left i.e.:                                               |
+|        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
+|        L_mult(-32768,-32768) = 2147483647.                                |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_mult (Word16 var1, Word16 var2)
+{
+	Word32 L_var_out;
+	L_var_out = (Word32) var1 *(Word32) var2;
+	if (L_var_out != (Word32) 0x40000000L)
+	{
+		L_var_out *= 2;
+	}
+	else
+	{
+		L_var_out = MAX_32;
+	}
+	return (L_var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : round                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
+|   with saturation. Shift the resulting bits right by 16 and return the 16 |
+|   bit number:                                                             |
+|               round(L_var1) = extract_h(L_add(L_var1,32768))              |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var1                                                                 |
+|             32 bit long signed integer (Word32 ) whose value falls in the |
+|             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 voround (Word32 L_var1)
+{
+	Word16 var_out;
+	Word32 L_rounded;
+	L_rounded = L_add (L_var1, (Word32) 0x00008000L);
+	var_out = extract_h (L_rounded);
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_mac                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
+|   result to L_var3 with saturation, return a 32 bit result:               |
+|        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
+{
+	Word32 L_var_out;
+	Word32 L_product;
+	L_product = ((var1 * var2) << 1);
+	L_var_out = L_add (L_var3, L_product);
+	return (L_var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_msu                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
+|   bit result to L_var3 with saturation, return a 32 bit result:           |
+|        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
+|                                                                           |
+|   Complexity weight : 1                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
+{
+	Word32 L_var_out;
+	Word32 L_product;
+	L_product = (var1 * var2)<<1;
+	L_var_out = L_sub (L_var3, L_product);
+	return (L_var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_add                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
+|   overflow control and saturation; the result is set at +2147483647 when  |
+|   overflow occurs or at -2147483648 when underflow occurs.                |
+|                                                                           |
+|   Complexity weight : 2                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_add (Word32 L_var1, Word32 L_var2)
+{
+	Word32 L_var_out;
+	L_var_out = L_var1 + L_var2;
+	if (((L_var1 ^ L_var2) & MIN_32) == 0)
+	{
+		if ((L_var_out ^ L_var1) & MIN_32)
+		{
+			L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
+		}
+	}
+	return (L_var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_sub                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
+|   overflow control and saturation; the result is set at +2147483647 when  |
+|   overflow occurs or at -2147483648 when underflow occurs.                |
+|                                                                           |
+|   Complexity weight : 2                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_sub (Word32 L_var1, Word32 L_var2)
+{
+	Word32 L_var_out;
+	L_var_out = L_var1 - L_var2;
+	if (((L_var1 ^ L_var2) & MIN_32) != 0)
+	{
+		if ((L_var_out ^ L_var1) & MIN_32)
+		{
+			L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
+		}
+	}
+	return (L_var_out);
+}
+
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : mult_r                                                  |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Same as mult with rounding, i.e.:                                       |
+|     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
+|     mult_r(-32768,-32768) = 32767.                                        |
+|                                                                           |
+|   Complexity weight : 2                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 mult_r (Word16 var1, Word16 var2)
+{
+	Word16 var_out;
+	Word32 L_product_arr;
+	L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
+	L_product_arr += (Word32) 0x00004000L;      /* round */
+	L_product_arr &= (Word32) 0xffff8000L;
+	L_product_arr >>= 15;       /* shift */
+	if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
+	{
+		L_product_arr |= (Word32) 0xffff0000L;
+	}
+	var_out = saturate (L_product_arr);
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_shl                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
+|   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
+|   shift L_var1 right by -var2 with sign extension. Saturate the result in |
+|   case of underflows or overflows.                                        |
+|                                                                           |
+|   Complexity weight : 2                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_shl (Word32 L_var1, Word16 var2)
+{
+	Word32 L_var_out = 0L;
+	if (var2 <= 0)
+	{
+		if (var2 < -32)
+			var2 = -32;
+		L_var_out = (L_var1 >> (Word16)-var2);
+	}
+	else
+	{
+		for (; var2 > 0; var2--)
+		{
+			if (L_var1 > (Word32) 0X3fffffffL)
+			{
+				L_var_out = MAX_32;
+				break;
+			}
+			else
+			{
+				if (L_var1 < (Word32) 0xc0000000L)
+				{
+					//Overflow = 1;
+					L_var_out = MIN_32;
+					break;
+				}
+			}
+			L_var1 *= 2;
+			L_var_out = L_var1;
+		}
+	}
+	return (L_var_out);
+}
+
+static_vo Word32 L_shl2(Word32 L_var1, Word16 var2)
+{
+	Word32 L_var_out = 0L;
+
+	for (; var2 > 0; var2--)
+	{
+		if (L_var1 > (Word32) 0X3fffffffL)
+		{
+			L_var_out = MAX_32;
+			break;
+		}
+		else
+		{
+			if (L_var1 < (Word32) 0xc0000000L)
+			{
+				L_var_out = MIN_32;
+				break;
+			}
+		}
+		L_var1 <<=1 ;
+		L_var_out = L_var1;
+	}
+	return (L_var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_shr                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
+|   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
+|   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
+|   in case of underflows or overflows.                                     |
+|                                                                           |
+|   Complexity weight : 2                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_shr (Word32 L_var1, Word16 var2)
+{
+	Word32 L_var_out;
+	if (var2 < 0)
+	{
+		if (var2 < -32)
+			var2 = -32;
+		L_var_out = L_shl2(L_var1, (Word16)-var2);
+	}
+	else
+	{
+		if (var2 >= 31)
+		{
+			L_var_out = (L_var1 < 0L) ? -1 : 0;
+		}
+		else
+		{
+			if (L_var1 < 0)
+			{
+				L_var_out = ~((~L_var1) >> var2);
+			}
+			else
+			{
+				L_var_out = L_var1 >> var2;
+			}
+		}
+	}
+	return (L_var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : L_shr_r                                                 |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
+|   case of underflows or overflows :                                       |
+|    - If var2 is greater than zero :                                       |
+|          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
+|          is equal to zero                                                 |
+|                     then                                                  |
+|                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
+|                     else                                                  |
+|                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
+|    - If var2 is less than or equal to zero :                              |
+|                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
+|                                                                           |
+|   Complexity weight : 3                                                   |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var1                                                                 |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    L_var_out                                                              |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word32 L_shr_r (Word32 L_var1, Word16 var2)
+{
+	Word32 L_var_out;
+	if (var2 > 31)
+	{
+		L_var_out = 0;
+	}
+	else
+	{
+		L_var_out = L_shr (L_var1, var2);
+		if (var2 > 0)
+		{
+			if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)
+			{
+				L_var_out++;
+			}
+		}
+	}
+	return (L_var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : norm_s                                                  |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Produces the number of left shift needed to normalize the 16 bit varia- |
+|   ble var1 for positive values on the interval with minimum of 16384 and  |
+|   maximum of 32767, and for negative values on the interval with minimum  |
+|   of -32768 and maximum of -16384; in order to normalize the result, the  |
+|   following operation must be done :                                      |
+|                    norm_var1 = shl(var1,norm_s(var1)).                    |
+|                                                                           |
+|   Complexity weight : 15                                                  |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0x0000 0000 <= var_out <= 0x0000 000f.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 norm_s (Word16 var1)
+{
+	Word16 var_out = 0;
+	if (var1 == 0)
+	{
+		var_out = 0;
+	}
+	else
+	{
+		if (var1 == -1)
+		{
+			var_out = 15;
+		}
+		else
+		{
+			if (var1 < 0)
+			{
+				var1 = (Word16)~var1;
+			}
+			for (var_out = 0; var1 < 0x4000; var_out++)
+			{
+				var1 <<= 1;
+			}
+		}
+	}
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : div_s                                                   |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Produces a result which is the fractional integer division of var1  by  |
+|   var2; var1 and var2 must be positive and var2 must be greater or equal  |
+|   to var1; the result is positive (leading bit equal to 0) and truncated  |
+|   to 16 bits.                                                             |
+|   If var1 = var2 then div(var1,var2) = 32767.                             |
+|                                                                           |
+|   Complexity weight : 18                                                  |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    var1                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0x0000 0000 <= var1 <= var2 and var2 != 0.            |
+|                                                                           |
+|    var2                                                                   |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : var1 <= var2 <= 0x0000 7fff and var2 != 0.            |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
+|             It's a Q15 value (point between b15 and b14).                 |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 div_s (Word16 var1, Word16 var2)
+{
+	Word16 var_out = 0;
+	Word16 iteration;
+	Word32 L_num;
+	Word32 L_denom;
+	if ((var1 < 0) || (var2 < 0))
+	{
+		var_out = MAX_16;
+		return var_out;
+	}
+	if (var2 == 0)
+	{
+		var_out = MAX_16;
+		return var_out;
+	}
+	if (var1 == 0)
+	{
+		var_out = 0;
+	}
+	else
+	{
+		if (var1 == var2)
+		{
+			var_out = MAX_16;
+		}
+		else
+		{
+			L_num = L_deposit_l (var1);
+			L_denom = L_deposit_l(var2);
+			for (iteration = 0; iteration < 15; iteration++)
+			{
+				var_out <<= 1;
+				L_num <<= 1;
+				if (L_num >= L_denom)
+				{
+					L_num -= L_denom;
+					var_out += 1;
+				}
+			}
+		}
+	}
+	return (var_out);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : norm_l                                                  |
+|                                                                           |
+|   Purpose :                                                               |
+|                                                                           |
+|   Produces the number of left shifts needed to normalize the 32 bit varia-|
+|   ble L_var1 for positive values on the interval with minimum of          |
+|   1073741824 and maximum of 2147483647, and for negative values on the in-|
+|   terval with minimum of -2147483648 and maximum of -1073741824; in order |
+|   to normalize the result, the following operation must be done :         |
+|                   norm_L_var1 = L_shl(L_var1,norm_l(L_var1)).             |
+|                                                                           |
+|   Complexity weight : 30                                                  |
+|                                                                           |
+|   Inputs :                                                                |
+|                                                                           |
+|    L_var1                                                                 |
+|             32 bit long signed integer (Word32) whose value falls in the  |
+|             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+|                                                                           |
+|   Outputs :                                                               |
+|                                                                           |
+|    none                                                                   |
+|                                                                           |
+|   Return Value :                                                          |
+|                                                                           |
+|    var_out                                                                |
+|             16 bit short signed integer (Word16) whose value falls in the |
+|             range : 0x0000 0000 <= var_out <= 0x0000 001f.                |
+|___________________________________________________________________________|
+*/
+
+static_vo Word16 norm_l (Word32 L_var1)
+{
+	Word16 var_out = 0;
+	if (L_var1 != 0)
+	{
+		var_out = 31;
+		if (L_var1 != (Word32) 0xffffffffL)
+		{
+			L_var1 ^= (L_var1 >>31);
+			for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)
+			{
+				L_var1 <<= 1;
+			}
+		}
+	}
+	return (var_out);
+}
+
+#endif //__BASIC_OP_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/bits.h b/media/libstagefright/codecs/amrwbenc/inc/bits.h
index 77146de..e880684 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/bits.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/bits.h
@@ -1,92 +1,92 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
-*                         BITS.H                                           *
-*--------------------------------------------------------------------------*
-*       Number of bits for different modes			           *
-*--------------------------------------------------------------------------*/
-
-#ifndef __BITS_H__
-#define __BITS_H__
-
-#include <stdio.h>
-#include "typedef.h"
-#include "cnst.h"
-#include "cod_main.h"
-
-#define NBBITS_7k     132                  /* 6.60k  */
-#define NBBITS_9k     177                  /* 8.85k  */
-#define NBBITS_12k    253                  /* 12.65k */
-#define NBBITS_14k    285                  /* 14.25k */
-#define NBBITS_16k    317                  /* 15.85k */
-#define NBBITS_18k    365                  /* 18.25k */
-#define NBBITS_20k    397                  /* 19.85k */
-#define NBBITS_23k    461                  /* 23.05k */
-#define NBBITS_24k    477                  /* 23.85k */
-
-#define NBBITS_SID    35
-#define NB_BITS_MAX   NBBITS_24k
-
-#define BIT_0     (Word16)-127
-#define BIT_1     (Word16)127
-#define BIT_0_ITU (Word16)0x007F
-#define BIT_1_ITU (Word16)0x0081
-
-#define SIZE_MAX1  (3+NB_BITS_MAX)          /* serial size max */
-#define TX_FRAME_TYPE (Word16)0x6b21
-#define RX_FRAME_TYPE (Word16)0x6b20
-
-static const Word16 nb_of_bits[NUM_OF_MODES] = {
-	NBBITS_7k,
-	NBBITS_9k,
-	NBBITS_12k,
-	NBBITS_14k,
-	NBBITS_16k,
-	NBBITS_18k,
-	NBBITS_20k,
-	NBBITS_23k,
-	NBBITS_24k,
-	NBBITS_SID
-};
-
-/*typedef struct
-{
-Word16 sid_update_counter;
-Word16 sid_handover_debt;
-Word16 prev_ft;
-} TX_State;
-*/
-
-//typedef struct
-//{
-//	Word16 prev_ft;
-//	Word16 prev_mode;
-//} RX_State;
-
-int PackBits(Word16 prms[], Word16 coding_mode, Word16 mode, Coder_State *st);
-
-
-void Parm_serial(
-		Word16 value,                         /* input : parameter value */
-		Word16 no_of_bits,                    /* input : number of bits  */
-		Word16 ** prms
-		);
-
-
-#endif  //__BITS_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+*                         BITS.H                                           *
+*--------------------------------------------------------------------------*
+*       Number of bits for different modes			           *
+*--------------------------------------------------------------------------*/
+
+#ifndef __BITS_H__
+#define __BITS_H__
+
+#include <stdio.h>
+#include "typedef.h"
+#include "cnst.h"
+#include "cod_main.h"
+
+#define NBBITS_7k     132                  /* 6.60k  */
+#define NBBITS_9k     177                  /* 8.85k  */
+#define NBBITS_12k    253                  /* 12.65k */
+#define NBBITS_14k    285                  /* 14.25k */
+#define NBBITS_16k    317                  /* 15.85k */
+#define NBBITS_18k    365                  /* 18.25k */
+#define NBBITS_20k    397                  /* 19.85k */
+#define NBBITS_23k    461                  /* 23.05k */
+#define NBBITS_24k    477                  /* 23.85k */
+
+#define NBBITS_SID    35
+#define NB_BITS_MAX   NBBITS_24k
+
+#define BIT_0     (Word16)-127
+#define BIT_1     (Word16)127
+#define BIT_0_ITU (Word16)0x007F
+#define BIT_1_ITU (Word16)0x0081
+
+#define SIZE_MAX1  (3+NB_BITS_MAX)          /* serial size max */
+#define TX_FRAME_TYPE (Word16)0x6b21
+#define RX_FRAME_TYPE (Word16)0x6b20
+
+static const Word16 nb_of_bits[NUM_OF_MODES] = {
+	NBBITS_7k,
+	NBBITS_9k,
+	NBBITS_12k,
+	NBBITS_14k,
+	NBBITS_16k,
+	NBBITS_18k,
+	NBBITS_20k,
+	NBBITS_23k,
+	NBBITS_24k,
+	NBBITS_SID
+};
+
+/*typedef struct
+{
+Word16 sid_update_counter;
+Word16 sid_handover_debt;
+Word16 prev_ft;
+} TX_State;
+*/
+
+//typedef struct
+//{
+//	Word16 prev_ft;
+//	Word16 prev_mode;
+//} RX_State;
+
+int PackBits(Word16 prms[], Word16 coding_mode, Word16 mode, Coder_State *st);
+
+
+void Parm_serial(
+		Word16 value,                         /* input : parameter value */
+		Word16 no_of_bits,                    /* input : number of bits  */
+		Word16 ** prms
+		);
+
+
+#endif  //__BITS_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/cnst.h b/media/libstagefright/codecs/amrwbenc/inc/cnst.h
index ffdbd88..5395d2d 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/cnst.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/cnst.h
@@ -1,81 +1,81 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
- *                         CNST.H                                           *
- *--------------------------------------------------------------------------*
- *       Codec constant parameters (coder and decoder)                      *
- *--------------------------------------------------------------------------*/
-
-#ifndef __CNST_H__
-#define __CNST_H__
-
-#define L_FRAME16k   320                   /* Frame size at 16kHz                        */
-#define L_FRAME      256                   /* Frame size                                 */
-#define L_SUBFR16k   80                    /* Subframe size at 16kHz                     */
-
-#define L_SUBFR      64                    /* Subframe size                              */
-#define NB_SUBFR     4                     /* Number of subframe per frame               */
-
-#define L_NEXT       64                    /* Overhead in LP analysis                    */
-#define L_WINDOW     384                   /* window size in LP analysis                 */
-#define L_TOTAL      384                   /* Total size of speech buffer.               */
-#define M            16                    /* Order of LP filter                         */
-#define M16k         20
-
-#define L_FILT16k    15                    /* Delay of down-sampling filter              */
-#define L_FILT       12                    /* Delay of up-sampling filter                */
-
-#define GP_CLIP      15565                 /* Pitch gain clipping = 0.95 Q14             */
-#define PIT_SHARP    27853                 /* pitch sharpening factor = 0.85 Q15         */
-
-#define PIT_MIN      34                    /* Minimum pitch lag with resolution 1/4      */
-#define PIT_FR2      128                   /* Minimum pitch lag with resolution 1/2      */
-#define PIT_FR1_9b   160                   /* Minimum pitch lag with resolution 1        */
-#define PIT_FR1_8b   92                    /* Minimum pitch lag with resolution 1        */
-#define PIT_MAX      231                   /* Maximum pitch lag                          */
-#define L_INTERPOL   (16+1)                /* Length of filter for interpolation         */
-
-#define OPL_DECIM    2                     /* Decimation in open-loop pitch analysis     */
-
-#define PREEMPH_FAC  22282                 /* preemphasis factor (0.68 in Q15)           */
-#define GAMMA1       30147                 /* Weighting factor (numerator) (0.92 in Q15) */
-#define TILT_FAC     22282                 /* tilt factor (denominator) (0.68 in Q15)    */
-
-#define Q_MAX        8                     /* scaling max for signal (see syn_filt_32)   */
-
-#define RANDOM_INITSEED  21845             /* own random init value                      */
-
-#define L_MEANBUF        3
-#define ONE_PER_MEANBUF 10923
-
-#define MODE_7k       0
-#define MODE_9k       1
-#define MODE_12k      2
-#define MODE_14k      3
-#define MODE_16k      4
-#define MODE_18k      5
-#define MODE_20k      6
-#define MODE_23k      7
-#define MODE_24k      8
-#define MRDTX         9
-#define NUM_OF_MODES  10                   /* see bits.h for bits definition             */
-
-#define EHF_MASK (Word16)0x0008            /* homing frame pattern                       */
-
-#endif //__CNST_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+ *                         CNST.H                                           *
+ *--------------------------------------------------------------------------*
+ *       Codec constant parameters (coder and decoder)                      *
+ *--------------------------------------------------------------------------*/
+
+#ifndef __CNST_H__
+#define __CNST_H__
+
+#define L_FRAME16k   320                   /* Frame size at 16kHz                        */
+#define L_FRAME      256                   /* Frame size                                 */
+#define L_SUBFR16k   80                    /* Subframe size at 16kHz                     */
+
+#define L_SUBFR      64                    /* Subframe size                              */
+#define NB_SUBFR     4                     /* Number of subframe per frame               */
+
+#define L_NEXT       64                    /* Overhead in LP analysis                    */
+#define L_WINDOW     384                   /* window size in LP analysis                 */
+#define L_TOTAL      384                   /* Total size of speech buffer.               */
+#define M            16                    /* Order of LP filter                         */
+#define M16k         20
+
+#define L_FILT16k    15                    /* Delay of down-sampling filter              */
+#define L_FILT       12                    /* Delay of up-sampling filter                */
+
+#define GP_CLIP      15565                 /* Pitch gain clipping = 0.95 Q14             */
+#define PIT_SHARP    27853                 /* pitch sharpening factor = 0.85 Q15         */
+
+#define PIT_MIN      34                    /* Minimum pitch lag with resolution 1/4      */
+#define PIT_FR2      128                   /* Minimum pitch lag with resolution 1/2      */
+#define PIT_FR1_9b   160                   /* Minimum pitch lag with resolution 1        */
+#define PIT_FR1_8b   92                    /* Minimum pitch lag with resolution 1        */
+#define PIT_MAX      231                   /* Maximum pitch lag                          */
+#define L_INTERPOL   (16+1)                /* Length of filter for interpolation         */
+
+#define OPL_DECIM    2                     /* Decimation in open-loop pitch analysis     */
+
+#define PREEMPH_FAC  22282                 /* preemphasis factor (0.68 in Q15)           */
+#define GAMMA1       30147                 /* Weighting factor (numerator) (0.92 in Q15) */
+#define TILT_FAC     22282                 /* tilt factor (denominator) (0.68 in Q15)    */
+
+#define Q_MAX        8                     /* scaling max for signal (see syn_filt_32)   */
+
+#define RANDOM_INITSEED  21845             /* own random init value                      */
+
+#define L_MEANBUF        3
+#define ONE_PER_MEANBUF 10923
+
+#define MODE_7k       0
+#define MODE_9k       1
+#define MODE_12k      2
+#define MODE_14k      3
+#define MODE_16k      4
+#define MODE_18k      5
+#define MODE_20k      6
+#define MODE_23k      7
+#define MODE_24k      8
+#define MRDTX         9
+#define NUM_OF_MODES  10                   /* see bits.h for bits definition             */
+
+#define EHF_MASK (Word16)0x0008            /* homing frame pattern                       */
+
+#endif //__CNST_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/cod_main.h b/media/libstagefright/codecs/amrwbenc/inc/cod_main.h
index 1fd5787..53ca55e 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/cod_main.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/cod_main.h
@@ -1,103 +1,103 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
- *                         COD_MAIN.H                                       *
- *--------------------------------------------------------------------------*
- *       Static memory in the encoder				            *
- *--------------------------------------------------------------------------*/
-#ifndef __COD_MAIN_H__
-#define __COD_MAIN_H__
-
-#include "cnst.h"                          /* coder constant parameters */
-
-#include "wb_vad.h"
-#include "dtx.h"
-#include "stream.h"
-#include "voAMRWB.h"
-
-typedef struct
-{
-    Word16 mem_decim[2 * L_FILT16k];       /* speech decimated filter memory */
-    Word16 mem_sig_in[6];                  /* hp50 filter memory */
-    Word16 mem_preemph;                    /* speech preemph filter memory */
-    Word16 old_speech[L_TOTAL - L_FRAME];  /* old speech vector at 12.8kHz */
-    Word16 old_wsp[PIT_MAX / OPL_DECIM];   /* old decimated weighted speech vector */
-    Word16 old_exc[PIT_MAX + L_INTERPOL];  /* old excitation vector */
-    Word16 mem_levinson[M + 2];            /* levinson routine memory */
-    Word16 ispold[M];                      /* old isp (immittance spectral pairs) */
-    Word16 ispold_q[M];                    /* quantized old isp */
-    Word16 past_isfq[M];                   /* past isf quantizer */
-    Word16 mem_wsp;                        /* wsp vector memory */
-    Word16 mem_decim2[3];                  /* wsp decimation filter memory */
-    Word16 mem_w0;                         /* target vector memory */
-    Word16 mem_syn[M];                     /* synthesis memory */
-    Word16 tilt_code;                      /* tilt of code */
-    Word16 old_wsp_max;                    /* old wsp maximum value */
-    Word16 old_wsp_shift;                  /* old wsp shift */
-    Word16 Q_old;                          /* old scaling factor */
-    Word16 Q_max[2];                       /* old maximum scaling factor */
-    Word16 gp_clip[2];                     /* gain of pitch clipping memory */
-    Word16 qua_gain[4];                    /* gain quantizer memory */
-
-    Word16 old_T0_med;
-    Word16 ol_gain;
-    Word16 ada_w;
-    Word16 ol_wght_flg;
-    Word16 old_ol_lag[5];
-    Word16 hp_wsp_mem[9];
-    Word16 old_hp_wsp[L_FRAME / OPL_DECIM + (PIT_MAX / OPL_DECIM)];
-    VadVars *vadSt;
-    dtx_encState *dtx_encSt;
-    Word16 first_frame;
-    Word16 isfold[M];                      /* old isf (frequency domain) */
-    Word32 L_gc_thres;                     /* threshold for noise enhancer */
-    Word16 mem_syn_hi[M];                  /* modified synthesis memory (MSB) */
-    Word16 mem_syn_lo[M];                  /* modified synthesis memory (LSB) */
-    Word16 mem_deemph;                     /* speech deemph filter memory */
-    Word16 mem_sig_out[6];                 /* hp50 filter memory for synthesis */
-    Word16 mem_hp400[6];                   /* hp400 filter memory for synthesis */
-    Word16 mem_oversamp[2 * L_FILT];       /* synthesis oversampled filter memory */
-    Word16 mem_syn_hf[M];                  /* HF synthesis memory */
-    Word16 mem_hf[2 * L_FILT16k];          /* HF band-pass filter memory */
-    Word16 mem_hf2[2 * L_FILT16k];         /* HF band-pass filter memory */
-    Word16 seed2;                          /* random memory for HF generation */
-    Word16 vad_hist;
-    Word16 gain_alpha;
-    /*  TX_State structure  */
-	Word16 sid_update_counter;
-    Word16 sid_handover_debt;
-    Word16 prev_ft;
-	Word16 allow_dtx;
-	/*some input/output buffer parameters */
-	unsigned char       *inputStream;
-	int			        inputSize;
-	VOAMRWBMODE  		mode;
-	VOAMRWBFRAMETYPE	frameType;
-	unsigned short      *outputStream;
-	int			        outputSize;
-	FrameStream         *stream;
-	VO_MEM_OPERATOR     *pvoMemop;
-	VO_MEM_OPERATOR     voMemoprator;
-	VO_PTR              hCheck;
-} Coder_State;
-
-typedef void* HAMRENC;
-
-#endif  //__COD_MAIN_H__
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+ *                         COD_MAIN.H                                       *
+ *--------------------------------------------------------------------------*
+ *       Static memory in the encoder				            *
+ *--------------------------------------------------------------------------*/
+#ifndef __COD_MAIN_H__
+#define __COD_MAIN_H__
+
+#include "cnst.h"                          /* coder constant parameters */
+
+#include "wb_vad.h"
+#include "dtx.h"
+#include "stream.h"
+#include "voAMRWB.h"
+
+typedef struct
+{
+    Word16 mem_decim[2 * L_FILT16k];       /* speech decimated filter memory */
+    Word16 mem_sig_in[6];                  /* hp50 filter memory */
+    Word16 mem_preemph;                    /* speech preemph filter memory */
+    Word16 old_speech[L_TOTAL - L_FRAME];  /* old speech vector at 12.8kHz */
+    Word16 old_wsp[PIT_MAX / OPL_DECIM];   /* old decimated weighted speech vector */
+    Word16 old_exc[PIT_MAX + L_INTERPOL];  /* old excitation vector */
+    Word16 mem_levinson[M + 2];            /* levinson routine memory */
+    Word16 ispold[M];                      /* old isp (immittance spectral pairs) */
+    Word16 ispold_q[M];                    /* quantized old isp */
+    Word16 past_isfq[M];                   /* past isf quantizer */
+    Word16 mem_wsp;                        /* wsp vector memory */
+    Word16 mem_decim2[3];                  /* wsp decimation filter memory */
+    Word16 mem_w0;                         /* target vector memory */
+    Word16 mem_syn[M];                     /* synthesis memory */
+    Word16 tilt_code;                      /* tilt of code */
+    Word16 old_wsp_max;                    /* old wsp maximum value */
+    Word16 old_wsp_shift;                  /* old wsp shift */
+    Word16 Q_old;                          /* old scaling factor */
+    Word16 Q_max[2];                       /* old maximum scaling factor */
+    Word16 gp_clip[2];                     /* gain of pitch clipping memory */
+    Word16 qua_gain[4];                    /* gain quantizer memory */
+
+    Word16 old_T0_med;
+    Word16 ol_gain;
+    Word16 ada_w;
+    Word16 ol_wght_flg;
+    Word16 old_ol_lag[5];
+    Word16 hp_wsp_mem[9];
+    Word16 old_hp_wsp[L_FRAME / OPL_DECIM + (PIT_MAX / OPL_DECIM)];
+    VadVars *vadSt;
+    dtx_encState *dtx_encSt;
+    Word16 first_frame;
+    Word16 isfold[M];                      /* old isf (frequency domain) */
+    Word32 L_gc_thres;                     /* threshold for noise enhancer */
+    Word16 mem_syn_hi[M];                  /* modified synthesis memory (MSB) */
+    Word16 mem_syn_lo[M];                  /* modified synthesis memory (LSB) */
+    Word16 mem_deemph;                     /* speech deemph filter memory */
+    Word16 mem_sig_out[6];                 /* hp50 filter memory for synthesis */
+    Word16 mem_hp400[6];                   /* hp400 filter memory for synthesis */
+    Word16 mem_oversamp[2 * L_FILT];       /* synthesis oversampled filter memory */
+    Word16 mem_syn_hf[M];                  /* HF synthesis memory */
+    Word16 mem_hf[2 * L_FILT16k];          /* HF band-pass filter memory */
+    Word16 mem_hf2[2 * L_FILT16k];         /* HF band-pass filter memory */
+    Word16 seed2;                          /* random memory for HF generation */
+    Word16 vad_hist;
+    Word16 gain_alpha;
+    /*  TX_State structure  */
+	Word16 sid_update_counter;
+    Word16 sid_handover_debt;
+    Word16 prev_ft;
+	Word16 allow_dtx;
+	/*some input/output buffer parameters */
+	unsigned char       *inputStream;
+	int			        inputSize;
+	VOAMRWBMODE  		mode;
+	VOAMRWBFRAMETYPE	frameType;
+	unsigned short      *outputStream;
+	int			        outputSize;
+	FrameStream         *stream;
+	VO_MEM_OPERATOR     *pvoMemop;
+	VO_MEM_OPERATOR     voMemoprator;
+	VO_PTR              hCheck;
+} Coder_State;
+
+typedef void* HAMRENC;
+
+#endif  //__COD_MAIN_H__
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/dtx.h b/media/libstagefright/codecs/amrwbenc/inc/dtx.h
index e52c2d0..0bdda67 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/dtx.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/dtx.h
@@ -1,115 +1,115 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
- *                         DTX.H					    *
- *--------------------------------------------------------------------------*
- *       Static memory, constants and frametypes for the DTX 		    *
- *--------------------------------------------------------------------------*/
-
-#ifndef __DTX_H__
-#define __DTX_H__
-
-#define DTX_MAX_EMPTY_THRESH 50
-#define DTX_HIST_SIZE 8
-#define DTX_HIST_SIZE_MIN_ONE 7
-#define DTX_ELAPSED_FRAMES_THRESH (24 + 7 -1)
-#define DTX_HANG_CONST 7                   /* yields eight frames of SP HANGOVER  */
-#define INV_MED_THRESH 14564
-#define ISF_GAP  128                       /* 50 */
-#define ONE_MINUS_ISF_GAP 16384 - ISF_GAP
-#define ISF_GAP   128
-#define ISF_DITH_GAP   448
-#define ISF_FACTOR_LOW 256
-#define ISF_FACTOR_STEP 2
-#define GAIN_THR 180
-#define GAIN_FACTOR 75
-
-typedef struct
-{
-    Word16 isf_hist[M * DTX_HIST_SIZE];
-    Word16 log_en_hist[DTX_HIST_SIZE];
-    Word16 hist_ptr;
-    Word16 log_en_index;
-    Word16 cng_seed;
-    /* DTX handler stuff */
-    Word16 dtxHangoverCount;
-    Word16 decAnaElapsedCount;
-    Word32 D[28];
-    Word32 sumD[DTX_HIST_SIZE];
-} dtx_encState;
-
-#define SPEECH 0
-#define DTX 1
-#define DTX_MUTE 2
-
-#define TX_SPEECH 0
-#define TX_SID_FIRST 1
-#define TX_SID_UPDATE 2
-#define TX_NO_DATA 3
-
-#define RX_SPEECH_GOOD 0
-#define RX_SPEECH_PROBABLY_DEGRADED 1
-#define RX_SPEECH_LOST 2
-#define RX_SPEECH_BAD 3
-#define RX_SID_FIRST 4
-#define RX_SID_UPDATE 5
-#define RX_SID_BAD 6
-#define RX_NO_DATA 7
-
-/*****************************************************************************
- *
- * DEFINITION OF DATA TYPES
- *****************************************************************************/
-
-Word16 dtx_enc_init(dtx_encState ** st, Word16 isf_init[], VO_MEM_OPERATOR *pMemOP);
-Word16 dtx_enc_reset(dtx_encState * st, Word16 isf_init[]);
-void dtx_enc_exit(dtx_encState ** st, VO_MEM_OPERATOR *pMemOP);
-
-Word16 dtx_enc(
-     dtx_encState * st,                    /* i/o : State struct                                         */
-     Word16 isf[M],                        /* o   : CN ISF vector                                        */
-     Word16 * exc2,                        /* o   : CN excitation                                        */
-     Word16 ** prms
-);
-
-Word16 dtx_buffer(
-     dtx_encState * st,                    /* i/o : State struct                    */
-     Word16 isf_new[],                     /* i   : isf vector                      */
-     Word32 enr,                           /* i   : residual energy (in L_FRAME)    */
-     Word16 codec_mode
-);
-
-void tx_dtx_handler(dtx_encState * st,     /* i/o : State struct           */
-     Word16 vad_flag,                      /* i   : vad decision           */
-     Word16 * usedMode                     /* i/o : mode changed or not    */
-);
-
-void Qisf_ns(
-     Word16 * isf1,                        /* input : ISF in the frequency domain (0..0.5) */
-     Word16 * isf_q,                       /* output: quantized ISF                        */
-     Word16 * indice                       /* output: quantization indices                 */
-);
-
-
-void Disf_ns(
-     Word16 * indice,                      /* input:  quantization indices                  */
-     Word16 * isf_q                        /* input : ISF in the frequency domain (0..0.5)  */
-);
-
-#endif  //__DTX_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+ *                         DTX.H					    *
+ *--------------------------------------------------------------------------*
+ *       Static memory, constants and frametypes for the DTX 		    *
+ *--------------------------------------------------------------------------*/
+
+#ifndef __DTX_H__
+#define __DTX_H__
+
+#define DTX_MAX_EMPTY_THRESH 50
+#define DTX_HIST_SIZE 8
+#define DTX_HIST_SIZE_MIN_ONE 7
+#define DTX_ELAPSED_FRAMES_THRESH (24 + 7 -1)
+#define DTX_HANG_CONST 7                   /* yields eight frames of SP HANGOVER  */
+#define INV_MED_THRESH 14564
+#define ISF_GAP  128                       /* 50 */
+#define ONE_MINUS_ISF_GAP 16384 - ISF_GAP
+#define ISF_GAP   128
+#define ISF_DITH_GAP   448
+#define ISF_FACTOR_LOW 256
+#define ISF_FACTOR_STEP 2
+#define GAIN_THR 180
+#define GAIN_FACTOR 75
+
+typedef struct
+{
+    Word16 isf_hist[M * DTX_HIST_SIZE];
+    Word16 log_en_hist[DTX_HIST_SIZE];
+    Word16 hist_ptr;
+    Word16 log_en_index;
+    Word16 cng_seed;
+    /* DTX handler stuff */
+    Word16 dtxHangoverCount;
+    Word16 decAnaElapsedCount;
+    Word32 D[28];
+    Word32 sumD[DTX_HIST_SIZE];
+} dtx_encState;
+
+#define SPEECH 0
+#define DTX 1
+#define DTX_MUTE 2
+
+#define TX_SPEECH 0
+#define TX_SID_FIRST 1
+#define TX_SID_UPDATE 2
+#define TX_NO_DATA 3
+
+#define RX_SPEECH_GOOD 0
+#define RX_SPEECH_PROBABLY_DEGRADED 1
+#define RX_SPEECH_LOST 2
+#define RX_SPEECH_BAD 3
+#define RX_SID_FIRST 4
+#define RX_SID_UPDATE 5
+#define RX_SID_BAD 6
+#define RX_NO_DATA 7
+
+/*****************************************************************************
+ *
+ * DEFINITION OF DATA TYPES
+ *****************************************************************************/
+
+Word16 dtx_enc_init(dtx_encState ** st, Word16 isf_init[], VO_MEM_OPERATOR *pMemOP);
+Word16 dtx_enc_reset(dtx_encState * st, Word16 isf_init[]);
+void dtx_enc_exit(dtx_encState ** st, VO_MEM_OPERATOR *pMemOP);
+
+Word16 dtx_enc(
+     dtx_encState * st,                    /* i/o : State struct                                         */
+     Word16 isf[M],                        /* o   : CN ISF vector                                        */
+     Word16 * exc2,                        /* o   : CN excitation                                        */
+     Word16 ** prms
+);
+
+Word16 dtx_buffer(
+     dtx_encState * st,                    /* i/o : State struct                    */
+     Word16 isf_new[],                     /* i   : isf vector                      */
+     Word32 enr,                           /* i   : residual energy (in L_FRAME)    */
+     Word16 codec_mode
+);
+
+void tx_dtx_handler(dtx_encState * st,     /* i/o : State struct           */
+     Word16 vad_flag,                      /* i   : vad decision           */
+     Word16 * usedMode                     /* i/o : mode changed or not    */
+);
+
+void Qisf_ns(
+     Word16 * isf1,                        /* input : ISF in the frequency domain (0..0.5) */
+     Word16 * isf_q,                       /* output: quantized ISF                        */
+     Word16 * indice                       /* output: quantization indices                 */
+);
+
+
+void Disf_ns(
+     Word16 * indice,                      /* input:  quantization indices                  */
+     Word16 * isf_q                        /* input : ISF in the frequency domain (0..0.5)  */
+);
+
+#endif  //__DTX_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/grid100.tab b/media/libstagefright/codecs/amrwbenc/inc/grid100.tab
index efee18d..658d28d 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/grid100.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/grid100.tab
@@ -1,53 +1,53 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-
-/*-------------------------------------------------------------*
- *  Table for az_isp()                                         *
- *                                                             *
- * Vector grid[] is in Q15                                     *
- *                                                             *
- * grid[0] = 1.0;                                              *
- * grid[grid_points+1] = -1.0;                                 *
- * for (i = 1; i < grid_points; i++)                           *
- *   grid[i] = cos((6.283185307*i)/(2.0*grid_points));         *
- *                                                             *
- *-------------------------------------------------------------*/
-
-/* Version 101 points */
-
-#define   GRID_POINTS     100
-
-const Word16 vogrid[GRID_POINTS+1] ={
-    32767,     32751,     32703,     32622,     32509,     32364,
-    32187,     31978,     31738,     31466,     31164,     30830,
-    30466,     30072,     29649,     29196,     28714,     28204,
-    27666,     27101,     26509,     25891,     25248,     24579,
-    23886,     23170,     22431,     21669,     20887,     20083,
-    19260,     18418,     17557,     16680,     15786,     14876,
-    13951,     13013,     12062,     11099,     10125,      9141,
-     8149,      7148,      6140,      5126,      4106,      3083,
-     2057,      1029,         0,     -1029,     -2057,     -3083,
-    -4106,     -5126,     -6140,     -7148,     -8149,     -9141,
-   -10125,    -11099,    -12062,    -13013,    -13951,    -14876,
-   -15786,    -16680,    -17557,    -18418,    -19260,    -20083,
-   -20887,    -21669,    -22431,    -23170,    -23886,    -24579,
-   -25248,    -25891,    -26509,    -27101,    -27666,    -28204,
-   -28714,    -29196,    -29649,    -30072,    -30466,    -30830,
-   -31164,    -31466,    -31738,    -31978,    -32187,    -32364,
-   -32509,    -32622,    -32703,    -32751,    -32760};
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+
+/*-------------------------------------------------------------*
+ *  Table for az_isp()                                         *
+ *                                                             *
+ * Vector grid[] is in Q15                                     *
+ *                                                             *
+ * grid[0] = 1.0;                                              *
+ * grid[grid_points+1] = -1.0;                                 *
+ * for (i = 1; i < grid_points; i++)                           *
+ *   grid[i] = cos((6.283185307*i)/(2.0*grid_points));         *
+ *                                                             *
+ *-------------------------------------------------------------*/
+
+/* Version 101 points */
+
+#define   GRID_POINTS     100
+
+const Word16 vogrid[GRID_POINTS+1] ={
+    32767,     32751,     32703,     32622,     32509,     32364,
+    32187,     31978,     31738,     31466,     31164,     30830,
+    30466,     30072,     29649,     29196,     28714,     28204,
+    27666,     27101,     26509,     25891,     25248,     24579,
+    23886,     23170,     22431,     21669,     20887,     20083,
+    19260,     18418,     17557,     16680,     15786,     14876,
+    13951,     13013,     12062,     11099,     10125,      9141,
+     8149,      7148,      6140,      5126,      4106,      3083,
+     2057,      1029,         0,     -1029,     -2057,     -3083,
+    -4106,     -5126,     -6140,     -7148,     -8149,     -9141,
+   -10125,    -11099,    -12062,    -13013,    -13951,    -14876,
+   -15786,    -16680,    -17557,    -18418,    -19260,    -20083,
+   -20887,    -21669,    -22431,    -23170,    -23886,    -24579,
+   -25248,    -25891,    -26509,    -27101,    -27666,    -28204,
+   -28714,    -29196,    -29649,    -30072,    -30466,    -30830,
+   -31164,    -31466,    -31738,    -31978,    -32187,    -32364,
+   -32509,    -32622,    -32703,    -32751,    -32760};
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/ham_wind.tab b/media/libstagefright/codecs/amrwbenc/inc/ham_wind.tab
index 91f8690..560a997 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/ham_wind.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/ham_wind.tab
@@ -1,73 +1,73 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/* Hamming_cos window for LPC analysis.                 */
-/*   Create with function hamm_cos(window,384-128,128)  */
-
-#define L_WINDOW 384
-
-const Word16 vo_window[L_WINDOW] = {
-    2621,    2622,    2626,    2632,    2640,    2650,    2662,    2677,
-    2694,    2714,    2735,    2759,    2785,    2814,    2844,    2877,
-    2912,    2949,    2989,    3031,    3075,    3121,    3169,    3220,
-    3273,    3328,    3385,    3444,    3506,    3569,    3635,    3703,
-    3773,    3845,    3919,    3996,    4074,    4155,    4237,    4321,
-    4408,    4496,    4587,    4680,    4774,    4870,    4969,    5069,
-    5171,    5275,    5381,    5489,    5599,    5710,    5824,    5939,
-    6056,    6174,    6295,    6417,    6541,    6666,    6793,    6922,
-    7052,    7185,    7318,    7453,    7590,    7728,    7868,    8009,
-    8152,    8296,    8442,    8589,    8737,    8887,    9038,    9191,
-    9344,    9499,    9655,    9813,    9971,   10131,   10292,   10454,
-   10617,   10781,   10946,   11113,   11280,   11448,   11617,   11787,
-   11958,   12130,   12303,   12476,   12650,   12825,   13001,   13178,
-   13355,   13533,   13711,   13890,   14070,   14250,   14431,   14612,
-   14793,   14975,   15158,   15341,   15524,   15708,   15891,   16076,
-   16260,   16445,   16629,   16814,   16999,   17185,   17370,   17555,
-   17740,   17926,   18111,   18296,   18481,   18666,   18851,   19036,
-   19221,   19405,   19589,   19773,   19956,   20139,   20322,   20504,
-   20686,   20867,   21048,   21229,   21408,   21588,   21767,   21945,
-   22122,   22299,   22475,   22651,   22825,   22999,   23172,   23344,
-   23516,   23686,   23856,   24025,   24192,   24359,   24525,   24689,
-   24853,   25016,   25177,   25337,   25496,   25654,   25811,   25967,
-   26121,   26274,   26426,   26576,   26725,   26873,   27019,   27164,
-   27308,   27450,   27590,   27729,   27867,   28003,   28137,   28270,
-   28401,   28531,   28659,   28785,   28910,   29033,   29154,   29274,
-   29391,   29507,   29622,   29734,   29845,   29953,   30060,   30165,
-   30268,   30370,   30469,   30566,   30662,   30755,   30847,   30936,
-   31024,   31109,   31193,   31274,   31354,   31431,   31506,   31579,
-   31651,   31719,   31786,   31851,   31914,   31974,   32032,   32088,
-   32142,   32194,   32243,   32291,   32336,   32379,   32419,   32458,
-   32494,   32528,   32560,   32589,   32617,   32642,   32664,   32685,
-   32703,   32719,   32733,   32744,   32753,   32760,   32764,   32767,
-   32767,   32765,   32757,   32745,   32727,   32705,   32678,   32646,
-   32609,   32567,   32520,   32468,   32411,   32349,   32283,   32211,
-   32135,   32054,   31968,   31877,   31781,   31681,   31575,   31465,
-   31351,   31231,   31107,   30978,   30844,   30706,   30563,   30415,
-   30263,   30106,   29945,   29779,   29609,   29434,   29255,   29071,
-   28883,   28691,   28494,   28293,   28087,   27878,   27664,   27446,
-   27224,   26997,   26767,   26533,   26294,   26052,   25806,   25555,
-   25301,   25043,   24782,   24516,   24247,   23974,   23698,   23418,
-   23134,   22847,   22557,   22263,   21965,   21665,   21361,   21054,
-   20743,   20430,   20113,   19794,   19471,   19146,   18817,   18486,
-   18152,   17815,   17476,   17134,   16789,   16442,   16092,   15740,
-   15385,   15028,   14669,   14308,   13944,   13579,   13211,   12841,
-   12470,   12096,   11721,   11344,   10965,   10584,   10202,    9819,
-    9433,    9047,    8659,    8270,    7879,    7488,    7095,    6701,
-    6306,    5910,    5514,    5116,    4718,    4319,    3919,    3519,
-    3118,    2716,    2315,    1913,    1510,    1108,     705,     302};
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/* Hamming_cos window for LPC analysis.                 */
+/*   Create with function hamm_cos(window,384-128,128)  */
+
+#define L_WINDOW 384
+
+const Word16 vo_window[L_WINDOW] = {
+    2621,    2622,    2626,    2632,    2640,    2650,    2662,    2677,
+    2694,    2714,    2735,    2759,    2785,    2814,    2844,    2877,
+    2912,    2949,    2989,    3031,    3075,    3121,    3169,    3220,
+    3273,    3328,    3385,    3444,    3506,    3569,    3635,    3703,
+    3773,    3845,    3919,    3996,    4074,    4155,    4237,    4321,
+    4408,    4496,    4587,    4680,    4774,    4870,    4969,    5069,
+    5171,    5275,    5381,    5489,    5599,    5710,    5824,    5939,
+    6056,    6174,    6295,    6417,    6541,    6666,    6793,    6922,
+    7052,    7185,    7318,    7453,    7590,    7728,    7868,    8009,
+    8152,    8296,    8442,    8589,    8737,    8887,    9038,    9191,
+    9344,    9499,    9655,    9813,    9971,   10131,   10292,   10454,
+   10617,   10781,   10946,   11113,   11280,   11448,   11617,   11787,
+   11958,   12130,   12303,   12476,   12650,   12825,   13001,   13178,
+   13355,   13533,   13711,   13890,   14070,   14250,   14431,   14612,
+   14793,   14975,   15158,   15341,   15524,   15708,   15891,   16076,
+   16260,   16445,   16629,   16814,   16999,   17185,   17370,   17555,
+   17740,   17926,   18111,   18296,   18481,   18666,   18851,   19036,
+   19221,   19405,   19589,   19773,   19956,   20139,   20322,   20504,
+   20686,   20867,   21048,   21229,   21408,   21588,   21767,   21945,
+   22122,   22299,   22475,   22651,   22825,   22999,   23172,   23344,
+   23516,   23686,   23856,   24025,   24192,   24359,   24525,   24689,
+   24853,   25016,   25177,   25337,   25496,   25654,   25811,   25967,
+   26121,   26274,   26426,   26576,   26725,   26873,   27019,   27164,
+   27308,   27450,   27590,   27729,   27867,   28003,   28137,   28270,
+   28401,   28531,   28659,   28785,   28910,   29033,   29154,   29274,
+   29391,   29507,   29622,   29734,   29845,   29953,   30060,   30165,
+   30268,   30370,   30469,   30566,   30662,   30755,   30847,   30936,
+   31024,   31109,   31193,   31274,   31354,   31431,   31506,   31579,
+   31651,   31719,   31786,   31851,   31914,   31974,   32032,   32088,
+   32142,   32194,   32243,   32291,   32336,   32379,   32419,   32458,
+   32494,   32528,   32560,   32589,   32617,   32642,   32664,   32685,
+   32703,   32719,   32733,   32744,   32753,   32760,   32764,   32767,
+   32767,   32765,   32757,   32745,   32727,   32705,   32678,   32646,
+   32609,   32567,   32520,   32468,   32411,   32349,   32283,   32211,
+   32135,   32054,   31968,   31877,   31781,   31681,   31575,   31465,
+   31351,   31231,   31107,   30978,   30844,   30706,   30563,   30415,
+   30263,   30106,   29945,   29779,   29609,   29434,   29255,   29071,
+   28883,   28691,   28494,   28293,   28087,   27878,   27664,   27446,
+   27224,   26997,   26767,   26533,   26294,   26052,   25806,   25555,
+   25301,   25043,   24782,   24516,   24247,   23974,   23698,   23418,
+   23134,   22847,   22557,   22263,   21965,   21665,   21361,   21054,
+   20743,   20430,   20113,   19794,   19471,   19146,   18817,   18486,
+   18152,   17815,   17476,   17134,   16789,   16442,   16092,   15740,
+   15385,   15028,   14669,   14308,   13944,   13579,   13211,   12841,
+   12470,   12096,   11721,   11344,   10965,   10584,   10202,    9819,
+    9433,    9047,    8659,    8270,    7879,    7488,    7095,    6701,
+    6306,    5910,    5514,    5116,    4718,    4319,    3919,    3519,
+    3118,    2716,    2315,    1913,    1510,    1108,     705,     302};
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/homing.tab b/media/libstagefright/codecs/amrwbenc/inc/homing.tab
index 2963da7..e399fb8 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/homing.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/homing.tab
@@ -1,123 +1,123 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-
-#define DHF_PARMS_MAX 32               /* homing frame pattern  */
-#define NUM_OF_SPMODES 9
-
-#define PRML 15
-#define PRMN_7k NBBITS_7k/PRML + 1
-#define PRMN_9k NBBITS_9k/PRML + 1
-#define PRMN_12k NBBITS_12k/PRML + 1
-#define PRMN_14k NBBITS_14k/PRML + 1
-#define PRMN_16k NBBITS_16k/PRML + 1
-#define PRMN_18k NBBITS_18k/PRML + 1
-#define PRMN_20k NBBITS_20k/PRML + 1
-#define PRMN_23k NBBITS_23k/PRML + 1
-#define PRMN_24k NBBITS_24k/PRML + 1
-
-static const Word16 dfh_M7k[PRMN_7k] =
-{
-  3168, 29954, 29213, 16121, 
-	64, 13440, 30624, 16430, 
- 19008
-};
-
-static const Word16 dfh_M9k[PRMN_9k] =
-{
-   3168, 31665,  9943, 9123, 
-  15599,  4358, 20248, 2048, 
-  17040, 27787, 16816, 13888
-};
-
-static const Word16 dfh_M12k[PRMN_12k] =
-{
-  3168, 31665,  9943,  9128, 
-  3647,  8129, 30930, 27926, 
- 18880, 12319,   496,  1042, 
-  4061, 20446, 25629, 28069, 
- 13948
-};
-
-static const Word16 dfh_M14k[PRMN_14k] =
-{
-    3168, 31665,  9943,  9131, 
-   24815,   655, 26616, 26764, 
-    7238, 19136,  6144,    88, 
-	4158, 25733, 30567, 30494, 
-	221, 20321, 17823
-};
-
-static const Word16 dfh_M16k[PRMN_16k] =
-{
-    3168, 31665,  9943,  9131, 
-   24815,   700,  3824,  7271, 
-   26400,  9528,  6594, 26112, 
-     108,  2068, 12867, 16317, 
-   23035, 24632,  7528,  1752, 
-    6759, 24576
-};
-
-static const Word16 dfh_M18k[PRMN_18k] =
-{
-     3168, 31665,  9943,  9135, 
-	14787, 14423, 30477, 24927, 
-	25345, 30154,   916,  5728, 
-	18978,  2048,   528, 16449, 
-	 2436,  3581, 23527, 29479, 
-	 8237, 16810, 27091, 19052, 
-	    0
-};
-
-static const Word16 dfh_M20k[PRMN_20k] =
-{
-     3168, 31665,  9943,  9129, 
-	 8637, 31807, 24646,   736, 
-	28643,  2977,  2566, 25564, 
-	12930, 13960,  2048,   834, 
-	 3270,  4100, 26920, 16237, 
-	31227, 17667, 15059, 20589, 
-	30249, 29123, 0
-};
-
-static const Word16 dfh_M23k[PRMN_23k] =
-{
-	 3168, 31665,  9943,  9132, 
-	16748,  3202, 28179, 16317, 
-	30590, 15857, 19960,  8818, 
-	21711, 21538,  4260, 16690, 
-	20224,  3666,  4194,  9497, 
-	16320, 15388,  5755, 31551, 
-	14080,  3574, 15932,    50, 
-	23392, 26053, 31216
-};
-
-static const Word16 dfh_M24k[PRMN_24k] =
-{
-	 3168, 31665,  9943,  9134, 
-	24776,  5857, 18475, 28535, 
-	29662, 14321, 16725,  4396, 
-	29353, 10003, 17068, 20504, 
-	  720,     0,  8465, 12581, 
-	28863, 24774,  9709, 26043, 
-	 7941, 27649, 13965, 15236, 
-	18026, 22047, 16681,  3968
-};
-
-
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+
+#define DHF_PARMS_MAX 32               /* homing frame pattern  */
+#define NUM_OF_SPMODES 9
+
+#define PRML 15
+#define PRMN_7k NBBITS_7k/PRML + 1
+#define PRMN_9k NBBITS_9k/PRML + 1
+#define PRMN_12k NBBITS_12k/PRML + 1
+#define PRMN_14k NBBITS_14k/PRML + 1
+#define PRMN_16k NBBITS_16k/PRML + 1
+#define PRMN_18k NBBITS_18k/PRML + 1
+#define PRMN_20k NBBITS_20k/PRML + 1
+#define PRMN_23k NBBITS_23k/PRML + 1
+#define PRMN_24k NBBITS_24k/PRML + 1
+
+static const Word16 dfh_M7k[PRMN_7k] =
+{
+  3168, 29954, 29213, 16121,
+	64, 13440, 30624, 16430,
+ 19008
+};
+
+static const Word16 dfh_M9k[PRMN_9k] =
+{
+   3168, 31665,  9943, 9123,
+  15599,  4358, 20248, 2048,
+  17040, 27787, 16816, 13888
+};
+
+static const Word16 dfh_M12k[PRMN_12k] =
+{
+  3168, 31665,  9943,  9128,
+  3647,  8129, 30930, 27926,
+ 18880, 12319,   496,  1042,
+  4061, 20446, 25629, 28069,
+ 13948
+};
+
+static const Word16 dfh_M14k[PRMN_14k] =
+{
+    3168, 31665,  9943,  9131,
+   24815,   655, 26616, 26764,
+    7238, 19136,  6144,    88,
+	4158, 25733, 30567, 30494,
+	221, 20321, 17823
+};
+
+static const Word16 dfh_M16k[PRMN_16k] =
+{
+    3168, 31665,  9943,  9131,
+   24815,   700,  3824,  7271,
+   26400,  9528,  6594, 26112,
+     108,  2068, 12867, 16317,
+   23035, 24632,  7528,  1752,
+    6759, 24576
+};
+
+static const Word16 dfh_M18k[PRMN_18k] =
+{
+     3168, 31665,  9943,  9135,
+	14787, 14423, 30477, 24927,
+	25345, 30154,   916,  5728,
+	18978,  2048,   528, 16449,
+	 2436,  3581, 23527, 29479,
+	 8237, 16810, 27091, 19052,
+	    0
+};
+
+static const Word16 dfh_M20k[PRMN_20k] =
+{
+     3168, 31665,  9943,  9129,
+	 8637, 31807, 24646,   736,
+	28643,  2977,  2566, 25564,
+	12930, 13960,  2048,   834,
+	 3270,  4100, 26920, 16237,
+	31227, 17667, 15059, 20589,
+	30249, 29123, 0
+};
+
+static const Word16 dfh_M23k[PRMN_23k] =
+{
+	 3168, 31665,  9943,  9132,
+	16748,  3202, 28179, 16317,
+	30590, 15857, 19960,  8818,
+	21711, 21538,  4260, 16690,
+	20224,  3666,  4194,  9497,
+	16320, 15388,  5755, 31551,
+	14080,  3574, 15932,    50,
+	23392, 26053, 31216
+};
+
+static const Word16 dfh_M24k[PRMN_24k] =
+{
+	 3168, 31665,  9943,  9134,
+	24776,  5857, 18475, 28535,
+	29662, 14321, 16725,  4396,
+	29353, 10003, 17068, 20504,
+	  720,     0,  8465, 12581,
+	28863, 24774,  9709, 26043,
+	 7941, 27649, 13965, 15236,
+	18026, 22047, 16681,  3968
+};
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/isp_isf.tab b/media/libstagefright/codecs/amrwbenc/inc/isp_isf.tab
index ff20e38..97c3b68 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/isp_isf.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/isp_isf.tab
@@ -1,62 +1,62 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*-----------------------------------------------------*
- | Tables for function Isf_isp() and Isp_isf()         |
- *-----------------------------------------------------*/
-
-/* table of cos(x) in Q15 */
-
-const static Word16 table[129] = {
-  32767,
-  32758,  32729,  32679,  32610,  32522,  32413,  32286,  32138,
-  31972,  31786,  31581,  31357,  31114,  30853,  30572,  30274,
-  29957,  29622,  29269,  28899,  28511,  28106,  27684,  27246,
-  26791,  26320,  25833,  25330,  24812,  24279,  23732,  23170,
-  22595,  22006,  21403,  20788,  20160,  19520,  18868,  18205,
-  17531,  16846,  16151,  15447,  14733,  14010,  13279,  12540,
-  11793,  11039,  10279,   9512,   8740,   7962,   7180,   6393,
-   5602,   4808,   4011,   3212,   2411,   1608,    804,      0,
-   -804,  -1608,  -2411,  -3212,  -4011,  -4808,  -5602,  -6393,
-  -7180,  -7962,  -8740,  -9512, -10279, -11039, -11793, -12540,
- -13279, -14010, -14733, -15447, -16151, -16846, -17531, -18205,
- -18868, -19520, -20160, -20788, -21403, -22006, -22595, -23170,
- -23732, -24279, -24812, -25330, -25833, -26320, -26791, -27246,
- -27684, -28106, -28511, -28899, -29269, -29622, -29957, -30274,
- -30572, -30853, -31114, -31357, -31581, -31786, -31972, -32138,
- -32286, -32413, -32522, -32610, -32679, -32729, -32758, -32768};
-
-/* slope in Q11 used to compute y = acos(x) */
-
-const static Word16 slope[128] = { 
- -26214, -9039, -5243, -3799, -2979, -2405, -2064, -1771,
- -1579, -1409, -1279, -1170, -1079, -1004, -933, -880,
- -827, -783, -743, -708, -676, -647, -621, -599,
- -576, -557, -538, -521, -506, -492, -479, -466,
- -456, -445, -435, -426, -417, -410, -402, -395,
- -389, -383, -377, -372, -367, -363, -359, -355,
- -351, -348, -345, -342, -340, -337, -335, -333,
- -331, -330, -329, -328, -327, -326, -326, -326,
- -326, -326, -326, -327, -328, -329, -330, -331,
- -333, -335, -337, -340, -342, -345, -348, -351,
- -355, -359, -363, -367, -372, -377, -383, -389,
- -395, -402, -410, -417, -426, -435, -445, -456,
- -466, -479, -492, -506, -521, -538, -557, -576,
- -599, -621, -647, -676, -708, -743, -783, -827,
- -880, -933, -1004, -1079, -1170, -1279, -1409, -1579,
- -1771, -2064, -2405, -2979, -3799, -5243, -9039, -26214};
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*-----------------------------------------------------*
+ | Tables for function Isf_isp() and Isp_isf()         |
+ *-----------------------------------------------------*/
+
+/* table of cos(x) in Q15 */
+
+const static Word16 table[129] = {
+  32767,
+  32758,  32729,  32679,  32610,  32522,  32413,  32286,  32138,
+  31972,  31786,  31581,  31357,  31114,  30853,  30572,  30274,
+  29957,  29622,  29269,  28899,  28511,  28106,  27684,  27246,
+  26791,  26320,  25833,  25330,  24812,  24279,  23732,  23170,
+  22595,  22006,  21403,  20788,  20160,  19520,  18868,  18205,
+  17531,  16846,  16151,  15447,  14733,  14010,  13279,  12540,
+  11793,  11039,  10279,   9512,   8740,   7962,   7180,   6393,
+   5602,   4808,   4011,   3212,   2411,   1608,    804,      0,
+   -804,  -1608,  -2411,  -3212,  -4011,  -4808,  -5602,  -6393,
+  -7180,  -7962,  -8740,  -9512, -10279, -11039, -11793, -12540,
+ -13279, -14010, -14733, -15447, -16151, -16846, -17531, -18205,
+ -18868, -19520, -20160, -20788, -21403, -22006, -22595, -23170,
+ -23732, -24279, -24812, -25330, -25833, -26320, -26791, -27246,
+ -27684, -28106, -28511, -28899, -29269, -29622, -29957, -30274,
+ -30572, -30853, -31114, -31357, -31581, -31786, -31972, -32138,
+ -32286, -32413, -32522, -32610, -32679, -32729, -32758, -32768};
+
+/* slope in Q11 used to compute y = acos(x) */
+
+const static Word16 slope[128] = {
+ -26214, -9039, -5243, -3799, -2979, -2405, -2064, -1771,
+ -1579, -1409, -1279, -1170, -1079, -1004, -933, -880,
+ -827, -783, -743, -708, -676, -647, -621, -599,
+ -576, -557, -538, -521, -506, -492, -479, -466,
+ -456, -445, -435, -426, -417, -410, -402, -395,
+ -389, -383, -377, -372, -367, -363, -359, -355,
+ -351, -348, -345, -342, -340, -337, -335, -333,
+ -331, -330, -329, -328, -327, -326, -326, -326,
+ -326, -326, -326, -327, -328, -329, -330, -331,
+ -333, -335, -337, -340, -342, -345, -348, -351,
+ -355, -359, -363, -367, -372, -377, -383, -389,
+ -395, -402, -410, -417, -426, -435, -445, -456,
+ -466, -479, -492, -506, -521, -538, -557, -576,
+ -599, -621, -647, -676, -708, -743, -783, -827,
+ -880, -933, -1004, -1079, -1170, -1279, -1409, -1579,
+ -1771, -2064, -2405, -2979, -3799, -5243, -9039, -26214};
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/lag_wind.tab b/media/libstagefright/codecs/amrwbenc/inc/lag_wind.tab
index 4175d66..9c73357 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/lag_wind.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/lag_wind.tab
@@ -1,81 +1,81 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*-----------------------------------------------------*
- | Table of lag_window for autocorrelation.            |
- | noise floor = 1.0001   = (0.9999  on r[1] ..r[16])  |
- | Bandwidth expansion = 60 Hz                         |
- | Sampling frequency  = 12800 Hz                      |
- |                                                     |
- | Special double precision format. See "math_op.c"    |
- |                                                     |
- | lag_wind[0] =  1.00000000    (not stored)           |
- | lag_wind[1] =  0.99946642                           |
- | lag_wind[2] =  0.99816680                           |
- | lag_wind[3] =  0.99600452                           |
- | lag_wind[4] =  0.99298513                           |
- | lag_wind[5] =  0.98911655                           |
- | lag_wind[6] =  0.98440880                           |
- | lag_wind[7] =  0.97887397                           |
- | lag_wind[8] =  0.97252619                           |
- | lag_wind[9] =  0.96538186                           |
- | lag_wind[10]=  0.95745903                           |
- | lag_wind[11]=  0.94877797                           |
- | lag_wind[12]=  0.93936038                           |
- | lag_wind[13]=  0.92922986                           |
- | lag_wind[14]=  0.91841155                           |
- | lag_wind[15]=  0.90693212                           |
- | lag_wind[16]=  0.89481968                           |
- ------------------------------------------------------*/
-
-#define M 16
-
-static Word16 volag_h[M] = {
-      32750,
-      32707,
-      32637,
-      32538,
-      32411,
-      32257,
-      32075,
-      31867,
-      31633,
-      31374,
-      31089,
-      30780,
-      30449,
-      30094,
-      29718,
-      29321};
-
-static Word16 volag_l[M] = {
-      16896,
-      30464,
-       2496,
-       4480,
-      12160,
-       3520,
-      24320,
-      24192,
-      20736,
-        576,
-      18240,
-      31488,
-        128,
-      16704,
-      11520,
-      14784};
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*-----------------------------------------------------*
+ | Table of lag_window for autocorrelation.            |
+ | noise floor = 1.0001   = (0.9999  on r[1] ..r[16])  |
+ | Bandwidth expansion = 60 Hz                         |
+ | Sampling frequency  = 12800 Hz                      |
+ |                                                     |
+ | Special double precision format. See "math_op.c"    |
+ |                                                     |
+ | lag_wind[0] =  1.00000000    (not stored)           |
+ | lag_wind[1] =  0.99946642                           |
+ | lag_wind[2] =  0.99816680                           |
+ | lag_wind[3] =  0.99600452                           |
+ | lag_wind[4] =  0.99298513                           |
+ | lag_wind[5] =  0.98911655                           |
+ | lag_wind[6] =  0.98440880                           |
+ | lag_wind[7] =  0.97887397                           |
+ | lag_wind[8] =  0.97252619                           |
+ | lag_wind[9] =  0.96538186                           |
+ | lag_wind[10]=  0.95745903                           |
+ | lag_wind[11]=  0.94877797                           |
+ | lag_wind[12]=  0.93936038                           |
+ | lag_wind[13]=  0.92922986                           |
+ | lag_wind[14]=  0.91841155                           |
+ | lag_wind[15]=  0.90693212                           |
+ | lag_wind[16]=  0.89481968                           |
+ ------------------------------------------------------*/
+
+#define M 16
+
+static Word16 volag_h[M] = {
+      32750,
+      32707,
+      32637,
+      32538,
+      32411,
+      32257,
+      32075,
+      31867,
+      31633,
+      31374,
+      31089,
+      30780,
+      30449,
+      30094,
+      29718,
+      29321};
+
+static Word16 volag_l[M] = {
+      16896,
+      30464,
+       2496,
+       4480,
+      12160,
+       3520,
+      24320,
+      24192,
+      20736,
+        576,
+      18240,
+      31488,
+        128,
+      16704,
+      11520,
+      14784};
diff --git a/media/libstagefright/codecs/amrwbenc/inc/log2.h b/media/libstagefright/codecs/amrwbenc/inc/log2.h
index 91bdbec..b065eb4 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/log2.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/log2.h
@@ -1,62 +1,62 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/********************************************************************************
-*
-*      File             : log2.h
-*      Purpose          : Computes log2(L_x)
-*
-********************************************************************************
-*/
-#ifndef __LOG2_H__
-#define __LOG2_H__
- 
-/*
-********************************************************************************
-*                         INCLUDE FILES
-********************************************************************************
-*/
-#include "typedef.h"
- 
-/*
-********************************************************************************
-*                         DEFINITION OF DATA TYPES
-********************************************************************************
-*/
- 
-/*
-********************************************************************************
-*                         DECLARATION OF PROTOTYPES
-********************************************************************************
-*/
-void Log2 (
-		Word32 L_x,        /* (i) : input value                                 */
-		Word16 *exponent,  /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
-		Word16 *fraction   /* (o) : Fractional part of Log2. (range: 0<=val<1)*/
-	  );
-
-void Log2_norm (
-		Word32 L_x,         /* (i) : input value (normalized)                    */
-		Word16 exp,         /* (i) : norm_l (L_x)                                */
-		Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
-		Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1)  */
-	       );
-
-#endif  //__LOG2_H__
-
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/********************************************************************************
+*
+*      File             : log2.h
+*      Purpose          : Computes log2(L_x)
+*
+********************************************************************************
+*/
+#ifndef __LOG2_H__
+#define __LOG2_H__
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Log2 (
+		Word32 L_x,        /* (i) : input value                                 */
+		Word16 *exponent,  /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+		Word16 *fraction   /* (o) : Fractional part of Log2. (range: 0<=val<1)*/
+	  );
+
+void Log2_norm (
+		Word32 L_x,         /* (i) : input value (normalized)                    */
+		Word16 exp,         /* (i) : norm_l (L_x)                                */
+		Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+		Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1)  */
+	       );
+
+#endif  //__LOG2_H__
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/log2_tab.h b/media/libstagefright/codecs/amrwbenc/inc/log2_tab.h
index 7761ae6..85fa73c 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/log2_tab.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/log2_tab.h
@@ -1,35 +1,35 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-
-/*******************************************************************************
-*
-*      File             : log2.tab
-*      Purpose          : Table for routine Log2().
-*      $Id $
-*
-********************************************************************************
-*/
-static const Word16 table[33] =
-{
-    0, 1455, 2866, 4236, 5568, 6863, 8124, 9352, 10549, 11716,
-    12855, 13967, 15054, 16117, 17156, 18172, 19167, 20142, 21097, 22033,
-    22951, 23852, 24735, 25603, 26455, 27291, 28113, 28922, 29716, 30497,
-    31266, 32023, 32767
-};
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+
+/*******************************************************************************
+*
+*      File             : log2.tab
+*      Purpose          : Table for routine Log2().
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 table[33] =
+{
+    0, 1455, 2866, 4236, 5568, 6863, 8124, 9352, 10549, 11716,
+    12855, 13967, 15054, 16117, 17156, 18172, 19167, 20142, 21097, 22033,
+    22951, 23852, 24735, 25603, 26455, 27291, 28113, 28922, 29716, 30497,
+    31266, 32023, 32767
+};
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/main.h b/media/libstagefright/codecs/amrwbenc/inc/main.h
index d7e7c67..3a6f963 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/main.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/main.h
@@ -1,45 +1,45 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
- *                         MAIN.H	                                    *
- *--------------------------------------------------------------------------*
- *       Main functions							    *
- *--------------------------------------------------------------------------*/
-
-#ifndef __MAIN_H__
-#define __MAIN_H__
-
-void coder(
-     Word16 * mode,                        /* input :  used mode                             */
-     Word16 speech16k[],                   /* input :  320 new speech samples (at 16 kHz)    */
-     Word16 prms[],                        /* output:  output parameters           */
-     Word16 * ser_size,                    /* output:  bit rate of the used mode   */
-     void *spe_state,                      /* i/o   :  State structure                       */
-     Word16 allow_dtx                      /* input :  DTX ON/OFF                            */
-);
-
-
-
-void Reset_encoder(void *st, Word16 reset_all);
-
-
-Word16 encoder_homing_frame_test(Word16 input_frame[]);
-
-#endif //__MAIN_H__
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+ *                         MAIN.H	                                    *
+ *--------------------------------------------------------------------------*
+ *       Main functions							    *
+ *--------------------------------------------------------------------------*/
+
+#ifndef __MAIN_H__
+#define __MAIN_H__
+
+void coder(
+     Word16 * mode,                        /* input :  used mode                             */
+     Word16 speech16k[],                   /* input :  320 new speech samples (at 16 kHz)    */
+     Word16 prms[],                        /* output:  output parameters           */
+     Word16 * ser_size,                    /* output:  bit rate of the used mode   */
+     void *spe_state,                      /* i/o   :  State structure                       */
+     Word16 allow_dtx                      /* input :  DTX ON/OFF                            */
+);
+
+
+
+void Reset_encoder(void *st, Word16 reset_all);
+
+
+Word16 encoder_homing_frame_test(Word16 input_frame[]);
+
+#endif //__MAIN_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/math_op.h b/media/libstagefright/codecs/amrwbenc/inc/math_op.h
index 25e29f7..7b6196b 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/math_op.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/math_op.h
@@ -1,55 +1,55 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
- *                         MATH_OP.H	                                    *
- *--------------------------------------------------------------------------*
- *       Mathematical operations					    *
- *--------------------------------------------------------------------------*/
-
-#ifndef __MATH_OP_H__
-#define __MATH_OP_H__
-
-Word32 Isqrt(                              /* (o) Q31 : output value (range: 0<=val<1)         */
-		Word32 L_x                            /* (i) Q0  : input value  (range: 0<=val<=7fffffff) */
-	    );
-
-void Isqrt_n(
-		Word32 * frac,                        /* (i/o) Q31: normalized value (1.0 < frac <= 0.5) */
-		Word16 * exp                          /* (i/o)    : exponent (value = frac x 2^exponent) */
-	    );
-
-Word32 Pow2(                               /* (o) Q0  : result       (range: 0<=val<=0x7fffffff) */
-		Word16 exponant,                      /* (i) Q0  : Integer part.      (range: 0<=val<=30)   */
-		Word16 fraction                       /* (i) Q15 : Fractionnal part.  (range: 0.0<=val<1.0) */
-	   );
-
-Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
-		Word16 x[],                           /* (i) 12bits: x vector                       */
-		Word16 y[],                           /* (i) 12bits: y vector                       */
-		Word16 lg,                            /* (i)    : vector length                     */
-		Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
-		);
-
-Word32 Dot_product12_asm(                      /* (o) Q31: normalized result (1 < val <= -1) */
-		Word16 x[],                           /* (i) 12bits: x vector                       */
-		Word16 y[],                           /* (i) 12bits: y vector                       */
-		Word16 lg,                            /* (i)    : vector length                     */
-		Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
-		);
-#endif //__MATH_OP_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+ *                         MATH_OP.H	                                    *
+ *--------------------------------------------------------------------------*
+ *       Mathematical operations					    *
+ *--------------------------------------------------------------------------*/
+
+#ifndef __MATH_OP_H__
+#define __MATH_OP_H__
+
+Word32 Isqrt(                              /* (o) Q31 : output value (range: 0<=val<1)         */
+		Word32 L_x                            /* (i) Q0  : input value  (range: 0<=val<=7fffffff) */
+	    );
+
+void Isqrt_n(
+		Word32 * frac,                        /* (i/o) Q31: normalized value (1.0 < frac <= 0.5) */
+		Word16 * exp                          /* (i/o)    : exponent (value = frac x 2^exponent) */
+	    );
+
+Word32 Pow2(                               /* (o) Q0  : result       (range: 0<=val<=0x7fffffff) */
+		Word16 exponant,                      /* (i) Q0  : Integer part.      (range: 0<=val<=30)   */
+		Word16 fraction                       /* (i) Q15 : Fractionnal part.  (range: 0.0<=val<1.0) */
+	   );
+
+Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
+		Word16 x[],                           /* (i) 12bits: x vector                       */
+		Word16 y[],                           /* (i) 12bits: y vector                       */
+		Word16 lg,                            /* (i)    : vector length                     */
+		Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
+		);
+
+Word32 Dot_product12_asm(                      /* (o) Q31: normalized result (1 < val <= -1) */
+		Word16 x[],                           /* (i) 12bits: x vector                       */
+		Word16 y[],                           /* (i) 12bits: y vector                       */
+		Word16 lg,                            /* (i)    : vector length                     */
+		Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
+		);
+#endif //__MATH_OP_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/mem_align.h b/media/libstagefright/codecs/amrwbenc/inc/mem_align.h
index d6ddec3..442786a 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/mem_align.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/mem_align.h
@@ -1,35 +1,35 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		mem_align.h
-
-	Content:	Memory alloc alignments functions
-
-*******************************************************************************/
-
-#ifndef __VO_MEM_ALIGN_H__
-#define __VO_MEM_ALIGN_H__
-
-#include "voMem.h"
-#include "typedef.h"
-
-extern void *mem_malloc(VO_MEM_OPERATOR *pMemop, unsigned int size, unsigned char alignment, unsigned int CodecID);
-extern void mem_free(VO_MEM_OPERATOR *pMemop, void *mem_ptr, unsigned int CodecID);
-
-#endif	/* __VO_MEM_ALIGN_H__ */
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		mem_align.h
+
+	Content:	Memory alloc alignments functions
+
+*******************************************************************************/
+
+#ifndef __VO_MEM_ALIGN_H__
+#define __VO_MEM_ALIGN_H__
+
+#include "voMem.h"
+#include "typedef.h"
+
+extern void *mem_malloc(VO_MEM_OPERATOR *pMemop, unsigned int size, unsigned char alignment, unsigned int CodecID);
+extern void mem_free(VO_MEM_OPERATOR *pMemop, void *mem_ptr, unsigned int CodecID);
+
+#endif	/* __VO_MEM_ALIGN_H__ */
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/mime_io.tab b/media/libstagefright/codecs/amrwbenc/inc/mime_io.tab
index ffc86a1..7b485ea 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/mime_io.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/mime_io.tab
@@ -1,368 +1,368 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-#include <stdio.h>
-#include "typedef.h"
-
-static UWord8 toc_byte[16] = {0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C,
-                              0x44, 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C};
-
-/* number of speech bits for all modes */
-static Word16 unpacked_size[16] = {132,  177, 253, 285, 317, 365, 397, 461,
-                                   477,   35,   0,   0,   0,   0,   0,   0};
-
-/* size of packed frame for each mode, excluding TOC byte */
-static Word16 packed_size[16] = {17, 23, 32, 36, 40, 46, 50, 58,
-                                 60,  5,  0,  0,  0,  0,  0,  0};
-
-/* number of unused speech bits in packed format for each mode */
-static Word16 unused_size[16] = {4, 7, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0};
-
-/* sorting tables for all modes */
-
-static Word16 sort_660[132] = {
-     0,   5,   6,   7,  61,  84, 107, 130,  62,  85,
-     8,   4,  37,  38,  39,  40,  58,  81, 104, 127,
-    60,  83, 106, 129, 108, 131, 128,  41,  42,  80,
-   126,   1,   3,  57, 103,  82, 105,  59,   2,  63,
-   109, 110,  86,  19,  22,  23,  64,  87,  18,  20,
-    21,  17,  13,  88,  43,  89,  65, 111,  14,  24,
-    25,  26,  27,  28,  15,  16,  44,  90,  66, 112,
-     9,  11,  10,  12,  67, 113,  29,  30,  31,  32,
-    34,  33,  35,  36,  45,  51,  68,  74,  91,  97,
-   114, 120,  46,  69,  92, 115,  52,  75,  98, 121,
-    47,  70,  93, 116,  53,  76,  99, 122,  48,  71,
-    94, 117,  54,  77, 100, 123,  49,  72,  95, 118,
-    55,  78, 101, 124,  50,  73,  96, 119,  56,  79,
-   102, 125
-};
-
-static Word16 sort_885[177] = {
-     0,   4,   6,   7,   5,   3,  47,  48,  49, 112,
-   113, 114,  75, 106, 140, 171,  80, 111, 145, 176,
-    77, 108, 142, 173,  78, 109, 143, 174,  79, 110,
-   144, 175,  76, 107, 141, 172,  50, 115,  51,   2,
-     1,  81, 116, 146,  19,  21,  12,  17,  18,  20,
-    16,  25,  13,  10,  14,  24,  23,  22,  26,   8,
-    15,  52, 117,  31,  82, 147,   9,  33,  11,  83,
-   148,  53, 118,  28,  27,  84, 149,  34,  35,  29,
-    46,  32,  30,  54, 119,  37,  36,  39,  38,  40,
-    85, 150,  41,  42,  43,  44,  45,  55,  60,  65,
-    70,  86,  91,  96, 101, 120, 125, 130, 135, 151,
-   156, 161, 166,  56,  87, 121, 152,  61,  92, 126,
-   157,  66,  97, 131, 162,  71, 102, 136, 167,  57,
-    88, 122, 153,  62,  93, 127, 158,  67,  98, 132,
-   163,  72, 103, 137, 168,  58,  89, 123, 154,  63,
-    94, 128, 159,  68,  99, 133, 164,  73, 104, 138,
-   169,  59,  90, 124, 155,  64,  95, 129, 160,  69,
-   100, 134, 165,  74, 105, 139, 170
-};
-
-static Word16 sort_1265[253] = {
-     0,   4,   6,  93, 143, 196, 246,   7,   5,   3,
-    47,  48,  49,  50,  51, 150, 151, 152, 153, 154,
-    94, 144, 197, 247,  99, 149, 202, 252,  96, 146,
-   199, 249,  97, 147, 200, 250, 100, 203,  98, 148,
-   201, 251,  95, 145, 198, 248,  52,   2,   1, 101,
-   204, 155,  19,  21,  12,  17,  18,  20,  16,  25,
-    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
-   156,  31, 102, 205,   9,  33,  11, 103, 206,  54,
-   157,  28,  27, 104, 207,  34,  35,  29,  46,  32,
-    30,  55, 158,  37,  36,  39,  38,  40, 105, 208,
-    41,  42,  43,  44,  45,  56, 106, 159, 209,  57,
-    66,  75,  84, 107, 116, 125, 134, 160, 169, 178,
-   187, 210, 219, 228, 237,  58, 108, 161, 211,  62,
-   112, 165, 215,  67, 117, 170, 220,  71, 121, 174,
-   224,  76, 126, 179, 229,  80, 130, 183, 233,  85,
-   135, 188, 238,  89, 139, 192, 242,  59, 109, 162,
-   212,  63, 113, 166, 216,  68, 118, 171, 221,  72,
-   122, 175, 225,  77, 127, 180, 230,  81, 131, 184,
-   234,  86, 136, 189, 239,  90, 140, 193, 243,  60,
-   110, 163, 213,  64, 114, 167, 217,  69, 119, 172,
-   222,  73, 123, 176, 226,  78, 128, 181, 231,  82,
-   132, 185, 235,  87, 137, 190, 240,  91, 141, 194,
-   244,  61, 111, 164, 214,  65, 115, 168, 218,  70,
-   120, 173, 223,  74, 124, 177, 227,  79, 129, 182,
-   232,  83, 133, 186, 236,  88, 138, 191, 241,  92,
-   142, 195, 245                         
-};
-
-static Word16 sort_1425[285] = {
-     0,   4,   6, 101, 159, 220, 278,   7,   5,   3,
-    47,  48,  49,  50,  51, 166, 167, 168, 169, 170,
-   102, 160, 221, 279, 107, 165, 226, 284, 104, 162,
-   223, 281, 105, 163, 224, 282, 108, 227, 106, 164,
-   225, 283, 103, 161, 222, 280,  52,   2,   1, 109,
-   228, 171,  19,  21,  12,  17,  18,  20,  16,  25,
-    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
-   172,  31, 110, 229,   9,  33,  11, 111, 230,  54,
-   173,  28,  27, 112, 231,  34,  35,  29,  46,  32,
-    30,  55, 174,  37,  36,  39,  38,  40, 113, 232,
-    41,  42,  43,  44,  45,  56, 114, 175, 233,  62,
-   120, 181, 239,  75, 133, 194, 252,  57, 115, 176,
-   234,  63, 121, 182, 240,  70, 128, 189, 247,  76,
-   134, 195, 253,  83, 141, 202, 260,  92, 150, 211,
-   269,  84, 142, 203, 261,  93, 151, 212, 270,  85,
-   143, 204, 262,  94, 152, 213, 271,  86, 144, 205,
-   263,  95, 153, 214, 272,  64, 122, 183, 241,  77,
-   135, 196, 254,  65, 123, 184, 242,  78, 136, 197,
-   255,  87, 145, 206, 264,  96, 154, 215, 273,  58,
-   116, 177, 235,  66, 124, 185, 243,  71, 129, 190,
-   248,  79, 137, 198, 256,  88, 146, 207, 265,  97,
-   155, 216, 274,  59, 117, 178, 236,  67, 125, 186,
-   244,  72, 130, 191, 249,  80, 138, 199, 257,  89,
-   147, 208, 266,  98, 156, 217, 275,  60, 118, 179,
-   237,  68, 126, 187, 245,  73, 131, 192, 250,  81,
-   139, 200, 258,  90, 148, 209, 267,  99, 157, 218,
-   276,  61, 119, 180, 238,  69, 127, 188, 246,  74,
-   132, 193, 251,  82, 140, 201, 259,  91, 149, 210,
-   268, 100, 158, 219, 277
-};
-
-static Word16 sort_1585[317] = {
-     0,   4,   6, 109, 175, 244, 310,   7,   5,   3,
-    47,  48,  49,  50,  51, 182, 183, 184, 185, 186,
-   110, 176, 245, 311, 115, 181, 250, 316, 112, 178,
-   247, 313, 113, 179, 248, 314, 116, 251, 114, 180,
-   249, 315, 111, 177, 246, 312,  52,   2,   1, 117,
-   252, 187,  19,  21,  12,  17,  18,  20,  16,  25,
-    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
-   188,  31, 118, 253,   9,  33,  11, 119, 254,  54,
-   189,  28,  27, 120, 255,  34,  35,  29,  46,  32,
-    30,  55, 190,  37,  36,  39,  38,  40, 121, 256,
-    41,  42,  43,  44,  45,  56, 122, 191, 257,  63,
-   129, 198, 264,  76, 142, 211, 277,  89, 155, 224,
-   290, 102, 168, 237, 303,  57, 123, 192, 258,  70,
-   136, 205, 271,  83, 149, 218, 284,  96, 162, 231,
-   297,  62, 128, 197, 263,  75, 141, 210, 276,  88,
-   154, 223, 289, 101, 167, 236, 302,  58, 124, 193,
-   259,  71, 137, 206, 272,  84, 150, 219, 285,  97,
-   163, 232, 298,  59, 125, 194, 260,  64, 130, 199,
-   265,  67, 133, 202, 268,  72, 138, 207, 273,  77,
-   143, 212, 278,  80, 146, 215, 281,  85, 151, 220,
-   286,  90, 156, 225, 291,  93, 159, 228, 294,  98,
-   164, 233, 299, 103, 169, 238, 304, 106, 172, 241,
-   307,  60, 126, 195, 261,  65, 131, 200, 266,  68,
-   134, 203, 269,  73, 139, 208, 274,  78, 144, 213,
-   279,  81, 147, 216, 282,  86, 152, 221, 287,  91,
-   157, 226, 292,  94, 160, 229, 295,  99, 165, 234,
-   300, 104, 170, 239, 305, 107, 173, 242, 308,  61,
-   127, 196, 262,  66, 132, 201, 267,  69, 135, 204,
-   270,  74, 140, 209, 275,  79, 145, 214, 280,  82,
-   148, 217, 283,  87, 153, 222, 288,  92, 158, 227,
-   293,  95, 161, 230, 296, 100, 166, 235, 301, 105,
-   171, 240, 306, 108, 174, 243, 309
-};
-
-static Word16 sort_1825[365] = {
-     0,   4,   6, 121, 199, 280, 358,   7,   5,   3,
-    47,  48,  49,  50,  51, 206, 207, 208, 209, 210,
-   122, 200, 281, 359, 127, 205, 286, 364, 124, 202,
-   283, 361, 125, 203, 284, 362, 128, 287, 126, 204,
-   285, 363, 123, 201, 282, 360,  52,   2,   1, 129,
-   288, 211,  19,  21,  12,  17,  18,  20,  16,  25,
-    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
-   212,  31, 130, 289,   9,  33,  11, 131, 290,  54,
-   213,  28,  27, 132, 291,  34,  35,  29,  46,  32,
-    30,  55, 214,  37,  36,  39,  38,  40, 133, 292,
-    41,  42,  43,  44,  45,  56, 134, 215, 293, 198,
-   299, 136, 120, 138,  60, 279,  58,  62, 357, 139,
-   140, 295, 156,  57, 219, 297,  63, 217, 137, 170,
-   300, 222,  64, 106,  61,  78, 294,  92, 142, 141,
-   135, 221, 296, 301, 343,  59, 298, 184, 329, 315,
-   220, 216, 265, 251, 218, 237, 352, 223, 157,  86,
-   171,  87, 164, 351, 111, 302,  65, 178, 115, 323,
-    72, 192, 101, 179,  93,  73, 193, 151, 337, 309,
-   143, 274,  69, 324, 165, 150,  97, 338, 110, 310,
-   330, 273,  68, 107, 175, 245, 114,  79, 113, 189,
-   246, 259, 174,  71, 185,  96, 344, 100, 322,  83,
-   334, 316, 333, 252, 161, 348, 147,  82, 269, 232,
-   260, 308, 353, 347, 163, 231, 306, 320, 188, 270,
-   146, 177, 266, 350, 256,  85, 149, 116, 191, 160,
-   238, 258, 336, 305, 255,  88, 224,  99, 339, 230,
-   228, 227, 272, 242, 241, 319, 233, 311, 102,  74,
-   180, 275,  66, 194, 152, 325, 172, 247, 244, 261,
-   117, 158, 166, 354,  75, 144, 108, 312,  94, 186,
-   303,  80, 234,  89, 195, 112, 340, 181, 345, 317,
-   326, 276, 239, 167, 118, 313,  70, 355, 327, 253,
-   190, 176, 271, 104,  98, 153, 103,  90,  76, 267,
-   277, 248, 225, 262, 182,  84, 154, 235, 335, 168,
-   331, 196, 341, 249, 162, 307, 148, 349, 263, 321,
-   257, 243, 229, 356, 159, 119,  67, 187, 173, 145,
-   240,  77, 304, 332, 314, 342, 109, 254,  81, 278,
-   105,  91, 346, 318, 183, 250, 197, 328,  95, 155,
-   169, 268, 226, 236, 264                 
-};
-
-static Word16 sort_1985[397] = {
-     0,   4,   6, 129, 215, 304, 390,   7,   5,   3,
-    47,  48,  49,  50,  51, 222, 223, 224, 225, 226,
-   130, 216, 305, 391, 135, 221, 310, 396, 132, 218,
-   307, 393, 133, 219, 308, 394, 136, 311, 134, 220,
-   309, 395, 131, 217, 306, 392,  52,   2,   1, 137,
-   312, 227,  19,  21,  12,  17,  18,  20,  16,  25,
-    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
-   228,  31, 138, 313,   9,  33,  11, 139, 314,  54,
-   229,  28,  27, 140, 315,  34,  35,  29,  46,  32,
-    30,  55, 230,  37,  36,  39,  38,  40, 141, 316,
-    41,  42,  43,  44,  45,  56, 142, 231, 317,  63,
-    73,  92, 340,  82, 324, 149, 353, 159, 334, 165,
-   338, 178, 163, 254,  77, 168, 257, 153, 343,  57,
-   248, 238,  79, 252, 166,  67,  80, 201, 101, 267,
-   143, 164, 341, 255, 339, 187, 376, 318,  78, 328,
-   362, 115, 232, 242, 253, 290, 276,  62,  58, 158,
-    68,  93, 179, 319, 148, 169, 154,  72, 385, 329,
-   333, 344, 102,  83, 144, 233, 323, 124, 243, 192,
-   354, 237,  64, 247, 202, 209, 150, 116, 335, 268,
-   239, 299, 188, 196, 298,  94, 195, 258, 123, 363,
-   384, 109, 325, 371, 170, 370,  84, 110, 295, 180,
-    74, 210, 191, 106, 291, 205, 367, 381, 377, 206,
-   355, 122, 119, 120, 383, 160, 105, 108, 277, 380,
-   294, 284, 285, 345, 208, 269, 249, 366, 386, 300,
-   297, 259, 125, 369, 197,  97, 194, 286, 211, 281,
-   280, 183, 372,  87, 155, 283,  59, 348, 327, 184,
-    76, 111, 330, 203, 349,  69,  98, 152, 145, 189,
-    66, 320, 337, 173, 358, 251, 198, 174, 263, 262,
-   126, 241, 193,  88, 388, 117,  95, 387, 112, 359,
-   287, 244, 103, 272, 301, 171, 162, 234, 273, 127,
-   373, 181, 292,  85, 378, 302, 121, 107, 364, 346,
-   356, 212, 278, 213,  65, 382, 288, 207, 113, 175,
-    99, 296, 374, 368, 199, 260, 185, 336, 331, 161,
-   270, 264, 250, 240,  75, 350, 151,  60,  89, 321,
-   156, 274, 360, 326,  70, 282, 167, 146, 352,  81,
-    91, 389, 266, 245, 177, 235, 190, 256, 204, 342,
-   128, 118, 303, 104, 379, 182, 114, 375, 200,  96,
-   293, 172, 214, 365, 279,  86, 289, 351, 347, 357,
-   261, 186, 176, 271,  90, 100, 147, 322, 275, 361,
-    71, 332,  61, 265, 157, 246, 236         
-};
-
-static Word16 sort_2305[461] = {
-     0,   4,   6, 145, 247, 352, 454,   7,   5,   3,
-    47,  48,  49,  50,  51, 254, 255, 256, 257, 258,
-   146, 248, 353, 455, 151, 253, 358, 460, 148, 250,
-   355, 457, 149, 251, 356, 458, 152, 359, 150, 252,
-   357, 459, 147, 249, 354, 456,  52,   2,   1, 153,
-   360, 259,  19,  21,  12,  17,  18,  20,  16,  25,
-    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
-   260,  31, 154, 361,   9,  33,  11, 155, 362,  54,
-   261,  28,  27, 156, 363,  34,  35,  29,  46,  32,
-    30,  55, 262,  37,  36,  39,  38,  40, 157, 364,
-    41,  42,  43,  44,  45,  56, 158, 263, 365, 181,
-   192, 170,  79,  57, 399,  90, 159, 297, 377, 366,
-   275,  68, 183, 388, 286, 194, 299, 92 ,  70, 182,
-   401, 172,  59,  91,  58, 400, 368, 161,  81, 160,
-   264, 171,  80, 389, 390, 378, 379, 193, 298,  69,
-   266, 265, 367, 277, 288, 276, 287, 184,  60, 195,
-    82,  93,  71, 369, 402, 173, 162, 444, 300, 391,
-    98,  76, 278,  61, 267, 374, 135, 411, 167, 102,
-   380, 200,  87, 178,  65,  94, 204, 124,  72, 342,
-   189, 305, 381, 396, 433, 301, 226, 407, 289, 237,
-   113, 215, 185, 128, 309, 403, 116, 320, 196, 331,
-   370, 422, 174,  64, 392,  83, 425, 219, 134, 188,
-   432, 112, 427, 139, 279, 163, 436, 208, 447, 218,
-   236, 229,  97, 294, 385, 230, 166, 268, 177, 443,
-   225, 426, 101, 272, 138, 127, 290, 117, 347, 199,
-   414,  95, 140, 240, 410, 395, 209, 129, 283, 346,
-   105, 241, 437,  86, 308, 448, 203, 345, 186, 107,
-   220, 415, 334, 319, 106, 313, 118, 123,  73, 207,
-   421, 214, 384, 373, 438,  62, 371, 341,  75, 449,
-   168, 323, 164, 242, 416, 324, 304, 197, 335, 404,
-   271,  63, 191, 325,  96, 169, 231, 280, 312, 187,
-   406,  84, 201, 100,  67, 382, 175, 336, 202, 330,
-   269, 393, 376, 383, 293, 307, 409, 179, 285, 314,
-   302, 372, 398, 190, 180,  89,  99, 103, 232,  78,
-    88,  77, 136, 387, 165, 198, 394, 125, 176, 428,
-    74, 375, 238, 227,  66, 273, 282, 141, 306, 412,
-   114,  85, 130, 348, 119, 291, 296, 386, 233, 397,
-   303, 405, 284, 445, 423, 221, 210, 205, 450, 108,
-   274, 434, 216, 343, 337, 142, 243, 321, 408, 451,
-   310, 292, 120, 109, 281, 439, 270, 429, 332, 295,
-   418, 211, 315, 222, 326, 131, 430, 244, 327, 349,
-   417, 316, 143, 338, 440, 234, 110, 212, 452, 245,
-   121, 419, 350, 223, 132, 441, 328, 413, 317, 339,
-   126, 104, 137, 446, 344, 239, 435, 115, 333, 206,
-   322, 217, 228, 424, 453, 311, 351, 111, 442, 224,
-   213, 122, 431, 340, 235, 246, 133, 144, 420, 329,
-   318
-};
-
-static Word16 sort_2385[477] = {
-     0,   4,   6, 145, 251, 360, 466,   7,   5,   3,
-    47,  48,  49,  50,  51, 262, 263, 264, 265, 266,
-   146, 252, 361, 467, 151, 257, 366, 472, 148, 254,
-   363, 469, 149, 255, 364, 470, 156, 371, 150, 256,
-   365, 471, 147, 253, 362, 468,  52,   2,   1, 157,
-   372, 267,  19,  21,  12,  17,  18,  20,  16,  25,
-    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
-   268,  31, 152, 153, 154, 155, 258, 259, 260, 261,
-   367, 368, 369, 370, 473, 474, 475, 476, 158, 373,
-     9,  33,  11, 159, 374,  54, 269,  28,  27, 160,
-   375,  34,  35,  29,  46,  32,  30,  55, 270, 37,
-    36,  39,  38,  40, 161, 376,  41,  42,  43,  44,
-    45,  56, 162, 271, 377, 185, 196, 174,  79,  57,
-   411,  90, 163, 305, 389, 378, 283,  68, 187, 400,
-   294, 198, 307,  92,  70, 186, 413, 176,  59,  91,
-    58, 412, 380, 165,  81, 164, 272, 175,  80, 401,
-   402, 390, 391, 197, 306,  69, 274, 273, 379, 285,
-   296, 284, 295, 188,  60, 199,  82,  93,  71, 381,
-   414, 177, 166, 456, 308, 403,  98,  76, 286,  61,
-   275, 386, 135, 423, 171, 102, 392, 204,  87, 182,
-    65,  94, 208, 124,  72, 350, 193, 313, 393, 408,
-   445, 309, 230, 419, 297, 241, 113, 219, 189, 128,
-   317, 415, 116, 328, 200, 339, 382, 434, 178,  64,
-   404,  83, 437, 223, 134, 192, 444, 112, 439, 139,
-   287, 167, 448, 212, 459, 222, 240, 233,  97, 302,
-   397, 234, 170, 276, 181, 455, 229, 438, 101, 280,
-   138, 127, 298, 117, 355, 203, 426,  95, 140, 244,
-   422, 407, 213, 129, 291, 354, 105, 245, 449,  86,
-   316, 460, 207, 353, 190, 107, 224, 427, 342, 327,
-   106, 321, 118, 123,  73, 211, 433, 218, 396, 385,
-   450,  62, 383, 349,  75, 461, 172, 331, 168, 246,
-   428, 332, 312, 201, 343, 416, 279,  63, 195, 333,
-    96, 173, 235, 288, 320, 191, 418,  84, 205, 100,
-    67, 394, 179, 344, 206, 338, 277, 405, 388, 395,
-   301, 315, 421, 183, 293, 322, 310, 384, 410, 194,
-   184,  89,  99, 103, 236,  78,  88,  77, 136, 399,
-   169, 202, 406, 125, 180, 440,  74, 387, 242, 231,
-    66, 281, 290, 141, 314, 424, 114,  85, 130, 356,
-   119, 299, 304, 398, 237, 409, 311, 417, 292, 457,
-   435, 225, 214, 209, 462, 108, 282, 446, 220, 351,
-   345, 142, 247, 329, 420, 463, 318, 300, 120, 109,
-   289, 451, 278, 441, 340, 303, 430, 215, 323, 226,
-   334, 131, 442, 248, 335, 357, 429, 324, 143, 346,
-   452, 238, 110, 216, 464, 249, 121, 431, 358, 227,
-   132, 453, 336, 425, 325, 347, 126, 104, 137, 458,
-   352, 243, 447, 115, 341, 210, 330, 221, 232, 436,
-   465, 319, 359, 111, 454, 228, 217, 122, 443, 348,
-   239, 250, 133, 144, 432, 337, 326         
-};
-
-static Word16 sort_SID[35] = {
-    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
-   10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
-   20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
-   30, 31, 32, 33, 34
-};
-
-/* pointer table for bit sorting tables */
-static Word16 *sort_ptr[16] = { sort_660, sort_885, sort_1265, sort_1425, sort_1585, sort_1825, sort_1985, sort_2305,
-                               sort_2385, sort_SID,      NULL,      NULL,      NULL,      NULL,      NULL,      NULL};
-
-
-
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+#include <stdio.h>
+#include "typedef.h"
+
+static UWord8 toc_byte[16] = {0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C,
+                              0x44, 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C};
+
+/* number of speech bits for all modes */
+static Word16 unpacked_size[16] = {132,  177, 253, 285, 317, 365, 397, 461,
+                                   477,   35,   0,   0,   0,   0,   0,   0};
+
+/* size of packed frame for each mode, excluding TOC byte */
+static Word16 packed_size[16] = {17, 23, 32, 36, 40, 46, 50, 58,
+                                 60,  5,  0,  0,  0,  0,  0,  0};
+
+/* number of unused speech bits in packed format for each mode */
+static Word16 unused_size[16] = {4, 7, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0};
+
+/* sorting tables for all modes */
+
+static Word16 sort_660[132] = {
+     0,   5,   6,   7,  61,  84, 107, 130,  62,  85,
+     8,   4,  37,  38,  39,  40,  58,  81, 104, 127,
+    60,  83, 106, 129, 108, 131, 128,  41,  42,  80,
+   126,   1,   3,  57, 103,  82, 105,  59,   2,  63,
+   109, 110,  86,  19,  22,  23,  64,  87,  18,  20,
+    21,  17,  13,  88,  43,  89,  65, 111,  14,  24,
+    25,  26,  27,  28,  15,  16,  44,  90,  66, 112,
+     9,  11,  10,  12,  67, 113,  29,  30,  31,  32,
+    34,  33,  35,  36,  45,  51,  68,  74,  91,  97,
+   114, 120,  46,  69,  92, 115,  52,  75,  98, 121,
+    47,  70,  93, 116,  53,  76,  99, 122,  48,  71,
+    94, 117,  54,  77, 100, 123,  49,  72,  95, 118,
+    55,  78, 101, 124,  50,  73,  96, 119,  56,  79,
+   102, 125
+};
+
+static Word16 sort_885[177] = {
+     0,   4,   6,   7,   5,   3,  47,  48,  49, 112,
+   113, 114,  75, 106, 140, 171,  80, 111, 145, 176,
+    77, 108, 142, 173,  78, 109, 143, 174,  79, 110,
+   144, 175,  76, 107, 141, 172,  50, 115,  51,   2,
+     1,  81, 116, 146,  19,  21,  12,  17,  18,  20,
+    16,  25,  13,  10,  14,  24,  23,  22,  26,   8,
+    15,  52, 117,  31,  82, 147,   9,  33,  11,  83,
+   148,  53, 118,  28,  27,  84, 149,  34,  35,  29,
+    46,  32,  30,  54, 119,  37,  36,  39,  38,  40,
+    85, 150,  41,  42,  43,  44,  45,  55,  60,  65,
+    70,  86,  91,  96, 101, 120, 125, 130, 135, 151,
+   156, 161, 166,  56,  87, 121, 152,  61,  92, 126,
+   157,  66,  97, 131, 162,  71, 102, 136, 167,  57,
+    88, 122, 153,  62,  93, 127, 158,  67,  98, 132,
+   163,  72, 103, 137, 168,  58,  89, 123, 154,  63,
+    94, 128, 159,  68,  99, 133, 164,  73, 104, 138,
+   169,  59,  90, 124, 155,  64,  95, 129, 160,  69,
+   100, 134, 165,  74, 105, 139, 170
+};
+
+static Word16 sort_1265[253] = {
+     0,   4,   6,  93, 143, 196, 246,   7,   5,   3,
+    47,  48,  49,  50,  51, 150, 151, 152, 153, 154,
+    94, 144, 197, 247,  99, 149, 202, 252,  96, 146,
+   199, 249,  97, 147, 200, 250, 100, 203,  98, 148,
+   201, 251,  95, 145, 198, 248,  52,   2,   1, 101,
+   204, 155,  19,  21,  12,  17,  18,  20,  16,  25,
+    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
+   156,  31, 102, 205,   9,  33,  11, 103, 206,  54,
+   157,  28,  27, 104, 207,  34,  35,  29,  46,  32,
+    30,  55, 158,  37,  36,  39,  38,  40, 105, 208,
+    41,  42,  43,  44,  45,  56, 106, 159, 209,  57,
+    66,  75,  84, 107, 116, 125, 134, 160, 169, 178,
+   187, 210, 219, 228, 237,  58, 108, 161, 211,  62,
+   112, 165, 215,  67, 117, 170, 220,  71, 121, 174,
+   224,  76, 126, 179, 229,  80, 130, 183, 233,  85,
+   135, 188, 238,  89, 139, 192, 242,  59, 109, 162,
+   212,  63, 113, 166, 216,  68, 118, 171, 221,  72,
+   122, 175, 225,  77, 127, 180, 230,  81, 131, 184,
+   234,  86, 136, 189, 239,  90, 140, 193, 243,  60,
+   110, 163, 213,  64, 114, 167, 217,  69, 119, 172,
+   222,  73, 123, 176, 226,  78, 128, 181, 231,  82,
+   132, 185, 235,  87, 137, 190, 240,  91, 141, 194,
+   244,  61, 111, 164, 214,  65, 115, 168, 218,  70,
+   120, 173, 223,  74, 124, 177, 227,  79, 129, 182,
+   232,  83, 133, 186, 236,  88, 138, 191, 241,  92,
+   142, 195, 245
+};
+
+static Word16 sort_1425[285] = {
+     0,   4,   6, 101, 159, 220, 278,   7,   5,   3,
+    47,  48,  49,  50,  51, 166, 167, 168, 169, 170,
+   102, 160, 221, 279, 107, 165, 226, 284, 104, 162,
+   223, 281, 105, 163, 224, 282, 108, 227, 106, 164,
+   225, 283, 103, 161, 222, 280,  52,   2,   1, 109,
+   228, 171,  19,  21,  12,  17,  18,  20,  16,  25,
+    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
+   172,  31, 110, 229,   9,  33,  11, 111, 230,  54,
+   173,  28,  27, 112, 231,  34,  35,  29,  46,  32,
+    30,  55, 174,  37,  36,  39,  38,  40, 113, 232,
+    41,  42,  43,  44,  45,  56, 114, 175, 233,  62,
+   120, 181, 239,  75, 133, 194, 252,  57, 115, 176,
+   234,  63, 121, 182, 240,  70, 128, 189, 247,  76,
+   134, 195, 253,  83, 141, 202, 260,  92, 150, 211,
+   269,  84, 142, 203, 261,  93, 151, 212, 270,  85,
+   143, 204, 262,  94, 152, 213, 271,  86, 144, 205,
+   263,  95, 153, 214, 272,  64, 122, 183, 241,  77,
+   135, 196, 254,  65, 123, 184, 242,  78, 136, 197,
+   255,  87, 145, 206, 264,  96, 154, 215, 273,  58,
+   116, 177, 235,  66, 124, 185, 243,  71, 129, 190,
+   248,  79, 137, 198, 256,  88, 146, 207, 265,  97,
+   155, 216, 274,  59, 117, 178, 236,  67, 125, 186,
+   244,  72, 130, 191, 249,  80, 138, 199, 257,  89,
+   147, 208, 266,  98, 156, 217, 275,  60, 118, 179,
+   237,  68, 126, 187, 245,  73, 131, 192, 250,  81,
+   139, 200, 258,  90, 148, 209, 267,  99, 157, 218,
+   276,  61, 119, 180, 238,  69, 127, 188, 246,  74,
+   132, 193, 251,  82, 140, 201, 259,  91, 149, 210,
+   268, 100, 158, 219, 277
+};
+
+static Word16 sort_1585[317] = {
+     0,   4,   6, 109, 175, 244, 310,   7,   5,   3,
+    47,  48,  49,  50,  51, 182, 183, 184, 185, 186,
+   110, 176, 245, 311, 115, 181, 250, 316, 112, 178,
+   247, 313, 113, 179, 248, 314, 116, 251, 114, 180,
+   249, 315, 111, 177, 246, 312,  52,   2,   1, 117,
+   252, 187,  19,  21,  12,  17,  18,  20,  16,  25,
+    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
+   188,  31, 118, 253,   9,  33,  11, 119, 254,  54,
+   189,  28,  27, 120, 255,  34,  35,  29,  46,  32,
+    30,  55, 190,  37,  36,  39,  38,  40, 121, 256,
+    41,  42,  43,  44,  45,  56, 122, 191, 257,  63,
+   129, 198, 264,  76, 142, 211, 277,  89, 155, 224,
+   290, 102, 168, 237, 303,  57, 123, 192, 258,  70,
+   136, 205, 271,  83, 149, 218, 284,  96, 162, 231,
+   297,  62, 128, 197, 263,  75, 141, 210, 276,  88,
+   154, 223, 289, 101, 167, 236, 302,  58, 124, 193,
+   259,  71, 137, 206, 272,  84, 150, 219, 285,  97,
+   163, 232, 298,  59, 125, 194, 260,  64, 130, 199,
+   265,  67, 133, 202, 268,  72, 138, 207, 273,  77,
+   143, 212, 278,  80, 146, 215, 281,  85, 151, 220,
+   286,  90, 156, 225, 291,  93, 159, 228, 294,  98,
+   164, 233, 299, 103, 169, 238, 304, 106, 172, 241,
+   307,  60, 126, 195, 261,  65, 131, 200, 266,  68,
+   134, 203, 269,  73, 139, 208, 274,  78, 144, 213,
+   279,  81, 147, 216, 282,  86, 152, 221, 287,  91,
+   157, 226, 292,  94, 160, 229, 295,  99, 165, 234,
+   300, 104, 170, 239, 305, 107, 173, 242, 308,  61,
+   127, 196, 262,  66, 132, 201, 267,  69, 135, 204,
+   270,  74, 140, 209, 275,  79, 145, 214, 280,  82,
+   148, 217, 283,  87, 153, 222, 288,  92, 158, 227,
+   293,  95, 161, 230, 296, 100, 166, 235, 301, 105,
+   171, 240, 306, 108, 174, 243, 309
+};
+
+static Word16 sort_1825[365] = {
+     0,   4,   6, 121, 199, 280, 358,   7,   5,   3,
+    47,  48,  49,  50,  51, 206, 207, 208, 209, 210,
+   122, 200, 281, 359, 127, 205, 286, 364, 124, 202,
+   283, 361, 125, 203, 284, 362, 128, 287, 126, 204,
+   285, 363, 123, 201, 282, 360,  52,   2,   1, 129,
+   288, 211,  19,  21,  12,  17,  18,  20,  16,  25,
+    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
+   212,  31, 130, 289,   9,  33,  11, 131, 290,  54,
+   213,  28,  27, 132, 291,  34,  35,  29,  46,  32,
+    30,  55, 214,  37,  36,  39,  38,  40, 133, 292,
+    41,  42,  43,  44,  45,  56, 134, 215, 293, 198,
+   299, 136, 120, 138,  60, 279,  58,  62, 357, 139,
+   140, 295, 156,  57, 219, 297,  63, 217, 137, 170,
+   300, 222,  64, 106,  61,  78, 294,  92, 142, 141,
+   135, 221, 296, 301, 343,  59, 298, 184, 329, 315,
+   220, 216, 265, 251, 218, 237, 352, 223, 157,  86,
+   171,  87, 164, 351, 111, 302,  65, 178, 115, 323,
+    72, 192, 101, 179,  93,  73, 193, 151, 337, 309,
+   143, 274,  69, 324, 165, 150,  97, 338, 110, 310,
+   330, 273,  68, 107, 175, 245, 114,  79, 113, 189,
+   246, 259, 174,  71, 185,  96, 344, 100, 322,  83,
+   334, 316, 333, 252, 161, 348, 147,  82, 269, 232,
+   260, 308, 353, 347, 163, 231, 306, 320, 188, 270,
+   146, 177, 266, 350, 256,  85, 149, 116, 191, 160,
+   238, 258, 336, 305, 255,  88, 224,  99, 339, 230,
+   228, 227, 272, 242, 241, 319, 233, 311, 102,  74,
+   180, 275,  66, 194, 152, 325, 172, 247, 244, 261,
+   117, 158, 166, 354,  75, 144, 108, 312,  94, 186,
+   303,  80, 234,  89, 195, 112, 340, 181, 345, 317,
+   326, 276, 239, 167, 118, 313,  70, 355, 327, 253,
+   190, 176, 271, 104,  98, 153, 103,  90,  76, 267,
+   277, 248, 225, 262, 182,  84, 154, 235, 335, 168,
+   331, 196, 341, 249, 162, 307, 148, 349, 263, 321,
+   257, 243, 229, 356, 159, 119,  67, 187, 173, 145,
+   240,  77, 304, 332, 314, 342, 109, 254,  81, 278,
+   105,  91, 346, 318, 183, 250, 197, 328,  95, 155,
+   169, 268, 226, 236, 264
+};
+
+static Word16 sort_1985[397] = {
+     0,   4,   6, 129, 215, 304, 390,   7,   5,   3,
+    47,  48,  49,  50,  51, 222, 223, 224, 225, 226,
+   130, 216, 305, 391, 135, 221, 310, 396, 132, 218,
+   307, 393, 133, 219, 308, 394, 136, 311, 134, 220,
+   309, 395, 131, 217, 306, 392,  52,   2,   1, 137,
+   312, 227,  19,  21,  12,  17,  18,  20,  16,  25,
+    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
+   228,  31, 138, 313,   9,  33,  11, 139, 314,  54,
+   229,  28,  27, 140, 315,  34,  35,  29,  46,  32,
+    30,  55, 230,  37,  36,  39,  38,  40, 141, 316,
+    41,  42,  43,  44,  45,  56, 142, 231, 317,  63,
+    73,  92, 340,  82, 324, 149, 353, 159, 334, 165,
+   338, 178, 163, 254,  77, 168, 257, 153, 343,  57,
+   248, 238,  79, 252, 166,  67,  80, 201, 101, 267,
+   143, 164, 341, 255, 339, 187, 376, 318,  78, 328,
+   362, 115, 232, 242, 253, 290, 276,  62,  58, 158,
+    68,  93, 179, 319, 148, 169, 154,  72, 385, 329,
+   333, 344, 102,  83, 144, 233, 323, 124, 243, 192,
+   354, 237,  64, 247, 202, 209, 150, 116, 335, 268,
+   239, 299, 188, 196, 298,  94, 195, 258, 123, 363,
+   384, 109, 325, 371, 170, 370,  84, 110, 295, 180,
+    74, 210, 191, 106, 291, 205, 367, 381, 377, 206,
+   355, 122, 119, 120, 383, 160, 105, 108, 277, 380,
+   294, 284, 285, 345, 208, 269, 249, 366, 386, 300,
+   297, 259, 125, 369, 197,  97, 194, 286, 211, 281,
+   280, 183, 372,  87, 155, 283,  59, 348, 327, 184,
+    76, 111, 330, 203, 349,  69,  98, 152, 145, 189,
+    66, 320, 337, 173, 358, 251, 198, 174, 263, 262,
+   126, 241, 193,  88, 388, 117,  95, 387, 112, 359,
+   287, 244, 103, 272, 301, 171, 162, 234, 273, 127,
+   373, 181, 292,  85, 378, 302, 121, 107, 364, 346,
+   356, 212, 278, 213,  65, 382, 288, 207, 113, 175,
+    99, 296, 374, 368, 199, 260, 185, 336, 331, 161,
+   270, 264, 250, 240,  75, 350, 151,  60,  89, 321,
+   156, 274, 360, 326,  70, 282, 167, 146, 352,  81,
+    91, 389, 266, 245, 177, 235, 190, 256, 204, 342,
+   128, 118, 303, 104, 379, 182, 114, 375, 200,  96,
+   293, 172, 214, 365, 279,  86, 289, 351, 347, 357,
+   261, 186, 176, 271,  90, 100, 147, 322, 275, 361,
+    71, 332,  61, 265, 157, 246, 236
+};
+
+static Word16 sort_2305[461] = {
+     0,   4,   6, 145, 247, 352, 454,   7,   5,   3,
+    47,  48,  49,  50,  51, 254, 255, 256, 257, 258,
+   146, 248, 353, 455, 151, 253, 358, 460, 148, 250,
+   355, 457, 149, 251, 356, 458, 152, 359, 150, 252,
+   357, 459, 147, 249, 354, 456,  52,   2,   1, 153,
+   360, 259,  19,  21,  12,  17,  18,  20,  16,  25,
+    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
+   260,  31, 154, 361,   9,  33,  11, 155, 362,  54,
+   261,  28,  27, 156, 363,  34,  35,  29,  46,  32,
+    30,  55, 262,  37,  36,  39,  38,  40, 157, 364,
+    41,  42,  43,  44,  45,  56, 158, 263, 365, 181,
+   192, 170,  79,  57, 399,  90, 159, 297, 377, 366,
+   275,  68, 183, 388, 286, 194, 299, 92 ,  70, 182,
+   401, 172,  59,  91,  58, 400, 368, 161,  81, 160,
+   264, 171,  80, 389, 390, 378, 379, 193, 298,  69,
+   266, 265, 367, 277, 288, 276, 287, 184,  60, 195,
+    82,  93,  71, 369, 402, 173, 162, 444, 300, 391,
+    98,  76, 278,  61, 267, 374, 135, 411, 167, 102,
+   380, 200,  87, 178,  65,  94, 204, 124,  72, 342,
+   189, 305, 381, 396, 433, 301, 226, 407, 289, 237,
+   113, 215, 185, 128, 309, 403, 116, 320, 196, 331,
+   370, 422, 174,  64, 392,  83, 425, 219, 134, 188,
+   432, 112, 427, 139, 279, 163, 436, 208, 447, 218,
+   236, 229,  97, 294, 385, 230, 166, 268, 177, 443,
+   225, 426, 101, 272, 138, 127, 290, 117, 347, 199,
+   414,  95, 140, 240, 410, 395, 209, 129, 283, 346,
+   105, 241, 437,  86, 308, 448, 203, 345, 186, 107,
+   220, 415, 334, 319, 106, 313, 118, 123,  73, 207,
+   421, 214, 384, 373, 438,  62, 371, 341,  75, 449,
+   168, 323, 164, 242, 416, 324, 304, 197, 335, 404,
+   271,  63, 191, 325,  96, 169, 231, 280, 312, 187,
+   406,  84, 201, 100,  67, 382, 175, 336, 202, 330,
+   269, 393, 376, 383, 293, 307, 409, 179, 285, 314,
+   302, 372, 398, 190, 180,  89,  99, 103, 232,  78,
+    88,  77, 136, 387, 165, 198, 394, 125, 176, 428,
+    74, 375, 238, 227,  66, 273, 282, 141, 306, 412,
+   114,  85, 130, 348, 119, 291, 296, 386, 233, 397,
+   303, 405, 284, 445, 423, 221, 210, 205, 450, 108,
+   274, 434, 216, 343, 337, 142, 243, 321, 408, 451,
+   310, 292, 120, 109, 281, 439, 270, 429, 332, 295,
+   418, 211, 315, 222, 326, 131, 430, 244, 327, 349,
+   417, 316, 143, 338, 440, 234, 110, 212, 452, 245,
+   121, 419, 350, 223, 132, 441, 328, 413, 317, 339,
+   126, 104, 137, 446, 344, 239, 435, 115, 333, 206,
+   322, 217, 228, 424, 453, 311, 351, 111, 442, 224,
+   213, 122, 431, 340, 235, 246, 133, 144, 420, 329,
+   318
+};
+
+static Word16 sort_2385[477] = {
+     0,   4,   6, 145, 251, 360, 466,   7,   5,   3,
+    47,  48,  49,  50,  51, 262, 263, 264, 265, 266,
+   146, 252, 361, 467, 151, 257, 366, 472, 148, 254,
+   363, 469, 149, 255, 364, 470, 156, 371, 150, 256,
+   365, 471, 147, 253, 362, 468,  52,   2,   1, 157,
+   372, 267,  19,  21,  12,  17,  18,  20,  16,  25,
+    13,  10,  14,  24,  23,  22,  26,   8,  15,  53,
+   268,  31, 152, 153, 154, 155, 258, 259, 260, 261,
+   367, 368, 369, 370, 473, 474, 475, 476, 158, 373,
+     9,  33,  11, 159, 374,  54, 269,  28,  27, 160,
+   375,  34,  35,  29,  46,  32,  30,  55, 270, 37,
+    36,  39,  38,  40, 161, 376,  41,  42,  43,  44,
+    45,  56, 162, 271, 377, 185, 196, 174,  79,  57,
+   411,  90, 163, 305, 389, 378, 283,  68, 187, 400,
+   294, 198, 307,  92,  70, 186, 413, 176,  59,  91,
+    58, 412, 380, 165,  81, 164, 272, 175,  80, 401,
+   402, 390, 391, 197, 306,  69, 274, 273, 379, 285,
+   296, 284, 295, 188,  60, 199,  82,  93,  71, 381,
+   414, 177, 166, 456, 308, 403,  98,  76, 286,  61,
+   275, 386, 135, 423, 171, 102, 392, 204,  87, 182,
+    65,  94, 208, 124,  72, 350, 193, 313, 393, 408,
+   445, 309, 230, 419, 297, 241, 113, 219, 189, 128,
+   317, 415, 116, 328, 200, 339, 382, 434, 178,  64,
+   404,  83, 437, 223, 134, 192, 444, 112, 439, 139,
+   287, 167, 448, 212, 459, 222, 240, 233,  97, 302,
+   397, 234, 170, 276, 181, 455, 229, 438, 101, 280,
+   138, 127, 298, 117, 355, 203, 426,  95, 140, 244,
+   422, 407, 213, 129, 291, 354, 105, 245, 449,  86,
+   316, 460, 207, 353, 190, 107, 224, 427, 342, 327,
+   106, 321, 118, 123,  73, 211, 433, 218, 396, 385,
+   450,  62, 383, 349,  75, 461, 172, 331, 168, 246,
+   428, 332, 312, 201, 343, 416, 279,  63, 195, 333,
+    96, 173, 235, 288, 320, 191, 418,  84, 205, 100,
+    67, 394, 179, 344, 206, 338, 277, 405, 388, 395,
+   301, 315, 421, 183, 293, 322, 310, 384, 410, 194,
+   184,  89,  99, 103, 236,  78,  88,  77, 136, 399,
+   169, 202, 406, 125, 180, 440,  74, 387, 242, 231,
+    66, 281, 290, 141, 314, 424, 114,  85, 130, 356,
+   119, 299, 304, 398, 237, 409, 311, 417, 292, 457,
+   435, 225, 214, 209, 462, 108, 282, 446, 220, 351,
+   345, 142, 247, 329, 420, 463, 318, 300, 120, 109,
+   289, 451, 278, 441, 340, 303, 430, 215, 323, 226,
+   334, 131, 442, 248, 335, 357, 429, 324, 143, 346,
+   452, 238, 110, 216, 464, 249, 121, 431, 358, 227,
+   132, 453, 336, 425, 325, 347, 126, 104, 137, 458,
+   352, 243, 447, 115, 341, 210, 330, 221, 232, 436,
+   465, 319, 359, 111, 454, 228, 217, 122, 443, 348,
+   239, 250, 133, 144, 432, 337, 326
+};
+
+static Word16 sort_SID[35] = {
+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
+   10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
+   20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+   30, 31, 32, 33, 34
+};
+
+/* pointer table for bit sorting tables */
+static Word16 *sort_ptr[16] = { sort_660, sort_885, sort_1265, sort_1425, sort_1585, sort_1825, sort_1985, sort_2305,
+                               sort_2385, sort_SID,      NULL,      NULL,      NULL,      NULL,      NULL,      NULL};
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/oper_32b.h b/media/libstagefright/codecs/amrwbenc/inc/oper_32b.h
index 4159d84..7a0f564 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/oper_32b.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/oper_32b.h
@@ -1,31 +1,31 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/* Double precision operations */
-/* $Id$ */
-
-#ifndef __OPER_32B_H__
-#define __OPER_32B_H__
-
-void VO_L_Extract (Word32 L_32, Word16 *hi, Word16 *lo);
-Word32 L_Comp (Word16 hi, Word16 lo);
-Word32 Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2);
-Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n);
-Word32 Div_32 (Word32 L_num, Word16 denom_hi, Word16 denom_lo);
-
-#endif //__OPER_32B_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/* Double precision operations */
+/* $Id$ */
+
+#ifndef __OPER_32B_H__
+#define __OPER_32B_H__
+
+void VO_L_Extract (Word32 L_32, Word16 *hi, Word16 *lo);
+Word32 L_Comp (Word16 hi, Word16 lo);
+Word32 Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2);
+Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n);
+Word32 Div_32 (Word32 L_num, Word16 denom_hi, Word16 denom_lo);
+
+#endif //__OPER_32B_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/p_med_o.h b/media/libstagefright/codecs/amrwbenc/inc/p_med_o.h
index 27c4c7e..4a13f16 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/p_med_o.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/p_med_o.h
@@ -1,52 +1,52 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/*--------------------------------------------------------------------------*
- *                         P_MED_O.H                                        *
- *--------------------------------------------------------------------------*
- *       Median open-loop lag search				            *
- *--------------------------------------------------------------------------*/
-
-#ifndef __P_MED_O_H__
-#define __P_MED_O_H__
-
-Word16 Pitch_med_ol(                       /* output: open loop pitch lag                        */
-		Word16 wsp[],                         /* input : signal used to compute the open loop pitch */
-		/* wsp[-pit_max] to wsp[-1] should be known   */
-		Word16 L_min,                         /* input : minimum pitch lag                          */
-		Word16 L_max,                         /* input : maximum pitch lag                          */
-		Word16 L_frame,                       /* input : length of frame to compute pitch           */
-		Word16 L_0,                           /* input : old_ open-loop pitch                       */
-		Word16 * gain,                        /* output: normalize correlation of hp_wsp for the Lag */
-		Word16 * hp_wsp_mem,                  /* i:o   : memory of the hypass filter for hp_wsp[] (lg=9)   */
-		Word16 * old_hp_wsp,                  /* i:o   : hypass wsp[]                               */
-		Word16 wght_flg                       /* input : is weighting function used                 */
-		);
-
-Word16 Med_olag(                           /* output : median of  5 previous open-loop lags       */
-		Word16 prev_ol_lag,                   /* input  : previous open-loop lag                     */
-		Word16 old_ol_lag[5]
-	       );
-
-void Hp_wsp(
-		Word16 wsp[],                         /* i   : wsp[]  signal       */
-		Word16 hp_wsp[],                      /* o   : hypass wsp[]        */
-		Word16 lg,                            /* i   : lenght of signal    */
-		Word16 mem[]                          /* i/o : filter memory [9]   */
-	   );
-
-#endif  //__P_MED_O_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/*--------------------------------------------------------------------------*
+ *                         P_MED_O.H                                        *
+ *--------------------------------------------------------------------------*
+ *       Median open-loop lag search				            *
+ *--------------------------------------------------------------------------*/
+
+#ifndef __P_MED_O_H__
+#define __P_MED_O_H__
+
+Word16 Pitch_med_ol(                       /* output: open loop pitch lag                        */
+		Word16 wsp[],                         /* input : signal used to compute the open loop pitch */
+		/* wsp[-pit_max] to wsp[-1] should be known   */
+		Word16 L_min,                         /* input : minimum pitch lag                          */
+		Word16 L_max,                         /* input : maximum pitch lag                          */
+		Word16 L_frame,                       /* input : length of frame to compute pitch           */
+		Word16 L_0,                           /* input : old_ open-loop pitch                       */
+		Word16 * gain,                        /* output: normalize correlation of hp_wsp for the Lag */
+		Word16 * hp_wsp_mem,                  /* i:o   : memory of the hypass filter for hp_wsp[] (lg=9)   */
+		Word16 * old_hp_wsp,                  /* i:o   : hypass wsp[]                               */
+		Word16 wght_flg                       /* input : is weighting function used                 */
+		);
+
+Word16 Med_olag(                           /* output : median of  5 previous open-loop lags       */
+		Word16 prev_ol_lag,                   /* input  : previous open-loop lag                     */
+		Word16 old_ol_lag[5]
+	       );
+
+void Hp_wsp(
+		Word16 wsp[],                         /* i   : wsp[]  signal       */
+		Word16 hp_wsp[],                      /* o   : hypass wsp[]        */
+		Word16 lg,                            /* i   : lenght of signal    */
+		Word16 mem[]                          /* i/o : filter memory [9]   */
+	   );
+
+#endif  //__P_MED_O_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/p_med_ol.tab b/media/libstagefright/codecs/amrwbenc/inc/p_med_ol.tab
index 14bd1d5..d74ec8e 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/p_med_ol.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/p_med_ol.tab
@@ -1,47 +1,47 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*-----------------------------------------------------*
- | Table for function Pitch_med_ol()				   |
- *-----------------------------------------------------*/
-
- static Word16 corrweight[199]= {
-
- 10772, 10794, 10816, 10839, 10862, 10885, 10908, 10932, 10955, 10980,
- 11004, 11029, 11054, 11079, 11105, 11131, 11157, 11183, 11210, 11238,
- 11265, 11293, 11322, 11350, 11379, 11409, 11439, 11469, 11500, 11531,
- 11563, 11595, 11628, 11661, 11694, 11728, 11763, 11798, 11834, 11870,
- 11907, 11945, 11983, 12022, 12061, 12101, 12142, 12184, 12226, 12270,
- 12314, 12358, 12404, 12451, 12498, 12547, 12596, 12647, 12699, 12751,
- 12805, 12861, 12917, 12975, 13034, 13095, 13157, 13221, 13286, 13353,
- 13422, 13493, 13566, 13641, 13719, 13798, 13880, 13965, 14053, 14143,
- 14237, 14334, 14435, 14539, 14648, 14761, 14879, 15002, 15130, 15265,
- 15406, 15554, 15710, 15874, 16056, 16384, 16384, 16384, 16384, 16384,
- 16384, 16384, 16056, 15874, 15710, 15554, 15406, 15265, 15130, 15002,
- 14879, 14761, 14648, 14539, 14435, 14334, 14237, 14143, 14053, 13965,
- 13880, 13798, 13719, 13641, 13566, 13493, 13422, 13353, 13286, 13221,
- 13157, 13095, 13034, 12975, 12917, 12861, 12805, 12751, 12699, 12647,
- 12596, 12547, 12498, 12451, 12404, 12358, 12314, 12270, 12226, 12184,
- 12142, 12101, 12061, 12022, 11983, 11945, 11907, 11870, 11834, 11798,
- 11763, 11728, 11694, 11661, 11628, 11595, 11563, 11531, 11500, 11469,
- 11439, 11409, 11379, 11350, 11322, 11293, 11265, 11238, 11210, 11183,
- 11157, 11131, 11105, 11079, 11054, 11029, 11004, 10980, 10955, 10932,
- 10908, 10885, 10862, 10839, 10816, 10794, 10772, 10750, 10728};
-
-
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*-----------------------------------------------------*
+ | Table for function Pitch_med_ol()				   |
+ *-----------------------------------------------------*/
+
+ static Word16 corrweight[199]= {
+
+ 10772, 10794, 10816, 10839, 10862, 10885, 10908, 10932, 10955, 10980,
+ 11004, 11029, 11054, 11079, 11105, 11131, 11157, 11183, 11210, 11238,
+ 11265, 11293, 11322, 11350, 11379, 11409, 11439, 11469, 11500, 11531,
+ 11563, 11595, 11628, 11661, 11694, 11728, 11763, 11798, 11834, 11870,
+ 11907, 11945, 11983, 12022, 12061, 12101, 12142, 12184, 12226, 12270,
+ 12314, 12358, 12404, 12451, 12498, 12547, 12596, 12647, 12699, 12751,
+ 12805, 12861, 12917, 12975, 13034, 13095, 13157, 13221, 13286, 13353,
+ 13422, 13493, 13566, 13641, 13719, 13798, 13880, 13965, 14053, 14143,
+ 14237, 14334, 14435, 14539, 14648, 14761, 14879, 15002, 15130, 15265,
+ 15406, 15554, 15710, 15874, 16056, 16384, 16384, 16384, 16384, 16384,
+ 16384, 16384, 16056, 15874, 15710, 15554, 15406, 15265, 15130, 15002,
+ 14879, 14761, 14648, 14539, 14435, 14334, 14237, 14143, 14053, 13965,
+ 13880, 13798, 13719, 13641, 13566, 13493, 13422, 13353, 13286, 13221,
+ 13157, 13095, 13034, 12975, 12917, 12861, 12805, 12751, 12699, 12647,
+ 12596, 12547, 12498, 12451, 12404, 12358, 12314, 12270, 12226, 12184,
+ 12142, 12101, 12061, 12022, 11983, 11945, 11907, 11870, 11834, 11798,
+ 11763, 11728, 11694, 11661, 11628, 11595, 11563, 11531, 11500, 11469,
+ 11439, 11409, 11379, 11350, 11322, 11293, 11265, 11238, 11210, 11183,
+ 11157, 11131, 11105, 11079, 11054, 11029, 11004, 10980, 10955, 10932,
+ 10908, 10885, 10862, 10839, 10816, 10794, 10772, 10750, 10728};
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/q_gain2.tab b/media/libstagefright/codecs/amrwbenc/inc/q_gain2.tab
index 1a0deee..bc36489 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/q_gain2.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/q_gain2.tab
@@ -1,228 +1,228 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*------------------------------------------------------*
- * Tables for function q_gain2()                        *
- *                                                      *
- *  g_pitch(Q14),  g_code(Q11)                          *
- *                                                      *
- * pitch gain are ordered in table to reduce complexity *
- * during quantization of gains.                        *
- *------------------------------------------------------*/
-
-#define nb_qua_gain6b  64     /* Number of quantization level */
-#define nb_qua_gain7b  128    /* Number of quantization level */
-
-
-static Word16 t_qua_gain6b[64*2] = {
-   1566,  1332,
-   1577,  3557,
-   3071,  6490,
-   4193, 10163,
-   4496,  2534,
-   5019,  4488,
-   5586, 15614,
-   5725,  1422,
-   6453,   580,
-   6724,  6831,
-   7657,  3527,
-   8072,  2099,
-   8232,  5319,
-   8827,  8775,
-   9740,  2868,
-   9856,  1465,
-  10087, 12488,
-  10241,  4453,
-  10859,  6618,
-  11321,  3587,
-  11417,  1800,
-  11643,  2428,
-  11718,   988,
-  12312,  5093,
-  12523,  8413,
-  12574, 26214,
-  12601,  3396,
-  13172,  1623,
-  13285,  2423,
-  13418,  6087,
-  13459, 12810,
-  13656,  3607,
-  14111,  4521,
-  14144,  1229,
-  14425,  1871,
-  14431,  7234,
-  14445,  2834,
-  14628, 10036,
-  14860, 17496,
-  15161,  3629,
-  15209,  5819,
-  15299,  2256,
-  15518,  4722,
-  15663,  1060,
-  15759,  7972,
-  15939, 11964,
-  16020,  2996,
-  16086,  1707,
-  16521,  4254,
-  16576,  6224,
-  16894,  2380,
-  16906,   681,
-  17213,  8406,
-  17610,  3418,
-  17895,  5269,
-  18168, 11748,
-  18230,  1575,
-  18607, 32767,
-  18728, 21684,
-  19137,  2543,
-  19422,  6577,
-  19446,  4097,
-  19450,  9056,
-  20371, 14885};
-
-static Word16 t_qua_gain7b[128*2] = {
-    204,   441,
-    464,  1977,
-    869,  1077,
-   1072,  3062,
-   1281,  4759,
-   1647,  1539,
-   1845,  7020,
-   1853,   634,
-   1995,  2336,
-   2351, 15400,
-   2661,  1165,
-   2702,  3900,
-   2710, 10133,
-   3195,  1752,
-   3498,  2624,
-   3663,   849,
-   3984,  5697,
-   4214,  3399,
-   4415,  1304,
-   4695,  2056,
-   5376,  4558,
-   5386,   676,
-   5518, 23554,
-   5567,  7794,
-   5644,  3061,
-   5672,  1513,
-   5957,  2338,
-   6533,  1060,
-   6804,  5998,
-   6820,  1767,
-   6937,  3837,
-   7277,   414,
-   7305,  2665,
-   7466, 11304,
-   7942,   794,
-   8007,  1982,
-   8007,  1366,
-   8326,  3105,
-   8336,  4810,
-   8708,  7954,
-   8989,  2279,
-   9031,  1055,
-   9247,  3568,
-   9283,  1631,
-   9654,  6311,
-   9811,  2605,
-  10120,   683,
-  10143,  4179,
-  10245,  1946,
-  10335,  1218,
-  10468,  9960,
-  10651,  3000,
-  10951,  1530,
-  10969,  5290,
-  11203,  2305,
-  11325,  3562,
-  11771,  6754,
-  11839,  1849,
-  11941,  4495,
-  11954,  1298,
-  11975, 15223,
-  11977,   883,
-  11986,  2842,
-  12438,  2141,
-  12593,  3665,
-  12636,  8367,
-  12658,  1594,
-  12886,  2628,
-  12984,  4942,
-  13146,  1115,
-  13224,   524,
-  13341,  3163,
-  13399,  1923,
-  13549,  5961,
-  13606,  1401,
-  13655,  2399,
-  13782,  3909,
-  13868, 10923,
-  14226,  1723,
-  14232,  2939,
-  14278,  7528,
-  14439,  4598,
-  14451,   984,
-  14458,  2265,
-  14792,  1403,
-  14818,  3445,
-  14899,  5709,
-  15017, 15362,
-  15048,  1946,
-  15069,  2655,
-  15405,  9591,
-  15405,  4079,
-  15570,  7183,
-  15687,  2286,
-  15691,  1624,
-  15699,  3068,
-  15772,  5149,
-  15868,  1205,
-  15970,   696,
-  16249,  3584,
-  16338,  1917,
-  16424,  2560,
-  16483,  4438,
-  16529,  6410,
-  16620, 11966,
-  16839,  8780,
-  17030,  3050,
-  17033, 18325,
-  17092,  1568,
-  17123,  5197,
-  17351,  2113,
-  17374,   980,
-  17566, 26214,
-  17609,  3912,
-  17639, 32767,
-  18151,  7871,
-  18197,  2516,
-  18202,  5649,
-  18679,  3283,
-  18930,  1370,
-  19271, 13757,
-  19317,  4120,
-  19460,  1973,
-  19654, 10018,
-  19764,  6792,
-  19912,  5135,
-  20040,  2841,
-  21234, 19833};
-
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*------------------------------------------------------*
+ * Tables for function q_gain2()                        *
+ *                                                      *
+ *  g_pitch(Q14),  g_code(Q11)                          *
+ *                                                      *
+ * pitch gain are ordered in table to reduce complexity *
+ * during quantization of gains.                        *
+ *------------------------------------------------------*/
+
+#define nb_qua_gain6b  64     /* Number of quantization level */
+#define nb_qua_gain7b  128    /* Number of quantization level */
+
+
+static Word16 t_qua_gain6b[64*2] = {
+   1566,  1332,
+   1577,  3557,
+   3071,  6490,
+   4193, 10163,
+   4496,  2534,
+   5019,  4488,
+   5586, 15614,
+   5725,  1422,
+   6453,   580,
+   6724,  6831,
+   7657,  3527,
+   8072,  2099,
+   8232,  5319,
+   8827,  8775,
+   9740,  2868,
+   9856,  1465,
+  10087, 12488,
+  10241,  4453,
+  10859,  6618,
+  11321,  3587,
+  11417,  1800,
+  11643,  2428,
+  11718,   988,
+  12312,  5093,
+  12523,  8413,
+  12574, 26214,
+  12601,  3396,
+  13172,  1623,
+  13285,  2423,
+  13418,  6087,
+  13459, 12810,
+  13656,  3607,
+  14111,  4521,
+  14144,  1229,
+  14425,  1871,
+  14431,  7234,
+  14445,  2834,
+  14628, 10036,
+  14860, 17496,
+  15161,  3629,
+  15209,  5819,
+  15299,  2256,
+  15518,  4722,
+  15663,  1060,
+  15759,  7972,
+  15939, 11964,
+  16020,  2996,
+  16086,  1707,
+  16521,  4254,
+  16576,  6224,
+  16894,  2380,
+  16906,   681,
+  17213,  8406,
+  17610,  3418,
+  17895,  5269,
+  18168, 11748,
+  18230,  1575,
+  18607, 32767,
+  18728, 21684,
+  19137,  2543,
+  19422,  6577,
+  19446,  4097,
+  19450,  9056,
+  20371, 14885};
+
+static Word16 t_qua_gain7b[128*2] = {
+    204,   441,
+    464,  1977,
+    869,  1077,
+   1072,  3062,
+   1281,  4759,
+   1647,  1539,
+   1845,  7020,
+   1853,   634,
+   1995,  2336,
+   2351, 15400,
+   2661,  1165,
+   2702,  3900,
+   2710, 10133,
+   3195,  1752,
+   3498,  2624,
+   3663,   849,
+   3984,  5697,
+   4214,  3399,
+   4415,  1304,
+   4695,  2056,
+   5376,  4558,
+   5386,   676,
+   5518, 23554,
+   5567,  7794,
+   5644,  3061,
+   5672,  1513,
+   5957,  2338,
+   6533,  1060,
+   6804,  5998,
+   6820,  1767,
+   6937,  3837,
+   7277,   414,
+   7305,  2665,
+   7466, 11304,
+   7942,   794,
+   8007,  1982,
+   8007,  1366,
+   8326,  3105,
+   8336,  4810,
+   8708,  7954,
+   8989,  2279,
+   9031,  1055,
+   9247,  3568,
+   9283,  1631,
+   9654,  6311,
+   9811,  2605,
+  10120,   683,
+  10143,  4179,
+  10245,  1946,
+  10335,  1218,
+  10468,  9960,
+  10651,  3000,
+  10951,  1530,
+  10969,  5290,
+  11203,  2305,
+  11325,  3562,
+  11771,  6754,
+  11839,  1849,
+  11941,  4495,
+  11954,  1298,
+  11975, 15223,
+  11977,   883,
+  11986,  2842,
+  12438,  2141,
+  12593,  3665,
+  12636,  8367,
+  12658,  1594,
+  12886,  2628,
+  12984,  4942,
+  13146,  1115,
+  13224,   524,
+  13341,  3163,
+  13399,  1923,
+  13549,  5961,
+  13606,  1401,
+  13655,  2399,
+  13782,  3909,
+  13868, 10923,
+  14226,  1723,
+  14232,  2939,
+  14278,  7528,
+  14439,  4598,
+  14451,   984,
+  14458,  2265,
+  14792,  1403,
+  14818,  3445,
+  14899,  5709,
+  15017, 15362,
+  15048,  1946,
+  15069,  2655,
+  15405,  9591,
+  15405,  4079,
+  15570,  7183,
+  15687,  2286,
+  15691,  1624,
+  15699,  3068,
+  15772,  5149,
+  15868,  1205,
+  15970,   696,
+  16249,  3584,
+  16338,  1917,
+  16424,  2560,
+  16483,  4438,
+  16529,  6410,
+  16620, 11966,
+  16839,  8780,
+  17030,  3050,
+  17033, 18325,
+  17092,  1568,
+  17123,  5197,
+  17351,  2113,
+  17374,   980,
+  17566, 26214,
+  17609,  3912,
+  17639, 32767,
+  18151,  7871,
+  18197,  2516,
+  18202,  5649,
+  18679,  3283,
+  18930,  1370,
+  19271, 13757,
+  19317,  4120,
+  19460,  1973,
+  19654, 10018,
+  19764,  6792,
+  19912,  5135,
+  20040,  2841,
+  21234, 19833};
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/q_pulse.h b/media/libstagefright/codecs/amrwbenc/inc/q_pulse.h
index baf5525..b5d5280 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/q_pulse.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/q_pulse.h
@@ -1,66 +1,66 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*--------------------------------------------------------------------------*
- *                         Q_PULSE.H                                        *
- *--------------------------------------------------------------------------*
- * Coding and decoding of algebraic codebook			            *
- *--------------------------------------------------------------------------*/
-
-#ifndef  __Q_PULSE_H__
-#define  __Q_PULSE_H__
-
-#include "typedef.h"
-
-Word32 quant_1p_N1(                        /* (o) return (N+1) bits           */
-		Word16 pos,                           /* (i) position of the pulse       */
-		Word16 N);                            /* (i) number of bits for position */
-
-Word32 quant_2p_2N1(                       /* (o) return (2*N)+1 bits         */
-		Word16 pos1,                          /* (i) position of the pulse 1     */
-		Word16 pos2,                          /* (i) position of the pulse 2     */
-		Word16 N);                            /* (i) number of bits for position */
-
-Word32 quant_3p_3N1(                       /* (o) return (3*N)+1 bits         */
-		Word16 pos1,                          /* (i) position of the pulse 1     */
-		Word16 pos2,                          /* (i) position of the pulse 2     */
-		Word16 pos3,                          /* (i) position of the pulse 3     */
-		Word16 N);                            /* (i) number of bits for position */
-
-Word32 quant_4p_4N1(                       /* (o) return (4*N)+1 bits         */
-		Word16 pos1,                          /* (i) position of the pulse 1     */
-		Word16 pos2,                          /* (i) position of the pulse 2     */
-		Word16 pos3,                          /* (i) position of the pulse 3     */
-		Word16 pos4,                          /* (i) position of the pulse 4     */
-		Word16 N);                            /* (i) number of bits for position */
-
-Word32 quant_4p_4N(                        /* (o) return 4*N bits             */
-		Word16 pos[],                         /* (i) position of the pulse 1..4  */
-		Word16 N);                            /* (i) number of bits for position */
-
-Word32 quant_5p_5N(                        /* (o) return 5*N bits             */
-		Word16 pos[],                         /* (i) position of the pulse 1..5  */
-		Word16 N);                            /* (i) number of bits for position */
-
-Word32 quant_6p_6N_2(                      /* (o) return (6*N)-2 bits         */
-		Word16 pos[],                         /* (i) position of the pulse 1..6  */
-		Word16 N);                            /* (i) number of bits for position */
-
-
-#endif //__Q_PULSE_H__
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*--------------------------------------------------------------------------*
+ *                         Q_PULSE.H                                        *
+ *--------------------------------------------------------------------------*
+ * Coding and decoding of algebraic codebook			            *
+ *--------------------------------------------------------------------------*/
+
+#ifndef  __Q_PULSE_H__
+#define  __Q_PULSE_H__
+
+#include "typedef.h"
+
+Word32 quant_1p_N1(                        /* (o) return (N+1) bits           */
+		Word16 pos,                           /* (i) position of the pulse       */
+		Word16 N);                            /* (i) number of bits for position */
+
+Word32 quant_2p_2N1(                       /* (o) return (2*N)+1 bits         */
+		Word16 pos1,                          /* (i) position of the pulse 1     */
+		Word16 pos2,                          /* (i) position of the pulse 2     */
+		Word16 N);                            /* (i) number of bits for position */
+
+Word32 quant_3p_3N1(                       /* (o) return (3*N)+1 bits         */
+		Word16 pos1,                          /* (i) position of the pulse 1     */
+		Word16 pos2,                          /* (i) position of the pulse 2     */
+		Word16 pos3,                          /* (i) position of the pulse 3     */
+		Word16 N);                            /* (i) number of bits for position */
+
+Word32 quant_4p_4N1(                       /* (o) return (4*N)+1 bits         */
+		Word16 pos1,                          /* (i) position of the pulse 1     */
+		Word16 pos2,                          /* (i) position of the pulse 2     */
+		Word16 pos3,                          /* (i) position of the pulse 3     */
+		Word16 pos4,                          /* (i) position of the pulse 4     */
+		Word16 N);                            /* (i) number of bits for position */
+
+Word32 quant_4p_4N(                        /* (o) return 4*N bits             */
+		Word16 pos[],                         /* (i) position of the pulse 1..4  */
+		Word16 N);                            /* (i) number of bits for position */
+
+Word32 quant_5p_5N(                        /* (o) return 5*N bits             */
+		Word16 pos[],                         /* (i) position of the pulse 1..5  */
+		Word16 N);                            /* (i) number of bits for position */
+
+Word32 quant_6p_6N_2(                      /* (o) return (6*N)-2 bits         */
+		Word16 pos[],                         /* (i) position of the pulse 1..6  */
+		Word16 N);                            /* (i) number of bits for position */
+
+
+#endif //__Q_PULSE_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/qisf_ns.tab b/media/libstagefright/codecs/amrwbenc/inc/qisf_ns.tab
index 52f0daf..43c47e9 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/qisf_ns.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/qisf_ns.tab
@@ -1,347 +1,347 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*-------------------------------------------------------------------*
- *                         qisf_ns.h
- *-------------------------------------------------------------------*
- * Quantization tables for split by 5 VQ of ISFs for a background noise database
- * Version whith no prediction
- *-------------------------------------------------------------------*/
-
-#define ORDER   16            /* order of linear prediction filter */
-#define ISF_GAP 128
-
-#define SIZE_BK_NOISE1  64
-#define SIZE_BK_NOISE2  64
-#define SIZE_BK_NOISE3  64
-#define SIZE_BK_NOISE4  32
-#define SIZE_BK_NOISE5  32
-
-
-/* means of ISFs */
- static Word16 mean_isf_noise[ORDER] = {
-
-   478,  1100,  2213,  3267,  4219,  5222,  6198,  7240,
-  8229,  9153, 10098, 11108, 12144, 13184, 14165,  3803};
-
-
-/* 28 bits */
-/*-------------------------------------------------------------------*
- *  isf codebooks:  split-by-5 VQ                                    *
- *                                                                   *
- *  codebook   vector dimension    number of vectors                 *
- *  ~~~~~~~~   ~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~                 *
- *     1            2                  64                            *
- *     2            3                  64                            *
- *     3            3                  64                            *
- *     4            4                  32                            *
- *     5            4                  32                            *
- *-------------------------------------------------------------------*/
-
-/*------------------------------------------------*
- * 1st split:   isf0 to isf1
- *------------------------------------------------*/
-
-
- static Word16 dico1_isf_noise[SIZE_BK_NOISE1*2] = {
-
-  -269,  -673,
-  -222,  -537,
-  -233,  -430,
-  -138,  -451,
-  -212,  -331,
-  -192,  -241,
-   -87,  -231,
-  -191,  -128,
-   -70,  -106,
-  -164,    -6,
-    74,  -179,
-    27,   -33,
-  -102,    74,
-  -162,   115,
-   -94,   172,
-    -6,   130,
-  -143,   234,
-    14,   218,
-   -65,   270,
-    88,   182,
-  -124,   341,
-   -44,   381,
-    38,   335,
-   117,   274,
-  -112,   454,
-    74,   431,
-    -5,   488,
-   175,   384,
-   -83,   561,
-   122,   529,
-    21,   601,
-   229,   481,
-   231,   303,
-   226,   608,
-   300,   372,
-   210,   187,
-   306,   265,
-   328,   473,
-   382,   331,
-   371,   132,
-   139,    58,
-   365,    21,
-   250,   -82,
-   443,   218,
-   483,   110,
-   426,   415,
-   579,   222,
-   518,   333,
-   573,   448,
-   455,   529,
-   685,   329,
-   332,   580,
-   595,   593,
-   468,   645,
-   762,   517,
-   326,   709,
-   485,   793,
-   130,   684,
-   671,   737,
-   354,   876,
-    88,   806,
-   -65,   706,
-   -35,  1016,
-   266,  1123};
-
-
-/*------------------------------------------------*
- * 2nd split:   isf2 to isf4
- *------------------------------------------------*/
-
- static Word16 dico2_isf_noise[SIZE_BK_NOISE2*3] = {
-
-  -824,  -884,  -949,
-  -805,  -456,  -418,
-  -442,  -438,  -541,
-  -217,  -578,  -793,
-  -168,  -444,  -582,
-  -287,  -492,  -274,
-  -552,  -297,  -300,
-  -163,  -333,  -358,
-  -370,  -232,  -232,
-  -175,  -358,  -159,
-  -381,   -21,  -357,
-  -184,  -159,  -162,
-   -53,  -191,  -280,
-    18,  -267,  -215,
-  -138,    61,  -283,
-    71,   -95,  -294,
-    13,  -156,  -546,
-     0,   -83,   -79,
-    44,    97,  -316,
-   178,   -52,  -213,
-   222,  -261,  -422,
-   237,  -118,   -44,
-   141,   145,  -132,
-   363,    81,  -287,
-   213,    65,    34,
-  -107,    94,    -5,
-    91,   -29,   126,
-  -355,    51,   -41,
-  -219,   -76,   145,
-   -63,   100,   244,
-  -719,    44,    27,
-  -572,  -124,   155,
-  -423,   133,   315,
-  -917,    71,   224,
-  -268,   318,   131,
-   -93,  -190,   420,
-   -97,   122,   491,
-   -79,   317,   355,
-   130,   100,   325,
-    86,  -293,   210,
-   133,   258,   161,
-   176,   -73,   465,
-   195,   300,   384,
-   348,    22,   221,
-   376,   183,   409,
-   377,   286,   202,
-   242,   213,   659,
-   257,   565,   248,
-   344,   408,   -76,
-   405,   440,   509,
-   612,   385,   379,
-   536,   607,   216,
-   -56,   582,   192,
-   100,   517,   567,
-  -365,   448,   445,
-   728,   347,    10,
-   505,   357,   759,
-   636,   582,   658,
-   335,   517,   852,
-   378,   809,   572,
-  -195,   878,   829,
-   529,   707,   987,
-   918,   726,   392,
-  1250,   997,  1063};
-
-/*------------------------------------------------*
- * 3rd split:   isf5 to isf7
- *------------------------------------------------*/
-
- static Word16 dico3_isf_noise[SIZE_BK_NOISE3*3] = {
-
-  -805,  -838,  -774,
-  -522,  -627,  -828,
-  -477,  -486,  -603,
-  -295,  -481,  -634,
-  -366,  -384,  -393,
-  -186,  -414,  -396,
-  -237,  -394,  -106,
-  -252,  -202,  -275,
-   -61,  -177,  -442,
-   -84,  -198,  -199,
-  -179,  -125,   -31,
-   -72,   -47,  -163,
-  -298,  -220,   215,
-   -64,  -168,   251,
-  -133,   156,   -59,
-   -30,    -2,   127,
-    54,    66,   -61,
-  -233,    21,   251,
-   209,   -50,    32,
-    33,   194,   136,
-  -117,   -18,   475,
-   202,    46,   309,
-   256,   185,    53,
-    35,   200,   390,
-   200,   263,   242,
-  -216,   302,   294,
-   128,   358,     0,
-    19,   431,   287,
-   224,   447,   280,
-   367,   165,   213,
-   397,   314,   319,
-   383,   379,    75,
-   277,   325,   462,
-   394,   505,   334,
-   251,    98,  -213,
-   450,   153,   448,
-   565,   226,    76,
-   470,   383,   502,
-   635,   390,   278,
-   237,   135,   620,
-   342,   401,   649,
-   331,   551,   518,
-   130,   418,   592,
-   531,   306,   737,
-   729,   389,   580,
-   497,   557,   699,
-   296,   383,   874,
-   283,   624,   759,
-   126,   622,   476,
-   559,   595,   472,
-   382,   770,   616,
-   719,   613,   745,
-   540,   639,   928,
-   517,   826,   801,
-   684,   811,   604,
-   752,   786,   857,
-   933,   661,   350,
-   694,   450,  1061,
-   562,   911,  1051,
-   824,   813,  1104,
-   758,  1047,   882,
-  1140,   917,   889,
-  1039,  1246,  1426,
-  1483,  1666,  1876};
-
-/*------------------------------------------------*
- * 4th split:   isf8 to isf11
- *------------------------------------------------*/
-
- static Word16 dico4_isf_noise[SIZE_BK_NOISE4*4] = {
-
-  -776,  -854,  -891,  -920,
-  -552,  -610,  -663,  -741,
-  -321,  -370,  -476,  -565,
-   274,  -160,  -456,   201,
-   265,    67,  -160,  -306,
-    -8,  -210,    79,   272,
-   163,   236,   307,   308,
-   578,   317,    64,   298,
-    -9,   197,   342,   620,
-   343,   232,   314,   622,
-   173,   149,   548,   527,
-   356,   370,   481,   376,
-   135,   444,   488,   556,
-   391,   471,   487,   653,
-   228,   424,   576,   835,
-   422,   372,   722,   682,
-   295,   673,   693,   635,
-   539,   596,   590,   449,
-   475,   618,   659,   818,
-   735,   517,   491,   673,
-   602,   346,   257,   877,
-   625,   635,   849,   720,
-   727,   818,   698,   595,
-   653,   481,   690,  1139,
-   814,   762,   704,   908,
-   507,   747,   898,   936,
-   848,   855,   924,   785,
-   646,  1037,   882,   795,
-   772,   845,  1024,  1151,
-  1133,   983,   818,   921,
-   940,  1068,  1252,  1302,
-  1588,  1767,  1718,  1513};
-
-/*------------------------------------------------*
- * 5th split:   isf12 to isf15
- *------------------------------------------------*/
-
- static Word16 dico5_isf_noise[SIZE_BK_NOISE5*4] = {
-  -810,  -879,  -945,  -254,
-   248,   184,   671,   128,
-   288,   703,   918,    99,
-   658,   558,   662,   219,
-   552,   585,   910,   208,
-   559,   804,   759,   119,
-   606,   774,   921,  -139,
-   782,   761,   748,   208,
-   756,   708,   983,    56,
-   544,   864,  1010,   152,
-   737,   698,   987,   299,
-   771,   924,   879,   103,
-   536,   785,   961,   405,
-   667,   916,   801,   328,
-   738,   705,   773,   439,
-   823,   871,   992,   355,
-   640,  1004,  1052,   369,
-   724,   822,   949,   597,
-   415,   655,   729,   482,
-  1009,   896,   793,   363,
-   908,   803,   687,   -25,
-  1016,   838,  1011,   189,
-   947,  1112,   942,   222,
-   914,  1049,   981,   527,
-   956,   987,  1011,  -120,
-   781,  1049,  1121,    92,
-  1178,  1053,   884,    47,
-  1123,  1059,  1182,   118,
-   933,   972,  1277,   357,
-  1109,   918,  1101,   503,
-  1039,  1286,  1220,   317,
-  1351,  1207,  1010,   326};
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*-------------------------------------------------------------------*
+ *                         qisf_ns.h
+ *-------------------------------------------------------------------*
+ * Quantization tables for split by 5 VQ of ISFs for a background noise database
+ * Version whith no prediction
+ *-------------------------------------------------------------------*/
+
+#define ORDER   16            /* order of linear prediction filter */
+#define ISF_GAP 128
+
+#define SIZE_BK_NOISE1  64
+#define SIZE_BK_NOISE2  64
+#define SIZE_BK_NOISE3  64
+#define SIZE_BK_NOISE4  32
+#define SIZE_BK_NOISE5  32
+
+
+/* means of ISFs */
+ static Word16 mean_isf_noise[ORDER] = {
+
+   478,  1100,  2213,  3267,  4219,  5222,  6198,  7240,
+  8229,  9153, 10098, 11108, 12144, 13184, 14165,  3803};
+
+
+/* 28 bits */
+/*-------------------------------------------------------------------*
+ *  isf codebooks:  split-by-5 VQ                                    *
+ *                                                                   *
+ *  codebook   vector dimension    number of vectors                 *
+ *  ~~~~~~~~   ~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~                 *
+ *     1            2                  64                            *
+ *     2            3                  64                            *
+ *     3            3                  64                            *
+ *     4            4                  32                            *
+ *     5            4                  32                            *
+ *-------------------------------------------------------------------*/
+
+/*------------------------------------------------*
+ * 1st split:   isf0 to isf1
+ *------------------------------------------------*/
+
+
+ static Word16 dico1_isf_noise[SIZE_BK_NOISE1*2] = {
+
+  -269,  -673,
+  -222,  -537,
+  -233,  -430,
+  -138,  -451,
+  -212,  -331,
+  -192,  -241,
+   -87,  -231,
+  -191,  -128,
+   -70,  -106,
+  -164,    -6,
+    74,  -179,
+    27,   -33,
+  -102,    74,
+  -162,   115,
+   -94,   172,
+    -6,   130,
+  -143,   234,
+    14,   218,
+   -65,   270,
+    88,   182,
+  -124,   341,
+   -44,   381,
+    38,   335,
+   117,   274,
+  -112,   454,
+    74,   431,
+    -5,   488,
+   175,   384,
+   -83,   561,
+   122,   529,
+    21,   601,
+   229,   481,
+   231,   303,
+   226,   608,
+   300,   372,
+   210,   187,
+   306,   265,
+   328,   473,
+   382,   331,
+   371,   132,
+   139,    58,
+   365,    21,
+   250,   -82,
+   443,   218,
+   483,   110,
+   426,   415,
+   579,   222,
+   518,   333,
+   573,   448,
+   455,   529,
+   685,   329,
+   332,   580,
+   595,   593,
+   468,   645,
+   762,   517,
+   326,   709,
+   485,   793,
+   130,   684,
+   671,   737,
+   354,   876,
+    88,   806,
+   -65,   706,
+   -35,  1016,
+   266,  1123};
+
+
+/*------------------------------------------------*
+ * 2nd split:   isf2 to isf4
+ *------------------------------------------------*/
+
+ static Word16 dico2_isf_noise[SIZE_BK_NOISE2*3] = {
+
+  -824,  -884,  -949,
+  -805,  -456,  -418,
+  -442,  -438,  -541,
+  -217,  -578,  -793,
+  -168,  -444,  -582,
+  -287,  -492,  -274,
+  -552,  -297,  -300,
+  -163,  -333,  -358,
+  -370,  -232,  -232,
+  -175,  -358,  -159,
+  -381,   -21,  -357,
+  -184,  -159,  -162,
+   -53,  -191,  -280,
+    18,  -267,  -215,
+  -138,    61,  -283,
+    71,   -95,  -294,
+    13,  -156,  -546,
+     0,   -83,   -79,
+    44,    97,  -316,
+   178,   -52,  -213,
+   222,  -261,  -422,
+   237,  -118,   -44,
+   141,   145,  -132,
+   363,    81,  -287,
+   213,    65,    34,
+  -107,    94,    -5,
+    91,   -29,   126,
+  -355,    51,   -41,
+  -219,   -76,   145,
+   -63,   100,   244,
+  -719,    44,    27,
+  -572,  -124,   155,
+  -423,   133,   315,
+  -917,    71,   224,
+  -268,   318,   131,
+   -93,  -190,   420,
+   -97,   122,   491,
+   -79,   317,   355,
+   130,   100,   325,
+    86,  -293,   210,
+   133,   258,   161,
+   176,   -73,   465,
+   195,   300,   384,
+   348,    22,   221,
+   376,   183,   409,
+   377,   286,   202,
+   242,   213,   659,
+   257,   565,   248,
+   344,   408,   -76,
+   405,   440,   509,
+   612,   385,   379,
+   536,   607,   216,
+   -56,   582,   192,
+   100,   517,   567,
+  -365,   448,   445,
+   728,   347,    10,
+   505,   357,   759,
+   636,   582,   658,
+   335,   517,   852,
+   378,   809,   572,
+  -195,   878,   829,
+   529,   707,   987,
+   918,   726,   392,
+  1250,   997,  1063};
+
+/*------------------------------------------------*
+ * 3rd split:   isf5 to isf7
+ *------------------------------------------------*/
+
+ static Word16 dico3_isf_noise[SIZE_BK_NOISE3*3] = {
+
+  -805,  -838,  -774,
+  -522,  -627,  -828,
+  -477,  -486,  -603,
+  -295,  -481,  -634,
+  -366,  -384,  -393,
+  -186,  -414,  -396,
+  -237,  -394,  -106,
+  -252,  -202,  -275,
+   -61,  -177,  -442,
+   -84,  -198,  -199,
+  -179,  -125,   -31,
+   -72,   -47,  -163,
+  -298,  -220,   215,
+   -64,  -168,   251,
+  -133,   156,   -59,
+   -30,    -2,   127,
+    54,    66,   -61,
+  -233,    21,   251,
+   209,   -50,    32,
+    33,   194,   136,
+  -117,   -18,   475,
+   202,    46,   309,
+   256,   185,    53,
+    35,   200,   390,
+   200,   263,   242,
+  -216,   302,   294,
+   128,   358,     0,
+    19,   431,   287,
+   224,   447,   280,
+   367,   165,   213,
+   397,   314,   319,
+   383,   379,    75,
+   277,   325,   462,
+   394,   505,   334,
+   251,    98,  -213,
+   450,   153,   448,
+   565,   226,    76,
+   470,   383,   502,
+   635,   390,   278,
+   237,   135,   620,
+   342,   401,   649,
+   331,   551,   518,
+   130,   418,   592,
+   531,   306,   737,
+   729,   389,   580,
+   497,   557,   699,
+   296,   383,   874,
+   283,   624,   759,
+   126,   622,   476,
+   559,   595,   472,
+   382,   770,   616,
+   719,   613,   745,
+   540,   639,   928,
+   517,   826,   801,
+   684,   811,   604,
+   752,   786,   857,
+   933,   661,   350,
+   694,   450,  1061,
+   562,   911,  1051,
+   824,   813,  1104,
+   758,  1047,   882,
+  1140,   917,   889,
+  1039,  1246,  1426,
+  1483,  1666,  1876};
+
+/*------------------------------------------------*
+ * 4th split:   isf8 to isf11
+ *------------------------------------------------*/
+
+ static Word16 dico4_isf_noise[SIZE_BK_NOISE4*4] = {
+
+  -776,  -854,  -891,  -920,
+  -552,  -610,  -663,  -741,
+  -321,  -370,  -476,  -565,
+   274,  -160,  -456,   201,
+   265,    67,  -160,  -306,
+    -8,  -210,    79,   272,
+   163,   236,   307,   308,
+   578,   317,    64,   298,
+    -9,   197,   342,   620,
+   343,   232,   314,   622,
+   173,   149,   548,   527,
+   356,   370,   481,   376,
+   135,   444,   488,   556,
+   391,   471,   487,   653,
+   228,   424,   576,   835,
+   422,   372,   722,   682,
+   295,   673,   693,   635,
+   539,   596,   590,   449,
+   475,   618,   659,   818,
+   735,   517,   491,   673,
+   602,   346,   257,   877,
+   625,   635,   849,   720,
+   727,   818,   698,   595,
+   653,   481,   690,  1139,
+   814,   762,   704,   908,
+   507,   747,   898,   936,
+   848,   855,   924,   785,
+   646,  1037,   882,   795,
+   772,   845,  1024,  1151,
+  1133,   983,   818,   921,
+   940,  1068,  1252,  1302,
+  1588,  1767,  1718,  1513};
+
+/*------------------------------------------------*
+ * 5th split:   isf12 to isf15
+ *------------------------------------------------*/
+
+ static Word16 dico5_isf_noise[SIZE_BK_NOISE5*4] = {
+  -810,  -879,  -945,  -254,
+   248,   184,   671,   128,
+   288,   703,   918,    99,
+   658,   558,   662,   219,
+   552,   585,   910,   208,
+   559,   804,   759,   119,
+   606,   774,   921,  -139,
+   782,   761,   748,   208,
+   756,   708,   983,    56,
+   544,   864,  1010,   152,
+   737,   698,   987,   299,
+   771,   924,   879,   103,
+   536,   785,   961,   405,
+   667,   916,   801,   328,
+   738,   705,   773,   439,
+   823,   871,   992,   355,
+   640,  1004,  1052,   369,
+   724,   822,   949,   597,
+   415,   655,   729,   482,
+  1009,   896,   793,   363,
+   908,   803,   687,   -25,
+  1016,   838,  1011,   189,
+   947,  1112,   942,   222,
+   914,  1049,   981,   527,
+   956,   987,  1011,  -120,
+   781,  1049,  1121,    92,
+  1178,  1053,   884,    47,
+  1123,  1059,  1182,   118,
+   933,   972,  1277,   357,
+  1109,   918,  1101,   503,
+  1039,  1286,  1220,   317,
+  1351,  1207,  1010,   326};
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/qpisf_2s.tab b/media/libstagefright/codecs/amrwbenc/inc/qpisf_2s.tab
index 4d869a4..b6b4e81 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/qpisf_2s.tab
+++ b/media/libstagefright/codecs/amrwbenc/inc/qpisf_2s.tab
@@ -1,1360 +1,1360 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*-------------------------------------------------------------------*
- *                         qpisf_2s.h
- *-------------------------------------------------------------------*
- * Quantization tables for two-stage of ISFs (split by 2 in 1st stage)
- * Version whith prediction MU = 0.25
- *-------------------------------------------------------------------*/
-
-#define ORDER   16            /* order of linear prediction filter */
-#define ISF_GAP 128           /* 50 Hz */
-#define N_SURV  4
-
-#define SIZE_BK1  256
-#define SIZE_BK2  256
-#define SIZE_BK21 64
-#define SIZE_BK22 128
-#define SIZE_BK23 128
-#define SIZE_BK24 32
-#define SIZE_BK25 32
-
-#define SIZE_BK21_36b 128
-#define SIZE_BK22_36b 128
-#define SIZE_BK23_36b 64
-
-/* means of ISFs */
-static Word16 mean_isf[ORDER] = {
-
-   738,  1326,  2336,  3578,  4596,  5662,  6711,  7730,
-  8750,  9753, 10705, 11728, 12833, 13971, 15043,  4037};
-
-/* 46 bits */
-/*-------------------------------------------------------------------*
- *  isf codebooks:  two-stage VQ with split-by-5 in 2nd stage        *
- *                                                                   *
- *  codebook   vector dimension    number of vectors                 *
- *  ~~~~~~~~   ~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~                 *
- *     1_1            9                  256                         *
- *     1_2            7                  256                         *
- *     2_1            3                  64                          *
- *     2_2            3                  128                         *
- *     2_3            3                  128                         *
- *     2_4            3                  32                          *
- *     2_5            4                  32                          *
- *-------------------------------------------------------------------*/
-
-/*------------------------------------------------*
- * 1st stage codebook; 1st split:   isf0 to isf8
- *------------------------------------------------*/
-
-static Word16 dico1_isf[SIZE_BK1*9] = {
-
-   579,  1081,  1035,   390,     3,  -263,  -198,   -82,    38,
-    18,   -68,   -12,   313,   761,   405,   249,   111,   -76,
-   740,  1263,  1292,  1006,   997,  1019,  1017,   976,   923,
-   -91,   827,   948,   648,   613,   535,   522,   490,   421,
-    41,   -44,  -281,  -472,   652,   534,   193,   135,   -90,
-    41,  -121,  -356,   -60,   663,   307,    61,   -48,  -344,
-   557,   946,  1049,   867,   846,   990,  1112,  1262,  1241,
-  -118,  -204,   328,   512,   870,   793,   610,   402,   186,
-   156,   293,    74,  -338,  -475,  -897,  -594,  -161,  -497,
-   226,   131,  -138,   307,   169,  -271,  -164,  -387,  -624,
-    62,   -32,   -61,  -252,  -541,  -828, -1027,  -523,  -662,
-   102,   -61,   141,   112,  -270,  -251,  -541,    25,  -150,
-     6,  -132,  -356,  -686,   -96,  -322,  -522,   -31,  -326,
-   -36,  -209,  -521,  -229,   307,  -132,    -5,   -99,  -384,
-    60,   -51,  -237,  -668,  -973,  -407,  -708,   -75,  -172,
-    26,  -138,  -266,   111,  -302,    43,  -278,  -356,  -359,
-   570,   822,   496,  -154,  -312,   -92,   137,   279,   371,
-  -146,   368,   409,    68,     6,    77,   167,   202,   162,
-   633,   898,   996,   756,   662,   683,   783,   909,   996,
-  -103,   294,   607,   415,   483,   462,   480,   431,   408,
-  -120,  -338,  -612,  -524,   584,   331,    92,   433,   276,
-  -178,  -293,  -154,   -41,   269,   100,    -9,   213,   160,
-   830,   736,   278,   820,  1254,   686,   712,  1039,   473,
-  -218,  -304,   463,   454,   397,   273,   202,   286,   273,
-  -232,     7,     6,  -388,  -472,  -427,  -378,  -167,  -100,
-  -294,  -183,   134,   -47,   101,   -88,   -84,  -117,    -3,
-    57,    17,  -202,  -634,  -989, -1119,  -533,   176,   -36,
-   120,   -28,    23,   111,  -319,   318,   -22,   -77,   266,
-  -271,  -464,  -434,  -658,  -640,  -385,  -385,   -99,   -69,
-  -198,  -259,  -266,   -44,   -39,  -139,  -137,   171,    66,
-     9,  -145,  -377,  -846, -1000,  -111,  -325,   342,   135,
-   -81,  -286,  -380,   192,   -57,   307,    76,   -24,  -140,
-   677,   702,   247,    56,   249,   141,  -105,  -236,   -99,
-    36,   -39,   -69,   348,   198,   -93,   322,    91,   -72,
-   503,   885,  1508,  1307,  1282,  1172,  1119,  1209,  1061,
-   416,   719,   989,  1227,  1001,  1052,   954,   741,  1044,
-  -127,  -376,  -657,   139,   623,   223,   501,   306,   220,
-  -113,  -384,  -796,   504,   438,    85,   213,   -83,  -194,
-   585,  1132,  1233,  1091,  1247,  1433,  1512,  1448,  1314,
-  -174,  -422,     7,  1155,  1089,  1182,  1003,   945,   806,
-     8,  -126,  -317,  -103,  -351,  -695,   -98,  -268,  -537,
-    33,  -103,  -290,   167,   -39,  -407,    44,  -208,  -375,
-   104,   -23,   -64,  -291,  -637,  -851, -1084,   -61,  -112,
-   -75,  -306,  -434,   218,  -148,  -354,  -680,  -133,  -216,
-  -121,  -377,  -718,   -97,  -130,  -361,  -156,  -379,  -599,
-   -56,  -254,  -586,   235,   157,  -214,    11,  -260,  -149,
-  -124,  -267,  -397,  -580,  -593,  -527,  -805,  -385,   346,
-  -193,  -440,  -708,  -351,  -141,  -255,  -499,  -147,  -185,
-   448,   660,   494,   208,   509,   461,   338,   291,   149,
-  -223,    88,   335,   159,   212,   191,   286,   308,   205,
-   -31,   469,   803,   659,   619,   658,   843,   987,  1113,
-  -171,  -242,   514,   362,   295,   524,   552,   694,   585,
-   -64,  -308,  -448,   -21,   284,   786,   446,   289,    92,
-  -218,  -390,    -7,   169,   206,   330,   352,   408,   358,
-   -36,   702,   959,   859,   861,  1115,  1269,  1357,  1305,
-  -133,  -341,   -65,   678,   417,   440,   486,   518,   780,
-    33,   -44,  -191,  -344,  -461,  -755,  -201,   217,   -31,
-  -353,  -547,   -44,   123,   -61,   -68,   -79,    29,    60,
-    73,   -57,  -406,  -766, -1243, -1203,   240,   400,   165,
-   -73,  -282,  -601,  -213,  -171,  -375,   332,    35,  -103,
-   -29,  -207,  -553,  -476,  -638,  -908,   172,   -22,  -135,
-  -192,  -239,  -164,  -103,  -111,   -47,   153,   125,   110,
-    -1,  -203,  -570, -1030, -1424,  -535,   155,     1,   147,
-  -333,  -653,  -865,  -197,  -158,   -21,   -44,    95,   108,
-   389,   588,   490,    33,  -237,  -524,  -628,  -136,  -260,
-    40,  -177,  -462,   453,   862,   380,   131,  -130,  -405,
-   842,  1678,  1841,  1549,  1474,  1256,  1082,   905,   742,
-   370,  1216,  1768,  1633,  1212,   636,    22,  -330,    71,
-   -76,  -281,  -741,  -742,   898,   619,   277,    71,  -222,
-   -32,  -265,  -556,   -25,   994,   682,   305,   126,  -165,
-    73,   738,   893,   968,   993,  1768,  2273,  1840,  1391,
-   -69,  -349,  -585,   234,  1158,   903,   626,   510,   251,
-    -1,   -99,  -272,  -210,  -603,  -351,  -540,  -811,  -383,
-   -16,  -230,  -504,   410,   149,  -205,  -343,  -651,  -639,
-   103,    -9,  -227,  -205,  -562,  -781, -1079, -1208,  -156,
-   143,    63,  -135,   -67,  -317,  -602,  -784, -1154,  -640,
-  -144,  -391,  -674,  -622,  -200,  -254,  -660,  -947,  -395,
-   -40,  -250,  -625,    27,   543,    94,  -131,  -386,  -673,
-  -123,  -371,  -757,  -451,  -564,  -614,  -415,  -711,   -35,
-  -116,  -309,  -593,  -268,   239,   -33,  -338,  -650,  -135,
-    94,   251,   554,    57,  -312,  -423,  -154,   -57,   235,
-  -268,   -71,   381,   114,   -44,   -87,   125,   173,   133,
-  1513,  1714,  1238,   534,   276,   315,   461,   459,   508,
-  -131,   -19,  1149,   670,   486,   356,   309,   369,   296,
-  -223,  -501,  -899,  -722,   -70,     6,   131,   310,   394,
-   -99,  -303,  -517,   249,    64,   -53,   135,   -11,   453,
-  -147,  -399,  -730,  -401,   817,   738,   802,   749,   575,
-  -154,  -435,  -739,   800,   593,   366,   529,   318,   326,
-  -224,    45,   -39,  -387,  -515,  -518,  -608,  -384,  -321,
-  -315,  -377,   143,  -101,  -113,  -377,  -177,  -144,   -12,
-   117,    40,  -239,  -651, -1051,  -581,  -737,  -990,  -328,
-    26,   -50,  -157,   -23,  -453,  -283,  -531,  -546,   192,
-  -252,  -501,  -743,  -589,  -627,  -499,  -328,  -118,   -72,
-  -324,  -494,  -244,  -306,  -144,  -177,  -262,  -135,   -78,
-   -36,  -234,  -519,  -961, -1290,  -314,  -479,  -371,   -45,
-   -95,  -292,  -535,    -8,  -300,   112,  -164,  -277,   198,
-   -99,  -128,   880,   836,   579,   351,    23,   -95,  -217,
-   -27,  -258,   124,  1011,   597,   425,   144,     7,   -73,
-   421,  1293,  1640,  1623,  1742,  1617,  1499,  1284,  1006,
-   -95,   752,  1680,  1569,  1618,  1436,  1200,   980,   712,
-   -69,  -300,  -683,  -435,  1132,   899,   504,   332,   109,
-   -74,  -323,  -637,   563,  1074,   608,   371,   105,   -49,
-   -78,   831,  1194,  1110,  1378,  1481,  1492,  1365,  1217,
-  -259,  -121,  1440,  1334,  1628,  1490,  1438,  1223,   933,
-   -82,  -306,  -613,  -222,  -378,  -675,  -545,  -671,  -845,
-    53,  -124,  -347,   422,    52,  -125,  -270,  -529,     9,
-    79,   -89,  -320,  -662,  -999, -1199, -1243,  -676,  -297,
-   -68,  -273,  -611,   137,  -146,  -397,  -627,  -845,  -220,
-  -112,  -346,  -797,  -826,   234,  -132,  -188,  -278,  -522,
-  -159,  -405,  -734,  -419,   293,    74,  -167,  -167,   184,
-  -153,  -437,  -833, -1080,  -336,  -472,  -561,  -340,  -253,
-  -169,  -423,  -820,  -904,  -131,   -19,  -346,  -604,    31,
-    33,   -31,   312,    62,  -148,    49,   -59,   564,   486,
-  -306,  -333,   194,   -44,    67,    72,   147,   205,   243,
-  -207,   -49,  1360,   983,   969,   991,  1014,  1110,   973,
-  -211,  -172,   883,   627,   711,   674,   705,   798,   746,
-   -88,  -325,  -763,  -974,   687,   908,   514,   382,   172,
-  -292,  -612,  -805,    63,   131,   270,   259,   352,   348,
-  -235,   -84,   955,   818,  1120,  1289,  1559,  1480,  1285,
-  -180,  -461,  -614,   657,   691,   745,   854,   783,   713,
-   -97,  -309,  -477,  -614,  -777,  -734,  -768,  -526,  -472,
-  -344,  -476,   -35,  -169,    49,   -77,  -150,  -240,  -141,
-   -52,  -268,  -639,  -919, -1278, -1113,  -342,  -333,  -151,
-   -68,  -242,  -585,   -73,  -209,  -478,  -159,  -429,   133,
-  -197,  -499, -1005, -1268,  -272,  -224,  -105,   -67,    17,
-  -363,  -618,  -414,  -116,   -62,    20,    10,   116,   108,
-  -195,  -475,  -906, -1260,  -891,  -441,  -277,  -142,   -28,
-  -226,  -519,  -950,  -700,  -275,  -266,  -116,  -105,    82,
-   404,   511,   520,   327,    17,  -194,  -333,  -536,  -586,
-  -114,  -130,   276,   237,   204,   342,   135,   -16,  -111,
-   670,  1208,  1168,   860,   742,   601,   528,   403,   309,
-   397,   621,   966,   752,   579,   398,   400,   329,   252,
-   191,   180,  -137,  -467,   272,   106,   -95,    17,  -192,
-   -80,  -290,  -626,   194,   598,   196,    21,  -281,    77,
-   510,   864,  1108,   807,   939,   902,   925,   717,   481,
-   137,   367,   534,   764,   670,   382,   296,   153,    84,
-   303,   497,   144,   -85,  -125,  -539,  -482,  -464,  -764,
-   233,   347,    68,  -147,   169,  -210,  -242,  -226,  -482,
-   307,   422,   154,  -175,  -386,  -722,  -724,  -904, -1015,
-   309,   308,   160,   -60,  -470,  -420,  -598,  -791,  -219,
-    68,   121,  -137,  -560,  -146,  -446,  -515,  -494,  -729,
-   130,    53,  -227,    46,   474,    32,  -161,  -192,  -490,
-   213,   164,   -71,  -465,  -876,  -161,  -456,  -587,   -48,
-   218,   117,    39,   177,  -194,   -88,  -226,  -418,    50,
-   210,   547,   569,   279,   121,   -44,   -50,    10,   -84,
-    58,   140,   182,    -5,   267,   117,   106,   211,   198,
-   539,   835,   913,   719,   617,   544,   591,   565,   642,
-   153,   559,   872,   460,   222,   108,   188,   180,   183,
-   158,   119,   284,  -153,  -271,   229,    87,   110,   -57,
-  -183,    82,   118,    21,    13,    40,   118,   191,   185,
-   162,   889,   654,   108,   -34,   244,   488,   561,   532,
-   163,    56,   609,   341,    50,   329,    68,   266,   218,
-   100,   206,    18,  -304,  -107,  -436,  -487,   -65,  -306,
-   -86,   154,   134,   -30,   -45,   -73,  -104,   -80,   -96,
-   245,   330,    10,  -440,  -849, -1082,    79,    40,  -265,
-   196,   372,   272,  -181,  -493,  -389,   275,    80,   -59,
-     2,   -12,  -246,  -505,  -100,  -436,    21,  -187,  -431,
-  -221,   -48,    36,  -271,  -186,  -147,  -109,    26,    71,
-   213,   140,    72,  -351,  -620,   -84,  -363,    69,    46,
-    91,   167,    -3,   -95,   -99,  -105,   -48,   114,   147,
-   259,   249,   172,   607,   406,    52,    59,  -189,  -320,
-   115,   -85,   -54,   574,   128,   226,   -59,  -253,   130,
-   -62,  1033,  1308,  1035,  1127,  1098,  1029,   961,   823,
-    39,   364,   757,   940,   728,   660,   659,   583,   770,
-  -115,  -338,  -760,  -471,   394,    37,   441,   178,     6,
-   -57,  -305,  -525,   796,   453,   188,    -4,  -114,   248,
-    71,   444,   797,   731,  1096,  1157,  1222,  1029,   811,
-   135,   359,   551,   425,   749,   815,   874,   704,   502,
-   132,   247,     0,  -206,  -449,  -750,  -258,  -514,  -633,
-   248,   249,    91,   121,  -195,  -499,   -90,  -282,  -435,
-    78,    20,  -277,  -623,  -983, -1224,  -415,  -458,  -639,
-   347,   509,   208,  -179,  -464,  -728,   -76,  -237,  -486,
-  -103,  -343,  -756,  -713,  -265,  -609,  -191,  -398,  -636,
-  -121,  -383,  -749,   567,   252,   -36,  -354,  -417,   -50,
-   204,   100,  -149,  -650, -1081,   -47,    -7,  -263,   111,
-   -46,  -180,  -267,  -324,  -562,  -394,  -692,   398,   292,
-   482,   670,   683,   624,   442,   165,   116,    36,  -149,
-   108,   247,   291,   247,   355,   122,   109,   224,   296,
-   -14,   945,   990,   801,   755,   815,   847,   913,   892,
-   292,   349,   725,   482,   388,   329,   429,   620,   667,
-   -34,   197,   213,  -127,    84,   494,   620,   575,   375,
-   126,   207,   172,   167,   362,   202,   296,   395,   455,
-    -6,   250,   539,   467,   636,   801,  1149,  1287,  1118,
-    27,   240,   369,   280,   440,   411,   634,   892,   953,
-   159,   170,   -58,  -395,  -797,  -690,    77,  -211,  -334,
-    -5,   -28,   -13,   -74,  -335,  -603,   300,    88,  -205,
-    82,   -33,  -364,  -698, -1203, -1153,   110,  -146,  -289,
-   113,     1,  -243,  -588,  -994,  -496,   414,   160,    42,
-   -56,  -247,  -440,  -693,  -996,  -479,    11,  -178,  -357,
-  -151,  -353,  -327,  -211,  -340,   141,    65,   425,   453,
-    34,  -169,  -455,  -932, -1215,   138,   499,   256,   324,
-    68,   139,   -15,  -547,  -478,    17,   306,   502,   481,
-   -32,  -134,   445,   129,  -143,  -244,  -503,  -507,  -599,
-    61,  -140,  -345,   496,   458,    -2,    20,  -227,  -514,
-   394,  1765,  1666,  1339,  1117,   806,   642,   479,   380,
-   215,   519,   920,  1053,  1090,   791,   528,   290,   155,
-   -54,  -233,  -647,  -602,   639,   294,    -2,  -167,  -442,
-   -78,  -315,  -791,  -113,   820,   403,   158,  -116,  -356,
-   529,  1851,  2003,  1228,   622,   -41,  -416,   344,   819,
-  -105,  -379,  -236,  1224,   893,   749,   568,   356,   214,
-   -17,  -199,  -144,    50,  -283,  -247,  -578,  -846, -1087,
-    69,   -11,  -381,  -206,   209,  -284,  -387,  -416,  -716,
-    39,    -5,  -145,  -374,  -682,  -909, -1074, -1169, -1066,
-   287,   226,    67,  -221,  -662,  -171,  -421,  -642,  -707,
-  -132,  -348,  -538,  -448,   -20,    -4,  -354,  -748,  -933,
-     4,   -75,  -289,  -598,   317,    52,  -208,  -297,  -559,
-   -88,  -264,  -358,  -589,  -631,  -248,  -523,  -822, -1071,
-    70,    -8,    54,  -314,  -515,    92,  -146,  -274,  -493,
-   199,    62,   391,   158,  -141,    71,  -219,  -203,  -207,
-   152,    40,   329,   162,   -29,    48,  -149,   108,   127,
-   635,  1058,   883,   492,   372,   312,   317,   274,   241,
-   267,   722,  1256,   882,   625,   248,     8,   -81,   -60,
-   -58,  -138,  -291,  -600,   -12,    -2,   -39,   147,   117,
-  -107,  -345,  -513,   459,    76,    92,  -272,   388,   262,
-   362,   516,   203,  -409,  -716,  -831,  -331,   185,   209,
-  -117,  -391,  -298,   671,   292,   538,   257,   166,   -38,
-  -102,  -319,  -194,  -283,  -573,  -262,  -579,  -219,  -444,
-  -235,    78,    11,  -168,  -101,  -229,  -263,  -321,  -123,
-    70,    50,  -170,  -599,  -996,  -588,  -263,  -516,  -455,
-   394,   363,   229,  -136,  -538,    21,  -183,  -348,  -201,
-  -124,  -368,  -640,  -879,  -847,  -209,  -409,  -494,  -515,
-  -127,  -341,  -541,  -425,  -510,   -10,  -252,  -473,  -291,
-    84,   -69,  -201,  -676,  -868,   103,  -311,  -132,  -320,
-     5,  -173,  -188,  -297,  -628,   197,   -57,     7,   -11,
-    49,  -160,    56,   558,   111,    33,  -311,  -440,  -463,
-    -1,  -246,  -307,   862,   453,   139,  -170,  -355,  -232,
-   279,   966,  1642,  1478,  1463,  1123,   795,   525,   339,
-  -197,   -38,  1702,  1331,  1252,   950,   692,   504,   426,
-  -108,  -344,  -861, -1172,   444,   354,    88,   -46,  -220,
-   -53,  -321,  -494,  1113,   744,   364,   198,   -34,   -75,
-   457,   955,  1177,  1214,  1427,  1457,  1345,   917,   539,
-   -69,   199,   897,  1140,  1343,  1183,   977,   742,   522,
-   122,    44,  -269,    27,  -155,  -562,  -307,  -590,  -773,
-   154,    42,  -160,   252,  -129,  -305,  -471,  -733,  -371,
-   135,   185,   -82,  -416,  -722,  -913,  -504,  -743,  -880,
-   149,   214,   -84,  -329,  -680,  -835,  -426,  -661,   -81,
-  -128,  -380,  -735,  -998,  -337,    17,  -182,  -467,  -697,
-   -84,  -290,  -510,  -592,    13,   440,   154,   -38,  -279,
-    70,   -61,  -246,  -727, -1047,   -80,  -381,  -535,  -704,
-   178,    -2,  -146,  -670,  -938,   482,   138,    63,    65,
-   -11,    15,   772,   443,   142,   -20,  -209,  -126,  -161,
-   -32,  -249,    95,   552,   124,    30,  -343,    82,   -86,
-   148,   751,  1515,  1105,   867,   606,   474,   448,   399,
-  -163,  -257,   899,  1097,   906,   751,   502,   390,   294,
-   -51,  -258,  -447,  -806,  -368,   763,   464,   364,   183,
-  -166,  -374,  -367,    87,    35,   399,   418,   856,   833,
-  -205,  -310,   588,   778,   785,  1065,  1118,  1245,  1157,
-  -173,  -312,   107,   345,   400,   790,   870,  1113,  1001,
-    -7,  -120,  -387,  -410,  -614,  -943,  -226,  -384,  -491,
-  -203,  -288,   -51,  -331,   -90,  -178,  -408,  -573,  -338,
-    56,   -29,  -273,  -627, -1041,  -798,  -247,  -467,   148,
-    66,    -2,  -205,  -205,  -575,  -349,   -57,  -352,   -58,
-   -45,  -225,  -471,  -924,  -497,    77,   -32,    44,  -135,
-  -277,  -491,  -497,  -502,  -424,  -202,  -137,    77,    96,
-    26,  -179,  -469, -1008, -1260,   262,   -35,  -132,  -259,
-   -66,  -232,  -447,  -533,  -789,  -191,  -100,  -267,   364};
-
-/*------------------------------------------------*
- * 1st stage codebook; 2nd split:   isf9 to isf15
- *------------------------------------------------*/
-
-static Word16 dico2_isf[SIZE_BK2*7] = {
-
-  1357,  1313,  1136,   784,   438,   181,   145,
-   636,   648,   667,   568,   442,   217,   362,
-   427,   440,   674,   524,   332,   117,  -417,
-   121,   295,   468,   465,   230,    44,  -221,
-  -147,  -240,   149,    80,   390,   278,   106,
-  -418,  -556,   552,   511,   235,   144,   -95,
-    43,   193,   274,   150,    67,    34,  -273,
-   -43,  -126,   171,   416,   282,    63,  -354,
-  -372,   -86,  -344,  -108,   -94,  -182,   -89,
-  -600,  -840,  -200,   465,   258,   -11,  -253,
-   -48,   329,    97,  -290,  -543,  -795,  -354,
-  -570,  -117,   187,    10,  -133,  -416,   -76,
-  -618,  -129,  -247,  -371,    45,   -76,   277,
- -1022, -1079,   126,   474,   254,   127,    52,
-  -281,    76,  -167,  -361,  -283,  -551,  -283,
-  -119,   -52,    -1,   134,   -32,  -204,  -415,
-  1064,   827,   637,   684,   464,   209,    12,
-   482,   416,   449,   371,   335,   294,   194,
-   719,   576,   365,   135,   113,    91,  -199,
-   298,   176,   493,   366,   194,   163,    36,
-   -35,  -236,  -259,   -36,    -4,    99,   152,
-   -98,  -306,   -27,   228,    90,   111,   -86,
-    91,    13,  -211,  -258,  -106,    86,   -64,
-    73,   -35,   -57,   -31,   162,    35,  -192,
-  -109,  -335,  -629,   -66,   -61,  -128,   322,
-  -495,  -669,  -728,   193,    31,  -220,   122,
-   324,    95,   -89,   -91,  -409,  -710,  -154,
-     0,  -234,    92,    33,  -343,  -609,  -220,
-  -343,  -408,  -476,  -655,  -153,    82,   222,
-  -490,  -745,  -255,    49,   -48,   135,  -127,
-   119,   -67,  -328,  -390,  -272,  -545,   -56,
-   -57,  -130,   -10,    -7,  -164,   -47,   -22,
-   984,  1064,   961,   568,   210,   -27,    16,
-   811,   691,   754,   514,   224,   -35,   166,
-   662,   704,   618,   386,    57,  -211,  -257,
-   510,   359,   418,   393,    91,  -144,   -18,
-  -193,   -31,   -27,   223,    89,  -143,    24,
-  -112,   -98,   471,   319,   185,     3,   175,
-   252,   146,   -47,   272,    48,  -211,  -234,
-   146,    69,   203,   364,    68,   -52,    51,
-  -259,  -478,  -697,  -349,  -758,  -501,    63,
-  -501,  -769,  -289,    79,  -311,  -497,  -106,
-   251,    53,  -235,  -469,  -895,  -884,   145,
-  -416,  -551,   140,  -133,  -523,  -775,    44,
-  -326,  -423,  -713,  -497,   -86,  -431,    99,
-  -757,  -772,  -160,   -76,   -46,   -32,   379,
-    85,   -35,  -200,  -401,  -663, -1040,  -247,
-  -180,  -330,   -92,  -376,    27,  -183,  -110,
-  1279,  1086,   781,   502,   324,   164,   157,
-   682,   466,   449,   277,   146,    28,   409,
-   635,   472,   390,   107,  -232,  -538,  -139,
-   196,   396,   332,   213,   209,   -29,   -81,
-   150,   -95,  -312,    76,   -77,  -320,   -50,
-    46,     9,    47,   175,   139,    30,   384,
-   218,   206,   -24,  -250,   -96,  -276,  -183,
-    26,   119,    38,    14,    -4,  -133,   -52,
-  -477,  -614,  -987,  -715,  -631,  -813,   200,
-  -744, -1009, -1065,  -745,  -631,  -171,    18,
-  -137,  -251,  -483,  -613,  -980, -1203,    12,
-  -605,  -767,  -562,  -686, -1088,  -515,    58,
-  -202,  -428,  -782, -1072,   -96,  -234,  -179,
-  -480,  -709, -1070,  -897,  -131,   -92,   321,
-  -145,  -193,  -512,  -729,  -572,  -765,  -210,
-  -331,  -585,  -525,  -631,  -281,  -208,  -303,
-  1165,  1104,   939,   828,   716,   426,   155,
-     6,  -109,   820,   778,   415,   113,   -27,
-   381,   339,   314,   265,   121,    -9,  -474,
-  -373,    47,   584,   442,    99,  -231,  -113,
-  -496,   -38,  -285,   262,   305,   170,     4,
-  -587,  -556,    69,    66,   471,   354,    13,
-  -138,    70,   -18,   106,    67,   167,  -302,
-  -445,  -141,   185,   191,   151,    83,  -133,
-  -257,  -521,  -720,  -198,   134,   -46,  -182,
-  -819, -1168,  -777,   512,   359,    95,  -113,
-   137,    -2,   -74,  -138,  -401,  -114,  -371,
-  -242,  -466,   204,   223,   -31,  -212,  -192,
-  -532,  -637,  -466,  -686,   256,   277,  -139,
- -1141, -1244,  -381,   -75,   -54,    14,    88,
-  -311,   115,  -143,  -499,  -343,   124,  -416,
-  -616,  -147,  -135,    43,    -4,   121,  -369,
-   835,   783,   641,   390,   355,   350,    64,
-    72,   194,   443,   467,   436,   219,   372,
-   464,   369,   192,     4,  -156,   -72,  -226,
-    57,   206,   303,   205,   188,   101,   265,
-   -40,  -205,  -488,  -184,   276,    64,   -26,
-  -217,  -433,  -297,   137,   328,   308,  -289,
-   378,    81,  -308,  -465,    57,   -37,   227,
-  -100,    24,   -36,  -151,   199,     8,   143,
-  -426,  -697, -1059,  -133,   388,   161,   321,
-  -644, -1023, -1271,    39,    66,  -123,    70,
-   372,   177,  -173,  -556,  -553,  -304,  -189,
-  -117,  -369,  -425,  -122,  -462,  -152,   -73,
-  -649,  -850, -1189,  -767,   497,   360,   222,
-  -798, -1139, -1455,  -190,   430,   234,   179,
-    42,   -94,  -405,  -692,    38,  -202,  -246,
-  -169,  -366,  -290,   -88,   -64,    32,  -292,
-  1010,   923,   938,   710,   465,   230,   342,
-   217,   300,  1054,   675,    68,  -458,  -179,
-    78,   453,   316,    18,  -237,  -496,  -243,
-   167,    21,   424,   215,   -91,  -303,  -170,
-  -290,   -81,   -70,   -67,    40,    54,   -59,
-  -353,  -427,   -90,    53,    94,     9,    54,
-   -28,   318,   283,    15,  -240,   -58,    79,
-   -75,  -121,   229,    35,    58,     6,  -133,
-  -351,  -514,  -744,  -834,  -705,  -137,   164,
- -1124, -1388, -1055,  -230,   -73,    40,    36,
-  -163,  -233,  -532,  -785, -1170,  -697,    96,
-  -788,  -959,  -246,  -430,  -624,  -165,    -8,
-  -856,  -540,  -630,  -907,  -337,   -70,    76,
-  -937, -1042,  -659,  -733,  -208,   199,   -26,
-  -523,    78,   -98,  -501,  -869,  -890,   -81,
-  -624,  -703,   -45,  -348,   -25,    87,  -186,
-  1005,   823,   546,   249,    90,   -22,   207,
-   298,   397,   381,   319,   200,    62,   303,
-   473,   379,   133,  -247,  -632,  -441,    75,
-   284,   208,   391,   115,   -25,    44,    95,
-   -72,    79,   -95,   -63,  -129,  -293,   203,
-  -164,  -349,   115,   122,    69,    -1,   378,
-   348,   170,    99,    58,  -179,  -302,   188,
-  -190,    -2,   150,    23,   -51,   -11,   216,
-  -615,  -863, -1090, -1427,  -802,   -48,    -6,
-  -961, -1276, -1548,  -727,   -58,    56,   223,
-  -124,  -255,  -561,  -988, -1277,  -148,   -82,
-  -480,  -660,  -891, -1191, -1339,  -325,    20,
-  -621,  -917, -1296, -1350,   264,   289,    50,
-  -844, -1022, -1345, -1329,  -293,    46,   278,
-  -260,  -468,  -829, -1176,  -533,  -560,   -78,
-  -215,  -484,  -822, -1233,  -791,    15,  -138,
-  1301,  1317,  1262,  1048,   716,   357,   -64,
-   578,   824,   925,   802,   630,   362,   102,
-   470,   925,   767,   514,   327,   190,  -112,
-   225,   492,   495,   437,   598,   384,   -45,
-    43,    82,   -42,   175,   519,   342,   -64,
-  -304,  -154,   159,   576,   403,   221,   327,
-   214,   244,   122,   -62,   312,    92,  -160,
-   218,   208,   310,   268,   306,   323,  -199,
-  -285,  -269,   -79,  -124,  -143,  -153,   236,
-  -205,  -384,  -426,   344,    59,  -185,  -184,
-  -272,   247,   126,  -210,  -518,  -468,    78,
-   -99,  -120,   502,   160,  -280,  -557,   304,
-  -423,   -17,  -283,  -443,   215,   212,  -140,
-  -564,  -684,  -228,   510,   361,   130,   323,
-  -428,   335,    98,   -65,    36,  -215,  -246,
-  -362,    51,   364,   -16,  -234,   150,  -165,
-   914,   883,   751,   653,   676,   464,  -153,
-   631,   545,   535,   720,   596,   360,   -81,
-   783,   712,   512,   439,   341,   251,  -391,
-   497,   417,   249,   372,   295,   173,  -193,
-   128,  -110,  -385,    93,    39,   173,  -231,
-   216,   -59,  -253,   462,   389,   154,    69,
-   455,   270,    -4,  -337,   -49,   233,  -322,
-   307,   143,    53,   218,   128,   236,  -156,
-   -37,  -186,  -240,  -411,  -110,     9,   399,
-  -140,  -365,  -628,   258,   380,   214,   277,
-   131,   454,   177,  -285,  -520,   108,  -214,
-    77,  -141,   201,  -123,  -490,  -131,    60,
-   -14,  -194,  -521,  -741,   273,   362,   -33,
-  -362,  -566,  -287,  -228,   161,   237,   317,
-  -269,   195,   -75,  -375,  -204,    11,    77,
-  -128,  -264,  -156,  -223,  -475,   265,    27,
-  1238,  1147,   916,   689,   432,   210,  -280,
-   800,   664,   879,   726,   411,   160,  -164,
-   454,   686,   536,   275,   147,    46,   111,
-   303,   486,   512,   355,   241,   181,   -69,
-    79,    92,    29,   147,   233,    52,    17,
-  -171,   289,   131,   439,   271,     3,   -10,
-   413,   241,   144,   174,   155,    -2,    14,
-    58,   217,   247,   219,   149,   175,   -18,
-   228,    -8,  -240,  -206,  -513,  -191,   202,
-   -96,  -272,  -454,    33,  -300,  -575,    46,
-   -10,  -108,  -246,  -347,  -770,  -535,     9,
-  -326,  -430,   -61,  -321,  -704,  -299,   201,
-    -1,  -280,  -603,  -419,  -185,    18,   -36,
-  -516,  -522,  -379,  -291,  -181,   -97,    27,
-  -159,  -313,  -525,  -224,  -510,  -831,  -197,
-  -292,  -459,   -59,  -310,  -562,  -143,  -351,
-  1066,   912,   631,   389,   207,    86,  -224,
-   596,   512,   596,   505,   314,   122,   -48,
-   787,   861,   441,   -93,  -303,    33,  -190,
-   257,   469,   337,    51,    15,   298,   -93,
-   295,    73,  -119,    25,    36,    23,   108,
-   -28,    -3,   -32,   114,    21,   185,   107,
-   482,   305,    15,  -279,  -319,    52,    96,
-   226,    46,   115,    72,  -136,   133,  -125,
-    18,  -207,  -559,  -590,  -503,  -482,   321,
-  -571,  -789,  -951,  -172,  -441,  -538,   113,
-   181,    14,  -310,  -641, -1001,  -202,   159,
-  -136,  -393,  -433,  -513,  -911,  -144,   -22,
-    72,  -265,  -706,  -954,  -159,    53,   332,
-  -338,  -591,  -852,  -383,  -395,    56,    44,
-    43,  -158,  -464,  -897,  -631,  -157,  -294,
-  -161,  -128,  -328,  -573,  -483,  -125,    11,
-  1017,   906,  1051,  1005,   679,   341,  -102,
-   359,   334,  1567,  1314,   723,   105,    10,
-   -65,   726,   529,   301,   220,    43,  -273,
-  -510,   436,   719,   566,   358,   179,   114,
-  -560,   298,   133,  -120,   342,   225,    14,
-  -899,  -101,   217,   617,   400,   146,   -58,
-   -41,   352,    82,  -196,    39,   121,  -167,
-  -212,    59,   447,   284,   423,   250,  -169,
-  -371,  -484,  -596,    30,   -41,   249,    22,
-  -372,  -650,  -794,   477,   445,   216,   -79,
-  -352,   275,    17,  -443,  -929,    92,    19,
-  -699,  -696,   431,   264,   -49,  -310,   182,
-  -978,  -217,  -430,  -400,   101,   261,    72,
-  -929,  -889,  -357,   -13,   463,   378,   236,
-  -826,    56,    30,  -299,  -360,  -128,   -51,
-  -878,  -299,  -111,    75,    65,    36,     3,
-   817,   368,   -25,   354,   697,   591,  -173,
-   309,   212,   222,   751,   484,   140,   -56,
-   593,   379,    70,    -8,   258,   180,   110,
-   165,   -46,   255,   297,   219,   273,   105,
-   160,   -70,  -358,  -181,   379,   330,   319,
-  -238,  -369,  -198,   740,   580,   319,  -143,
-   201,   109,  -202,  -456,   328,   276,  -141,
-   203,   170,   111,    42,   207,   360,   188,
-  -345,  -399,  -513,  -233,   650,   422,    81,
-  -635,  -961, -1220,   463,   539,   204,   209,
-   202,   -25,  -194,  -498,  -787,   193,  -143,
-  -449,  -538,   195,  -106,  -331,    68,    62,
-  -228,  -477,  -840,  -576,   317,   128,   283,
-  -671,  -937,  -807,  -114,   391,   335,   -62,
-   246,     2,  -314,  -679,  -303,   180,   -88,
-  -107,  -272,    90,  -198,   -28,   290,  -112,
-   885,  1149,  1021,   712,   496,   281,   -83,
-   269,   492,   787,   643,   347,    70,   124,
-   336,   636,   499,    92,  -229,  -179,   191,
-    26,   402,   564,   340,   149,   -11,   135,
-  -440,   561,   470,   204,   -72,  -186,   140,
-  -720,    14,   355,   229,    68,  -133,   465,
-   110,   310,   103,    12,   106,    29,   158,
-  -178,   113,   161,   142,   121,   115,    27,
-  -651,  -414,  -645,  -152,  -164,   -13,  -429,
-  -639,  -944,  -681,  -104,   -81,    52,  -189,
-  -663,  -164,  -316,  -683,  -954,  -205,   -83,
-  -609,  -669,  -172,  -517,  -694,   283,   -80,
-  -646,  -152,  -383,  -678,  -246,   -40,  -143,
-  -747,  -796,  -745,  -390,   -98,    43,   275,
-  -599,  -199,  -398,  -433,  -436,  -538,    31,
- -1107,  -568,  -376,  -265,  -126,   -21,     1,
-   847,   573,   308,   392,   305,   101,    55,
-   273,   293,   201,   267,   346,   201,   123,
-   727,   480,   226,     2,   -65,  -138,   164,
-   273,   208,   173,   292,    12,   253,   174,
-   340,   207,   180,    88,   116,    46,   475,
-  -460,  -166,   -30,    13,   110,   173,   396,
-   137,    88,    43,  -137,   -94,    34,   284,
-    96,   -14,   226,    40,    63,    70,   130,
-  -467,  -735, -1012, -1174,  -307,   305,   -67,
-  -612,  -920, -1146,  -567,    -8,    92,   -25,
-  -182,  -271,  -492,  -754,  -857,   287,   -75,
-  -494,  -787,  -689,  -683,  -709,   137,  -326,
-  -288,  -550,  -903, -1105,   334,   321,   -62,
-  -354,  -653,  -834,  -445,     1,   377,  -152,
-  -162,  -306,  -608,  -937,  -297,   247,  -192,
-  -234,  -477,  -244,  -488,  -266,   342,  -332};
-
-/*---------------------------------------------------*
- * 2nd stage codebook; 1st split:   isf2_0 to isf2_2
- *---------------------------------------------------*/
-
-
-static Word16 dico21_isf[SIZE_BK21*3] = {
-
-   329,   409,   249,
-   -33,   505,   160,
-   -29,   -14,   582,
-  -262,   127,   354,
-   145,   237,   175,
-  -152,   245,   122,
-    27,    42,   340,
-   -84,   -93,   311,
-   285,   222,  -156,
-    47,   -43,  -504,
-   234,   121,   385,
-   104,  -317,    45,
-   176,   195,     8,
-   104,   -59,   -94,
-   177,    53,   192,
-   -34,  -127,   152,
-   570,   277,   -34,
-   -67,  -329,  -639,
-  -157,  -272,   462,
-  -177,  -462,   198,
-   322,   179,   115,
-  -386,   171,    19,
-    19,   -12,   195,
-  -120,  -252,   201,
-   304,    36,  -336,
-  -128,  -221,  -380,
-   171,  -185,   296,
-  -242,  -312,    23,
-   198,    39,    16,
-    -3,  -177,  -111,
-   111,   -93,    76,
-   -92,  -223,     4,
-   177,   406,   -44,
-  -168,   380,  -149,
-    -4,   273,   331,
-  -420,   513,   277,
-    21,   247,    47,
-   -58,   131,    -2,
-    -3,   134,   180,
-  -145,    40,   175,
-   189,    74,  -145,
-   -27,   -45,  -325,
-   370,  -114,   -21,
-   -83,  -415,  -173,
-    77,    95,   -51,
-   -40,   -30,   -67,
-    71,    88,    86,
-   -35,   -98,    14,
-    69,   197,  -334,
-  -196,    79,  -231,
-  -348,  -137,   218,
-  -352,   -89,   -85,
-    47,   201,  -130,
-  -165,    37,   -15,
-   -43,     3,    86,
-  -161,  -108,    79,
-    83,    21,  -237,
-   -81,  -149,  -238,
-   150,  -186,  -251,
-  -186,  -249,  -162,
-   -19,    66,  -139,
-   -26,   -50,  -181,
-    24,    11,     0,
-  -130,  -105,   -98};
-
-
-
-/*---------------------------------------------------*
- * 2nd stage codebook; 2nd split:   isf2_3 to isf2_5
- *---------------------------------------------------*/
-
-
-static Word16 dico22_isf[SIZE_BK22*3] = {
-
-  -127,   310,    42,
-  -242,   197,     5,
-  -151,    84,   -17,
-  -214,   127,  -149,
-  -247,  -131,   159,
-  -268,  -267,   -95,
-  -217,     1,   -79,
-  -271,   -80,  -185,
-   -45,   436,   159,
-   165,   199,   391,
-   -33,    81,   187,
-   -66,   -42,   355,
-  -298,   -57,   343,
-  -108,  -537,   226,
-  -144,   -23,   193,
-   176,  -402,    87,
-    53,   296,    25,
-   -84,   253,  -104,
-   -58,   105,  -126,
-  -169,   174,  -314,
-   -48,    44,  -294,
-  -164,  -417,  -242,
-  -139,     3,  -194,
-  -155,  -207,  -211,
-   119,   322,   213,
-   333,    50,   380,
-   237,   247,    -2,
-   466,   -16,   201,
-   238,  -255,  -107,
-    67,  -440,  -149,
-   122,   -88,  -139,
-    88,  -247,   -73,
-   -41,   231,   167,
-   -62,   155,    16,
-   -65,    16,    77,
-   -68,    -2,   -63,
-  -151,  -300,   160,
-   -18,  -333,    54,
-   -56,   -94,     5,
-     2,  -190,    14,
-    92,   148,   209,
-   108,     9,   272,
-   108,    35,   110,
-   142,   -85,   145,
-    47,  -157,   279,
-     3,  -320,   246,
-    43,   -72,    68,
-    86,  -217,   135,
-    36,   140,    79,
-    56,   175,   -49,
-    26,    45,     3,
-    73,    55,  -101,
-   109,  -183,  -242,
-    -4,  -283,  -242,
-    48,   -68,   -48,
-    -6,  -153,  -122,
-   161,   196,    96,
-   232,    80,   190,
-   165,    97,    11,
-   258,   -31,    71,
-   267,   -77,   -91,
-   311,  -209,    87,
-   152,   -14,   -22,
-   150,  -149,     9,
-  -324,   557,   187,
-  -384,   307,    46,
-  -251,    27,    77,
-  -365,    77,   -52,
-  -482,   -84,   160,
-  -424,  -515,   -64,
-  -294,  -120,    -4,
-  -476,  -116,  -109,
-   -97,   318,   365,
-   106,   627,   445,
-  -190,   120,   287,
-  -146,    65,   619,
-  -427,   242,   363,
-  -361,  -371,   432,
-  -347,   102,   168,
-  -629,   195,   -14,
-   -65,   476,   -47,
-  -297,   320,  -168,
-   -55,   356,  -264,
-  -391,    82,  -286,
-   -51,   -31,  -556,
-  -178,  -399,  -586,
-  -205,   -49,  -360,
-  -343,  -238,  -337,
-   220,   457,    58,
-   561,   467,   259,
-   340,   270,  -168,
-   450,    77,  -280,
-    60,   167,  -413,
-   133,  -252,  -492,
-   216,   157,  -290,
-   282,     0,  -495,
-  -226,   293,   183,
-  -157,   135,   122,
-  -158,   -59,    39,
-  -133,  -118,   -97,
-  -332,  -309,   113,
-  -160,  -425,    -6,
-  -149,  -211,    24,
-   -80,  -277,   -90,
-   -11,   125,   338,
-   130,   -71,   465,
-     5,   -45,   184,
-   237,   -95,   253,
-  -139,  -197,   297,
-   -19,  -300,   511,
-   -63,  -152,   139,
-   250,  -289,   336,
-   124,   339,  -150,
-    34,   176,  -208,
-   171,   166,  -116,
-    94,    38,  -229,
-    75,   -65,  -339,
-   -78,  -205,  -385,
-     0,   -30,  -163,
-   -56,  -110,  -242,
-   321,   244,   194,
-   505,   238,    -1,
-   317,   116,    65,
-   309,    88,   -74,
-   452,   -51,   -50,
-   334,  -217,  -290,
-   211,    41,  -152,
-   238,   -55,  -260};
-
-
-/*---------------------------------------------------*
- * 2nd stage codebook; 3rd split:   isf2_6 to isf2_8
- *---------------------------------------------------*/
-
-
-static Word16 dico23_isf[SIZE_BK23*3] = {
-
-   -10,   151,   359,
-   136,   298,   223,
-   255,  -104,   290,
-   423,     6,   183,
-  -270,  -269,   -98,
-   -52,   -82,    13,
-   -82,  -274,   -97,
-    90,  -246,   -72,
-  -299,   -70,   421,
-   -88,   365,   430,
-   187,  -318,   381,
-   380,    37,   488,
-  -373,  -316,    79,
-  -308,  -101,     5,
-  -135,  -451,     8,
-    72,  -421,  -154,
-   180,   170,  -121,
-    62,   177,   -40,
-   326,    80,  -105,
-   248,   263,    -5,
-  -168,  -181,  -221,
-    -2,   -23,  -158,
-   -14,  -149,  -121,
-   119,   -91,  -147,
-   119,   332,  -153,
-    49,   303,    34,
-   442,   -55,   -69,
-   217,   454,    58,
-  -359,  -187,  -375,
-   -42,    50,  -274,
-    -8,  -267,  -249,
-    85,   -86,  -346,
-   -77,   -40,   345,
-    89,   134,   219,
-   156,   -80,   160,
-   108,    40,   116,
-  -158,  -206,    29,
-     5,   -32,   175,
-   -65,  -158,   146,
-    55,   -78,    73,
-  -114,  -222,   353,
-   -47,    81,   211,
-    49,  -151,   268,
-   105,     4,   302,
-  -263,  -132,   183,
-  -151,   -28,   201,
-  -177,  -307,   166,
-   101,  -221,   130,
-    74,    58,   -98,
-    32,    44,    13,
-   194,    30,  -142,
-   170,    96,     8,
-  -136,  -119,   -91,
-   -65,     8,   -55,
-     3,  -188,    12,
-    45,   -63,   -49,
-   149,   -21,   -19,
-    24,   144,    95,
-   254,   -22,    60,
-   161,   196,    96,
-  -158,   -61,    48,
-   -70,    33,    82,
-   -23,  -321,    58,
-   155,  -147,     5,
-  -364,   328,    77,
-   -21,   453,   173,
-  -108,    82,   630,
-   367,   263,   208,
-  -300,   -62,  -176,
-  -205,   143,  -158,
-  -169,  -410,  -264,
-   257,  -269,  -100,
-  -636,   289,    -2,
-  -292,   627,   173,
-  -382,  -363,   387,
-   248,   524,   447,
-  -521,  -111,  -107,
-  -395,   118,  -274,
-  -343,  -680,  -125,
-  -172,  -447,  -663,
-    75,   148,  -367,
-   -79,   263,   -94,
-   249,   148,  -286,
-   380,   271,  -162,
-  -142,    -4,  -186,
-   -57,   111,  -125,
-   -35,  -108,  -254,
-   100,    29,  -242,
-   -80,   303,  -264,
-   -78,   464,   -57,
-   248,   -22,  -494,
-   661,   662,    44,
-  -193,   -40,  -330,
-  -178,   145,  -337,
-   -90,  -199,  -400,
-   -40,   -23,  -498,
-  -192,   114,   315,
-   -41,   244,   190,
-    88,   -97,   485,
-   241,    80,   212,
-  -246,    40,    87,
-  -156,   147,   134,
-    -2,  -334,   239,
-   308,  -203,   110,
-  -459,   251,   422,
-  -218,   310,   228,
-   -86,  -346,   654,
-   184,   175,   425,
-  -481,   -63,   169,
-  -349,   117,   188,
-  -125,  -560,   310,
-   158,  -416,    94,
-    46,   171,  -192,
-   -63,   157,    14,
-   256,   -35,  -271,
-   322,   123,    53,
-  -214,     4,   -76,
-  -156,    86,   -18,
-   128,  -197,  -232,
-   265,   -90,   -98,
-  -308,   332,  -145,
-  -131,   308,    58,
-   509,    59,  -339,
-   562,   196,   -14,
-  -378,   100,   -47,
-  -234,   202,     1,
-   104,  -270,  -493,
-   319,  -210,  -325};
-
-
-/*---------------------------------------------------*
- * 2nd stage codebook; 4th split:   isf2_9 to isf2_11
- *---------------------------------------------------*/
-
-static Word16 dico24_isf[SIZE_BK24*3] = {
-
-   -79,   -89,    -4,
-  -171,    77,  -211,
-   160,  -193,    98,
-   120,  -103,   323,
-    32,   -22,  -129,
-    72,    78,  -268,
-   182,   -76,   -66,
-   309,    99,  -145,
-  -229,  -157,   -84,
-  -383,    98,   -71,
-   -90,  -352,    12,
-  -284,  -178,   178,
-   -65,  -125,  -166,
-   -87,  -175,  -351,
-    42,  -198,   -48,
-   154,  -140,  -243,
-   -77,    18,   108,
-   -39,   355,    91,
-    87,     8,   155,
-    -4,   158,   239,
-   128,    95,   -54,
-     7,   246,  -124,
-   258,    15,    89,
-   206,   216,    98,
-  -201,     9,    18,
-  -312,   233,   204,
-   -39,  -174,   155,
-  -144,    -9,   284,
-   -57,    70,   -69,
-  -157,   187,    18,
-    54,   -30,    23,
-    24,   135,    55};
-
-
-/*---------------------------------------------------*
- * 2nd stage codebook; 5th split:   isf2_12 to isf2_15
- *---------------------------------------------------*/
-
-static Word16 dico25_isf[SIZE_BK25*4] = {
-
-   169,   142,  -119,   115,
-   206,   -20,    94,   226,
-  -106,   313,   -21,    16,
-   -62,   161,    71,   255,
-   -89,   101,  -185,   125,
-    72,   -30,  -201,   344,
-  -258,    33,    -8,    81,
-  -104,  -154,    72,   296,
-   144,   -68,  -268,   -25,
-    81,   -78,   -87,   106,
-    22,   155,  -186,  -119,
-   -46,   -28,    27,    91,
-  -114,   -37,  -175,   -33,
-   -94,  -222,  -189,   122,
-  -132,  -119,  -191,  -270,
-  -172,  -173,    18,   -43,
-   279,   135,   -42,  -128,
-   187,   -86,   229,  -138,
-   159,   240,   140,    46,
-    69,    25,   227,    77,
-    21,   115,    13,     8,
-    68,  -248,   126,    81,
-  -150,   137,   207,    -9,
-  -154,  -133,   289,    67,
-   143,   -37,   -86,  -326,
-   180,   -32,    19,   -23,
-    26,   168,   116,  -233,
-   -32,   -26,   118,   -78,
-     3,    -8,   -45,  -115,
-    57,  -215,   -54,   -83,
-  -209,   112,   -22,  -167,
-   -91,  -151,   168,  -262};
-
-
-
-       /* 36 bit */
-/*-------------------------------------------------------------------*
- *  isf codebooks:  two-stage VQ with split-by-3 in 2nd stage        *
- *                1st stage is kept the same as the 46 bit quantizer *
- *                                                                   *
- *  codebook   vector dimension    number of vectors                 *
- *  ~~~~~~~~   ~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~                 *
- *     1_1            9                  256                         *
- *     1_2            7                  256                         *
- *     2_1            5                  128                         *
- *     2_2            4                  128                         *
- *     2_3            7                  64                          *
- *-------------------------------------------------------------------*/
-
-static Word16 dico21_isf_36b[SIZE_BK21_36b*5] = {
-
-   -52,   -96,   212,   315,   -73,
-    82,  -204,   363,   136,  -197,
-  -126,  -331,   183,   218,   143,
-   -49,   -41,   557,   230,    72,
-     2,   -73,   163,   377,   221,
-   133,   111,   278,   215,  -110,
-  -102,   -20,   284,   113,   273,
-    84,   319,   290,    18,    85,
-   -25,    -5,   125,   132,  -204,
-   -38,    -5,   286,    -9,  -356,
-  -140,  -256,    92,   117,  -189,
-  -144,   191,   313,    51,   -98,
-   167,   -10,    44,   247,    36,
-   381,   197,   238,    74,     6,
-    38,  -408,    29,    -3,   -85,
-    92,   266,   157,   -25,  -200,
-   161,  -121,    70,    84,  -140,
-   -16,   -86,   112,   -94,  -189,
-  -269,  -270,   351,   107,   -24,
-   -68,   -67,   492,  -103,  -155,
-   -53,  -131,    62,   122,    10,
-   135,    84,   283,   -55,  -120,
-   -12,  -219,   331,   -81,   167,
-   220,  -136,   147,  -172,   -42,
-   140,   -95,  -109,   -88,  -194,
-     0,    -2,    -4,   -33,  -381,
-   -66,  -217,   152,  -186,  -402,
-   244,   108,   156,  -140,  -395,
-   113,  -136,  -196,   110,   -24,
-   214,   118,    11,   -64,  -131,
-  -110,  -286,    -6,  -332,    16,
-    94,    97,    79,  -291,  -205,
-    -5,   -39,   -20,   252,   -96,
-    76,   174,   101,   163,    61,
-   -69,  -239,   -55,   399,     6,
-  -115,   319,   164,   275,   196,
-   -15,    36,   -47,   331,   121,
-   226,   209,   271,   325,   184,
-    13,   -80,  -218,   471,   353,
-   288,   378,    16,   -51,   251,
-   174,   116,    52,   149,  -279,
-   235,   276,    39,   120,   -48,
-     0,  -108,  -108,   241,  -339,
-   -93,   534,    45,    33,   -87,
-   194,   149,   -71,   405,   -44,
-   409,   370,    81,  -186,  -154,
-    25,  -102,  -448,   124,  -173,
-    22,   408,  -110,  -310,  -214,
-   -26,    23,   -83,   114,    14,
-  -110,   164,    52,   223,   -82,
-    37,   -25,  -263,   306,   -15,
-  -466,   415,   292,   165,   -18,
-    29,   -19,  -171,   155,   182,
-   179,   144,   -27,   231,   258,
-  -103,  -247,  -396,   238,   113,
-   375,  -154,  -109,    -4,   156,
-    98,    85,  -292,    -5,  -124,
-   116,   139,  -116,   -98,  -294,
-   -14,   -83,  -278,  -117,  -378,
-   106,    33,  -106,  -344,  -484,
-   119,    17,  -412,   138,   166,
-   384,   101,  -204,    88,  -156,
-  -121,  -284,  -300,    -1,  -166,
-   280,    33,  -152,  -313,   -81,
-   -37,    22,   229,   153,    37,
-   -60,   -83,   236,    -8,   -41,
-  -169,  -228,   126,   -20,   363,
-  -235,    17,   364,  -156,   156,
-   -25,   -30,    72,   144,   156,
-   153,   -26,   256,    97,   144,
-   -21,   -37,    48,   -65,   250,
-    63,    77,   273,  -128,   124,
-  -129,   -26,    40,     9,  -115,
-    -6,    82,    38,   -90,  -182,
-  -336,   -13,    28,   158,    91,
-   -30,   241,   137,  -170,   -17,
-   146,    14,   -11,    33,    61,
-   192,   197,    54,   -84,    85,
-    23,  -200,   -78,   -29,   140,
-   122,   237,   106,  -341,   136,
-   -57,  -142,   -85,   -16,   -74,
-   -59,   -90,    -8,  -187,   -20,
-  -211,  -267,   216,  -179,  -110,
-   -50,    -7,   220,  -267,   -70,
-   -57,   -42,   -17,   -15,    71,
-    32,    21,    63,  -137,    33,
-  -137,  -175,   104,   -68,    97,
-   -67,   -43,   133,  -301,   221,
-  -116,  -200,   -81,   -92,  -272,
-   -64,   -41,   -54,  -244,  -220,
-  -287,  -242,   -50,   -87,   -89,
-  -245,   236,   102,  -166,  -295,
-    66,    24,  -162,   -71,    95,
-    66,   136,   -90,  -220,   -36,
-   -98,  -161,  -222,  -188,    29,
-   -18,    18,   -19,  -415,     9,
-    49,    61,   100,    39,   -56,
-  -111,    82,   135,   -31,    52,
-   -90,  -153,   -93,   189,   182,
-  -214,   295,   119,   -74,   284,
-     2,   137,    37,    47,   182,
-    92,   117,   184,   -53,   373,
-   -21,   -14,   -35,   136,   391,
-   146,   129,  -164,   -28,   333,
-    92,    80,   -84,   100,  -134,
-    -8,   217,   -32,     3,   -47,
-  -151,   251,  -215,   142,    92,
-  -224,   310,  -172,  -275,    98,
-   159,   155,  -177,   112,    53,
-   205,    27,     8,  -240,   192,
-   169,   120,  -319,  -201,   106,
-    11,    36,   -86,  -237,   455,
-  -109,  -154,  -163,   174,   -55,
-   -38,    32,  -101,   -78,   -59,
-  -205,  -321,   -97,    69,    79,
-  -310,    44,    18,  -185,    34,
-  -115,   -20,  -148,   -39,   203,
-   -29,   154,   -30,  -158,   166,
-   -45,  -131,  -317,   -24,   363,
-  -165,  -205,  -112,  -222,   265,
-   -32,   -44,  -150,    54,  -193,
-    -6,   -38,  -255,  -169,  -115,
-  -266,    87,  -189,   -36,  -169,
-   -60,   -87,  -266,  -436,  -170,
-   -68,   -81,  -278,    24,    38,
-   -23,   -19,  -155,  -256,   141,
-   -61,  -226,  -565,  -175,    71,
-     9,   -29,  -237,  -515,   263};
-
-static Word16 dico22_isf_36b[SIZE_BK22_36b*4] = {
-
-  -298,    -6,    95,    31,
-  -213,   -87,  -122,   261,
-     4,   -49,   208,    14,
-  -129,  -110,    30,   118,
-  -214,   258,   110,  -235,
-   -41,   -18,  -126,   120,
-   103,    65,   127,   -37,
-   126,   -36,   -24,    25,
-  -138,   -67,  -278,  -186,
-  -164,  -194,  -201,    78,
-  -211,   -87,   -51,  -221,
-  -174,   -79,   -94,   -39,
-    23,    -6,  -157,  -240,
-    22,  -110,  -153,   -68,
-   148,    -5,    -2,  -149,
-    -1,  -135,   -39,  -179,
-    68,   360,  -117,   -15,
-   137,    47,  -278,   146,
-   136,   260,   135,    65,
-    61,   116,   -45,    97,
-   231,   379,    87,  -120,
-   338,   177,  -272,     3,
-   266,   156,    28,   -69,
-   260,    84,   -85,    86,
-  -266,   154,  -256,  -182,
-   -17,   -65,  -304,    -6,
-   -40,   175,  -151,  -180,
-   -27,    27,   -87,   -63,
-   121,   114,  -166,  -469,
-   159,   -66,  -323,  -231,
-   214,   152,  -141,  -212,
-   137,    36,  -184,   -51,
-  -282,  -237,    40,    10,
-   -48,  -235,   -37,   251,
-   -54,  -323,   136,    29,
-   -88,  -174,   213,   198,
-  -390,    99,   -63,  -375,
-   107,  -169,  -164,   424,
-    69,  -111,   141,  -167,
-    74,  -129,    65,   144,
-  -353,  -207,  -205,  -109,
-  -160,  -386,  -355,    98,
-  -176,  -493,   -20,  -143,
-  -252,  -432,    -2,   216,
-   -90,  -174,  -168,  -411,
-    13,  -284,  -229,  -160,
-   -87,  -279,    34,  -251,
-   -75,  -263,   -58,   -42,
-   420,    53,  -211,  -358,
-   384,   -35,  -374,   396,
-    68,  -228,   323,    -2,
-   167,  -307,   192,   194,
-   459,   329,    -5,  -332,
-   375,    79,    -7,   313,
-   282,  -124,   200,   -92,
-   271,  -162,   -70,   180,
-  -157,  -298,  -514,  -309,
-    58,  -163,  -546,    18,
-   124,  -364,   167,  -238,
-    83,  -411,  -117,    96,
-   140,  -112,  -388,  -624,
-   259,  -133,  -317,    41,
-   163,  -130,   -64,  -334,
-   226,  -165,  -124,  -110,
-  -466,   -61,     6,   229,
-  -153,   205,  -145,   242,
-  -159,    48,   195,   148,
-   -58,    28,    31,   279,
-  -303,   185,   279,    -4,
-   -61,   197,    59,    86,
-  -114,   123,   168,   -52,
-    35,    36,   100,   126,
-  -407,   102,   -77,   -40,
-  -338,    -1,  -342,   156,
-  -179,   105,   -34,   -97,
-  -185,    84,   -35,   108,
-  -133,   107,   -91,  -357,
-  -180,    54,  -229,    24,
-   -44,    47,    47,  -182,
-   -66,    13,    45,     4,
-  -339,   251,    64,   226,
-   -42,   101,  -350,   275,
-   -99,   398,   142,   121,
-   111,    12,  -102,   260,
-     0,   505,   260,   -94,
-   161,   285,   -96,   224,
-    -4,   206,   314,    33,
-   167,   139,    88,   204,
-  -235,   316,   -60,   -25,
-    -8,  -150,  -312,   201,
-   -36,   292,    61,  -104,
-   -40,   174,  -162,    42,
-   -21,   402,   -29,  -351,
-    21,   152,  -360,   -93,
-    57,   191,   212,  -196,
-    76,   158,   -21,   -69,
-  -328,  -185,   331,   119,
-   -53,   285,    56,   337,
-  -107,   -24,   405,    29,
-   -18,   137,   272,   277,
-  -255,    22,   173,  -191,
-   295,   322,   325,   302,
-    21,   -27,   332,  -178,
-   119,    13,   271,   129,
-  -455,  -180,   116,  -191,
-  -227,    62,  -148,   524,
-  -176,  -287,   282,  -157,
-  -243,    13,   199,   430,
-   -59,   -49,   115,  -365,
-    72,  -172,  -137,    93,
-  -138,  -126,   141,   -84,
-     5,  -124,    38,   -20,
-  -258,   311,   601,   213,
-    94,   130,   -61,   502,
-    -1,  -157,   485,   313,
-   146,   -74,   158,   345,
-   276,   135,   280,   -57,
-   490,   252,    99,    43,
-   267,   -74,   429,   105,
-   278,   -23,   119,    94,
-  -542,   488,   257,  -115,
-   -84,  -244,  -438,   478,
-  -113,  -545,   387,   101,
-   -95,  -306,   111,   498,
-    95,   166,    22,  -301,
-   420,   -15,   -58,   -78,
-   270,    29,   122,  -282,
-   160,  -240,    50,   -38};
-
-static Word16 dico23_isf_36b[SIZE_BK23_36b*7] = {
-
-    81,   -18,    68,   -27,  -122,  -280,    -4,
-    45,  -177,   209,   -30,  -136,   -74,   131,
-   -44,   101,   -75,   -88,   -48,  -137,   -54,
-  -245,   -28,    63,   -18,  -112,  -103,    58,
-   -79,    -6,   220,   -65,   114,   -35,   -50,
-   109,   -65,   143,  -114,   129,    76,   125,
-   166,    90,   -61,  -242,   186,   -74,   -43,
-   -46,   -92,    49,  -227,    24,  -155,    39,
-    67,    85,    99,   -42,    53,  -184,  -281,
-   142,  -122,     0,    21,  -142,   -15,   -17,
-   223,    92,   -21,   -48,   -82,   -14,  -167,
-    51,   -37,  -243,   -30,   -90,    18,   -56,
-    54,   105,    74,    86,    69,    13,  -101,
-   196,    72,   -89,    43,    65,    19,    39,
-   121,    34,   131,   -82,    25,   213,  -156,
-   101,  -102,  -136,   -21,    57,   214,    22,
-    36,  -124,   205,   204,    58,  -156,   -83,
-    83,  -117,   137,   137,    85,   116,    44,
-   -92,  -148,   -68,    11,  -102,  -197,  -220,
-   -76,  -185,   -58,   132,   -26,  -183,    85,
-    -7,   -31,    -2,    23,   205,  -151,    10,
-   -27,   -37,    -5,   -18,   292,   131,     1,
-   117,  -168,     9,   -93,    80,   -59,  -125,
-  -182,  -244,    98,   -24,   135,   -22,    94,
-   221,    97,   106,    42,    43,  -160,    83,
-    25,   -64,   -21,     6,    14,   -15,   154,
-   126,    15,  -140,   150,   -10,  -207,  -114,
-    79,   -63,  -211,   -70,   -28,  -217,   165,
-    46,    38,   -22,   281,   132,   -62,   109,
-   112,    54,  -112,   -93,   208,    27,   296,
-   115,    10,  -147,    41,   216,    42,  -276,
-    50,  -115,  -254,   167,   117,    -2,    61,
-    17,   144,    34,   -72,  -186,  -150,   272,
-   -29,   -66,   -89,   -95,  -149,   129,   251,
-   122,     0,   -50,  -234,   -91,    36,    26,
-  -105,  -102,   -88,  -121,  -236,    -7,   -11,
-  -204,   109,     5,  -191,   105,   -15,   163,
-   -80,    32,   -24,  -209,    41,   294,    70,
-  -106,   -94,  -204,  -118,   120,   -50,   -37,
-   -82,  -241,    46,  -131,   -29,   150,   -55,
-    33,   155,   120,   -89,    -8,     7,    62,
-   213,    82,    61,    18,  -161,   144,   152,
-    30,   131,    65,   -87,  -255,   -17,  -107,
-    -8,    85,   -64,    51,  -162,   223,   -53,
-  -134,   261,    69,   -56,   218,    72,  -111,
-     2,   155,  -113,   -87,    49,    85,   -28,
-  -163,    42,    -1,  -196,     7,    39,  -245,
-    14,  -137,   -79,    11,  -160,   202,  -293,
-   -94,    33,   208,   100,    56,   -44,   326,
-   -78,   -41,   232,    13,  -142,   227,    80,
-   -16,   -87,   201,    33,  -133,    15,  -183,
-   -58,  -192,   -47,   184,  -128,   133,    99,
-  -205,    11,  -155,    78,    52,    72,   141,
-  -246,    26,    99,   151,    59,   115,   -64,
-   -79,   -47,   -16,   -14,     6,    47,   -43,
-   -72,  -178,   -27,   162,   112,    43,  -174,
-  -175,   238,   186,    71,   -54,  -188,   -76,
-  -225,   233,    39,   -39,  -158,   122,    44,
-   -26,    43,    84,   130,   -93,   -51,    22,
-     3,    92,  -150,   136,  -182,   -57,    97,
-  -131,   179,   -78,    80,    91,  -165,    90,
-    -2,   148,    15,   130,    65,   175,   117,
-  -138,   114,  -137,   132,     3,   -10,  -186,
-   140,    -4,   -37,   254,   -62,    92,  -109};
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*-------------------------------------------------------------------*
+ *                         qpisf_2s.h
+ *-------------------------------------------------------------------*
+ * Quantization tables for two-stage of ISFs (split by 2 in 1st stage)
+ * Version whith prediction MU = 0.25
+ *-------------------------------------------------------------------*/
+
+#define ORDER   16            /* order of linear prediction filter */
+#define ISF_GAP 128           /* 50 Hz */
+#define N_SURV  4
+
+#define SIZE_BK1  256
+#define SIZE_BK2  256
+#define SIZE_BK21 64
+#define SIZE_BK22 128
+#define SIZE_BK23 128
+#define SIZE_BK24 32
+#define SIZE_BK25 32
+
+#define SIZE_BK21_36b 128
+#define SIZE_BK22_36b 128
+#define SIZE_BK23_36b 64
+
+/* means of ISFs */
+static Word16 mean_isf[ORDER] = {
+
+   738,  1326,  2336,  3578,  4596,  5662,  6711,  7730,
+  8750,  9753, 10705, 11728, 12833, 13971, 15043,  4037};
+
+/* 46 bits */
+/*-------------------------------------------------------------------*
+ *  isf codebooks:  two-stage VQ with split-by-5 in 2nd stage        *
+ *                                                                   *
+ *  codebook   vector dimension    number of vectors                 *
+ *  ~~~~~~~~   ~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~                 *
+ *     1_1            9                  256                         *
+ *     1_2            7                  256                         *
+ *     2_1            3                  64                          *
+ *     2_2            3                  128                         *
+ *     2_3            3                  128                         *
+ *     2_4            3                  32                          *
+ *     2_5            4                  32                          *
+ *-------------------------------------------------------------------*/
+
+/*------------------------------------------------*
+ * 1st stage codebook; 1st split:   isf0 to isf8
+ *------------------------------------------------*/
+
+static Word16 dico1_isf[SIZE_BK1*9] = {
+
+   579,  1081,  1035,   390,     3,  -263,  -198,   -82,    38,
+    18,   -68,   -12,   313,   761,   405,   249,   111,   -76,
+   740,  1263,  1292,  1006,   997,  1019,  1017,   976,   923,
+   -91,   827,   948,   648,   613,   535,   522,   490,   421,
+    41,   -44,  -281,  -472,   652,   534,   193,   135,   -90,
+    41,  -121,  -356,   -60,   663,   307,    61,   -48,  -344,
+   557,   946,  1049,   867,   846,   990,  1112,  1262,  1241,
+  -118,  -204,   328,   512,   870,   793,   610,   402,   186,
+   156,   293,    74,  -338,  -475,  -897,  -594,  -161,  -497,
+   226,   131,  -138,   307,   169,  -271,  -164,  -387,  -624,
+    62,   -32,   -61,  -252,  -541,  -828, -1027,  -523,  -662,
+   102,   -61,   141,   112,  -270,  -251,  -541,    25,  -150,
+     6,  -132,  -356,  -686,   -96,  -322,  -522,   -31,  -326,
+   -36,  -209,  -521,  -229,   307,  -132,    -5,   -99,  -384,
+    60,   -51,  -237,  -668,  -973,  -407,  -708,   -75,  -172,
+    26,  -138,  -266,   111,  -302,    43,  -278,  -356,  -359,
+   570,   822,   496,  -154,  -312,   -92,   137,   279,   371,
+  -146,   368,   409,    68,     6,    77,   167,   202,   162,
+   633,   898,   996,   756,   662,   683,   783,   909,   996,
+  -103,   294,   607,   415,   483,   462,   480,   431,   408,
+  -120,  -338,  -612,  -524,   584,   331,    92,   433,   276,
+  -178,  -293,  -154,   -41,   269,   100,    -9,   213,   160,
+   830,   736,   278,   820,  1254,   686,   712,  1039,   473,
+  -218,  -304,   463,   454,   397,   273,   202,   286,   273,
+  -232,     7,     6,  -388,  -472,  -427,  -378,  -167,  -100,
+  -294,  -183,   134,   -47,   101,   -88,   -84,  -117,    -3,
+    57,    17,  -202,  -634,  -989, -1119,  -533,   176,   -36,
+   120,   -28,    23,   111,  -319,   318,   -22,   -77,   266,
+  -271,  -464,  -434,  -658,  -640,  -385,  -385,   -99,   -69,
+  -198,  -259,  -266,   -44,   -39,  -139,  -137,   171,    66,
+     9,  -145,  -377,  -846, -1000,  -111,  -325,   342,   135,
+   -81,  -286,  -380,   192,   -57,   307,    76,   -24,  -140,
+   677,   702,   247,    56,   249,   141,  -105,  -236,   -99,
+    36,   -39,   -69,   348,   198,   -93,   322,    91,   -72,
+   503,   885,  1508,  1307,  1282,  1172,  1119,  1209,  1061,
+   416,   719,   989,  1227,  1001,  1052,   954,   741,  1044,
+  -127,  -376,  -657,   139,   623,   223,   501,   306,   220,
+  -113,  -384,  -796,   504,   438,    85,   213,   -83,  -194,
+   585,  1132,  1233,  1091,  1247,  1433,  1512,  1448,  1314,
+  -174,  -422,     7,  1155,  1089,  1182,  1003,   945,   806,
+     8,  -126,  -317,  -103,  -351,  -695,   -98,  -268,  -537,
+    33,  -103,  -290,   167,   -39,  -407,    44,  -208,  -375,
+   104,   -23,   -64,  -291,  -637,  -851, -1084,   -61,  -112,
+   -75,  -306,  -434,   218,  -148,  -354,  -680,  -133,  -216,
+  -121,  -377,  -718,   -97,  -130,  -361,  -156,  -379,  -599,
+   -56,  -254,  -586,   235,   157,  -214,    11,  -260,  -149,
+  -124,  -267,  -397,  -580,  -593,  -527,  -805,  -385,   346,
+  -193,  -440,  -708,  -351,  -141,  -255,  -499,  -147,  -185,
+   448,   660,   494,   208,   509,   461,   338,   291,   149,
+  -223,    88,   335,   159,   212,   191,   286,   308,   205,
+   -31,   469,   803,   659,   619,   658,   843,   987,  1113,
+  -171,  -242,   514,   362,   295,   524,   552,   694,   585,
+   -64,  -308,  -448,   -21,   284,   786,   446,   289,    92,
+  -218,  -390,    -7,   169,   206,   330,   352,   408,   358,
+   -36,   702,   959,   859,   861,  1115,  1269,  1357,  1305,
+  -133,  -341,   -65,   678,   417,   440,   486,   518,   780,
+    33,   -44,  -191,  -344,  -461,  -755,  -201,   217,   -31,
+  -353,  -547,   -44,   123,   -61,   -68,   -79,    29,    60,
+    73,   -57,  -406,  -766, -1243, -1203,   240,   400,   165,
+   -73,  -282,  -601,  -213,  -171,  -375,   332,    35,  -103,
+   -29,  -207,  -553,  -476,  -638,  -908,   172,   -22,  -135,
+  -192,  -239,  -164,  -103,  -111,   -47,   153,   125,   110,
+    -1,  -203,  -570, -1030, -1424,  -535,   155,     1,   147,
+  -333,  -653,  -865,  -197,  -158,   -21,   -44,    95,   108,
+   389,   588,   490,    33,  -237,  -524,  -628,  -136,  -260,
+    40,  -177,  -462,   453,   862,   380,   131,  -130,  -405,
+   842,  1678,  1841,  1549,  1474,  1256,  1082,   905,   742,
+   370,  1216,  1768,  1633,  1212,   636,    22,  -330,    71,
+   -76,  -281,  -741,  -742,   898,   619,   277,    71,  -222,
+   -32,  -265,  -556,   -25,   994,   682,   305,   126,  -165,
+    73,   738,   893,   968,   993,  1768,  2273,  1840,  1391,
+   -69,  -349,  -585,   234,  1158,   903,   626,   510,   251,
+    -1,   -99,  -272,  -210,  -603,  -351,  -540,  -811,  -383,
+   -16,  -230,  -504,   410,   149,  -205,  -343,  -651,  -639,
+   103,    -9,  -227,  -205,  -562,  -781, -1079, -1208,  -156,
+   143,    63,  -135,   -67,  -317,  -602,  -784, -1154,  -640,
+  -144,  -391,  -674,  -622,  -200,  -254,  -660,  -947,  -395,
+   -40,  -250,  -625,    27,   543,    94,  -131,  -386,  -673,
+  -123,  -371,  -757,  -451,  -564,  -614,  -415,  -711,   -35,
+  -116,  -309,  -593,  -268,   239,   -33,  -338,  -650,  -135,
+    94,   251,   554,    57,  -312,  -423,  -154,   -57,   235,
+  -268,   -71,   381,   114,   -44,   -87,   125,   173,   133,
+  1513,  1714,  1238,   534,   276,   315,   461,   459,   508,
+  -131,   -19,  1149,   670,   486,   356,   309,   369,   296,
+  -223,  -501,  -899,  -722,   -70,     6,   131,   310,   394,
+   -99,  -303,  -517,   249,    64,   -53,   135,   -11,   453,
+  -147,  -399,  -730,  -401,   817,   738,   802,   749,   575,
+  -154,  -435,  -739,   800,   593,   366,   529,   318,   326,
+  -224,    45,   -39,  -387,  -515,  -518,  -608,  -384,  -321,
+  -315,  -377,   143,  -101,  -113,  -377,  -177,  -144,   -12,
+   117,    40,  -239,  -651, -1051,  -581,  -737,  -990,  -328,
+    26,   -50,  -157,   -23,  -453,  -283,  -531,  -546,   192,
+  -252,  -501,  -743,  -589,  -627,  -499,  -328,  -118,   -72,
+  -324,  -494,  -244,  -306,  -144,  -177,  -262,  -135,   -78,
+   -36,  -234,  -519,  -961, -1290,  -314,  -479,  -371,   -45,
+   -95,  -292,  -535,    -8,  -300,   112,  -164,  -277,   198,
+   -99,  -128,   880,   836,   579,   351,    23,   -95,  -217,
+   -27,  -258,   124,  1011,   597,   425,   144,     7,   -73,
+   421,  1293,  1640,  1623,  1742,  1617,  1499,  1284,  1006,
+   -95,   752,  1680,  1569,  1618,  1436,  1200,   980,   712,
+   -69,  -300,  -683,  -435,  1132,   899,   504,   332,   109,
+   -74,  -323,  -637,   563,  1074,   608,   371,   105,   -49,
+   -78,   831,  1194,  1110,  1378,  1481,  1492,  1365,  1217,
+  -259,  -121,  1440,  1334,  1628,  1490,  1438,  1223,   933,
+   -82,  -306,  -613,  -222,  -378,  -675,  -545,  -671,  -845,
+    53,  -124,  -347,   422,    52,  -125,  -270,  -529,     9,
+    79,   -89,  -320,  -662,  -999, -1199, -1243,  -676,  -297,
+   -68,  -273,  -611,   137,  -146,  -397,  -627,  -845,  -220,
+  -112,  -346,  -797,  -826,   234,  -132,  -188,  -278,  -522,
+  -159,  -405,  -734,  -419,   293,    74,  -167,  -167,   184,
+  -153,  -437,  -833, -1080,  -336,  -472,  -561,  -340,  -253,
+  -169,  -423,  -820,  -904,  -131,   -19,  -346,  -604,    31,
+    33,   -31,   312,    62,  -148,    49,   -59,   564,   486,
+  -306,  -333,   194,   -44,    67,    72,   147,   205,   243,
+  -207,   -49,  1360,   983,   969,   991,  1014,  1110,   973,
+  -211,  -172,   883,   627,   711,   674,   705,   798,   746,
+   -88,  -325,  -763,  -974,   687,   908,   514,   382,   172,
+  -292,  -612,  -805,    63,   131,   270,   259,   352,   348,
+  -235,   -84,   955,   818,  1120,  1289,  1559,  1480,  1285,
+  -180,  -461,  -614,   657,   691,   745,   854,   783,   713,
+   -97,  -309,  -477,  -614,  -777,  -734,  -768,  -526,  -472,
+  -344,  -476,   -35,  -169,    49,   -77,  -150,  -240,  -141,
+   -52,  -268,  -639,  -919, -1278, -1113,  -342,  -333,  -151,
+   -68,  -242,  -585,   -73,  -209,  -478,  -159,  -429,   133,
+  -197,  -499, -1005, -1268,  -272,  -224,  -105,   -67,    17,
+  -363,  -618,  -414,  -116,   -62,    20,    10,   116,   108,
+  -195,  -475,  -906, -1260,  -891,  -441,  -277,  -142,   -28,
+  -226,  -519,  -950,  -700,  -275,  -266,  -116,  -105,    82,
+   404,   511,   520,   327,    17,  -194,  -333,  -536,  -586,
+  -114,  -130,   276,   237,   204,   342,   135,   -16,  -111,
+   670,  1208,  1168,   860,   742,   601,   528,   403,   309,
+   397,   621,   966,   752,   579,   398,   400,   329,   252,
+   191,   180,  -137,  -467,   272,   106,   -95,    17,  -192,
+   -80,  -290,  -626,   194,   598,   196,    21,  -281,    77,
+   510,   864,  1108,   807,   939,   902,   925,   717,   481,
+   137,   367,   534,   764,   670,   382,   296,   153,    84,
+   303,   497,   144,   -85,  -125,  -539,  -482,  -464,  -764,
+   233,   347,    68,  -147,   169,  -210,  -242,  -226,  -482,
+   307,   422,   154,  -175,  -386,  -722,  -724,  -904, -1015,
+   309,   308,   160,   -60,  -470,  -420,  -598,  -791,  -219,
+    68,   121,  -137,  -560,  -146,  -446,  -515,  -494,  -729,
+   130,    53,  -227,    46,   474,    32,  -161,  -192,  -490,
+   213,   164,   -71,  -465,  -876,  -161,  -456,  -587,   -48,
+   218,   117,    39,   177,  -194,   -88,  -226,  -418,    50,
+   210,   547,   569,   279,   121,   -44,   -50,    10,   -84,
+    58,   140,   182,    -5,   267,   117,   106,   211,   198,
+   539,   835,   913,   719,   617,   544,   591,   565,   642,
+   153,   559,   872,   460,   222,   108,   188,   180,   183,
+   158,   119,   284,  -153,  -271,   229,    87,   110,   -57,
+  -183,    82,   118,    21,    13,    40,   118,   191,   185,
+   162,   889,   654,   108,   -34,   244,   488,   561,   532,
+   163,    56,   609,   341,    50,   329,    68,   266,   218,
+   100,   206,    18,  -304,  -107,  -436,  -487,   -65,  -306,
+   -86,   154,   134,   -30,   -45,   -73,  -104,   -80,   -96,
+   245,   330,    10,  -440,  -849, -1082,    79,    40,  -265,
+   196,   372,   272,  -181,  -493,  -389,   275,    80,   -59,
+     2,   -12,  -246,  -505,  -100,  -436,    21,  -187,  -431,
+  -221,   -48,    36,  -271,  -186,  -147,  -109,    26,    71,
+   213,   140,    72,  -351,  -620,   -84,  -363,    69,    46,
+    91,   167,    -3,   -95,   -99,  -105,   -48,   114,   147,
+   259,   249,   172,   607,   406,    52,    59,  -189,  -320,
+   115,   -85,   -54,   574,   128,   226,   -59,  -253,   130,
+   -62,  1033,  1308,  1035,  1127,  1098,  1029,   961,   823,
+    39,   364,   757,   940,   728,   660,   659,   583,   770,
+  -115,  -338,  -760,  -471,   394,    37,   441,   178,     6,
+   -57,  -305,  -525,   796,   453,   188,    -4,  -114,   248,
+    71,   444,   797,   731,  1096,  1157,  1222,  1029,   811,
+   135,   359,   551,   425,   749,   815,   874,   704,   502,
+   132,   247,     0,  -206,  -449,  -750,  -258,  -514,  -633,
+   248,   249,    91,   121,  -195,  -499,   -90,  -282,  -435,
+    78,    20,  -277,  -623,  -983, -1224,  -415,  -458,  -639,
+   347,   509,   208,  -179,  -464,  -728,   -76,  -237,  -486,
+  -103,  -343,  -756,  -713,  -265,  -609,  -191,  -398,  -636,
+  -121,  -383,  -749,   567,   252,   -36,  -354,  -417,   -50,
+   204,   100,  -149,  -650, -1081,   -47,    -7,  -263,   111,
+   -46,  -180,  -267,  -324,  -562,  -394,  -692,   398,   292,
+   482,   670,   683,   624,   442,   165,   116,    36,  -149,
+   108,   247,   291,   247,   355,   122,   109,   224,   296,
+   -14,   945,   990,   801,   755,   815,   847,   913,   892,
+   292,   349,   725,   482,   388,   329,   429,   620,   667,
+   -34,   197,   213,  -127,    84,   494,   620,   575,   375,
+   126,   207,   172,   167,   362,   202,   296,   395,   455,
+    -6,   250,   539,   467,   636,   801,  1149,  1287,  1118,
+    27,   240,   369,   280,   440,   411,   634,   892,   953,
+   159,   170,   -58,  -395,  -797,  -690,    77,  -211,  -334,
+    -5,   -28,   -13,   -74,  -335,  -603,   300,    88,  -205,
+    82,   -33,  -364,  -698, -1203, -1153,   110,  -146,  -289,
+   113,     1,  -243,  -588,  -994,  -496,   414,   160,    42,
+   -56,  -247,  -440,  -693,  -996,  -479,    11,  -178,  -357,
+  -151,  -353,  -327,  -211,  -340,   141,    65,   425,   453,
+    34,  -169,  -455,  -932, -1215,   138,   499,   256,   324,
+    68,   139,   -15,  -547,  -478,    17,   306,   502,   481,
+   -32,  -134,   445,   129,  -143,  -244,  -503,  -507,  -599,
+    61,  -140,  -345,   496,   458,    -2,    20,  -227,  -514,
+   394,  1765,  1666,  1339,  1117,   806,   642,   479,   380,
+   215,   519,   920,  1053,  1090,   791,   528,   290,   155,
+   -54,  -233,  -647,  -602,   639,   294,    -2,  -167,  -442,
+   -78,  -315,  -791,  -113,   820,   403,   158,  -116,  -356,
+   529,  1851,  2003,  1228,   622,   -41,  -416,   344,   819,
+  -105,  -379,  -236,  1224,   893,   749,   568,   356,   214,
+   -17,  -199,  -144,    50,  -283,  -247,  -578,  -846, -1087,
+    69,   -11,  -381,  -206,   209,  -284,  -387,  -416,  -716,
+    39,    -5,  -145,  -374,  -682,  -909, -1074, -1169, -1066,
+   287,   226,    67,  -221,  -662,  -171,  -421,  -642,  -707,
+  -132,  -348,  -538,  -448,   -20,    -4,  -354,  -748,  -933,
+     4,   -75,  -289,  -598,   317,    52,  -208,  -297,  -559,
+   -88,  -264,  -358,  -589,  -631,  -248,  -523,  -822, -1071,
+    70,    -8,    54,  -314,  -515,    92,  -146,  -274,  -493,
+   199,    62,   391,   158,  -141,    71,  -219,  -203,  -207,
+   152,    40,   329,   162,   -29,    48,  -149,   108,   127,
+   635,  1058,   883,   492,   372,   312,   317,   274,   241,
+   267,   722,  1256,   882,   625,   248,     8,   -81,   -60,
+   -58,  -138,  -291,  -600,   -12,    -2,   -39,   147,   117,
+  -107,  -345,  -513,   459,    76,    92,  -272,   388,   262,
+   362,   516,   203,  -409,  -716,  -831,  -331,   185,   209,
+  -117,  -391,  -298,   671,   292,   538,   257,   166,   -38,
+  -102,  -319,  -194,  -283,  -573,  -262,  -579,  -219,  -444,
+  -235,    78,    11,  -168,  -101,  -229,  -263,  -321,  -123,
+    70,    50,  -170,  -599,  -996,  -588,  -263,  -516,  -455,
+   394,   363,   229,  -136,  -538,    21,  -183,  -348,  -201,
+  -124,  -368,  -640,  -879,  -847,  -209,  -409,  -494,  -515,
+  -127,  -341,  -541,  -425,  -510,   -10,  -252,  -473,  -291,
+    84,   -69,  -201,  -676,  -868,   103,  -311,  -132,  -320,
+     5,  -173,  -188,  -297,  -628,   197,   -57,     7,   -11,
+    49,  -160,    56,   558,   111,    33,  -311,  -440,  -463,
+    -1,  -246,  -307,   862,   453,   139,  -170,  -355,  -232,
+   279,   966,  1642,  1478,  1463,  1123,   795,   525,   339,
+  -197,   -38,  1702,  1331,  1252,   950,   692,   504,   426,
+  -108,  -344,  -861, -1172,   444,   354,    88,   -46,  -220,
+   -53,  -321,  -494,  1113,   744,   364,   198,   -34,   -75,
+   457,   955,  1177,  1214,  1427,  1457,  1345,   917,   539,
+   -69,   199,   897,  1140,  1343,  1183,   977,   742,   522,
+   122,    44,  -269,    27,  -155,  -562,  -307,  -590,  -773,
+   154,    42,  -160,   252,  -129,  -305,  -471,  -733,  -371,
+   135,   185,   -82,  -416,  -722,  -913,  -504,  -743,  -880,
+   149,   214,   -84,  -329,  -680,  -835,  -426,  -661,   -81,
+  -128,  -380,  -735,  -998,  -337,    17,  -182,  -467,  -697,
+   -84,  -290,  -510,  -592,    13,   440,   154,   -38,  -279,
+    70,   -61,  -246,  -727, -1047,   -80,  -381,  -535,  -704,
+   178,    -2,  -146,  -670,  -938,   482,   138,    63,    65,
+   -11,    15,   772,   443,   142,   -20,  -209,  -126,  -161,
+   -32,  -249,    95,   552,   124,    30,  -343,    82,   -86,
+   148,   751,  1515,  1105,   867,   606,   474,   448,   399,
+  -163,  -257,   899,  1097,   906,   751,   502,   390,   294,
+   -51,  -258,  -447,  -806,  -368,   763,   464,   364,   183,
+  -166,  -374,  -367,    87,    35,   399,   418,   856,   833,
+  -205,  -310,   588,   778,   785,  1065,  1118,  1245,  1157,
+  -173,  -312,   107,   345,   400,   790,   870,  1113,  1001,
+    -7,  -120,  -387,  -410,  -614,  -943,  -226,  -384,  -491,
+  -203,  -288,   -51,  -331,   -90,  -178,  -408,  -573,  -338,
+    56,   -29,  -273,  -627, -1041,  -798,  -247,  -467,   148,
+    66,    -2,  -205,  -205,  -575,  -349,   -57,  -352,   -58,
+   -45,  -225,  -471,  -924,  -497,    77,   -32,    44,  -135,
+  -277,  -491,  -497,  -502,  -424,  -202,  -137,    77,    96,
+    26,  -179,  -469, -1008, -1260,   262,   -35,  -132,  -259,
+   -66,  -232,  -447,  -533,  -789,  -191,  -100,  -267,   364};
+
+/*------------------------------------------------*
+ * 1st stage codebook; 2nd split:   isf9 to isf15
+ *------------------------------------------------*/
+
+static Word16 dico2_isf[SIZE_BK2*7] = {
+
+  1357,  1313,  1136,   784,   438,   181,   145,
+   636,   648,   667,   568,   442,   217,   362,
+   427,   440,   674,   524,   332,   117,  -417,
+   121,   295,   468,   465,   230,    44,  -221,
+  -147,  -240,   149,    80,   390,   278,   106,
+  -418,  -556,   552,   511,   235,   144,   -95,
+    43,   193,   274,   150,    67,    34,  -273,
+   -43,  -126,   171,   416,   282,    63,  -354,
+  -372,   -86,  -344,  -108,   -94,  -182,   -89,
+  -600,  -840,  -200,   465,   258,   -11,  -253,
+   -48,   329,    97,  -290,  -543,  -795,  -354,
+  -570,  -117,   187,    10,  -133,  -416,   -76,
+  -618,  -129,  -247,  -371,    45,   -76,   277,
+ -1022, -1079,   126,   474,   254,   127,    52,
+  -281,    76,  -167,  -361,  -283,  -551,  -283,
+  -119,   -52,    -1,   134,   -32,  -204,  -415,
+  1064,   827,   637,   684,   464,   209,    12,
+   482,   416,   449,   371,   335,   294,   194,
+   719,   576,   365,   135,   113,    91,  -199,
+   298,   176,   493,   366,   194,   163,    36,
+   -35,  -236,  -259,   -36,    -4,    99,   152,
+   -98,  -306,   -27,   228,    90,   111,   -86,
+    91,    13,  -211,  -258,  -106,    86,   -64,
+    73,   -35,   -57,   -31,   162,    35,  -192,
+  -109,  -335,  -629,   -66,   -61,  -128,   322,
+  -495,  -669,  -728,   193,    31,  -220,   122,
+   324,    95,   -89,   -91,  -409,  -710,  -154,
+     0,  -234,    92,    33,  -343,  -609,  -220,
+  -343,  -408,  -476,  -655,  -153,    82,   222,
+  -490,  -745,  -255,    49,   -48,   135,  -127,
+   119,   -67,  -328,  -390,  -272,  -545,   -56,
+   -57,  -130,   -10,    -7,  -164,   -47,   -22,
+   984,  1064,   961,   568,   210,   -27,    16,
+   811,   691,   754,   514,   224,   -35,   166,
+   662,   704,   618,   386,    57,  -211,  -257,
+   510,   359,   418,   393,    91,  -144,   -18,
+  -193,   -31,   -27,   223,    89,  -143,    24,
+  -112,   -98,   471,   319,   185,     3,   175,
+   252,   146,   -47,   272,    48,  -211,  -234,
+   146,    69,   203,   364,    68,   -52,    51,
+  -259,  -478,  -697,  -349,  -758,  -501,    63,
+  -501,  -769,  -289,    79,  -311,  -497,  -106,
+   251,    53,  -235,  -469,  -895,  -884,   145,
+  -416,  -551,   140,  -133,  -523,  -775,    44,
+  -326,  -423,  -713,  -497,   -86,  -431,    99,
+  -757,  -772,  -160,   -76,   -46,   -32,   379,
+    85,   -35,  -200,  -401,  -663, -1040,  -247,
+  -180,  -330,   -92,  -376,    27,  -183,  -110,
+  1279,  1086,   781,   502,   324,   164,   157,
+   682,   466,   449,   277,   146,    28,   409,
+   635,   472,   390,   107,  -232,  -538,  -139,
+   196,   396,   332,   213,   209,   -29,   -81,
+   150,   -95,  -312,    76,   -77,  -320,   -50,
+    46,     9,    47,   175,   139,    30,   384,
+   218,   206,   -24,  -250,   -96,  -276,  -183,
+    26,   119,    38,    14,    -4,  -133,   -52,
+  -477,  -614,  -987,  -715,  -631,  -813,   200,
+  -744, -1009, -1065,  -745,  -631,  -171,    18,
+  -137,  -251,  -483,  -613,  -980, -1203,    12,
+  -605,  -767,  -562,  -686, -1088,  -515,    58,
+  -202,  -428,  -782, -1072,   -96,  -234,  -179,
+  -480,  -709, -1070,  -897,  -131,   -92,   321,
+  -145,  -193,  -512,  -729,  -572,  -765,  -210,
+  -331,  -585,  -525,  -631,  -281,  -208,  -303,
+  1165,  1104,   939,   828,   716,   426,   155,
+     6,  -109,   820,   778,   415,   113,   -27,
+   381,   339,   314,   265,   121,    -9,  -474,
+  -373,    47,   584,   442,    99,  -231,  -113,
+  -496,   -38,  -285,   262,   305,   170,     4,
+  -587,  -556,    69,    66,   471,   354,    13,
+  -138,    70,   -18,   106,    67,   167,  -302,
+  -445,  -141,   185,   191,   151,    83,  -133,
+  -257,  -521,  -720,  -198,   134,   -46,  -182,
+  -819, -1168,  -777,   512,   359,    95,  -113,
+   137,    -2,   -74,  -138,  -401,  -114,  -371,
+  -242,  -466,   204,   223,   -31,  -212,  -192,
+  -532,  -637,  -466,  -686,   256,   277,  -139,
+ -1141, -1244,  -381,   -75,   -54,    14,    88,
+  -311,   115,  -143,  -499,  -343,   124,  -416,
+  -616,  -147,  -135,    43,    -4,   121,  -369,
+   835,   783,   641,   390,   355,   350,    64,
+    72,   194,   443,   467,   436,   219,   372,
+   464,   369,   192,     4,  -156,   -72,  -226,
+    57,   206,   303,   205,   188,   101,   265,
+   -40,  -205,  -488,  -184,   276,    64,   -26,
+  -217,  -433,  -297,   137,   328,   308,  -289,
+   378,    81,  -308,  -465,    57,   -37,   227,
+  -100,    24,   -36,  -151,   199,     8,   143,
+  -426,  -697, -1059,  -133,   388,   161,   321,
+  -644, -1023, -1271,    39,    66,  -123,    70,
+   372,   177,  -173,  -556,  -553,  -304,  -189,
+  -117,  -369,  -425,  -122,  -462,  -152,   -73,
+  -649,  -850, -1189,  -767,   497,   360,   222,
+  -798, -1139, -1455,  -190,   430,   234,   179,
+    42,   -94,  -405,  -692,    38,  -202,  -246,
+  -169,  -366,  -290,   -88,   -64,    32,  -292,
+  1010,   923,   938,   710,   465,   230,   342,
+   217,   300,  1054,   675,    68,  -458,  -179,
+    78,   453,   316,    18,  -237,  -496,  -243,
+   167,    21,   424,   215,   -91,  -303,  -170,
+  -290,   -81,   -70,   -67,    40,    54,   -59,
+  -353,  -427,   -90,    53,    94,     9,    54,
+   -28,   318,   283,    15,  -240,   -58,    79,
+   -75,  -121,   229,    35,    58,     6,  -133,
+  -351,  -514,  -744,  -834,  -705,  -137,   164,
+ -1124, -1388, -1055,  -230,   -73,    40,    36,
+  -163,  -233,  -532,  -785, -1170,  -697,    96,
+  -788,  -959,  -246,  -430,  -624,  -165,    -8,
+  -856,  -540,  -630,  -907,  -337,   -70,    76,
+  -937, -1042,  -659,  -733,  -208,   199,   -26,
+  -523,    78,   -98,  -501,  -869,  -890,   -81,
+  -624,  -703,   -45,  -348,   -25,    87,  -186,
+  1005,   823,   546,   249,    90,   -22,   207,
+   298,   397,   381,   319,   200,    62,   303,
+   473,   379,   133,  -247,  -632,  -441,    75,
+   284,   208,   391,   115,   -25,    44,    95,
+   -72,    79,   -95,   -63,  -129,  -293,   203,
+  -164,  -349,   115,   122,    69,    -1,   378,
+   348,   170,    99,    58,  -179,  -302,   188,
+  -190,    -2,   150,    23,   -51,   -11,   216,
+  -615,  -863, -1090, -1427,  -802,   -48,    -6,
+  -961, -1276, -1548,  -727,   -58,    56,   223,
+  -124,  -255,  -561,  -988, -1277,  -148,   -82,
+  -480,  -660,  -891, -1191, -1339,  -325,    20,
+  -621,  -917, -1296, -1350,   264,   289,    50,
+  -844, -1022, -1345, -1329,  -293,    46,   278,
+  -260,  -468,  -829, -1176,  -533,  -560,   -78,
+  -215,  -484,  -822, -1233,  -791,    15,  -138,
+  1301,  1317,  1262,  1048,   716,   357,   -64,
+   578,   824,   925,   802,   630,   362,   102,
+   470,   925,   767,   514,   327,   190,  -112,
+   225,   492,   495,   437,   598,   384,   -45,
+    43,    82,   -42,   175,   519,   342,   -64,
+  -304,  -154,   159,   576,   403,   221,   327,
+   214,   244,   122,   -62,   312,    92,  -160,
+   218,   208,   310,   268,   306,   323,  -199,
+  -285,  -269,   -79,  -124,  -143,  -153,   236,
+  -205,  -384,  -426,   344,    59,  -185,  -184,
+  -272,   247,   126,  -210,  -518,  -468,    78,
+   -99,  -120,   502,   160,  -280,  -557,   304,
+  -423,   -17,  -283,  -443,   215,   212,  -140,
+  -564,  -684,  -228,   510,   361,   130,   323,
+  -428,   335,    98,   -65,    36,  -215,  -246,
+  -362,    51,   364,   -16,  -234,   150,  -165,
+   914,   883,   751,   653,   676,   464,  -153,
+   631,   545,   535,   720,   596,   360,   -81,
+   783,   712,   512,   439,   341,   251,  -391,
+   497,   417,   249,   372,   295,   173,  -193,
+   128,  -110,  -385,    93,    39,   173,  -231,
+   216,   -59,  -253,   462,   389,   154,    69,
+   455,   270,    -4,  -337,   -49,   233,  -322,
+   307,   143,    53,   218,   128,   236,  -156,
+   -37,  -186,  -240,  -411,  -110,     9,   399,
+  -140,  -365,  -628,   258,   380,   214,   277,
+   131,   454,   177,  -285,  -520,   108,  -214,
+    77,  -141,   201,  -123,  -490,  -131,    60,
+   -14,  -194,  -521,  -741,   273,   362,   -33,
+  -362,  -566,  -287,  -228,   161,   237,   317,
+  -269,   195,   -75,  -375,  -204,    11,    77,
+  -128,  -264,  -156,  -223,  -475,   265,    27,
+  1238,  1147,   916,   689,   432,   210,  -280,
+   800,   664,   879,   726,   411,   160,  -164,
+   454,   686,   536,   275,   147,    46,   111,
+   303,   486,   512,   355,   241,   181,   -69,
+    79,    92,    29,   147,   233,    52,    17,
+  -171,   289,   131,   439,   271,     3,   -10,
+   413,   241,   144,   174,   155,    -2,    14,
+    58,   217,   247,   219,   149,   175,   -18,
+   228,    -8,  -240,  -206,  -513,  -191,   202,
+   -96,  -272,  -454,    33,  -300,  -575,    46,
+   -10,  -108,  -246,  -347,  -770,  -535,     9,
+  -326,  -430,   -61,  -321,  -704,  -299,   201,
+    -1,  -280,  -603,  -419,  -185,    18,   -36,
+  -516,  -522,  -379,  -291,  -181,   -97,    27,
+  -159,  -313,  -525,  -224,  -510,  -831,  -197,
+  -292,  -459,   -59,  -310,  -562,  -143,  -351,
+  1066,   912,   631,   389,   207,    86,  -224,
+   596,   512,   596,   505,   314,   122,   -48,
+   787,   861,   441,   -93,  -303,    33,  -190,
+   257,   469,   337,    51,    15,   298,   -93,
+   295,    73,  -119,    25,    36,    23,   108,
+   -28,    -3,   -32,   114,    21,   185,   107,
+   482,   305,    15,  -279,  -319,    52,    96,
+   226,    46,   115,    72,  -136,   133,  -125,
+    18,  -207,  -559,  -590,  -503,  -482,   321,
+  -571,  -789,  -951,  -172,  -441,  -538,   113,
+   181,    14,  -310,  -641, -1001,  -202,   159,
+  -136,  -393,  -433,  -513,  -911,  -144,   -22,
+    72,  -265,  -706,  -954,  -159,    53,   332,
+  -338,  -591,  -852,  -383,  -395,    56,    44,
+    43,  -158,  -464,  -897,  -631,  -157,  -294,
+  -161,  -128,  -328,  -573,  -483,  -125,    11,
+  1017,   906,  1051,  1005,   679,   341,  -102,
+   359,   334,  1567,  1314,   723,   105,    10,
+   -65,   726,   529,   301,   220,    43,  -273,
+  -510,   436,   719,   566,   358,   179,   114,
+  -560,   298,   133,  -120,   342,   225,    14,
+  -899,  -101,   217,   617,   400,   146,   -58,
+   -41,   352,    82,  -196,    39,   121,  -167,
+  -212,    59,   447,   284,   423,   250,  -169,
+  -371,  -484,  -596,    30,   -41,   249,    22,
+  -372,  -650,  -794,   477,   445,   216,   -79,
+  -352,   275,    17,  -443,  -929,    92,    19,
+  -699,  -696,   431,   264,   -49,  -310,   182,
+  -978,  -217,  -430,  -400,   101,   261,    72,
+  -929,  -889,  -357,   -13,   463,   378,   236,
+  -826,    56,    30,  -299,  -360,  -128,   -51,
+  -878,  -299,  -111,    75,    65,    36,     3,
+   817,   368,   -25,   354,   697,   591,  -173,
+   309,   212,   222,   751,   484,   140,   -56,
+   593,   379,    70,    -8,   258,   180,   110,
+   165,   -46,   255,   297,   219,   273,   105,
+   160,   -70,  -358,  -181,   379,   330,   319,
+  -238,  -369,  -198,   740,   580,   319,  -143,
+   201,   109,  -202,  -456,   328,   276,  -141,
+   203,   170,   111,    42,   207,   360,   188,
+  -345,  -399,  -513,  -233,   650,   422,    81,
+  -635,  -961, -1220,   463,   539,   204,   209,
+   202,   -25,  -194,  -498,  -787,   193,  -143,
+  -449,  -538,   195,  -106,  -331,    68,    62,
+  -228,  -477,  -840,  -576,   317,   128,   283,
+  -671,  -937,  -807,  -114,   391,   335,   -62,
+   246,     2,  -314,  -679,  -303,   180,   -88,
+  -107,  -272,    90,  -198,   -28,   290,  -112,
+   885,  1149,  1021,   712,   496,   281,   -83,
+   269,   492,   787,   643,   347,    70,   124,
+   336,   636,   499,    92,  -229,  -179,   191,
+    26,   402,   564,   340,   149,   -11,   135,
+  -440,   561,   470,   204,   -72,  -186,   140,
+  -720,    14,   355,   229,    68,  -133,   465,
+   110,   310,   103,    12,   106,    29,   158,
+  -178,   113,   161,   142,   121,   115,    27,
+  -651,  -414,  -645,  -152,  -164,   -13,  -429,
+  -639,  -944,  -681,  -104,   -81,    52,  -189,
+  -663,  -164,  -316,  -683,  -954,  -205,   -83,
+  -609,  -669,  -172,  -517,  -694,   283,   -80,
+  -646,  -152,  -383,  -678,  -246,   -40,  -143,
+  -747,  -796,  -745,  -390,   -98,    43,   275,
+  -599,  -199,  -398,  -433,  -436,  -538,    31,
+ -1107,  -568,  -376,  -265,  -126,   -21,     1,
+   847,   573,   308,   392,   305,   101,    55,
+   273,   293,   201,   267,   346,   201,   123,
+   727,   480,   226,     2,   -65,  -138,   164,
+   273,   208,   173,   292,    12,   253,   174,
+   340,   207,   180,    88,   116,    46,   475,
+  -460,  -166,   -30,    13,   110,   173,   396,
+   137,    88,    43,  -137,   -94,    34,   284,
+    96,   -14,   226,    40,    63,    70,   130,
+  -467,  -735, -1012, -1174,  -307,   305,   -67,
+  -612,  -920, -1146,  -567,    -8,    92,   -25,
+  -182,  -271,  -492,  -754,  -857,   287,   -75,
+  -494,  -787,  -689,  -683,  -709,   137,  -326,
+  -288,  -550,  -903, -1105,   334,   321,   -62,
+  -354,  -653,  -834,  -445,     1,   377,  -152,
+  -162,  -306,  -608,  -937,  -297,   247,  -192,
+  -234,  -477,  -244,  -488,  -266,   342,  -332};
+
+/*---------------------------------------------------*
+ * 2nd stage codebook; 1st split:   isf2_0 to isf2_2
+ *---------------------------------------------------*/
+
+
+static Word16 dico21_isf[SIZE_BK21*3] = {
+
+   329,   409,   249,
+   -33,   505,   160,
+   -29,   -14,   582,
+  -262,   127,   354,
+   145,   237,   175,
+  -152,   245,   122,
+    27,    42,   340,
+   -84,   -93,   311,
+   285,   222,  -156,
+    47,   -43,  -504,
+   234,   121,   385,
+   104,  -317,    45,
+   176,   195,     8,
+   104,   -59,   -94,
+   177,    53,   192,
+   -34,  -127,   152,
+   570,   277,   -34,
+   -67,  -329,  -639,
+  -157,  -272,   462,
+  -177,  -462,   198,
+   322,   179,   115,
+  -386,   171,    19,
+    19,   -12,   195,
+  -120,  -252,   201,
+   304,    36,  -336,
+  -128,  -221,  -380,
+   171,  -185,   296,
+  -242,  -312,    23,
+   198,    39,    16,
+    -3,  -177,  -111,
+   111,   -93,    76,
+   -92,  -223,     4,
+   177,   406,   -44,
+  -168,   380,  -149,
+    -4,   273,   331,
+  -420,   513,   277,
+    21,   247,    47,
+   -58,   131,    -2,
+    -3,   134,   180,
+  -145,    40,   175,
+   189,    74,  -145,
+   -27,   -45,  -325,
+   370,  -114,   -21,
+   -83,  -415,  -173,
+    77,    95,   -51,
+   -40,   -30,   -67,
+    71,    88,    86,
+   -35,   -98,    14,
+    69,   197,  -334,
+  -196,    79,  -231,
+  -348,  -137,   218,
+  -352,   -89,   -85,
+    47,   201,  -130,
+  -165,    37,   -15,
+   -43,     3,    86,
+  -161,  -108,    79,
+    83,    21,  -237,
+   -81,  -149,  -238,
+   150,  -186,  -251,
+  -186,  -249,  -162,
+   -19,    66,  -139,
+   -26,   -50,  -181,
+    24,    11,     0,
+  -130,  -105,   -98};
+
+
+
+/*---------------------------------------------------*
+ * 2nd stage codebook; 2nd split:   isf2_3 to isf2_5
+ *---------------------------------------------------*/
+
+
+static Word16 dico22_isf[SIZE_BK22*3] = {
+
+  -127,   310,    42,
+  -242,   197,     5,
+  -151,    84,   -17,
+  -214,   127,  -149,
+  -247,  -131,   159,
+  -268,  -267,   -95,
+  -217,     1,   -79,
+  -271,   -80,  -185,
+   -45,   436,   159,
+   165,   199,   391,
+   -33,    81,   187,
+   -66,   -42,   355,
+  -298,   -57,   343,
+  -108,  -537,   226,
+  -144,   -23,   193,
+   176,  -402,    87,
+    53,   296,    25,
+   -84,   253,  -104,
+   -58,   105,  -126,
+  -169,   174,  -314,
+   -48,    44,  -294,
+  -164,  -417,  -242,
+  -139,     3,  -194,
+  -155,  -207,  -211,
+   119,   322,   213,
+   333,    50,   380,
+   237,   247,    -2,
+   466,   -16,   201,
+   238,  -255,  -107,
+    67,  -440,  -149,
+   122,   -88,  -139,
+    88,  -247,   -73,
+   -41,   231,   167,
+   -62,   155,    16,
+   -65,    16,    77,
+   -68,    -2,   -63,
+  -151,  -300,   160,
+   -18,  -333,    54,
+   -56,   -94,     5,
+     2,  -190,    14,
+    92,   148,   209,
+   108,     9,   272,
+   108,    35,   110,
+   142,   -85,   145,
+    47,  -157,   279,
+     3,  -320,   246,
+    43,   -72,    68,
+    86,  -217,   135,
+    36,   140,    79,
+    56,   175,   -49,
+    26,    45,     3,
+    73,    55,  -101,
+   109,  -183,  -242,
+    -4,  -283,  -242,
+    48,   -68,   -48,
+    -6,  -153,  -122,
+   161,   196,    96,
+   232,    80,   190,
+   165,    97,    11,
+   258,   -31,    71,
+   267,   -77,   -91,
+   311,  -209,    87,
+   152,   -14,   -22,
+   150,  -149,     9,
+  -324,   557,   187,
+  -384,   307,    46,
+  -251,    27,    77,
+  -365,    77,   -52,
+  -482,   -84,   160,
+  -424,  -515,   -64,
+  -294,  -120,    -4,
+  -476,  -116,  -109,
+   -97,   318,   365,
+   106,   627,   445,
+  -190,   120,   287,
+  -146,    65,   619,
+  -427,   242,   363,
+  -361,  -371,   432,
+  -347,   102,   168,
+  -629,   195,   -14,
+   -65,   476,   -47,
+  -297,   320,  -168,
+   -55,   356,  -264,
+  -391,    82,  -286,
+   -51,   -31,  -556,
+  -178,  -399,  -586,
+  -205,   -49,  -360,
+  -343,  -238,  -337,
+   220,   457,    58,
+   561,   467,   259,
+   340,   270,  -168,
+   450,    77,  -280,
+    60,   167,  -413,
+   133,  -252,  -492,
+   216,   157,  -290,
+   282,     0,  -495,
+  -226,   293,   183,
+  -157,   135,   122,
+  -158,   -59,    39,
+  -133,  -118,   -97,
+  -332,  -309,   113,
+  -160,  -425,    -6,
+  -149,  -211,    24,
+   -80,  -277,   -90,
+   -11,   125,   338,
+   130,   -71,   465,
+     5,   -45,   184,
+   237,   -95,   253,
+  -139,  -197,   297,
+   -19,  -300,   511,
+   -63,  -152,   139,
+   250,  -289,   336,
+   124,   339,  -150,
+    34,   176,  -208,
+   171,   166,  -116,
+    94,    38,  -229,
+    75,   -65,  -339,
+   -78,  -205,  -385,
+     0,   -30,  -163,
+   -56,  -110,  -242,
+   321,   244,   194,
+   505,   238,    -1,
+   317,   116,    65,
+   309,    88,   -74,
+   452,   -51,   -50,
+   334,  -217,  -290,
+   211,    41,  -152,
+   238,   -55,  -260};
+
+
+/*---------------------------------------------------*
+ * 2nd stage codebook; 3rd split:   isf2_6 to isf2_8
+ *---------------------------------------------------*/
+
+
+static Word16 dico23_isf[SIZE_BK23*3] = {
+
+   -10,   151,   359,
+   136,   298,   223,
+   255,  -104,   290,
+   423,     6,   183,
+  -270,  -269,   -98,
+   -52,   -82,    13,
+   -82,  -274,   -97,
+    90,  -246,   -72,
+  -299,   -70,   421,
+   -88,   365,   430,
+   187,  -318,   381,
+   380,    37,   488,
+  -373,  -316,    79,
+  -308,  -101,     5,
+  -135,  -451,     8,
+    72,  -421,  -154,
+   180,   170,  -121,
+    62,   177,   -40,
+   326,    80,  -105,
+   248,   263,    -5,
+  -168,  -181,  -221,
+    -2,   -23,  -158,
+   -14,  -149,  -121,
+   119,   -91,  -147,
+   119,   332,  -153,
+    49,   303,    34,
+   442,   -55,   -69,
+   217,   454,    58,
+  -359,  -187,  -375,
+   -42,    50,  -274,
+    -8,  -267,  -249,
+    85,   -86,  -346,
+   -77,   -40,   345,
+    89,   134,   219,
+   156,   -80,   160,
+   108,    40,   116,
+  -158,  -206,    29,
+     5,   -32,   175,
+   -65,  -158,   146,
+    55,   -78,    73,
+  -114,  -222,   353,
+   -47,    81,   211,
+    49,  -151,   268,
+   105,     4,   302,
+  -263,  -132,   183,
+  -151,   -28,   201,
+  -177,  -307,   166,
+   101,  -221,   130,
+    74,    58,   -98,
+    32,    44,    13,
+   194,    30,  -142,
+   170,    96,     8,
+  -136,  -119,   -91,
+   -65,     8,   -55,
+     3,  -188,    12,
+    45,   -63,   -49,
+   149,   -21,   -19,
+    24,   144,    95,
+   254,   -22,    60,
+   161,   196,    96,
+  -158,   -61,    48,
+   -70,    33,    82,
+   -23,  -321,    58,
+   155,  -147,     5,
+  -364,   328,    77,
+   -21,   453,   173,
+  -108,    82,   630,
+   367,   263,   208,
+  -300,   -62,  -176,
+  -205,   143,  -158,
+  -169,  -410,  -264,
+   257,  -269,  -100,
+  -636,   289,    -2,
+  -292,   627,   173,
+  -382,  -363,   387,
+   248,   524,   447,
+  -521,  -111,  -107,
+  -395,   118,  -274,
+  -343,  -680,  -125,
+  -172,  -447,  -663,
+    75,   148,  -367,
+   -79,   263,   -94,
+   249,   148,  -286,
+   380,   271,  -162,
+  -142,    -4,  -186,
+   -57,   111,  -125,
+   -35,  -108,  -254,
+   100,    29,  -242,
+   -80,   303,  -264,
+   -78,   464,   -57,
+   248,   -22,  -494,
+   661,   662,    44,
+  -193,   -40,  -330,
+  -178,   145,  -337,
+   -90,  -199,  -400,
+   -40,   -23,  -498,
+  -192,   114,   315,
+   -41,   244,   190,
+    88,   -97,   485,
+   241,    80,   212,
+  -246,    40,    87,
+  -156,   147,   134,
+    -2,  -334,   239,
+   308,  -203,   110,
+  -459,   251,   422,
+  -218,   310,   228,
+   -86,  -346,   654,
+   184,   175,   425,
+  -481,   -63,   169,
+  -349,   117,   188,
+  -125,  -560,   310,
+   158,  -416,    94,
+    46,   171,  -192,
+   -63,   157,    14,
+   256,   -35,  -271,
+   322,   123,    53,
+  -214,     4,   -76,
+  -156,    86,   -18,
+   128,  -197,  -232,
+   265,   -90,   -98,
+  -308,   332,  -145,
+  -131,   308,    58,
+   509,    59,  -339,
+   562,   196,   -14,
+  -378,   100,   -47,
+  -234,   202,     1,
+   104,  -270,  -493,
+   319,  -210,  -325};
+
+
+/*---------------------------------------------------*
+ * 2nd stage codebook; 4th split:   isf2_9 to isf2_11
+ *---------------------------------------------------*/
+
+static Word16 dico24_isf[SIZE_BK24*3] = {
+
+   -79,   -89,    -4,
+  -171,    77,  -211,
+   160,  -193,    98,
+   120,  -103,   323,
+    32,   -22,  -129,
+    72,    78,  -268,
+   182,   -76,   -66,
+   309,    99,  -145,
+  -229,  -157,   -84,
+  -383,    98,   -71,
+   -90,  -352,    12,
+  -284,  -178,   178,
+   -65,  -125,  -166,
+   -87,  -175,  -351,
+    42,  -198,   -48,
+   154,  -140,  -243,
+   -77,    18,   108,
+   -39,   355,    91,
+    87,     8,   155,
+    -4,   158,   239,
+   128,    95,   -54,
+     7,   246,  -124,
+   258,    15,    89,
+   206,   216,    98,
+  -201,     9,    18,
+  -312,   233,   204,
+   -39,  -174,   155,
+  -144,    -9,   284,
+   -57,    70,   -69,
+  -157,   187,    18,
+    54,   -30,    23,
+    24,   135,    55};
+
+
+/*---------------------------------------------------*
+ * 2nd stage codebook; 5th split:   isf2_12 to isf2_15
+ *---------------------------------------------------*/
+
+static Word16 dico25_isf[SIZE_BK25*4] = {
+
+   169,   142,  -119,   115,
+   206,   -20,    94,   226,
+  -106,   313,   -21,    16,
+   -62,   161,    71,   255,
+   -89,   101,  -185,   125,
+    72,   -30,  -201,   344,
+  -258,    33,    -8,    81,
+  -104,  -154,    72,   296,
+   144,   -68,  -268,   -25,
+    81,   -78,   -87,   106,
+    22,   155,  -186,  -119,
+   -46,   -28,    27,    91,
+  -114,   -37,  -175,   -33,
+   -94,  -222,  -189,   122,
+  -132,  -119,  -191,  -270,
+  -172,  -173,    18,   -43,
+   279,   135,   -42,  -128,
+   187,   -86,   229,  -138,
+   159,   240,   140,    46,
+    69,    25,   227,    77,
+    21,   115,    13,     8,
+    68,  -248,   126,    81,
+  -150,   137,   207,    -9,
+  -154,  -133,   289,    67,
+   143,   -37,   -86,  -326,
+   180,   -32,    19,   -23,
+    26,   168,   116,  -233,
+   -32,   -26,   118,   -78,
+     3,    -8,   -45,  -115,
+    57,  -215,   -54,   -83,
+  -209,   112,   -22,  -167,
+   -91,  -151,   168,  -262};
+
+
+
+       /* 36 bit */
+/*-------------------------------------------------------------------*
+ *  isf codebooks:  two-stage VQ with split-by-3 in 2nd stage        *
+ *                1st stage is kept the same as the 46 bit quantizer *
+ *                                                                   *
+ *  codebook   vector dimension    number of vectors                 *
+ *  ~~~~~~~~   ~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~~~~                 *
+ *     1_1            9                  256                         *
+ *     1_2            7                  256                         *
+ *     2_1            5                  128                         *
+ *     2_2            4                  128                         *
+ *     2_3            7                  64                          *
+ *-------------------------------------------------------------------*/
+
+static Word16 dico21_isf_36b[SIZE_BK21_36b*5] = {
+
+   -52,   -96,   212,   315,   -73,
+    82,  -204,   363,   136,  -197,
+  -126,  -331,   183,   218,   143,
+   -49,   -41,   557,   230,    72,
+     2,   -73,   163,   377,   221,
+   133,   111,   278,   215,  -110,
+  -102,   -20,   284,   113,   273,
+    84,   319,   290,    18,    85,
+   -25,    -5,   125,   132,  -204,
+   -38,    -5,   286,    -9,  -356,
+  -140,  -256,    92,   117,  -189,
+  -144,   191,   313,    51,   -98,
+   167,   -10,    44,   247,    36,
+   381,   197,   238,    74,     6,
+    38,  -408,    29,    -3,   -85,
+    92,   266,   157,   -25,  -200,
+   161,  -121,    70,    84,  -140,
+   -16,   -86,   112,   -94,  -189,
+  -269,  -270,   351,   107,   -24,
+   -68,   -67,   492,  -103,  -155,
+   -53,  -131,    62,   122,    10,
+   135,    84,   283,   -55,  -120,
+   -12,  -219,   331,   -81,   167,
+   220,  -136,   147,  -172,   -42,
+   140,   -95,  -109,   -88,  -194,
+     0,    -2,    -4,   -33,  -381,
+   -66,  -217,   152,  -186,  -402,
+   244,   108,   156,  -140,  -395,
+   113,  -136,  -196,   110,   -24,
+   214,   118,    11,   -64,  -131,
+  -110,  -286,    -6,  -332,    16,
+    94,    97,    79,  -291,  -205,
+    -5,   -39,   -20,   252,   -96,
+    76,   174,   101,   163,    61,
+   -69,  -239,   -55,   399,     6,
+  -115,   319,   164,   275,   196,
+   -15,    36,   -47,   331,   121,
+   226,   209,   271,   325,   184,
+    13,   -80,  -218,   471,   353,
+   288,   378,    16,   -51,   251,
+   174,   116,    52,   149,  -279,
+   235,   276,    39,   120,   -48,
+     0,  -108,  -108,   241,  -339,
+   -93,   534,    45,    33,   -87,
+   194,   149,   -71,   405,   -44,
+   409,   370,    81,  -186,  -154,
+    25,  -102,  -448,   124,  -173,
+    22,   408,  -110,  -310,  -214,
+   -26,    23,   -83,   114,    14,
+  -110,   164,    52,   223,   -82,
+    37,   -25,  -263,   306,   -15,
+  -466,   415,   292,   165,   -18,
+    29,   -19,  -171,   155,   182,
+   179,   144,   -27,   231,   258,
+  -103,  -247,  -396,   238,   113,
+   375,  -154,  -109,    -4,   156,
+    98,    85,  -292,    -5,  -124,
+   116,   139,  -116,   -98,  -294,
+   -14,   -83,  -278,  -117,  -378,
+   106,    33,  -106,  -344,  -484,
+   119,    17,  -412,   138,   166,
+   384,   101,  -204,    88,  -156,
+  -121,  -284,  -300,    -1,  -166,
+   280,    33,  -152,  -313,   -81,
+   -37,    22,   229,   153,    37,
+   -60,   -83,   236,    -8,   -41,
+  -169,  -228,   126,   -20,   363,
+  -235,    17,   364,  -156,   156,
+   -25,   -30,    72,   144,   156,
+   153,   -26,   256,    97,   144,
+   -21,   -37,    48,   -65,   250,
+    63,    77,   273,  -128,   124,
+  -129,   -26,    40,     9,  -115,
+    -6,    82,    38,   -90,  -182,
+  -336,   -13,    28,   158,    91,
+   -30,   241,   137,  -170,   -17,
+   146,    14,   -11,    33,    61,
+   192,   197,    54,   -84,    85,
+    23,  -200,   -78,   -29,   140,
+   122,   237,   106,  -341,   136,
+   -57,  -142,   -85,   -16,   -74,
+   -59,   -90,    -8,  -187,   -20,
+  -211,  -267,   216,  -179,  -110,
+   -50,    -7,   220,  -267,   -70,
+   -57,   -42,   -17,   -15,    71,
+    32,    21,    63,  -137,    33,
+  -137,  -175,   104,   -68,    97,
+   -67,   -43,   133,  -301,   221,
+  -116,  -200,   -81,   -92,  -272,
+   -64,   -41,   -54,  -244,  -220,
+  -287,  -242,   -50,   -87,   -89,
+  -245,   236,   102,  -166,  -295,
+    66,    24,  -162,   -71,    95,
+    66,   136,   -90,  -220,   -36,
+   -98,  -161,  -222,  -188,    29,
+   -18,    18,   -19,  -415,     9,
+    49,    61,   100,    39,   -56,
+  -111,    82,   135,   -31,    52,
+   -90,  -153,   -93,   189,   182,
+  -214,   295,   119,   -74,   284,
+     2,   137,    37,    47,   182,
+    92,   117,   184,   -53,   373,
+   -21,   -14,   -35,   136,   391,
+   146,   129,  -164,   -28,   333,
+    92,    80,   -84,   100,  -134,
+    -8,   217,   -32,     3,   -47,
+  -151,   251,  -215,   142,    92,
+  -224,   310,  -172,  -275,    98,
+   159,   155,  -177,   112,    53,
+   205,    27,     8,  -240,   192,
+   169,   120,  -319,  -201,   106,
+    11,    36,   -86,  -237,   455,
+  -109,  -154,  -163,   174,   -55,
+   -38,    32,  -101,   -78,   -59,
+  -205,  -321,   -97,    69,    79,
+  -310,    44,    18,  -185,    34,
+  -115,   -20,  -148,   -39,   203,
+   -29,   154,   -30,  -158,   166,
+   -45,  -131,  -317,   -24,   363,
+  -165,  -205,  -112,  -222,   265,
+   -32,   -44,  -150,    54,  -193,
+    -6,   -38,  -255,  -169,  -115,
+  -266,    87,  -189,   -36,  -169,
+   -60,   -87,  -266,  -436,  -170,
+   -68,   -81,  -278,    24,    38,
+   -23,   -19,  -155,  -256,   141,
+   -61,  -226,  -565,  -175,    71,
+     9,   -29,  -237,  -515,   263};
+
+static Word16 dico22_isf_36b[SIZE_BK22_36b*4] = {
+
+  -298,    -6,    95,    31,
+  -213,   -87,  -122,   261,
+     4,   -49,   208,    14,
+  -129,  -110,    30,   118,
+  -214,   258,   110,  -235,
+   -41,   -18,  -126,   120,
+   103,    65,   127,   -37,
+   126,   -36,   -24,    25,
+  -138,   -67,  -278,  -186,
+  -164,  -194,  -201,    78,
+  -211,   -87,   -51,  -221,
+  -174,   -79,   -94,   -39,
+    23,    -6,  -157,  -240,
+    22,  -110,  -153,   -68,
+   148,    -5,    -2,  -149,
+    -1,  -135,   -39,  -179,
+    68,   360,  -117,   -15,
+   137,    47,  -278,   146,
+   136,   260,   135,    65,
+    61,   116,   -45,    97,
+   231,   379,    87,  -120,
+   338,   177,  -272,     3,
+   266,   156,    28,   -69,
+   260,    84,   -85,    86,
+  -266,   154,  -256,  -182,
+   -17,   -65,  -304,    -6,
+   -40,   175,  -151,  -180,
+   -27,    27,   -87,   -63,
+   121,   114,  -166,  -469,
+   159,   -66,  -323,  -231,
+   214,   152,  -141,  -212,
+   137,    36,  -184,   -51,
+  -282,  -237,    40,    10,
+   -48,  -235,   -37,   251,
+   -54,  -323,   136,    29,
+   -88,  -174,   213,   198,
+  -390,    99,   -63,  -375,
+   107,  -169,  -164,   424,
+    69,  -111,   141,  -167,
+    74,  -129,    65,   144,
+  -353,  -207,  -205,  -109,
+  -160,  -386,  -355,    98,
+  -176,  -493,   -20,  -143,
+  -252,  -432,    -2,   216,
+   -90,  -174,  -168,  -411,
+    13,  -284,  -229,  -160,
+   -87,  -279,    34,  -251,
+   -75,  -263,   -58,   -42,
+   420,    53,  -211,  -358,
+   384,   -35,  -374,   396,
+    68,  -228,   323,    -2,
+   167,  -307,   192,   194,
+   459,   329,    -5,  -332,
+   375,    79,    -7,   313,
+   282,  -124,   200,   -92,
+   271,  -162,   -70,   180,
+  -157,  -298,  -514,  -309,
+    58,  -163,  -546,    18,
+   124,  -364,   167,  -238,
+    83,  -411,  -117,    96,
+   140,  -112,  -388,  -624,
+   259,  -133,  -317,    41,
+   163,  -130,   -64,  -334,
+   226,  -165,  -124,  -110,
+  -466,   -61,     6,   229,
+  -153,   205,  -145,   242,
+  -159,    48,   195,   148,
+   -58,    28,    31,   279,
+  -303,   185,   279,    -4,
+   -61,   197,    59,    86,
+  -114,   123,   168,   -52,
+    35,    36,   100,   126,
+  -407,   102,   -77,   -40,
+  -338,    -1,  -342,   156,
+  -179,   105,   -34,   -97,
+  -185,    84,   -35,   108,
+  -133,   107,   -91,  -357,
+  -180,    54,  -229,    24,
+   -44,    47,    47,  -182,
+   -66,    13,    45,     4,
+  -339,   251,    64,   226,
+   -42,   101,  -350,   275,
+   -99,   398,   142,   121,
+   111,    12,  -102,   260,
+     0,   505,   260,   -94,
+   161,   285,   -96,   224,
+    -4,   206,   314,    33,
+   167,   139,    88,   204,
+  -235,   316,   -60,   -25,
+    -8,  -150,  -312,   201,
+   -36,   292,    61,  -104,
+   -40,   174,  -162,    42,
+   -21,   402,   -29,  -351,
+    21,   152,  -360,   -93,
+    57,   191,   212,  -196,
+    76,   158,   -21,   -69,
+  -328,  -185,   331,   119,
+   -53,   285,    56,   337,
+  -107,   -24,   405,    29,
+   -18,   137,   272,   277,
+  -255,    22,   173,  -191,
+   295,   322,   325,   302,
+    21,   -27,   332,  -178,
+   119,    13,   271,   129,
+  -455,  -180,   116,  -191,
+  -227,    62,  -148,   524,
+  -176,  -287,   282,  -157,
+  -243,    13,   199,   430,
+   -59,   -49,   115,  -365,
+    72,  -172,  -137,    93,
+  -138,  -126,   141,   -84,
+     5,  -124,    38,   -20,
+  -258,   311,   601,   213,
+    94,   130,   -61,   502,
+    -1,  -157,   485,   313,
+   146,   -74,   158,   345,
+   276,   135,   280,   -57,
+   490,   252,    99,    43,
+   267,   -74,   429,   105,
+   278,   -23,   119,    94,
+  -542,   488,   257,  -115,
+   -84,  -244,  -438,   478,
+  -113,  -545,   387,   101,
+   -95,  -306,   111,   498,
+    95,   166,    22,  -301,
+   420,   -15,   -58,   -78,
+   270,    29,   122,  -282,
+   160,  -240,    50,   -38};
+
+static Word16 dico23_isf_36b[SIZE_BK23_36b*7] = {
+
+    81,   -18,    68,   -27,  -122,  -280,    -4,
+    45,  -177,   209,   -30,  -136,   -74,   131,
+   -44,   101,   -75,   -88,   -48,  -137,   -54,
+  -245,   -28,    63,   -18,  -112,  -103,    58,
+   -79,    -6,   220,   -65,   114,   -35,   -50,
+   109,   -65,   143,  -114,   129,    76,   125,
+   166,    90,   -61,  -242,   186,   -74,   -43,
+   -46,   -92,    49,  -227,    24,  -155,    39,
+    67,    85,    99,   -42,    53,  -184,  -281,
+   142,  -122,     0,    21,  -142,   -15,   -17,
+   223,    92,   -21,   -48,   -82,   -14,  -167,
+    51,   -37,  -243,   -30,   -90,    18,   -56,
+    54,   105,    74,    86,    69,    13,  -101,
+   196,    72,   -89,    43,    65,    19,    39,
+   121,    34,   131,   -82,    25,   213,  -156,
+   101,  -102,  -136,   -21,    57,   214,    22,
+    36,  -124,   205,   204,    58,  -156,   -83,
+    83,  -117,   137,   137,    85,   116,    44,
+   -92,  -148,   -68,    11,  -102,  -197,  -220,
+   -76,  -185,   -58,   132,   -26,  -183,    85,
+    -7,   -31,    -2,    23,   205,  -151,    10,
+   -27,   -37,    -5,   -18,   292,   131,     1,
+   117,  -168,     9,   -93,    80,   -59,  -125,
+  -182,  -244,    98,   -24,   135,   -22,    94,
+   221,    97,   106,    42,    43,  -160,    83,
+    25,   -64,   -21,     6,    14,   -15,   154,
+   126,    15,  -140,   150,   -10,  -207,  -114,
+    79,   -63,  -211,   -70,   -28,  -217,   165,
+    46,    38,   -22,   281,   132,   -62,   109,
+   112,    54,  -112,   -93,   208,    27,   296,
+   115,    10,  -147,    41,   216,    42,  -276,
+    50,  -115,  -254,   167,   117,    -2,    61,
+    17,   144,    34,   -72,  -186,  -150,   272,
+   -29,   -66,   -89,   -95,  -149,   129,   251,
+   122,     0,   -50,  -234,   -91,    36,    26,
+  -105,  -102,   -88,  -121,  -236,    -7,   -11,
+  -204,   109,     5,  -191,   105,   -15,   163,
+   -80,    32,   -24,  -209,    41,   294,    70,
+  -106,   -94,  -204,  -118,   120,   -50,   -37,
+   -82,  -241,    46,  -131,   -29,   150,   -55,
+    33,   155,   120,   -89,    -8,     7,    62,
+   213,    82,    61,    18,  -161,   144,   152,
+    30,   131,    65,   -87,  -255,   -17,  -107,
+    -8,    85,   -64,    51,  -162,   223,   -53,
+  -134,   261,    69,   -56,   218,    72,  -111,
+     2,   155,  -113,   -87,    49,    85,   -28,
+  -163,    42,    -1,  -196,     7,    39,  -245,
+    14,  -137,   -79,    11,  -160,   202,  -293,
+   -94,    33,   208,   100,    56,   -44,   326,
+   -78,   -41,   232,    13,  -142,   227,    80,
+   -16,   -87,   201,    33,  -133,    15,  -183,
+   -58,  -192,   -47,   184,  -128,   133,    99,
+  -205,    11,  -155,    78,    52,    72,   141,
+  -246,    26,    99,   151,    59,   115,   -64,
+   -79,   -47,   -16,   -14,     6,    47,   -43,
+   -72,  -178,   -27,   162,   112,    43,  -174,
+  -175,   238,   186,    71,   -54,  -188,   -76,
+  -225,   233,    39,   -39,  -158,   122,    44,
+   -26,    43,    84,   130,   -93,   -51,    22,
+     3,    92,  -150,   136,  -182,   -57,    97,
+  -131,   179,   -78,    80,    91,  -165,    90,
+    -2,   148,    15,   130,    65,   175,   117,
+  -138,   114,  -137,   132,     3,   -10,  -186,
+   140,    -4,   -37,   254,   -62,    92,  -109};
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/stream.h b/media/libstagefright/codecs/amrwbenc/inc/stream.h
index edbc13a..4c1d0f0 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/stream.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/stream.h
@@ -1,47 +1,47 @@
-
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/***********************************************************************
-File:		stream.h
-
-Contains:       VOME API Buffer Operator Implement Header
-
-************************************************************************/
-#ifndef __STREAM_H__
-#define __STREAM_H__
-
-#include "voMem.h"
-#define Frame_Maxsize  1024 * 2  //Work Buffer 10K 
-#define Frame_MaxByte  640        //AMR_WB Encoder one frame 320 samples = 640 Bytes
-#define MIN(a,b)	 ((a) < (b)? (a) : (b))
-
-typedef struct{
-	unsigned char *set_ptr;
-	unsigned char *frame_ptr;
-	unsigned char *frame_ptr_bk;
-	int  set_len;
-	int  framebuffer_len; 
-	int  frame_storelen;
-	int  used_len;
-}FrameStream;
-
-void voAWB_UpdateFrameBuffer(FrameStream *stream, VO_MEM_OPERATOR *pMemOP);
-void voAWB_InitFrameBuffer(FrameStream *stream);
-void voAWB_FlushFrameBuffer(FrameStream *stream);
-#endif //__STREAM_H__
-
+
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/***********************************************************************
+File:		stream.h
+
+Contains:       VOME API Buffer Operator Implement Header
+
+************************************************************************/
+#ifndef __STREAM_H__
+#define __STREAM_H__
+
+#include "voMem.h"
+#define Frame_Maxsize  1024 * 2  //Work Buffer 10K
+#define Frame_MaxByte  640        //AMR_WB Encoder one frame 320 samples = 640 Bytes
+#define MIN(a,b)	 ((a) < (b)? (a) : (b))
+
+typedef struct{
+	unsigned char *set_ptr;
+	unsigned char *frame_ptr;
+	unsigned char *frame_ptr_bk;
+	int  set_len;
+	int  framebuffer_len;
+	int  frame_storelen;
+	int  used_len;
+}FrameStream;
+
+void voAWB_UpdateFrameBuffer(FrameStream *stream, VO_MEM_OPERATOR *pMemOP);
+void voAWB_InitFrameBuffer(FrameStream *stream);
+void voAWB_FlushFrameBuffer(FrameStream *stream);
+#endif //__STREAM_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/typedef.h b/media/libstagefright/codecs/amrwbenc/inc/typedef.h
index aa8c098..f08a678 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/typedef.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/typedef.h
@@ -1,65 +1,65 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*
-*      File             : typedef.c
-*      Purpose          : Basic types.
-*
-************************************************************************/
-
-#ifndef __TYPEDEF_H__
-#define __TYPEDEF_H__
-
-#undef ORIGINAL_TYPEDEF_H /* define to get "original" ETSI version
-                             of typedef.h                           */
-
-#ifdef ORIGINAL_TYPEDEF_H
-/*
- * this is the original code from the ETSI file typedef.h
- */
-   
-#if defined(__BORLANDC__) || defined(__WATCOMC__) || defined(_MSC_VER) || defined(__ZTC__)
-typedef signed char Word8;
-typedef short Word16;
-typedef long Word32;
-typedef int Flag;
-
-#elif defined(__sun)
-typedef signed char Word8;
-typedef short Word16;
-typedef long Word32;
-typedef int Flag;
-
-#elif defined(__unix__) || defined(__unix)
-typedef signed char Word8;
-typedef short Word16;
-typedef int Word32;
-typedef int Flag;
-
-#endif
-#else /* not original typedef.h */
-
-/*
- * use (improved) type definition file typdefs.h and add a "Flag" type
- */
-#include "typedefs.h"
-typedef int Flag;
-
-#endif
-
-#endif  //__TYPEDEF_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*
+*      File             : typedef.c
+*      Purpose          : Basic types.
+*
+************************************************************************/
+
+#ifndef __TYPEDEF_H__
+#define __TYPEDEF_H__
+
+#undef ORIGINAL_TYPEDEF_H /* define to get "original" ETSI version
+                             of typedef.h                           */
+
+#ifdef ORIGINAL_TYPEDEF_H
+/*
+ * this is the original code from the ETSI file typedef.h
+ */
+
+#if defined(__BORLANDC__) || defined(__WATCOMC__) || defined(_MSC_VER) || defined(__ZTC__)
+typedef signed char Word8;
+typedef short Word16;
+typedef long Word32;
+typedef int Flag;
+
+#elif defined(__sun)
+typedef signed char Word8;
+typedef short Word16;
+typedef long Word32;
+typedef int Flag;
+
+#elif defined(__unix__) || defined(__unix)
+typedef signed char Word8;
+typedef short Word16;
+typedef int Word32;
+typedef int Flag;
+
+#endif
+#else /* not original typedef.h */
+
+/*
+ * use (improved) type definition file typdefs.h and add a "Flag" type
+ */
+#include "typedefs.h"
+typedef int Flag;
+
+#endif
+
+#endif  //__TYPEDEF_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/typedefs.h b/media/libstagefright/codecs/amrwbenc/inc/typedefs.h
index 28b657e..0062584 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/typedefs.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/typedefs.h
@@ -1,211 +1,211 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/*
-*
-*      File             : typedefs.h
-*      Description      : Definition of platform independent data
-*                         types and constants
-*
-*
-*      The following platform independent data types and corresponding
-*      preprocessor (#define) constants are defined:
-*
-*        defined type  meaning           corresponding constants
-*        ----------------------------------------------------------
-*        Char          character         (none)
-*        Bool          boolean           true, false
-*        Word8         8-bit signed      minWord8,   maxWord8
-*        UWord8        8-bit unsigned    minUWord8,  maxUWord8
-*        Word16        16-bit signed     minWord16,  maxWord16
-*        UWord16       16-bit unsigned   minUWord16, maxUWord16
-*        Word32        32-bit signed     minWord32,  maxWord32
-*        UWord32       32-bit unsigned   minUWord32, maxUWord32
-*        Float         floating point    minFloat,   maxFloat
-*
-*
-*      The following compile switches are #defined:
-*
-*        PLATFORM      string indicating platform progam is compiled on
-*                      possible values: "OSF", "PC", "SUN"
-*
-*        OSF           only defined if the current platform is an Alpha
-*        PC            only defined if the current platform is a PC
-*        SUN           only defined if the current platform is a Sun
-*        
-*        LSBFIRST      is defined if the byte order on this platform is
-*                      "least significant byte first" -> defined on DEC Alpha
-*                      and PC, undefined on Sun
-*
-********************************************************************************
-*/
-
-#ifndef __TYPEDEFS_H__
-#define __TYPEDEFS_H__
-
-/*
-********************************************************************************
-*                         INCLUDE FILES
-********************************************************************************
-*/
-#include <float.h>
-#include <limits.h>
-
-
-
-/*
-********************************************************************************
-*                         DEFINITION OF CONSTANTS 
-********************************************************************************
-*/
-/*
- ********* define char type
- */
-typedef char Char;
-
-/*
- ********* define 8 bit signed/unsigned types & constants
- */
-#if SCHAR_MAX == 127
-typedef signed char Word8;
-#define minWord8  SCHAR_MIN
-#define maxWord8  SCHAR_MAX
-
-typedef unsigned char UWord8;
-#define minUWord8 0
-#define maxUWord8 UCHAR_MAX
-#else
-#error cannot find 8-bit type
-#endif
-
-
-/*
- ********* define 16 bit signed/unsigned types & constants
- */
-#if INT_MAX == 32767
-typedef int Word16;
-#define minWord16     INT_MIN
-#define maxWord16     INT_MAX
-typedef unsigned int UWord16;
-#define minUWord16    0
-#define maxUWord16    UINT_MAX
-#elif SHRT_MAX == 32767
-typedef short Word16;
-#define minWord16     SHRT_MIN
-#define maxWord16     SHRT_MAX
-typedef unsigned short UWord16;
-#define minUWord16    0
-#define maxUWord16    USHRT_MAX
-#else
-#error cannot find 16-bit type
-#endif
-
-
-/*
- ********* define 32 bit signed/unsigned types & constants
- */
-#if INT_MAX == 2147483647
-typedef int Word32;
-#define minWord32     INT_MIN
-#define maxWord32     INT_MAX
-typedef unsigned int UWord32;
-#define minUWord32    0
-#define maxUWord32    UINT_MAX
-#elif LONG_MAX == 2147483647
-typedef long Word32;
-#define minWord32     LONG_MIN
-#define maxWord32     LONG_MAX
-typedef unsigned long UWord32;
-#define minUWord32    0
-#define maxUWord32    ULONG_MAX
-#else
-#error cannot find 32-bit type
-#endif
-
-/*
- ********* define floating point type & constants
- */
-/* use "#if 0" below if Float should be double;
-   use "#if 1" below if Float should be float
- */
-#if 0
-typedef float Float;
-#define maxFloat      FLT_MAX
-#define minFloat      FLT_MIN
-#else
-typedef double Float;
-#define maxFloat      DBL_MAX
-#define minFloat      DBL_MIN
-#endif
-
-/*
- ********* define complex type
- */
-typedef struct {
-  Float r;  /* real      part */
-  Float i;  /* imaginary part */
-} CPX;
-
-/*
- ********* define boolean type
- */
-typedef int Bool;
-#define false 0
-#define true 1
-
-/* ******Avoid function multiple definition****** */
-#define     Autocorr         voAWB_Autocorr
-#define     Convolve         voAWB_Convolve
-#define     cor_h_x          voAWB_cor_h_x
-#define     dtx_enc_init     voAWB_dtx_enc_init
-#define     dtx_enc_reset    voAWB_dtx_enc_reset
-#define     dtx_enc_exit     voAWB_dtx_enc_exit
-#define     dtx_enc          voAWB_dtx_enc
-#define     dtx_buffer       voAWB_dtx_buffer
-#define     tx_dtx_handler   voAWB_tx_dtx_handler
-#define     G_pitch          voAWB_G_pitch
-#define     Isp_Az           voAWB_Isp_Az
-#define     Lag_window       voAWB_Lag_window
-#define     Log2_norm        voAWB_Log2_norm
-#define     Log2             voAWB_Log2
-#define     Pow2             voAWB_Pow2
-#define     L_Comp           voAWB_L_Comp
-#define     Mpy_32           voAWB_Mpy_32
-#define     Mpy_32_16        voAWB_Mpy_32_16
-#define     Div_32           voAWB_Div_32
-#define     Pit_shrp         voAWB_Pit_shrp
-#define     Qisf_ns          voAWB_Qisf_ns
-#define     Disf_ns          voAWB_Disf_ns
-#define     Residu           voAWB_Residu
-#define     Syn_filt         voAWB_Syn_filt
-#define     Set_zero         voAWB_Set_zero
-#define     Copy             voAWB_Copy
-#define     voice_factor     voAWB_voice_factor
-#define     Syn_filt_32      voAWB_Syn_filt_32
-#define     Isf_isp          voAWB_Isf_isp
-#define     Levinson         voAWB_Levinson
-#define     median5          voAWB_median5           
-#define     Pred_lt4         voAWB_Pred_lt4
-#define     Reorder_isf      voAWB_Reorder_isf
-#define     Dpisf_2s_36b     voAWB_Dpisf_2s_36b
-#define     Dpisf_2s_46b     voAWB_Dpisf_2s_46b
-#define     Dot_product12    voAWB_Dot_product12
-#define     mem_malloc       voAWB_mem_malloc
-#define     mem_free         voAWB_mem_free
-/******************************************************/
-
-#endif  //#define __TYPEDEFS_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/*
+*
+*      File             : typedefs.h
+*      Description      : Definition of platform independent data
+*                         types and constants
+*
+*
+*      The following platform independent data types and corresponding
+*      preprocessor (#define) constants are defined:
+*
+*        defined type  meaning           corresponding constants
+*        ----------------------------------------------------------
+*        Char          character         (none)
+*        Bool          boolean           true, false
+*        Word8         8-bit signed      minWord8,   maxWord8
+*        UWord8        8-bit unsigned    minUWord8,  maxUWord8
+*        Word16        16-bit signed     minWord16,  maxWord16
+*        UWord16       16-bit unsigned   minUWord16, maxUWord16
+*        Word32        32-bit signed     minWord32,  maxWord32
+*        UWord32       32-bit unsigned   minUWord32, maxUWord32
+*        Float         floating point    minFloat,   maxFloat
+*
+*
+*      The following compile switches are #defined:
+*
+*        PLATFORM      string indicating platform progam is compiled on
+*                      possible values: "OSF", "PC", "SUN"
+*
+*        OSF           only defined if the current platform is an Alpha
+*        PC            only defined if the current platform is a PC
+*        SUN           only defined if the current platform is a Sun
+*
+*        LSBFIRST      is defined if the byte order on this platform is
+*                      "least significant byte first" -> defined on DEC Alpha
+*                      and PC, undefined on Sun
+*
+********************************************************************************
+*/
+
+#ifndef __TYPEDEFS_H__
+#define __TYPEDEFS_H__
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <float.h>
+#include <limits.h>
+
+
+
+/*
+********************************************************************************
+*                         DEFINITION OF CONSTANTS
+********************************************************************************
+*/
+/*
+ ********* define char type
+ */
+typedef char Char;
+
+/*
+ ********* define 8 bit signed/unsigned types & constants
+ */
+#if SCHAR_MAX == 127
+typedef signed char Word8;
+#define minWord8  SCHAR_MIN
+#define maxWord8  SCHAR_MAX
+
+typedef unsigned char UWord8;
+#define minUWord8 0
+#define maxUWord8 UCHAR_MAX
+#else
+#error cannot find 8-bit type
+#endif
+
+
+/*
+ ********* define 16 bit signed/unsigned types & constants
+ */
+#if INT_MAX == 32767
+typedef int Word16;
+#define minWord16     INT_MIN
+#define maxWord16     INT_MAX
+typedef unsigned int UWord16;
+#define minUWord16    0
+#define maxUWord16    UINT_MAX
+#elif SHRT_MAX == 32767
+typedef short Word16;
+#define minWord16     SHRT_MIN
+#define maxWord16     SHRT_MAX
+typedef unsigned short UWord16;
+#define minUWord16    0
+#define maxUWord16    USHRT_MAX
+#else
+#error cannot find 16-bit type
+#endif
+
+
+/*
+ ********* define 32 bit signed/unsigned types & constants
+ */
+#if INT_MAX == 2147483647
+typedef int Word32;
+#define minWord32     INT_MIN
+#define maxWord32     INT_MAX
+typedef unsigned int UWord32;
+#define minUWord32    0
+#define maxUWord32    UINT_MAX
+#elif LONG_MAX == 2147483647
+typedef long Word32;
+#define minWord32     LONG_MIN
+#define maxWord32     LONG_MAX
+typedef unsigned long UWord32;
+#define minUWord32    0
+#define maxUWord32    ULONG_MAX
+#else
+#error cannot find 32-bit type
+#endif
+
+/*
+ ********* define floating point type & constants
+ */
+/* use "#if 0" below if Float should be double;
+   use "#if 1" below if Float should be float
+ */
+#if 0
+typedef float Float;
+#define maxFloat      FLT_MAX
+#define minFloat      FLT_MIN
+#else
+typedef double Float;
+#define maxFloat      DBL_MAX
+#define minFloat      DBL_MIN
+#endif
+
+/*
+ ********* define complex type
+ */
+typedef struct {
+  Float r;  /* real      part */
+  Float i;  /* imaginary part */
+} CPX;
+
+/*
+ ********* define boolean type
+ */
+typedef int Bool;
+#define false 0
+#define true 1
+
+/* ******Avoid function multiple definition****** */
+#define     Autocorr         voAWB_Autocorr
+#define     Convolve         voAWB_Convolve
+#define     cor_h_x          voAWB_cor_h_x
+#define     dtx_enc_init     voAWB_dtx_enc_init
+#define     dtx_enc_reset    voAWB_dtx_enc_reset
+#define     dtx_enc_exit     voAWB_dtx_enc_exit
+#define     dtx_enc          voAWB_dtx_enc
+#define     dtx_buffer       voAWB_dtx_buffer
+#define     tx_dtx_handler   voAWB_tx_dtx_handler
+#define     G_pitch          voAWB_G_pitch
+#define     Isp_Az           voAWB_Isp_Az
+#define     Lag_window       voAWB_Lag_window
+#define     Log2_norm        voAWB_Log2_norm
+#define     Log2             voAWB_Log2
+#define     Pow2             voAWB_Pow2
+#define     L_Comp           voAWB_L_Comp
+#define     Mpy_32           voAWB_Mpy_32
+#define     Mpy_32_16        voAWB_Mpy_32_16
+#define     Div_32           voAWB_Div_32
+#define     Pit_shrp         voAWB_Pit_shrp
+#define     Qisf_ns          voAWB_Qisf_ns
+#define     Disf_ns          voAWB_Disf_ns
+#define     Residu           voAWB_Residu
+#define     Syn_filt         voAWB_Syn_filt
+#define     Set_zero         voAWB_Set_zero
+#define     Copy             voAWB_Copy
+#define     voice_factor     voAWB_voice_factor
+#define     Syn_filt_32      voAWB_Syn_filt_32
+#define     Isf_isp          voAWB_Isf_isp
+#define     Levinson         voAWB_Levinson
+#define     median5          voAWB_median5
+#define     Pred_lt4         voAWB_Pred_lt4
+#define     Reorder_isf      voAWB_Reorder_isf
+#define     Dpisf_2s_36b     voAWB_Dpisf_2s_36b
+#define     Dpisf_2s_46b     voAWB_Dpisf_2s_46b
+#define     Dot_product12    voAWB_Dot_product12
+#define     mem_malloc       voAWB_mem_malloc
+#define     mem_free         voAWB_mem_free
+/******************************************************/
+
+#endif  //#define __TYPEDEFS_H__
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/wb_vad.h b/media/libstagefright/codecs/amrwbenc/inc/wb_vad.h
index b733afe..6822f48 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/wb_vad.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/wb_vad.h
@@ -1,78 +1,78 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*-------------------------------------------------------------------*
- *                         WB_VAD.H                                  *
- *-------------------------------------------------------------------*
- * Functions and static memory for Voice Activity Detection.         *
- *-------------------------------------------------------------------*/
-
-#ifndef __WB_VAD_H__
-#define __WB_VAD_H__
-
-/******************************************************************************
- *                         INCLUDE FILES
- ******************************************************************************/
-#include "typedef.h"
-#include "wb_vad_c.h"
-#include "voMem.h"
-
-/******************************************************************************
- *                         DEFINITION OF DATA TYPES
- ******************************************************************************/
-
-typedef struct
-{
-	Word16 bckr_est[COMPLEN];              /* background noise estimate                */
-	Word16 ave_level[COMPLEN];             /* averaged input components for stationary */
-	/* estimation                               */
-	Word16 old_level[COMPLEN];             /* input levels of the previous frame       */
-	Word16 sub_level[COMPLEN];             /* input levels calculated at the end of a frame (lookahead)  */
-	Word16 a_data5[F_5TH_CNT][2];          /* memory for the filter bank               */
-	Word16 a_data3[F_3TH_CNT];             /* memory for the filter bank               */
-
-	Word16 burst_count;                    /* counts length of a speech burst          */
-	Word16 hang_count;                     /* hangover counter                         */
-	Word16 stat_count;                     /* stationary counter                       */
-
-	/* Note that each of the following two variables holds 15 flags. Each flag reserves 1 bit of the
-	 * variable. The newest flag is in the bit 15 (assuming that LSB is bit 1 and MSB is bit 16). */
-	Word16 vadreg;                         /* flags for intermediate VAD decisions     */
-	Word16 tone_flag;                      /* tone detection flags                     */
-
-	Word16 sp_est_cnt;                     /* counter for speech level estimation      */
-	Word16 sp_max;                         /* maximum level                            */
-	Word16 sp_max_cnt;                     /* counts frames that contains speech       */
-	Word16 speech_level;                   /* estimated speech level                   */
-	Word32 prev_pow_sum;                   /* power of previous frame                  */
-
-} VadVars;
-
-/********************************************************************************
- *
- * DECLARATION OF PROTOTYPES
- ********************************************************************************/
-
-Word16 wb_vad_init(VadVars ** st, VO_MEM_OPERATOR *pMemOP);
-Word16 wb_vad_reset(VadVars * st);
-void wb_vad_exit(VadVars ** st, VO_MEM_OPERATOR *pMemOP);
-void wb_vad_tone_detection(VadVars * st, Word16 p_gain);
-Word16 wb_vad(VadVars * st, Word16 in_buf[]);
-
-#endif  //__WB_VAD_H__
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*-------------------------------------------------------------------*
+ *                         WB_VAD.H                                  *
+ *-------------------------------------------------------------------*
+ * Functions and static memory for Voice Activity Detection.         *
+ *-------------------------------------------------------------------*/
+
+#ifndef __WB_VAD_H__
+#define __WB_VAD_H__
+
+/******************************************************************************
+ *                         INCLUDE FILES
+ ******************************************************************************/
+#include "typedef.h"
+#include "wb_vad_c.h"
+#include "voMem.h"
+
+/******************************************************************************
+ *                         DEFINITION OF DATA TYPES
+ ******************************************************************************/
+
+typedef struct
+{
+	Word16 bckr_est[COMPLEN];              /* background noise estimate                */
+	Word16 ave_level[COMPLEN];             /* averaged input components for stationary */
+	/* estimation                               */
+	Word16 old_level[COMPLEN];             /* input levels of the previous frame       */
+	Word16 sub_level[COMPLEN];             /* input levels calculated at the end of a frame (lookahead)  */
+	Word16 a_data5[F_5TH_CNT][2];          /* memory for the filter bank               */
+	Word16 a_data3[F_3TH_CNT];             /* memory for the filter bank               */
+
+	Word16 burst_count;                    /* counts length of a speech burst          */
+	Word16 hang_count;                     /* hangover counter                         */
+	Word16 stat_count;                     /* stationary counter                       */
+
+	/* Note that each of the following two variables holds 15 flags. Each flag reserves 1 bit of the
+	 * variable. The newest flag is in the bit 15 (assuming that LSB is bit 1 and MSB is bit 16). */
+	Word16 vadreg;                         /* flags for intermediate VAD decisions     */
+	Word16 tone_flag;                      /* tone detection flags                     */
+
+	Word16 sp_est_cnt;                     /* counter for speech level estimation      */
+	Word16 sp_max;                         /* maximum level                            */
+	Word16 sp_max_cnt;                     /* counts frames that contains speech       */
+	Word16 speech_level;                   /* estimated speech level                   */
+	Word32 prev_pow_sum;                   /* power of previous frame                  */
+
+} VadVars;
+
+/********************************************************************************
+ *
+ * DECLARATION OF PROTOTYPES
+ ********************************************************************************/
+
+Word16 wb_vad_init(VadVars ** st, VO_MEM_OPERATOR *pMemOP);
+Word16 wb_vad_reset(VadVars * st);
+void wb_vad_exit(VadVars ** st, VO_MEM_OPERATOR *pMemOP);
+void wb_vad_tone_detection(VadVars * st, Word16 p_gain);
+Word16 wb_vad(VadVars * st, Word16 in_buf[]);
+
+#endif  //__WB_VAD_H__
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/inc/wb_vad_c.h b/media/libstagefright/codecs/amrwbenc/inc/wb_vad_c.h
index 39ef506..04fd318 100644
--- a/media/libstagefright/codecs/amrwbenc/inc/wb_vad_c.h
+++ b/media/libstagefright/codecs/amrwbenc/inc/wb_vad_c.h
@@ -1,109 +1,109 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/*-------------------------------------------------------------------*
- *                         WB_VAD_C.H				     *
- *-------------------------------------------------------------------*
- * Constants for Voice Activity Detection.			     *
- *-------------------------------------------------------------------*/
-
-#ifndef __WB_VAD_C_H__
-#define __WB_VAD_C_H__
-
-#define FRAME_LEN 256                      /* Length (samples) of the input frame          */
-#define COMPLEN 12                         /* Number of sub-bands used by VAD              */
-
-#define UNIRSHFT 7                         /* = log2(MAX_16/UNITY), UNITY = 256      */
-#define SCALE 128                          /* (UNITY*UNITY)/512 */
-
-#define TONE_THR (Word16)(0.65*MAX_16)     /* Threshold for tone detection   */
-
-/* constants for speech level estimation */
-#define SP_EST_COUNT 80
-#define SP_ACTIVITY_COUNT 25
-#define ALPHA_SP_UP (Word16)((1.0 - 0.85)*MAX_16)
-#define ALPHA_SP_DOWN (Word16)((1.0 - 0.85)*MAX_16)
-
-#define NOM_LEVEL 2050                     /* about -26 dBov Q15 */
-#define SPEECH_LEVEL_INIT NOM_LEVEL        /* initial speech level */
-#define MIN_SPEECH_LEVEL1  (Word16)(NOM_LEVEL * 0.063)  /* NOM_LEVEL -24 dB */
-#define MIN_SPEECH_LEVEL2  (Word16)(NOM_LEVEL * 0.2)    /* NOM_LEVEL -14 dB */
-#define MIN_SPEECH_SNR 4096                /* 0 dB, lowest SNR estimation, Q12 */
-
-/* Time constants for background spectrum update */
-#define ALPHA_UP1   (Word16)((1.0 - 0.95)*MAX_16)       /* Normal update, upwards:   */
-#define ALPHA_DOWN1 (Word16)((1.0 - 0.936)*MAX_16)      /* Normal update, downwards  */
-#define ALPHA_UP2   (Word16)((1.0 - 0.985)*MAX_16)      /* Forced update, upwards    */
-#define ALPHA_DOWN2 (Word16)((1.0 - 0.943)*MAX_16)      /* Forced update, downwards  */
-#define ALPHA3      (Word16)((1.0 - 0.95)*MAX_16)       /* Update downwards          */
-#define ALPHA4      (Word16)((1.0 - 0.9)*MAX_16)        /* For stationary estimation */
-#define ALPHA5      (Word16)((1.0 - 0.5)*MAX_16)        /* For stationary estimation */
-
-/* Constants for VAD threshold */
-#define THR_MIN  (Word16)(1.6*SCALE)       /* Minimum threshold               */
-#define THR_HIGH (Word16)(6*SCALE)         /* Highest threshold               */
-#define THR_LOW (Word16)(1.7*SCALE)        /* Lowest threshold               */
-#define NO_P1 31744                        /* ilog2(1), Noise level for highest threshold */
-#define NO_P2 19786                        /* ilog2(0.1*MAX_16), Noise level for lowest threshold */
-#define NO_SLOPE (Word16)(MAX_16*(float)(THR_LOW-THR_HIGH)/(float)(NO_P2-NO_P1))
-
-#define SP_CH_MIN (Word16)(-0.75*SCALE)
-#define SP_CH_MAX (Word16)(0.75*SCALE)
-#define SP_P1 22527                        /* ilog2(NOM_LEVEL/4) */
-#define SP_P2 17832                        /* ilog2(NOM_LEVEL*4) */
-#define SP_SLOPE (Word16)(MAX_16*(float)(SP_CH_MAX-SP_CH_MIN)/(float)(SP_P2-SP_P1))
-
-/* Constants for hangover length */
-#define HANG_HIGH  12                      /* longest hangover               */
-#define HANG_LOW  2                        /* shortest hangover               */
-#define HANG_P1 THR_LOW                    /* threshold for longest hangover */
-#define HANG_P2 (Word16)(4*SCALE)          /* threshold for shortest hangover */
-#define HANG_SLOPE (Word16)(MAX_16*(float)(HANG_LOW-HANG_HIGH)/(float)(HANG_P2-HANG_P1))
-
-/* Constants for burst length */
-#define BURST_HIGH 8                       /* longest burst length         */
-#define BURST_LOW 3                        /* shortest burst length        */
-#define BURST_P1 THR_HIGH                  /* threshold for longest burst */
-#define BURST_P2 THR_LOW                   /* threshold for shortest burst */
-#define BURST_SLOPE (Word16)(MAX_16*(float)(BURST_LOW-BURST_HIGH)/(float)(BURST_P2-BURST_P1))
-
-/* Parameters for background spectrum recovery function */
-#define STAT_COUNT 20                      /* threshold of stationary detection counter         */
-
-#define STAT_THR_LEVEL 184                 /* Threshold level for stationarity detection        */
-#define STAT_THR 1000                      /* Threshold for stationarity detection              */
-
-/* Limits for background noise estimate */
-#define NOISE_MIN 40                       /* minimum */
-#define NOISE_MAX 20000                    /* maximum */
-#define NOISE_INIT 150                     /* initial */
-
-/* Thresholds for signal power (now calculated on 2 frames) */
-#define VAD_POW_LOW (Word32)30000L         /* If input power is lower than this, VAD is set to 0 */
-#define POW_TONE_THR (Word32)686080L       /* If input power is lower,tone detection flag is ignored */
-
-/* Constants for the filter bank */
-#define COEFF3   13363                     /* coefficient for the 3rd order filter     */
-#define COEFF5_1 21955                     /* 1st coefficient the for 5th order filter */
-#define COEFF5_2 6390                      /* 2nd coefficient the for 5th order filter */
-#define F_5TH_CNT 5                        /* number of 5th order filters */
-#define F_3TH_CNT 6                        /* number of 3th order filters */
-
-#endif   //__WB_VAD_C_H__
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/*-------------------------------------------------------------------*
+ *                         WB_VAD_C.H				     *
+ *-------------------------------------------------------------------*
+ * Constants for Voice Activity Detection.			     *
+ *-------------------------------------------------------------------*/
+
+#ifndef __WB_VAD_C_H__
+#define __WB_VAD_C_H__
+
+#define FRAME_LEN 256                      /* Length (samples) of the input frame          */
+#define COMPLEN 12                         /* Number of sub-bands used by VAD              */
+
+#define UNIRSHFT 7                         /* = log2(MAX_16/UNITY), UNITY = 256      */
+#define SCALE 128                          /* (UNITY*UNITY)/512 */
+
+#define TONE_THR (Word16)(0.65*MAX_16)     /* Threshold for tone detection   */
+
+/* constants for speech level estimation */
+#define SP_EST_COUNT 80
+#define SP_ACTIVITY_COUNT 25
+#define ALPHA_SP_UP (Word16)((1.0 - 0.85)*MAX_16)
+#define ALPHA_SP_DOWN (Word16)((1.0 - 0.85)*MAX_16)
+
+#define NOM_LEVEL 2050                     /* about -26 dBov Q15 */
+#define SPEECH_LEVEL_INIT NOM_LEVEL        /* initial speech level */
+#define MIN_SPEECH_LEVEL1  (Word16)(NOM_LEVEL * 0.063)  /* NOM_LEVEL -24 dB */
+#define MIN_SPEECH_LEVEL2  (Word16)(NOM_LEVEL * 0.2)    /* NOM_LEVEL -14 dB */
+#define MIN_SPEECH_SNR 4096                /* 0 dB, lowest SNR estimation, Q12 */
+
+/* Time constants for background spectrum update */
+#define ALPHA_UP1   (Word16)((1.0 - 0.95)*MAX_16)       /* Normal update, upwards:   */
+#define ALPHA_DOWN1 (Word16)((1.0 - 0.936)*MAX_16)      /* Normal update, downwards  */
+#define ALPHA_UP2   (Word16)((1.0 - 0.985)*MAX_16)      /* Forced update, upwards    */
+#define ALPHA_DOWN2 (Word16)((1.0 - 0.943)*MAX_16)      /* Forced update, downwards  */
+#define ALPHA3      (Word16)((1.0 - 0.95)*MAX_16)       /* Update downwards          */
+#define ALPHA4      (Word16)((1.0 - 0.9)*MAX_16)        /* For stationary estimation */
+#define ALPHA5      (Word16)((1.0 - 0.5)*MAX_16)        /* For stationary estimation */
+
+/* Constants for VAD threshold */
+#define THR_MIN  (Word16)(1.6*SCALE)       /* Minimum threshold               */
+#define THR_HIGH (Word16)(6*SCALE)         /* Highest threshold               */
+#define THR_LOW (Word16)(1.7*SCALE)        /* Lowest threshold               */
+#define NO_P1 31744                        /* ilog2(1), Noise level for highest threshold */
+#define NO_P2 19786                        /* ilog2(0.1*MAX_16), Noise level for lowest threshold */
+#define NO_SLOPE (Word16)(MAX_16*(float)(THR_LOW-THR_HIGH)/(float)(NO_P2-NO_P1))
+
+#define SP_CH_MIN (Word16)(-0.75*SCALE)
+#define SP_CH_MAX (Word16)(0.75*SCALE)
+#define SP_P1 22527                        /* ilog2(NOM_LEVEL/4) */
+#define SP_P2 17832                        /* ilog2(NOM_LEVEL*4) */
+#define SP_SLOPE (Word16)(MAX_16*(float)(SP_CH_MAX-SP_CH_MIN)/(float)(SP_P2-SP_P1))
+
+/* Constants for hangover length */
+#define HANG_HIGH  12                      /* longest hangover               */
+#define HANG_LOW  2                        /* shortest hangover               */
+#define HANG_P1 THR_LOW                    /* threshold for longest hangover */
+#define HANG_P2 (Word16)(4*SCALE)          /* threshold for shortest hangover */
+#define HANG_SLOPE (Word16)(MAX_16*(float)(HANG_LOW-HANG_HIGH)/(float)(HANG_P2-HANG_P1))
+
+/* Constants for burst length */
+#define BURST_HIGH 8                       /* longest burst length         */
+#define BURST_LOW 3                        /* shortest burst length        */
+#define BURST_P1 THR_HIGH                  /* threshold for longest burst */
+#define BURST_P2 THR_LOW                   /* threshold for shortest burst */
+#define BURST_SLOPE (Word16)(MAX_16*(float)(BURST_LOW-BURST_HIGH)/(float)(BURST_P2-BURST_P1))
+
+/* Parameters for background spectrum recovery function */
+#define STAT_COUNT 20                      /* threshold of stationary detection counter         */
+
+#define STAT_THR_LEVEL 184                 /* Threshold level for stationarity detection        */
+#define STAT_THR 1000                      /* Threshold for stationarity detection              */
+
+/* Limits for background noise estimate */
+#define NOISE_MIN 40                       /* minimum */
+#define NOISE_MAX 20000                    /* maximum */
+#define NOISE_INIT 150                     /* initial */
+
+/* Thresholds for signal power (now calculated on 2 frames) */
+#define VAD_POW_LOW (Word32)30000L         /* If input power is lower than this, VAD is set to 0 */
+#define POW_TONE_THR (Word32)686080L       /* If input power is lower,tone detection flag is ignored */
+
+/* Constants for the filter bank */
+#define COEFF3   13363                     /* coefficient for the 3rd order filter     */
+#define COEFF5_1 21955                     /* 1st coefficient the for 5th order filter */
+#define COEFF5_2 6390                      /* 2nd coefficient the for 5th order filter */
+#define F_5TH_CNT 5                        /* number of 5th order filters */
+#define F_3TH_CNT 6                        /* number of 3th order filters */
+
+#endif   //__WB_VAD_C_H__
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Deemph_32_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Deemph_32_opt.s
index 0eb5e9f..282db92 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Deemph_32_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Deemph_32_opt.s
@@ -1,104 +1,104 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@void Deemph_32(
-@     Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
-@     Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
-@     Word16 y[],                           /* (o)     : output signal (x16)      */
-@     Word16 mu,                            /* (i) Q15 : deemphasis factor        */
-@     Word16 L,                             /* (i)     : vector size              */
-@     Word16 * mem                          /* (i/o)   : memory (y[-1])           */
-@     )
-
-@x_hi     RN      R0
-@x_lo     RN      R1
-@y[]      RN      R2
-@*mem     RN      R3
-
-           .section  .text
-           .global   Deemph_32_asm
-	   
-Deemph_32_asm:
-
-           STMFD   	r13!, {r4 - r12, r14} 
-	   MOV          r4, #2                   @i=0
-	   LDRSH        r6, [r0], #2             @load x_hi[0]
-	   LDRSH        r7, [r1], #2             @load x_lo[0]
-	   LDR          r5, =22282               @r5---mu
-	   MOV          r11, #0x8000
-
-           @y[0]
-	   MOV          r10, r6, LSL #16         @L_tmp = x_hi[0]<<16
-	   MOV          r8,  r5, ASR #1          @fac = mu >> 1
-	   LDR          r5,  [r3]
-	   ADD          r12, r10, r7, LSL #4     @L_tmp += x_lo[0] << 4
-	   MOV          r10, r12, LSL #3         @L_tmp <<= 3
-	   MUL          r9, r5, r8
-	   LDRSH        r6, [r0], #2             @load x_hi[1] 
-	   QDADD        r10, r10, r9
-	   LDRSH        r7, [r1], #2             @load x_lo[1]  
-	   MOV          r12, r10, LSL #1         @L_tmp = L_mac(L_tmp, *mem, fac)
-	   QADD         r10, r12, r11
-	   MOV          r14, r10, ASR #16        @y[0] = round(L_tmp)
-
-
-	   MOV          r10, r6, LSL #16
-	   ADD          r12, r10, r7, LSL #4
-           STRH         r14, [r2], #2            @update y[0]
-	   MOV          r10, r12, LSL #3
-	   MUL          r9, r14, r8
-	   QDADD        r10, r10, r9
-	   MOV          r12, r10, LSL #1
-	   QADD         r10, r12, r11
-	   MOV          r14, r10, ASR #16        @y[1] = round(L_tmp)
-
-LOOP:
-           LDRSH        r6, [r0], #2             @load x_hi[]
-	   LDRSH        r7, [r1], #2
-	   STRH         r14, [r2], #2
-	   MOV          r10, r6, LSL #16
-	   ADD          r12, r10, r7, LSL #4
-	   MUL          r9, r14, r8
-	   MOV          r10, r12, LSL #3
-	   QDADD        r10, r10, r9
-           LDRSH        r6, [r0], #2             @load x_hi[]
-	   MOV          r12, r10, LSL #1
-	   QADD         r10, r12, r11
-	   LDRSH        r7, [r1], #2
-	   MOV          r14, r10, ASR #16
-
-	   MOV          r10, r6, LSL #16
-	   ADD          r12, r10, r7, LSL #4
-	   STRH         r14, [r2], #2
-	   MUL          r9, r14, r8
-	   MOV          r10, r12, LSL #3
-	   QDADD        r10, r10, r9
-           ADD          r4, r4, #2
-	   MOV          r12, r10, LSL #1
-	   QADD         r10, r12, r11
-           CMP          r4, #64
-	   MOV          r14, r10, ASR #16
-
-           BLT          LOOP
-           STR          r14, [r3]
-           STRH         r14, [r2]	   
-
-           LDMFD   	r13!, {r4 - r12, r15} 
-
-	   @ENDP
-	   .END
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@void Deemph_32(
+@     Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
+@     Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
+@     Word16 y[],                           /* (o)     : output signal (x16)      */
+@     Word16 mu,                            /* (i) Q15 : deemphasis factor        */
+@     Word16 L,                             /* (i)     : vector size              */
+@     Word16 * mem                          /* (i/o)   : memory (y[-1])           */
+@     )
+
+@x_hi     RN      R0
+@x_lo     RN      R1
+@y[]      RN      R2
+@*mem     RN      R3
+
+           .section  .text
+           .global   Deemph_32_asm
+
+Deemph_32_asm:
+
+           STMFD   	r13!, {r4 - r12, r14}
+	   MOV          r4, #2                   @i=0
+	   LDRSH        r6, [r0], #2             @load x_hi[0]
+	   LDRSH        r7, [r1], #2             @load x_lo[0]
+	   LDR          r5, =22282               @r5---mu
+	   MOV          r11, #0x8000
+
+           @y[0]
+	   MOV          r10, r6, LSL #16         @L_tmp = x_hi[0]<<16
+	   MOV          r8,  r5, ASR #1          @fac = mu >> 1
+	   LDR          r5,  [r3]
+	   ADD          r12, r10, r7, LSL #4     @L_tmp += x_lo[0] << 4
+	   MOV          r10, r12, LSL #3         @L_tmp <<= 3
+	   MUL          r9, r5, r8
+	   LDRSH        r6, [r0], #2             @load x_hi[1]
+	   QDADD        r10, r10, r9
+	   LDRSH        r7, [r1], #2             @load x_lo[1]
+	   MOV          r12, r10, LSL #1         @L_tmp = L_mac(L_tmp, *mem, fac)
+	   QADD         r10, r12, r11
+	   MOV          r14, r10, ASR #16        @y[0] = round(L_tmp)
+
+
+	   MOV          r10, r6, LSL #16
+	   ADD          r12, r10, r7, LSL #4
+           STRH         r14, [r2], #2            @update y[0]
+	   MOV          r10, r12, LSL #3
+	   MUL          r9, r14, r8
+	   QDADD        r10, r10, r9
+	   MOV          r12, r10, LSL #1
+	   QADD         r10, r12, r11
+	   MOV          r14, r10, ASR #16        @y[1] = round(L_tmp)
+
+LOOP:
+           LDRSH        r6, [r0], #2             @load x_hi[]
+	   LDRSH        r7, [r1], #2
+	   STRH         r14, [r2], #2
+	   MOV          r10, r6, LSL #16
+	   ADD          r12, r10, r7, LSL #4
+	   MUL          r9, r14, r8
+	   MOV          r10, r12, LSL #3
+	   QDADD        r10, r10, r9
+           LDRSH        r6, [r0], #2             @load x_hi[]
+	   MOV          r12, r10, LSL #1
+	   QADD         r10, r12, r11
+	   LDRSH        r7, [r1], #2
+	   MOV          r14, r10, ASR #16
+
+	   MOV          r10, r6, LSL #16
+	   ADD          r12, r10, r7, LSL #4
+	   STRH         r14, [r2], #2
+	   MUL          r9, r14, r8
+	   MOV          r10, r12, LSL #3
+	   QDADD        r10, r10, r9
+           ADD          r4, r4, #2
+	   MOV          r12, r10, LSL #1
+	   QADD         r10, r12, r11
+           CMP          r4, #64
+	   MOV          r14, r10, ASR #16
+
+           BLT          LOOP
+           STR          r14, [r3]
+           STRH         r14, [r2]
+
+           LDMFD   	r13!, {r4 - r12, r15}
+
+	   @ENDP
+	   .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Dot_p_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Dot_p_opt.s
index 0383269..4aa317e 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Dot_p_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Dot_p_opt.s
@@ -1,80 +1,80 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
-@       Word16 x[],                           /* (i) 12bits: x vector                       */
-@       Word16 y[],                           /* (i) 12bits: y vector                       */
-@       Word16 lg,                            /* (i)    : vector length                     */
-@       Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
-@)
-@****************************************************************
-@  x[]   ---  r0
-@  y[]   ---  r1
-@  lg    ---  r2
-@  *exp  ---  r3
-
-          .section  .text
- 	  .global   Dot_product12_asm
-
-Dot_product12_asm:
-
-          STMFD   	    r13!, {r4 - r12, r14} 
-          MOV               r4, #0                                 @ L_sum = 0
-          MOV               r5, #0                                 @ i = 0
-
-LOOP:
-          LDR           r6, [r0], #4
-          LDR           r7, [r1], #4
-          LDR           r8, [r0], #4
-          SMLABB        r4, r6, r7, r4
-          LDR           r9, [r1], #4
-	  SMLATT        r4, r6, r7, r4 
-
-	  LDR           r6, [r0], #4
-	  SMLABB        r4, r8, r9, r4
-
-	  LDR           r7, [r1], #4
-	  SMLATT        r4, r8, r9, r4	  
-	  LDR           r8, [r0], #4
-
-	  SMLABB        r4, r6, r7, r4
-	  LDR           r9, [r1], #4
-	  SMLATT        r4, r6, r7, r4
-	  ADD           r5, r5, #8
-	  SMLABB        r4, r8, r9, r4
-	  CMP           r5, r2
-	  SMLATT        r4, r8, r9, r4
-	  BLT           LOOP
-              
-          MOV           r12, r4, LSL #1
-          ADD           r12, r12, #1                         @ L_sum = (L_sum << 1)  + 1
-	  MOV           r4, r12
-
-          CMP           r12, #0
-	  RSBLT         r4, r12, #0
-          CLZ           r10, r4
-          SUB           r10, r10, #1                         @ sft = norm_l(L_sum)
-          MOV           r0, r12, LSL r10                     @ L_sum = L_sum << sft
-          RSB           r11, r10, #30                        @ *exp = 30 - sft
-          STRH          r11, [r3]                     
-
-Dot_product12_end:
-		     
-          LDMFD   	    r13!, {r4 - r12, r15} 
-          @ENDFUNC
-          .END
- 
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
+@       Word16 x[],                           /* (i) 12bits: x vector                       */
+@       Word16 y[],                           /* (i) 12bits: y vector                       */
+@       Word16 lg,                            /* (i)    : vector length                     */
+@       Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
+@)
+@****************************************************************
+@  x[]   ---  r0
+@  y[]   ---  r1
+@  lg    ---  r2
+@  *exp  ---  r3
+
+          .section  .text
+ 	  .global   Dot_product12_asm
+
+Dot_product12_asm:
+
+          STMFD   	    r13!, {r4 - r12, r14}
+          MOV               r4, #0                                 @ L_sum = 0
+          MOV               r5, #0                                 @ i = 0
+
+LOOP:
+          LDR           r6, [r0], #4
+          LDR           r7, [r1], #4
+          LDR           r8, [r0], #4
+          SMLABB        r4, r6, r7, r4
+          LDR           r9, [r1], #4
+	  SMLATT        r4, r6, r7, r4
+
+	  LDR           r6, [r0], #4
+	  SMLABB        r4, r8, r9, r4
+
+	  LDR           r7, [r1], #4
+	  SMLATT        r4, r8, r9, r4
+	  LDR           r8, [r0], #4
+
+	  SMLABB        r4, r6, r7, r4
+	  LDR           r9, [r1], #4
+	  SMLATT        r4, r6, r7, r4
+	  ADD           r5, r5, #8
+	  SMLABB        r4, r8, r9, r4
+	  CMP           r5, r2
+	  SMLATT        r4, r8, r9, r4
+	  BLT           LOOP
+
+          MOV           r12, r4, LSL #1
+          ADD           r12, r12, #1                         @ L_sum = (L_sum << 1)  + 1
+	  MOV           r4, r12
+
+          CMP           r12, #0
+	  RSBLT         r4, r12, #0
+          CLZ           r10, r4
+          SUB           r10, r10, #1                         @ sft = norm_l(L_sum)
+          MOV           r0, r12, LSL r10                     @ L_sum = L_sum << sft
+          RSB           r11, r10, #30                        @ *exp = 30 - sft
+          STRH          r11, [r3]
+
+Dot_product12_end:
+
+          LDMFD   	    r13!, {r4 - r12, r15}
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Filt_6k_7k_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Filt_6k_7k_opt.s
index e6ebd73..856ada8 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Filt_6k_7k_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Filt_6k_7k_opt.s
@@ -1,185 +1,185 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-
-@**********************************************************************/
-@void Filt_6k_7k(
-@     Word16 signal[],                      /* input:  signal                  */
-@     Word16 lg,                            /* input:  length of input         */
-@     Word16 mem[]                          /* in/out: memory (size=30)        */
-@)
-@******************************************************************
-@ r0    ---  signal[]
-@ r1    ---  lg
-@ r2    ---  mem[] 
-
-          .section  .text
-          .global  Filt_6k_7k_asm
-          .extern  voAWB_Copy
-          .extern  fir_6k_7k
-
-Filt_6k_7k_asm:
-
-          STMFD   		r13!, {r4 - r12, r14} 
-          SUB    		r13, r13, #240              @ x[L_SUBFR16k + (L_FIR - 1)]
-          MOV     		r8, r0                      @ copy signal[] address
-          MOV     		r4, r1                      @ copy lg address
-          MOV     		r5, r2                      @ copy mem[] address
-
-          MOV     		r1, r13
-          MOV     		r0, r2
-          MOV     		r2, #30                     @ L_FIR - 1
-          BL      		voAWB_Copy                   @ memcpy(x, mem, (L_FIR - 1)<<1)
-
-          LDR     		r10, Lable1                 @ get fir_7k address     
-
-          MOV           	r14, #0  
-          MOV                   r3, r8                      @ change myMemCopy to Copy, due to Copy will change r3 content
-          ADD     	    	r6, r13, #60                @ get x[L_FIR - 1] address
-          MOV           	r7, r3                      @ get signal[i]
-LOOP1:
-          LDRSH         	r8,  [r7], #2
-          LDRSH         	r9,  [r7], #2
-          MOV           	r8, r8, ASR #2
-          MOV           	r9, r9, ASR #2
-          LDRSH         	r11, [r7], #2
-          LDRSH         	r12, [r7], #2
-          MOV           	r11, r11, ASR #2
-          MOV           	r12, r12, ASR #2
-          STRH          	r8, [r6], #2
-          STRH          	r9, [r6], #2
-          STRH          	r11, [r6], #2
-          STRH          	r12, [r6], #2
-          LDRSH         	r8,  [r7], #2
-          LDRSH         	r9,  [r7], #2
-          MOV           	r8, r8, ASR #2
-          MOV           	r9, r9, ASR #2
-          LDRSH         	r11, [r7], #2
-          LDRSH         	r12, [r7], #2
-          MOV           	r11, r11, ASR #2
-          MOV           	r12, r12, ASR #2
-          STRH          	r8, [r6], #2
-          STRH          	r9, [r6], #2
-          STRH          	r11, [r6], #2
-          STRH          	r12, [r6], #2
-          ADD           	r14, r14, #8
-          CMP           	r14, #80
-          BLT           	LOOP1          
-
-
-          STR     		r5, [sp, #-4]               @ PUSH  r5 to stack
-
-          @ not use registers: r4, r10, r12, r14, r5
-          MOV     		r4, r13 
-          MOV     		r5, #0                      @ i = 0              
-LOOP2:
-          LDR           	r0, [r10]
-
-          LDRSH  	        r1, [r4]                   @ load x[i]
-          LDRSH   	        r2, [r4, #60]              @ load x[i + 30]
-          LDRSH                 r6, [r4, #2]               @ load x[i + 1]
-          LDRSH                 r7, [r4, #58]              @ load x[i + 29]
-          ADD                   r1, r1, r2                 @ x[i] + x[i + 30]
-          ADD                   r6, r6, r7                 @ x[i + 1] + x[i + 29]
-          LDRSH                 r8, [r4, #4]               @ load x[i + 2]
-          LDRSH                 r9, [r4, #56]              @ load x[i + 28]
-
-          SMULBB                r14, r1, r0                @ (x[i] + x[i + 30]) * fir_7k[0]
-          ADD                   r8, r8, r9                 @ x[i + 2] + x[i + 28]
-          SMLABT                r14, r6, r0, r14           @ (x[i + 1] + x[i + 29]) * fir_7k[1]
-
-          LDR                   r0, [r10, #4]
-          LDRSH                 r1, [r4, #6]               @ load x[i+3]
-          LDRSH                 r2, [r4, #54]              @ load x[i+27]
-          LDRSH                 r6, [r4, #8]               @ load x[i+4]
-          LDRSH                 r7, [r4, #52]              @ load x[i+26]
-          ADD                   r1, r1, r2                 @ x[i+3] + x[i+27]
-          ADD                   r6, r6, r7                 @ x[i+4] + x[i+26]
-          SMLABB                r14, r8, r0, r14           @ (x[i + 2] + x[i + 28]) * fir_7k[2]
-          LDRSH                 r8, [r4, #10]              @ load x[i+5]
-          LDRSH                 r9, [r4, #50]              @ load x[i+25]
-          SMLABT                r14, r1, r0, r14           @ (x[i+3] + x[i+27]) * fir_7k[3]
-          ADD                   r8, r8, r9                 @ x[i+5] + x[i+25] 
- 
-          LDR                   r0, [r10, #8]
-          LDRSH                 r1, [r4, #12]              @ x[i+6]
-          LDRSH                 r2, [r4, #48]              @ x[i+24]
-          SMLABB                r14, r6, r0, r14           @ (x[i+4] + x[i+26]) * fir_7k[4]
-          LDRSH                 r6, [r4, #14]              @ x[i+7] 
-          LDRSH                 r7, [r4, #46]              @ x[i+23]
-          SMLABT                r14, r8, r0, r14           @ (x[i+5] + x[i+25]) * fir_7k[5]
-          LDR                   r0, [r10, #12]
-          ADD                   r1, r1, r2                 @ (x[i+6] + x[i+24])
-          ADD                   r6, r6, r7                 @ (x[i+7] + x[i+23])
-          SMLABB                r14, r1, r0, r14           @ (x[i+6] + x[i+24]) * fir_7k[6]
-          LDRSH                 r8, [r4, #16]              @ x[i+8]
-          LDRSH                 r9, [r4, #44]              @ x[i+22] 
-          SMLABT                r14, r6, r0, r14           @ (x[i+7] + x[i+23]) * fir_7k[7]  
-          LDR                   r0, [r10, #16]
-          LDRSH                 r1, [r4, #18]              @ x[i+9]
-          LDRSH                 r2, [r4, #42]              @ x[i+21]
-          LDRSH                 r6, [r4, #20]              @ x[i+10]
-          LDRSH                 r7, [r4, #40]              @ x[i+20]
-          ADD                   r8, r8, r9                 @ (x[i+8] + x[i+22])
-          ADD                   r1, r1, r2                 @ (x[i+9] + x[i+21])
-          ADD                   r6, r6, r7                 @ (x[i+10] + x[i+20])
-          SMLABB                r14, r8, r0, r14           @ (x[i+8] + x[i+22]) * fir_7k[8]
-          LDRSH                 r8, [r4, #22]              @ x[i+11]
-          LDRSH                 r9, [r4, #38]              @ x[i+19]
-          SMLABT                r14, r1, r0, r14           @ (x[i+9] + x[i+21]) * fir_7k[9]
-          LDR                   r0, [r10, #20]
-          LDRSH                 r1, [r4, #24]              @ x[i+12]
-          LDRSH                 r2, [r4, #36]              @ x[i+18]
-          SMLABB                r14, r6, r0, r14           @ (x[i+10] + x[i+20]) * fir_7k[10]
-          LDRSH                 r6, [r4, #26]              @ x[i+13]
-          ADD                   r8, r8, r9                 @ (x[i+11] + x[i+19])  
-          LDRSH                 r7, [r4, #34]              @ x[i+17]
-          SMLABT                r14, r8, r0, r14           @ (x[i+11] + x[i+19]) * fir_7k[11]
-          LDR                   r0, [r10, #24]
-          ADD                   r1, r1, r2                 @ x[i+12] + x[i+18]
-          LDRSH                 r8, [r4, #28]              @ x[i+14]
-          SMLABB                r14, r1, r0, r14           @ (x[i+12] + x[i+18]) * fir_7k[12]
-          ADD                   r6, r6, r7                 @ (x[i+13] + x[i+17])
-          LDRSH                 r9, [r4, #32]              @ x[i+16] 
-          SMLABT                r14, r6, r0, r14           @ (x[i+13] + x[i+17]) * fir_7k[13]
-          LDR                   r0, [r10, #28]         
-          ADD                   r8, r8, r9                 @ (x[i+14] + x[i+16])
-          LDRSH                 r1, [r4, #30]              @ x[i+15]
-          SMLABB                r14, r8, r0, r14           @ (x[i+14] + x[i+16]) * fir_7k[14]
-          SMLABT                r14, r1, r0, r14           @ x[i+15] * fir_7k[15]                              
-
-          ADD     		r5, r5, #1
-          ADD     		r14, r14, #0x4000
-          ADD     		r4, r4, #2                
-          MOV     		r1, r14, ASR #15
-          CMP     		r5, #80
-          STRH    		r1, [r3], #2               @signal[i] = (L_tmp + 0x4000) >> 15
-          BLT     		LOOP2      
-           
-          LDR     		r1, [sp, #-4]               @mem address
-          ADD     		r0, r13, #160               @x + lg
-          MOV     		r2, #30
-          BL      		voAWB_Copy
-                    
-Filt_6k_7k_end:
-          ADD     		r13, r13, #240  
-          LDMFD   		r13!, {r4 - r12, r15} 
- 
-Lable1:
-          .word   		fir_6k_7k
-          @ENDFUNC
-          .END
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+
+@**********************************************************************/
+@void Filt_6k_7k(
+@     Word16 signal[],                      /* input:  signal                  */
+@     Word16 lg,                            /* input:  length of input         */
+@     Word16 mem[]                          /* in/out: memory (size=30)        */
+@)
+@******************************************************************
+@ r0    ---  signal[]
+@ r1    ---  lg
+@ r2    ---  mem[]
+
+          .section  .text
+          .global  Filt_6k_7k_asm
+          .extern  voAWB_Copy
+          .extern  fir_6k_7k
+
+Filt_6k_7k_asm:
+
+          STMFD   		r13!, {r4 - r12, r14}
+          SUB    		r13, r13, #240              @ x[L_SUBFR16k + (L_FIR - 1)]
+          MOV     		r8, r0                      @ copy signal[] address
+          MOV     		r4, r1                      @ copy lg address
+          MOV     		r5, r2                      @ copy mem[] address
+
+          MOV     		r1, r13
+          MOV     		r0, r2
+          MOV     		r2, #30                     @ L_FIR - 1
+          BL      		voAWB_Copy                   @ memcpy(x, mem, (L_FIR - 1)<<1)
+
+          LDR     		r10, Lable1                 @ get fir_7k address
+
+          MOV           	r14, #0
+          MOV                   r3, r8                      @ change myMemCopy to Copy, due to Copy will change r3 content
+          ADD     	    	r6, r13, #60                @ get x[L_FIR - 1] address
+          MOV           	r7, r3                      @ get signal[i]
+LOOP1:
+          LDRSH         	r8,  [r7], #2
+          LDRSH         	r9,  [r7], #2
+          MOV           	r8, r8, ASR #2
+          MOV           	r9, r9, ASR #2
+          LDRSH         	r11, [r7], #2
+          LDRSH         	r12, [r7], #2
+          MOV           	r11, r11, ASR #2
+          MOV           	r12, r12, ASR #2
+          STRH          	r8, [r6], #2
+          STRH          	r9, [r6], #2
+          STRH          	r11, [r6], #2
+          STRH          	r12, [r6], #2
+          LDRSH         	r8,  [r7], #2
+          LDRSH         	r9,  [r7], #2
+          MOV           	r8, r8, ASR #2
+          MOV           	r9, r9, ASR #2
+          LDRSH         	r11, [r7], #2
+          LDRSH         	r12, [r7], #2
+          MOV           	r11, r11, ASR #2
+          MOV           	r12, r12, ASR #2
+          STRH          	r8, [r6], #2
+          STRH          	r9, [r6], #2
+          STRH          	r11, [r6], #2
+          STRH          	r12, [r6], #2
+          ADD           	r14, r14, #8
+          CMP           	r14, #80
+          BLT           	LOOP1
+
+
+          STR     		r5, [sp, #-4]               @ PUSH  r5 to stack
+
+          @ not use registers: r4, r10, r12, r14, r5
+          MOV     		r4, r13
+          MOV     		r5, #0                      @ i = 0
+LOOP2:
+          LDR           	r0, [r10]
+
+          LDRSH  	        r1, [r4]                   @ load x[i]
+          LDRSH   	        r2, [r4, #60]              @ load x[i + 30]
+          LDRSH                 r6, [r4, #2]               @ load x[i + 1]
+          LDRSH                 r7, [r4, #58]              @ load x[i + 29]
+          ADD                   r1, r1, r2                 @ x[i] + x[i + 30]
+          ADD                   r6, r6, r7                 @ x[i + 1] + x[i + 29]
+          LDRSH                 r8, [r4, #4]               @ load x[i + 2]
+          LDRSH                 r9, [r4, #56]              @ load x[i + 28]
+
+          SMULBB                r14, r1, r0                @ (x[i] + x[i + 30]) * fir_7k[0]
+          ADD                   r8, r8, r9                 @ x[i + 2] + x[i + 28]
+          SMLABT                r14, r6, r0, r14           @ (x[i + 1] + x[i + 29]) * fir_7k[1]
+
+          LDR                   r0, [r10, #4]
+          LDRSH                 r1, [r4, #6]               @ load x[i+3]
+          LDRSH                 r2, [r4, #54]              @ load x[i+27]
+          LDRSH                 r6, [r4, #8]               @ load x[i+4]
+          LDRSH                 r7, [r4, #52]              @ load x[i+26]
+          ADD                   r1, r1, r2                 @ x[i+3] + x[i+27]
+          ADD                   r6, r6, r7                 @ x[i+4] + x[i+26]
+          SMLABB                r14, r8, r0, r14           @ (x[i + 2] + x[i + 28]) * fir_7k[2]
+          LDRSH                 r8, [r4, #10]              @ load x[i+5]
+          LDRSH                 r9, [r4, #50]              @ load x[i+25]
+          SMLABT                r14, r1, r0, r14           @ (x[i+3] + x[i+27]) * fir_7k[3]
+          ADD                   r8, r8, r9                 @ x[i+5] + x[i+25]
+
+          LDR                   r0, [r10, #8]
+          LDRSH                 r1, [r4, #12]              @ x[i+6]
+          LDRSH                 r2, [r4, #48]              @ x[i+24]
+          SMLABB                r14, r6, r0, r14           @ (x[i+4] + x[i+26]) * fir_7k[4]
+          LDRSH                 r6, [r4, #14]              @ x[i+7]
+          LDRSH                 r7, [r4, #46]              @ x[i+23]
+          SMLABT                r14, r8, r0, r14           @ (x[i+5] + x[i+25]) * fir_7k[5]
+          LDR                   r0, [r10, #12]
+          ADD                   r1, r1, r2                 @ (x[i+6] + x[i+24])
+          ADD                   r6, r6, r7                 @ (x[i+7] + x[i+23])
+          SMLABB                r14, r1, r0, r14           @ (x[i+6] + x[i+24]) * fir_7k[6]
+          LDRSH                 r8, [r4, #16]              @ x[i+8]
+          LDRSH                 r9, [r4, #44]              @ x[i+22]
+          SMLABT                r14, r6, r0, r14           @ (x[i+7] + x[i+23]) * fir_7k[7]
+          LDR                   r0, [r10, #16]
+          LDRSH                 r1, [r4, #18]              @ x[i+9]
+          LDRSH                 r2, [r4, #42]              @ x[i+21]
+          LDRSH                 r6, [r4, #20]              @ x[i+10]
+          LDRSH                 r7, [r4, #40]              @ x[i+20]
+          ADD                   r8, r8, r9                 @ (x[i+8] + x[i+22])
+          ADD                   r1, r1, r2                 @ (x[i+9] + x[i+21])
+          ADD                   r6, r6, r7                 @ (x[i+10] + x[i+20])
+          SMLABB                r14, r8, r0, r14           @ (x[i+8] + x[i+22]) * fir_7k[8]
+          LDRSH                 r8, [r4, #22]              @ x[i+11]
+          LDRSH                 r9, [r4, #38]              @ x[i+19]
+          SMLABT                r14, r1, r0, r14           @ (x[i+9] + x[i+21]) * fir_7k[9]
+          LDR                   r0, [r10, #20]
+          LDRSH                 r1, [r4, #24]              @ x[i+12]
+          LDRSH                 r2, [r4, #36]              @ x[i+18]
+          SMLABB                r14, r6, r0, r14           @ (x[i+10] + x[i+20]) * fir_7k[10]
+          LDRSH                 r6, [r4, #26]              @ x[i+13]
+          ADD                   r8, r8, r9                 @ (x[i+11] + x[i+19])
+          LDRSH                 r7, [r4, #34]              @ x[i+17]
+          SMLABT                r14, r8, r0, r14           @ (x[i+11] + x[i+19]) * fir_7k[11]
+          LDR                   r0, [r10, #24]
+          ADD                   r1, r1, r2                 @ x[i+12] + x[i+18]
+          LDRSH                 r8, [r4, #28]              @ x[i+14]
+          SMLABB                r14, r1, r0, r14           @ (x[i+12] + x[i+18]) * fir_7k[12]
+          ADD                   r6, r6, r7                 @ (x[i+13] + x[i+17])
+          LDRSH                 r9, [r4, #32]              @ x[i+16]
+          SMLABT                r14, r6, r0, r14           @ (x[i+13] + x[i+17]) * fir_7k[13]
+          LDR                   r0, [r10, #28]
+          ADD                   r8, r8, r9                 @ (x[i+14] + x[i+16])
+          LDRSH                 r1, [r4, #30]              @ x[i+15]
+          SMLABB                r14, r8, r0, r14           @ (x[i+14] + x[i+16]) * fir_7k[14]
+          SMLABT                r14, r1, r0, r14           @ x[i+15] * fir_7k[15]
+
+          ADD     		r5, r5, #1
+          ADD     		r14, r14, #0x4000
+          ADD     		r4, r4, #2
+          MOV     		r1, r14, ASR #15
+          CMP     		r5, #80
+          STRH    		r1, [r3], #2               @signal[i] = (L_tmp + 0x4000) >> 15
+          BLT     		LOOP2
+
+          LDR     		r1, [sp, #-4]               @mem address
+          ADD     		r0, r13, #160               @x + lg
+          MOV     		r2, #30
+          BL      		voAWB_Copy
+
+Filt_6k_7k_end:
+          ADD     		r13, r13, #240
+          LDMFD   		r13!, {r4 - r12, r15}
+
+Lable1:
+          .word   		fir_6k_7k
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Norm_Corr_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Norm_Corr_opt.s
index b440a31..49bdc2b 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Norm_Corr_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Norm_Corr_opt.s
@@ -32,8 +32,8 @@
 @ r6 --- corr_norm[]
 
 
-	.section  .text 
-        .global   Norm_corr_asm 
+	.section  .text
+        .global   Norm_corr_asm
         .extern   Convolve_asm
         .extern   Isqrt_n
 @******************************
@@ -47,17 +47,17 @@
 .equ         T_MIN         ,   212
 .equ         T_MAX         ,   216
 .equ         CORR_NORM     ,   220
-                  
+
 Norm_corr_asm:
 
-        STMFD      r13!, {r4 - r12, r14}  
+        STMFD      r13!, {r4 - r12, r14}
         SUB        r13, r13, #voSTACK
-  
+
         ADD        r8, r13, #20                 @get the excf[L_SUBFR]
         LDR        r4, [r13, #T_MIN]            @get t_min
         RSB        r11, r4, #0                  @k = -t_min
-        ADD        r5, r0, r11, LSL #1          @get the &exc[k]   
-        
+        ADD        r5, r0, r11, LSL #1          @get the &exc[k]
+
         @transfer Convolve function
         STMFD       sp!, {r0 - r3}
         MOV         r0, r5
@@ -68,7 +68,7 @@ Norm_corr_asm:
 
         @ r8 --- excf[]
 
-	MOV         r14, r1                       @copy xn[] address                      
+	MOV         r14, r1                       @copy xn[] address
         MOV         r5, #64
         MOV         r6, #0                       @L_tmp = 0
         MOV         r7, #1
@@ -93,21 +93,21 @@ LOOP1:
 	CLZ         r7, r9
 	SUB         r6, r7, #1                   @exp = norm_l(L_tmp)
         RSB         r7, r6, #32                  @exp = 32 - exp
-	MOV         r6, r7, ASR #1         
+	MOV         r6, r7, ASR #1
 	RSB         r7, r6, #0                   @scale = -(exp >> 1)
-	
+
         @loop for every possible period
 	@for(t = t_min@ t <= t_max@ t++)
 	@r7 --- scale r4 --- t_min r8 --- excf[]
 
-LOOPFOR:	
+LOOPFOR:
         MOV         r5, #0                       @L_tmp  = 0
 	MOV         r6, #0                       @L_tmp1 = 0
-	MOV         r9, #64  
+	MOV         r9, #64
 	MOV         r12, r1                      @copy of xn[]
 	ADD         r14, r13, #20                @copy of excf[]
 	MOV         r8, #0x8000
-        	
+
 LOOPi:
 	LDR         r11, [r14], #4               @load excf[i], excf[i+1]
         LDR         r10, [r12], #4               @load xn[i], xn[i+1]
@@ -128,13 +128,13 @@ LOOPi:
 	MOV         r10, #1
 	ADD         r5, r10, r5, LSL #1          @L_tmp = (L_tmp << 1) + 1
 	ADD         r6, r10, r6, LSL #1          @L_tmp1 = (L_tmp1 << 1) + 1
- 
-	CLZ         r10, r5        
+
+	CLZ         r10, r5
 	CMP         r5, #0
 	RSBLT       r11, r5, #0
 	CLZLT       r10, r11
 	SUB         r10, r10, #1                 @exp = norm_l(L_tmp)
-     
+
 	MOV         r5, r5, LSL r10              @L_tmp = (L_tmp << exp)
 	RSB         r10, r10, #30                @exp_corr = 30 - exp
 	MOV         r11, r5, ASR #16             @corr = extract_h(L_tmp)
@@ -150,7 +150,7 @@ LOOPi:
 	@Isqrt_n(&L_tmp, &exp_norm)
 
 	MOV         r14, r0
-	MOV         r12, r1 
+	MOV         r12, r1
 
         STMFD       sp!, {r0 - r4, r7 - r12, r14}
 	ADD         r1, sp, #4
@@ -168,7 +168,7 @@ LOOPi:
 	MOV         r6, r6, ASR #16              @norm = extract_h(L_tmp)
 	MUL         r12, r6, r11
 	ADD         r12, r12, r12                @L_tmp = vo_L_mult(corr, norm)
-  
+
 	ADD         r6, r10, r5
 	ADD         r6, r6, r7                   @exp_corr + exp_norm + scale
 
@@ -187,9 +187,9 @@ LOOPi:
 
 	CMP         r4, r6
 	BEQ         Norm_corr_asm_end
- 
+
 	ADD         r4, r4, #1                   @ t_min ++
-        
+
 	RSB         r5, r4, #0                   @ k
 
 	MOV         r6, #63                      @ i = 63
@@ -216,16 +216,16 @@ LOOPK:
 	MUL         r14, r11, r8
         LDR         r6, [r13, #T_MAX]            @ get t_max
 	MOV         r8, r14, ASR #15
-	STRH        r8, [r10]                    
+	STRH        r8, [r10]
 
 	CMP         r4, r6
 	BLE         LOOPFOR
 
-Norm_corr_asm_end: 
-        
-        ADD            r13, r13, #voSTACK      
+Norm_corr_asm_end:
+
+        ADD            r13, r13, #voSTACK
         LDMFD          r13!, {r4 - r12, r15}
-    
+
         .END
 
 
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Syn_filt_32_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Syn_filt_32_opt.s
index 6416634..3f4930c 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Syn_filt_32_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/Syn_filt_32_opt.s
@@ -1,226 +1,226 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@void Syn_filt_32(
-@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
-@     Word16 m,                             /* (i)     : order of LP filter             */
-@     Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
-@     Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
-@     Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
-@     Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
-@     Word16 lg                             /* (i)     : size of filtering              */
-@)
-@***************************************************************
-@
-@ a[]      --- r0
-@ m        --- r1
-@ exc[]    --- r2
-@ Qnew     --- r3
-@ sig_hi[] --- r4
-@ sig_lo[] --- r5
-@ lg       --- r6
-
-          .section  .text
-          .global  Syn_filt_32_asm
-
-Syn_filt_32_asm:
-
-          STMFD   	r13!, {r4 - r12, r14} 
-          LDR           r4,  [r13, #40]                  @ get sig_hi[] address
-          LDR           r5,  [r13, #44]                  @ get sig_lo[] address
-
-          LDRSH         r6,  [r0]                        @ load Aq[0]
-          ADD           r7,  r3, #4                      @ 4 + Q_new
-          MOV           r3, r6, ASR r7                   @ a0 = Aq[0] >> (4 + Q_new)
-
-          LDR           r14, =0xffff
-          LDRSH         r6, [r0, #2]                     @ load Aq[1]
-          LDRSH         r7, [r0, #4]                     @ load Aq[2]
-          LDRSH         r8, [r0, #6]                     @ load Aq[3]
-          LDRSH         r9, [r0, #8]                     @ load Aq[4]
-          AND           r6, r6, r14
-          AND           r8, r8, r14
-          ORR           r10, r6, r7, LSL #16             @ Aq[2] -- Aq[1]
-          ORR           r11, r8, r9, LSL #16             @ Aq[4] -- Aq[3]
-          STR           r10, [r13, #-4]                  
-          STR           r11, [r13, #-8]
-
-          LDRSH         r6, [r0, #10]                    @ load Aq[5]
-          LDRSH         r7, [r0, #12]                    @ load Aq[6]
-          LDRSH         r8, [r0, #14]                    @ load Aq[7]
-          LDRSH         r9, [r0, #16]                    @ load Aq[8]
-          AND           r6, r6, r14
-          AND           r8, r8, r14
-          ORR           r10, r6, r7, LSL #16             @ Aq[6] -- Aq[5]
-          ORR           r11, r8, r9, LSL #16             @ Aq[8] -- Aq[7]
-          STR           r10, [r13, #-12]
-          STR           r11, [r13, #-16]
-
-          LDRSH         r6, [r0, #18]                    @ load Aq[9]
-          LDRSH         r7, [r0, #20]                    @ load Aq[10]
-          LDRSH         r8, [r0, #22]                    @ load Aq[11]
-          LDRSH         r9, [r0, #24]                    @ load Aq[12]
-          AND           r6, r6, r14 
-          AND           r8, r8, r14
-          ORR           r10, r6, r7, LSL #16             @ Aq[10] -- Aq[9]
-          ORR           r11, r8, r9, LSL #16             @ Aq[12] -- Aq[11]
-          STR           r10, [r13, #-20]
-          STR           r11, [r13, #-24]  
-
-          LDRSH         r6, [r0, #26]                    @ load Aq[13]
-          LDRSH         r7, [r0, #28]                    @ load Aq[14]
-          LDRSH         r8, [r0, #30]                    @ load Aq[15]
-          LDRSH         r9, [r0, #32]                    @ load Aq[16]
-          AND           r6, r6, r14
-          AND           r8, r8, r14
-          ORR           r10, r6, r7, LSL #16             @ Aq[14] -- Aq[13]
-          ORR           r11, r8, r9, LSL #16             @ Aq[16] -- Aq[15]
-          STR           r10, [r13, #-28]
-          STR           r11, [r13, #-32]
-          
-          MOV           r8, #0                           @ i = 0
-              
-LOOP:            
-          LDRSH         r6, [r5, #-2]                    @ load sig_lo[i-1]
-          LDRSH         r7, [r5, #-4]                    @ load sig_lo[i-2]
-
-          LDR           r11, [r13, #-4]                  @ Aq[2] -- Aq[1]        
-          LDRSH         r9, [r5, #-6]                    @ load sig_lo[i-3]
-          LDRSH         r10, [r5, #-8]                   @ load sig_lo[i-4]
-
-          SMULBB        r12, r6, r11                     @ sig_lo[i-1] * Aq[1]
-
-          LDRSH         r6, [r5, #-10]                   @ load sig_lo[i-5]
-          SMLABT        r12, r7, r11, r12                @ sig_lo[i-2] * Aq[2]
-          LDR           r11, [r13, #-8]                  @ Aq[4] -- Aq[3]
-          LDRSH         r7, [r5, #-12]                   @ load sig_lo[i-6]
-          SMLABB        r12, r9, r11, r12                @ sig_lo[i-3] * Aq[3]
-          LDRSH         r9, [r5, #-14]                   @ load sig_lo[i-7]
-          SMLABT        r12, r10, r11, r12               @ sig_lo[i-4] * Aq[4]
-          LDR           r11, [r13, #-12]                 @ Aq[6] -- Aq[5]
-          LDRSH         r10, [r5, #-16]                  @ load sig_lo[i-8]
-          SMLABB        r12, r6, r11, r12                @ sig_lo[i-5] * Aq[5]
-          LDRSH         r6,  [r5, #-18]                  @ load sig_lo[i-9]
-          SMLABT        r12, r7, r11, r12                @ sig_lo[i-6] * Aq[6]
-          LDR           r11, [r13, #-16]                 @ Aq[8] -- Aq[7]
-          LDRSH         r7,  [r5, #-20]                  @ load sig_lo[i-10]
-          SMLABB        r12, r9, r11, r12                @ sig_lo[i-7] * Aq[7]
-          LDRSH         r9, [r5, #-22]                   @ load sig_lo[i-11]
-          SMLABT        r12, r10, r11, r12               @ sig_lo[i-8] * Aq[8]
-          LDR           r11, [r13, #-20]                 @ Aq[10] -- Aq[9]
-          LDRSH         r10,[r5, #-24]                   @ load sig_lo[i-12]
-          SMLABB        r12, r6, r11, r12                @ sig_lo[i-9] * Aq[9]
-          LDRSH         r6, [r5, #-26]                   @ load sig_lo[i-13]
-          SMLABT        r12, r7, r11, r12                @ sig_lo[i-10] * Aq[10]
-          LDR           r11, [r13, #-24]                 @ Aq[12] -- Aq[11]
-          LDRSH         r7, [r5, #-28]                   @ load sig_lo[i-14]
-          SMLABB        r12, r9, r11, r12                @ sig_lo[i-11] * Aq[11]
-          LDRSH         r9, [r5, #-30]                   @ load sig_lo[i-15]
-          SMLABT        r12, r10, r11, r12               @ sig_lo[i-12] * Aq[12]
-
-          LDR           r11, [r13, #-28]                 @ Aq[14] -- Aq[13]
-          LDRSH         r10, [r5, #-32]                  @ load sig_lo[i-16]
-          SMLABB        r12, r6, r11, r12                @ sig_lo[i-13] * Aq[13]
-          SMLABT        r12, r7, r11, r12                @ sig_lo[i-14] * Aq[14]
- 
-          LDR           r11, [r13, #-32]                 @ Aq[16] -- Aq[15]
-          LDRSH         r6, [r2],#2                      @ load exc[i] 
-          SMLABB        r12, r9, r11, r12                @ sig_lo[i-15] * Aq[15]
-          SMLABT        r12, r10, r11, r12               @ sig_lo[i-16] * Aq[16]
-          MUL           r7, r6, r3                       @ exc[i] * a0 
-          RSB           r14, r12, #0                     @ L_tmp
-          MOV           r14, r14, ASR #11                @ L_tmp >>= 11
-          ADD           r14, r14, r7, LSL #1             @ L_tmp += (exc[i] * a0) << 1
-
-
-          LDRSH         r6, [r4, #-2]                    @ load sig_hi[i-1]
-          LDRSH         r7, [r4, #-4]                    @ load sig_hi[i-2]
-
-          LDR           r11, [r13, #-4]                  @ Aq[2] -- Aq[1]        
-          LDRSH         r9, [r4, #-6]                    @ load sig_hi[i-3]
-          LDRSH         r10, [r4, #-8]                   @ load sig_hi[i-4]
-          SMULBB        r12, r6, r11                     @ sig_hi[i-1] * Aq[1]
-          LDRSH         r6, [r4, #-10]                   @ load sig_hi[i-5]
-	  SMLABT        r12, r7, r11, r12                @ sig_hi[i-2] * Aq[2]
-
-          LDR           r11, [r13, #-8]                  @ Aq[4] -- Aq[3]
-          LDRSH         r7, [r4, #-12]                   @ load sig_hi[i-6]
-
-          SMLABB        r12, r9, r11, r12                @ sig_hi[i-3] * Aq[3]
-	  LDRSH         r9, [r4, #-14]                   @ load sig_hi[i-7]
-
-	  SMLABT        r12, r10, r11, r12               @ sig_hi[i-4] * Aq[4]
-
-          LDR           r11, [r13, #-12]                 @ Aq[6] -- Aq[5]
-          LDRSH         r10, [r4, #-16]                  @ load sig_hi[i-8]
-
-	  SMLABB        r12, r6, r11, r12                @ sig_hi[i-5] * Aq[5]
-
-	  LDRSH         r6,  [r4, #-18]                  @ load sig_hi[i-9]
-	  SMLABT        r12, r7, r11, r12                @ sig_hi[i-6] * Aq[6]
-
-          LDR           r11, [r13, #-16]                 @ Aq[8] -- Aq[7]
-          LDRSH         r7,  [r4, #-20]                  @ load sig_hi[i-10]
-
-	  SMLABB        r12, r9, r11, r12                @ sig_hi[i-7] * Aq[7]
-
-	  LDRSH         r9, [r4, #-22]                   @ load sig_hi[i-11]
-
-	  SMLABT        r12, r10, r11, r12               @ sig_hi[i-8] * Aq[8]
-
-          LDR           r11, [r13, #-20]                 @ Aq[10] -- Aq[9]
-          LDRSH         r10,[r4, #-24]                   @ load sig_hi[i-12]
-
-	  SMLABB        r12, r6, r11, r12                @ sig_hi[i-9] * Aq[9]
-          LDRSH         r6, [r4, #-26]                   @ load sig_hi[i-13]
-          SMLABT        r12, r7, r11, r12                @ sig_hi[i-10] * Aq[10]
-
-          LDR           r11, [r13, #-24]                 @ Aq[12] -- Aq[11]
-          LDRSH         r7, [r4, #-28]                   @ load sig_hi[i-14]
-          SMLABB        r12, r9, r11, r12                @ sig_hi[i-11] * Aq[11]
-          LDRSH         r9, [r4, #-30]                   @ load sig_hi[i-15]
-          SMLABT        r12, r10, r11, r12               @ sig_hi[i-12] * Aq[12]
-
-          LDR           r11, [r13, #-28]                 @ Aq[14] -- Aq[13]
-          LDRSH         r10, [r4, #-32]                  @ load sig_hi[i-16]
-          SMLABB        r12, r6, r11, r12                @ sig_hi[i-13] * Aq[13]
-          SMLABT        r12, r7, r11, r12                @ sig_hi[i-14] * Aq[14]
- 
-          LDR           r11, [r13, #-32]                 @ Aq[16] -- Aq[15]
-          SMLABB        r12, r9, r11, r12                @ sig_hi[i-15] * Aq[15]
-          SMLABT        r12, r10, r11, r12               @ sig_hi[i-16] * Aq[16]       
-          ADD           r6, r12, r12                     @ r12 << 1
-          SUB           r14, r14, r6                     
-          MOV           r14, r14, LSL #3                 @ L_tmp <<=3
-  
-          MOV           r7, r14, ASR #16                 @ L_tmp >> 16
-
-          MOV           r14, r14, ASR #4                 @ L_tmp >>=4
-          STRH          r7, [r4], #2                         @ sig_hi[i] = L_tmp >> 16
-          SUB           r9, r14, r7, LSL #12             @ sig_lo[i] = L_tmp - (sig_hi[i] << 12)
-
-          ADD           r8, r8, #1
-          STRH          r9, [r5], #2   
-          CMP           r8, #64
-          BLT           LOOP                            
-         
-Syn_filt_32_end:
-		     
-          LDMFD   	    r13!, {r4 - r12, r15} 
-          @ENDFUNC
-          .END
- 
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@void Syn_filt_32(
+@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
+@     Word16 m,                             /* (i)     : order of LP filter             */
+@     Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
+@     Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
+@     Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
+@     Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
+@     Word16 lg                             /* (i)     : size of filtering              */
+@)
+@***************************************************************
+@
+@ a[]      --- r0
+@ m        --- r1
+@ exc[]    --- r2
+@ Qnew     --- r3
+@ sig_hi[] --- r4
+@ sig_lo[] --- r5
+@ lg       --- r6
+
+          .section  .text
+          .global  Syn_filt_32_asm
+
+Syn_filt_32_asm:
+
+          STMFD   	r13!, {r4 - r12, r14}
+          LDR           r4,  [r13, #40]                  @ get sig_hi[] address
+          LDR           r5,  [r13, #44]                  @ get sig_lo[] address
+
+          LDRSH         r6,  [r0]                        @ load Aq[0]
+          ADD           r7,  r3, #4                      @ 4 + Q_new
+          MOV           r3, r6, ASR r7                   @ a0 = Aq[0] >> (4 + Q_new)
+
+          LDR           r14, =0xffff
+          LDRSH         r6, [r0, #2]                     @ load Aq[1]
+          LDRSH         r7, [r0, #4]                     @ load Aq[2]
+          LDRSH         r8, [r0, #6]                     @ load Aq[3]
+          LDRSH         r9, [r0, #8]                     @ load Aq[4]
+          AND           r6, r6, r14
+          AND           r8, r8, r14
+          ORR           r10, r6, r7, LSL #16             @ Aq[2] -- Aq[1]
+          ORR           r11, r8, r9, LSL #16             @ Aq[4] -- Aq[3]
+          STR           r10, [r13, #-4]
+          STR           r11, [r13, #-8]
+
+          LDRSH         r6, [r0, #10]                    @ load Aq[5]
+          LDRSH         r7, [r0, #12]                    @ load Aq[6]
+          LDRSH         r8, [r0, #14]                    @ load Aq[7]
+          LDRSH         r9, [r0, #16]                    @ load Aq[8]
+          AND           r6, r6, r14
+          AND           r8, r8, r14
+          ORR           r10, r6, r7, LSL #16             @ Aq[6] -- Aq[5]
+          ORR           r11, r8, r9, LSL #16             @ Aq[8] -- Aq[7]
+          STR           r10, [r13, #-12]
+          STR           r11, [r13, #-16]
+
+          LDRSH         r6, [r0, #18]                    @ load Aq[9]
+          LDRSH         r7, [r0, #20]                    @ load Aq[10]
+          LDRSH         r8, [r0, #22]                    @ load Aq[11]
+          LDRSH         r9, [r0, #24]                    @ load Aq[12]
+          AND           r6, r6, r14
+          AND           r8, r8, r14
+          ORR           r10, r6, r7, LSL #16             @ Aq[10] -- Aq[9]
+          ORR           r11, r8, r9, LSL #16             @ Aq[12] -- Aq[11]
+          STR           r10, [r13, #-20]
+          STR           r11, [r13, #-24]
+
+          LDRSH         r6, [r0, #26]                    @ load Aq[13]
+          LDRSH         r7, [r0, #28]                    @ load Aq[14]
+          LDRSH         r8, [r0, #30]                    @ load Aq[15]
+          LDRSH         r9, [r0, #32]                    @ load Aq[16]
+          AND           r6, r6, r14
+          AND           r8, r8, r14
+          ORR           r10, r6, r7, LSL #16             @ Aq[14] -- Aq[13]
+          ORR           r11, r8, r9, LSL #16             @ Aq[16] -- Aq[15]
+          STR           r10, [r13, #-28]
+          STR           r11, [r13, #-32]
+
+          MOV           r8, #0                           @ i = 0
+
+LOOP:
+          LDRSH         r6, [r5, #-2]                    @ load sig_lo[i-1]
+          LDRSH         r7, [r5, #-4]                    @ load sig_lo[i-2]
+
+          LDR           r11, [r13, #-4]                  @ Aq[2] -- Aq[1]
+          LDRSH         r9, [r5, #-6]                    @ load sig_lo[i-3]
+          LDRSH         r10, [r5, #-8]                   @ load sig_lo[i-4]
+
+          SMULBB        r12, r6, r11                     @ sig_lo[i-1] * Aq[1]
+
+          LDRSH         r6, [r5, #-10]                   @ load sig_lo[i-5]
+          SMLABT        r12, r7, r11, r12                @ sig_lo[i-2] * Aq[2]
+          LDR           r11, [r13, #-8]                  @ Aq[4] -- Aq[3]
+          LDRSH         r7, [r5, #-12]                   @ load sig_lo[i-6]
+          SMLABB        r12, r9, r11, r12                @ sig_lo[i-3] * Aq[3]
+          LDRSH         r9, [r5, #-14]                   @ load sig_lo[i-7]
+          SMLABT        r12, r10, r11, r12               @ sig_lo[i-4] * Aq[4]
+          LDR           r11, [r13, #-12]                 @ Aq[6] -- Aq[5]
+          LDRSH         r10, [r5, #-16]                  @ load sig_lo[i-8]
+          SMLABB        r12, r6, r11, r12                @ sig_lo[i-5] * Aq[5]
+          LDRSH         r6,  [r5, #-18]                  @ load sig_lo[i-9]
+          SMLABT        r12, r7, r11, r12                @ sig_lo[i-6] * Aq[6]
+          LDR           r11, [r13, #-16]                 @ Aq[8] -- Aq[7]
+          LDRSH         r7,  [r5, #-20]                  @ load sig_lo[i-10]
+          SMLABB        r12, r9, r11, r12                @ sig_lo[i-7] * Aq[7]
+          LDRSH         r9, [r5, #-22]                   @ load sig_lo[i-11]
+          SMLABT        r12, r10, r11, r12               @ sig_lo[i-8] * Aq[8]
+          LDR           r11, [r13, #-20]                 @ Aq[10] -- Aq[9]
+          LDRSH         r10,[r5, #-24]                   @ load sig_lo[i-12]
+          SMLABB        r12, r6, r11, r12                @ sig_lo[i-9] * Aq[9]
+          LDRSH         r6, [r5, #-26]                   @ load sig_lo[i-13]
+          SMLABT        r12, r7, r11, r12                @ sig_lo[i-10] * Aq[10]
+          LDR           r11, [r13, #-24]                 @ Aq[12] -- Aq[11]
+          LDRSH         r7, [r5, #-28]                   @ load sig_lo[i-14]
+          SMLABB        r12, r9, r11, r12                @ sig_lo[i-11] * Aq[11]
+          LDRSH         r9, [r5, #-30]                   @ load sig_lo[i-15]
+          SMLABT        r12, r10, r11, r12               @ sig_lo[i-12] * Aq[12]
+
+          LDR           r11, [r13, #-28]                 @ Aq[14] -- Aq[13]
+          LDRSH         r10, [r5, #-32]                  @ load sig_lo[i-16]
+          SMLABB        r12, r6, r11, r12                @ sig_lo[i-13] * Aq[13]
+          SMLABT        r12, r7, r11, r12                @ sig_lo[i-14] * Aq[14]
+
+          LDR           r11, [r13, #-32]                 @ Aq[16] -- Aq[15]
+          LDRSH         r6, [r2],#2                      @ load exc[i]
+          SMLABB        r12, r9, r11, r12                @ sig_lo[i-15] * Aq[15]
+          SMLABT        r12, r10, r11, r12               @ sig_lo[i-16] * Aq[16]
+          MUL           r7, r6, r3                       @ exc[i] * a0
+          RSB           r14, r12, #0                     @ L_tmp
+          MOV           r14, r14, ASR #11                @ L_tmp >>= 11
+          ADD           r14, r14, r7, LSL #1             @ L_tmp += (exc[i] * a0) << 1
+
+
+          LDRSH         r6, [r4, #-2]                    @ load sig_hi[i-1]
+          LDRSH         r7, [r4, #-4]                    @ load sig_hi[i-2]
+
+          LDR           r11, [r13, #-4]                  @ Aq[2] -- Aq[1]
+          LDRSH         r9, [r4, #-6]                    @ load sig_hi[i-3]
+          LDRSH         r10, [r4, #-8]                   @ load sig_hi[i-4]
+          SMULBB        r12, r6, r11                     @ sig_hi[i-1] * Aq[1]
+          LDRSH         r6, [r4, #-10]                   @ load sig_hi[i-5]
+	  SMLABT        r12, r7, r11, r12                @ sig_hi[i-2] * Aq[2]
+
+          LDR           r11, [r13, #-8]                  @ Aq[4] -- Aq[3]
+          LDRSH         r7, [r4, #-12]                   @ load sig_hi[i-6]
+
+          SMLABB        r12, r9, r11, r12                @ sig_hi[i-3] * Aq[3]
+	  LDRSH         r9, [r4, #-14]                   @ load sig_hi[i-7]
+
+	  SMLABT        r12, r10, r11, r12               @ sig_hi[i-4] * Aq[4]
+
+          LDR           r11, [r13, #-12]                 @ Aq[6] -- Aq[5]
+          LDRSH         r10, [r4, #-16]                  @ load sig_hi[i-8]
+
+	  SMLABB        r12, r6, r11, r12                @ sig_hi[i-5] * Aq[5]
+
+	  LDRSH         r6,  [r4, #-18]                  @ load sig_hi[i-9]
+	  SMLABT        r12, r7, r11, r12                @ sig_hi[i-6] * Aq[6]
+
+          LDR           r11, [r13, #-16]                 @ Aq[8] -- Aq[7]
+          LDRSH         r7,  [r4, #-20]                  @ load sig_hi[i-10]
+
+	  SMLABB        r12, r9, r11, r12                @ sig_hi[i-7] * Aq[7]
+
+	  LDRSH         r9, [r4, #-22]                   @ load sig_hi[i-11]
+
+	  SMLABT        r12, r10, r11, r12               @ sig_hi[i-8] * Aq[8]
+
+          LDR           r11, [r13, #-20]                 @ Aq[10] -- Aq[9]
+          LDRSH         r10,[r4, #-24]                   @ load sig_hi[i-12]
+
+	  SMLABB        r12, r6, r11, r12                @ sig_hi[i-9] * Aq[9]
+          LDRSH         r6, [r4, #-26]                   @ load sig_hi[i-13]
+          SMLABT        r12, r7, r11, r12                @ sig_hi[i-10] * Aq[10]
+
+          LDR           r11, [r13, #-24]                 @ Aq[12] -- Aq[11]
+          LDRSH         r7, [r4, #-28]                   @ load sig_hi[i-14]
+          SMLABB        r12, r9, r11, r12                @ sig_hi[i-11] * Aq[11]
+          LDRSH         r9, [r4, #-30]                   @ load sig_hi[i-15]
+          SMLABT        r12, r10, r11, r12               @ sig_hi[i-12] * Aq[12]
+
+          LDR           r11, [r13, #-28]                 @ Aq[14] -- Aq[13]
+          LDRSH         r10, [r4, #-32]                  @ load sig_hi[i-16]
+          SMLABB        r12, r6, r11, r12                @ sig_hi[i-13] * Aq[13]
+          SMLABT        r12, r7, r11, r12                @ sig_hi[i-14] * Aq[14]
+
+          LDR           r11, [r13, #-32]                 @ Aq[16] -- Aq[15]
+          SMLABB        r12, r9, r11, r12                @ sig_hi[i-15] * Aq[15]
+          SMLABT        r12, r10, r11, r12               @ sig_hi[i-16] * Aq[16]
+          ADD           r6, r12, r12                     @ r12 << 1
+          SUB           r14, r14, r6
+          MOV           r14, r14, LSL #3                 @ L_tmp <<=3
+
+          MOV           r7, r14, ASR #16                 @ L_tmp >> 16
+
+          MOV           r14, r14, ASR #4                 @ L_tmp >>=4
+          STRH          r7, [r4], #2                         @ sig_hi[i] = L_tmp >> 16
+          SUB           r9, r14, r7, LSL #12             @ sig_lo[i] = L_tmp - (sig_hi[i] << 12)
+
+          ADD           r8, r8, #1
+          STRH          r9, [r5], #2
+          CMP           r8, #64
+          BLT           LOOP
+
+Syn_filt_32_end:
+
+          LDMFD   	    r13!, {r4 - r12, r15}
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/convolve_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/convolve_opt.s
index 0228bda..71bb532 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/convolve_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/convolve_opt.s
@@ -27,24 +27,24 @@
 @  r3 --- L
 
 	.section  .text
-        .global   Convolve_asm 
+        .global   Convolve_asm
 
 Convolve_asm:
 
-        STMFD          r13!, {r4 - r12, r14}  
+        STMFD          r13!, {r4 - r12, r14}
         MOV            r3,  #0                           @ n
 	MOV            r11, #0x8000
-        
-LOOP: 
+
+LOOP:
         ADD            r4, r1, r3, LSL #1                @ tmpH address
         ADD            r5, r3, #1                        @ i = n + 1
         MOV            r6, r0                            @ tmpX = x
         LDRSH          r9,  [r6], #2                     @ *tmpX++
         LDRSH          r10, [r4], #-2                    @ *tmpH--
         SUB            r5, r5, #1
-        MUL            r8,  r9, r10 
+        MUL            r8,  r9, r10
 
-LOOP1:                    
+LOOP1:
         CMP            r5, #0
         BLE            L1
 	LDRSH          r9,  [r6], #2                     @ *tmpX++
@@ -58,12 +58,12 @@ LOOP1:
 	LDRSH          r12, [r6], #2                     @ *tmpX++
 	LDRSH          r14, [r4], #-2                    @ *tmpH--
 	MLA            r8, r9, r10, r8
-        SUBS           r5, r5, #4 
+        SUBS           r5, r5, #4
 	MLA            r8, r12, r14, r8
-    
-        B              LOOP1  
 
-L1:                  
+        B              LOOP1
+
+L1:
 
         ADD            r5, r11, r8, LSL #1
         MOV            r5, r5, LSR #16                   @extract_h(s)
@@ -75,14 +75,14 @@ L1:
         ADD            r5, r3, #1
         MOV            r6, r0
         LDRSH          r9,  [r6], #2                     @ *tmpX++
-        LDRSH          r10, [r4], #-2                     
+        LDRSH          r10, [r4], #-2
         LDRSH          r12, [r6], #2
         LDRSH          r14, [r4], #-2
 
         MUL            r8, r9, r10
         SUB            r5, r5, #2
         MLA            r8, r12, r14, r8
-        
+
 LOOP2:
         CMP            r5, #0
         BLE            L2
@@ -97,14 +97,14 @@ LOOP2:
 	LDRSH          r12, [r6], #2                     @ *tmpX++
 	LDRSH          r14, [r4], #-2                    @ *tmpH--
 	MLA            r8, r9, r10, r8
-        SUBS           r5, r5, #4 
+        SUBS           r5, r5, #4
 	MLA            r8, r12, r14, r8
         B              LOOP2
 
 L2:
         ADD            r8, r11, r8, LSL #1
         MOV            r8, r8, LSR #16                   @extract_h(s)
-        ADD            r3, r3, #1  
+        ADD            r3, r3, #1
         STRH           r8, [r2], #2                      @y[n]
 
         ADD            r4, r1, r3, LSL #1
@@ -117,7 +117,7 @@ L2:
         MUL            r8, r9, r10
         LDRSH          r9,  [r6], #2
         LDRSH          r10, [r4], #-2
-        MLA            r8, r12, r14, r8 
+        MLA            r8, r12, r14, r8
         SUB            r5, r5, #3
         MLA            r8, r9, r10, r8
 
@@ -135,9 +135,9 @@ LOOP3:
 	LDRSH          r12, [r6], #2                     @ *tmpX++
 	LDRSH          r14, [r4], #-2                    @ *tmpH--
 	MLA            r8, r9, r10, r8
-        SUBS           r5, r5, #4 
-	MLA            r8, r12, r14, r8 
-        B              LOOP3   
+        SUBS           r5, r5, #4
+	MLA            r8, r12, r14, r8
+        B              LOOP3
 
 L3:
         ADD            r8, r11, r8, LSL #1
@@ -150,7 +150,7 @@ L3:
         MOV            r6, r0
         MOV            r8, #0
 
-LOOP4:                    
+LOOP4:
         CMP            r5, #0
         BLE            L4
 	LDRSH          r9,  [r6], #2                     @ *tmpX++
@@ -164,22 +164,22 @@ LOOP4:
 	LDRSH          r12, [r6], #2                     @ *tmpX++
 	LDRSH          r14, [r4], #-2                    @ *tmpH--
 	MLA            r8, r9, r10, r8
-        SUBS           r5, r5, #4 
-	MLA            r8, r12, r14, r8        
-        B              LOOP4    
-L4:                  
+        SUBS           r5, r5, #4
+	MLA            r8, r12, r14, r8
+        B              LOOP4
+L4:
         ADD            r5, r11, r8, LSL #1
         MOV            r5, r5, LSR #16                   @extract_h(s)
         ADD            r3, r3, #1
         STRH           r5, [r2], #2                      @y[n]
-        
+
         CMP            r3, #64
         BLT            LOOP
-                
-Convolve_asm_end: 
- 
+
+Convolve_asm_end:
+
         LDMFD      r13!, {r4 - r12, r15}
-    
+
         @ENDFUNC
         .END
 
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/cor_h_vec_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/cor_h_vec_opt.s
index 441b984..2d4c7cc 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/cor_h_vec_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/cor_h_vec_opt.s
@@ -1,151 +1,151 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@static void cor_h_vec_012(
-@		Word16 h[],                           /* (i) scaled impulse response                 */
-@		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
-@		Word16 track,                         /* (i) track to use                            */
-@		Word16 sign[],                        /* (i) sign vector                             */
-@		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
-@		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
-@		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
-@)
-@r0 ---- h[]
-@r1 ---- vec[]
-@r2 ---- track
-@r3 ---- sign[]
-@r4 ---- rrixix[][NB_POS]
-@r5 ---- cor_1[]
-@r6 ---- cor_2[]
-
-
-          .section  .text
-	  .global  cor_h_vec_012_asm
-
-cor_h_vec_012_asm:
-
-         STMFD         r13!, {r4 - r12, r14}
-	 LDR           r4, [r13, #40]                    @load rrixix[][NB_POS]
-	 ADD           r7, r4, r2, LSL #5                @r7 --- p0 = rrixix[track]
-         MOV           r4, #0                            @i=0
-
-	 @r0 --- h[], r1 --- vec[],  r2 --- pos
-	 @r3 --- sign[], r4 --- i, r7 --- p0
-LOOPi:
-         MOV           r5, #0                            @L_sum1 = 0
-         MOV           r6, #0                            @L_sum2 = 0
-         ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
-         MOV           r10, r0                           @p1 = h
-         RSB           r11, r2, #62                      @j=62-pos
-
-LOOPj1:
-	 LDRSH         r12, [r10], #2  
-	 LDRSH         r8,  [r9], #2
-	 LDRSH         r14, [r9]
-	 SUBS          r11, r11, #1
-         MLA           r5, r12, r8, r5
-         MLA           r6, r12, r14, r6	 
-	 BGE           LOOPj1
-
-	 LDRSH         r12, [r10], #2                     @*p1++
-	 MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
-         MLA           r5, r12, r14, r5
-         MOV           r14, #0x8000
-         MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
-         ADD           r10, r6, r14         
-         ADD           r9, r5, r14
-         MOV           r5, r9, ASR #16
-         MOV           r6, r10, ASR #16
-         ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
-         ADD           r8, r7, #32
-         LDRSH         r10, [r9], #2                 	  @sign[pos]
-	 LDRSH         r11, [r9]                          @sign[pos + 1]
-	 MUL           r12, r5, r10
-	 MUL           r14, r6, r11
-	 MOV           r5, r12, ASR #15
-	 MOV           r6, r14, ASR #15
-	 LDR           r9,  [r13, #44]                   
-	 LDR           r12, [r13, #48]
-         LDRSH         r10, [r7], #2                      @*p0++
-	 LDRSH         r11, [r8]                          @*p3++
-         ADD           r9, r9, r4, LSL #1
-	 ADD           r12, r12, r4, LSL #1
-	 ADD           r5, r5, r10
-	 ADD           r6, r6, r11
-	 STRH          r5, [r9]
-	 STRH          r6, [r12]
-
-         ADD           r2, r2, #4
- 
-         MOV           r5, #0                            @L_sum1 = 0
-	 MOV           r6, #0                            @L_sum2 = 0
-	 ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
-	 MOV           r10, r0                           @p1 = h
-	 RSB           r11, r2, #62                      @j=62-pos
-	 ADD           r4, r4, #1                        @i++
-
-LOOPj2:
-	 LDRSH         r12, [r10], #2  
-	 LDRSH         r8,  [r9], #2
-	 LDRSH         r14, [r9]
-	 SUBS          r11, r11, #1
-         MLA           r5, r12, r8, r5
-         MLA           r6, r12, r14, r6	 
-	 BGE           LOOPj2
-
-	 LDRSH         r12, [r10], #2                     @*p1++
-	 MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
-         MLA           r5, r12, r14, r5
-         MOV           r14, #0x8000
-         MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
-         ADD           r10, r6, r14        
-         ADD           r9, r5, r14
-
-         MOV           r5, r9, ASR #16
-         MOV           r6, r10, ASR #16
-         ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
-         ADD           r8, r7, #32
-         LDRSH         r10, [r9], #2                 	  @sign[pos]
-	 LDRSH         r11, [r9]                          @sign[pos + 1]
-	 MUL           r12, r5, r10
-	 MUL           r14, r6, r11
-	 MOV           r5, r12, ASR #15
-	 MOV           r6, r14, ASR #15
-	 LDR           r9,  [r13, #44]                   
-	 LDR           r12, [r13, #48]
-         LDRSH         r10, [r7], #2                      @*p0++
-	 LDRSH         r11, [r8]                          @*p3++
-         ADD           r9, r9, r4, LSL #1
-	 ADD           r12, r12, r4, LSL #1
-	 ADD           r5, r5, r10
-	 ADD           r6, r6, r11
-	 STRH          r5, [r9]
-	 STRH          r6, [r12]
-	 ADD           r4, r4, #1                         @i+1
-	 ADD           r2, r2, #4                         @pos += STEP
-	 CMP           r4, #16
-	 
-	 BLT           LOOPi
-         
-the_end:
-         LDMFD         r13!, {r4 - r12, r15}
-      
-         @ENDFUNC
-         .END	 
-        
-	
-	  
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@static void cor_h_vec_012(
+@		Word16 h[],                           /* (i) scaled impulse response                 */
+@		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
+@		Word16 track,                         /* (i) track to use                            */
+@		Word16 sign[],                        /* (i) sign vector                             */
+@		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
+@		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
+@		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
+@)
+@r0 ---- h[]
+@r1 ---- vec[]
+@r2 ---- track
+@r3 ---- sign[]
+@r4 ---- rrixix[][NB_POS]
+@r5 ---- cor_1[]
+@r6 ---- cor_2[]
+
+
+          .section  .text
+	  .global  cor_h_vec_012_asm
+
+cor_h_vec_012_asm:
+
+         STMFD         r13!, {r4 - r12, r14}
+	 LDR           r4, [r13, #40]                    @load rrixix[][NB_POS]
+	 ADD           r7, r4, r2, LSL #5                @r7 --- p0 = rrixix[track]
+         MOV           r4, #0                            @i=0
+
+	 @r0 --- h[], r1 --- vec[],  r2 --- pos
+	 @r3 --- sign[], r4 --- i, r7 --- p0
+LOOPi:
+         MOV           r5, #0                            @L_sum1 = 0
+         MOV           r6, #0                            @L_sum2 = 0
+         ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
+         MOV           r10, r0                           @p1 = h
+         RSB           r11, r2, #62                      @j=62-pos
+
+LOOPj1:
+	 LDRSH         r12, [r10], #2
+	 LDRSH         r8,  [r9], #2
+	 LDRSH         r14, [r9]
+	 SUBS          r11, r11, #1
+         MLA           r5, r12, r8, r5
+         MLA           r6, r12, r14, r6
+	 BGE           LOOPj1
+
+	 LDRSH         r12, [r10], #2                     @*p1++
+	 MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
+         MLA           r5, r12, r14, r5
+         MOV           r14, #0x8000
+         MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
+         ADD           r10, r6, r14
+         ADD           r9, r5, r14
+         MOV           r5, r9, ASR #16
+         MOV           r6, r10, ASR #16
+         ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
+         ADD           r8, r7, #32
+         LDRSH         r10, [r9], #2                 	  @sign[pos]
+	 LDRSH         r11, [r9]                          @sign[pos + 1]
+	 MUL           r12, r5, r10
+	 MUL           r14, r6, r11
+	 MOV           r5, r12, ASR #15
+	 MOV           r6, r14, ASR #15
+	 LDR           r9,  [r13, #44]
+	 LDR           r12, [r13, #48]
+         LDRSH         r10, [r7], #2                      @*p0++
+	 LDRSH         r11, [r8]                          @*p3++
+         ADD           r9, r9, r4, LSL #1
+	 ADD           r12, r12, r4, LSL #1
+	 ADD           r5, r5, r10
+	 ADD           r6, r6, r11
+	 STRH          r5, [r9]
+	 STRH          r6, [r12]
+
+         ADD           r2, r2, #4
+
+         MOV           r5, #0                            @L_sum1 = 0
+	 MOV           r6, #0                            @L_sum2 = 0
+	 ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
+	 MOV           r10, r0                           @p1 = h
+	 RSB           r11, r2, #62                      @j=62-pos
+	 ADD           r4, r4, #1                        @i++
+
+LOOPj2:
+	 LDRSH         r12, [r10], #2
+	 LDRSH         r8,  [r9], #2
+	 LDRSH         r14, [r9]
+	 SUBS          r11, r11, #1
+         MLA           r5, r12, r8, r5
+         MLA           r6, r12, r14, r6
+	 BGE           LOOPj2
+
+	 LDRSH         r12, [r10], #2                     @*p1++
+	 MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
+         MLA           r5, r12, r14, r5
+         MOV           r14, #0x8000
+         MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
+         ADD           r10, r6, r14
+         ADD           r9, r5, r14
+
+         MOV           r5, r9, ASR #16
+         MOV           r6, r10, ASR #16
+         ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
+         ADD           r8, r7, #32
+         LDRSH         r10, [r9], #2                 	  @sign[pos]
+	 LDRSH         r11, [r9]                          @sign[pos + 1]
+	 MUL           r12, r5, r10
+	 MUL           r14, r6, r11
+	 MOV           r5, r12, ASR #15
+	 MOV           r6, r14, ASR #15
+	 LDR           r9,  [r13, #44]
+	 LDR           r12, [r13, #48]
+         LDRSH         r10, [r7], #2                      @*p0++
+	 LDRSH         r11, [r8]                          @*p3++
+         ADD           r9, r9, r4, LSL #1
+	 ADD           r12, r12, r4, LSL #1
+	 ADD           r5, r5, r10
+	 ADD           r6, r6, r11
+	 STRH          r5, [r9]
+	 STRH          r6, [r12]
+	 ADD           r4, r4, #1                         @i+1
+	 ADD           r2, r2, #4                         @pos += STEP
+	 CMP           r4, #16
+
+	 BLT           LOOPi
+
+the_end:
+         LDMFD         r13!, {r4 - r12, r15}
+
+         @ENDFUNC
+         .END
+
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/pred_lt4_1_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/pred_lt4_1_opt.s
index d5dd8f0..e0b338d 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/pred_lt4_1_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/pred_lt4_1_opt.s
@@ -1,460 +1,460 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@void Pred_lt4(
-@		  Word16 exc[],                         /* in/out: excitation buffer */
-@		  Word16 T0,                            /* input : integer pitch lag */
-@		  Word16 frac,                          /* input : fraction of lag   */
-@		  Word16 L_subfr                        /* input : subframe size     */
-@	      )
-
-@******************************
-@       ARM Register
-@******************************
-@ r0  ---  exc[]
-@ r1  ---  T0
-@ r2  ---  frac
-@ r3  ---  L_subfr
-
-         .section  .text
-	 .global   pred_lt4_asm
-	 .extern   inter4_2
-
-pred_lt4_asm:
-
-         STMFD     r13!, {r4 - r12, r14} 
-         RSB       r4, r1, #0                         @-T0
-         RSB       r2, r2, #0                         @frac = -frac
-         ADD       r5, r0, r4, LSL #1                 @x = exc - T0
-         CMP       r2, #0
-         ADDLT     r2, r2, #4                         @frac += UP_SAMP
-         SUBLT     r5, r5, #2                         @x--
-         SUB       r5, r5, #30                        @x -= 15
-         RSB       r4, r2, #3                         @k = 3 - frac
-         LDR       r6, Table
-	 MOV       r8, r4, LSL #6                    
-         @MOV       r7, #0                             @j = 0
-         ADD       r8, r6, r8                         @ptr2 = &(inter4_2[k][0])
-
-	 MOV       r1, r5
-	 MOV       r5, #0x8000
-	 MOV       r14, #21
-@ used register
-         @r0 --- exc[]  r1 --- x  r7 --- j  r8 --- ptr2  r5 --- 0x8000
-THREE_LOOP:
-
-         @MOV       r1, r5                             @ptr1 = x
-	 MOV       r2, r8                             @ptr = ptr2
-         LDR       r3, [r2], #4                       @h[0], h[1]
-	 LDRSH     r4, [r1], #2                       @x[0]
-	 LDRSH     r6, [r1], #2                       @x[1]
-	 LDRSH     r9, [r1], #2                       @x[2]
-
-	 SMULBB    r10, r4, r3                        @x[0] * h[0]                  
-	 SMULBB    r11, r6, r3                        @x[1] * h[0]
-	 SMULBB    r12, r9, r3                        @x[2] * h[0]
-
-         LDRSH     r4, [r1], #2                       @x[3]
-	 SMLABT    r10, r6, r3, r10                   @x[1] * h[1]
-         SMLABT    r11, r9, r3, r11                   @x[2] * h[1]
-	 SMLABT    r12, r4, r3, r12                   @x[3] * h[1]
-
-	 LDR       r3, [r2], #4                       @h[2], h[3]
-	 LDRSH     r6, [r1], #2                       @x[4]
-	 SMLABB    r10, r9, r3, r10                   @x[2] * h[2]
-         SMLABB    r11, r4, r3, r11                   @x[3] * h[2]
-         SMLABB    r12, r6, r3, r12                   @x[4] * h[2]
-
-         LDRSH     r9, [r1], #2                       @x[5]
-         SMLABT    r10, r4, r3, r10                   @x[3] * h[3]
-         SMLABT    r11, r6, r3, r11                   @x[4] * h[3]
-         SMLABT    r12, r9, r3, r12                   @x[5] * h[3]
-
-         LDR       r3, [r2], #4                       @h[4], h[5]
-         LDRSH     r4, [r1], #2                       @x[6]
-         SMLABB    r10, r6, r3, r10                   @x[4] * h[4]
-         SMLABB    r11, r9, r3, r11                   @x[5] * h[4]
-         SMLABB    r12, r4, r3, r12                   @x[6] * h[4]
-
-	 LDRSH     r6, [r1], #2                       @x[7]
-	 SMLABT    r10, r9, r3, r10                   @x[5] * h[5]
-	 SMLABT    r11, r4, r3, r11                   @x[6] * h[5]
-	 SMLABT    r12, r6, r3, r12                   @x[7] * h[5]
-
-         LDR       r3, [r2], #4                       @h[6], h[7]
-	 LDRSH     r9, [r1], #2                       @x[8]
-	 SMLABB    r10, r4, r3, r10                   @x[6] * h[6]
-	 SMLABB    r11, r6, r3, r11                   @x[7] * h[6]
-	 SMLABB    r12, r9, r3, r12                   @x[8] * h[6]
-
-	 LDRSH     r4, [r1], #2                       @x[9]
-	 SMLABT    r10, r6, r3, r10                   @x[7] * h[7]
-	 SMLABT    r11, r9, r3, r11                   @x[8] * h[7]
-	 SMLABT    r12, r4, r3, r12                   @x[9] * h[7]
-
-	 LDR       r3, [r2], #4                       @h[8], h[9]
-	 LDRSH     r6, [r1], #2                       @x[10]
-	 SMLABB    r10, r9, r3, r10                   @x[8] * h[8]
-	 SMLABB    r11, r4, r3, r11                   @x[9] * h[8]
-	 SMLABB    r12, r6, r3, r12                   @x[10] * h[8]
-
-	 LDRSH     r9, [r1], #2                       @x[11]
-	 SMLABT    r10, r4, r3, r10                   @x[9] * h[9]
-	 SMLABT    r11, r6, r3, r11                   @x[10] * h[9]
-	 SMLABT    r12, r9, r3, r12                   @x[11] * h[9]
-
-         LDR       r3, [r2], #4                       @h[10], h[11]
-	 LDRSH     r4, [r1], #2                       @x[12]
-         SMLABB    r10, r6, r3, r10                   @x[10] * h[10]
-	 SMLABB    r11, r9, r3, r11                   @x[11] * h[10]
-	 SMLABB    r12, r4, r3, r12                   @x[12] * h[10]
-
-	 LDRSH     r6, [r1], #2                       @x[13]
-	 SMLABT    r10, r9, r3, r10                   @x[11] * h[11]
-	 SMLABT    r11, r4, r3, r11                   @x[12] * h[11]
-	 SMLABT    r12, r6, r3, r12                   @x[13] * h[11]
-
-	 LDR       r3, [r2], #4                       @h[12], h[13]
-	 LDRSH     r9, [r1], #2                       @x[14]
-	 SMLABB    r10, r4, r3, r10                   @x[12] * h[12]
-	 SMLABB    r11, r6, r3, r11                   @x[13] * h[12]
-	 SMLABB    r12, r9, r3, r12                   @x[14] * h[12]
-
-	 LDRSH     r4, [r1], #2                       @x[15]
-	 SMLABT    r10, r6, r3, r10                   @x[13] * h[13]
-	 SMLABT    r11, r9, r3, r11                   @x[14] * h[13]
-	 SMLABT    r12, r4, r3, r12                   @x[15] * h[13]
-
-	 LDR       r3, [r2], #4                       @h[14], h[15]
-	 LDRSH     r6, [r1], #2                       @x[16]
-	 SMLABB    r10, r9, r3, r10                   @x[14] * h[14]
-	 SMLABB    r11, r4, r3, r11                   @x[15] * h[14]
-	 SMLABB    r12, r6, r3, r12                   @x[16] * h[14]
-
-	 LDRSH     r9, [r1], #2                       @x[17]
-         SMLABT    r10, r4, r3, r10                   @x[15] * h[15]
-	 SMLABT    r11, r6, r3, r11                   @x[16] * h[15]
-	 SMLABT    r12, r9, r3, r12                   @x[17] * h[15]
-
-	 LDR       r3, [r2], #4                       @h[16], h[17]
-	 LDRSH     r4, [r1], #2                       @x[18]
-	 SMLABB    r10, r6, r3, r10                   @x[16] * h[16]
-	 SMLABB    r11, r9, r3, r11                   @x[17] * h[16]
-	 SMLABB    r12, r4, r3, r12                   @x[18] * h[16]
-
-         LDRSH     r6, [r1], #2                       @x[19]
-	 SMLABT    r10, r9, r3, r10                   @x[17] * h[17]
-	 SMLABT    r11, r4, r3, r11                   @x[18] * h[17]
-	 SMLABT    r12, r6, r3, r12                   @x[19] * h[17]
-
-	 LDR       r3, [r2], #4                       @h[18], h[19]
-         LDRSH     r9, [r1], #2                       @x[20]
-	 SMLABB    r10, r4, r3, r10                   @x[18] * h[18]
-	 SMLABB    r11, r6, r3, r11                   @x[19] * h[18]
-	 SMLABB    r12, r9, r3, r12                   @x[20] * h[18]
-
-	 LDRSH     r4, [r1], #2                       @x[21]
-	 SMLABT    r10, r6, r3, r10                   @x[19] * h[19]
-	 SMLABT    r11, r9, r3, r11                   @x[20] * h[19]
-	 SMLABT    r12, r4, r3, r12                   @x[21] * h[19]
-
-	 LDR       r3, [r2], #4                       @h[20], h[21]
-	 LDRSH     r6, [r1], #2                       @x[22]
-	 SMLABB    r10, r9, r3, r10                   @x[20] * h[20]
-	 SMLABB    r11, r4, r3, r11                   @x[21] * h[20]
-	 SMLABB    r12, r6, r3, r12                   @x[22] * h[20]
-
-	 LDRSH     r9, [r1], #2                       @x[23]
-	 SMLABT    r10, r4, r3, r10                   @x[21] * h[21]
-	 SMLABT    r11, r6, r3, r11                   @x[22] * h[21]
-	 SMLABT    r12, r9, r3, r12                   @x[23] * h[21]
-
-	 LDR       r3, [r2], #4                       @h[22], h[23]
-	 LDRSH     r4, [r1], #2                       @x[24]
-	 SMLABB    r10, r6, r3, r10                   @x[22] * h[22]
-	 SMLABB    r11, r9, r3, r11                   @x[23] * h[22]
-	 SMLABB    r12, r4, r3, r12                   @x[24] * h[22]
-
-         LDRSH     r6, [r1], #2                       @x[25]
-	 SMLABT    r10, r9, r3, r10                   @x[23] * h[23]
-	 SMLABT    r11, r4, r3, r11                   @x[24] * h[23]
-	 SMLABT    r12, r6, r3, r12                   @x[25] * h[23]
-
-	 LDR       r3, [r2], #4                       @h[24], h[25]
-         LDRSH     r9, [r1], #2                       @x[26]
-	 SMLABB    r10, r4, r3, r10                   @x[24] * h[24]
-	 SMLABB    r11, r6, r3, r11                   @x[25] * h[24]
-	 SMLABB    r12, r9, r3, r12                   @x[26] * h[24]
-
-	 LDRSH     r4, [r1], #2                       @x[27]
-	 SMLABT    r10, r6, r3, r10                   @x[25] * h[25]
-	 SMLABT    r11, r9, r3, r11                   @x[26] * h[25]
-	 SMLABT    r12, r4, r3, r12                   @x[27] * h[25]
-
-	 LDR       r3, [r2], #4                       @h[26], h[27]
-	 LDRSH     r6, [r1], #2                       @x[28]
-	 SMLABB    r10, r9, r3, r10                   @x[26] * h[26]
-	 SMLABB    r11, r4, r3, r11                   @x[27] * h[26]
-	 SMLABB    r12, r6, r3, r12                   @x[28] * h[26]
-
-	 LDRSH     r9, [r1], #2                       @x[29]
-	 SMLABT    r10, r4, r3, r10                   @x[27] * h[27]
-	 SMLABT    r11, r6, r3, r11                   @x[28] * h[27]
-	 SMLABT    r12, r9, r3, r12                   @x[29] * h[27]
-
-	 LDR       r3, [r2], #4                       @h[28], h[29]
-	 LDRSH     r4, [r1], #2                       @x[30]
-	 SMLABB    r10, r6, r3, r10                   @x[28] * h[28]
-	 SMLABB    r11, r9, r3, r11                   @x[29] * h[28]
-	 SMLABB    r12, r4, r3, r12                   @x[30] * h[28]
-
-         LDRSH     r6, [r1], #2                       @x[31]
-	 SMLABT    r10, r9, r3, r10                   @x[29] * h[29]
-	 SMLABT    r11, r4, r3, r11                   @x[30] * h[29]
-	 SMLABT    r12, r6, r3, r12                   @x[31] * h[29]
-
-	 LDR       r3, [r2], #4                       @h[30], h[31]
-         LDRSH     r9, [r1], #2                       @x[32]
-	 SMLABB    r10, r4, r3, r10                   @x[30] * h[30]
-	 SMLABB    r11, r6, r3, r11                   @x[31] * h[30]
-	 SMLABB    r12, r9, r3, r12                   @x[32] * h[30]
-
-	 LDRSH     r4, [r1], #-60                     @x[33]
-	 SMLABT    r10, r6, r3, r10                   @x[31] * h[31]
-	 SMLABT    r11, r9, r3, r11                   @x[32] * h[31]
-	 SMLABT    r12, r4, r3, r12                   @x[33] * h[31]
-
-	 @SSAT      r10, #32, r10, LSL #2
-	 @SSAT      r11, #32, r11, LSL #2
-	 @SSAT      r12, #32, r12, LSL #2
-
-	 MOV       r10, r10, LSL #1
-	 MOV       r11, r11, LSL #1
-	 MOV       r12, r12, LSL #1
-
-	 QADD      r10, r10, r10
-	 QADD      r11, r11, r11
-	 QADD      r12, r12, r12
-
-	 QADD      r10, r10, r5
-	 QADD      r11, r11, r5
-	 QADD      r12, r12, r5
-
-	 SUBS      r14, r14, #1
-
-	 MOV       r10, r10, ASR #16
-	 MOV       r11, r11, ASR #16
-	 MOV       r12, r12, ASR #16
-
-	 STRH      r10, [r0], #2
-	 STRH      r11, [r0], #2
-	 STRH      r12, [r0], #2
-	 BNE       THREE_LOOP
-
-	 MOV       r2, r8                             @ptr = ptr2
-
-Last2LOOP:
-
-         LDR       r3, [r2], #4                       @h[0], h[1]
-	 LDRSH     r4, [r1], #2                       @x[0]
-	 LDRSH     r6, [r1], #2                       @x[1]
-	 LDRSH     r9, [r1], #2                       @x[2]
-
-	 SMULBB    r10, r4, r3                        @x[0] * h[0]
-	 SMULBB    r11, r6, r3                        @x[1] * h[0]
-
-	 SMLABT    r10, r6, r3, r10                   @x[1] * h[1]
-	 SMLABT    r11, r9, r3, r11                   @x[2] * h[1]
-
-	 LDR       r3, [r2], #4                       @h[2], h[3]
-	 LDRSH     r4, [r1], #2                       @x[3]
-         LDRSH     r6, [r1], #2                       @x[4]
-
-	 SMLABB    r10, r9, r3, r10                   @x[2] * h[2]
-         SMLABB    r11, r4, r3, r11                   @x[3] * h[2]
-      
-	 SMLABT    r10, r4, r3, r10                   @x[3] * h[3]
-	 SMLABT    r11, r6, r3, r11                   @x[4] * h[3]
-
-	 LDR       r3, [r2], #4                       @h[4], h[5]
-	 LDRSH     r9, [r1], #2                       @x[5]
-	 LDRSH     r4, [r1], #2                       @x[6]
-
-	 SMLABB    r10, r6, r3, r10                   @x[4] * h[4]
-	 SMLABB    r11, r9, r3, r11                   @x[5] * h[4]
-
-	 SMLABT    r10, r9, r3, r10                   @x[5] * h[5]
-	 SMLABT    r11, r4, r3, r11                   @x[6] * h[5]
-
-	 LDR       r3, [r2], #4                       @h[6], h[7]
-	 LDRSH     r6, [r1], #2                       @x[7]
-	 LDRSH     r9, [r1], #2                       @x[8]
-
-	 SMLABB    r10, r4, r3, r10                   @x[6] * h[6]
-	 SMLABB    r11, r6, r3, r11                   @x[7] * h[6]
-
-	 SMLABT    r10, r6, r3, r10                   @x[7] * h[7]
-	 SMLABT    r11, r9, r3, r11                   @x[8] * h[7]
-
-	 LDR       r3, [r2], #4                       @h[8], h[9]
-	 LDRSH     r4, [r1], #2                       @x[9]
-	 LDRSH     r6, [r1], #2                       @x[10]
-
-	 SMLABB    r10, r9, r3, r10                   @x[8] * h[8]
-	 SMLABB    r11, r4, r3, r11                   @x[9] * h[8]
-
-	 SMLABT    r10, r4, r3, r10                   @x[9] * h[9]
-	 SMLABT    r11, r6, r3, r11                   @x[10] * h[9]
-
-	 LDR       r3, [r2], #4                       @h[10], h[11]
-	 LDRSH     r9, [r1], #2                       @x[11]
-	 LDRSH     r4, [r1], #2                       @x[12]
-
-	 SMLABB    r10, r6, r3, r10                   @x[10] * h[10]
-	 SMLABB    r11, r9, r3, r11                   @x[11] * h[10]
-
-	 SMLABT    r10, r9, r3, r10                   @x[11] * h[11]
-	 SMLABT    r11, r4, r3, r11                   @x[12] * h[11]
-
-	 LDR       r3, [r2], #4                       @h[12], h[13]
-	 LDRSH     r6, [r1], #2                       @x[13]
-	 LDRSH     r9, [r1], #2                       @x[14]
-
-	 SMLABB    r10, r4, r3, r10                   @x[12] * h[12]
-	 SMLABB    r11, r6, r3, r11                   @x[13] * h[12]
-
-	 SMLABT    r10, r6, r3, r10                   @x[13] * h[13]
-	 SMLABT    r11, r9, r3, r11                   @x[14] * h[13]
-
-	 LDR       r3, [r2], #4                       @h[14], h[15]
-	 LDRSH     r4, [r1], #2                       @x[15]
-	 LDRSH     r6, [r1], #2                       @x[16]
-
-	 SMLABB    r10, r9, r3, r10                   @x[14] * h[14]
-	 SMLABB    r11, r4, r3, r11                   @x[15] * h[14]
-
-	 SMLABT    r10, r4, r3, r10                   @x[15] * h[15]
-	 SMLABT    r11, r6, r3, r11                   @x[16] * h[15]
-
-	 LDR       r3, [r2], #4                       @h[16], h[17]
-	 LDRSH     r9, [r1], #2                       @x[17]
-	 LDRSH     r4, [r1], #2                       @x[18]
-
-	 SMLABB    r10, r6, r3, r10                   @x[16] * h[16]
-	 SMLABB    r11, r9, r3, r11                   @x[17] * h[16]
-
-	 SMLABT    r10, r9, r3, r10                   @x[17] * h[17]
-	 SMLABT    r11, r4, r3, r11                   @x[18] * h[17]
-
-	 LDR       r3, [r2], #4                       @h[18], h[19]
-	 LDRSH     r6, [r1], #2                       @x[19]
-	 LDRSH     r9, [r1], #2                       @x[20]
-
-	 SMLABB    r10, r4, r3, r10                   @x[18] * h[18]
-	 SMLABB    r11, r6, r3, r11                   @x[19] * h[18]
-
-	 SMLABT    r10, r6, r3, r10                   @x[19] * h[19]
-	 SMLABT    r11, r9, r3, r11                   @x[20] * h[19]
-
-	 LDR       r3, [r2], #4                       @h[20], h[21]
-	 LDRSH     r4, [r1], #2                       @x[21]
-	 LDRSH     r6, [r1], #2                       @x[22]
-
-	 SMLABB    r10, r9, r3, r10                   @x[20] * h[20]
-	 SMLABB    r11, r4, r3, r11                   @x[21] * h[20]
-
-	 SMLABT    r10, r4, r3, r10                   @x[21] * h[21]
-	 SMLABT    r11, r6, r3, r11                   @x[22] * h[21]
-
-	 LDR       r3, [r2], #4                       @h[22], h[23]
-	 LDRSH     r9, [r1], #2                       @x[23]
-	 LDRSH     r4, [r1], #2                       @x[24]
-
-	 SMLABB    r10, r6, r3, r10                   @x[22] * h[22]
-	 SMLABB    r11, r9, r3, r11                   @x[23] * h[22]
-
-	 SMLABT    r10, r9, r3, r10                   @x[23] * h[23]
-	 SMLABT    r11, r4, r3, r11                   @x[24] * h[23]
-
-	 LDR       r3, [r2], #4                       @h[24], h[25]
-	 LDRSH     r6, [r1], #2                       @x[25]
-	 LDRSH     r9, [r1], #2                       @x[26]
-
-	 SMLABB    r10, r4, r3, r10                   @x[24] * h[24]
-	 SMLABB    r11, r6, r3, r11                   @x[25] * h[24]
-
-	 SMLABT    r10, r6, r3, r10                   @x[25] * h[25]
-	 SMLABT    r11, r9, r3, r11                   @x[26] * h[25]
-
-	 LDR       r3, [r2], #4                       @h[26], h[27]
-	 LDRSH     r4, [r1], #2                       @x[27]
-	 LDRSH     r6, [r1], #2                       @x[28]
-
-	 SMLABB    r10, r9, r3, r10                   @x[26] * h[26]
-	 SMLABB    r11, r4, r3, r11                   @x[27] * h[26]
-
-	 SMLABT    r10, r4, r3, r10                   @x[27] * h[27]
-	 SMLABT    r11, r6, r3, r11                   @x[28] * h[27]
-
-	 LDR       r3, [r2], #4                       @h[28], h[29]
-	 LDRSH     r9, [r1], #2                       @x[29]
-	 LDRSH     r4, [r1], #2                       @x[30]
-
-	 SMLABB    r10, r6, r3, r10                   @x[28] * h[28]
-	 SMLABB    r11, r9, r3, r11                   @x[29] * h[28]
-
-	 SMLABT    r10, r9, r3, r10                   @x[29] * h[29]
-	 SMLABT    r11, r4, r3, r11                   @x[30] * h[29]
-
-	 LDR       r3, [r2], #4                       @h[30], h[31]
-	 LDRSH     r6, [r1], #2                       @x[31]
-	 LDRSH     r9, [r1], #2                       @x[32]
-
-	 SMLABB    r10, r4, r3, r10                   @x[30] * h[30]
-	 SMLABB    r11, r6, r3, r11                   @x[31] * h[30]
-
-	 SMLABT    r10, r6, r3, r10                   @x[31] * h[31]
-	 SMLABT    r11, r9, r3, r11                   @x[32] * h[31]
-
-	 @SSAT      r10, #32, r10, LSL #2
-	 @SSAT      r11, #32, r11, LSL #2
-	 MOV       r10, r10, LSL #1
-	 MOV       r11, r11, LSL #1
-
-	 QADD      r10, r10, r10
-	 QADD      r11, r11, r11 
-
-	 QADD      r10, r10, r5
-	 QADD      r11, r11, r5
-
-	 MOV       r10, r10, ASR #16
-	 MOV       r11, r11, ASR #16
-
-	 STRH      r10, [r0], #2
-	 STRH      r11, [r0], #2
-
-
-pred_lt4_end:
-         LDMFD     r13!, {r4 - r12, r15}
-
-Table:
-         .word       inter4_2
-	 @ENDFUNC
-	 .END
-
-
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@void Pred_lt4(
+@		  Word16 exc[],                         /* in/out: excitation buffer */
+@		  Word16 T0,                            /* input : integer pitch lag */
+@		  Word16 frac,                          /* input : fraction of lag   */
+@		  Word16 L_subfr                        /* input : subframe size     */
+@	      )
+
+@******************************
+@       ARM Register
+@******************************
+@ r0  ---  exc[]
+@ r1  ---  T0
+@ r2  ---  frac
+@ r3  ---  L_subfr
+
+         .section  .text
+	 .global   pred_lt4_asm
+	 .extern   inter4_2
+
+pred_lt4_asm:
+
+         STMFD     r13!, {r4 - r12, r14}
+         RSB       r4, r1, #0                         @-T0
+         RSB       r2, r2, #0                         @frac = -frac
+         ADD       r5, r0, r4, LSL #1                 @x = exc - T0
+         CMP       r2, #0
+         ADDLT     r2, r2, #4                         @frac += UP_SAMP
+         SUBLT     r5, r5, #2                         @x--
+         SUB       r5, r5, #30                        @x -= 15
+         RSB       r4, r2, #3                         @k = 3 - frac
+         LDR       r6, Table
+	 MOV       r8, r4, LSL #6
+         @MOV       r7, #0                             @j = 0
+         ADD       r8, r6, r8                         @ptr2 = &(inter4_2[k][0])
+
+	 MOV       r1, r5
+	 MOV       r5, #0x8000
+	 MOV       r14, #21
+@ used register
+         @r0 --- exc[]  r1 --- x  r7 --- j  r8 --- ptr2  r5 --- 0x8000
+THREE_LOOP:
+
+         @MOV       r1, r5                             @ptr1 = x
+	 MOV       r2, r8                             @ptr = ptr2
+         LDR       r3, [r2], #4                       @h[0], h[1]
+	 LDRSH     r4, [r1], #2                       @x[0]
+	 LDRSH     r6, [r1], #2                       @x[1]
+	 LDRSH     r9, [r1], #2                       @x[2]
+
+	 SMULBB    r10, r4, r3                        @x[0] * h[0]
+	 SMULBB    r11, r6, r3                        @x[1] * h[0]
+	 SMULBB    r12, r9, r3                        @x[2] * h[0]
+
+         LDRSH     r4, [r1], #2                       @x[3]
+	 SMLABT    r10, r6, r3, r10                   @x[1] * h[1]
+         SMLABT    r11, r9, r3, r11                   @x[2] * h[1]
+	 SMLABT    r12, r4, r3, r12                   @x[3] * h[1]
+
+	 LDR       r3, [r2], #4                       @h[2], h[3]
+	 LDRSH     r6, [r1], #2                       @x[4]
+	 SMLABB    r10, r9, r3, r10                   @x[2] * h[2]
+         SMLABB    r11, r4, r3, r11                   @x[3] * h[2]
+         SMLABB    r12, r6, r3, r12                   @x[4] * h[2]
+
+         LDRSH     r9, [r1], #2                       @x[5]
+         SMLABT    r10, r4, r3, r10                   @x[3] * h[3]
+         SMLABT    r11, r6, r3, r11                   @x[4] * h[3]
+         SMLABT    r12, r9, r3, r12                   @x[5] * h[3]
+
+         LDR       r3, [r2], #4                       @h[4], h[5]
+         LDRSH     r4, [r1], #2                       @x[6]
+         SMLABB    r10, r6, r3, r10                   @x[4] * h[4]
+         SMLABB    r11, r9, r3, r11                   @x[5] * h[4]
+         SMLABB    r12, r4, r3, r12                   @x[6] * h[4]
+
+	 LDRSH     r6, [r1], #2                       @x[7]
+	 SMLABT    r10, r9, r3, r10                   @x[5] * h[5]
+	 SMLABT    r11, r4, r3, r11                   @x[6] * h[5]
+	 SMLABT    r12, r6, r3, r12                   @x[7] * h[5]
+
+         LDR       r3, [r2], #4                       @h[6], h[7]
+	 LDRSH     r9, [r1], #2                       @x[8]
+	 SMLABB    r10, r4, r3, r10                   @x[6] * h[6]
+	 SMLABB    r11, r6, r3, r11                   @x[7] * h[6]
+	 SMLABB    r12, r9, r3, r12                   @x[8] * h[6]
+
+	 LDRSH     r4, [r1], #2                       @x[9]
+	 SMLABT    r10, r6, r3, r10                   @x[7] * h[7]
+	 SMLABT    r11, r9, r3, r11                   @x[8] * h[7]
+	 SMLABT    r12, r4, r3, r12                   @x[9] * h[7]
+
+	 LDR       r3, [r2], #4                       @h[8], h[9]
+	 LDRSH     r6, [r1], #2                       @x[10]
+	 SMLABB    r10, r9, r3, r10                   @x[8] * h[8]
+	 SMLABB    r11, r4, r3, r11                   @x[9] * h[8]
+	 SMLABB    r12, r6, r3, r12                   @x[10] * h[8]
+
+	 LDRSH     r9, [r1], #2                       @x[11]
+	 SMLABT    r10, r4, r3, r10                   @x[9] * h[9]
+	 SMLABT    r11, r6, r3, r11                   @x[10] * h[9]
+	 SMLABT    r12, r9, r3, r12                   @x[11] * h[9]
+
+         LDR       r3, [r2], #4                       @h[10], h[11]
+	 LDRSH     r4, [r1], #2                       @x[12]
+         SMLABB    r10, r6, r3, r10                   @x[10] * h[10]
+	 SMLABB    r11, r9, r3, r11                   @x[11] * h[10]
+	 SMLABB    r12, r4, r3, r12                   @x[12] * h[10]
+
+	 LDRSH     r6, [r1], #2                       @x[13]
+	 SMLABT    r10, r9, r3, r10                   @x[11] * h[11]
+	 SMLABT    r11, r4, r3, r11                   @x[12] * h[11]
+	 SMLABT    r12, r6, r3, r12                   @x[13] * h[11]
+
+	 LDR       r3, [r2], #4                       @h[12], h[13]
+	 LDRSH     r9, [r1], #2                       @x[14]
+	 SMLABB    r10, r4, r3, r10                   @x[12] * h[12]
+	 SMLABB    r11, r6, r3, r11                   @x[13] * h[12]
+	 SMLABB    r12, r9, r3, r12                   @x[14] * h[12]
+
+	 LDRSH     r4, [r1], #2                       @x[15]
+	 SMLABT    r10, r6, r3, r10                   @x[13] * h[13]
+	 SMLABT    r11, r9, r3, r11                   @x[14] * h[13]
+	 SMLABT    r12, r4, r3, r12                   @x[15] * h[13]
+
+	 LDR       r3, [r2], #4                       @h[14], h[15]
+	 LDRSH     r6, [r1], #2                       @x[16]
+	 SMLABB    r10, r9, r3, r10                   @x[14] * h[14]
+	 SMLABB    r11, r4, r3, r11                   @x[15] * h[14]
+	 SMLABB    r12, r6, r3, r12                   @x[16] * h[14]
+
+	 LDRSH     r9, [r1], #2                       @x[17]
+         SMLABT    r10, r4, r3, r10                   @x[15] * h[15]
+	 SMLABT    r11, r6, r3, r11                   @x[16] * h[15]
+	 SMLABT    r12, r9, r3, r12                   @x[17] * h[15]
+
+	 LDR       r3, [r2], #4                       @h[16], h[17]
+	 LDRSH     r4, [r1], #2                       @x[18]
+	 SMLABB    r10, r6, r3, r10                   @x[16] * h[16]
+	 SMLABB    r11, r9, r3, r11                   @x[17] * h[16]
+	 SMLABB    r12, r4, r3, r12                   @x[18] * h[16]
+
+         LDRSH     r6, [r1], #2                       @x[19]
+	 SMLABT    r10, r9, r3, r10                   @x[17] * h[17]
+	 SMLABT    r11, r4, r3, r11                   @x[18] * h[17]
+	 SMLABT    r12, r6, r3, r12                   @x[19] * h[17]
+
+	 LDR       r3, [r2], #4                       @h[18], h[19]
+         LDRSH     r9, [r1], #2                       @x[20]
+	 SMLABB    r10, r4, r3, r10                   @x[18] * h[18]
+	 SMLABB    r11, r6, r3, r11                   @x[19] * h[18]
+	 SMLABB    r12, r9, r3, r12                   @x[20] * h[18]
+
+	 LDRSH     r4, [r1], #2                       @x[21]
+	 SMLABT    r10, r6, r3, r10                   @x[19] * h[19]
+	 SMLABT    r11, r9, r3, r11                   @x[20] * h[19]
+	 SMLABT    r12, r4, r3, r12                   @x[21] * h[19]
+
+	 LDR       r3, [r2], #4                       @h[20], h[21]
+	 LDRSH     r6, [r1], #2                       @x[22]
+	 SMLABB    r10, r9, r3, r10                   @x[20] * h[20]
+	 SMLABB    r11, r4, r3, r11                   @x[21] * h[20]
+	 SMLABB    r12, r6, r3, r12                   @x[22] * h[20]
+
+	 LDRSH     r9, [r1], #2                       @x[23]
+	 SMLABT    r10, r4, r3, r10                   @x[21] * h[21]
+	 SMLABT    r11, r6, r3, r11                   @x[22] * h[21]
+	 SMLABT    r12, r9, r3, r12                   @x[23] * h[21]
+
+	 LDR       r3, [r2], #4                       @h[22], h[23]
+	 LDRSH     r4, [r1], #2                       @x[24]
+	 SMLABB    r10, r6, r3, r10                   @x[22] * h[22]
+	 SMLABB    r11, r9, r3, r11                   @x[23] * h[22]
+	 SMLABB    r12, r4, r3, r12                   @x[24] * h[22]
+
+         LDRSH     r6, [r1], #2                       @x[25]
+	 SMLABT    r10, r9, r3, r10                   @x[23] * h[23]
+	 SMLABT    r11, r4, r3, r11                   @x[24] * h[23]
+	 SMLABT    r12, r6, r3, r12                   @x[25] * h[23]
+
+	 LDR       r3, [r2], #4                       @h[24], h[25]
+         LDRSH     r9, [r1], #2                       @x[26]
+	 SMLABB    r10, r4, r3, r10                   @x[24] * h[24]
+	 SMLABB    r11, r6, r3, r11                   @x[25] * h[24]
+	 SMLABB    r12, r9, r3, r12                   @x[26] * h[24]
+
+	 LDRSH     r4, [r1], #2                       @x[27]
+	 SMLABT    r10, r6, r3, r10                   @x[25] * h[25]
+	 SMLABT    r11, r9, r3, r11                   @x[26] * h[25]
+	 SMLABT    r12, r4, r3, r12                   @x[27] * h[25]
+
+	 LDR       r3, [r2], #4                       @h[26], h[27]
+	 LDRSH     r6, [r1], #2                       @x[28]
+	 SMLABB    r10, r9, r3, r10                   @x[26] * h[26]
+	 SMLABB    r11, r4, r3, r11                   @x[27] * h[26]
+	 SMLABB    r12, r6, r3, r12                   @x[28] * h[26]
+
+	 LDRSH     r9, [r1], #2                       @x[29]
+	 SMLABT    r10, r4, r3, r10                   @x[27] * h[27]
+	 SMLABT    r11, r6, r3, r11                   @x[28] * h[27]
+	 SMLABT    r12, r9, r3, r12                   @x[29] * h[27]
+
+	 LDR       r3, [r2], #4                       @h[28], h[29]
+	 LDRSH     r4, [r1], #2                       @x[30]
+	 SMLABB    r10, r6, r3, r10                   @x[28] * h[28]
+	 SMLABB    r11, r9, r3, r11                   @x[29] * h[28]
+	 SMLABB    r12, r4, r3, r12                   @x[30] * h[28]
+
+         LDRSH     r6, [r1], #2                       @x[31]
+	 SMLABT    r10, r9, r3, r10                   @x[29] * h[29]
+	 SMLABT    r11, r4, r3, r11                   @x[30] * h[29]
+	 SMLABT    r12, r6, r3, r12                   @x[31] * h[29]
+
+	 LDR       r3, [r2], #4                       @h[30], h[31]
+         LDRSH     r9, [r1], #2                       @x[32]
+	 SMLABB    r10, r4, r3, r10                   @x[30] * h[30]
+	 SMLABB    r11, r6, r3, r11                   @x[31] * h[30]
+	 SMLABB    r12, r9, r3, r12                   @x[32] * h[30]
+
+	 LDRSH     r4, [r1], #-60                     @x[33]
+	 SMLABT    r10, r6, r3, r10                   @x[31] * h[31]
+	 SMLABT    r11, r9, r3, r11                   @x[32] * h[31]
+	 SMLABT    r12, r4, r3, r12                   @x[33] * h[31]
+
+	 @SSAT      r10, #32, r10, LSL #2
+	 @SSAT      r11, #32, r11, LSL #2
+	 @SSAT      r12, #32, r12, LSL #2
+
+	 MOV       r10, r10, LSL #1
+	 MOV       r11, r11, LSL #1
+	 MOV       r12, r12, LSL #1
+
+	 QADD      r10, r10, r10
+	 QADD      r11, r11, r11
+	 QADD      r12, r12, r12
+
+	 QADD      r10, r10, r5
+	 QADD      r11, r11, r5
+	 QADD      r12, r12, r5
+
+	 SUBS      r14, r14, #1
+
+	 MOV       r10, r10, ASR #16
+	 MOV       r11, r11, ASR #16
+	 MOV       r12, r12, ASR #16
+
+	 STRH      r10, [r0], #2
+	 STRH      r11, [r0], #2
+	 STRH      r12, [r0], #2
+	 BNE       THREE_LOOP
+
+	 MOV       r2, r8                             @ptr = ptr2
+
+Last2LOOP:
+
+         LDR       r3, [r2], #4                       @h[0], h[1]
+	 LDRSH     r4, [r1], #2                       @x[0]
+	 LDRSH     r6, [r1], #2                       @x[1]
+	 LDRSH     r9, [r1], #2                       @x[2]
+
+	 SMULBB    r10, r4, r3                        @x[0] * h[0]
+	 SMULBB    r11, r6, r3                        @x[1] * h[0]
+
+	 SMLABT    r10, r6, r3, r10                   @x[1] * h[1]
+	 SMLABT    r11, r9, r3, r11                   @x[2] * h[1]
+
+	 LDR       r3, [r2], #4                       @h[2], h[3]
+	 LDRSH     r4, [r1], #2                       @x[3]
+         LDRSH     r6, [r1], #2                       @x[4]
+
+	 SMLABB    r10, r9, r3, r10                   @x[2] * h[2]
+         SMLABB    r11, r4, r3, r11                   @x[3] * h[2]
+
+	 SMLABT    r10, r4, r3, r10                   @x[3] * h[3]
+	 SMLABT    r11, r6, r3, r11                   @x[4] * h[3]
+
+	 LDR       r3, [r2], #4                       @h[4], h[5]
+	 LDRSH     r9, [r1], #2                       @x[5]
+	 LDRSH     r4, [r1], #2                       @x[6]
+
+	 SMLABB    r10, r6, r3, r10                   @x[4] * h[4]
+	 SMLABB    r11, r9, r3, r11                   @x[5] * h[4]
+
+	 SMLABT    r10, r9, r3, r10                   @x[5] * h[5]
+	 SMLABT    r11, r4, r3, r11                   @x[6] * h[5]
+
+	 LDR       r3, [r2], #4                       @h[6], h[7]
+	 LDRSH     r6, [r1], #2                       @x[7]
+	 LDRSH     r9, [r1], #2                       @x[8]
+
+	 SMLABB    r10, r4, r3, r10                   @x[6] * h[6]
+	 SMLABB    r11, r6, r3, r11                   @x[7] * h[6]
+
+	 SMLABT    r10, r6, r3, r10                   @x[7] * h[7]
+	 SMLABT    r11, r9, r3, r11                   @x[8] * h[7]
+
+	 LDR       r3, [r2], #4                       @h[8], h[9]
+	 LDRSH     r4, [r1], #2                       @x[9]
+	 LDRSH     r6, [r1], #2                       @x[10]
+
+	 SMLABB    r10, r9, r3, r10                   @x[8] * h[8]
+	 SMLABB    r11, r4, r3, r11                   @x[9] * h[8]
+
+	 SMLABT    r10, r4, r3, r10                   @x[9] * h[9]
+	 SMLABT    r11, r6, r3, r11                   @x[10] * h[9]
+
+	 LDR       r3, [r2], #4                       @h[10], h[11]
+	 LDRSH     r9, [r1], #2                       @x[11]
+	 LDRSH     r4, [r1], #2                       @x[12]
+
+	 SMLABB    r10, r6, r3, r10                   @x[10] * h[10]
+	 SMLABB    r11, r9, r3, r11                   @x[11] * h[10]
+
+	 SMLABT    r10, r9, r3, r10                   @x[11] * h[11]
+	 SMLABT    r11, r4, r3, r11                   @x[12] * h[11]
+
+	 LDR       r3, [r2], #4                       @h[12], h[13]
+	 LDRSH     r6, [r1], #2                       @x[13]
+	 LDRSH     r9, [r1], #2                       @x[14]
+
+	 SMLABB    r10, r4, r3, r10                   @x[12] * h[12]
+	 SMLABB    r11, r6, r3, r11                   @x[13] * h[12]
+
+	 SMLABT    r10, r6, r3, r10                   @x[13] * h[13]
+	 SMLABT    r11, r9, r3, r11                   @x[14] * h[13]
+
+	 LDR       r3, [r2], #4                       @h[14], h[15]
+	 LDRSH     r4, [r1], #2                       @x[15]
+	 LDRSH     r6, [r1], #2                       @x[16]
+
+	 SMLABB    r10, r9, r3, r10                   @x[14] * h[14]
+	 SMLABB    r11, r4, r3, r11                   @x[15] * h[14]
+
+	 SMLABT    r10, r4, r3, r10                   @x[15] * h[15]
+	 SMLABT    r11, r6, r3, r11                   @x[16] * h[15]
+
+	 LDR       r3, [r2], #4                       @h[16], h[17]
+	 LDRSH     r9, [r1], #2                       @x[17]
+	 LDRSH     r4, [r1], #2                       @x[18]
+
+	 SMLABB    r10, r6, r3, r10                   @x[16] * h[16]
+	 SMLABB    r11, r9, r3, r11                   @x[17] * h[16]
+
+	 SMLABT    r10, r9, r3, r10                   @x[17] * h[17]
+	 SMLABT    r11, r4, r3, r11                   @x[18] * h[17]
+
+	 LDR       r3, [r2], #4                       @h[18], h[19]
+	 LDRSH     r6, [r1], #2                       @x[19]
+	 LDRSH     r9, [r1], #2                       @x[20]
+
+	 SMLABB    r10, r4, r3, r10                   @x[18] * h[18]
+	 SMLABB    r11, r6, r3, r11                   @x[19] * h[18]
+
+	 SMLABT    r10, r6, r3, r10                   @x[19] * h[19]
+	 SMLABT    r11, r9, r3, r11                   @x[20] * h[19]
+
+	 LDR       r3, [r2], #4                       @h[20], h[21]
+	 LDRSH     r4, [r1], #2                       @x[21]
+	 LDRSH     r6, [r1], #2                       @x[22]
+
+	 SMLABB    r10, r9, r3, r10                   @x[20] * h[20]
+	 SMLABB    r11, r4, r3, r11                   @x[21] * h[20]
+
+	 SMLABT    r10, r4, r3, r10                   @x[21] * h[21]
+	 SMLABT    r11, r6, r3, r11                   @x[22] * h[21]
+
+	 LDR       r3, [r2], #4                       @h[22], h[23]
+	 LDRSH     r9, [r1], #2                       @x[23]
+	 LDRSH     r4, [r1], #2                       @x[24]
+
+	 SMLABB    r10, r6, r3, r10                   @x[22] * h[22]
+	 SMLABB    r11, r9, r3, r11                   @x[23] * h[22]
+
+	 SMLABT    r10, r9, r3, r10                   @x[23] * h[23]
+	 SMLABT    r11, r4, r3, r11                   @x[24] * h[23]
+
+	 LDR       r3, [r2], #4                       @h[24], h[25]
+	 LDRSH     r6, [r1], #2                       @x[25]
+	 LDRSH     r9, [r1], #2                       @x[26]
+
+	 SMLABB    r10, r4, r3, r10                   @x[24] * h[24]
+	 SMLABB    r11, r6, r3, r11                   @x[25] * h[24]
+
+	 SMLABT    r10, r6, r3, r10                   @x[25] * h[25]
+	 SMLABT    r11, r9, r3, r11                   @x[26] * h[25]
+
+	 LDR       r3, [r2], #4                       @h[26], h[27]
+	 LDRSH     r4, [r1], #2                       @x[27]
+	 LDRSH     r6, [r1], #2                       @x[28]
+
+	 SMLABB    r10, r9, r3, r10                   @x[26] * h[26]
+	 SMLABB    r11, r4, r3, r11                   @x[27] * h[26]
+
+	 SMLABT    r10, r4, r3, r10                   @x[27] * h[27]
+	 SMLABT    r11, r6, r3, r11                   @x[28] * h[27]
+
+	 LDR       r3, [r2], #4                       @h[28], h[29]
+	 LDRSH     r9, [r1], #2                       @x[29]
+	 LDRSH     r4, [r1], #2                       @x[30]
+
+	 SMLABB    r10, r6, r3, r10                   @x[28] * h[28]
+	 SMLABB    r11, r9, r3, r11                   @x[29] * h[28]
+
+	 SMLABT    r10, r9, r3, r10                   @x[29] * h[29]
+	 SMLABT    r11, r4, r3, r11                   @x[30] * h[29]
+
+	 LDR       r3, [r2], #4                       @h[30], h[31]
+	 LDRSH     r6, [r1], #2                       @x[31]
+	 LDRSH     r9, [r1], #2                       @x[32]
+
+	 SMLABB    r10, r4, r3, r10                   @x[30] * h[30]
+	 SMLABB    r11, r6, r3, r11                   @x[31] * h[30]
+
+	 SMLABT    r10, r6, r3, r10                   @x[31] * h[31]
+	 SMLABT    r11, r9, r3, r11                   @x[32] * h[31]
+
+	 @SSAT      r10, #32, r10, LSL #2
+	 @SSAT      r11, #32, r11, LSL #2
+	 MOV       r10, r10, LSL #1
+	 MOV       r11, r11, LSL #1
+
+	 QADD      r10, r10, r10
+	 QADD      r11, r11, r11
+
+	 QADD      r10, r10, r5
+	 QADD      r11, r11, r5
+
+	 MOV       r10, r10, ASR #16
+	 MOV       r11, r11, ASR #16
+
+	 STRH      r10, [r0], #2
+	 STRH      r11, [r0], #2
+
+
+pred_lt4_end:
+         LDMFD     r13!, {r4 - r12, r15}
+
+Table:
+         .word       inter4_2
+	 @ENDFUNC
+	 .END
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/residu_asm_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/residu_asm_opt.s
index 060d9c7..5ff0964 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/residu_asm_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/residu_asm_opt.s
@@ -1,228 +1,228 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@void Residu(
-@	    Word16 a[],                           /* (i) Q12 : prediction coefficients */
-@	    Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed */
-@	    Word16 y[],                           /* (o) x2  : residual signal       */
-@	    Word16 lg                             /* (i)     : size of filtering     */
-@	   )
-@a[] --- r0
-@x[] --- r1
-@y[] --- r2
-@lg  --- r3
-
-        .section  .text
-	.global   Residu_opt
-
-Residu_opt:
-
-        STMFD   r13!, {r4 - r12, r14}
-
-        LDRH    r5, [r0], #2
-        LDRH    r6, [r0], #2
-        ORR     r5, r6, r5, LSL #16                  @r5 --- a0, a1	
-
-        LDRH    r6, [r0], #2
-	LDRH    r7, [r0], #2
-	ORR     r6, r7, r6, LSL #16                  @r6 --- a2, a3
-	
-        LDRH    r7, [r0], #2
-	LDRH    r8, [r0], #2
-	ORR     r7, r8, r7, LSL #16                  @r7 --- a4, a5
-
-	LDRH    r8, [r0], #2
-	LDRH    r9, [r0], #2
-	ORR     r8, r9, r8, LSL #16                  @r8 --- a6, a7
-
-	LDRH    r9, [r0], #2
-	LDRH    r10, [r0], #2
-	ORR     r9, r10, r9, LSL #16                 @r9 --- a8, a9
-
-	LDRH    r10, [r0], #2
-	LDRH    r11, [r0], #2
-	ORR     r10, r11, r10, LSL #16               @r10 --- a10, a11
-
-        LDRH    r11, [r0], #2
-	LDRH    r12, [r0], #2
-	ORR     r11, r12, r11, LSL #16               @r11 --- a12, a13
-	
-	LDRH    r12, [r0], #2
-	LDRH    r4, [r0], #2
-	ORR     r12, r4, r12, LSL #16                @r12 --- a14, a15
-	
-
-	STMFD   r13!, {r8 - r12}                     @store r8-r12 
-	LDRH    r4, [r0], #2                         @load a16
-        MOV     r14, r3, ASR #2                      @one loop get 4 outputs
-	ADD     r1, r1, #4
-	MOV     r0, r2
-	ORR     r14, r4, r14, LSL #16                @r14 --- loopnum, a16
-
-residu_loop:
-
-        LDR     r10, [r1], #-4                       @r10  --- x[3], x[2]
-	LDR     r2,  [r1], #-4                       @r2   --- x[1], x[0]
-
-	SMULTB  r3, r5, r2                           @i1(0)  --- r3 = x[0] * a0
-        SMULTT  r4, r5, r2                           @i2(0)  --- r4 = x[1] * a0	
-	SMULTB  r11, r5, r10                         @i3(0)  --- r11 = x[2] * a0
-	SMULTT  r12, r5, r10                         @i4(0)  --- r12 = x[3] * a0
-
-        SMLABB  r4, r5, r2, r4                       @i2(1)  --- r4 += x[0] * a1
-        SMLABT  r11, r5, r2, r11                     @i3(1)  --- r11 += x[1] * a0
-        SMLABB  r12, r5, r10, r12                    @i4(1)  --- r12 += x[2] * a1
-
-	SMLATB  r11, r6, r2, r11                     @i3(2)  --- r11 += x[0] * a2
-	SMLATT  r12, r6, r2, r12                     @i4(2)  --- r12 += x[1] * a2
-	SMLABB  r12, r6, r2, r12                     @i4(3)  --- r12 += x[0] * a3                 
-	
-	LDR     r2, [r1], #-4                        @r2 ---- x[-1], x[-2]
-
-	SMLABT  r3, r5, r2, r3                       @i1(1) --- r3 += x[-1] * a1
-	SMLATT  r4, r6, r2, r4                       @i2(2) --- r4 += x[-1] * a2
-	SMLABT  r11, r6, r2, r11                     @i3(3) --- r11 += x[-1] * a3
-	SMLATT  r12, r7, r2, r12                     @i4(4) --- r12 += x[-1] * a4
-        SMLATB  r3, r6, r2, r3                       @i1(2) --- r3 += x[-2] * a2	
-
-	SMLABB	r4, r6, r2, r4				@ i2	(3)
-	SMLATB  r11,r7, r2, r11				@ i3	(4)
-	SMLABB	r12,r7, r2, r12				@ i4	(5)
-	
-	LDR	r2,[r1],#-4
-	SMLABT	r3, r6, r2, r3				@ i1	(3)
-	SMLATT	r4, r7, r2, r4				@ i2	(4)
-	SMLABT	r11,r7, r2, r11				@ i3	(5)
-	SMLATT	r12,r8, r2, r12				@ i4	(6)
-	SMLATB	r3, r7, r2, r3				@ i1	(4)
-	SMLABB	r4, r7, r2, r4				@ i2	(5)
-	SMLATB	r11,r8, r2, r11				@ i3	(6)
-	SMLABB	r12,r8, r2, r12				@ i4	(7)
-		
-	LDR	r2,[r1],#-4
-	SMLABT	r3, r7, r2, r3				@ i1	(5)
-	SMLATT	r4, r8, r2, r4				@ i2	(6)
-	SMLABT	r11,r8, r2, r11				@ i3	(7)
-	SMLATT	r12,r9, r2, r12				@ i4	(8)
-	SMLATB	r3, r8, r2, r3				@ i1	(6)
-	SMLABB	r4, r8, r2, r4				@ i2	(7)
-	SMLATB	r11,r9, r2, r11				@ i3	(8)
-	SMLABB	r12,r9, r2, r12				@ i4	(9)
-	LDR	r10, [r13, #8]				@ [ a10 | a11]
-	
-	LDR	r2,[r1],#-4
-	SMLABT	r3, r8, r2, r3				@ i1	(7)
-	SMLATT	r4, r9, r2, r4				@ i2	(8)
-	SMLABT	r11,r9, r2, r11				@ i3	(9)
-	SMLATT	r12,r10, r2, r12			@ i4	(10)
-	SMLATB	r3, r9, r2, r3				@ i1	(8)
-	SMLABB	r4, r9, r2, r4				@ i2	(9)
-	SMLATB	r11,r10, r2, r11			@ i3	(10)
-	SMLABB	r12,r10, r2, r12			@ i4	(11)
-	LDR	r8, [r13, #12]				@ [ a12 | a13 ]
-		
-	LDR	r2,[r1],#-4
-	SMLABT	r3, r9, r2, r3				@ i1	(9)
-	SMLATT	r4, r10, r2, r4				@ i2	(10)
-	SMLABT	r11,r10, r2, r11			@ i3	(11)
-	SMLATT	r12,r8, r2, r12				@ i4	(12)
-	SMLATB	r3, r10, r2, r3				@ i1	(10)
-	SMLABB	r4, r10, r2, r4				@ i2	(11)
-	SMLATB	r11,r8, r2, r11				@ i3	(12)
-	SMLABB	r12,r8, r2, r12				@ i4	(13)
-	LDR	r9, [r13, #16]				@ [ a14 | a15 ]
-	
-	LDR	r2,[r1],#-4
-	SMLABT	r3, r10, r2, r3				@ i1	(11)
-	SMLATT	r4, r8, r2, r4				@ i2	(12)
-	SMLABT	r11,r8, r2, r11				@ i3	(13)
-	SMLATT	r12,r9, r2, r12				@ i4	(14)
-	SMLATB	r3, r8, r2, r3				@ i1	(12)
-	SMLABB	r4, r8, r2, r4				@ i2	(13)
-	SMLATB	r11,r9, r2, r11				@ i3	(14)
-	SMLABB	r12,r9, r2, r12				@ i4	(15)
-	
-
-	LDR	r2,[r1],#-4
-	SMLABT	r3, r8, r2, r3				@ i1	(13)
-	SMLATT	r4, r9, r2, r4				@ i2	(14)
-	SMLABT	r11,r9, r2, r11				@ i3	(15)
-	SMLABT	r12,r14, r2, r12			@ i4	(16)
-	SMLATB	r3, r9, r2, r3				@ i1	(14)
-	SMLABB	r4, r9, r2, r4				@ i2	(15)
-	SMLABB	r11,r14, r2, r11			@ i3	(16)
-	LDR		r8, [r13]					@ [ a6 | a7 ]
-			
-        LDR     r2,[r1],#44         		@ Change
-	SMLABT	r3, r9, r2, r3
-	SMLABB	r3, r14, r2, r3
-	SMLABT	r4, r14, r2, r4
-	LDR		r9, [r13, #4]				@ [ a8 | a9 ]
-	
-
-	QADD	r3,r3,r3					
-	QADD	r4,r4,r4					
-	QADD	r11,r11,r11					
-	QADD	r12,r12,r12					
-		
-	QADD	r3,r3,r3					
-	QADD	r4,r4,r4					
-	QADD	r11,r11,r11					
-	QADD	r12,r12,r12					
-	
-	QADD	r3,r3,r3					
-	QADD	r4,r4,r4					
-	QADD	r11,r11,r11					
-	QADD	r12,r12,r12					
-	
-	QADD	r3,r3,r3					
-	QADD	r4,r4,r4					
-	QADD	r11,r11,r11					
-	QADD	r12,r12,r12					
-	
-	MOV	r2,#32768	
-	
-	QDADD	r3,r2,r3					
-	QDADD	r4,r2,r4					
-	QDADD	r11,r2,r11					
-	QDADD	r12,r2,r12					
-		
-	
-	MOV	r3,r3,asr #16
-	MOV	r4,r4,asr #16
-	MOV	r11,r11,asr #16
-	MOV	r12,r12,asr #16
-	
-	STRH	r3,[r0],#2
-	STRH	r4,[r0],#2
-	STRH	r11,[r0],#2
-	STRH	r12,[r0],#2
-	
-	MOV	r2,r14,asr #16
-	SUB	r14, r14, #0x10000
-	SUBS	r2,r2,#1
-	BNE	residu_loop	
-end:
-	LDMFD	r13!, {r8 -r12}	
-	LDMFD	r13!, {r4 -r12,pc}
-
-        @ENDFUNC
-        .END	 
-        
-	
-	  
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@void Residu(
+@	    Word16 a[],                           /* (i) Q12 : prediction coefficients */
+@	    Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed */
+@	    Word16 y[],                           /* (o) x2  : residual signal       */
+@	    Word16 lg                             /* (i)     : size of filtering     */
+@	   )
+@a[] --- r0
+@x[] --- r1
+@y[] --- r2
+@lg  --- r3
+
+        .section  .text
+	.global   Residu_opt
+
+Residu_opt:
+
+        STMFD   r13!, {r4 - r12, r14}
+
+        LDRH    r5, [r0], #2
+        LDRH    r6, [r0], #2
+        ORR     r5, r6, r5, LSL #16                  @r5 --- a0, a1
+
+        LDRH    r6, [r0], #2
+	LDRH    r7, [r0], #2
+	ORR     r6, r7, r6, LSL #16                  @r6 --- a2, a3
+
+        LDRH    r7, [r0], #2
+	LDRH    r8, [r0], #2
+	ORR     r7, r8, r7, LSL #16                  @r7 --- a4, a5
+
+	LDRH    r8, [r0], #2
+	LDRH    r9, [r0], #2
+	ORR     r8, r9, r8, LSL #16                  @r8 --- a6, a7
+
+	LDRH    r9, [r0], #2
+	LDRH    r10, [r0], #2
+	ORR     r9, r10, r9, LSL #16                 @r9 --- a8, a9
+
+	LDRH    r10, [r0], #2
+	LDRH    r11, [r0], #2
+	ORR     r10, r11, r10, LSL #16               @r10 --- a10, a11
+
+        LDRH    r11, [r0], #2
+	LDRH    r12, [r0], #2
+	ORR     r11, r12, r11, LSL #16               @r11 --- a12, a13
+
+	LDRH    r12, [r0], #2
+	LDRH    r4, [r0], #2
+	ORR     r12, r4, r12, LSL #16                @r12 --- a14, a15
+
+
+	STMFD   r13!, {r8 - r12}                     @store r8-r12
+	LDRH    r4, [r0], #2                         @load a16
+        MOV     r14, r3, ASR #2                      @one loop get 4 outputs
+	ADD     r1, r1, #4
+	MOV     r0, r2
+	ORR     r14, r4, r14, LSL #16                @r14 --- loopnum, a16
+
+residu_loop:
+
+        LDR     r10, [r1], #-4                       @r10  --- x[3], x[2]
+	LDR     r2,  [r1], #-4                       @r2   --- x[1], x[0]
+
+	SMULTB  r3, r5, r2                           @i1(0)  --- r3 = x[0] * a0
+        SMULTT  r4, r5, r2                           @i2(0)  --- r4 = x[1] * a0
+	SMULTB  r11, r5, r10                         @i3(0)  --- r11 = x[2] * a0
+	SMULTT  r12, r5, r10                         @i4(0)  --- r12 = x[3] * a0
+
+        SMLABB  r4, r5, r2, r4                       @i2(1)  --- r4 += x[0] * a1
+        SMLABT  r11, r5, r2, r11                     @i3(1)  --- r11 += x[1] * a0
+        SMLABB  r12, r5, r10, r12                    @i4(1)  --- r12 += x[2] * a1
+
+	SMLATB  r11, r6, r2, r11                     @i3(2)  --- r11 += x[0] * a2
+	SMLATT  r12, r6, r2, r12                     @i4(2)  --- r12 += x[1] * a2
+	SMLABB  r12, r6, r2, r12                     @i4(3)  --- r12 += x[0] * a3
+
+	LDR     r2, [r1], #-4                        @r2 ---- x[-1], x[-2]
+
+	SMLABT  r3, r5, r2, r3                       @i1(1) --- r3 += x[-1] * a1
+	SMLATT  r4, r6, r2, r4                       @i2(2) --- r4 += x[-1] * a2
+	SMLABT  r11, r6, r2, r11                     @i3(3) --- r11 += x[-1] * a3
+	SMLATT  r12, r7, r2, r12                     @i4(4) --- r12 += x[-1] * a4
+        SMLATB  r3, r6, r2, r3                       @i1(2) --- r3 += x[-2] * a2
+
+	SMLABB	r4, r6, r2, r4				@ i2	(3)
+	SMLATB  r11,r7, r2, r11				@ i3	(4)
+	SMLABB	r12,r7, r2, r12				@ i4	(5)
+
+	LDR	r2,[r1],#-4
+	SMLABT	r3, r6, r2, r3				@ i1	(3)
+	SMLATT	r4, r7, r2, r4				@ i2	(4)
+	SMLABT	r11,r7, r2, r11				@ i3	(5)
+	SMLATT	r12,r8, r2, r12				@ i4	(6)
+	SMLATB	r3, r7, r2, r3				@ i1	(4)
+	SMLABB	r4, r7, r2, r4				@ i2	(5)
+	SMLATB	r11,r8, r2, r11				@ i3	(6)
+	SMLABB	r12,r8, r2, r12				@ i4	(7)
+
+	LDR	r2,[r1],#-4
+	SMLABT	r3, r7, r2, r3				@ i1	(5)
+	SMLATT	r4, r8, r2, r4				@ i2	(6)
+	SMLABT	r11,r8, r2, r11				@ i3	(7)
+	SMLATT	r12,r9, r2, r12				@ i4	(8)
+	SMLATB	r3, r8, r2, r3				@ i1	(6)
+	SMLABB	r4, r8, r2, r4				@ i2	(7)
+	SMLATB	r11,r9, r2, r11				@ i3	(8)
+	SMLABB	r12,r9, r2, r12				@ i4	(9)
+	LDR	r10, [r13, #8]				@ [ a10 | a11]
+
+	LDR	r2,[r1],#-4
+	SMLABT	r3, r8, r2, r3				@ i1	(7)
+	SMLATT	r4, r9, r2, r4				@ i2	(8)
+	SMLABT	r11,r9, r2, r11				@ i3	(9)
+	SMLATT	r12,r10, r2, r12			@ i4	(10)
+	SMLATB	r3, r9, r2, r3				@ i1	(8)
+	SMLABB	r4, r9, r2, r4				@ i2	(9)
+	SMLATB	r11,r10, r2, r11			@ i3	(10)
+	SMLABB	r12,r10, r2, r12			@ i4	(11)
+	LDR	r8, [r13, #12]				@ [ a12 | a13 ]
+
+	LDR	r2,[r1],#-4
+	SMLABT	r3, r9, r2, r3				@ i1	(9)
+	SMLATT	r4, r10, r2, r4				@ i2	(10)
+	SMLABT	r11,r10, r2, r11			@ i3	(11)
+	SMLATT	r12,r8, r2, r12				@ i4	(12)
+	SMLATB	r3, r10, r2, r3				@ i1	(10)
+	SMLABB	r4, r10, r2, r4				@ i2	(11)
+	SMLATB	r11,r8, r2, r11				@ i3	(12)
+	SMLABB	r12,r8, r2, r12				@ i4	(13)
+	LDR	r9, [r13, #16]				@ [ a14 | a15 ]
+
+	LDR	r2,[r1],#-4
+	SMLABT	r3, r10, r2, r3				@ i1	(11)
+	SMLATT	r4, r8, r2, r4				@ i2	(12)
+	SMLABT	r11,r8, r2, r11				@ i3	(13)
+	SMLATT	r12,r9, r2, r12				@ i4	(14)
+	SMLATB	r3, r8, r2, r3				@ i1	(12)
+	SMLABB	r4, r8, r2, r4				@ i2	(13)
+	SMLATB	r11,r9, r2, r11				@ i3	(14)
+	SMLABB	r12,r9, r2, r12				@ i4	(15)
+
+
+	LDR	r2,[r1],#-4
+	SMLABT	r3, r8, r2, r3				@ i1	(13)
+	SMLATT	r4, r9, r2, r4				@ i2	(14)
+	SMLABT	r11,r9, r2, r11				@ i3	(15)
+	SMLABT	r12,r14, r2, r12			@ i4	(16)
+	SMLATB	r3, r9, r2, r3				@ i1	(14)
+	SMLABB	r4, r9, r2, r4				@ i2	(15)
+	SMLABB	r11,r14, r2, r11			@ i3	(16)
+	LDR		r8, [r13]					@ [ a6 | a7 ]
+
+        LDR     r2,[r1],#44         		@ Change
+	SMLABT	r3, r9, r2, r3
+	SMLABB	r3, r14, r2, r3
+	SMLABT	r4, r14, r2, r4
+	LDR		r9, [r13, #4]				@ [ a8 | a9 ]
+
+
+	QADD	r3,r3,r3
+	QADD	r4,r4,r4
+	QADD	r11,r11,r11
+	QADD	r12,r12,r12
+
+	QADD	r3,r3,r3
+	QADD	r4,r4,r4
+	QADD	r11,r11,r11
+	QADD	r12,r12,r12
+
+	QADD	r3,r3,r3
+	QADD	r4,r4,r4
+	QADD	r11,r11,r11
+	QADD	r12,r12,r12
+
+	QADD	r3,r3,r3
+	QADD	r4,r4,r4
+	QADD	r11,r11,r11
+	QADD	r12,r12,r12
+
+	MOV	r2,#32768
+
+	QDADD	r3,r2,r3
+	QDADD	r4,r2,r4
+	QDADD	r11,r2,r11
+	QDADD	r12,r2,r12
+
+
+	MOV	r3,r3,asr #16
+	MOV	r4,r4,asr #16
+	MOV	r11,r11,asr #16
+	MOV	r12,r12,asr #16
+
+	STRH	r3,[r0],#2
+	STRH	r4,[r0],#2
+	STRH	r11,[r0],#2
+	STRH	r12,[r0],#2
+
+	MOV	r2,r14,asr #16
+	SUB	r14, r14, #0x10000
+	SUBS	r2,r2,#1
+	BNE	residu_loop
+end:
+	LDMFD	r13!, {r8 -r12}
+	LDMFD	r13!, {r4 -r12,pc}
+
+        @ENDFUNC
+        .END
+
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/scale_sig_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/scale_sig_opt.s
index aa9f464..b300224 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/scale_sig_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/scale_sig_opt.s
@@ -1,75 +1,75 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@void Scale_sig(
-@	       Word16 x[],                           /* (i/o) : signal to scale               */
-@	       Word16 lg,                            /* (i)   : size of x[]                   */
-@	       Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
-@	       )
-@
-@r0 --- x[]
-@r1 --- lg
-@r2 --- exp
-
-          .section  .text
-	  .global   Scale_sig_opt
-
-Scale_sig_opt:
-
-         STMFD         r13!, {r4 - r12, r14}
-	 SUB           r3, r1, #1                  @i = lg - 1
-         CMP           r2, #0                      @Compare exp and 0
-	 RSB           r7, r2, #0                  @exp = -exp
-	 ADD           r10, r2, #16                @16 + exp
-         ADD           r4, r0, r3, LSL #1          @x[i] address
-	 MOV           r8, #0x7fffffff
-	 MOV           r9, #0x8000
-	 BLE           LOOP2
-	 
-LOOP1:
-
-         LDRSH          r5, [r4]                    @load x[i]
-         MOV           r12, r5, LSL r10
-	 TEQ           r5, r12, ASR r10
-	 EORNE         r12, r8, r5, ASR #31
-	 SUBS          r3, r3, #1
-	 QADD          r11, r12, r9
-	 MOV           r12, r11, ASR #16
-	 STRH          r12, [r4], #-2
-	 BGE           LOOP1
-         BL            The_end
-
-LOOP2:
-
-         LDRSH          r5, [r4]                   @load x[i]
-	 MOV           r6, r5, LSL #16            @L_tmp = x[i] << 16
-	 MOV           r5, r6, ASR r7             @L_tmp >>= exp
-	 QADD          r11, r5, r9
-	 MOV           r12, r11, ASR #16
-	 SUBS          r3, r3, #1
-	 STRH          r12, [r4], #-2
-	 BGE           LOOP2
-
-The_end:
-         LDMFD         r13!, {r4 - r12, r15}
-     
-         @ENDFUNC
-         .END	 
-        
-	
-	  
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@void Scale_sig(
+@	       Word16 x[],                           /* (i/o) : signal to scale               */
+@	       Word16 lg,                            /* (i)   : size of x[]                   */
+@	       Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
+@	       )
+@
+@r0 --- x[]
+@r1 --- lg
+@r2 --- exp
+
+          .section  .text
+	  .global   Scale_sig_opt
+
+Scale_sig_opt:
+
+         STMFD         r13!, {r4 - r12, r14}
+	 SUB           r3, r1, #1                  @i = lg - 1
+         CMP           r2, #0                      @Compare exp and 0
+	 RSB           r7, r2, #0                  @exp = -exp
+	 ADD           r10, r2, #16                @16 + exp
+         ADD           r4, r0, r3, LSL #1          @x[i] address
+	 MOV           r8, #0x7fffffff
+	 MOV           r9, #0x8000
+	 BLE           LOOP2
+
+LOOP1:
+
+         LDRSH          r5, [r4]                    @load x[i]
+         MOV           r12, r5, LSL r10
+	 TEQ           r5, r12, ASR r10
+	 EORNE         r12, r8, r5, ASR #31
+	 SUBS          r3, r3, #1
+	 QADD          r11, r12, r9
+	 MOV           r12, r11, ASR #16
+	 STRH          r12, [r4], #-2
+	 BGE           LOOP1
+         BL            The_end
+
+LOOP2:
+
+         LDRSH          r5, [r4]                   @load x[i]
+	 MOV           r6, r5, LSL #16            @L_tmp = x[i] << 16
+	 MOV           r5, r6, ASR r7             @L_tmp >>= exp
+	 QADD          r11, r5, r9
+	 MOV           r12, r11, ASR #16
+	 SUBS          r3, r3, #1
+	 STRH          r12, [r4], #-2
+	 BGE           LOOP2
+
+The_end:
+         LDMFD         r13!, {r4 - r12, r15}
+
+         @ENDFUNC
+         .END
+
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/syn_filt_opt.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/syn_filt_opt.s
index e05e9e0..0c287a4 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/syn_filt_opt.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV5E/syn_filt_opt.s
@@ -1,238 +1,238 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@**********************************************************************/
-@void Syn_filt(
-@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
-@     Word16 x[],                           /* (i)     : input signal                             */
-@     Word16 y[],                           /* (o)     : output signal                            */
-@     Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
-@)
-@***********************************************************************
-@ a[]    ---   r0
-@ x[]    ---   r1
-@ y[]    ---   r2
-@ mem[]  ---   r3
-@ m ---  16  lg --- 80  update --- 1
-
-          .section  .text
-	  .global   Syn_filt_asm
-          .extern   voAWB_Copy
-
-Syn_filt_asm:
-
-          STMFD   	r13!, {r4 - r12, r14} 
-          SUB           r13, r13, #700                   @ y_buf[L_FRAME16k + M16k]
-   
-          MOV           r4, r3                           @ copy mem[] address
-          MOV           r5, r13                          @ copy yy = y_buf address
-
-          @ for(i = 0@ i < m@ i++)
-          @{
-          @    *yy++ = mem[i]@
-          @} 
-
-          LDRH          r6,  [r4], #2          
-          LDRH          r7,  [r4], #2
-          LDRH          r8,  [r4], #2
-          LDRH          r9,  [r4], #2
-          LDRH          r10, [r4], #2
-          LDRH          r11, [r4], #2
-          LDRH          r12, [r4], #2
-          LDRH          r14, [r4], #2
-
-          STRH          r6,  [r5], #2
-          STRH          r7,  [r5], #2
-          STRH          r8,  [r5], #2
-          STRH          r9,  [r5], #2
-          STRH          r10, [r5], #2
-          STRH          r11, [r5], #2
-          STRH          r12, [r5], #2
-          STRH          r14, [r5], #2
-
-          LDRH          r6,  [r4], #2          
-          LDRH          r7,  [r4], #2
-          LDRH          r8,  [r4], #2
-          LDRH          r9,  [r4], #2
-          LDRH          r10, [r4], #2
-          LDRH          r11, [r4], #2
-          LDRH          r12, [r4], #2
-          LDRH          r14, [r4], #2
-
-          STRH          r6,  [r5], #2
-          STRH          r7,  [r5], #2
-          STRH          r8,  [r5], #2
-          STRH          r9,  [r5], #2
-          STRH          r10, [r5], #2
-          STRH          r11, [r5], #2
-          STRH          r12, [r5], #2
-          STRH          r14, [r5], #2
-
-          LDRSH         r5, [r0]                         @ load a[0]
-          MOV           r8, #0                           @ i = 0
-          MOV           r5, r5, ASR #1                   @ a0 = a[0] >> 1
-          @MOV           r4, r13
-          @ load all a[]
-
-          LDR           r14, =0xffff
-          LDRSH         r6, [r0, #2]                     @ load a[1]
-          LDRSH         r7, [r0, #4]                     @ load a[2]
-          LDRSH         r9, [r0, #6]                     @ load a[3]
-          LDRSH         r11,[r0, #8]                     @ load a[4]
-          AND           r6, r6, r14
-          AND           r9, r9, r14          
-          ORR           r10, r6, r7, LSL #16             @ -a[2] -- -a[1]
-          ORR           r12, r9, r11, LSL #16            @ -a[4] -- -a[3]
-          STR           r10, [r13, #-4]
-          STR           r12, [r13, #-8]
-          
-          LDRSH         r6, [r0, #10]                    @ load a[5]
-          LDRSH         r7, [r0, #12]                    @ load a[6]
-          LDRSH         r9, [r0, #14]                    @ load a[7]
-          LDRSH         r11,[r0, #16]                    @ load a[8]
-          AND           r6, r6, r14
-          AND           r9, r9, r14          
-          ORR           r10, r6, r7, LSL #16             @ -a[6] -- -a[5]
-          ORR           r12, r9, r11, LSL #16            @ -a[8] -- -a[7]
-          STR           r10, [r13, #-12]
-          STR           r12, [r13, #-16]          
-           
-          LDRSH         r6, [r0, #18]                    @ load a[9]
-          LDRSH         r7, [r0, #20]                    @ load a[10]
-          LDRSH         r9, [r0, #22]                    @ load a[11]
-          LDRSH         r11,[r0, #24]                    @ load a[12]
-          AND           r6, r6, r14
-          AND           r9, r9, r14          
-          ORR           r10, r6, r7, LSL #16             @ -a[10] -- -a[9]
-          ORR           r12, r9, r11, LSL #16            @ -a[12] -- -a[11]
-          STR           r10, [r13, #-20]
-          STR           r12, [r13, #-24]    
-
-          LDRSH         r6, [r0, #26]                    @ load a[13]
-          LDRSH         r7, [r0, #28]                    @ load a[14]
-          LDRSH         r9, [r0, #30]                    @ load a[15]
-          LDRSH         r11,[r0, #32]                    @ load a[16]
-          AND           r6, r6, r14
-          AND           r9, r9, r14          
-          ORR           r10, r6, r7, LSL #16             @ -a[14] -- -a[13]
-          ORR           r12, r9, r11, LSL #16            @ -a[16] -- -a[15]
-          STR           r10, [r13, #-28]
-          STR           r12, [r13, #-32]                
-                     
-          ADD           r4, r13, #32
-LOOP:
-          LDRSH         r6,  [r1], #2                    @ load x[i]
-          ADD           r10, r4, r8, LSL #1              @ temp_p = yy + i
-
-          MUL           r0, r5, r6                      @ L_tmp = x[i] * a0
-          @ for(j = 1@ j <= m, j+=8)
-          LDR           r7,  [r13, #-4]                  @ -a[2]  -a[1]
-          LDRSH         r9,  [r10, #-2]                  @ *(temp_p - 1)
-          LDRSH         r12, [r10, #-4]                  @ *(temp_p - 2)
-
-
-          SMULBB        r14, r9, r7                      @ -a[1] * (*(temp_p -1))
-
-          LDRSH         r6,  [r10, #-6]                  @ *(temp_p - 3)
-
-          SMLABT        r14, r12, r7, r14                @ -a[2] * (*(temp_p - 2))
-
-          LDR           r7,  [r13, #-8]                  @ -a[4] -a[3]
-          LDRSH         r11, [r10, #-8]                  @ *(temp_p - 4)
-
-          SMLABB        r14, r6, r7, r14                 @ -a[3] * (*(temp_p -3))
-
-          LDRSH         r9,  [r10, #-10]                 @ *(temp_p - 5)
-   
-          SMLABT        r14, r11, r7, r14                @ -a[4] * (*(temp_p -4))        
-
-          LDR           r7,  [r13, #-12]                 @ -a[6]  -a[5]
-          LDRSH         r12, [r10, #-12]                 @ *(temp_p - 6)
-
-          SMLABB        r14, r9, r7, r14                 @ -a[5] * (*(temp_p -5))
-
-          LDRSH         r6,  [r10, #-14]                 @ *(temp_p - 7)
-
-          SMLABT        r14, r12, r7, r14                @ -a[6] * (*(temp_p - 6))
-
-          LDR           r7,  [r13, #-16]                 @ -a[8] -a[7]
-          LDRSH         r11, [r10, #-16]                 @ *(temp_p - 8)
-         
-          SMLABB        r14, r6, r7, r14                 @ -a[7] * (*(temp_p -7))
-
-          LDRSH         r9,  [r10, #-18]                 @ *(temp_p - 9)
-
-          SMLABT        r14, r11, r7, r14                @ -a[8] * (*(temp_p -8))          
- 
-          LDR           r7,  [r13, #-20]                 @ -a[10]  -a[9]
-          LDRSH         r12, [r10, #-20]                 @ *(temp_p - 10)
-
-          SMLABB        r14, r9, r7, r14                 @ -a[9] * (*(temp_p -9))
-
-          LDRSH         r6,  [r10, #-22]                 @ *(temp_p - 11)
-
-          SMLABT        r14, r12, r7, r14                @ -a[10] * (*(temp_p - 10))
-
-          LDR           r7,  [r13, #-24]                 @ -a[12] -a[11]
-          LDRSH         r11, [r10, #-24]                 @ *(temp_p - 12)
-
-          SMLABB        r14, r6, r7, r14                 @ -a[11] * (*(temp_p -11))
-
-          LDRSH         r9,  [r10, #-26]                 @ *(temp_p - 13)
-
-          SMLABT        r14, r11, r7, r14                @ -a[12] * (*(temp_p -12))           
-
-          LDR           r7,  [r13, #-28]                 @ -a[14] -a[13]
-          LDRSH         r12, [r10, #-28]                 @ *(temp_p - 14)
- 
-          SMLABB        r14, r9, r7, r14                 @ -a[13] * (*(temp_p -13))
-
-          LDRSH         r6,  [r10, #-30]                 @ *(temp_p - 15)
-
-          SMLABT        r14, r12, r7, r14                @ -a[14] * (*(temp_p - 14))
-
-          LDR           r7,  [r13, #-32]                 @ -a[16] -a[15]
-          LDRSH         r11, [r10, #-32]                 @ *(temp_p - 16)
-
-          SMLABB        r14, r6, r7, r14                 @ -a[15] * (*(temp_p -15))
-
-          SMLABT        r14, r11, r7, r14                @ -a[16] * (*(temp_p -16))
-
-          RSB           r14, r14, r0
-                                  
-          MOV           r7, r14, LSL #4                  @ L_tmp <<=4
-          ADD           r8, r8, #1
-          ADD           r14, r7, #0x8000                 
-          MOV           r7, r14, ASR #16                 @ (L_tmp + 0x8000) >> 16
-          CMP           r8, #80
-          STRH          r7, [r10]                        @ yy[i]
-          STRH          r7, [r2], #2                     @ y[i]
-          BLT           LOOP
- 
-          @ update mem[]
-          ADD           r5, r13, #160                    @ yy[64] address
-          MOV           r1, r3
-          MOV           r0, r5
-          MOV           r2, #16
-          BL            voAWB_Copy          
-
-Syn_filt_asm_end:
- 
-          ADD           r13, r13, #700		     
-          LDMFD   	r13!, {r4 - r12, r15} 
-          @ENDFUNC
-          .END
- 
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@**********************************************************************/
+@void Syn_filt(
+@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
+@     Word16 x[],                           /* (i)     : input signal                             */
+@     Word16 y[],                           /* (o)     : output signal                            */
+@     Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
+@)
+@***********************************************************************
+@ a[]    ---   r0
+@ x[]    ---   r1
+@ y[]    ---   r2
+@ mem[]  ---   r3
+@ m ---  16  lg --- 80  update --- 1
+
+          .section  .text
+	  .global   Syn_filt_asm
+          .extern   voAWB_Copy
+
+Syn_filt_asm:
+
+          STMFD   	r13!, {r4 - r12, r14}
+          SUB           r13, r13, #700                   @ y_buf[L_FRAME16k + M16k]
+
+          MOV           r4, r3                           @ copy mem[] address
+          MOV           r5, r13                          @ copy yy = y_buf address
+
+          @ for(i = 0@ i < m@ i++)
+          @{
+          @    *yy++ = mem[i]@
+          @}
+
+          LDRH          r6,  [r4], #2
+          LDRH          r7,  [r4], #2
+          LDRH          r8,  [r4], #2
+          LDRH          r9,  [r4], #2
+          LDRH          r10, [r4], #2
+          LDRH          r11, [r4], #2
+          LDRH          r12, [r4], #2
+          LDRH          r14, [r4], #2
+
+          STRH          r6,  [r5], #2
+          STRH          r7,  [r5], #2
+          STRH          r8,  [r5], #2
+          STRH          r9,  [r5], #2
+          STRH          r10, [r5], #2
+          STRH          r11, [r5], #2
+          STRH          r12, [r5], #2
+          STRH          r14, [r5], #2
+
+          LDRH          r6,  [r4], #2
+          LDRH          r7,  [r4], #2
+          LDRH          r8,  [r4], #2
+          LDRH          r9,  [r4], #2
+          LDRH          r10, [r4], #2
+          LDRH          r11, [r4], #2
+          LDRH          r12, [r4], #2
+          LDRH          r14, [r4], #2
+
+          STRH          r6,  [r5], #2
+          STRH          r7,  [r5], #2
+          STRH          r8,  [r5], #2
+          STRH          r9,  [r5], #2
+          STRH          r10, [r5], #2
+          STRH          r11, [r5], #2
+          STRH          r12, [r5], #2
+          STRH          r14, [r5], #2
+
+          LDRSH         r5, [r0]                         @ load a[0]
+          MOV           r8, #0                           @ i = 0
+          MOV           r5, r5, ASR #1                   @ a0 = a[0] >> 1
+          @MOV           r4, r13
+          @ load all a[]
+
+          LDR           r14, =0xffff
+          LDRSH         r6, [r0, #2]                     @ load a[1]
+          LDRSH         r7, [r0, #4]                     @ load a[2]
+          LDRSH         r9, [r0, #6]                     @ load a[3]
+          LDRSH         r11,[r0, #8]                     @ load a[4]
+          AND           r6, r6, r14
+          AND           r9, r9, r14
+          ORR           r10, r6, r7, LSL #16             @ -a[2] -- -a[1]
+          ORR           r12, r9, r11, LSL #16            @ -a[4] -- -a[3]
+          STR           r10, [r13, #-4]
+          STR           r12, [r13, #-8]
+
+          LDRSH         r6, [r0, #10]                    @ load a[5]
+          LDRSH         r7, [r0, #12]                    @ load a[6]
+          LDRSH         r9, [r0, #14]                    @ load a[7]
+          LDRSH         r11,[r0, #16]                    @ load a[8]
+          AND           r6, r6, r14
+          AND           r9, r9, r14
+          ORR           r10, r6, r7, LSL #16             @ -a[6] -- -a[5]
+          ORR           r12, r9, r11, LSL #16            @ -a[8] -- -a[7]
+          STR           r10, [r13, #-12]
+          STR           r12, [r13, #-16]
+
+          LDRSH         r6, [r0, #18]                    @ load a[9]
+          LDRSH         r7, [r0, #20]                    @ load a[10]
+          LDRSH         r9, [r0, #22]                    @ load a[11]
+          LDRSH         r11,[r0, #24]                    @ load a[12]
+          AND           r6, r6, r14
+          AND           r9, r9, r14
+          ORR           r10, r6, r7, LSL #16             @ -a[10] -- -a[9]
+          ORR           r12, r9, r11, LSL #16            @ -a[12] -- -a[11]
+          STR           r10, [r13, #-20]
+          STR           r12, [r13, #-24]
+
+          LDRSH         r6, [r0, #26]                    @ load a[13]
+          LDRSH         r7, [r0, #28]                    @ load a[14]
+          LDRSH         r9, [r0, #30]                    @ load a[15]
+          LDRSH         r11,[r0, #32]                    @ load a[16]
+          AND           r6, r6, r14
+          AND           r9, r9, r14
+          ORR           r10, r6, r7, LSL #16             @ -a[14] -- -a[13]
+          ORR           r12, r9, r11, LSL #16            @ -a[16] -- -a[15]
+          STR           r10, [r13, #-28]
+          STR           r12, [r13, #-32]
+
+          ADD           r4, r13, #32
+LOOP:
+          LDRSH         r6,  [r1], #2                    @ load x[i]
+          ADD           r10, r4, r8, LSL #1              @ temp_p = yy + i
+
+          MUL           r0, r5, r6                      @ L_tmp = x[i] * a0
+          @ for(j = 1@ j <= m, j+=8)
+          LDR           r7,  [r13, #-4]                  @ -a[2]  -a[1]
+          LDRSH         r9,  [r10, #-2]                  @ *(temp_p - 1)
+          LDRSH         r12, [r10, #-4]                  @ *(temp_p - 2)
+
+
+          SMULBB        r14, r9, r7                      @ -a[1] * (*(temp_p -1))
+
+          LDRSH         r6,  [r10, #-6]                  @ *(temp_p - 3)
+
+          SMLABT        r14, r12, r7, r14                @ -a[2] * (*(temp_p - 2))
+
+          LDR           r7,  [r13, #-8]                  @ -a[4] -a[3]
+          LDRSH         r11, [r10, #-8]                  @ *(temp_p - 4)
+
+          SMLABB        r14, r6, r7, r14                 @ -a[3] * (*(temp_p -3))
+
+          LDRSH         r9,  [r10, #-10]                 @ *(temp_p - 5)
+
+          SMLABT        r14, r11, r7, r14                @ -a[4] * (*(temp_p -4))
+
+          LDR           r7,  [r13, #-12]                 @ -a[6]  -a[5]
+          LDRSH         r12, [r10, #-12]                 @ *(temp_p - 6)
+
+          SMLABB        r14, r9, r7, r14                 @ -a[5] * (*(temp_p -5))
+
+          LDRSH         r6,  [r10, #-14]                 @ *(temp_p - 7)
+
+          SMLABT        r14, r12, r7, r14                @ -a[6] * (*(temp_p - 6))
+
+          LDR           r7,  [r13, #-16]                 @ -a[8] -a[7]
+          LDRSH         r11, [r10, #-16]                 @ *(temp_p - 8)
+
+          SMLABB        r14, r6, r7, r14                 @ -a[7] * (*(temp_p -7))
+
+          LDRSH         r9,  [r10, #-18]                 @ *(temp_p - 9)
+
+          SMLABT        r14, r11, r7, r14                @ -a[8] * (*(temp_p -8))
+
+          LDR           r7,  [r13, #-20]                 @ -a[10]  -a[9]
+          LDRSH         r12, [r10, #-20]                 @ *(temp_p - 10)
+
+          SMLABB        r14, r9, r7, r14                 @ -a[9] * (*(temp_p -9))
+
+          LDRSH         r6,  [r10, #-22]                 @ *(temp_p - 11)
+
+          SMLABT        r14, r12, r7, r14                @ -a[10] * (*(temp_p - 10))
+
+          LDR           r7,  [r13, #-24]                 @ -a[12] -a[11]
+          LDRSH         r11, [r10, #-24]                 @ *(temp_p - 12)
+
+          SMLABB        r14, r6, r7, r14                 @ -a[11] * (*(temp_p -11))
+
+          LDRSH         r9,  [r10, #-26]                 @ *(temp_p - 13)
+
+          SMLABT        r14, r11, r7, r14                @ -a[12] * (*(temp_p -12))
+
+          LDR           r7,  [r13, #-28]                 @ -a[14] -a[13]
+          LDRSH         r12, [r10, #-28]                 @ *(temp_p - 14)
+
+          SMLABB        r14, r9, r7, r14                 @ -a[13] * (*(temp_p -13))
+
+          LDRSH         r6,  [r10, #-30]                 @ *(temp_p - 15)
+
+          SMLABT        r14, r12, r7, r14                @ -a[14] * (*(temp_p - 14))
+
+          LDR           r7,  [r13, #-32]                 @ -a[16] -a[15]
+          LDRSH         r11, [r10, #-32]                 @ *(temp_p - 16)
+
+          SMLABB        r14, r6, r7, r14                 @ -a[15] * (*(temp_p -15))
+
+          SMLABT        r14, r11, r7, r14                @ -a[16] * (*(temp_p -16))
+
+          RSB           r14, r14, r0
+
+          MOV           r7, r14, LSL #4                  @ L_tmp <<=4
+          ADD           r8, r8, #1
+          ADD           r14, r7, #0x8000
+          MOV           r7, r14, ASR #16                 @ (L_tmp + 0x8000) >> 16
+          CMP           r8, #80
+          STRH          r7, [r10]                        @ yy[i]
+          STRH          r7, [r2], #2                     @ y[i]
+          BLT           LOOP
+
+          @ update mem[]
+          ADD           r5, r13, #160                    @ yy[64] address
+          MOV           r1, r3
+          MOV           r0, r5
+          MOV           r2, #16
+          BL            voAWB_Copy
+
+Syn_filt_asm_end:
+
+          ADD           r13, r13, #700
+          LDMFD   	r13!, {r4 - r12, r15}
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Deemph_32_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Deemph_32_neon.s
index acb60c3..1d5893f 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Deemph_32_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Deemph_32_neon.s
@@ -1,102 +1,102 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@void Deemph_32(
-@     Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
-@     Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
-@     Word16 y[],                           /* (o)     : output signal (x16)      */
-@     Word16 mu,                            /* (i) Q15 : deemphasis factor        */
-@     Word16 L,                             /* (i)     : vector size              */
-@     Word16 * mem                          /* (i/o)   : memory (y[-1])           */
-@     )
-
-@x_hi     RN      R0
-@x_lo     RN      R1
-@y[]      RN      R2
-@*mem     RN      R3
-
-           .section  .text
-           .global   Deemph_32_asm
-	   
-Deemph_32_asm:
-
-           STMFD   	r13!, {r4 - r12, r14} 
-	   MOV          r4, #2                   @i=0
-	   LDRSH        r6, [r0], #2             @load x_hi[0]
-	   LDRSH        r7, [r1], #2             @load x_lo[0]
-	   LDR          r5, =22282               @r5---mu
-	   MOV          r11, #0x8000
-
-           @y[0]
-	   MOV          r10, r6, LSL #16         @L_tmp = x_hi[0]<<16
-	   MOV          r8,  r5, ASR #1          @fac = mu >> 1
-	   LDR          r5,  [r3]
-	   ADD          r12, r10, r7, LSL #4     @L_tmp += x_lo[0] << 4
-	   MOV          r10, r12, LSL #3         @L_tmp <<= 3
-	   MUL          r9, r5, r8
-	   LDRSH        r6, [r0], #2             @load x_hi[1] 
-	   QDADD        r10, r10, r9
-	   LDRSH        r7, [r1], #2             @load x_lo[1]  
-	   MOV          r12, r10, LSL #1         @L_tmp = L_mac(L_tmp, *mem, fac)
-	   QADD         r10, r12, r11
-	   MOV          r14, r10, ASR #16        @y[0] = round(L_tmp)
-
-
-	   MOV          r10, r6, LSL #16
-	   ADD          r12, r10, r7, LSL #4
-           STRH         r14, [r2], #2            @update y[0]
-	   MOV          r10, r12, LSL #3
-	   MUL          r9, r14, r8
-	   QDADD        r10, r10, r9
-	   MOV          r12, r10, LSL #1
-	   QADD         r10, r12, r11
-	   MOV          r14, r10, ASR #16        @y[1] = round(L_tmp)
-
-LOOP:
-           LDRSH        r6, [r0], #2             @load x_hi[]
-	   LDRSH        r7, [r1], #2
-	   STRH         r14, [r2], #2
-	   MOV          r10, r6, LSL #16
-	   ADD          r12, r10, r7, LSL #4
-	   MUL          r9, r14, r8
-	   MOV          r10, r12, LSL #3
-	   QDADD        r10, r10, r9
-           LDRSH        r6, [r0], #2             @load x_hi[]
-	   MOV          r12, r10, LSL #1
-	   QADD         r10, r12, r11
-	   LDRSH        r7, [r1], #2
-	   MOV          r14, r10, ASR #16
-
-	   MOV          r10, r6, LSL #16
-	   ADD          r12, r10, r7, LSL #4
-	   STRH         r14, [r2], #2
-	   MUL          r9, r14, r8
-	   MOV          r10, r12, LSL #3
-	   QDADD        r10, r10, r9
-           ADD          r4, r4, #2
-	   MOV          r12, r10, LSL #1
-	   QADD         r10, r12, r11
-           CMP          r4, #64
-	   MOV          r14, r10, ASR #16
-
-           BLT          LOOP
-           STR          r14, [r3]
-           STRH         r14, [r2]	   
-
-           LDMFD   	r13!, {r4 - r12, r15} 
-
-	   .END
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@void Deemph_32(
+@     Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
+@     Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
+@     Word16 y[],                           /* (o)     : output signal (x16)      */
+@     Word16 mu,                            /* (i) Q15 : deemphasis factor        */
+@     Word16 L,                             /* (i)     : vector size              */
+@     Word16 * mem                          /* (i/o)   : memory (y[-1])           */
+@     )
+
+@x_hi     RN      R0
+@x_lo     RN      R1
+@y[]      RN      R2
+@*mem     RN      R3
+
+           .section  .text
+           .global   Deemph_32_asm
+
+Deemph_32_asm:
+
+           STMFD   	r13!, {r4 - r12, r14}
+	   MOV          r4, #2                   @i=0
+	   LDRSH        r6, [r0], #2             @load x_hi[0]
+	   LDRSH        r7, [r1], #2             @load x_lo[0]
+	   LDR          r5, =22282               @r5---mu
+	   MOV          r11, #0x8000
+
+           @y[0]
+	   MOV          r10, r6, LSL #16         @L_tmp = x_hi[0]<<16
+	   MOV          r8,  r5, ASR #1          @fac = mu >> 1
+	   LDR          r5,  [r3]
+	   ADD          r12, r10, r7, LSL #4     @L_tmp += x_lo[0] << 4
+	   MOV          r10, r12, LSL #3         @L_tmp <<= 3
+	   MUL          r9, r5, r8
+	   LDRSH        r6, [r0], #2             @load x_hi[1]
+	   QDADD        r10, r10, r9
+	   LDRSH        r7, [r1], #2             @load x_lo[1]
+	   MOV          r12, r10, LSL #1         @L_tmp = L_mac(L_tmp, *mem, fac)
+	   QADD         r10, r12, r11
+	   MOV          r14, r10, ASR #16        @y[0] = round(L_tmp)
+
+
+	   MOV          r10, r6, LSL #16
+	   ADD          r12, r10, r7, LSL #4
+           STRH         r14, [r2], #2            @update y[0]
+	   MOV          r10, r12, LSL #3
+	   MUL          r9, r14, r8
+	   QDADD        r10, r10, r9
+	   MOV          r12, r10, LSL #1
+	   QADD         r10, r12, r11
+	   MOV          r14, r10, ASR #16        @y[1] = round(L_tmp)
+
+LOOP:
+           LDRSH        r6, [r0], #2             @load x_hi[]
+	   LDRSH        r7, [r1], #2
+	   STRH         r14, [r2], #2
+	   MOV          r10, r6, LSL #16
+	   ADD          r12, r10, r7, LSL #4
+	   MUL          r9, r14, r8
+	   MOV          r10, r12, LSL #3
+	   QDADD        r10, r10, r9
+           LDRSH        r6, [r0], #2             @load x_hi[]
+	   MOV          r12, r10, LSL #1
+	   QADD         r10, r12, r11
+	   LDRSH        r7, [r1], #2
+	   MOV          r14, r10, ASR #16
+
+	   MOV          r10, r6, LSL #16
+	   ADD          r12, r10, r7, LSL #4
+	   STRH         r14, [r2], #2
+	   MUL          r9, r14, r8
+	   MOV          r10, r12, LSL #3
+	   QDADD        r10, r10, r9
+           ADD          r4, r4, #2
+	   MOV          r12, r10, LSL #1
+	   QADD         r10, r12, r11
+           CMP          r4, #64
+	   MOV          r14, r10, ASR #16
+
+           BLT          LOOP
+           STR          r14, [r3]
+           STRH         r14, [r2]
+
+           LDMFD   	r13!, {r4 - r12, r15}
+
+	   .END
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Dot_p_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Dot_p_neon.s
index 07ca344..8230944 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Dot_p_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Dot_p_neon.s
@@ -1,127 +1,127 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@**********************************************************************/
-@Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
-@       Word16 x[],                           /* (i) 12bits: x vector                       */
-@       Word16 y[],                           /* (i) 12bits: y vector                       */
-@       Word16 lg,                            /* (i)    : vector length                     */
-@       Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
-@)
-@************************************************************************
-@  x[]   ---  r0
-@  y[]   ---  r1
-@  lg    ---  r2
-@  *exp  ---  r3
-
-          .section   .text
-          .global    Dot_product12_asm
-
-Dot_product12_asm:
-
-          STMFD   	    r13!, {r4 - r12, r14}
-	  CMP               r0, r1
-	  BEQ               LOOP_EQ
-
-          VLD1.S16          {Q0, Q1}, [r0]!               @load 16 Word16 x[]
-          VLD1.S16          {Q2, Q3}, [r0]!               @load 16 Word16 x[]
-          VLD1.S16          {Q4, Q5}, [r0]!               @load 16 Word16 x[]
-          VLD1.S16          {Q6, Q7}, [r0]!               @load 16 Word16 x[]
-	  VLD1.S16          {Q8, Q9}, [r1]!               @load 16 Word16 y[]
-	  VLD1.S16          {Q10, Q11}, [r1]!             @load 16 Word16 y[]
-	  VLD1.S16          {Q12, Q13}, [r1]!             @load 16 Word16 y[]
-
-          VMULL.S16         Q15, D16, D0
-          VMLAL.S16         Q15, D17, D1               
-          VMLAL.S16         Q15, D18, D2
-          VMLAL.S16         Q15, D19, D3
-	  VLD1.S16          {Q0, Q1}, [r1]!               @load 16 Word16 y[]   
-          VMLAL.S16         Q15, D20, D4       
-          VMLAL.S16         Q15, D21, D5
-          VMLAL.S16         Q15, D22, D6
-          VMLAL.S16         Q15, D23, D7                                       
-          VMLAL.S16         Q15, D24, D8
-          VMLAL.S16         Q15, D25, D9
-          VMLAL.S16         Q15, D26, D10
-          VMLAL.S16         Q15, D27, D11
-          VMLAL.S16         Q15, D0, D12
-          VMLAL.S16         Q15, D1, D13
-          VMLAL.S16         Q15, D2, D14
-          VMLAL.S16         Q15, D3, D15
-
-          CMP               r2, #64
-          BEQ               Lable1
-          VLD1.S16          {Q0, Q1}, [r0]!               @load 16 Word16 x[]  
-	  VLD1.S16          {Q2, Q3}, [r1]! 
-          VMLAL.S16         Q15, D4, D0             
-          VMLAL.S16         Q15, D5, D1
-          VMLAL.S16         Q15, D6, D2
-          VMLAL.S16         Q15, D7, D3
-	  BL                Lable1
-
-LOOP_EQ:
-          VLD1.S16          {Q0, Q1}, [r0]!
-	  VLD1.S16          {Q2, Q3}, [r0]!
-	  VLD1.S16          {Q4, Q5}, [r0]!
-	  VLD1.S16          {Q6, Q7}, [r0]!
-	  VMULL.S16         Q15, D0, D0
-	  VMLAL.S16         Q15, D1, D1
-	  VMLAL.S16         Q15, D2, D2
-	  VMLAL.S16         Q15, D3, D3
-	  VMLAL.S16         Q15, D4, D4
-	  VMLAL.S16         Q15, D5, D5
-	  VMLAL.S16         Q15, D6, D6
-	  VMLAL.S16         Q15, D7, D7
-	  VMLAL.S16         Q15, D8, D8
-	  VMLAL.S16         Q15, D9, D9
-	  VMLAL.S16         Q15, D10, D10
-	  VMLAL.S16         Q15, D11, D11
-	  VMLAL.S16         Q15, D12, D12
-	  VMLAL.S16         Q15, D13, D13
-	  VMLAL.S16         Q15, D14, D14
-	  VMLAL.S16         Q15, D15, D15
-
-	  CMP               r2, #64
-	  BEQ               Lable1
-	  VLD1.S16          {Q0, Q1}, [r0]!
-	  VMLAL.S16         Q15, D0, D0
-	  VMLAL.S16         Q15, D1, D1
-	  VMLAL.S16         Q15, D2, D2
-	  VMLAL.S16         Q15, D3, D3
-
-Lable1: 
-
-          VQADD.S32         D30, D30, D31
-          VPADD.S32         D30, D30, D30
-          VMOV.S32          r12, D30[0]        
-
-	  ADD               r12, r12, r12
-          ADD               r12, r12, #1                         @ L_sum = (L_sum << 1)  + 1
-	  MOV               r4, r12
-	  CMP               r12, #0
-	  RSBLT             r4, r12, #0
-          CLZ               r10, r4
-          SUB               r10, r10, #1                         @ sft = norm_l(L_sum)
-          MOV               r0, r12, LSL r10                     @ L_sum = L_sum << sft
-          RSB               r11, r10, #30                        @ *exp = 30 - sft
-          STRH              r11, [r3]                     
-
-Dot_product12_end:
-		     
-          LDMFD   	    r13!, {r4 - r12, r15} 
-
-          .END
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@**********************************************************************/
+@Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
+@       Word16 x[],                           /* (i) 12bits: x vector                       */
+@       Word16 y[],                           /* (i) 12bits: y vector                       */
+@       Word16 lg,                            /* (i)    : vector length                     */
+@       Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
+@)
+@************************************************************************
+@  x[]   ---  r0
+@  y[]   ---  r1
+@  lg    ---  r2
+@  *exp  ---  r3
+
+          .section   .text
+          .global    Dot_product12_asm
+
+Dot_product12_asm:
+
+          STMFD   	    r13!, {r4 - r12, r14}
+	  CMP               r0, r1
+	  BEQ               LOOP_EQ
+
+          VLD1.S16          {Q0, Q1}, [r0]!               @load 16 Word16 x[]
+          VLD1.S16          {Q2, Q3}, [r0]!               @load 16 Word16 x[]
+          VLD1.S16          {Q4, Q5}, [r0]!               @load 16 Word16 x[]
+          VLD1.S16          {Q6, Q7}, [r0]!               @load 16 Word16 x[]
+	  VLD1.S16          {Q8, Q9}, [r1]!               @load 16 Word16 y[]
+	  VLD1.S16          {Q10, Q11}, [r1]!             @load 16 Word16 y[]
+	  VLD1.S16          {Q12, Q13}, [r1]!             @load 16 Word16 y[]
+
+          VMULL.S16         Q15, D16, D0
+          VMLAL.S16         Q15, D17, D1
+          VMLAL.S16         Q15, D18, D2
+          VMLAL.S16         Q15, D19, D3
+	  VLD1.S16          {Q0, Q1}, [r1]!               @load 16 Word16 y[]
+          VMLAL.S16         Q15, D20, D4
+          VMLAL.S16         Q15, D21, D5
+          VMLAL.S16         Q15, D22, D6
+          VMLAL.S16         Q15, D23, D7
+          VMLAL.S16         Q15, D24, D8
+          VMLAL.S16         Q15, D25, D9
+          VMLAL.S16         Q15, D26, D10
+          VMLAL.S16         Q15, D27, D11
+          VMLAL.S16         Q15, D0, D12
+          VMLAL.S16         Q15, D1, D13
+          VMLAL.S16         Q15, D2, D14
+          VMLAL.S16         Q15, D3, D15
+
+          CMP               r2, #64
+          BEQ               Lable1
+          VLD1.S16          {Q0, Q1}, [r0]!               @load 16 Word16 x[]
+	  VLD1.S16          {Q2, Q3}, [r1]!
+          VMLAL.S16         Q15, D4, D0
+          VMLAL.S16         Q15, D5, D1
+          VMLAL.S16         Q15, D6, D2
+          VMLAL.S16         Q15, D7, D3
+	  BL                Lable1
+
+LOOP_EQ:
+          VLD1.S16          {Q0, Q1}, [r0]!
+	  VLD1.S16          {Q2, Q3}, [r0]!
+	  VLD1.S16          {Q4, Q5}, [r0]!
+	  VLD1.S16          {Q6, Q7}, [r0]!
+	  VMULL.S16         Q15, D0, D0
+	  VMLAL.S16         Q15, D1, D1
+	  VMLAL.S16         Q15, D2, D2
+	  VMLAL.S16         Q15, D3, D3
+	  VMLAL.S16         Q15, D4, D4
+	  VMLAL.S16         Q15, D5, D5
+	  VMLAL.S16         Q15, D6, D6
+	  VMLAL.S16         Q15, D7, D7
+	  VMLAL.S16         Q15, D8, D8
+	  VMLAL.S16         Q15, D9, D9
+	  VMLAL.S16         Q15, D10, D10
+	  VMLAL.S16         Q15, D11, D11
+	  VMLAL.S16         Q15, D12, D12
+	  VMLAL.S16         Q15, D13, D13
+	  VMLAL.S16         Q15, D14, D14
+	  VMLAL.S16         Q15, D15, D15
+
+	  CMP               r2, #64
+	  BEQ               Lable1
+	  VLD1.S16          {Q0, Q1}, [r0]!
+	  VMLAL.S16         Q15, D0, D0
+	  VMLAL.S16         Q15, D1, D1
+	  VMLAL.S16         Q15, D2, D2
+	  VMLAL.S16         Q15, D3, D3
+
+Lable1:
+
+          VQADD.S32         D30, D30, D31
+          VPADD.S32         D30, D30, D30
+          VMOV.S32          r12, D30[0]
+
+	  ADD               r12, r12, r12
+          ADD               r12, r12, #1                         @ L_sum = (L_sum << 1)  + 1
+	  MOV               r4, r12
+	  CMP               r12, #0
+	  RSBLT             r4, r12, #0
+          CLZ               r10, r4
+          SUB               r10, r10, #1                         @ sft = norm_l(L_sum)
+          MOV               r0, r12, LSL r10                     @ L_sum = L_sum << sft
+          RSB               r11, r10, #30                        @ *exp = 30 - sft
+          STRH              r11, [r3]
+
+Dot_product12_end:
+
+          LDMFD   	    r13!, {r4 - r12, r15}
+
+          .END
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Filt_6k_7k_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Filt_6k_7k_neon.s
index 1880024..14ba828 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Filt_6k_7k_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Filt_6k_7k_neon.s
@@ -1,228 +1,228 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@                             
-@**********************************************************************/
-@void Filt_6k_7k(
-@     Word16 signal[],                      /* input:  signal                  */
-@     Word16 lg,                            /* input:  length of input         */
-@     Word16 mem[]                          /* in/out: memory (size=30)        */
-@)
-@***********************************************************************
-@ r0    ---  signal[]
-@ r1    ---  lg
-@ r2    ---  mem[] 
-
-          .section  .text
-          .global   Filt_6k_7k_asm
-          .extern   fir_6k_7k
-
-Filt_6k_7k_asm:
-
-          STMFD   		r13!, {r0 - r12, r14} 
-          SUB    		r13, r13, #240              @ x[L_SUBFR16k + (L_FIR - 1)]
-          MOV     		r8, r0                      @ copy signal[] address
-          MOV     		r5, r2                      @ copy mem[] address
-
-          MOV     		r0, r2
-          MOV     		r1, r13
-
-	  VLD1.S16              {D0, D1, D2, D3}, [r0]!
-	  VLD1.S16              {D4, D5, D6, D7}, [r0]!
-
-	  VST1.S16              {D0, D1, D2, D3}, [r1]!
-	  VST1.S16              {D4, D5, D6}, [r1]!
-	  VST1.S16              D7[0], [r1]!
-	  VST1.S16              D7[1], [r1]!
-
-
-
-          LDR     		r10, Lable1                 @ get fir_7k address     
-          MOV                   r3, r8                      @ change myMemCopy to Copy, due to Copy will change r3 content
-          ADD     	    	r6, r13, #60                @ get x[L_FIR - 1] address
-          MOV           	r7, r3                      @ get signal[i]
-          @for (i = lg - 1@ i >= 0@ i--)
-          @{
-          @     x[i + L_FIR - 1] = signal[i] >> 2@
-          @}
-	  VLD1.S16              {Q0, Q1}, [r7]!		    @ signal[0]  ~ signal[15]
-	  VLD1.S16              {Q2, Q3}, [r7]!             @ signal[16] ~ signal[31]
-          VLD1.S16              {Q4, Q5}, [r7]!             @ signal[32] ~ signal[47]
-	  VLD1.S16              {Q6, Q7}, [r7]!             @ signal[48] ~ signal[63]
-	  VLD1.S16              {Q8, Q9}, [r7]!             @ signal[64] ~ signal[79]
-	  VSHR.S16              Q10, Q0, #2
-          VSHR.S16              Q11, Q1, #2
-          VSHR.S16              Q12, Q2, #2
-	  VSHR.S16              Q13, Q3, #2
-	  VST1.S16              {Q10, Q11}, [r6]!
-	  VSHR.S16              Q0,  Q4, #2
-	  VSHR.S16              Q1,  Q5, #2
-	  VSHR.S16              Q10, Q6, #2
-	  VSHR.S16              Q11, Q7, #2
-	  VSHR.S16              Q2,  Q8, #2
-	  VSHR.S16              Q3,  Q9, #2
-	  VST1.S16              {Q12, Q13}, [r6]!
-	  VST1.S16              {Q0, Q1}, [r6]!
-	  VST1.S16              {Q10, Q11}, [r6]!
-	  VST1.S16              {Q2, Q3}, [r6]!
-
-	  MOV                   r12, r5
-          @STR     		r5, [sp, #-4]               @ PUSH  r5 to stack
-          @ not use registers: r4, r10, r12, r14, r5
-          MOV     		r4, r13 
-          MOV     		r5, #0                      @ i = 0    
-         
-          @ r4 --- x[i], r10 ---- fir_6k_7k
-          VLD1.S16              {Q0, Q1}, [r10]!           @fir_6k_7k[0]  ~ fir_6k_7k[15]
-	  VLD1.S16              {Q2, Q3}, [r10]!           @fir_6k_7k[16] ~ fir_6k_7k[31]
-          VMOV.S16              D7[3], r5                        @set fir_6k_7K = 0
-
-	  VLD1.S16              {Q4, Q5}, [r4]!            @x[0]  ~ x[15]
-	  VLD1.S16              {Q6, Q7}, [r4]!            @x[16] ~ X[31]
-	  VLD1.S16              {Q8}, [r4]! 
-          VMOV.S16              Q15, #0	  
-          
-LOOP_6K7K:
-
-          VMULL.S16             Q9,D8,D0[0]                 
-          VMULL.S16             Q10,D9,D1[0] 
-          VMULL.S16             Q11,D9,D0[0]                 
-          VMULL.S16             Q12,D10,D1[0]
-          VEXT.8                Q4,Q4,Q5,#2
-          VMLAL.S16             Q9,D10,D2[0]
-          VMLAL.S16             Q10,D11,D3[0]
-          VMLAL.S16             Q11,D11,D2[0]
-          VMLAL.S16             Q12,D12,D3[0]    
-          VEXT.8                Q5,Q5,Q6,#2
-          VMLAL.S16             Q9,D12,D4[0]
-          VMLAL.S16             Q10,D13,D5[0]
-          VMLAL.S16             Q11,D13,D4[0]
-          VMLAL.S16             Q12,D14,D5[0]
-          VEXT.8                Q6,Q6,Q7,#2
-          VMLAL.S16             Q9,D14,D6[0]
-          VMLAL.S16             Q10,D15,D7[0]
-          VMLAL.S16             Q11,D15,D6[0]
-	  VMLAL.S16             Q12,D16,D7[0]
-	  VEXT.8  		Q7,Q7,Q8,#2 
-
-	  VMLAL.S16 		Q9,D8,D0[1]                
-	  VMLAL.S16     	Q10,D9,D1[1]
-	  VEXT.8 		Q8,Q8,Q15,#2 
-	  VMLAL.S16 		Q11,D9,D0[1]                
-	  VMLAL.S16 		Q12,D10,D1[1]
-	  VEXT.8  		Q4,Q4,Q5,#2
-	  VMLAL.S16 		Q9,D10,D2[1]
-	  VMLAL.S16 		Q10,D11,D3[1]
-	  VMLAL.S16 		Q11,D11,D2[1]
-	  VMLAL.S16 		Q12,D12,D3[1]    
-	  VEXT.8  		Q5,Q5,Q6,#2
-	  VMLAL.S16 		Q9,D12,D4[1]
-	  VMLAL.S16 		Q10,D13,D5[1]
-	  VMLAL.S16 		Q11,D13,D4[1]
-	  VMLAL.S16 		Q12,D14,D5[1]
-	  VEXT.8  		Q6,Q6,Q7,#2
-	  VMLAL.S16 		Q9,D14,D6[1]
-	  VMLAL.S16 		Q10,D15,D7[1]
-	  VMLAL.S16 		Q11,D15,D6[1]
-	  VMLAL.S16 		Q12,D16,D7[1]
-	  VEXT.8  		Q7,Q7,Q8,#2 
-
-	  VMLAL.S16 		Q9,D8,D0[2]           
-	  VMLAL.S16 		Q10,D9,D1[2]
-	  VEXT.8 		Q8,Q8,Q15,#2 
-	  VMLAL.S16 		Q11,D9,D0[2]           
-	  VMLAL.S16 		Q12,D10,D1[2]
-	  VEXT.8  		Q4,Q4,Q5,#2
-	  VMLAL.S16 		Q9,D10,D2[2]
-	  VMLAL.S16 		Q10,D11,D3[2]
-	  VMLAL.S16 		Q11,D11,D2[2]
-	  VMLAL.S16 		Q12,D12,D3[2]    
-	  VEXT.8  		Q5,Q5,Q6,#2
-	  VMLAL.S16 		Q9,D12,D4[2]
-	  VMLAL.S16 		Q10,D13,D5[2]
-	  VMLAL.S16 		Q11,D13,D4[2]
-	  VMLAL.S16 		Q12,D14,D5[2]
-	  VEXT.8  		Q6,Q6,Q7,#2
-	  VMLAL.S16 		Q9,D14,D6[2]
-	  VMLAL.S16 		Q10,D15,D7[2]
-	  VMLAL.S16 		Q11,D15,D6[2]
-	  VMLAL.S16 		Q12,D16,D7[2]
-	  VEXT.8  		Q7,Q7,Q8,#2 
-
-	  VMLAL.S16 		Q9,D8,D0[3]              
-	  VMLAL.S16 		Q10,D9,D1[3]
-	  VEXT.8 		Q8,Q8,Q15,#2 
-	  VMLAL.S16 		Q11,D9,D0[3]              
-	  VMLAL.S16 		Q12,D10,D1[3]
-	  VEXT.8  		Q4,Q4,Q5,#2
-	  VMLAL.S16 		Q9,D10,D2[3]
-	  VMLAL.S16 		Q10,D11,D3[3]
-	  VMLAL.S16 		Q11,D11,D2[3]
-	  VMLAL.S16 		Q12,D12,D3[3]    
-	  VEXT.8  		Q5,Q5,Q6,#2
-	  VMLAL.S16 		Q9,D12,D4[3]
-	  VMLAL.S16 		Q10,D13,D5[3]
-	  VMLAL.S16 		Q11,D13,D4[3]
-	  VMLAL.S16 		Q12,D14,D5[3]
-	  VEXT.8  		Q6,Q6,Q7,#2
-	  VMLAL.S16 		Q9,D14,D6[3]
-	  VMLAL.S16 		Q10,D15,D7[3]
-	  VMLAL.S16 		Q11,D15,D6[3]
-	  VMLAL.S16 		Q12,D16,D7[3]
-	  VEXT.8 		Q7,Q7,Q8,#2     
-
-	  VMOV.S16  		D8,D9
-	  VEXT.8 		Q8,Q8,Q15,#2 
-	  VMOV.S16  		D9,D10
-	  VADD.S32  		Q9,Q9,Q10
-	  VMOV.S16  		D10,D11
-	  VMOV.S16  		D11,D12
-	  VADD.S32  		Q11,Q11,Q12
-	  VMOV.S16  		D12,D13
-	  VQRSHRN.S32 		D28,Q9,#15
-	  VMOV.S16  		D13,D14
-	  VMOV.S16  		D14,D15
-	  VQRSHRN.S32 		D29,Q11,#15
-	  VMOV.S16  		D15,D16
-
-	  VLD1.S16  		{Q8},[r4]!
-	  ADD                   r5, r5, #8
-	  CMP   		r5, #80
-	  VST1.S16  		{D28,D29},[r3]!
-	  BLT     		LOOP_6K7K
-
-          ADD     		r0, r13, #160               @x + lg
-	  MOV                   r1, r12
-	  @LDR     		r1, [sp, #-4]               @mem address
-
-	  VLD1.S16              {D0, D1, D2, D3}, [r0]!
-	  VLD1.S16              {D4, D5, D6, D7}, [r0]!
-
-	  VST1.S16              {D0, D1, D2, D3}, [r1]!
-	  VST1.S16              {D4, D5, D6}, [r1]!
-	  VST1.S16              D7[0], [r1]!
-	  VST1.S16              D7[1], [r1]!
-                    
-Filt_6k_7k_end:
-
-          ADD     		r13, r13, #240  
-          LDMFD   		r13!, {r0 - r12, r15} 
- 
-Lable1:
-          .word   		fir_6k_7k
-          @ENDFUNC
-          .END
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@**********************************************************************/
+@void Filt_6k_7k(
+@     Word16 signal[],                      /* input:  signal                  */
+@     Word16 lg,                            /* input:  length of input         */
+@     Word16 mem[]                          /* in/out: memory (size=30)        */
+@)
+@***********************************************************************
+@ r0    ---  signal[]
+@ r1    ---  lg
+@ r2    ---  mem[]
+
+          .section  .text
+          .global   Filt_6k_7k_asm
+          .extern   fir_6k_7k
+
+Filt_6k_7k_asm:
+
+          STMFD   		r13!, {r0 - r12, r14}
+          SUB    		r13, r13, #240              @ x[L_SUBFR16k + (L_FIR - 1)]
+          MOV     		r8, r0                      @ copy signal[] address
+          MOV     		r5, r2                      @ copy mem[] address
+
+          MOV     		r0, r2
+          MOV     		r1, r13
+
+	  VLD1.S16              {D0, D1, D2, D3}, [r0]!
+	  VLD1.S16              {D4, D5, D6, D7}, [r0]!
+
+	  VST1.S16              {D0, D1, D2, D3}, [r1]!
+	  VST1.S16              {D4, D5, D6}, [r1]!
+	  VST1.S16              D7[0], [r1]!
+	  VST1.S16              D7[1], [r1]!
+
+
+
+          LDR     		r10, Lable1                 @ get fir_7k address
+          MOV                   r3, r8                      @ change myMemCopy to Copy, due to Copy will change r3 content
+          ADD     	    	r6, r13, #60                @ get x[L_FIR - 1] address
+          MOV           	r7, r3                      @ get signal[i]
+          @for (i = lg - 1@ i >= 0@ i--)
+          @{
+          @     x[i + L_FIR - 1] = signal[i] >> 2@
+          @}
+	  VLD1.S16              {Q0, Q1}, [r7]!		    @ signal[0]  ~ signal[15]
+	  VLD1.S16              {Q2, Q3}, [r7]!             @ signal[16] ~ signal[31]
+          VLD1.S16              {Q4, Q5}, [r7]!             @ signal[32] ~ signal[47]
+	  VLD1.S16              {Q6, Q7}, [r7]!             @ signal[48] ~ signal[63]
+	  VLD1.S16              {Q8, Q9}, [r7]!             @ signal[64] ~ signal[79]
+	  VSHR.S16              Q10, Q0, #2
+          VSHR.S16              Q11, Q1, #2
+          VSHR.S16              Q12, Q2, #2
+	  VSHR.S16              Q13, Q3, #2
+	  VST1.S16              {Q10, Q11}, [r6]!
+	  VSHR.S16              Q0,  Q4, #2
+	  VSHR.S16              Q1,  Q5, #2
+	  VSHR.S16              Q10, Q6, #2
+	  VSHR.S16              Q11, Q7, #2
+	  VSHR.S16              Q2,  Q8, #2
+	  VSHR.S16              Q3,  Q9, #2
+	  VST1.S16              {Q12, Q13}, [r6]!
+	  VST1.S16              {Q0, Q1}, [r6]!
+	  VST1.S16              {Q10, Q11}, [r6]!
+	  VST1.S16              {Q2, Q3}, [r6]!
+
+	  MOV                   r12, r5
+          @STR     		r5, [sp, #-4]               @ PUSH  r5 to stack
+          @ not use registers: r4, r10, r12, r14, r5
+          MOV     		r4, r13
+          MOV     		r5, #0                      @ i = 0
+
+          @ r4 --- x[i], r10 ---- fir_6k_7k
+          VLD1.S16              {Q0, Q1}, [r10]!           @fir_6k_7k[0]  ~ fir_6k_7k[15]
+	  VLD1.S16              {Q2, Q3}, [r10]!           @fir_6k_7k[16] ~ fir_6k_7k[31]
+          VMOV.S16              D7[3], r5                        @set fir_6k_7K = 0
+
+	  VLD1.S16              {Q4, Q5}, [r4]!            @x[0]  ~ x[15]
+	  VLD1.S16              {Q6, Q7}, [r4]!            @x[16] ~ X[31]
+	  VLD1.S16              {Q8}, [r4]!
+          VMOV.S16              Q15, #0
+
+LOOP_6K7K:
+
+          VMULL.S16             Q9,D8,D0[0]
+          VMULL.S16             Q10,D9,D1[0]
+          VMULL.S16             Q11,D9,D0[0]
+          VMULL.S16             Q12,D10,D1[0]
+          VEXT.8                Q4,Q4,Q5,#2
+          VMLAL.S16             Q9,D10,D2[0]
+          VMLAL.S16             Q10,D11,D3[0]
+          VMLAL.S16             Q11,D11,D2[0]
+          VMLAL.S16             Q12,D12,D3[0]
+          VEXT.8                Q5,Q5,Q6,#2
+          VMLAL.S16             Q9,D12,D4[0]
+          VMLAL.S16             Q10,D13,D5[0]
+          VMLAL.S16             Q11,D13,D4[0]
+          VMLAL.S16             Q12,D14,D5[0]
+          VEXT.8                Q6,Q6,Q7,#2
+          VMLAL.S16             Q9,D14,D6[0]
+          VMLAL.S16             Q10,D15,D7[0]
+          VMLAL.S16             Q11,D15,D6[0]
+	  VMLAL.S16             Q12,D16,D7[0]
+	  VEXT.8  		Q7,Q7,Q8,#2
+
+	  VMLAL.S16 		Q9,D8,D0[1]
+	  VMLAL.S16     	Q10,D9,D1[1]
+	  VEXT.8 		Q8,Q8,Q15,#2
+	  VMLAL.S16 		Q11,D9,D0[1]
+	  VMLAL.S16 		Q12,D10,D1[1]
+	  VEXT.8  		Q4,Q4,Q5,#2
+	  VMLAL.S16 		Q9,D10,D2[1]
+	  VMLAL.S16 		Q10,D11,D3[1]
+	  VMLAL.S16 		Q11,D11,D2[1]
+	  VMLAL.S16 		Q12,D12,D3[1]
+	  VEXT.8  		Q5,Q5,Q6,#2
+	  VMLAL.S16 		Q9,D12,D4[1]
+	  VMLAL.S16 		Q10,D13,D5[1]
+	  VMLAL.S16 		Q11,D13,D4[1]
+	  VMLAL.S16 		Q12,D14,D5[1]
+	  VEXT.8  		Q6,Q6,Q7,#2
+	  VMLAL.S16 		Q9,D14,D6[1]
+	  VMLAL.S16 		Q10,D15,D7[1]
+	  VMLAL.S16 		Q11,D15,D6[1]
+	  VMLAL.S16 		Q12,D16,D7[1]
+	  VEXT.8  		Q7,Q7,Q8,#2
+
+	  VMLAL.S16 		Q9,D8,D0[2]
+	  VMLAL.S16 		Q10,D9,D1[2]
+	  VEXT.8 		Q8,Q8,Q15,#2
+	  VMLAL.S16 		Q11,D9,D0[2]
+	  VMLAL.S16 		Q12,D10,D1[2]
+	  VEXT.8  		Q4,Q4,Q5,#2
+	  VMLAL.S16 		Q9,D10,D2[2]
+	  VMLAL.S16 		Q10,D11,D3[2]
+	  VMLAL.S16 		Q11,D11,D2[2]
+	  VMLAL.S16 		Q12,D12,D3[2]
+	  VEXT.8  		Q5,Q5,Q6,#2
+	  VMLAL.S16 		Q9,D12,D4[2]
+	  VMLAL.S16 		Q10,D13,D5[2]
+	  VMLAL.S16 		Q11,D13,D4[2]
+	  VMLAL.S16 		Q12,D14,D5[2]
+	  VEXT.8  		Q6,Q6,Q7,#2
+	  VMLAL.S16 		Q9,D14,D6[2]
+	  VMLAL.S16 		Q10,D15,D7[2]
+	  VMLAL.S16 		Q11,D15,D6[2]
+	  VMLAL.S16 		Q12,D16,D7[2]
+	  VEXT.8  		Q7,Q7,Q8,#2
+
+	  VMLAL.S16 		Q9,D8,D0[3]
+	  VMLAL.S16 		Q10,D9,D1[3]
+	  VEXT.8 		Q8,Q8,Q15,#2
+	  VMLAL.S16 		Q11,D9,D0[3]
+	  VMLAL.S16 		Q12,D10,D1[3]
+	  VEXT.8  		Q4,Q4,Q5,#2
+	  VMLAL.S16 		Q9,D10,D2[3]
+	  VMLAL.S16 		Q10,D11,D3[3]
+	  VMLAL.S16 		Q11,D11,D2[3]
+	  VMLAL.S16 		Q12,D12,D3[3]
+	  VEXT.8  		Q5,Q5,Q6,#2
+	  VMLAL.S16 		Q9,D12,D4[3]
+	  VMLAL.S16 		Q10,D13,D5[3]
+	  VMLAL.S16 		Q11,D13,D4[3]
+	  VMLAL.S16 		Q12,D14,D5[3]
+	  VEXT.8  		Q6,Q6,Q7,#2
+	  VMLAL.S16 		Q9,D14,D6[3]
+	  VMLAL.S16 		Q10,D15,D7[3]
+	  VMLAL.S16 		Q11,D15,D6[3]
+	  VMLAL.S16 		Q12,D16,D7[3]
+	  VEXT.8 		Q7,Q7,Q8,#2
+
+	  VMOV.S16  		D8,D9
+	  VEXT.8 		Q8,Q8,Q15,#2
+	  VMOV.S16  		D9,D10
+	  VADD.S32  		Q9,Q9,Q10
+	  VMOV.S16  		D10,D11
+	  VMOV.S16  		D11,D12
+	  VADD.S32  		Q11,Q11,Q12
+	  VMOV.S16  		D12,D13
+	  VQRSHRN.S32 		D28,Q9,#15
+	  VMOV.S16  		D13,D14
+	  VMOV.S16  		D14,D15
+	  VQRSHRN.S32 		D29,Q11,#15
+	  VMOV.S16  		D15,D16
+
+	  VLD1.S16  		{Q8},[r4]!
+	  ADD                   r5, r5, #8
+	  CMP   		r5, #80
+	  VST1.S16  		{D28,D29},[r3]!
+	  BLT     		LOOP_6K7K
+
+          ADD     		r0, r13, #160               @x + lg
+	  MOV                   r1, r12
+	  @LDR     		r1, [sp, #-4]               @mem address
+
+	  VLD1.S16              {D0, D1, D2, D3}, [r0]!
+	  VLD1.S16              {D4, D5, D6, D7}, [r0]!
+
+	  VST1.S16              {D0, D1, D2, D3}, [r1]!
+	  VST1.S16              {D4, D5, D6}, [r1]!
+	  VST1.S16              D7[0], [r1]!
+	  VST1.S16              D7[1], [r1]!
+
+Filt_6k_7k_end:
+
+          ADD     		r13, r13, #240
+          LDMFD   		r13!, {r0 - r12, r15}
+
+Lable1:
+          .word   		fir_6k_7k
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Norm_Corr_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Norm_Corr_neon.s
index 60e9ade..4263cd4 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Norm_Corr_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Norm_Corr_neon.s
@@ -33,7 +33,7 @@
 
 
 	.section  .text
-        .global    Norm_corr_asm 
+        .global    Norm_corr_asm
         .extern    Convolve_asm
         .extern    Isqrt_n
 @******************************
@@ -47,17 +47,17 @@
 .equ    T_MIN             , 212
 .equ    T_MAX             , 216
 .equ    CORR_NORM         , 220
-                  
+
 Norm_corr_asm:
 
-        STMFD          r13!, {r4 - r12, r14}  
+        STMFD          r13!, {r4 - r12, r14}
         SUB            r13, r13, #voSTACK
-  
+
         ADD            r8, r13, #20                 @get the excf[L_SUBFR]
         LDR            r4, [r13, #T_MIN]            @get t_min
         RSB            r11, r4, #0                  @k = -t_min
-        ADD            r5, r0, r11, LSL #1          @get the &exc[k]   
-        
+        ADD            r5, r0, r11, LSL #1          @get the &exc[k]
+
         @transfer Convolve function
         STMFD          sp!, {r0 - r3}
         MOV            r0, r5
@@ -68,7 +68,7 @@ Norm_corr_asm:
 
         @ r8 --- excf[]
 
-	MOV            r14, r1                       @copy xn[] address                      
+	MOV            r14, r1                       @copy xn[] address
         MOV            r7, #1
 	VLD1.S16       {Q0, Q1}, [r14]!
 	VLD1.S16       {Q2, Q3}, [r14]!
@@ -95,34 +95,34 @@ Norm_corr_asm:
         VQADD.S32      D20, D20, D21
         VMOV.S32       r9,  D20[0]
         VMOV.S32       r10, D20[1]
-        QADD           r6, r9, r10 
+        QADD           r6, r9, r10
 	QADD           r6, r6, r6
         QADD           r9, r6, r7                   @L_tmp = (L_tmp << 1) + 1;
 	CLZ            r7, r9
 	SUB            r6, r7, #1                   @exp = norm_l(L_tmp)
         RSB            r7, r6, #32                  @exp = 32 - exp
-	MOV            r6, r7, ASR #1         
+	MOV            r6, r7, ASR #1
 	RSB            r7, r6, #0                   @scale = -(exp >> 1)
-	
+
         @loop for every possible period
 	@for(t = t_min@ t <= t_max@ t++)
 	@r7 --- scale r4 --- t_min r8 --- excf[]
 
-LOOPFOR:	
+LOOPFOR:
 	ADD            r14, r13, #20                @copy of excf[]
 	MOV            r12, r1                      @copy of xn[]
 	MOV            r8, #0x8000
 
         VLD1.S16       {Q0, Q1}, [r14]!                 @ load 16 excf[]
-        VLD1.S16       {Q2, Q3}, [r14]!                 @ load 16 excf[]       
+        VLD1.S16       {Q2, Q3}, [r14]!                 @ load 16 excf[]
         VLD1.S16       {Q4, Q5}, [r12]!                 @ load 16 x[]
 	VLD1.S16       {Q6, Q7}, [r12]!                 @ load 16 x[]
         VMULL.S16    Q10, D0, D0                      @L_tmp1 += excf[] * excf[]
-        VMULL.S16    Q11, D0, D8                      @L_tmp  += x[] * excf[]                   
+        VMULL.S16    Q11, D0, D8                      @L_tmp  += x[] * excf[]
         VMLAL.S16    Q10, D1, D1
         VMLAL.S16    Q11, D1, D9
         VMLAL.S16    Q10, D2, D2
-        VMLAL.S16    Q11, D2, D10        
+        VMLAL.S16    Q11, D2, D10
         VMLAL.S16    Q10, D3, D3
         VMLAL.S16    Q11, D3, D11
         VMLAL.S16    Q10, D4, D4
@@ -143,7 +143,7 @@ LOOPFOR:
         VMLAL.S16    Q10, D1, D1
         VMLAL.S16    Q11, D1, D9
         VMLAL.S16    Q10, D2, D2
-        VMLAL.S16    Q11, D2, D10        
+        VMLAL.S16    Q11, D2, D10
         VMLAL.S16    Q10, D3, D3
         VMLAL.S16    Q11, D3, D11
         VMLAL.S16    Q10, D4, D4
@@ -162,19 +162,19 @@ LOOPFOR:
 	VPADD.S32      D22, D22, D22                   @D22[0] --- L_tmp << 1
 
 	VMOV.S32       r6, D20[0]
-        VMOV.S32       r5, D22[0]	
+        VMOV.S32       r5, D22[0]
 
 	@r5 --- L_tmp, r6 --- L_tmp1
 	MOV            r10, #1
 	ADD            r5, r10, r5, LSL #1                     @L_tmp = (L_tmp << 1) + 1
 	ADD            r6, r10, r6, LSL #1                     @L_tmp1 = (L_tmp1 << 1) + 1
- 
-	CLZ            r10, r5        
+
+	CLZ            r10, r5
 	CMP            r5, #0
 	RSBLT          r11, r5, #0
 	CLZLT          r10, r11
 	SUB            r10, r10, #1                 @exp = norm_l(L_tmp)
-     
+
 	MOV            r5, r5, LSL r10              @L_tmp = (L_tmp << exp)
 	RSB            r10, r10, #30                @exp_corr = 30 - exp
 	MOV            r11, r5, ASR #16             @corr = extract_h(L_tmp)
@@ -190,7 +190,7 @@ LOOPFOR:
 	@Isqrt_n(&L_tmp, &exp_norm)
 
 	MOV            r14, r0
-	MOV            r12, r1 
+	MOV            r12, r1
 
         STMFD          sp!, {r0 - r4, r7 - r12, r14}
 	ADD            r1, sp, #4
@@ -208,7 +208,7 @@ LOOPFOR:
 	MOV            r6, r6, ASR #16              @norm = extract_h(L_tmp)
 	MUL            r12, r6, r11
 	ADD            r12, r12, r12                @L_tmp = vo_L_mult(corr, norm)
-  
+
 	ADD            r6, r10, r5
 	ADD            r6, r6, r7                   @exp_corr + exp_norm + scale
 
@@ -227,8 +227,8 @@ LOOPFOR:
 
 	CMP            r4, r6
 	BEQ            Norm_corr_asm_end
- 
-	ADD            r4, r4, #1                   @ t_min ++ 
+
+	ADD            r4, r4, #1                   @ t_min ++
 	RSB            r5, r4, #0                   @ k
 
 	MOV            r6, #63                      @ i = 63
@@ -255,16 +255,16 @@ LOOPK:
 	MUL            r14, r11, r8
         LDR            r6, [r13, #T_MAX]            @ get t_max
 	MOV            r8, r14, ASR #15
-	STRH           r8, [r10]                    
+	STRH           r8, [r10]
 
 	CMP            r4, r6
 	BLE            LOOPFOR
 
-Norm_corr_asm_end: 
-        
-        ADD            r13, r13, #voSTACK      
+Norm_corr_asm_end:
+
+        ADD            r13, r13, #voSTACK
         LDMFD          r13!, {r4 - r12, r15}
-    
+
         .END
 
 
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Syn_filt_32_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Syn_filt_32_neon.s
index cb1764f..e786dde 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Syn_filt_32_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/Syn_filt_32_neon.s
@@ -1,133 +1,133 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@**********************************************************************/
-@void Syn_filt_32(
-@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
-@     Word16 m,                             /* (i)     : order of LP filter             */
-@     Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
-@     Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
-@     Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
-@     Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
-@     Word16 lg                             /* (i)     : size of filtering              */
-@)
-@***********************************************************************
-@ a[]      --- r0
-@ m        --- r1
-@ exc[]    --- r2
-@ Qnew     --- r3
-@ sig_hi[] --- r4
-@ sig_lo[] --- r5
-@ lg       --- r6
-
-          .section  .text 
-          .global   Syn_filt_32_asm
-
-Syn_filt_32_asm:
-
-          STMFD   	r13!, {r4 - r12, r14} 
-          LDR           r4,  [r13, #40]                  @ get sig_hi[] address
-          LDR           r5,  [r13, #44]                  @ get sig_lo[] address
-
-          LDRSH         r6,  [r0], #2                    @ load Aq[0]
-          ADD           r7,  r3, #4                      @ 4 + Q_new
-          MOV           r3, r6, ASR r7                   @ a0 = Aq[0] >> (4 + Q_new)
-
-	  SUB           r10, r4, #32                     @ sig_hi[-16] address
-	  SUB           r11, r5, #32                     @ sig_lo[-16] address
-
-	  VLD1.S16      {D0, D1, D2, D3}, [r0]!          @a[1] ~ a[16] 
-  
-          MOV           r8, #0                           @ i = 0
-
-	  VLD1.S16      {D4, D5, D6, D7}, [r10]!         @ sig_hi[-16] ~ sig_hi[-1]
-          VREV64.16     D0, D0
-          VREV64.16     D1, D1
-	  VLD1.S16      {D8, D9, D10, D11}, [r11]!       @ sig_lo[-16] ~ sig_lo[-1]
-          VREV64.16     D2, D2
-          VREV64.16     D3, D3	
-          VDUP.S32      Q15, r8
-              
-SYN_LOOP:
-
-          LDRSH         r6, [r2], #2                     @exc[i]
-	  @L_tmp = L_msu(L_tmp, sig_lo[i - j], a[j])@
-	  VMULL.S16     Q10, D8, D3
-	  VEXT.8        D8, D8, D9, #2
-	  VMLAL.S16     Q10, D9, D2
-	  VMLAL.S16     Q10, D10, D1
-	  VMLAL.S16     Q10, D11, D0
-
-	  VEXT.8        D9, D9, D10, #2
-	  VEXT.8        D10, D10, D11, #2
-	  
-	  VPADD.S32     D28, D20, D21
-          MUL           r12, r6, r3                      @exc[i] * a0
-	  VPADD.S32     D29, D28, D28
-	  VDUP.S32      Q10, D29[0]                      @result1
-          
-	  VMULL.S16     Q11, D4, D3
-	  VMLAL.S16     Q11, D5, D2
-          VSUB.S32      Q10, Q15, Q10
-	  @L_tmp = L_msu(L_tmp, sig_hi[i - j], a[j])@
-
-	  VMLAL.S16     Q11, D6, D1
-	  VEXT.8        D4, D4, D5, #2
-	  VMLAL.S16     Q11, D7, D0
-
-
-	  VEXT.8        D5, D5, D6, #2
-	  VEXT.8        D6, D6, D7, #2
-
-	  VPADD.S32     D28, D22, D23
-          VPADD.S32     D29, D28, D28
-          MOV           r14, r12, LSL #1                 @exc[i] * a0 << 1
-          VDUP.S32      Q11, D29[0]                      @result2
-
-
-
-	  VSHR.S32      Q10, Q10, #11                    @result1 >>= 11
-	  VSHL.S32      Q11, Q11, #1                     @result2 <<= 1
-	  VDUP.S32      Q12, r14                         
-	  VADD.S32      Q12, Q12, Q10                    @L_tmp = L_tmp - (result1 >>= 11) - (result2 <<= 1)
-	  VSUB.S32      Q12, Q12, Q11
-
-	  VSHL.S32      Q12, Q12, #3                     @L_tmp <<= 3
-
-
-	  VSHRN.S32     D20, Q12, #16                    @sig_hi[i] = L_tmp >> 16@
-	  VMOV.S16      r10, D20[0]
-	  VSHR.S32      Q12, Q12, #4                     @L_tmp >>= 4
-	  VEXT.8        D7, D7, D20, #2
-	  STRH          r10, [r4], #2                    @store sig_hi[i]
-          VMOV.S32      r11, D24[0]                      @r11 --- L_tmp >>= 4
-	  ADD           r8, r8, #1
-	  SUB           r12, r11, r10, LSL #12
-	  @MOV           r11, r12, ASR #16                @sig_lo[i]
-	  VDUP.S16      D21, r12
-	  VEXT.8        D11, D11, D21, #2
-	  STRH          r12, [r5], #2                    @stroe sig_lo[i]
-
-          CMP           r8, #64
-          BLT           SYN_LOOP                          
-         
-Syn_filt_32_end:
-		     
-          LDMFD   	    r13!, {r4 - r12, r15} 
-          @ENDFUNC
-          .END
- 
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@**********************************************************************/
+@void Syn_filt_32(
+@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
+@     Word16 m,                             /* (i)     : order of LP filter             */
+@     Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
+@     Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
+@     Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
+@     Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
+@     Word16 lg                             /* (i)     : size of filtering              */
+@)
+@***********************************************************************
+@ a[]      --- r0
+@ m        --- r1
+@ exc[]    --- r2
+@ Qnew     --- r3
+@ sig_hi[] --- r4
+@ sig_lo[] --- r5
+@ lg       --- r6
+
+          .section  .text
+          .global   Syn_filt_32_asm
+
+Syn_filt_32_asm:
+
+          STMFD   	r13!, {r4 - r12, r14}
+          LDR           r4,  [r13, #40]                  @ get sig_hi[] address
+          LDR           r5,  [r13, #44]                  @ get sig_lo[] address
+
+          LDRSH         r6,  [r0], #2                    @ load Aq[0]
+          ADD           r7,  r3, #4                      @ 4 + Q_new
+          MOV           r3, r6, ASR r7                   @ a0 = Aq[0] >> (4 + Q_new)
+
+	  SUB           r10, r4, #32                     @ sig_hi[-16] address
+	  SUB           r11, r5, #32                     @ sig_lo[-16] address
+
+	  VLD1.S16      {D0, D1, D2, D3}, [r0]!          @a[1] ~ a[16]
+
+          MOV           r8, #0                           @ i = 0
+
+	  VLD1.S16      {D4, D5, D6, D7}, [r10]!         @ sig_hi[-16] ~ sig_hi[-1]
+          VREV64.16     D0, D0
+          VREV64.16     D1, D1
+	  VLD1.S16      {D8, D9, D10, D11}, [r11]!       @ sig_lo[-16] ~ sig_lo[-1]
+          VREV64.16     D2, D2
+          VREV64.16     D3, D3
+          VDUP.S32      Q15, r8
+
+SYN_LOOP:
+
+          LDRSH         r6, [r2], #2                     @exc[i]
+	  @L_tmp = L_msu(L_tmp, sig_lo[i - j], a[j])@
+	  VMULL.S16     Q10, D8, D3
+	  VEXT.8        D8, D8, D9, #2
+	  VMLAL.S16     Q10, D9, D2
+	  VMLAL.S16     Q10, D10, D1
+	  VMLAL.S16     Q10, D11, D0
+
+	  VEXT.8        D9, D9, D10, #2
+	  VEXT.8        D10, D10, D11, #2
+
+	  VPADD.S32     D28, D20, D21
+          MUL           r12, r6, r3                      @exc[i] * a0
+	  VPADD.S32     D29, D28, D28
+	  VDUP.S32      Q10, D29[0]                      @result1
+
+	  VMULL.S16     Q11, D4, D3
+	  VMLAL.S16     Q11, D5, D2
+          VSUB.S32      Q10, Q15, Q10
+	  @L_tmp = L_msu(L_tmp, sig_hi[i - j], a[j])@
+
+	  VMLAL.S16     Q11, D6, D1
+	  VEXT.8        D4, D4, D5, #2
+	  VMLAL.S16     Q11, D7, D0
+
+
+	  VEXT.8        D5, D5, D6, #2
+	  VEXT.8        D6, D6, D7, #2
+
+	  VPADD.S32     D28, D22, D23
+          VPADD.S32     D29, D28, D28
+          MOV           r14, r12, LSL #1                 @exc[i] * a0 << 1
+          VDUP.S32      Q11, D29[0]                      @result2
+
+
+
+	  VSHR.S32      Q10, Q10, #11                    @result1 >>= 11
+	  VSHL.S32      Q11, Q11, #1                     @result2 <<= 1
+	  VDUP.S32      Q12, r14
+	  VADD.S32      Q12, Q12, Q10                    @L_tmp = L_tmp - (result1 >>= 11) - (result2 <<= 1)
+	  VSUB.S32      Q12, Q12, Q11
+
+	  VSHL.S32      Q12, Q12, #3                     @L_tmp <<= 3
+
+
+	  VSHRN.S32     D20, Q12, #16                    @sig_hi[i] = L_tmp >> 16@
+	  VMOV.S16      r10, D20[0]
+	  VSHR.S32      Q12, Q12, #4                     @L_tmp >>= 4
+	  VEXT.8        D7, D7, D20, #2
+	  STRH          r10, [r4], #2                    @store sig_hi[i]
+          VMOV.S32      r11, D24[0]                      @r11 --- L_tmp >>= 4
+	  ADD           r8, r8, #1
+	  SUB           r12, r11, r10, LSL #12
+	  @MOV           r11, r12, ASR #16                @sig_lo[i]
+	  VDUP.S16      D21, r12
+	  VEXT.8        D11, D11, D21, #2
+	  STRH          r12, [r5], #2                    @stroe sig_lo[i]
+
+          CMP           r8, #64
+          BLT           SYN_LOOP
+
+Syn_filt_32_end:
+
+          LDMFD   	    r13!, {r4 - r12, r15}
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/convolve_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/convolve_neon.s
index 189e33b..8efa9fb 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/convolve_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/convolve_neon.s
@@ -20,22 +20,22 @@
 @*    Word16 y[],        /* (o)     : output vector                          */
 @*    Word16 L           /* (i)     : vector size                            */
 @*)
-@ 
+@
 @ r0 --- x[]
 @ r1 --- h[]
 @ r2 --- y[]
 @ r3 --- L
 
-	.section  .text 
-        .global   Convolve_asm 
+	.section  .text
+        .global   Convolve_asm
 
 Convolve_asm:
 
-        STMFD          r13!, {r4 - r12, r14}  
-        MOV            r3,  #0                        
+        STMFD          r13!, {r4 - r12, r14}
+        MOV            r3,  #0
 	MOV            r11, #0x8000
-        
-LOOP: 
+
+LOOP:
         @MOV            r8, #0                            @ s = 0
         ADD            r4, r1, r3, LSL #1                @ tmpH address
         ADD            r5, r3, #1                        @ i = n + 1
@@ -43,21 +43,21 @@ LOOP:
         LDRSH          r9,  [r6], #2                     @ *tmpX++
         LDRSH          r10, [r4]                         @ *tmpH--
         SUB            r5, r5, #1
-        VMOV.S32       Q10, #0 
-        MUL            r8,  r9, r10 
+        VMOV.S32       Q10, #0
+        MUL            r8,  r9, r10
 
-LOOP1:                    
+LOOP1:
         CMP            r5, #0
         BLE            L1
         SUB            r4, r4, #8
         MOV            r9, r4
-        VLD1.S16       D0, [r6]!   
+        VLD1.S16       D0, [r6]!
         VLD1.S16       D1, [r9]!
         VREV64.16      D1, D1
-        SUBS           r5, r5, #4  
-        VMLAL.S16      Q10, D0, D1         
-        B              LOOP1    
-L1:                  
+        SUBS           r5, r5, #4
+        VMLAL.S16      Q10, D0, D1
+        B              LOOP1
+L1:
         VADD.S32       D20, D20, D21
         VPADD.S32      D20, D20, D20
         VMOV.S32       r5, D20[0]
@@ -73,25 +73,25 @@ L1:
         ADD            r5, r3, #1
         MOV            r6, r0
         LDRSH          r9,  [r6], #2                     @ *tmpX++
-        LDRSH          r10, [r4], #-2                     
+        LDRSH          r10, [r4], #-2
         LDRSH          r12, [r6], #2
         LDRSH          r14, [r4]
 
         MUL            r8, r9, r10
         SUB            r5, r5, #2
         MLA            r8, r12, r14, r8
-        
+
         VMOV.S32       Q10, #0
 LOOP2:
         CMP            r5, #0
         BLE            L2
         SUB            r4, r4, #8
         MOV            r9, r4
-        VLD1.S16       D0, [r6]!   
+        VLD1.S16       D0, [r6]!
         VLD1.S16       D1, [r9]!
         SUBS           r5, r5, #4
         VREV64.16      D1, D1
-        VMLAL.S16      Q10, D0, D1 
+        VMLAL.S16      Q10, D0, D1
         B              LOOP2
 L2:
         VADD.S32       D20, D20, D21
@@ -100,7 +100,7 @@ L2:
         ADD            r8, r8, r5
         ADD            r8, r11, r8, LSL #1
         MOV            r8, r8, LSR #16                   @extract_h(s)
-        ADD            r3, r3, #1  
+        ADD            r3, r3, #1
         STRH           r8, [r2], #2                      @y[n]
 
 
@@ -115,7 +115,7 @@ L2:
         MUL            r8, r9, r10
         LDRSH          r9,  [r6], #2
         LDRSH          r10, [r4]
-        MLA            r8, r12, r14, r8 
+        MLA            r8, r12, r14, r8
         SUB            r5, r5, #3
         MLA            r8, r9, r10, r8
 
@@ -125,12 +125,12 @@ LOOP3:
         BLE            L3
         SUB            r4, r4, #8
         MOV            r9, r4
-        VLD1.S16       D0, [r6]!   
+        VLD1.S16       D0, [r6]!
         VLD1.S16       D1, [r9]!
         VREV64.16      D1, D1
         SUBS           r5, r5, #4
-        VMLAL.S16      Q10, D0, D1 
-        B              LOOP3   
+        VMLAL.S16      Q10, D0, D1
+        B              LOOP3
 
 L3:
         VADD.S32       D20, D20, D21
@@ -146,18 +146,18 @@ L3:
         ADD            r4, r1, r5, LSL #1                @ tmpH address
         MOV            r6, r0
         VMOV.S32       Q10, #0
-LOOP4:                    
+LOOP4:
         CMP            r5, #0
         BLE            L4
         SUB            r4, r4, #8
         MOV            r9, r4
-        VLD1.S16       D0, [r6]!   
+        VLD1.S16       D0, [r6]!
         VLD1.S16       D1, [r9]!
         VREV64.16      D1, D1
-        SUBS           r5, r5, #4  
-        VMLAL.S16      Q10, D0, D1         
-        B              LOOP4    
-L4:                  
+        SUBS           r5, r5, #4
+        VMLAL.S16      Q10, D0, D1
+        B              LOOP4
+L4:
         VADD.S32       D20, D20, D21
         VPADD.S32      D20, D20, D20
         VMOV.S32       r5,  D20[0]
@@ -165,14 +165,14 @@ L4:
         MOV            r5, r5, LSR #16                   @extract_h(s)
         ADD            r3, r3, #1
         STRH           r5, [r2], #2                      @y[n]
-        
+
         CMP            r3, #64
         BLT            LOOP
-                
-Convolve_asm_end: 
- 
+
+Convolve_asm_end:
+
         LDMFD      r13!, {r4 - r12, r15}
-    
+
         @ENDFUNC
         .END
 
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/cor_h_vec_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/cor_h_vec_neon.s
index 2e339db..8904289 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/cor_h_vec_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/cor_h_vec_neon.s
@@ -1,151 +1,151 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@static void cor_h_vec_012(
-@		Word16 h[],                           /* (i) scaled impulse response                 */
-@		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
-@		Word16 track,                         /* (i) track to use                            */
-@		Word16 sign[],                        /* (i) sign vector                             */
-@		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
-@		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
-@		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
-@)
-@r0 ---- h[]
-@r1 ---- vec[]
-@r2 ---- track
-@r3 ---- sign[]
-@r4 ---- rrixix[][NB_POS]
-@r5 ---- cor_1[]
-@r6 ---- cor_2[]
-
-              .section .text 
-	      .global  cor_h_vec_012_asm
-
-cor_h_vec_012_asm:
-
-             STMFD         r13!, {r4 - r12, r14}
-	     LDR           r4, [r13, #40]                    @load rrixix[][NB_POS]
-	     ADD           r7, r4, r2, LSL #5                @r7 --- p0 = rrixix[track]
-             MOV           r4, #0                            @i=0
-
-	     @r0 --- h[], r1 --- vec[],  r2 --- pos
-	     @r3 --- sign[], r4 --- i, r7 --- p0
-
-LOOPi:
-             MOV           r5, #0                            @L_sum1 = 0
-	     MOV           r6, #0                            @L_sum2 = 0
-	     ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
-	     MOV           r10, r0                           @p1 = h
-	     RSB           r11, r2, #62                      @j=62-pos
-
-LOOPj1:
-	     LDRSH         r12, [r10], #2  
-	     LDRSH         r8,  [r9], #2
-	     LDRSH         r14, [r9]
-	     SUBS          r11, r11, #1
-             MLA           r5, r12, r8, r5
-             MLA           r6, r12, r14, r6	 
-	     BGE           LOOPj1
-
-	     LDRSH         r12, [r10], #2                     @*p1++
-	     MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
-             MLA           r5, r12, r14, r5
-             MOV           r14, #0x8000
-             MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
-             ADD           r10, r6, r14         
-             ADD           r9, r5, r14
-             MOV           r5, r9, ASR #16
-             MOV           r6, r10, ASR #16
-             ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
-             ADD           r8, r7, #32
-             LDRSH         r10, [r9], #2                 	  @sign[pos]
-	     LDRSH         r11, [r9]                          @sign[pos + 1]
-	     MUL           r12, r5, r10
-	     MUL           r14, r6, r11
-	     MOV           r5, r12, ASR #15
-	     MOV           r6, r14, ASR #15
-	     LDR           r9,  [r13, #44]                   
-	     LDR           r12, [r13, #48]
-             LDRSH         r10, [r7], #2                      @*p0++
-	     LDRSH         r11, [r8]                          @*p3++
-             ADD           r9, r9, r4, LSL #1
-	     ADD           r12, r12, r4, LSL #1
-	     ADD           r5, r5, r10
-	     ADD           r6, r6, r11
-	     STRH          r5, [r9]
-	     STRH          r6, [r12]
-
-             ADD           r2, r2, #4
- 
-             MOV           r5, #0                            @L_sum1 = 0
-	     MOV           r6, #0                            @L_sum2 = 0
-	     ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
-	     MOV           r10, r0                           @p1 = h
-	     RSB           r11, r2, #62                      @j=62-pos
-	     ADD           r4, r4, #1                        @i++
-
-LOOPj2:
-	     LDRSH         r12, [r10], #2  
-	     LDRSH         r8,  [r9], #2
-	     LDRSH         r14, [r9]
-	     SUBS          r11, r11, #1
-             MLA           r5, r12, r8, r5
-             MLA           r6, r12, r14, r6	 
-	     BGE           LOOPj2
-
-	     LDRSH         r12, [r10], #2                     @*p1++
-	     MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
-             MLA           r5, r12, r14, r5
-             MOV           r14, #0x8000
-             MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
-             ADD           r10, r6, r14        
-             ADD           r9, r5, r14
-
-             MOV           r5, r9, ASR #16
-             MOV           r6, r10, ASR #16
-             ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
-             ADD           r8, r7, #32
-             LDRSH         r10, [r9], #2                 	  @sign[pos]
-	     LDRSH         r11, [r9]                          @sign[pos + 1]
-	     MUL           r12, r5, r10
-	     MUL           r14, r6, r11
-	     MOV           r5, r12, ASR #15
-	     MOV           r6, r14, ASR #15
-	     LDR           r9,  [r13, #44]                   
-	     LDR           r12, [r13, #48]
-             LDRSH         r10, [r7], #2                      @*p0++
-	     LDRSH         r11, [r8]                          @*p3++
-             ADD           r9, r9, r4, LSL #1
-	     ADD           r12, r12, r4, LSL #1
-	     ADD           r5, r5, r10
-	     ADD           r6, r6, r11
-	     STRH          r5, [r9]
-	     STRH          r6, [r12]
-	     ADD           r4, r4, #1                         @i+1
-	     ADD           r2, r2, #4                         @pos += STEP
-	     CMP           r4, #16
-	     
-	     BLT           LOOPi
-         
-the_end:
-             LDMFD         r13!, {r4 - r12, r15}
-             
-	     .END	 
-        
-	
-	  
-
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@static void cor_h_vec_012(
+@		Word16 h[],                           /* (i) scaled impulse response                 */
+@		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
+@		Word16 track,                         /* (i) track to use                            */
+@		Word16 sign[],                        /* (i) sign vector                             */
+@		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
+@		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
+@		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
+@)
+@r0 ---- h[]
+@r1 ---- vec[]
+@r2 ---- track
+@r3 ---- sign[]
+@r4 ---- rrixix[][NB_POS]
+@r5 ---- cor_1[]
+@r6 ---- cor_2[]
+
+              .section .text
+	      .global  cor_h_vec_012_asm
+
+cor_h_vec_012_asm:
+
+             STMFD         r13!, {r4 - r12, r14}
+	     LDR           r4, [r13, #40]                    @load rrixix[][NB_POS]
+	     ADD           r7, r4, r2, LSL #5                @r7 --- p0 = rrixix[track]
+             MOV           r4, #0                            @i=0
+
+	     @r0 --- h[], r1 --- vec[],  r2 --- pos
+	     @r3 --- sign[], r4 --- i, r7 --- p0
+
+LOOPi:
+             MOV           r5, #0                            @L_sum1 = 0
+	     MOV           r6, #0                            @L_sum2 = 0
+	     ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
+	     MOV           r10, r0                           @p1 = h
+	     RSB           r11, r2, #62                      @j=62-pos
+
+LOOPj1:
+	     LDRSH         r12, [r10], #2
+	     LDRSH         r8,  [r9], #2
+	     LDRSH         r14, [r9]
+	     SUBS          r11, r11, #1
+             MLA           r5, r12, r8, r5
+             MLA           r6, r12, r14, r6
+	     BGE           LOOPj1
+
+	     LDRSH         r12, [r10], #2                     @*p1++
+	     MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
+             MLA           r5, r12, r14, r5
+             MOV           r14, #0x8000
+             MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
+             ADD           r10, r6, r14
+             ADD           r9, r5, r14
+             MOV           r5, r9, ASR #16
+             MOV           r6, r10, ASR #16
+             ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
+             ADD           r8, r7, #32
+             LDRSH         r10, [r9], #2                 	  @sign[pos]
+	     LDRSH         r11, [r9]                          @sign[pos + 1]
+	     MUL           r12, r5, r10
+	     MUL           r14, r6, r11
+	     MOV           r5, r12, ASR #15
+	     MOV           r6, r14, ASR #15
+	     LDR           r9,  [r13, #44]
+	     LDR           r12, [r13, #48]
+             LDRSH         r10, [r7], #2                      @*p0++
+	     LDRSH         r11, [r8]                          @*p3++
+             ADD           r9, r9, r4, LSL #1
+	     ADD           r12, r12, r4, LSL #1
+	     ADD           r5, r5, r10
+	     ADD           r6, r6, r11
+	     STRH          r5, [r9]
+	     STRH          r6, [r12]
+
+             ADD           r2, r2, #4
+
+             MOV           r5, #0                            @L_sum1 = 0
+	     MOV           r6, #0                            @L_sum2 = 0
+	     ADD           r9, r1, r2, LSL #1                @p2 = &vec[pos]
+	     MOV           r10, r0                           @p1 = h
+	     RSB           r11, r2, #62                      @j=62-pos
+	     ADD           r4, r4, #1                        @i++
+
+LOOPj2:
+	     LDRSH         r12, [r10], #2
+	     LDRSH         r8,  [r9], #2
+	     LDRSH         r14, [r9]
+	     SUBS          r11, r11, #1
+             MLA           r5, r12, r8, r5
+             MLA           r6, r12, r14, r6
+	     BGE           LOOPj2
+
+	     LDRSH         r12, [r10], #2                     @*p1++
+	     MOV           r6, r6, LSL #2                     @L_sum2 = (L_sum2 << 2)
+             MLA           r5, r12, r14, r5
+             MOV           r14, #0x8000
+             MOV           r5, r5, LSL #2                     @L_sum1 = (L_sum1 << 2)
+             ADD           r10, r6, r14
+             ADD           r9, r5, r14
+
+             MOV           r5, r9, ASR #16
+             MOV           r6, r10, ASR #16
+             ADD           r9, r3, r2, LSL #1                 @address of sign[pos]
+             ADD           r8, r7, #32
+             LDRSH         r10, [r9], #2                 	  @sign[pos]
+	     LDRSH         r11, [r9]                          @sign[pos + 1]
+	     MUL           r12, r5, r10
+	     MUL           r14, r6, r11
+	     MOV           r5, r12, ASR #15
+	     MOV           r6, r14, ASR #15
+	     LDR           r9,  [r13, #44]
+	     LDR           r12, [r13, #48]
+             LDRSH         r10, [r7], #2                      @*p0++
+	     LDRSH         r11, [r8]                          @*p3++
+             ADD           r9, r9, r4, LSL #1
+	     ADD           r12, r12, r4, LSL #1
+	     ADD           r5, r5, r10
+	     ADD           r6, r6, r11
+	     STRH          r5, [r9]
+	     STRH          r6, [r12]
+	     ADD           r4, r4, #1                         @i+1
+	     ADD           r2, r2, #4                         @pos += STEP
+	     CMP           r4, #16
+
+	     BLT           LOOPi
+
+the_end:
+             LDMFD         r13!, {r4 - r12, r15}
+
+	     .END
+
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/pred_lt4_1_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/pred_lt4_1_neon.s
index 3b8853f..6b782cb 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/pred_lt4_1_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/pred_lt4_1_neon.s
@@ -1,100 +1,100 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@void Pred_lt4(
-@     Word16 exc[],                         /* in/out: excitation buffer */
-@     Word16 T0,                            /* input : integer pitch lag */
-@     Word16 frac,                          /* input : fraction of lag   */
-@     Word16 L_subfr                        /* input : subframe size     */
-@)
-@***********************************************************************
-@ r0    ---  exc[]
-@ r1    ---  T0
-@ r2    ---  frac
-@ r3    ---  L_subfr
- 
-          .section  .text 
-          .global   pred_lt4_asm
-          .extern   inter4_2
-
-pred_lt4_asm:
-
-          STMFD   	r13!, {r4 - r12, r14} 
-          SUB           r4, r0, r1, LSL #1                        @ x = exc - T0
-          RSB           r2, r2, #0                                @ frac = - frac
-          SUB           r4, r4, #30                               @ x -= L_INTERPOL2 - 1
-          CMP           r2, #0
-          ADDLT         r2, r2, #4                                @ frac += UP_SAMP
-          SUBLT         r4, r4, #2                                @ x--
-
-          LDR           r11, Lable1
-          RSB           r2, r2, #3                                @ k = UP_SAMP - 1 - frac
-          MOV           r8, #0                                    @ j = 0
-	  ADD           r11, r11, r2, LSL #6                      @ get inter4_2[k][]
-
-	  VLD1.S16      {Q0, Q1}, [r11]!
-	  VLD1.S16      {Q2, Q3}, [r11]!
-          
-	  MOV           r6, #0x8000 
-
-          VLD1.S16      {Q4, Q5}, [r4]!                           @load 16 x[]
-          VLD1.S16      {Q6, Q7}, [r4]!                           @load 16 x[]
-
-LOOP:
-          VQDMULL.S16   Q15, D8, D0
-          VQDMLAL.S16   Q15, D9, D1
-          VQDMLAL.S16   Q15, D10, D2
-          VQDMLAL.S16   Q15, D11, D3
-        
-          VQDMLAL.S16   Q15, D12, D4
-          VQDMLAL.S16   Q15, D13, D5
-          VQDMLAL.S16   Q15, D14, D6
-          VQDMLAL.S16   Q15, D15, D7
-
-          LDRSH         r12, [r4], #2                
-          
-          VEXT.S16      D8, D8, D9, #1
-          VEXT.S16      D9, D9, D10, #1
-          VEXT.S16      D10, D10, D11, #1
-          VEXT.S16      D11, D11, D12, #1
-          VDUP.S16      D24, r12
-          VEXT.S16      D12, D12, D13, #1
-          VEXT.S16      D13, D13, D14, #1
-     
-          VQADD.S32     D30, D30, D31
-	  MOV           r11, #0x8000          
-          VPADD.S32     D30, D30, D30
-          ADD           r8, r8, #1
-          VMOV.S32      r12, D30[0]
-          VEXT.S16      D14, D14, D15, #1          
-
-          QADD          r1, r12, r12                              @ L_sum = (L_sum << 2)
-          VEXT.S16      D15, D15, D24, #1
-          QADD          r5, r1, r6                         
-          MOV           r1, r5, ASR #16
-          CMP           r8, r3
-          STRH          r1, [r0], #2                              @ exc[j] = (L_sum + 0x8000) >> 16
-          BLT           LOOP
-                    
-pred_lt4_end:
-		     
-          LDMFD   	r13!, {r4 - r12, r15} 
- 
-Lable1:
-          .word   	inter4_2
-          @ENDFUNC
-          .END
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@void Pred_lt4(
+@     Word16 exc[],                         /* in/out: excitation buffer */
+@     Word16 T0,                            /* input : integer pitch lag */
+@     Word16 frac,                          /* input : fraction of lag   */
+@     Word16 L_subfr                        /* input : subframe size     */
+@)
+@***********************************************************************
+@ r0    ---  exc[]
+@ r1    ---  T0
+@ r2    ---  frac
+@ r3    ---  L_subfr
+
+          .section  .text
+          .global   pred_lt4_asm
+          .extern   inter4_2
+
+pred_lt4_asm:
+
+          STMFD   	r13!, {r4 - r12, r14}
+          SUB           r4, r0, r1, LSL #1                        @ x = exc - T0
+          RSB           r2, r2, #0                                @ frac = - frac
+          SUB           r4, r4, #30                               @ x -= L_INTERPOL2 - 1
+          CMP           r2, #0
+          ADDLT         r2, r2, #4                                @ frac += UP_SAMP
+          SUBLT         r4, r4, #2                                @ x--
+
+          LDR           r11, Lable1
+          RSB           r2, r2, #3                                @ k = UP_SAMP - 1 - frac
+          MOV           r8, #0                                    @ j = 0
+	  ADD           r11, r11, r2, LSL #6                      @ get inter4_2[k][]
+
+	  VLD1.S16      {Q0, Q1}, [r11]!
+	  VLD1.S16      {Q2, Q3}, [r11]!
+
+	  MOV           r6, #0x8000
+
+          VLD1.S16      {Q4, Q5}, [r4]!                           @load 16 x[]
+          VLD1.S16      {Q6, Q7}, [r4]!                           @load 16 x[]
+
+LOOP:
+          VQDMULL.S16   Q15, D8, D0
+          VQDMLAL.S16   Q15, D9, D1
+          VQDMLAL.S16   Q15, D10, D2
+          VQDMLAL.S16   Q15, D11, D3
+
+          VQDMLAL.S16   Q15, D12, D4
+          VQDMLAL.S16   Q15, D13, D5
+          VQDMLAL.S16   Q15, D14, D6
+          VQDMLAL.S16   Q15, D15, D7
+
+          LDRSH         r12, [r4], #2
+
+          VEXT.S16      D8, D8, D9, #1
+          VEXT.S16      D9, D9, D10, #1
+          VEXT.S16      D10, D10, D11, #1
+          VEXT.S16      D11, D11, D12, #1
+          VDUP.S16      D24, r12
+          VEXT.S16      D12, D12, D13, #1
+          VEXT.S16      D13, D13, D14, #1
+
+          VQADD.S32     D30, D30, D31
+	  MOV           r11, #0x8000
+          VPADD.S32     D30, D30, D30
+          ADD           r8, r8, #1
+          VMOV.S32      r12, D30[0]
+          VEXT.S16      D14, D14, D15, #1
+
+          QADD          r1, r12, r12                              @ L_sum = (L_sum << 2)
+          VEXT.S16      D15, D15, D24, #1
+          QADD          r5, r1, r6
+          MOV           r1, r5, ASR #16
+          CMP           r8, r3
+          STRH          r1, [r0], #2                              @ exc[j] = (L_sum + 0x8000) >> 16
+          BLT           LOOP
+
+pred_lt4_end:
+
+          LDMFD   	r13!, {r4 - r12, r15}
+
+Lable1:
+          .word   	inter4_2
+          @ENDFUNC
+          .END
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/residu_asm_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/residu_asm_neon.s
index b9e6b23..394fa83 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/residu_asm_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/residu_asm_neon.s
@@ -26,17 +26,17 @@
 @lg         RN     r3
 
 	.section   .text
-        .global    Residu_opt 
+        .global    Residu_opt
 
 Residu_opt:
 
-        STMFD          r13!, {r4 - r12, r14} 
+        STMFD          r13!, {r4 - r12, r14}
         SUB            r7, r3, #4                       @i = lg - 4
-        
-        VLD1.S16       {D0, D1, D2, D3}, [r0]!              @get all a[]  
+
+        VLD1.S16       {D0, D1, D2, D3}, [r0]!              @get all a[]
 	VLD1.S16       {D4}, [r0]!
         VMOV.S32       Q8,  #0x8000
-        
+
 LOOP1:
         ADD            r9, r1, r7, LSL #1               @copy the address
         ADD            r10, r2, r7, LSL #1
@@ -45,7 +45,7 @@ LOOP1:
         VQDMULL.S16    Q10, D5, D0[0]                  @finish the first L_mult
 
         SUB            r8, r9, #2                       @get the x[i-1] address
-        VLD1.S16       D5, [r8]! 
+        VLD1.S16       D5, [r8]!
         VQDMLAL.S16    Q10, D5, D0[1]
 
         SUB            r8, r9, #4                       @load the x[i-2] address
@@ -53,36 +53,36 @@ LOOP1:
         VQDMLAL.S16    Q10, D5, D0[2]
 
         SUB            r8, r9, #6                       @load the x[i-3] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D0[3]                    
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D0[3]
 
         SUB            r8, r9, #8                       @load the x[i-4] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D1[0]  
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D1[0]
 
         SUB            r8, r9, #10                      @load the x[i-5] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D1[1] 
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D1[1]
 
         SUB            r8, r9, #12                      @load the x[i-6] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D1[2]  
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D1[2]
 
         SUB            r8, r9, #14                      @load the x[i-7] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D1[3]  
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D1[3]
 
         SUB            r8, r9, #16                      @load the x[i-8] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D2[0]  
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D2[0]
 
         SUB            r8, r9, #18                      @load the x[i-9] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D2[1]         
-           
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D2[1]
+
         SUB            r8, r9, #20                      @load the x[i-10] address
-        VLD1.S16       D5, [r8]!     
-        VQDMLAL.S16    Q10, D5, D2[2]  
+        VLD1.S16       D5, [r8]!
+        VQDMLAL.S16    Q10, D5, D2[2]
 
 	SUB            r8, r9, #22                      @load the x[i-11] address
 	VLD1.S16       D5, [r8]!
@@ -117,10 +117,10 @@ LOOP1:
 
         BGE            LOOP1
 
-Residu_asm_end: 
- 
+Residu_asm_end:
+
         LDMFD      r13!, {r4 - r12, r15}
-    
+
         @ENDFUNC
         .END
 
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/scale_sig_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/scale_sig_neon.s
index 14957d8..e45daac 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/scale_sig_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/scale_sig_neon.s
@@ -1,138 +1,138 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@                   
-@**********************************************************************/
-@void Scale_sig(
-@               Word16 x[],                           /* (i/o) : signal to scale               */
-@               Word16 lg,                            /* (i)   : size of x[]                   */
-@               Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
-@)
-@***********************************************************************
-@  x[]   ---  r0
-@  lg    ---  r1
-@  exp   ---  r2
-
-          .section  .text 
-          .global   Scale_sig_opt
-
-Scale_sig_opt:
-
-          STMFD   	r13!, {r4 - r12, r14} 
-          MOV           r4, #4
-          VMOV.S32      Q15, #0x8000       
-          VDUP.S32      Q14, r2  
-          MOV           r5, r0                          @ copy x[] address    
-          CMP           r1, #64
-          MOVEQ         r4, #1
-          BEQ           LOOP
-	  CMP           r1, #128
-	  MOVEQ         r4, #2
-	  BEQ           LOOP
-          CMP           r1, #256
-          BEQ           LOOP
-	  CMP           r1, #80
-	  MOVEQ         r4, #1
-	  BEQ           LOOP1
-
-LOOP1:
-          VLD1.S16      {Q0, Q1}, [r5]!                 @load 16 Word16 x[]     
-          VSHLL.S16     Q10, D0, #16
-          VSHLL.S16     Q11, D1, #16
-          VSHLL.S16     Q12, D2, #16
-          VSHLL.S16     Q13, D3, #16
-          VSHL.S32      Q10, Q10, Q14
-          VSHL.S32      Q11, Q11, Q14
-          VSHL.S32      Q12, Q12, Q14
-          VSHL.S32      Q13, Q13, Q14
-          VADDHN.S32    D16, Q10, Q15
-          VADDHN.S32    D17, Q11, Q15
-          VADDHN.S32    D18, Q12, Q15
-          VADDHN.S32    D19, Q13, Q15
-          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
-
-LOOP:                
-          VLD1.S16      {Q0, Q1}, [r5]!                 @load 16 Word16 x[]
-          VLD1.S16      {Q2, Q3}, [r5]!                 @load 16 Word16 x[]
-          VLD1.S16      {Q4, Q5}, [r5]!                 @load 16 Word16 x[]
-          VLD1.S16      {Q6, Q7}, [r5]!                 @load 16 Word16 x[]
-
-          VSHLL.S16     Q8, D0, #16
-          VSHLL.S16     Q9, D1, #16
-          VSHLL.S16     Q10, D2, #16
-          VSHLL.S16     Q11, D3, #16     
-          VSHL.S32      Q8, Q8, Q14
-          VSHL.S32      Q9, Q9, Q14
-          VSHL.S32      Q10, Q10, Q14
-          VSHL.S32      Q11, Q11, Q14
-          VADDHN.S32    D16, Q8, Q15
-          VADDHN.S32    D17, Q9, Q15
-          VADDHN.S32    D18, Q10, Q15
-          VADDHN.S32    D19, Q11, Q15
-          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
-
-   
-          VSHLL.S16     Q12, D4, #16
-          VSHLL.S16     Q13, D5, #16
-          VSHLL.S16     Q10, D6, #16
-          VSHLL.S16     Q11, D7, #16
-          VSHL.S32      Q12, Q12, Q14
-          VSHL.S32      Q13, Q13, Q14
-          VSHL.S32      Q10, Q10, Q14
-          VSHL.S32      Q11, Q11, Q14
-          VADDHN.S32    D16, Q12, Q15
-          VADDHN.S32    D17, Q13, Q15
-          VADDHN.S32    D18, Q10, Q15
-          VADDHN.S32    D19, Q11, Q15
-          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
-
-          VSHLL.S16     Q10, D8, #16
-          VSHLL.S16     Q11, D9, #16
-          VSHLL.S16     Q12, D10, #16
-          VSHLL.S16     Q13, D11, #16
-          VSHL.S32      Q10, Q10, Q14
-          VSHL.S32      Q11, Q11, Q14
-          VSHL.S32      Q12, Q12, Q14
-          VSHL.S32      Q13, Q13, Q14
-          VADDHN.S32    D16, Q10, Q15
-          VADDHN.S32    D17, Q11, Q15
-          VADDHN.S32    D18, Q12, Q15
-          VADDHN.S32    D19, Q13, Q15
-          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
-
-          VSHLL.S16     Q10, D12, #16   
-          VSHLL.S16     Q11, D13, #16
-          VSHLL.S16     Q12, D14, #16
-          VSHLL.S16     Q13, D15, #16
-          VSHL.S32      Q10, Q10, Q14
-          VSHL.S32      Q11, Q11, Q14
-          VSHL.S32      Q12, Q12, Q14
-          VSHL.S32      Q13, Q13, Q14
-          VADDHN.S32    D16, Q10, Q15
-          VADDHN.S32    D17, Q11, Q15
-          VADDHN.S32    D18, Q12, Q15
-          VADDHN.S32    D19, Q13, Q15 
-          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]  
-          SUBS          r4, r4, #1
-          BGT           LOOP     
-                
-                          
-Scale_sig_asm_end:
-
-          LDMFD   	r13!, {r4 - r12, r15} 
-          @ENDFUNC
-          .END
- 
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@**********************************************************************/
+@void Scale_sig(
+@               Word16 x[],                           /* (i/o) : signal to scale               */
+@               Word16 lg,                            /* (i)   : size of x[]                   */
+@               Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
+@)
+@***********************************************************************
+@  x[]   ---  r0
+@  lg    ---  r1
+@  exp   ---  r2
+
+          .section  .text
+          .global   Scale_sig_opt
+
+Scale_sig_opt:
+
+          STMFD   	r13!, {r4 - r12, r14}
+          MOV           r4, #4
+          VMOV.S32      Q15, #0x8000
+          VDUP.S32      Q14, r2
+          MOV           r5, r0                          @ copy x[] address
+          CMP           r1, #64
+          MOVEQ         r4, #1
+          BEQ           LOOP
+	  CMP           r1, #128
+	  MOVEQ         r4, #2
+	  BEQ           LOOP
+          CMP           r1, #256
+          BEQ           LOOP
+	  CMP           r1, #80
+	  MOVEQ         r4, #1
+	  BEQ           LOOP1
+
+LOOP1:
+          VLD1.S16      {Q0, Q1}, [r5]!                 @load 16 Word16 x[]
+          VSHLL.S16     Q10, D0, #16
+          VSHLL.S16     Q11, D1, #16
+          VSHLL.S16     Q12, D2, #16
+          VSHLL.S16     Q13, D3, #16
+          VSHL.S32      Q10, Q10, Q14
+          VSHL.S32      Q11, Q11, Q14
+          VSHL.S32      Q12, Q12, Q14
+          VSHL.S32      Q13, Q13, Q14
+          VADDHN.S32    D16, Q10, Q15
+          VADDHN.S32    D17, Q11, Q15
+          VADDHN.S32    D18, Q12, Q15
+          VADDHN.S32    D19, Q13, Q15
+          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
+
+LOOP:
+          VLD1.S16      {Q0, Q1}, [r5]!                 @load 16 Word16 x[]
+          VLD1.S16      {Q2, Q3}, [r5]!                 @load 16 Word16 x[]
+          VLD1.S16      {Q4, Q5}, [r5]!                 @load 16 Word16 x[]
+          VLD1.S16      {Q6, Q7}, [r5]!                 @load 16 Word16 x[]
+
+          VSHLL.S16     Q8, D0, #16
+          VSHLL.S16     Q9, D1, #16
+          VSHLL.S16     Q10, D2, #16
+          VSHLL.S16     Q11, D3, #16
+          VSHL.S32      Q8, Q8, Q14
+          VSHL.S32      Q9, Q9, Q14
+          VSHL.S32      Q10, Q10, Q14
+          VSHL.S32      Q11, Q11, Q14
+          VADDHN.S32    D16, Q8, Q15
+          VADDHN.S32    D17, Q9, Q15
+          VADDHN.S32    D18, Q10, Q15
+          VADDHN.S32    D19, Q11, Q15
+          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
+
+
+          VSHLL.S16     Q12, D4, #16
+          VSHLL.S16     Q13, D5, #16
+          VSHLL.S16     Q10, D6, #16
+          VSHLL.S16     Q11, D7, #16
+          VSHL.S32      Q12, Q12, Q14
+          VSHL.S32      Q13, Q13, Q14
+          VSHL.S32      Q10, Q10, Q14
+          VSHL.S32      Q11, Q11, Q14
+          VADDHN.S32    D16, Q12, Q15
+          VADDHN.S32    D17, Q13, Q15
+          VADDHN.S32    D18, Q10, Q15
+          VADDHN.S32    D19, Q11, Q15
+          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
+
+          VSHLL.S16     Q10, D8, #16
+          VSHLL.S16     Q11, D9, #16
+          VSHLL.S16     Q12, D10, #16
+          VSHLL.S16     Q13, D11, #16
+          VSHL.S32      Q10, Q10, Q14
+          VSHL.S32      Q11, Q11, Q14
+          VSHL.S32      Q12, Q12, Q14
+          VSHL.S32      Q13, Q13, Q14
+          VADDHN.S32    D16, Q10, Q15
+          VADDHN.S32    D17, Q11, Q15
+          VADDHN.S32    D18, Q12, Q15
+          VADDHN.S32    D19, Q13, Q15
+          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
+
+          VSHLL.S16     Q10, D12, #16
+          VSHLL.S16     Q11, D13, #16
+          VSHLL.S16     Q12, D14, #16
+          VSHLL.S16     Q13, D15, #16
+          VSHL.S32      Q10, Q10, Q14
+          VSHL.S32      Q11, Q11, Q14
+          VSHL.S32      Q12, Q12, Q14
+          VSHL.S32      Q13, Q13, Q14
+          VADDHN.S32    D16, Q10, Q15
+          VADDHN.S32    D17, Q11, Q15
+          VADDHN.S32    D18, Q12, Q15
+          VADDHN.S32    D19, Q13, Q15
+          VST1.S16      {Q8, Q9}, [r0]!                 @store 16 Word16 x[]
+          SUBS          r4, r4, #1
+          BGT           LOOP
+
+
+Scale_sig_asm_end:
+
+          LDMFD   	r13!, {r4 - r12, r15}
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/syn_filt_neon.s b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/syn_filt_neon.s
index dc3d4a8..5731bdb 100644
--- a/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/syn_filt_neon.s
+++ b/media/libstagefright/codecs/amrwbenc/src/asm/ARMV7/syn_filt_neon.s
@@ -1,106 +1,106 @@
-@/*
-@ ** Copyright 2003-2010, VisualOn, Inc.
-@ **
-@ ** Licensed under the Apache License, Version 2.0 (the "License");
-@ ** you may not use this file except in compliance with the License.
-@ ** You may obtain a copy of the License at
-@ **
-@ **     http://www.apache.org/licenses/LICENSE-2.0
-@ **
-@ ** Unless required by applicable law or agreed to in writing, software
-@ ** distributed under the License is distributed on an "AS IS" BASIS,
-@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-@ ** See the License for the specific language governing permissions and
-@ ** limitations under the License.
-@ */
-@
-@void Syn_filt(
-@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
-@     Word16 x[],                           /* (i)     : input signal                             */
-@     Word16 y[],                           /* (o)     : output signal                            */
-@     Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
-@)
-@***********************************************************************
-@ a[]    ---   r0
-@ x[]    ---   r1
-@ y[]    ---   r2
-@ mem[]  ---   r3
-@ m ---  16  lg --- 80  update --- 1
-
-          .section  .text 
-          .global   Syn_filt_asm
-
-Syn_filt_asm:
-
-          STMFD   	r13!, {r4 - r12, r14} 
-          SUB           r13, r13, #700                   @ y_buf[L_FRAME16k + M16k]
-   
-          MOV           r4, r3                           @ copy mem[] address
-          MOV           r5, r13                          @ copy yy = y_buf address
-
-          @ for(i = 0@ i < m@ i++)
-          @{
-          @    *yy++ = mem[i]@
-          @} 
-          VLD1.S16      {D0, D1, D2, D3}, [r4]!          @load 16 mems
-	  VST1.S16      {D0, D1, D2, D3}, [r5]!          @store 16 mem[] to *yy
-
-          LDRSH         r5, [r0], #2                     @ load a[0]
-          MOV           r8, #0                           @ i = 0
-          MOV           r5, r5, ASR #1                   @ a0 = a[0] >> 1
-          VMOV.S16      D8[0], r5
-          @ load all a[]
-          VLD1.S16      {D0, D1, D2, D3}, [r0]!          @ load a[1] ~ a[16]
-	  VREV64.16     D0, D0
-	  VREV64.16     D1, D1
-	  VREV64.16     D2, D2
-	  VREV64.16     D3, D3 
-	  MOV           r8, #0                           @ loop times
-	  MOV           r10, r13                         @ temp = y_buf
-	  ADD           r4, r13, #32                     @ yy[i] address
-
-          VLD1.S16      {D4, D5, D6, D7}, [r10]!         @ first 16 temp_p
-
-SYN_LOOP:
-
-          LDRSH         r6, [r1], #2                     @ load x[i]
-	  MUL           r12, r6, r5                      @ L_tmp = x[i] * a0
-	  ADD           r10, r4, r8, LSL #1              @ y[i], yy[i] address
-
-	  VDUP.S32      Q10, r12
-	  VMULL.S16     Q5, D3, D4                    
-          VMLAL.S16     Q5, D2, D5
-          VMLAL.S16     Q5, D1, D6
-          VMLAL.S16     Q5, D0, D7
-          VEXT.8        D4, D4, D5, #2
-          VEXT.8        D5, D5, D6, #2
-          VEXT.8        D6, D6, D7, #2
-          VPADD.S32     D12, D10, D11
-          ADD           r8, r8, #1
-          VPADD.S32     D10, D12, D12
-
-	  VDUP.S32      Q7, D10[0]
-
-	  VSUB.S32      Q9, Q10, Q7
-          VQRSHRN.S32   D20, Q9, #12   
-          VMOV.S16      r9, D20[0]
-          VEXT.8        D7, D7, D20, #2
-          CMP           r8, #80
-          STRH          r9, [r10]                        @ yy[i]
-          STRH          r9, [r2], #2                     @ y[i]          	         
-	  
-          BLT           SYN_LOOP
- 
-          @ update mem[]
-          ADD           r5, r13, #160                    @ yy[64] address
-	  VLD1.S16      {D0, D1, D2, D3}, [r5]!
-	  VST1.S16      {D0, D1, D2, D3}, [r3]!              
-
-Syn_filt_asm_end:
- 
-          ADD           r13, r13, #700		     
-          LDMFD   	r13!, {r4 - r12, r15} 
-          @ENDFUNC
-          .END
- 
-
+@/*
+@ ** Copyright 2003-2010, VisualOn, Inc.
+@ **
+@ ** Licensed under the Apache License, Version 2.0 (the "License");
+@ ** you may not use this file except in compliance with the License.
+@ ** You may obtain a copy of the License at
+@ **
+@ **     http://www.apache.org/licenses/LICENSE-2.0
+@ **
+@ ** Unless required by applicable law or agreed to in writing, software
+@ ** distributed under the License is distributed on an "AS IS" BASIS,
+@ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+@ ** See the License for the specific language governing permissions and
+@ ** limitations under the License.
+@ */
+@
+@void Syn_filt(
+@     Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
+@     Word16 x[],                           /* (i)     : input signal                             */
+@     Word16 y[],                           /* (o)     : output signal                            */
+@     Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
+@)
+@***********************************************************************
+@ a[]    ---   r0
+@ x[]    ---   r1
+@ y[]    ---   r2
+@ mem[]  ---   r3
+@ m ---  16  lg --- 80  update --- 1
+
+          .section  .text
+          .global   Syn_filt_asm
+
+Syn_filt_asm:
+
+          STMFD   	r13!, {r4 - r12, r14}
+          SUB           r13, r13, #700                   @ y_buf[L_FRAME16k + M16k]
+
+          MOV           r4, r3                           @ copy mem[] address
+          MOV           r5, r13                          @ copy yy = y_buf address
+
+          @ for(i = 0@ i < m@ i++)
+          @{
+          @    *yy++ = mem[i]@
+          @}
+          VLD1.S16      {D0, D1, D2, D3}, [r4]!          @load 16 mems
+	  VST1.S16      {D0, D1, D2, D3}, [r5]!          @store 16 mem[] to *yy
+
+          LDRSH         r5, [r0], #2                     @ load a[0]
+          MOV           r8, #0                           @ i = 0
+          MOV           r5, r5, ASR #1                   @ a0 = a[0] >> 1
+          VMOV.S16      D8[0], r5
+          @ load all a[]
+          VLD1.S16      {D0, D1, D2, D3}, [r0]!          @ load a[1] ~ a[16]
+	  VREV64.16     D0, D0
+	  VREV64.16     D1, D1
+	  VREV64.16     D2, D2
+	  VREV64.16     D3, D3
+	  MOV           r8, #0                           @ loop times
+	  MOV           r10, r13                         @ temp = y_buf
+	  ADD           r4, r13, #32                     @ yy[i] address
+
+          VLD1.S16      {D4, D5, D6, D7}, [r10]!         @ first 16 temp_p
+
+SYN_LOOP:
+
+          LDRSH         r6, [r1], #2                     @ load x[i]
+	  MUL           r12, r6, r5                      @ L_tmp = x[i] * a0
+	  ADD           r10, r4, r8, LSL #1              @ y[i], yy[i] address
+
+	  VDUP.S32      Q10, r12
+	  VMULL.S16     Q5, D3, D4
+          VMLAL.S16     Q5, D2, D5
+          VMLAL.S16     Q5, D1, D6
+          VMLAL.S16     Q5, D0, D7
+          VEXT.8        D4, D4, D5, #2
+          VEXT.8        D5, D5, D6, #2
+          VEXT.8        D6, D6, D7, #2
+          VPADD.S32     D12, D10, D11
+          ADD           r8, r8, #1
+          VPADD.S32     D10, D12, D12
+
+	  VDUP.S32      Q7, D10[0]
+
+	  VSUB.S32      Q9, Q10, Q7
+          VQRSHRN.S32   D20, Q9, #12
+          VMOV.S16      r9, D20[0]
+          VEXT.8        D7, D7, D20, #2
+          CMP           r8, #80
+          STRH          r9, [r10]                        @ yy[i]
+          STRH          r9, [r2], #2                     @ y[i]
+
+          BLT           SYN_LOOP
+
+          @ update mem[]
+          ADD           r5, r13, #160                    @ yy[64] address
+	  VLD1.S16      {D0, D1, D2, D3}, [r5]!
+	  VST1.S16      {D0, D1, D2, D3}, [r3]!
+
+Syn_filt_asm_end:
+
+          ADD           r13, r13, #700
+          LDMFD   	r13!, {r4 - r12, r15}
+          @ENDFUNC
+          .END
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/autocorr.c b/media/libstagefright/codecs/amrwbenc/src/autocorr.c
index 33ed670..8c477ca 100644
--- a/media/libstagefright/codecs/amrwbenc/src/autocorr.c
+++ b/media/libstagefright/codecs/amrwbenc/src/autocorr.c
@@ -1,127 +1,127 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-
-/***********************************************************************
-*       File: autocorr.c                                               *
-*                                                                      *
-*       Description:Compute autocorrelations of signal with windowing  *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "acelp.h"
-#include "ham_wind.tab"
-
-void Autocorr(
-		Word16 x[],                           /* (i)    : Input signal                      */
-		Word16 m,                             /* (i)    : LPC order                         */
-		Word16 r_h[],                         /* (o) Q15: Autocorrelations  (msb)           */
-		Word16 r_l[]                          /* (o)    : Autocorrelations  (lsb)           */
-	     )
-{
-	Word32 i, norm, shift;
-	Word16 y[L_WINDOW];
-	Word32 L_sum, L_sum1, L_tmp, F_LEN;
-	Word16 *p1,*p2,*p3;
-	const Word16 *p4;
-	/* Windowing of signal */
-	p1 = x;
-	p4 = vo_window;
-	p3 = y;
-
-	for (i = 0; i < L_WINDOW; i+=4)
-	{
-		*p3++ = vo_mult_r((*p1++), (*p4++));
-		*p3++ = vo_mult_r((*p1++), (*p4++));
-		*p3++ = vo_mult_r((*p1++), (*p4++));
-		*p3++ = vo_mult_r((*p1++), (*p4++));
-	}
-
-	/* calculate energy of signal */
-	L_sum = vo_L_deposit_h(16);               /* sqrt(256), avoid overflow after rounding */
-	for (i = 0; i < L_WINDOW; i++)
-	{
-		L_tmp = vo_L_mult(y[i], y[i]);
-		L_tmp = (L_tmp >> 8);
-		L_sum += L_tmp;
-	}
-
-	/* scale signal to avoid overflow in autocorrelation */
-	norm = norm_l(L_sum);
-	shift = 4 - (norm >> 1);
-	if(shift > 0)
-	{
-		p1 = y;
-		for (i = 0; i < L_WINDOW; i+=4)
-		{
-			*p1 = vo_shr_r(*p1, shift); 
-			p1++;
-			*p1 = vo_shr_r(*p1, shift); 
-			p1++;
-			*p1 = vo_shr_r(*p1, shift);
-			p1++;
-			*p1 = vo_shr_r(*p1, shift); 
-			p1++;
-		}
-	}
-
-	/* Compute and normalize r[0] */
-	L_sum = 1; 
-	for (i = 0; i < L_WINDOW; i+=4)
-	{
-		L_sum += vo_L_mult(y[i], y[i]);
-		L_sum += vo_L_mult(y[i+1], y[i+1]);
-		L_sum += vo_L_mult(y[i+2], y[i+2]);
-		L_sum += vo_L_mult(y[i+3], y[i+3]);
-	}
-
-	norm = norm_l(L_sum);
-	L_sum = (L_sum << norm);
-
-	r_h[0] = L_sum >> 16;
-	r_l[0] = (L_sum & 0xffff)>>1;
-
-	/* Compute r[1] to r[m] */
-	for (i = 1; i <= 8; i++)
-	{
-		L_sum1 = 0;
-		L_sum = 0;
-		F_LEN = (Word32)(L_WINDOW - 2*i);
-		p1 = y;
-		p2 = y + (2*i)-1;
-		do{
-			L_sum1 += *p1 * *p2++;
-			L_sum += *p1++ * *p2;
-		}while(--F_LEN!=0);
-
-		L_sum1 += *p1 * *p2++;
-
-		L_sum1 = L_sum1<<norm;
-		L_sum = L_sum<<norm;
-
-		r_h[(2*i)-1] = L_sum1 >> 15;
-		r_l[(2*i)-1] = L_sum1 & 0x00007fff;
-		r_h[(2*i)] = L_sum >> 15;
-		r_l[(2*i)] = L_sum & 0x00007fff;
-	}
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+
+/***********************************************************************
+*       File: autocorr.c                                               *
+*                                                                      *
+*       Description:Compute autocorrelations of signal with windowing  *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "acelp.h"
+#include "ham_wind.tab"
+
+void Autocorr(
+		Word16 x[],                           /* (i)    : Input signal                      */
+		Word16 m,                             /* (i)    : LPC order                         */
+		Word16 r_h[],                         /* (o) Q15: Autocorrelations  (msb)           */
+		Word16 r_l[]                          /* (o)    : Autocorrelations  (lsb)           */
+	     )
+{
+	Word32 i, norm, shift;
+	Word16 y[L_WINDOW];
+	Word32 L_sum, L_sum1, L_tmp, F_LEN;
+	Word16 *p1,*p2,*p3;
+	const Word16 *p4;
+	/* Windowing of signal */
+	p1 = x;
+	p4 = vo_window;
+	p3 = y;
+
+	for (i = 0; i < L_WINDOW; i+=4)
+	{
+		*p3++ = vo_mult_r((*p1++), (*p4++));
+		*p3++ = vo_mult_r((*p1++), (*p4++));
+		*p3++ = vo_mult_r((*p1++), (*p4++));
+		*p3++ = vo_mult_r((*p1++), (*p4++));
+	}
+
+	/* calculate energy of signal */
+	L_sum = vo_L_deposit_h(16);               /* sqrt(256), avoid overflow after rounding */
+	for (i = 0; i < L_WINDOW; i++)
+	{
+		L_tmp = vo_L_mult(y[i], y[i]);
+		L_tmp = (L_tmp >> 8);
+		L_sum += L_tmp;
+	}
+
+	/* scale signal to avoid overflow in autocorrelation */
+	norm = norm_l(L_sum);
+	shift = 4 - (norm >> 1);
+	if(shift > 0)
+	{
+		p1 = y;
+		for (i = 0; i < L_WINDOW; i+=4)
+		{
+			*p1 = vo_shr_r(*p1, shift);
+			p1++;
+			*p1 = vo_shr_r(*p1, shift);
+			p1++;
+			*p1 = vo_shr_r(*p1, shift);
+			p1++;
+			*p1 = vo_shr_r(*p1, shift);
+			p1++;
+		}
+	}
+
+	/* Compute and normalize r[0] */
+	L_sum = 1;
+	for (i = 0; i < L_WINDOW; i+=4)
+	{
+		L_sum += vo_L_mult(y[i], y[i]);
+		L_sum += vo_L_mult(y[i+1], y[i+1]);
+		L_sum += vo_L_mult(y[i+2], y[i+2]);
+		L_sum += vo_L_mult(y[i+3], y[i+3]);
+	}
+
+	norm = norm_l(L_sum);
+	L_sum = (L_sum << norm);
+
+	r_h[0] = L_sum >> 16;
+	r_l[0] = (L_sum & 0xffff)>>1;
+
+	/* Compute r[1] to r[m] */
+	for (i = 1; i <= 8; i++)
+	{
+		L_sum1 = 0;
+		L_sum = 0;
+		F_LEN = (Word32)(L_WINDOW - 2*i);
+		p1 = y;
+		p2 = y + (2*i)-1;
+		do{
+			L_sum1 += *p1 * *p2++;
+			L_sum += *p1++ * *p2;
+		}while(--F_LEN!=0);
+
+		L_sum1 += *p1 * *p2++;
+
+		L_sum1 = L_sum1<<norm;
+		L_sum = L_sum<<norm;
+
+		r_h[(2*i)-1] = L_sum1 >> 15;
+		r_l[(2*i)-1] = L_sum1 & 0x00007fff;
+		r_h[(2*i)] = L_sum >> 15;
+		r_l[(2*i)] = L_sum & 0x00007fff;
+	}
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/az_isp.c b/media/libstagefright/codecs/amrwbenc/src/az_isp.c
index 8259f91..43db27a 100644
--- a/media/libstagefright/codecs/amrwbenc/src/az_isp.c
+++ b/media/libstagefright/codecs/amrwbenc/src/az_isp.c
@@ -1,268 +1,268 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*  File: az_isp.c
-*
-*  Description:
-*-----------------------------------------------------------------------*
-* Compute the ISPs from  the LPC coefficients  (order=M)                *
-*-----------------------------------------------------------------------*
-*                                                                       *
-* The ISPs are the roots of the two polynomials F1(z) and F2(z)         *
-* defined as                                                            *
-*               F1(z) = A(z) + z^-m A(z^-1)                             *
-*  and          F2(z) = A(z) - z^-m A(z^-1)                             *
-*                                                                       *
-* For a even order m=2n, F1(z) has M/2 conjugate roots on the unit      *
-* circle and F2(z) has M/2-1 conjugate roots on the unit circle in      *
-* addition to two roots at 0 and pi.                                    *
-*                                                                       *
-* For a 16th order LP analysis, F1(z) and F2(z) can be written as       *
-*                                                                       *
-*   F1(z) = (1 + a[M])   PRODUCT  (1 - 2 cos(w_i) z^-1 + z^-2 )         *
-*                        i=0,2,4,6,8,10,12,14                           *
-*                                                                       *
-*   F2(z) = (1 - a[M]) (1 - z^-2) PRODUCT (1 - 2 cos(w_i) z^-1 + z^-2 ) *
-*                                 i=1,3,5,7,9,11,13                     *
-*                                                                       *
-* The ISPs are the M-1 frequencies w_i, i=0...M-2 plus the last         *
-* predictor coefficient a[M].                                           *
-*-----------------------------------------------------------------------*
-
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "stdio.h"
-#include "grid100.tab"
-
-#define M   16
-#define NC  (M/2)
-
-/* local function */
-static __inline Word16 Chebps2(Word16 x, Word16 f[], Word32 n);
-
-void Az_isp(
-		Word16 a[],                           /* (i) Q12 : predictor coefficients                 */
-		Word16 isp[],                         /* (o) Q15 : Immittance spectral pairs              */
-		Word16 old_isp[]                      /* (i)     : old isp[] (in case not found M roots)  */
-	   )
-{
-	Word32 i, j, nf, ip, order;
-	Word16 xlow, ylow, xhigh, yhigh, xmid, ymid, xint;
-	Word16 x, y, sign, exp;
-	Word16 *coef;
-	Word16 f1[NC + 1], f2[NC];
-	Word32 t0;
-	/*-------------------------------------------------------------*
-	 * find the sum and diff polynomials F1(z) and F2(z)           *
-	 *      F1(z) = [A(z) + z^M A(z^-1)]                           *
-	 *      F2(z) = [A(z) - z^M A(z^-1)]/(1-z^-2)                  *
-	 *                                                             *
-	 * for (i=0; i<NC; i++)                                        *
-	 * {                                                           *
-	 *   f1[i] = a[i] + a[M-i];                                    *
-	 *   f2[i] = a[i] - a[M-i];                                    *
-	 * }                                                           *
-	 * f1[NC] = 2.0*a[NC];                                         *
-	 *                                                             *
-	 * for (i=2; i<NC; i++)            Divide by (1-z^-2)          *
-	 *   f2[i] += f2[i-2];                                         *
-	 *-------------------------------------------------------------*/
-	for (i = 0; i < NC; i++)
-	{
-		t0 = a[i] << 15;
-		f1[i] = vo_round(t0 + (a[M - i] << 15));        /* =(a[i]+a[M-i])/2 */
-		f2[i] = vo_round(t0 - (a[M - i] << 15));        /* =(a[i]-a[M-i])/2 */
-	}
-	f1[NC] = a[NC];                        
-	for (i = 2; i < NC; i++)               /* Divide by (1-z^-2) */
-		f2[i] = add1(f2[i], f2[i - 2]);     
-
-	/*---------------------------------------------------------------------*
-	 * Find the ISPs (roots of F1(z) and F2(z) ) using the                 *
-	 * Chebyshev polynomial evaluation.                                    *
-	 * The roots of F1(z) and F2(z) are alternatively searched.            *
-	 * We start by finding the first root of F1(z) then we switch          *
-	 * to F2(z) then back to F1(z) and so on until all roots are found.    *
-	 *                                                                     *
-	 *  - Evaluate Chebyshev pol. at grid points and check for sign change.*
-	 *  - If sign change track the root by subdividing the interval        *
-	 *    2 times and ckecking sign change.                                *
-	 *---------------------------------------------------------------------*/
-	nf = 0;                                  /* number of found frequencies */
-	ip = 0;                                  /* indicator for f1 or f2      */
-	coef = f1;                             
-	order = NC;                            
-	xlow = vogrid[0];                        
-	ylow = Chebps2(xlow, coef, order);
-	j = 0;
-	while ((nf < M - 1) && (j < GRID_POINTS))
-	{
-		j ++;
-		xhigh = xlow;                     
-		yhigh = ylow;                      
-		xlow = vogrid[j];                    
-		ylow = Chebps2(xlow, coef, order);
-		if ((ylow * yhigh) <= (Word32) 0)
-		{
-			/* divide 2 times the interval */
-			for (i = 0; i < 2; i++)
-			{
-				xmid = (xlow >> 1) + (xhigh >> 1);        /* xmid = (xlow + xhigh)/2 */
-				ymid = Chebps2(xmid, coef, order);
-				if ((ylow * ymid) <= (Word32) 0)
-				{
-					yhigh = ymid;         
-					xhigh = xmid;          
-				} else
-				{
-					ylow = ymid;           
-					xlow = xmid;          
-				}
-			}
-			/*-------------------------------------------------------------*
-			 * Linear interpolation                                        *
-			 *    xint = xlow - ylow*(xhigh-xlow)/(yhigh-ylow);            *
-			 *-------------------------------------------------------------*/
-			x = xhigh - xlow;
-			y = yhigh - ylow;
-			if (y == 0)
-			{
-				xint = xlow;               
-			} else
-			{
-				sign = y;                 
-				y = abs_s(y);
-				exp = norm_s(y);
-				y = y << exp;
-				y = div_s((Word16) 16383, y);
-				t0 = x * y;
-				t0 = (t0 >> (19 - exp));
-				y = vo_extract_l(t0);         /* y= (xhigh-xlow)/(yhigh-ylow) in Q11 */
-				if (sign < 0)
-					y = -y;
-				t0 = ylow * y;      /* result in Q26 */
-				t0 = (t0 >> 10);        /* result in Q15 */
-				xint = vo_sub(xlow, vo_extract_l(t0));        /* xint = xlow - ylow*y */
-			}
-			isp[nf] = xint;                
-			xlow = xint;                   
-			nf++;                          
-			if (ip == 0)
-			{
-				ip = 1;                    
-				coef = f2;                
-				order = NC - 1;           
-			} else
-			{
-				ip = 0;                   
-				coef = f1;                 
-				order = NC;              
-			}
-			ylow = Chebps2(xlow, coef, order);
-		}
-	}
-	/* Check if M-1 roots found */
-	if(nf < M - 1)
-	{
-		for (i = 0; i < M; i++)
-		{
-			isp[i] = old_isp[i];          
-		}
-	} else
-	{
-		isp[M - 1] = a[M] << 3;                      /* From Q12 to Q15 with saturation */
-	}
-	return;
-}
-
-/*--------------------------------------------------------------*
-* function  Chebps2:                                           *
-*           ~~~~~~~                                            *
-*    Evaluates the Chebishev polynomial series                 *
-*--------------------------------------------------------------*
-*                                                              *
-*  The polynomial order is                                     *
-*     n = M/2   (M is the prediction order)                    *
-*  The polynomial is given by                                  *
-*    C(x) = f(0)T_n(x) + f(1)T_n-1(x) + ... +f(n-1)T_1(x) + f(n)/2 *
-* Arguments:                                                   *
-*  x:     input value of evaluation; x = cos(frequency) in Q15 *
-*  f[]:   coefficients of the pol.                      in Q11 *
-*  n:     order of the pol.                                    *
-*                                                              *
-* The value of C(x) is returned. (Satured to +-1.99 in Q14)    *
-*                                                              *
-*--------------------------------------------------------------*/
-
-static __inline Word16 Chebps2(Word16 x, Word16 f[], Word32 n)
-{
-	Word32 i, cheb;
-	Word16 b0_h, b0_l, b1_h, b1_l, b2_h, b2_l;
-	Word32 t0;
-
-	/* Note: All computation are done in Q24. */
-
-	t0 = f[0] << 13;
-	b2_h = t0 >> 16;
-	b2_l = (t0 & 0xffff)>>1;
-
-	t0 = ((b2_h * x)<<1) + (((b2_l * x)>>15)<<1);
-	t0 <<= 1;
-	t0 += (f[1] << 13);						/* + f[1] in Q24        */
-
-	b1_h = t0 >> 16;
-	b1_l = (t0 & 0xffff) >> 1;
-
-	for (i = 2; i < n; i++)
-	{
-		t0 = ((b1_h * x)<<1) + (((b1_l * x)>>15)<<1);
-
-		t0 += (b2_h * (-16384))<<1;
-		t0 += (f[i] << 12);
-		t0 <<= 1;
-		t0 -= (b2_l << 1);					/* t0 = 2.0*x*b1 - b2 + f[i]; */
-
-		b0_h = t0 >> 16;
-		b0_l = (t0 & 0xffff) >> 1;
-
-		b2_l = b1_l;                         /* b2 = b1; */
-		b2_h = b1_h;                       
-		b1_l = b0_l;                         /* b1 = b0; */
-		b1_h = b0_h;                       
-	}
-
-	t0 = ((b1_h * x)<<1) + (((b1_l * x)>>15)<<1);
-	t0 += (b2_h * (-32768))<<1;				/* t0 = x*b1 - b2          */
-	t0 -= (b2_l << 1);
-	t0 += (f[n] << 12);						/* t0 = x*b1 - b2 + f[i]/2 */
-
-	t0 = L_shl2(t0, 6);                     /* Q24 to Q30 with saturation */
-
-	cheb = extract_h(t0);                  /* Result in Q14              */
-
-	if (cheb == -32768)
-	{
-		cheb = -32767;                     /* to avoid saturation in Az_isp */
-	}
-	return (cheb);
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*  File: az_isp.c
+*
+*  Description:
+*-----------------------------------------------------------------------*
+* Compute the ISPs from  the LPC coefficients  (order=M)                *
+*-----------------------------------------------------------------------*
+*                                                                       *
+* The ISPs are the roots of the two polynomials F1(z) and F2(z)         *
+* defined as                                                            *
+*               F1(z) = A(z) + z^-m A(z^-1)                             *
+*  and          F2(z) = A(z) - z^-m A(z^-1)                             *
+*                                                                       *
+* For a even order m=2n, F1(z) has M/2 conjugate roots on the unit      *
+* circle and F2(z) has M/2-1 conjugate roots on the unit circle in      *
+* addition to two roots at 0 and pi.                                    *
+*                                                                       *
+* For a 16th order LP analysis, F1(z) and F2(z) can be written as       *
+*                                                                       *
+*   F1(z) = (1 + a[M])   PRODUCT  (1 - 2 cos(w_i) z^-1 + z^-2 )         *
+*                        i=0,2,4,6,8,10,12,14                           *
+*                                                                       *
+*   F2(z) = (1 - a[M]) (1 - z^-2) PRODUCT (1 - 2 cos(w_i) z^-1 + z^-2 ) *
+*                                 i=1,3,5,7,9,11,13                     *
+*                                                                       *
+* The ISPs are the M-1 frequencies w_i, i=0...M-2 plus the last         *
+* predictor coefficient a[M].                                           *
+*-----------------------------------------------------------------------*
+
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "stdio.h"
+#include "grid100.tab"
+
+#define M   16
+#define NC  (M/2)
+
+/* local function */
+static __inline Word16 Chebps2(Word16 x, Word16 f[], Word32 n);
+
+void Az_isp(
+		Word16 a[],                           /* (i) Q12 : predictor coefficients                 */
+		Word16 isp[],                         /* (o) Q15 : Immittance spectral pairs              */
+		Word16 old_isp[]                      /* (i)     : old isp[] (in case not found M roots)  */
+	   )
+{
+	Word32 i, j, nf, ip, order;
+	Word16 xlow, ylow, xhigh, yhigh, xmid, ymid, xint;
+	Word16 x, y, sign, exp;
+	Word16 *coef;
+	Word16 f1[NC + 1], f2[NC];
+	Word32 t0;
+	/*-------------------------------------------------------------*
+	 * find the sum and diff polynomials F1(z) and F2(z)           *
+	 *      F1(z) = [A(z) + z^M A(z^-1)]                           *
+	 *      F2(z) = [A(z) - z^M A(z^-1)]/(1-z^-2)                  *
+	 *                                                             *
+	 * for (i=0; i<NC; i++)                                        *
+	 * {                                                           *
+	 *   f1[i] = a[i] + a[M-i];                                    *
+	 *   f2[i] = a[i] - a[M-i];                                    *
+	 * }                                                           *
+	 * f1[NC] = 2.0*a[NC];                                         *
+	 *                                                             *
+	 * for (i=2; i<NC; i++)            Divide by (1-z^-2)          *
+	 *   f2[i] += f2[i-2];                                         *
+	 *-------------------------------------------------------------*/
+	for (i = 0; i < NC; i++)
+	{
+		t0 = a[i] << 15;
+		f1[i] = vo_round(t0 + (a[M - i] << 15));        /* =(a[i]+a[M-i])/2 */
+		f2[i] = vo_round(t0 - (a[M - i] << 15));        /* =(a[i]-a[M-i])/2 */
+	}
+	f1[NC] = a[NC];
+	for (i = 2; i < NC; i++)               /* Divide by (1-z^-2) */
+		f2[i] = add1(f2[i], f2[i - 2]);
+
+	/*---------------------------------------------------------------------*
+	 * Find the ISPs (roots of F1(z) and F2(z) ) using the                 *
+	 * Chebyshev polynomial evaluation.                                    *
+	 * The roots of F1(z) and F2(z) are alternatively searched.            *
+	 * We start by finding the first root of F1(z) then we switch          *
+	 * to F2(z) then back to F1(z) and so on until all roots are found.    *
+	 *                                                                     *
+	 *  - Evaluate Chebyshev pol. at grid points and check for sign change.*
+	 *  - If sign change track the root by subdividing the interval        *
+	 *    2 times and ckecking sign change.                                *
+	 *---------------------------------------------------------------------*/
+	nf = 0;                                  /* number of found frequencies */
+	ip = 0;                                  /* indicator for f1 or f2      */
+	coef = f1;
+	order = NC;
+	xlow = vogrid[0];
+	ylow = Chebps2(xlow, coef, order);
+	j = 0;
+	while ((nf < M - 1) && (j < GRID_POINTS))
+	{
+		j ++;
+		xhigh = xlow;
+		yhigh = ylow;
+		xlow = vogrid[j];
+		ylow = Chebps2(xlow, coef, order);
+		if ((ylow * yhigh) <= (Word32) 0)
+		{
+			/* divide 2 times the interval */
+			for (i = 0; i < 2; i++)
+			{
+				xmid = (xlow >> 1) + (xhigh >> 1);        /* xmid = (xlow + xhigh)/2 */
+				ymid = Chebps2(xmid, coef, order);
+				if ((ylow * ymid) <= (Word32) 0)
+				{
+					yhigh = ymid;
+					xhigh = xmid;
+				} else
+				{
+					ylow = ymid;
+					xlow = xmid;
+				}
+			}
+			/*-------------------------------------------------------------*
+			 * Linear interpolation                                        *
+			 *    xint = xlow - ylow*(xhigh-xlow)/(yhigh-ylow);            *
+			 *-------------------------------------------------------------*/
+			x = xhigh - xlow;
+			y = yhigh - ylow;
+			if (y == 0)
+			{
+				xint = xlow;
+			} else
+			{
+				sign = y;
+				y = abs_s(y);
+				exp = norm_s(y);
+				y = y << exp;
+				y = div_s((Word16) 16383, y);
+				t0 = x * y;
+				t0 = (t0 >> (19 - exp));
+				y = vo_extract_l(t0);         /* y= (xhigh-xlow)/(yhigh-ylow) in Q11 */
+				if (sign < 0)
+					y = -y;
+				t0 = ylow * y;      /* result in Q26 */
+				t0 = (t0 >> 10);        /* result in Q15 */
+				xint = vo_sub(xlow, vo_extract_l(t0));        /* xint = xlow - ylow*y */
+			}
+			isp[nf] = xint;
+			xlow = xint;
+			nf++;
+			if (ip == 0)
+			{
+				ip = 1;
+				coef = f2;
+				order = NC - 1;
+			} else
+			{
+				ip = 0;
+				coef = f1;
+				order = NC;
+			}
+			ylow = Chebps2(xlow, coef, order);
+		}
+	}
+	/* Check if M-1 roots found */
+	if(nf < M - 1)
+	{
+		for (i = 0; i < M; i++)
+		{
+			isp[i] = old_isp[i];
+		}
+	} else
+	{
+		isp[M - 1] = a[M] << 3;                      /* From Q12 to Q15 with saturation */
+	}
+	return;
+}
+
+/*--------------------------------------------------------------*
+* function  Chebps2:                                           *
+*           ~~~~~~~                                            *
+*    Evaluates the Chebishev polynomial series                 *
+*--------------------------------------------------------------*
+*                                                              *
+*  The polynomial order is                                     *
+*     n = M/2   (M is the prediction order)                    *
+*  The polynomial is given by                                  *
+*    C(x) = f(0)T_n(x) + f(1)T_n-1(x) + ... +f(n-1)T_1(x) + f(n)/2 *
+* Arguments:                                                   *
+*  x:     input value of evaluation; x = cos(frequency) in Q15 *
+*  f[]:   coefficients of the pol.                      in Q11 *
+*  n:     order of the pol.                                    *
+*                                                              *
+* The value of C(x) is returned. (Satured to +-1.99 in Q14)    *
+*                                                              *
+*--------------------------------------------------------------*/
+
+static __inline Word16 Chebps2(Word16 x, Word16 f[], Word32 n)
+{
+	Word32 i, cheb;
+	Word16 b0_h, b0_l, b1_h, b1_l, b2_h, b2_l;
+	Word32 t0;
+
+	/* Note: All computation are done in Q24. */
+
+	t0 = f[0] << 13;
+	b2_h = t0 >> 16;
+	b2_l = (t0 & 0xffff)>>1;
+
+	t0 = ((b2_h * x)<<1) + (((b2_l * x)>>15)<<1);
+	t0 <<= 1;
+	t0 += (f[1] << 13);						/* + f[1] in Q24        */
+
+	b1_h = t0 >> 16;
+	b1_l = (t0 & 0xffff) >> 1;
+
+	for (i = 2; i < n; i++)
+	{
+		t0 = ((b1_h * x)<<1) + (((b1_l * x)>>15)<<1);
+
+		t0 += (b2_h * (-16384))<<1;
+		t0 += (f[i] << 12);
+		t0 <<= 1;
+		t0 -= (b2_l << 1);					/* t0 = 2.0*x*b1 - b2 + f[i]; */
+
+		b0_h = t0 >> 16;
+		b0_l = (t0 & 0xffff) >> 1;
+
+		b2_l = b1_l;                         /* b2 = b1; */
+		b2_h = b1_h;
+		b1_l = b0_l;                         /* b1 = b0; */
+		b1_h = b0_h;
+	}
+
+	t0 = ((b1_h * x)<<1) + (((b1_l * x)>>15)<<1);
+	t0 += (b2_h * (-32768))<<1;				/* t0 = x*b1 - b2          */
+	t0 -= (b2_l << 1);
+	t0 += (f[n] << 12);						/* t0 = x*b1 - b2 + f[i]/2 */
+
+	t0 = L_shl2(t0, 6);                     /* Q24 to Q30 with saturation */
+
+	cheb = extract_h(t0);                  /* Result in Q14              */
+
+	if (cheb == -32768)
+	{
+		cheb = -32767;                     /* to avoid saturation in Az_isp */
+	}
+	return (cheb);
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/bits.c b/media/libstagefright/codecs/amrwbenc/src/bits.c
index 90d1a00..e78dc1f 100644
--- a/media/libstagefright/codecs/amrwbenc/src/bits.c
+++ b/media/libstagefright/codecs/amrwbenc/src/bits.c
@@ -1,210 +1,210 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-       File: bits.c
-
-	   Description: Performs bit stream manipulation
-
-************************************************************************/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "typedef.h"
-#include "basic_op.h"
-#include "cnst.h"
-#include "bits.h"
-#include "acelp.h"
-#include "dtx.h"
-#include "mime_io.tab"
-
-
-int PackBits(Word16 prms[],             /*  i: analysis parameters */
-			 Word16 coding_mode,        /*  i: coding bit-stream ratio mode */
-			 Word16 mode,               /*  i: coding bit-stream ratio mode*/ 
-			 Coder_State *st            /*i/o: coder global parameters struct */           
-			 )
-{
-	Word16 i, frame_type;
-	UWord8 temp;
-	UWord8 *stream_ptr;
-	Word16 bitstreamformat = st->frameType;
-
-	unsigned short* dataOut = st->outputStream;
-
-	if (coding_mode == MRDTX)
-	{	   
-		st->sid_update_counter--;
-
-		if (st->prev_ft == TX_SPEECH)
-		{
-			frame_type = TX_SID_FIRST;
-			st->sid_update_counter = 3;
-		} else
-		{
-			if ((st->sid_handover_debt > 0) && (st->sid_update_counter > 2))
-			{
-				/* ensure extra updates are  properly delayed after a possible SID_FIRST */
-				frame_type = TX_SID_UPDATE;
-				st->sid_handover_debt--;
-			} else
-			{
-				if (st->sid_update_counter == 0)
-				{
-					frame_type = TX_SID_UPDATE;
-					st->sid_update_counter = 8;
-				} else
-				{
-					frame_type = TX_NO_DATA;
-				}
-			}
-		}
-	} else
-	{
-		st->sid_update_counter = 8;
-		frame_type = TX_SPEECH;
-	}
-	st->prev_ft = frame_type;
-
-	if(bitstreamformat == 0)				/* default file format */
-	{
-		*(dataOut) = TX_FRAME_TYPE;
-		*(dataOut + 1) = frame_type;
-		*(dataOut + 2) = mode;
-		for (i = 0; i < nb_of_bits[coding_mode]; i++)
-		{
-			*(dataOut + 3 + i) = prms[i];
-		}
-		return  (3 + nb_of_bits[coding_mode])<<1;
-	} else
-	{
-		if (bitstreamformat == 1)		/* ITU file format */
-		{  						
-			*(dataOut) = 0x6b21;
-			if(frame_type != TX_NO_DATA && frame_type != TX_SID_FIRST)
-			{
-				*(dataOut + 1) = nb_of_bits[coding_mode];
-				for (i = 0; i < nb_of_bits[coding_mode]; i++)
-				{
-					if(prms[i] == BIT_0){
-						*(dataOut + 2 + i) = BIT_0_ITU;	 			
-					}
-					else{
-						*(dataOut + 2 + i) = BIT_1_ITU;
-					}
-				}
-				return (2 + nb_of_bits[coding_mode])<<1;   
-			} else
-			{
-				*(dataOut + 1) = 0;
-				return 2<<1;	   
-			}
-		} else							/* MIME/storage file format */
-		{
-#define MRSID 9
-			/* change mode index in case of SID frame */
-			if (coding_mode == MRDTX)
-			{
-				coding_mode = MRSID;
-				if (frame_type == TX_SID_FIRST)
-				{
-					for (i = 0; i < NBBITS_SID; i++)	prms[i] = BIT_0;
-				}
-			}
-			/* -> force NO_DATA frame */
-			if (coding_mode < 0 || coding_mode > 15 || (coding_mode > MRSID && coding_mode < 14))
-			{
-				coding_mode = 15;
-			}
-			/* mark empty frames between SID updates as NO_DATA frames */
-			if (coding_mode == MRSID && frame_type == TX_NO_DATA)
-			{
-				coding_mode = 15;
-			}
-			/* set pointer for packed frame, note that we handle data as bytes */
-			stream_ptr = (UWord8*)dataOut;
-			/* insert table of contents (ToC) byte at the beginning of the packet */
-			*stream_ptr = toc_byte[coding_mode];
-			stream_ptr++;
-			temp = 0;
-			/* sort and pack AMR-WB speech or SID bits */
-			for (i = 1; i < unpacked_size[coding_mode] + 1; i++)
-			{
-				if (prms[sort_ptr[coding_mode][i-1]] == BIT_1)
-				{
-					temp++;
-				}
-				if (i&0x7)
-				{
-					temp <<= 1;
-				}
-				else
-				{
-					*stream_ptr = temp;
-					stream_ptr++;
-					temp = 0;
-				}
-			}
-			/* insert SID type indication and speech mode in case of SID frame */
-			if (coding_mode == MRSID)
-			{
-				if (frame_type == TX_SID_UPDATE)
-				{
-					temp++;
-				}
-				temp <<= 4;
-				temp += mode & 0x000F;
-			}
-			/* insert unused bits (zeros) at the tail of the last byte */
-			if (unused_size[coding_mode])
-			{
-				temp <<= (unused_size[coding_mode] - 1);
-			}
-			*stream_ptr = temp;
-			/* write packed frame into file (1 byte added to cover ToC entry) */
-			return (1 + packed_size[coding_mode]);
-		}
-	}
-}
-
-/*-----------------------------------------------------*
-* Parm_serial -> convert parameters to serial stream  *
-*-----------------------------------------------------*/
-
-void Parm_serial(
-		Word16 value,                         /* input : parameter value */
-		Word16 no_of_bits,                    /* input : number of bits  */
-		Word16 ** prms
-		)
-{
-	Word16 i, bit;
-	*prms += no_of_bits;                  
-	for (i = 0; i < no_of_bits; i++)
-	{
-		bit = (Word16) (value & 0x0001);    /* get lsb */
-		if (bit == 0)
-			*--(*prms) = BIT_0;
-		else
-			*--(*prms) = BIT_1;
-		value >>= 1;          
-	}
-	*prms += no_of_bits;                  
-	return;
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+       File: bits.c
+
+	   Description: Performs bit stream manipulation
+
+************************************************************************/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "cnst.h"
+#include "bits.h"
+#include "acelp.h"
+#include "dtx.h"
+#include "mime_io.tab"
+
+
+int PackBits(Word16 prms[],             /*  i: analysis parameters */
+			 Word16 coding_mode,        /*  i: coding bit-stream ratio mode */
+			 Word16 mode,               /*  i: coding bit-stream ratio mode*/
+			 Coder_State *st            /*i/o: coder global parameters struct */
+			 )
+{
+	Word16 i, frame_type;
+	UWord8 temp;
+	UWord8 *stream_ptr;
+	Word16 bitstreamformat = st->frameType;
+
+	unsigned short* dataOut = st->outputStream;
+
+	if (coding_mode == MRDTX)
+	{
+		st->sid_update_counter--;
+
+		if (st->prev_ft == TX_SPEECH)
+		{
+			frame_type = TX_SID_FIRST;
+			st->sid_update_counter = 3;
+		} else
+		{
+			if ((st->sid_handover_debt > 0) && (st->sid_update_counter > 2))
+			{
+				/* ensure extra updates are  properly delayed after a possible SID_FIRST */
+				frame_type = TX_SID_UPDATE;
+				st->sid_handover_debt--;
+			} else
+			{
+				if (st->sid_update_counter == 0)
+				{
+					frame_type = TX_SID_UPDATE;
+					st->sid_update_counter = 8;
+				} else
+				{
+					frame_type = TX_NO_DATA;
+				}
+			}
+		}
+	} else
+	{
+		st->sid_update_counter = 8;
+		frame_type = TX_SPEECH;
+	}
+	st->prev_ft = frame_type;
+
+	if(bitstreamformat == 0)				/* default file format */
+	{
+		*(dataOut) = TX_FRAME_TYPE;
+		*(dataOut + 1) = frame_type;
+		*(dataOut + 2) = mode;
+		for (i = 0; i < nb_of_bits[coding_mode]; i++)
+		{
+			*(dataOut + 3 + i) = prms[i];
+		}
+		return  (3 + nb_of_bits[coding_mode])<<1;
+	} else
+	{
+		if (bitstreamformat == 1)		/* ITU file format */
+		{
+			*(dataOut) = 0x6b21;
+			if(frame_type != TX_NO_DATA && frame_type != TX_SID_FIRST)
+			{
+				*(dataOut + 1) = nb_of_bits[coding_mode];
+				for (i = 0; i < nb_of_bits[coding_mode]; i++)
+				{
+					if(prms[i] == BIT_0){
+						*(dataOut + 2 + i) = BIT_0_ITU;
+					}
+					else{
+						*(dataOut + 2 + i) = BIT_1_ITU;
+					}
+				}
+				return (2 + nb_of_bits[coding_mode])<<1;
+			} else
+			{
+				*(dataOut + 1) = 0;
+				return 2<<1;
+			}
+		} else							/* MIME/storage file format */
+		{
+#define MRSID 9
+			/* change mode index in case of SID frame */
+			if (coding_mode == MRDTX)
+			{
+				coding_mode = MRSID;
+				if (frame_type == TX_SID_FIRST)
+				{
+					for (i = 0; i < NBBITS_SID; i++)	prms[i] = BIT_0;
+				}
+			}
+			/* -> force NO_DATA frame */
+			if (coding_mode < 0 || coding_mode > 15 || (coding_mode > MRSID && coding_mode < 14))
+			{
+				coding_mode = 15;
+			}
+			/* mark empty frames between SID updates as NO_DATA frames */
+			if (coding_mode == MRSID && frame_type == TX_NO_DATA)
+			{
+				coding_mode = 15;
+			}
+			/* set pointer for packed frame, note that we handle data as bytes */
+			stream_ptr = (UWord8*)dataOut;
+			/* insert table of contents (ToC) byte at the beginning of the packet */
+			*stream_ptr = toc_byte[coding_mode];
+			stream_ptr++;
+			temp = 0;
+			/* sort and pack AMR-WB speech or SID bits */
+			for (i = 1; i < unpacked_size[coding_mode] + 1; i++)
+			{
+				if (prms[sort_ptr[coding_mode][i-1]] == BIT_1)
+				{
+					temp++;
+				}
+				if (i&0x7)
+				{
+					temp <<= 1;
+				}
+				else
+				{
+					*stream_ptr = temp;
+					stream_ptr++;
+					temp = 0;
+				}
+			}
+			/* insert SID type indication and speech mode in case of SID frame */
+			if (coding_mode == MRSID)
+			{
+				if (frame_type == TX_SID_UPDATE)
+				{
+					temp++;
+				}
+				temp <<= 4;
+				temp += mode & 0x000F;
+			}
+			/* insert unused bits (zeros) at the tail of the last byte */
+			if (unused_size[coding_mode])
+			{
+				temp <<= (unused_size[coding_mode] - 1);
+			}
+			*stream_ptr = temp;
+			/* write packed frame into file (1 byte added to cover ToC entry) */
+			return (1 + packed_size[coding_mode]);
+		}
+	}
+}
+
+/*-----------------------------------------------------*
+* Parm_serial -> convert parameters to serial stream  *
+*-----------------------------------------------------*/
+
+void Parm_serial(
+		Word16 value,                         /* input : parameter value */
+		Word16 no_of_bits,                    /* input : number of bits  */
+		Word16 ** prms
+		)
+{
+	Word16 i, bit;
+	*prms += no_of_bits;
+	for (i = 0; i < no_of_bits; i++)
+	{
+		bit = (Word16) (value & 0x0001);    /* get lsb */
+		if (bit == 0)
+			*--(*prms) = BIT_0;
+		else
+			*--(*prms) = BIT_1;
+		value >>= 1;
+	}
+	*prms += no_of_bits;
+	return;
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/c2t64fx.c b/media/libstagefright/codecs/amrwbenc/src/c2t64fx.c
index 39fc4c5..18698e2 100644
--- a/media/libstagefright/codecs/amrwbenc/src/c2t64fx.c
+++ b/media/libstagefright/codecs/amrwbenc/src/c2t64fx.c
@@ -1,297 +1,297 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/************************************************************************
-*      File: c2t64fx.c                                                  *
-*                                                                       *
-*	   Description:Performs algebraic codebook search for 6.60kbits mode*
-*                                                                       *
-*************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-#include "acelp.h"
-#include "cnst.h"
-
-#define NB_TRACK  2
-#define STEP      2
-#define NB_POS    32
-#define MSIZE     1024
-
-/*************************************************************************
-* Function:  ACELP_2t64_fx()                                             *
-*                                                                        *
-* 12 bits algebraic codebook.                                            *
-* 2 tracks x 32 positions per track = 64 samples.                        *
-*                                                                        *
-* 12 bits --> 2 pulses in a frame of 64 samples.                         *
-*                                                                        *
-* All pulses can have two (2) possible amplitudes: +1 or -1.             *
-* Each pulse can have 32 possible positions.                             *
-**************************************************************************/
-
-void ACELP_2t64_fx(
-		Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
-		Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
-		Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
-		Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
-		Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
-		Word16 * index                        /* (o) : index (12): 5+1+5+1 = 11 bits.                   */
-		)
-{
-	Word32 i, j, k, i0, i1, ix, iy, pos, pos2;
-	Word16 ps, psk, ps1, ps2, alpk, alp1, alp2, sq;
-	Word16 alp, val, exp, k_cn, k_dn;
-	Word16 *p0, *p1, *p2, *psign;
-	Word16 *h, *h_inv, *ptr_h1, *ptr_h2, *ptr_hf;
-
-	Word16 sign[L_SUBFR], vec[L_SUBFR], dn2[L_SUBFR];
-	Word16 h_buf[4 * L_SUBFR] = {0};
-	Word16 rrixix[NB_TRACK][NB_POS];
-	Word16 rrixiy[MSIZE];
-	Word32 s, cor;
-
-	/*----------------------------------------------------------------*
-	 * Find sign for each pulse position.                             *
-	 *----------------------------------------------------------------*/
-	alp = 8192;                              /* alp = 2.0 (Q12) */
-
-	/* calculate energy for normalization of cn[] and dn[] */
-	/* set k_cn = 32..32767 (ener_cn = 2^30..256-0) */
-#ifdef ASM_OPT             /* asm optimization branch */
-	s = Dot_product12_asm(cn, cn, L_SUBFR, &exp);
-#else
-	s = Dot_product12(cn, cn, L_SUBFR, &exp);
-#endif
-
-	Isqrt_n(&s, &exp);
-	s = L_shl(s, add1(exp, 5));             
-	k_cn = vo_round(s);
-
-	/* set k_dn = 32..512 (ener_dn = 2^30..2^22) */
-#ifdef ASM_OPT                  /* asm optimization branch */
-	s = Dot_product12_asm(dn, dn, L_SUBFR, &exp);
-#else
-	s = Dot_product12(dn, dn, L_SUBFR, &exp);
-#endif
-
-	Isqrt_n(&s, &exp);
-	k_dn = vo_round(L_shl(s, (exp + 8)));    /* k_dn = 256..4096 */
-	k_dn = vo_mult_r(alp, k_dn);              /* alp in Q12 */
-
-	/* mix normalized cn[] and dn[] */
-	p0 = cn;
-	p1 = dn;
-	p2 = dn2;
-
-	for (i = 0; i < L_SUBFR/4; i++)
-	{
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7;
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7;
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7;
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7; 
-	}
-
-	/* set sign according to dn2[] = k_cn*cn[] + k_dn*dn[]    */
-	for (i = 0; i < L_SUBFR; i ++)
-	{
-		val = dn[i];                   
-		ps = dn2[i];                   
-		if (ps >= 0)
-		{
-			sign[i] = 32767;             /* sign = +1 (Q12) */
-			vec[i] = -32768;           
-		} else
-		{
-			sign[i] = -32768;            /* sign = -1 (Q12) */
-			vec[i] = 32767;            
-			dn[i] = -val;
-		}
-	}
-	/*------------------------------------------------------------*
-	 * Compute h_inv[i].                                          *
-	 *------------------------------------------------------------*/
-	/* impulse response buffer for fast computation */
-	h = h_buf + L_SUBFR;                             
-	h_inv = h + (L_SUBFR<<1);         
-
-	for (i = 0; i < L_SUBFR; i++)
-	{
-		h[i] = H[i];                       
-		h_inv[i] = vo_negate(h[i]);           
-	}
-
-	/*------------------------------------------------------------*
-	 * Compute rrixix[][] needed for the codebook search.         *
-	 * Result is multiplied by 0.5                                *
-	 *------------------------------------------------------------*/
-	/* Init pointers to last position of rrixix[] */
-	p0 = &rrixix[0][NB_POS - 1];           
-	p1 = &rrixix[1][NB_POS - 1];           
-
-	ptr_h1 = h;                            
-	cor = 0x00010000L;                          /* for rounding */
-	for (i = 0; i < NB_POS; i++)
-	{
-		cor += ((*ptr_h1) * (*ptr_h1) << 1);
-		ptr_h1++;
-		*p1-- = (extract_h(cor) >> 1);            
-		cor += ((*ptr_h1) * (*ptr_h1) << 1);
-		ptr_h1++;
-		*p0-- = (extract_h(cor) >> 1);            
-	}
-
-	/*------------------------------------------------------------*
-	 * Compute rrixiy[][] needed for the codebook search.         *
-	 *------------------------------------------------------------*/
-	pos = MSIZE - 1;                       
-	pos2 = MSIZE - 2;                      
-	ptr_hf = h + 1;                        
-
-	for (k = 0; k < NB_POS; k++)
-	{
-		p1 = &rrixiy[pos];                 
-		p0 = &rrixiy[pos2];                
-		cor = 0x00008000L;                        /* for rounding */
-		ptr_h1 = h;                        
-		ptr_h2 = ptr_hf;                   
-
-		for (i = (k + 1); i < NB_POS; i++)
-		{
-			cor += ((*ptr_h1) * (*ptr_h2))<<1;
-			ptr_h1++;
-			ptr_h2++;
-			*p1 = extract_h(cor);          
-			cor += ((*ptr_h1) * (*ptr_h2))<<1;
-			ptr_h1++;
-			ptr_h2++;
-			*p0 = extract_h(cor);         
-
-			p1 -= (NB_POS + 1);
-			p0 -= (NB_POS + 1);
-		}
-		cor += ((*ptr_h1) * (*ptr_h2))<<1;
-		ptr_h1++;
-		ptr_h2++;
-		*p1 = extract_h(cor);              
-
-		pos -= NB_POS;
-		pos2--;
-		ptr_hf += STEP;
-	}
-
-	/*------------------------------------------------------------*
-	 * Modification of rrixiy[][] to take signs into account.     *
-	 *------------------------------------------------------------*/
-	p0 = rrixiy;                          
-	for (i = 0; i < L_SUBFR; i += STEP)
-	{
-		psign = sign;                      
-		if (psign[i] < 0)
-		{
-			psign = vec;                   
-		}
-		for (j = 1; j < L_SUBFR; j += STEP)
-		{
-			*p0 = vo_mult(*p0, psign[j]);     
-			p0++;
-		}
-	}
-	/*-------------------------------------------------------------------*
-	 * search 2 pulses:                                                  *
-	 * ~@~~~~~~~~~~~~~~                                                  *
-	 * 32 pos x 32 pos = 1024 tests (all combinaisons is tested)         *
-	 *-------------------------------------------------------------------*/
-	p0 = rrixix[0];                        
-	p1 = rrixix[1];                        
-	p2 = rrixiy;                          
-
-	psk = -1;                              
-	alpk = 1;                              
-	ix = 0;                                
-	iy = 1;                                
-
-	for (i0 = 0; i0 < L_SUBFR; i0 += STEP)
-	{
-		ps1 = dn[i0];                      
-		alp1 = (*p0++);                    
-		pos = -1;                          
-		for (i1 = 1; i1 < L_SUBFR; i1 += STEP)
-		{
-			ps2 = add1(ps1, dn[i1]);
-			alp2 = add1(alp1, add1(*p1++, *p2++));
-			sq = vo_mult(ps2, ps2);
-			s = vo_L_mult(alpk, sq) - ((psk * alp2)<<1);
-			if (s > 0)
-			{
-				psk = sq;                  
-				alpk = alp2;               
-				pos = i1;                  
-			}
-		}
-		p1 -= NB_POS;
-		if (pos >= 0)
-		{
-			ix = i0;                      
-			iy = pos;                      
-		}
-	}
-	/*-------------------------------------------------------------------*
-	 * Build the codeword, the filtered codeword and index of codevector.*
-	 *-------------------------------------------------------------------*/
-
-	for (i = 0; i < L_SUBFR; i++)
-	{
-		code[i] = 0;                       
-	}
-
-	i0 = (ix >> 1);                       /* pos of pulse 1 (0..31) */
-	i1 = (iy >> 1);                       /* pos of pulse 2 (0..31) */
-	if (sign[ix] > 0)
-	{
-		code[ix] = 512;                     /* codeword in Q9 format */
-		p0 = h - ix;                       
-	} else
-	{
-		code[ix] = -512;                   
-		i0 += NB_POS;                      
-		p0 = h_inv - ix;                   
-	}
-	if (sign[iy] > 0)
-	{
-		code[iy] = 512;                    
-		p1 = h - iy;                       
-	} else
-	{
-		code[iy] = -512;                   
-		i1 += NB_POS;                      
-		p1 = h_inv - iy;                   
-	}
-	*index = add1((i0 << 6), i1);          
-	for (i = 0; i < L_SUBFR; i++)
-	{
-		y[i] = vo_shr_r(add1((*p0++), (*p1++)), 3);
-	}
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/************************************************************************
+*      File: c2t64fx.c                                                  *
+*                                                                       *
+*	   Description:Performs algebraic codebook search for 6.60kbits mode*
+*                                                                       *
+*************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+#include "acelp.h"
+#include "cnst.h"
+
+#define NB_TRACK  2
+#define STEP      2
+#define NB_POS    32
+#define MSIZE     1024
+
+/*************************************************************************
+* Function:  ACELP_2t64_fx()                                             *
+*                                                                        *
+* 12 bits algebraic codebook.                                            *
+* 2 tracks x 32 positions per track = 64 samples.                        *
+*                                                                        *
+* 12 bits --> 2 pulses in a frame of 64 samples.                         *
+*                                                                        *
+* All pulses can have two (2) possible amplitudes: +1 or -1.             *
+* Each pulse can have 32 possible positions.                             *
+**************************************************************************/
+
+void ACELP_2t64_fx(
+		Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
+		Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
+		Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
+		Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
+		Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
+		Word16 * index                        /* (o) : index (12): 5+1+5+1 = 11 bits.                   */
+		)
+{
+	Word32 i, j, k, i0, i1, ix, iy, pos, pos2;
+	Word16 ps, psk, ps1, ps2, alpk, alp1, alp2, sq;
+	Word16 alp, val, exp, k_cn, k_dn;
+	Word16 *p0, *p1, *p2, *psign;
+	Word16 *h, *h_inv, *ptr_h1, *ptr_h2, *ptr_hf;
+
+	Word16 sign[L_SUBFR], vec[L_SUBFR], dn2[L_SUBFR];
+	Word16 h_buf[4 * L_SUBFR] = {0};
+	Word16 rrixix[NB_TRACK][NB_POS];
+	Word16 rrixiy[MSIZE];
+	Word32 s, cor;
+
+	/*----------------------------------------------------------------*
+	 * Find sign for each pulse position.                             *
+	 *----------------------------------------------------------------*/
+	alp = 8192;                              /* alp = 2.0 (Q12) */
+
+	/* calculate energy for normalization of cn[] and dn[] */
+	/* set k_cn = 32..32767 (ener_cn = 2^30..256-0) */
+#ifdef ASM_OPT             /* asm optimization branch */
+	s = Dot_product12_asm(cn, cn, L_SUBFR, &exp);
+#else
+	s = Dot_product12(cn, cn, L_SUBFR, &exp);
+#endif
+
+	Isqrt_n(&s, &exp);
+	s = L_shl(s, add1(exp, 5));
+	k_cn = vo_round(s);
+
+	/* set k_dn = 32..512 (ener_dn = 2^30..2^22) */
+#ifdef ASM_OPT                  /* asm optimization branch */
+	s = Dot_product12_asm(dn, dn, L_SUBFR, &exp);
+#else
+	s = Dot_product12(dn, dn, L_SUBFR, &exp);
+#endif
+
+	Isqrt_n(&s, &exp);
+	k_dn = vo_round(L_shl(s, (exp + 8)));    /* k_dn = 256..4096 */
+	k_dn = vo_mult_r(alp, k_dn);              /* alp in Q12 */
+
+	/* mix normalized cn[] and dn[] */
+	p0 = cn;
+	p1 = dn;
+	p2 = dn2;
+
+	for (i = 0; i < L_SUBFR/4; i++)
+	{
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+	}
+
+	/* set sign according to dn2[] = k_cn*cn[] + k_dn*dn[]    */
+	for (i = 0; i < L_SUBFR; i ++)
+	{
+		val = dn[i];
+		ps = dn2[i];
+		if (ps >= 0)
+		{
+			sign[i] = 32767;             /* sign = +1 (Q12) */
+			vec[i] = -32768;
+		} else
+		{
+			sign[i] = -32768;            /* sign = -1 (Q12) */
+			vec[i] = 32767;
+			dn[i] = -val;
+		}
+	}
+	/*------------------------------------------------------------*
+	 * Compute h_inv[i].                                          *
+	 *------------------------------------------------------------*/
+	/* impulse response buffer for fast computation */
+	h = h_buf + L_SUBFR;
+	h_inv = h + (L_SUBFR<<1);
+
+	for (i = 0; i < L_SUBFR; i++)
+	{
+		h[i] = H[i];
+		h_inv[i] = vo_negate(h[i]);
+	}
+
+	/*------------------------------------------------------------*
+	 * Compute rrixix[][] needed for the codebook search.         *
+	 * Result is multiplied by 0.5                                *
+	 *------------------------------------------------------------*/
+	/* Init pointers to last position of rrixix[] */
+	p0 = &rrixix[0][NB_POS - 1];
+	p1 = &rrixix[1][NB_POS - 1];
+
+	ptr_h1 = h;
+	cor = 0x00010000L;                          /* for rounding */
+	for (i = 0; i < NB_POS; i++)
+	{
+		cor += ((*ptr_h1) * (*ptr_h1) << 1);
+		ptr_h1++;
+		*p1-- = (extract_h(cor) >> 1);
+		cor += ((*ptr_h1) * (*ptr_h1) << 1);
+		ptr_h1++;
+		*p0-- = (extract_h(cor) >> 1);
+	}
+
+	/*------------------------------------------------------------*
+	 * Compute rrixiy[][] needed for the codebook search.         *
+	 *------------------------------------------------------------*/
+	pos = MSIZE - 1;
+	pos2 = MSIZE - 2;
+	ptr_hf = h + 1;
+
+	for (k = 0; k < NB_POS; k++)
+	{
+		p1 = &rrixiy[pos];
+		p0 = &rrixiy[pos2];
+		cor = 0x00008000L;                        /* for rounding */
+		ptr_h1 = h;
+		ptr_h2 = ptr_hf;
+
+		for (i = (k + 1); i < NB_POS; i++)
+		{
+			cor += ((*ptr_h1) * (*ptr_h2))<<1;
+			ptr_h1++;
+			ptr_h2++;
+			*p1 = extract_h(cor);
+			cor += ((*ptr_h1) * (*ptr_h2))<<1;
+			ptr_h1++;
+			ptr_h2++;
+			*p0 = extract_h(cor);
+
+			p1 -= (NB_POS + 1);
+			p0 -= (NB_POS + 1);
+		}
+		cor += ((*ptr_h1) * (*ptr_h2))<<1;
+		ptr_h1++;
+		ptr_h2++;
+		*p1 = extract_h(cor);
+
+		pos -= NB_POS;
+		pos2--;
+		ptr_hf += STEP;
+	}
+
+	/*------------------------------------------------------------*
+	 * Modification of rrixiy[][] to take signs into account.     *
+	 *------------------------------------------------------------*/
+	p0 = rrixiy;
+	for (i = 0; i < L_SUBFR; i += STEP)
+	{
+		psign = sign;
+		if (psign[i] < 0)
+		{
+			psign = vec;
+		}
+		for (j = 1; j < L_SUBFR; j += STEP)
+		{
+			*p0 = vo_mult(*p0, psign[j]);
+			p0++;
+		}
+	}
+	/*-------------------------------------------------------------------*
+	 * search 2 pulses:                                                  *
+	 * ~@~~~~~~~~~~~~~~                                                  *
+	 * 32 pos x 32 pos = 1024 tests (all combinaisons is tested)         *
+	 *-------------------------------------------------------------------*/
+	p0 = rrixix[0];
+	p1 = rrixix[1];
+	p2 = rrixiy;
+
+	psk = -1;
+	alpk = 1;
+	ix = 0;
+	iy = 1;
+
+	for (i0 = 0; i0 < L_SUBFR; i0 += STEP)
+	{
+		ps1 = dn[i0];
+		alp1 = (*p0++);
+		pos = -1;
+		for (i1 = 1; i1 < L_SUBFR; i1 += STEP)
+		{
+			ps2 = add1(ps1, dn[i1]);
+			alp2 = add1(alp1, add1(*p1++, *p2++));
+			sq = vo_mult(ps2, ps2);
+			s = vo_L_mult(alpk, sq) - ((psk * alp2)<<1);
+			if (s > 0)
+			{
+				psk = sq;
+				alpk = alp2;
+				pos = i1;
+			}
+		}
+		p1 -= NB_POS;
+		if (pos >= 0)
+		{
+			ix = i0;
+			iy = pos;
+		}
+	}
+	/*-------------------------------------------------------------------*
+	 * Build the codeword, the filtered codeword and index of codevector.*
+	 *-------------------------------------------------------------------*/
+
+	for (i = 0; i < L_SUBFR; i++)
+	{
+		code[i] = 0;
+	}
+
+	i0 = (ix >> 1);                       /* pos of pulse 1 (0..31) */
+	i1 = (iy >> 1);                       /* pos of pulse 2 (0..31) */
+	if (sign[ix] > 0)
+	{
+		code[ix] = 512;                     /* codeword in Q9 format */
+		p0 = h - ix;
+	} else
+	{
+		code[ix] = -512;
+		i0 += NB_POS;
+		p0 = h_inv - ix;
+	}
+	if (sign[iy] > 0)
+	{
+		code[iy] = 512;
+		p1 = h - iy;
+	} else
+	{
+		code[iy] = -512;
+		i1 += NB_POS;
+		p1 = h_inv - iy;
+	}
+	*index = add1((i0 << 6), i1);
+	for (i = 0; i < L_SUBFR; i++)
+	{
+		y[i] = vo_shr_r(add1((*p0++), (*p1++)), 3);
+	}
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/c4t64fx.c b/media/libstagefright/codecs/amrwbenc/src/c4t64fx.c
index 27ba95d..1ecc11f 100644
--- a/media/libstagefright/codecs/amrwbenc/src/c4t64fx.c
+++ b/media/libstagefright/codecs/amrwbenc/src/c4t64fx.c
@@ -1,1043 +1,1043 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: c4t64fx.c                                                 *
-*                                                                      *
-*	   Description:Performs algebraic codebook search for higher modes *
-*                                                                      *
-************************************************************************/
-
-/************************************************************************
-* Function: ACELP_4t64_fx()                                             *
-*                                                                       *
-* 20, 36, 44, 52, 64, 72, 88 bits algebraic codebook.                   *
-* 4 tracks x 16 positions per track = 64 samples.                       *
-*                                                                       *
-* 20 bits --> 4 pulses in a frame of 64 samples.                        *
-* 36 bits --> 8 pulses in a frame of 64 samples.                        *
-* 44 bits --> 10 pulses in a frame of 64 samples.                       *
-* 52 bits --> 12 pulses in a frame of 64 samples.                       *
-* 64 bits --> 16 pulses in a frame of 64 samples.                       *
-* 72 bits --> 18 pulses in a frame of 64 samples.                       *
-* 88 bits --> 24 pulses in a frame of 64 samples.                       *
-*                                                                       *
-* All pulses can have two (2) possible amplitudes: +1 or -1.            *
-* Each pulse can have sixteen (16) possible positions.                  *
-*************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-#include "acelp.h"
-#include "cnst.h"
-
-#include "q_pulse.h"
-
-static Word16 tipos[36] = {
-	0, 1, 2, 3,                            /* starting point &ipos[0], 1st iter */
-	1, 2, 3, 0,                            /* starting point &ipos[4], 2nd iter */
-	2, 3, 0, 1,                            /* starting point &ipos[8], 3rd iter */
-	3, 0, 1, 2,                            /* starting point &ipos[12], 4th iter */
-	0, 1, 2, 3,
-	1, 2, 3, 0,
-	2, 3, 0, 1,
-	3, 0, 1, 2,
-	0, 1, 2, 3};                           /* end point for 24 pulses &ipos[35], 4th iter */
-
-#define NB_PULSE_MAX  24
-
-#define L_SUBFR   64
-#define NB_TRACK  4
-#define STEP      4
-#define NB_POS    16
-#define MSIZE     256
-#define NB_MAX    8
-#define NPMAXPT   ((NB_PULSE_MAX+NB_TRACK-1)/NB_TRACK)
-
-/* Private functions */
-void cor_h_vec_012(
-		Word16 h[],                           /* (i) scaled impulse response                 */
-		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
-		Word16 track,                         /* (i) track to use                            */
-		Word16 sign[],                        /* (i) sign vector                             */
-		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
-		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
-		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
-		);
-
-void cor_h_vec_012_asm(
-		Word16 h[],                           /* (i) scaled impulse response                 */
-		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
-		Word16 track,                         /* (i) track to use                            */
-		Word16 sign[],                        /* (i) sign vector                             */
-		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
-		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
-		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
-		);
-
-void cor_h_vec_30(
-		Word16 h[],                           /* (i) scaled impulse response                 */
-		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
-		Word16 track,                         /* (i) track to use                            */
-		Word16 sign[],                        /* (i) sign vector                             */
-		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
-		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
-		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
-		);
-
-void search_ixiy(
-		Word16 nb_pos_ix,                     /* (i) nb of pos for pulse 1 (1..8)       */
-		Word16 track_x,                       /* (i) track of pulse 1                   */
-		Word16 track_y,                       /* (i) track of pulse 2                   */
-		Word16 * ps,                          /* (i/o) correlation of all fixed pulses  */
-		Word16 * alp,                         /* (i/o) energy of all fixed pulses       */
-		Word16 * ix,                          /* (o) position of pulse 1                */
-		Word16 * iy,                          /* (o) position of pulse 2                */
-		Word16 dn[],                          /* (i) corr. between target and h[]       */
-		Word16 dn2[],                         /* (i) vector of selected positions       */
-		Word16 cor_x[],                       /* (i) corr. of pulse 1 with fixed pulses */
-		Word16 cor_y[],                       /* (i) corr. of pulse 2 with fixed pulses */
-		Word16 rrixiy[][MSIZE]                /* (i) corr. of pulse 1 with pulse 2   */
-		);
-
-
-void ACELP_4t64_fx(
-		Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
-		Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
-		Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
-		Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
-		Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
-		Word16 nbbits,                        /* (i) : 20, 36, 44, 52, 64, 72 or 88 bits                */
-		Word16 ser_size,                      /* (i) : bit rate                                         */
-		Word16 _index[]                       /* (o) : index (20): 5+5+5+5 = 20 bits.                   */
-		/* (o) : index (36): 9+9+9+9 = 36 bits.                   */
-		/* (o) : index (44): 13+9+13+9 = 44 bits.                 */
-		/* (o) : index (52): 13+13+13+13 = 52 bits.               */
-		/* (o) : index (64): 2+2+2+2+14+14+14+14 = 64 bits.       */
-		/* (o) : index (72): 10+2+10+2+10+14+10+14 = 72 bits.     */
-		/* (o) : index (88): 11+11+11+11+11+11+11+11 = 88 bits.   */
-		)
-{
-	Word32 i, j, k;
-	Word16 st, ix, iy, pos, index, track, nb_pulse, nbiter, j_temp;
-	Word16 psk, ps, alpk, alp, val, k_cn, k_dn, exp;
-	Word16 *p0, *p1, *p2, *p3, *psign;
-	Word16 *h, *h_inv, *ptr_h1, *ptr_h2, *ptr_hf, h_shift;
-	Word32 s, cor, L_tmp, L_index;
-	Word16 dn2[L_SUBFR], sign[L_SUBFR], vec[L_SUBFR];
-	Word16 ind[NPMAXPT * NB_TRACK];
-	Word16 codvec[NB_PULSE_MAX], nbpos[10];
-	Word16 cor_x[NB_POS], cor_y[NB_POS], pos_max[NB_TRACK];
-	Word16 h_buf[4 * L_SUBFR];
-	Word16 rrixix[NB_TRACK][NB_POS], rrixiy[NB_TRACK][MSIZE];
-	Word16 ipos[NB_PULSE_MAX];
-
-	switch (nbbits)
-	{
-		case 20:                               /* 20 bits, 4 pulses, 4 tracks */
-			nbiter = 4;                          /* 4x16x16=1024 loop */
-			alp = 8192;                          /* alp = 2.0 (Q12) */
-			nb_pulse = 4;                      
-			nbpos[0] = 4;                      
-			nbpos[1] = 8;                      
-			break;
-		case 36:                               /* 36 bits, 8 pulses, 4 tracks */
-			nbiter = 4;                          /* 4x20x16=1280 loop */
-			alp = 4096;                          /* alp = 1.0 (Q12) */
-			nb_pulse = 8;                      
-			nbpos[0] = 4;                      
-			nbpos[1] = 8;                      
-			nbpos[2] = 8;                      
-			break;
-		case 44:                               /* 44 bits, 10 pulses, 4 tracks */
-			nbiter = 4;                          /* 4x26x16=1664 loop */
-			alp = 4096;                          /* alp = 1.0 (Q12) */
-			nb_pulse = 10;                     
-			nbpos[0] = 4;                      
-			nbpos[1] = 6;                      
-			nbpos[2] = 8;                      
-			nbpos[3] = 8;                      
-			break;
-		case 52:                               /* 52 bits, 12 pulses, 4 tracks */
-			nbiter = 4;                          /* 4x26x16=1664 loop */
-			alp = 4096;                          /* alp = 1.0 (Q12) */
-			nb_pulse = 12;                     
-			nbpos[0] = 4;                      
-			nbpos[1] = 6;                      
-			nbpos[2] = 8;                      
-			nbpos[3] = 8;                      
-			break;
-		case 64:                               /* 64 bits, 16 pulses, 4 tracks */
-			nbiter = 3;                          /* 3x36x16=1728 loop */
-			alp = 3277;                          /* alp = 0.8 (Q12) */
-			nb_pulse = 16;                     
-			nbpos[0] = 4;                      
-			nbpos[1] = 4;                      
-			nbpos[2] = 6;                      
-			nbpos[3] = 6;                      
-			nbpos[4] = 8;                      
-			nbpos[5] = 8;                      
-			break;
-		case 72:                               /* 72 bits, 18 pulses, 4 tracks */
-			nbiter = 3;                          /* 3x35x16=1680 loop */
-			alp = 3072;                          /* alp = 0.75 (Q12) */
-			nb_pulse = 18;                     
-			nbpos[0] = 2;                      
-			nbpos[1] = 3;                      
-			nbpos[2] = 4;                      
-			nbpos[3] = 5;                      
-			nbpos[4] = 6;                      
-			nbpos[5] = 7;                      
-			nbpos[6] = 8;                      
-			break;
-		case 88:                               /* 88 bits, 24 pulses, 4 tracks */
-			if(ser_size > 462)
-				nbiter = 1;
-			else
-				nbiter = 2;                    /* 2x53x16=1696 loop */
-
-			alp = 2048;                          /* alp = 0.5 (Q12) */
-			nb_pulse = 24;                     
-			nbpos[0] = 2;                      
-			nbpos[1] = 2;                      
-			nbpos[2] = 3;                      
-			nbpos[3] = 4;                      
-			nbpos[4] = 5;                      
-			nbpos[5] = 6;                      
-			nbpos[6] = 7;                      
-			nbpos[7] = 8;                      
-			nbpos[8] = 8;                      
-			nbpos[9] = 8;                      
-			break;
-		default:
-			nbiter = 0;
-			alp = 0;
-			nb_pulse = 0;
-	}
-
-	for (i = 0; i < nb_pulse; i++)
-	{
-		codvec[i] = i;                     
-	}
-
-	/*----------------------------------------------------------------*
-	 * Find sign for each pulse position.                             *
-	 *----------------------------------------------------------------*/
-	/* calculate energy for normalization of cn[] and dn[] */
-	/* set k_cn = 32..32767 (ener_cn = 2^30..256-0) */
-#ifdef ASM_OPT                  /* asm optimization branch */
-	s = Dot_product12_asm(cn, cn, L_SUBFR, &exp);
-#else
-	s = Dot_product12(cn, cn, L_SUBFR, &exp);
-#endif
-
-	Isqrt_n(&s, &exp);
-	s = L_shl(s, (exp + 5)); 
-	k_cn = extract_h(L_add(s, 0x8000));
-
-	/* set k_dn = 32..512 (ener_dn = 2^30..2^22) */
-#ifdef ASM_OPT                      /* asm optimization branch */
-	s = Dot_product12_asm(dn, dn, L_SUBFR, &exp);
-#else
-	s = Dot_product12(dn, dn, L_SUBFR, &exp);
-#endif
-
-	Isqrt_n(&s, &exp);
-	k_dn = (L_shl(s, (exp + 5 + 3)) + 0x8000) >> 16;    /* k_dn = 256..4096 */
-	k_dn = vo_mult_r(alp, k_dn);              /* alp in Q12 */
-
-	/* mix normalized cn[] and dn[] */
-	p0 = cn;
-	p1 = dn;
-	p2 = dn2;
-
-	for (i = 0; i < L_SUBFR/4; i++)
-	{
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7;
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7;
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7;
-		s = (k_cn* (*p0++))+(k_dn * (*p1++));
-		*p2++ = s >> 7; 
-	}
-
-	/* set sign according to dn2[] = k_cn*cn[] + k_dn*dn[]    */
-	for(i = 0; i < L_SUBFR; i++)
-	{
-		val = dn[i];                   
-		ps = dn2[i];                   
-		if (ps >= 0)
-		{
-			sign[i] = 32767;             /* sign = +1 (Q12) */
-			vec[i] = -32768;           
-		} else
-		{
-			sign[i] = -32768;            /* sign = -1 (Q12) */
-			vec[i] = 32767;            
-			dn[i] = -val;
-			dn2[i] = -ps;
-		}
-	}
-	/*----------------------------------------------------------------*
-	 * Select NB_MAX position per track according to max of dn2[].    *
-	 *----------------------------------------------------------------*/
-	pos = 0;
-	for (i = 0; i < NB_TRACK; i++)
-	{
-		for (k = 0; k < NB_MAX; k++)
-		{
-			ps = -1;                       
-			for (j = i; j < L_SUBFR; j += STEP)
-			{
-				if(dn2[j] > ps)
-				{
-					ps = dn2[j];          
-					pos = j;               
-				}
-			}
-			dn2[pos] = (k - NB_MAX);     /* dn2 < 0 when position is selected */
-			if (k == 0)
-			{
-				pos_max[i] = pos;          
-			}
-		}
-	}
-
-	/*--------------------------------------------------------------*
-	 * Scale h[] to avoid overflow and to get maximum of precision  *
-	 * on correlation.                                              *
-	 *                                                              *
-	 * Maximum of h[] (h[0]) is fixed to 2048 (MAX16 / 16).         *
-	 *  ==> This allow addition of 16 pulses without saturation.    *
-	 *                                                              *
-	 * Energy worst case (on resonant impulse response),            *
-	 * - energy of h[] is approximately MAX/16.                     *
-	 * - During search, the energy is divided by 8 to avoid         *
-	 *   overflow on "alp". (energy of h[] = MAX/128).              *
-	 *  ==> "alp" worst case detected is 22854 on sinusoidal wave.  *
-	 *--------------------------------------------------------------*/
-
-	/* impulse response buffer for fast computation */
-
-	h = h_buf;                             
-	h_inv = h_buf + (2 * L_SUBFR);   
-	L_tmp = 0;
-	for (i = 0; i < L_SUBFR; i++)
-	{
-		*h++ = 0;                          
-		*h_inv++ = 0;   
-		L_tmp += (H[i] * H[i]) << 1;
-	}
-	/* scale h[] down (/2) when energy of h[] is high with many pulses used */
-	val = extract_h(L_tmp);
-	h_shift = 0;                           
-
-	if ((nb_pulse >= 12) && (val > 1024))
-	{
-		h_shift = 1;                       
-	}
-	p0 = H;
-	p1 = h;
-	p2 = h_inv;
-
-	for (i = 0; i < L_SUBFR/4; i++)
-	{
-		*p1 = *p0++ >> h_shift;         
-		*p2++ = -(*p1++);  
-		*p1 = *p0++ >> h_shift;         
-		*p2++ = -(*p1++); 
-		*p1 = *p0++ >> h_shift;         
-		*p2++ = -(*p1++); 
-		*p1 = *p0++ >> h_shift;         
-		*p2++ = -(*p1++); 
-	}
-
-	/*------------------------------------------------------------*
-	 * Compute rrixix[][] needed for the codebook search.         *
-	 * This algorithm compute impulse response energy of all      *
-	 * positions (16) in each track (4).       Total = 4x16 = 64. *
-	 *------------------------------------------------------------*/
-
-	/* storage order --> i3i3, i2i2, i1i1, i0i0 */
-
-	/* Init pointers to last position of rrixix[] */
-	p0 = &rrixix[0][NB_POS - 1];           
-	p1 = &rrixix[1][NB_POS - 1];           
-	p2 = &rrixix[2][NB_POS - 1];           
-	p3 = &rrixix[3][NB_POS - 1];           
-
-	ptr_h1 = h;                            
-	cor = 0x00008000L;                             /* for rounding */
-	for (i = 0; i < NB_POS; i++)
-	{
-		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
-		ptr_h1++;
-		*p3-- = extract_h(cor);            
-		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
-		ptr_h1++;
-		*p2-- = extract_h(cor);            
-		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
-		ptr_h1++;
-		*p1-- = extract_h(cor);            
-		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
-		ptr_h1++;
-		*p0-- = extract_h(cor);            
-	}
-
-	/*------------------------------------------------------------*
-	 * Compute rrixiy[][] needed for the codebook search.         *
-	 * This algorithm compute correlation between 2 pulses        *
-	 * (2 impulses responses) in 4 possible adjacents tracks.     *
-	 * (track 0-1, 1-2, 2-3 and 3-0).     Total = 4x16x16 = 1024. *
-	 *------------------------------------------------------------*/
-
-	/* storage order --> i2i3, i1i2, i0i1, i3i0 */
-
-	pos = MSIZE - 1;                       
-	ptr_hf = h + 1;                        
-
-	for (k = 0; k < NB_POS; k++)
-	{
-		p3 = &rrixiy[2][pos];              
-		p2 = &rrixiy[1][pos];              
-		p1 = &rrixiy[0][pos];              
-		p0 = &rrixiy[3][pos - NB_POS];     
-
-		cor = 0x00008000L;                   /* for rounding */
-		ptr_h1 = h;                        
-		ptr_h2 = ptr_hf;                   
-
-		for (i = k + 1; i < NB_POS; i++)
-		{
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p3 = extract_h(cor);          
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p2 = extract_h(cor);          
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p1 = extract_h(cor);          
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p0 = extract_h(cor);         
-
-			p3 -= (NB_POS + 1);
-			p2 -= (NB_POS + 1);
-			p1 -= (NB_POS + 1);
-			p0 -= (NB_POS + 1);
-		}
-		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-		ptr_h1++;
-		ptr_h2++;
-		*p3 = extract_h(cor);              
-		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-		ptr_h1++;
-		ptr_h2++;
-		*p2 = extract_h(cor);              
-		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-		ptr_h1++;
-		ptr_h2++;
-		*p1 = extract_h(cor);              
-
-		pos -= NB_POS;
-		ptr_hf += STEP;
-	}
-
-	/* storage order --> i3i0, i2i3, i1i2, i0i1 */
-
-	pos = MSIZE - 1;                       
-	ptr_hf = h + 3;                        
-
-	for (k = 0; k < NB_POS; k++)
-	{
-		p3 = &rrixiy[3][pos];              
-		p2 = &rrixiy[2][pos - 1];          
-		p1 = &rrixiy[1][pos - 1];          
-		p0 = &rrixiy[0][pos - 1];          
-
-		cor = 0x00008000L;								/* for rounding */
-		ptr_h1 = h;                        
-		ptr_h2 = ptr_hf;                   
-
-		for (i = k + 1; i < NB_POS; i++)
-		{
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p3 = extract_h(cor);          
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p2 = extract_h(cor);          
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p1 = extract_h(cor);          
-			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-			ptr_h1++;
-			ptr_h2++;
-			*p0 = extract_h(cor);          
-
-			p3 -= (NB_POS + 1);
-			p2 -= (NB_POS + 1);
-			p1 -= (NB_POS + 1);
-			p0 -= (NB_POS + 1);
-		}
-		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
-		ptr_h1++;
-		ptr_h2++;
-		*p3 = extract_h(cor);              
-
-		pos--;
-		ptr_hf += STEP;
-	}
-
-	/*------------------------------------------------------------*
-	 * Modification of rrixiy[][] to take signs into account.     *
-	 *------------------------------------------------------------*/
-
-	p0 = &rrixiy[0][0];                    
-
-	for (k = 0; k < NB_TRACK; k++)
-	{
-		j_temp = (k + 1)&0x03;
-		for (i = k; i < L_SUBFR; i += STEP)
-		{
-			psign = sign;                  
-			if (psign[i] < 0)
-			{
-				psign = vec;               
-			}
-			j = j_temp;
-			for (; j < L_SUBFR; j += STEP)
-			{
-				*p0 = vo_mult(*p0, psign[j]);    
-				p0++;
-			}
-		}
-	}
-
-	/*-------------------------------------------------------------------*
-	 *                       Deep first search                           *
-	 *-------------------------------------------------------------------*/
-
-	psk = -1;                              
-	alpk = 1;                              
-
-	for (k = 0; k < nbiter; k++)
-	{
-		j_temp = k<<2;
-		for (i = 0; i < nb_pulse; i++)
-			ipos[i] = tipos[j_temp + i];
-
-		if(nbbits == 20)
-		{
-			pos = 0;                       
-			ps = 0;                        
-			alp = 0;                       
-			for (i = 0; i < L_SUBFR; i++)
-			{
-				vec[i] = 0;                
-			}
-		} else if ((nbbits == 36) || (nbbits == 44))
-		{
-			/* first stage: fix 2 pulses */
-			pos = 2;
-
-			ix = ind[0] = pos_max[ipos[0]];
-			iy = ind[1] = pos_max[ipos[1]];
-			ps = dn[ix] + dn[iy];
-			i = ix >> 2;                /* ix / STEP */
-			j = iy >> 2;                /* iy / STEP */
-			s = rrixix[ipos[0]][i] << 13;
-			s += rrixix[ipos[1]][j] << 13;
-			i = (i << 4) + j;         /* (ix/STEP)*NB_POS + (iy/STEP) */
-			s += rrixiy[ipos[0]][i] << 14;
-			alp = (s + 0x8000) >> 16;
-			if (sign[ix] < 0)
-				p0 = h_inv - ix;
-			else
-				p0 = h - ix;
-			if (sign[iy] < 0)
-				p1 = h_inv - iy;
-			else
-				p1 = h - iy;
-
-			for (i = 0; i < L_SUBFR; i++)
-			{
-				vec[i] = (*p0++) + (*p1++);
-			}
-
-			if(nbbits == 44)
-			{
-				ipos[8] = 0;               
-				ipos[9] = 1;               
-			}
-		} else
-		{
-			/* first stage: fix 4 pulses */
-			pos = 4;
-
-			ix = ind[0] = pos_max[ipos[0]];  
-			iy = ind[1] = pos_max[ipos[1]];  
-			i = ind[2] = pos_max[ipos[2]];   
-			j = ind[3] = pos_max[ipos[3]];   
-			ps = add1(add1(add1(dn[ix], dn[iy]), dn[i]), dn[j]);
-
-			if (sign[ix] < 0)
-				p0 = h_inv - ix;
-			else
-				p0 = h - ix;
-
-			if (sign[iy] < 0)
-				p1 = h_inv - iy;
-			else
-				p1 = h - iy;
-
-			if (sign[i] < 0)
-				p2 = h_inv - i;
-			else
-				p2 = h - i;
-
-			if (sign[j] < 0)
-				p3 = h_inv - j;
-			else
-				p3 = h - j;
-
-			L_tmp = 0L;
-			for(i = 0; i < L_SUBFR; i++)
-			{
-				vec[i]  = add1(add1(add1(*p0++, *p1++), *p2++), *p3++);
-				L_tmp  += (vec[i] * vec[i]) << 1;
-			}
-
-			alp = ((L_tmp >> 3) + 0x8000) >> 16;
-
-			if(nbbits == 72)
-			{
-				ipos[16] = 0;              
-				ipos[17] = 1;              
-			}
-		}
-
-		/* other stages of 2 pulses */
-
-		for (j = pos, st = 0; j < nb_pulse; j += 2, st++)
-		{
-			/*--------------------------------------------------*
-			 * Calculate correlation of all possible positions  *
-			 * of the next 2 pulses with previous fixed pulses. *
-			 * Each pulse can have 16 possible positions.       *
-			 *--------------------------------------------------*/
-			if(ipos[j] == 3)
-			{
-				cor_h_vec_30(h, vec, ipos[j], sign, rrixix, cor_x, cor_y);
-			}
-			else
-			{
-#ifdef ASM_OPT                 /* asm optimization branch */
-				cor_h_vec_012_asm(h, vec, ipos[j], sign, rrixix, cor_x, cor_y);
-#else
-				cor_h_vec_012(h, vec, ipos[j], sign, rrixix, cor_x, cor_y);
-#endif
-			}
-			/*--------------------------------------------------*
-			 * Find best positions of 2 pulses.                 *
-			 *--------------------------------------------------*/
-			search_ixiy(nbpos[st], ipos[j], ipos[j + 1], &ps, &alp,
-					&ix, &iy, dn, dn2, cor_x, cor_y, rrixiy);
-
-			ind[j] = ix;                   
-			ind[j + 1] = iy;               
-
-			if (sign[ix] < 0)
-				p0 = h_inv - ix;
-			else
-				p0 = h - ix;
-			if (sign[iy] < 0)
-				p1 = h_inv - iy;
-			else
-				p1 = h - iy;
-
-			for (i = 0; i < L_SUBFR; i+=4)
-			{
-				vec[i]   += add1((*p0++), (*p1++));       
-				vec[i+1] += add1((*p0++), (*p1++));        
-				vec[i+2] += add1((*p0++), (*p1++));        
-				vec[i+3] += add1((*p0++), (*p1++));      
-			}
-		}
-		/* memorise the best codevector */
-		ps = vo_mult(ps, ps);
-		s = vo_L_msu(vo_L_mult(alpk, ps), psk, alp);
-		if (s > 0)
-		{
-			psk = ps;                      
-			alpk = alp;                    
-			for (i = 0; i < nb_pulse; i++)
-			{
-				codvec[i] = ind[i];        
-			}
-			for (i = 0; i < L_SUBFR; i++)
-			{
-				y[i] = vec[i];             
-			}
-		}
-	}
-	/*-------------------------------------------------------------------*
-	 * Build the codeword, the filtered codeword and index of codevector.*
-	 *-------------------------------------------------------------------*/
-	for (i = 0; i < NPMAXPT * NB_TRACK; i++)
-	{
-		ind[i] = -1;                       
-	}
-	for (i = 0; i < L_SUBFR; i++)
-	{
-		code[i] = 0;                       
-		y[i] = vo_shr_r(y[i], 3);               /* Q12 to Q9 */
-	}
-	val = (512 >> h_shift);               /* codeword in Q9 format */
-	for (k = 0; k < nb_pulse; k++)
-	{
-		i = codvec[k];                       /* read pulse position */
-		j = sign[i];                         /* read sign           */
-		index = i >> 2;                 /* index = pos of pulse (0..15) */
-		track = (Word16) (i & 0x03);         /* track = i % NB_TRACK (0..3)  */
-
-		if (j > 0)
-		{
-			code[i] += val;   
-			codvec[k] += 128;  
-		} else
-		{
-			code[i] -= val;   
-			index += NB_POS;    
-		}
-
-		i = (Word16)((vo_L_mult(track, NPMAXPT) >> 1));
-
-		while (ind[i] >= 0)
-		{
-			i += 1;
-		}
-		ind[i] = index;                    
-	}
-
-	k = 0;                                 
-	/* Build index of codevector */
-	if(nbbits == 20)
-	{
-		for (track = 0; track < NB_TRACK; track++)
-		{
-			_index[track] = (Word16)(quant_1p_N1(ind[k], 4));
-			k += NPMAXPT;
-		}
-	} else if(nbbits == 36)
-	{
-		for (track = 0; track < NB_TRACK; track++)
-		{
-			_index[track] = (Word16)(quant_2p_2N1(ind[k], ind[k + 1], 4));
-			k += NPMAXPT;
-		}
-	} else if(nbbits == 44)
-	{
-		for (track = 0; track < NB_TRACK - 2; track++)
-		{
-			_index[track] = (Word16)(quant_3p_3N1(ind[k], ind[k + 1], ind[k + 2], 4));
-			k += NPMAXPT;
-		}
-		for (track = 2; track < NB_TRACK; track++)
-		{
-			_index[track] = (Word16)(quant_2p_2N1(ind[k], ind[k + 1], 4));
-			k += NPMAXPT;
-		}
-	} else if(nbbits == 52)
-	{
-		for (track = 0; track < NB_TRACK; track++)
-		{
-			_index[track] = (Word16)(quant_3p_3N1(ind[k], ind[k + 1], ind[k + 2], 4));
-			k += NPMAXPT;
-		}
-	} else if(nbbits == 64)
-	{
-		for (track = 0; track < NB_TRACK; track++)
-		{
-			L_index = quant_4p_4N(&ind[k], 4);
-			_index[track] = (Word16)((L_index >> 14) & 3);
-			_index[track + NB_TRACK] = (Word16)(L_index & 0x3FFF);
-			k += NPMAXPT;
-		}
-	} else if(nbbits == 72)
-	{
-		for (track = 0; track < NB_TRACK - 2; track++)
-		{
-			L_index = quant_5p_5N(&ind[k], 4);
-			_index[track] = (Word16)((L_index >> 10) & 0x03FF);
-			_index[track + NB_TRACK] = (Word16)(L_index & 0x03FF);
-			k += NPMAXPT;
-		}
-		for (track = 2; track < NB_TRACK; track++)
-		{
-			L_index = quant_4p_4N(&ind[k], 4);
-			_index[track] = (Word16)((L_index >> 14) & 3);
-			_index[track + NB_TRACK] = (Word16)(L_index & 0x3FFF);
-			k += NPMAXPT;
-		}
-	} else if(nbbits == 88)
-	{
-		for (track = 0; track < NB_TRACK; track++)
-		{
-			L_index = quant_6p_6N_2(&ind[k], 4);
-			_index[track] = (Word16)((L_index >> 11) & 0x07FF);
-			_index[track + NB_TRACK] = (Word16)(L_index & 0x07FF);
-			k += NPMAXPT;
-		}
-	}
-	return;
-}
-
-
-/*-------------------------------------------------------------------*
- * Function  cor_h_vec()                                             *
- * ~~~~~~~~~~~~~~~~~~~~~                                             *
- * Compute correlations of h[] with vec[] for the specified track.   *
- *-------------------------------------------------------------------*/
-void cor_h_vec_30(
-		Word16 h[],                           /* (i) scaled impulse response                 */
-		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
-		Word16 track,                         /* (i) track to use                            */
-		Word16 sign[],                        /* (i) sign vector                             */
-		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
-		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
-		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
-		)
-{
-	Word32 i, j, pos, corr;
-	Word16 *p0, *p1, *p2,*p3,*cor_x,*cor_y;
-	Word32 L_sum1,L_sum2;
-	cor_x = cor_1;
-	cor_y = cor_2;
-	p0 = rrixix[track];
-	p3 = rrixix[0];
-	pos = track;
-
-	for (i = 0; i < NB_POS; i+=2)
-	{
-		L_sum1 = L_sum2 = 0L;
-		p1 = h;
-		p2 = &vec[pos];
-		for (j=pos;j < L_SUBFR; j++)
-		{
-			L_sum1 += *p1 * *p2;		
-			p2-=3;
-			L_sum2 += *p1++ * *p2;		
-			p2+=4;
-		}
-		p2-=3;
-		L_sum2 += *p1++ * *p2++;	
-		L_sum2 += *p1++ * *p2++;	
-		L_sum2 += *p1++ * *p2++;	
-
-		L_sum1 = (L_sum1 << 2);
-		L_sum2 = (L_sum2 << 2);
-
-		corr = vo_round(L_sum1);	
-		*cor_x++ = vo_mult(corr, sign[pos]) + (*p0++);
-		corr = vo_round(L_sum2);
-		*cor_y++ = vo_mult(corr, sign[pos-3]) + (*p3++);
-		pos += STEP;
-
-		L_sum1 = L_sum2 = 0L;
-		p1 = h;
-		p2 = &vec[pos];
-		for (j=pos;j < L_SUBFR; j++)
-		{
-			L_sum1 += *p1 * *p2;		
-			p2-=3;
-			L_sum2 += *p1++ * *p2;		
-			p2+=4;
-		}
-		p2-=3;
-		L_sum2 += *p1++ * *p2++;	
-		L_sum2 += *p1++ * *p2++;	
-		L_sum2 += *p1++ * *p2++;	
-
-		L_sum1 = (L_sum1 << 2);
-		L_sum2 = (L_sum2 << 2);
-
-		corr = vo_round(L_sum1);	
-		*cor_x++ = vo_mult(corr, sign[pos]) + (*p0++);
-		corr = vo_round(L_sum2);
-		*cor_y++ = vo_mult(corr, sign[pos-3]) + (*p3++);
-		pos += STEP;
-	}
-	return;
-}
-
-void cor_h_vec_012(
-		Word16 h[],                           /* (i) scaled impulse response                 */
-		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
-		Word16 track,                         /* (i) track to use                            */
-		Word16 sign[],                        /* (i) sign vector                             */
-		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
-		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
-		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
-		)
-{
-	Word32 i, j, pos, corr;
-	Word16 *p0, *p1, *p2,*p3,*cor_x,*cor_y;
-	Word32 L_sum1,L_sum2;
-	cor_x = cor_1;
-	cor_y = cor_2;
-	p0 = rrixix[track];
-	p3 = rrixix[track+1];
-	pos = track;
-
-	for (i = 0; i < NB_POS; i+=2)
-	{
-		L_sum1 = L_sum2 = 0L;
-		p1 = h;
-		p2 = &vec[pos];
-		for (j=62-pos ;j >= 0; j--)
-		{
-			L_sum1 += *p1 * *p2++;
-			L_sum2 += *p1++ * *p2;
-		}
-		L_sum1 += *p1 * *p2;
-		L_sum1 = (L_sum1 << 2);
-		L_sum2 = (L_sum2 << 2);
-
-		corr = (L_sum1 + 0x8000) >> 16;
-		cor_x[i] = vo_mult(corr, sign[pos]) + (*p0++);
-		corr = (L_sum2 + 0x8000) >> 16;
-		cor_y[i] = vo_mult(corr, sign[pos + 1]) + (*p3++);
-		pos += STEP;
-
-		L_sum1 = L_sum2 = 0L;
-		p1 = h;
-		p2 = &vec[pos];
-		for (j= 62-pos;j >= 0; j--)
-		{
-			L_sum1 += *p1 * *p2++;
-			L_sum2 += *p1++ * *p2;
-		}
-		L_sum1 += *p1 * *p2;
-		L_sum1 = (L_sum1 << 2);
-		L_sum2 = (L_sum2 << 2);
-
-		corr = (L_sum1 + 0x8000) >> 16;
-		cor_x[i+1] = vo_mult(corr, sign[pos]) + (*p0++);
-		corr = (L_sum2 + 0x8000) >> 16;
-		cor_y[i+1] = vo_mult(corr, sign[pos + 1]) + (*p3++);
-		pos += STEP;
-	}
-	return;
-}
-
-/*-------------------------------------------------------------------*
- * Function  search_ixiy()                                           *
- * ~~~~~~~~~~~~~~~~~~~~~~~                                           *
- * Find the best positions of 2 pulses in a subframe.                *
- *-------------------------------------------------------------------*/
-
-void search_ixiy(
-		Word16 nb_pos_ix,                     /* (i) nb of pos for pulse 1 (1..8)       */
-		Word16 track_x,                       /* (i) track of pulse 1                   */
-		Word16 track_y,                       /* (i) track of pulse 2                   */
-		Word16 * ps,                          /* (i/o) correlation of all fixed pulses  */
-		Word16 * alp,                         /* (i/o) energy of all fixed pulses       */
-		Word16 * ix,                          /* (o) position of pulse 1                */
-		Word16 * iy,                          /* (o) position of pulse 2                */
-		Word16 dn[],                          /* (i) corr. between target and h[]       */
-		Word16 dn2[],                         /* (i) vector of selected positions       */
-		Word16 cor_x[],                       /* (i) corr. of pulse 1 with fixed pulses */
-		Word16 cor_y[],                       /* (i) corr. of pulse 2 with fixed pulses */
-		Word16 rrixiy[][MSIZE]                /* (i) corr. of pulse 1 with pulse 2   */
-		)
-{
-	Word32 x, y, pos, thres_ix;
-	Word16 ps1, ps2, sq, sqk;
-	Word16 alp_16, alpk;
-	Word16 *p0, *p1, *p2;
-	Word32 s, alp0, alp1, alp2;
-
-	p0 = cor_x;                            
-	p1 = cor_y;                            
-	p2 = rrixiy[track_x];                  
-
-	thres_ix = nb_pos_ix - NB_MAX;
-
-	alp0 = L_deposit_h(*alp);
-	alp0 = (alp0 + 0x00008000L);       /* for rounding */
-
-	sqk = -1;                              
-	alpk = 1;                              
-
-	for (x = track_x; x < L_SUBFR; x += STEP)
-	{
-		ps1 = *ps + dn[x];
-		alp1 = alp0 + ((*p0++)<<13);
-
-		if (dn2[x] < thres_ix)
-		{
-			pos = -1;
-			for (y = track_y; y < L_SUBFR; y += STEP)
-			{
-				ps2 = add1(ps1, dn[y]);
-
-				alp2 = alp1 + ((*p1++)<<13);
-				alp2 = alp2 + ((*p2++)<<14);
-				alp_16 = extract_h(alp2);
-				sq = vo_mult(ps2, ps2);
-				s = vo_L_mult(alpk, sq) - ((sqk * alp_16)<<1);
-
-				if (s > 0)
-				{
-					sqk = sq;              
-					alpk = alp_16;         
-					pos = y;               
-				}
-			}
-			p1 -= NB_POS;
-
-			if (pos >= 0)
-			{
-				*ix = x;                   
-				*iy = pos;                 
-			}
-		} else
-		{
-			p2 += NB_POS;
-		}
-	}
-
-	*ps = add1(*ps, add1(dn[*ix], dn[*iy])); 
-	*alp = alpk;                           
-
-	return;
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: c4t64fx.c                                                 *
+*                                                                      *
+*	   Description:Performs algebraic codebook search for higher modes *
+*                                                                      *
+************************************************************************/
+
+/************************************************************************
+* Function: ACELP_4t64_fx()                                             *
+*                                                                       *
+* 20, 36, 44, 52, 64, 72, 88 bits algebraic codebook.                   *
+* 4 tracks x 16 positions per track = 64 samples.                       *
+*                                                                       *
+* 20 bits --> 4 pulses in a frame of 64 samples.                        *
+* 36 bits --> 8 pulses in a frame of 64 samples.                        *
+* 44 bits --> 10 pulses in a frame of 64 samples.                       *
+* 52 bits --> 12 pulses in a frame of 64 samples.                       *
+* 64 bits --> 16 pulses in a frame of 64 samples.                       *
+* 72 bits --> 18 pulses in a frame of 64 samples.                       *
+* 88 bits --> 24 pulses in a frame of 64 samples.                       *
+*                                                                       *
+* All pulses can have two (2) possible amplitudes: +1 or -1.            *
+* Each pulse can have sixteen (16) possible positions.                  *
+*************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+#include "acelp.h"
+#include "cnst.h"
+
+#include "q_pulse.h"
+
+static Word16 tipos[36] = {
+	0, 1, 2, 3,                            /* starting point &ipos[0], 1st iter */
+	1, 2, 3, 0,                            /* starting point &ipos[4], 2nd iter */
+	2, 3, 0, 1,                            /* starting point &ipos[8], 3rd iter */
+	3, 0, 1, 2,                            /* starting point &ipos[12], 4th iter */
+	0, 1, 2, 3,
+	1, 2, 3, 0,
+	2, 3, 0, 1,
+	3, 0, 1, 2,
+	0, 1, 2, 3};                           /* end point for 24 pulses &ipos[35], 4th iter */
+
+#define NB_PULSE_MAX  24
+
+#define L_SUBFR   64
+#define NB_TRACK  4
+#define STEP      4
+#define NB_POS    16
+#define MSIZE     256
+#define NB_MAX    8
+#define NPMAXPT   ((NB_PULSE_MAX+NB_TRACK-1)/NB_TRACK)
+
+/* Private functions */
+void cor_h_vec_012(
+		Word16 h[],                           /* (i) scaled impulse response                 */
+		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
+		Word16 track,                         /* (i) track to use                            */
+		Word16 sign[],                        /* (i) sign vector                             */
+		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
+		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
+		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
+		);
+
+void cor_h_vec_012_asm(
+		Word16 h[],                           /* (i) scaled impulse response                 */
+		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
+		Word16 track,                         /* (i) track to use                            */
+		Word16 sign[],                        /* (i) sign vector                             */
+		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
+		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
+		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
+		);
+
+void cor_h_vec_30(
+		Word16 h[],                           /* (i) scaled impulse response                 */
+		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
+		Word16 track,                         /* (i) track to use                            */
+		Word16 sign[],                        /* (i) sign vector                             */
+		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
+		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
+		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
+		);
+
+void search_ixiy(
+		Word16 nb_pos_ix,                     /* (i) nb of pos for pulse 1 (1..8)       */
+		Word16 track_x,                       /* (i) track of pulse 1                   */
+		Word16 track_y,                       /* (i) track of pulse 2                   */
+		Word16 * ps,                          /* (i/o) correlation of all fixed pulses  */
+		Word16 * alp,                         /* (i/o) energy of all fixed pulses       */
+		Word16 * ix,                          /* (o) position of pulse 1                */
+		Word16 * iy,                          /* (o) position of pulse 2                */
+		Word16 dn[],                          /* (i) corr. between target and h[]       */
+		Word16 dn2[],                         /* (i) vector of selected positions       */
+		Word16 cor_x[],                       /* (i) corr. of pulse 1 with fixed pulses */
+		Word16 cor_y[],                       /* (i) corr. of pulse 2 with fixed pulses */
+		Word16 rrixiy[][MSIZE]                /* (i) corr. of pulse 1 with pulse 2   */
+		);
+
+
+void ACELP_4t64_fx(
+		Word16 dn[],                          /* (i) <12b : correlation between target x[] and H[]      */
+		Word16 cn[],                          /* (i) <12b : residual after long term prediction         */
+		Word16 H[],                           /* (i) Q12: impulse response of weighted synthesis filter */
+		Word16 code[],                        /* (o) Q9 : algebraic (fixed) codebook excitation         */
+		Word16 y[],                           /* (o) Q9 : filtered fixed codebook excitation            */
+		Word16 nbbits,                        /* (i) : 20, 36, 44, 52, 64, 72 or 88 bits                */
+		Word16 ser_size,                      /* (i) : bit rate                                         */
+		Word16 _index[]                       /* (o) : index (20): 5+5+5+5 = 20 bits.                   */
+		/* (o) : index (36): 9+9+9+9 = 36 bits.                   */
+		/* (o) : index (44): 13+9+13+9 = 44 bits.                 */
+		/* (o) : index (52): 13+13+13+13 = 52 bits.               */
+		/* (o) : index (64): 2+2+2+2+14+14+14+14 = 64 bits.       */
+		/* (o) : index (72): 10+2+10+2+10+14+10+14 = 72 bits.     */
+		/* (o) : index (88): 11+11+11+11+11+11+11+11 = 88 bits.   */
+		)
+{
+	Word32 i, j, k;
+	Word16 st, ix, iy, pos, index, track, nb_pulse, nbiter, j_temp;
+	Word16 psk, ps, alpk, alp, val, k_cn, k_dn, exp;
+	Word16 *p0, *p1, *p2, *p3, *psign;
+	Word16 *h, *h_inv, *ptr_h1, *ptr_h2, *ptr_hf, h_shift;
+	Word32 s, cor, L_tmp, L_index;
+	Word16 dn2[L_SUBFR], sign[L_SUBFR], vec[L_SUBFR];
+	Word16 ind[NPMAXPT * NB_TRACK];
+	Word16 codvec[NB_PULSE_MAX], nbpos[10];
+	Word16 cor_x[NB_POS], cor_y[NB_POS], pos_max[NB_TRACK];
+	Word16 h_buf[4 * L_SUBFR];
+	Word16 rrixix[NB_TRACK][NB_POS], rrixiy[NB_TRACK][MSIZE];
+	Word16 ipos[NB_PULSE_MAX];
+
+	switch (nbbits)
+	{
+		case 20:                               /* 20 bits, 4 pulses, 4 tracks */
+			nbiter = 4;                          /* 4x16x16=1024 loop */
+			alp = 8192;                          /* alp = 2.0 (Q12) */
+			nb_pulse = 4;
+			nbpos[0] = 4;
+			nbpos[1] = 8;
+			break;
+		case 36:                               /* 36 bits, 8 pulses, 4 tracks */
+			nbiter = 4;                          /* 4x20x16=1280 loop */
+			alp = 4096;                          /* alp = 1.0 (Q12) */
+			nb_pulse = 8;
+			nbpos[0] = 4;
+			nbpos[1] = 8;
+			nbpos[2] = 8;
+			break;
+		case 44:                               /* 44 bits, 10 pulses, 4 tracks */
+			nbiter = 4;                          /* 4x26x16=1664 loop */
+			alp = 4096;                          /* alp = 1.0 (Q12) */
+			nb_pulse = 10;
+			nbpos[0] = 4;
+			nbpos[1] = 6;
+			nbpos[2] = 8;
+			nbpos[3] = 8;
+			break;
+		case 52:                               /* 52 bits, 12 pulses, 4 tracks */
+			nbiter = 4;                          /* 4x26x16=1664 loop */
+			alp = 4096;                          /* alp = 1.0 (Q12) */
+			nb_pulse = 12;
+			nbpos[0] = 4;
+			nbpos[1] = 6;
+			nbpos[2] = 8;
+			nbpos[3] = 8;
+			break;
+		case 64:                               /* 64 bits, 16 pulses, 4 tracks */
+			nbiter = 3;                          /* 3x36x16=1728 loop */
+			alp = 3277;                          /* alp = 0.8 (Q12) */
+			nb_pulse = 16;
+			nbpos[0] = 4;
+			nbpos[1] = 4;
+			nbpos[2] = 6;
+			nbpos[3] = 6;
+			nbpos[4] = 8;
+			nbpos[5] = 8;
+			break;
+		case 72:                               /* 72 bits, 18 pulses, 4 tracks */
+			nbiter = 3;                          /* 3x35x16=1680 loop */
+			alp = 3072;                          /* alp = 0.75 (Q12) */
+			nb_pulse = 18;
+			nbpos[0] = 2;
+			nbpos[1] = 3;
+			nbpos[2] = 4;
+			nbpos[3] = 5;
+			nbpos[4] = 6;
+			nbpos[5] = 7;
+			nbpos[6] = 8;
+			break;
+		case 88:                               /* 88 bits, 24 pulses, 4 tracks */
+			if(ser_size > 462)
+				nbiter = 1;
+			else
+				nbiter = 2;                    /* 2x53x16=1696 loop */
+
+			alp = 2048;                          /* alp = 0.5 (Q12) */
+			nb_pulse = 24;
+			nbpos[0] = 2;
+			nbpos[1] = 2;
+			nbpos[2] = 3;
+			nbpos[3] = 4;
+			nbpos[4] = 5;
+			nbpos[5] = 6;
+			nbpos[6] = 7;
+			nbpos[7] = 8;
+			nbpos[8] = 8;
+			nbpos[9] = 8;
+			break;
+		default:
+			nbiter = 0;
+			alp = 0;
+			nb_pulse = 0;
+	}
+
+	for (i = 0; i < nb_pulse; i++)
+	{
+		codvec[i] = i;
+	}
+
+	/*----------------------------------------------------------------*
+	 * Find sign for each pulse position.                             *
+	 *----------------------------------------------------------------*/
+	/* calculate energy for normalization of cn[] and dn[] */
+	/* set k_cn = 32..32767 (ener_cn = 2^30..256-0) */
+#ifdef ASM_OPT                  /* asm optimization branch */
+	s = Dot_product12_asm(cn, cn, L_SUBFR, &exp);
+#else
+	s = Dot_product12(cn, cn, L_SUBFR, &exp);
+#endif
+
+	Isqrt_n(&s, &exp);
+	s = L_shl(s, (exp + 5));
+	k_cn = extract_h(L_add(s, 0x8000));
+
+	/* set k_dn = 32..512 (ener_dn = 2^30..2^22) */
+#ifdef ASM_OPT                      /* asm optimization branch */
+	s = Dot_product12_asm(dn, dn, L_SUBFR, &exp);
+#else
+	s = Dot_product12(dn, dn, L_SUBFR, &exp);
+#endif
+
+	Isqrt_n(&s, &exp);
+	k_dn = (L_shl(s, (exp + 5 + 3)) + 0x8000) >> 16;    /* k_dn = 256..4096 */
+	k_dn = vo_mult_r(alp, k_dn);              /* alp in Q12 */
+
+	/* mix normalized cn[] and dn[] */
+	p0 = cn;
+	p1 = dn;
+	p2 = dn2;
+
+	for (i = 0; i < L_SUBFR/4; i++)
+	{
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+		s = (k_cn* (*p0++))+(k_dn * (*p1++));
+		*p2++ = s >> 7;
+	}
+
+	/* set sign according to dn2[] = k_cn*cn[] + k_dn*dn[]    */
+	for(i = 0; i < L_SUBFR; i++)
+	{
+		val = dn[i];
+		ps = dn2[i];
+		if (ps >= 0)
+		{
+			sign[i] = 32767;             /* sign = +1 (Q12) */
+			vec[i] = -32768;
+		} else
+		{
+			sign[i] = -32768;            /* sign = -1 (Q12) */
+			vec[i] = 32767;
+			dn[i] = -val;
+			dn2[i] = -ps;
+		}
+	}
+	/*----------------------------------------------------------------*
+	 * Select NB_MAX position per track according to max of dn2[].    *
+	 *----------------------------------------------------------------*/
+	pos = 0;
+	for (i = 0; i < NB_TRACK; i++)
+	{
+		for (k = 0; k < NB_MAX; k++)
+		{
+			ps = -1;
+			for (j = i; j < L_SUBFR; j += STEP)
+			{
+				if(dn2[j] > ps)
+				{
+					ps = dn2[j];
+					pos = j;
+				}
+			}
+			dn2[pos] = (k - NB_MAX);     /* dn2 < 0 when position is selected */
+			if (k == 0)
+			{
+				pos_max[i] = pos;
+			}
+		}
+	}
+
+	/*--------------------------------------------------------------*
+	 * Scale h[] to avoid overflow and to get maximum of precision  *
+	 * on correlation.                                              *
+	 *                                                              *
+	 * Maximum of h[] (h[0]) is fixed to 2048 (MAX16 / 16).         *
+	 *  ==> This allow addition of 16 pulses without saturation.    *
+	 *                                                              *
+	 * Energy worst case (on resonant impulse response),            *
+	 * - energy of h[] is approximately MAX/16.                     *
+	 * - During search, the energy is divided by 8 to avoid         *
+	 *   overflow on "alp". (energy of h[] = MAX/128).              *
+	 *  ==> "alp" worst case detected is 22854 on sinusoidal wave.  *
+	 *--------------------------------------------------------------*/
+
+	/* impulse response buffer for fast computation */
+
+	h = h_buf;
+	h_inv = h_buf + (2 * L_SUBFR);
+	L_tmp = 0;
+	for (i = 0; i < L_SUBFR; i++)
+	{
+		*h++ = 0;
+		*h_inv++ = 0;
+		L_tmp += (H[i] * H[i]) << 1;
+	}
+	/* scale h[] down (/2) when energy of h[] is high with many pulses used */
+	val = extract_h(L_tmp);
+	h_shift = 0;
+
+	if ((nb_pulse >= 12) && (val > 1024))
+	{
+		h_shift = 1;
+	}
+	p0 = H;
+	p1 = h;
+	p2 = h_inv;
+
+	for (i = 0; i < L_SUBFR/4; i++)
+	{
+		*p1 = *p0++ >> h_shift;
+		*p2++ = -(*p1++);
+		*p1 = *p0++ >> h_shift;
+		*p2++ = -(*p1++);
+		*p1 = *p0++ >> h_shift;
+		*p2++ = -(*p1++);
+		*p1 = *p0++ >> h_shift;
+		*p2++ = -(*p1++);
+	}
+
+	/*------------------------------------------------------------*
+	 * Compute rrixix[][] needed for the codebook search.         *
+	 * This algorithm compute impulse response energy of all      *
+	 * positions (16) in each track (4).       Total = 4x16 = 64. *
+	 *------------------------------------------------------------*/
+
+	/* storage order --> i3i3, i2i2, i1i1, i0i0 */
+
+	/* Init pointers to last position of rrixix[] */
+	p0 = &rrixix[0][NB_POS - 1];
+	p1 = &rrixix[1][NB_POS - 1];
+	p2 = &rrixix[2][NB_POS - 1];
+	p3 = &rrixix[3][NB_POS - 1];
+
+	ptr_h1 = h;
+	cor = 0x00008000L;                             /* for rounding */
+	for (i = 0; i < NB_POS; i++)
+	{
+		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
+		ptr_h1++;
+		*p3-- = extract_h(cor);
+		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
+		ptr_h1++;
+		*p2-- = extract_h(cor);
+		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
+		ptr_h1++;
+		*p1-- = extract_h(cor);
+		cor += vo_L_mult((*ptr_h1), (*ptr_h1));
+		ptr_h1++;
+		*p0-- = extract_h(cor);
+	}
+
+	/*------------------------------------------------------------*
+	 * Compute rrixiy[][] needed for the codebook search.         *
+	 * This algorithm compute correlation between 2 pulses        *
+	 * (2 impulses responses) in 4 possible adjacents tracks.     *
+	 * (track 0-1, 1-2, 2-3 and 3-0).     Total = 4x16x16 = 1024. *
+	 *------------------------------------------------------------*/
+
+	/* storage order --> i2i3, i1i2, i0i1, i3i0 */
+
+	pos = MSIZE - 1;
+	ptr_hf = h + 1;
+
+	for (k = 0; k < NB_POS; k++)
+	{
+		p3 = &rrixiy[2][pos];
+		p2 = &rrixiy[1][pos];
+		p1 = &rrixiy[0][pos];
+		p0 = &rrixiy[3][pos - NB_POS];
+
+		cor = 0x00008000L;                   /* for rounding */
+		ptr_h1 = h;
+		ptr_h2 = ptr_hf;
+
+		for (i = k + 1; i < NB_POS; i++)
+		{
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p3 = extract_h(cor);
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p2 = extract_h(cor);
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p1 = extract_h(cor);
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p0 = extract_h(cor);
+
+			p3 -= (NB_POS + 1);
+			p2 -= (NB_POS + 1);
+			p1 -= (NB_POS + 1);
+			p0 -= (NB_POS + 1);
+		}
+		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+		ptr_h1++;
+		ptr_h2++;
+		*p3 = extract_h(cor);
+		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+		ptr_h1++;
+		ptr_h2++;
+		*p2 = extract_h(cor);
+		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+		ptr_h1++;
+		ptr_h2++;
+		*p1 = extract_h(cor);
+
+		pos -= NB_POS;
+		ptr_hf += STEP;
+	}
+
+	/* storage order --> i3i0, i2i3, i1i2, i0i1 */
+
+	pos = MSIZE - 1;
+	ptr_hf = h + 3;
+
+	for (k = 0; k < NB_POS; k++)
+	{
+		p3 = &rrixiy[3][pos];
+		p2 = &rrixiy[2][pos - 1];
+		p1 = &rrixiy[1][pos - 1];
+		p0 = &rrixiy[0][pos - 1];
+
+		cor = 0x00008000L;								/* for rounding */
+		ptr_h1 = h;
+		ptr_h2 = ptr_hf;
+
+		for (i = k + 1; i < NB_POS; i++)
+		{
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p3 = extract_h(cor);
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p2 = extract_h(cor);
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p1 = extract_h(cor);
+			cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+			ptr_h1++;
+			ptr_h2++;
+			*p0 = extract_h(cor);
+
+			p3 -= (NB_POS + 1);
+			p2 -= (NB_POS + 1);
+			p1 -= (NB_POS + 1);
+			p0 -= (NB_POS + 1);
+		}
+		cor += vo_L_mult((*ptr_h1), (*ptr_h2));
+		ptr_h1++;
+		ptr_h2++;
+		*p3 = extract_h(cor);
+
+		pos--;
+		ptr_hf += STEP;
+	}
+
+	/*------------------------------------------------------------*
+	 * Modification of rrixiy[][] to take signs into account.     *
+	 *------------------------------------------------------------*/
+
+	p0 = &rrixiy[0][0];
+
+	for (k = 0; k < NB_TRACK; k++)
+	{
+		j_temp = (k + 1)&0x03;
+		for (i = k; i < L_SUBFR; i += STEP)
+		{
+			psign = sign;
+			if (psign[i] < 0)
+			{
+				psign = vec;
+			}
+			j = j_temp;
+			for (; j < L_SUBFR; j += STEP)
+			{
+				*p0 = vo_mult(*p0, psign[j]);
+				p0++;
+			}
+		}
+	}
+
+	/*-------------------------------------------------------------------*
+	 *                       Deep first search                           *
+	 *-------------------------------------------------------------------*/
+
+	psk = -1;
+	alpk = 1;
+
+	for (k = 0; k < nbiter; k++)
+	{
+		j_temp = k<<2;
+		for (i = 0; i < nb_pulse; i++)
+			ipos[i] = tipos[j_temp + i];
+
+		if(nbbits == 20)
+		{
+			pos = 0;
+			ps = 0;
+			alp = 0;
+			for (i = 0; i < L_SUBFR; i++)
+			{
+				vec[i] = 0;
+			}
+		} else if ((nbbits == 36) || (nbbits == 44))
+		{
+			/* first stage: fix 2 pulses */
+			pos = 2;
+
+			ix = ind[0] = pos_max[ipos[0]];
+			iy = ind[1] = pos_max[ipos[1]];
+			ps = dn[ix] + dn[iy];
+			i = ix >> 2;                /* ix / STEP */
+			j = iy >> 2;                /* iy / STEP */
+			s = rrixix[ipos[0]][i] << 13;
+			s += rrixix[ipos[1]][j] << 13;
+			i = (i << 4) + j;         /* (ix/STEP)*NB_POS + (iy/STEP) */
+			s += rrixiy[ipos[0]][i] << 14;
+			alp = (s + 0x8000) >> 16;
+			if (sign[ix] < 0)
+				p0 = h_inv - ix;
+			else
+				p0 = h - ix;
+			if (sign[iy] < 0)
+				p1 = h_inv - iy;
+			else
+				p1 = h - iy;
+
+			for (i = 0; i < L_SUBFR; i++)
+			{
+				vec[i] = (*p0++) + (*p1++);
+			}
+
+			if(nbbits == 44)
+			{
+				ipos[8] = 0;
+				ipos[9] = 1;
+			}
+		} else
+		{
+			/* first stage: fix 4 pulses */
+			pos = 4;
+
+			ix = ind[0] = pos_max[ipos[0]];
+			iy = ind[1] = pos_max[ipos[1]];
+			i = ind[2] = pos_max[ipos[2]];
+			j = ind[3] = pos_max[ipos[3]];
+			ps = add1(add1(add1(dn[ix], dn[iy]), dn[i]), dn[j]);
+
+			if (sign[ix] < 0)
+				p0 = h_inv - ix;
+			else
+				p0 = h - ix;
+
+			if (sign[iy] < 0)
+				p1 = h_inv - iy;
+			else
+				p1 = h - iy;
+
+			if (sign[i] < 0)
+				p2 = h_inv - i;
+			else
+				p2 = h - i;
+
+			if (sign[j] < 0)
+				p3 = h_inv - j;
+			else
+				p3 = h - j;
+
+			L_tmp = 0L;
+			for(i = 0; i < L_SUBFR; i++)
+			{
+				vec[i]  = add1(add1(add1(*p0++, *p1++), *p2++), *p3++);
+				L_tmp  += (vec[i] * vec[i]) << 1;
+			}
+
+			alp = ((L_tmp >> 3) + 0x8000) >> 16;
+
+			if(nbbits == 72)
+			{
+				ipos[16] = 0;
+				ipos[17] = 1;
+			}
+		}
+
+		/* other stages of 2 pulses */
+
+		for (j = pos, st = 0; j < nb_pulse; j += 2, st++)
+		{
+			/*--------------------------------------------------*
+			 * Calculate correlation of all possible positions  *
+			 * of the next 2 pulses with previous fixed pulses. *
+			 * Each pulse can have 16 possible positions.       *
+			 *--------------------------------------------------*/
+			if(ipos[j] == 3)
+			{
+				cor_h_vec_30(h, vec, ipos[j], sign, rrixix, cor_x, cor_y);
+			}
+			else
+			{
+#ifdef ASM_OPT                 /* asm optimization branch */
+				cor_h_vec_012_asm(h, vec, ipos[j], sign, rrixix, cor_x, cor_y);
+#else
+				cor_h_vec_012(h, vec, ipos[j], sign, rrixix, cor_x, cor_y);
+#endif
+			}
+			/*--------------------------------------------------*
+			 * Find best positions of 2 pulses.                 *
+			 *--------------------------------------------------*/
+			search_ixiy(nbpos[st], ipos[j], ipos[j + 1], &ps, &alp,
+					&ix, &iy, dn, dn2, cor_x, cor_y, rrixiy);
+
+			ind[j] = ix;
+			ind[j + 1] = iy;
+
+			if (sign[ix] < 0)
+				p0 = h_inv - ix;
+			else
+				p0 = h - ix;
+			if (sign[iy] < 0)
+				p1 = h_inv - iy;
+			else
+				p1 = h - iy;
+
+			for (i = 0; i < L_SUBFR; i+=4)
+			{
+				vec[i]   += add1((*p0++), (*p1++));
+				vec[i+1] += add1((*p0++), (*p1++));
+				vec[i+2] += add1((*p0++), (*p1++));
+				vec[i+3] += add1((*p0++), (*p1++));
+			}
+		}
+		/* memorise the best codevector */
+		ps = vo_mult(ps, ps);
+		s = vo_L_msu(vo_L_mult(alpk, ps), psk, alp);
+		if (s > 0)
+		{
+			psk = ps;
+			alpk = alp;
+			for (i = 0; i < nb_pulse; i++)
+			{
+				codvec[i] = ind[i];
+			}
+			for (i = 0; i < L_SUBFR; i++)
+			{
+				y[i] = vec[i];
+			}
+		}
+	}
+	/*-------------------------------------------------------------------*
+	 * Build the codeword, the filtered codeword and index of codevector.*
+	 *-------------------------------------------------------------------*/
+	for (i = 0; i < NPMAXPT * NB_TRACK; i++)
+	{
+		ind[i] = -1;
+	}
+	for (i = 0; i < L_SUBFR; i++)
+	{
+		code[i] = 0;
+		y[i] = vo_shr_r(y[i], 3);               /* Q12 to Q9 */
+	}
+	val = (512 >> h_shift);               /* codeword in Q9 format */
+	for (k = 0; k < nb_pulse; k++)
+	{
+		i = codvec[k];                       /* read pulse position */
+		j = sign[i];                         /* read sign           */
+		index = i >> 2;                 /* index = pos of pulse (0..15) */
+		track = (Word16) (i & 0x03);         /* track = i % NB_TRACK (0..3)  */
+
+		if (j > 0)
+		{
+			code[i] += val;
+			codvec[k] += 128;
+		} else
+		{
+			code[i] -= val;
+			index += NB_POS;
+		}
+
+		i = (Word16)((vo_L_mult(track, NPMAXPT) >> 1));
+
+		while (ind[i] >= 0)
+		{
+			i += 1;
+		}
+		ind[i] = index;
+	}
+
+	k = 0;
+	/* Build index of codevector */
+	if(nbbits == 20)
+	{
+		for (track = 0; track < NB_TRACK; track++)
+		{
+			_index[track] = (Word16)(quant_1p_N1(ind[k], 4));
+			k += NPMAXPT;
+		}
+	} else if(nbbits == 36)
+	{
+		for (track = 0; track < NB_TRACK; track++)
+		{
+			_index[track] = (Word16)(quant_2p_2N1(ind[k], ind[k + 1], 4));
+			k += NPMAXPT;
+		}
+	} else if(nbbits == 44)
+	{
+		for (track = 0; track < NB_TRACK - 2; track++)
+		{
+			_index[track] = (Word16)(quant_3p_3N1(ind[k], ind[k + 1], ind[k + 2], 4));
+			k += NPMAXPT;
+		}
+		for (track = 2; track < NB_TRACK; track++)
+		{
+			_index[track] = (Word16)(quant_2p_2N1(ind[k], ind[k + 1], 4));
+			k += NPMAXPT;
+		}
+	} else if(nbbits == 52)
+	{
+		for (track = 0; track < NB_TRACK; track++)
+		{
+			_index[track] = (Word16)(quant_3p_3N1(ind[k], ind[k + 1], ind[k + 2], 4));
+			k += NPMAXPT;
+		}
+	} else if(nbbits == 64)
+	{
+		for (track = 0; track < NB_TRACK; track++)
+		{
+			L_index = quant_4p_4N(&ind[k], 4);
+			_index[track] = (Word16)((L_index >> 14) & 3);
+			_index[track + NB_TRACK] = (Word16)(L_index & 0x3FFF);
+			k += NPMAXPT;
+		}
+	} else if(nbbits == 72)
+	{
+		for (track = 0; track < NB_TRACK - 2; track++)
+		{
+			L_index = quant_5p_5N(&ind[k], 4);
+			_index[track] = (Word16)((L_index >> 10) & 0x03FF);
+			_index[track + NB_TRACK] = (Word16)(L_index & 0x03FF);
+			k += NPMAXPT;
+		}
+		for (track = 2; track < NB_TRACK; track++)
+		{
+			L_index = quant_4p_4N(&ind[k], 4);
+			_index[track] = (Word16)((L_index >> 14) & 3);
+			_index[track + NB_TRACK] = (Word16)(L_index & 0x3FFF);
+			k += NPMAXPT;
+		}
+	} else if(nbbits == 88)
+	{
+		for (track = 0; track < NB_TRACK; track++)
+		{
+			L_index = quant_6p_6N_2(&ind[k], 4);
+			_index[track] = (Word16)((L_index >> 11) & 0x07FF);
+			_index[track + NB_TRACK] = (Word16)(L_index & 0x07FF);
+			k += NPMAXPT;
+		}
+	}
+	return;
+}
+
+
+/*-------------------------------------------------------------------*
+ * Function  cor_h_vec()                                             *
+ * ~~~~~~~~~~~~~~~~~~~~~                                             *
+ * Compute correlations of h[] with vec[] for the specified track.   *
+ *-------------------------------------------------------------------*/
+void cor_h_vec_30(
+		Word16 h[],                           /* (i) scaled impulse response                 */
+		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
+		Word16 track,                         /* (i) track to use                            */
+		Word16 sign[],                        /* (i) sign vector                             */
+		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
+		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
+		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
+		)
+{
+	Word32 i, j, pos, corr;
+	Word16 *p0, *p1, *p2,*p3,*cor_x,*cor_y;
+	Word32 L_sum1,L_sum2;
+	cor_x = cor_1;
+	cor_y = cor_2;
+	p0 = rrixix[track];
+	p3 = rrixix[0];
+	pos = track;
+
+	for (i = 0; i < NB_POS; i+=2)
+	{
+		L_sum1 = L_sum2 = 0L;
+		p1 = h;
+		p2 = &vec[pos];
+		for (j=pos;j < L_SUBFR; j++)
+		{
+			L_sum1 += *p1 * *p2;
+			p2-=3;
+			L_sum2 += *p1++ * *p2;
+			p2+=4;
+		}
+		p2-=3;
+		L_sum2 += *p1++ * *p2++;
+		L_sum2 += *p1++ * *p2++;
+		L_sum2 += *p1++ * *p2++;
+
+		L_sum1 = (L_sum1 << 2);
+		L_sum2 = (L_sum2 << 2);
+
+		corr = vo_round(L_sum1);
+		*cor_x++ = vo_mult(corr, sign[pos]) + (*p0++);
+		corr = vo_round(L_sum2);
+		*cor_y++ = vo_mult(corr, sign[pos-3]) + (*p3++);
+		pos += STEP;
+
+		L_sum1 = L_sum2 = 0L;
+		p1 = h;
+		p2 = &vec[pos];
+		for (j=pos;j < L_SUBFR; j++)
+		{
+			L_sum1 += *p1 * *p2;
+			p2-=3;
+			L_sum2 += *p1++ * *p2;
+			p2+=4;
+		}
+		p2-=3;
+		L_sum2 += *p1++ * *p2++;
+		L_sum2 += *p1++ * *p2++;
+		L_sum2 += *p1++ * *p2++;
+
+		L_sum1 = (L_sum1 << 2);
+		L_sum2 = (L_sum2 << 2);
+
+		corr = vo_round(L_sum1);
+		*cor_x++ = vo_mult(corr, sign[pos]) + (*p0++);
+		corr = vo_round(L_sum2);
+		*cor_y++ = vo_mult(corr, sign[pos-3]) + (*p3++);
+		pos += STEP;
+	}
+	return;
+}
+
+void cor_h_vec_012(
+		Word16 h[],                           /* (i) scaled impulse response                 */
+		Word16 vec[],                         /* (i) scaled vector (/8) to correlate with h[] */
+		Word16 track,                         /* (i) track to use                            */
+		Word16 sign[],                        /* (i) sign vector                             */
+		Word16 rrixix[][NB_POS],              /* (i) correlation of h[x] with h[x]      */
+		Word16 cor_1[],                       /* (o) result of correlation (NB_POS elements) */
+		Word16 cor_2[]                        /* (o) result of correlation (NB_POS elements) */
+		)
+{
+	Word32 i, j, pos, corr;
+	Word16 *p0, *p1, *p2,*p3,*cor_x,*cor_y;
+	Word32 L_sum1,L_sum2;
+	cor_x = cor_1;
+	cor_y = cor_2;
+	p0 = rrixix[track];
+	p3 = rrixix[track+1];
+	pos = track;
+
+	for (i = 0; i < NB_POS; i+=2)
+	{
+		L_sum1 = L_sum2 = 0L;
+		p1 = h;
+		p2 = &vec[pos];
+		for (j=62-pos ;j >= 0; j--)
+		{
+			L_sum1 += *p1 * *p2++;
+			L_sum2 += *p1++ * *p2;
+		}
+		L_sum1 += *p1 * *p2;
+		L_sum1 = (L_sum1 << 2);
+		L_sum2 = (L_sum2 << 2);
+
+		corr = (L_sum1 + 0x8000) >> 16;
+		cor_x[i] = vo_mult(corr, sign[pos]) + (*p0++);
+		corr = (L_sum2 + 0x8000) >> 16;
+		cor_y[i] = vo_mult(corr, sign[pos + 1]) + (*p3++);
+		pos += STEP;
+
+		L_sum1 = L_sum2 = 0L;
+		p1 = h;
+		p2 = &vec[pos];
+		for (j= 62-pos;j >= 0; j--)
+		{
+			L_sum1 += *p1 * *p2++;
+			L_sum2 += *p1++ * *p2;
+		}
+		L_sum1 += *p1 * *p2;
+		L_sum1 = (L_sum1 << 2);
+		L_sum2 = (L_sum2 << 2);
+
+		corr = (L_sum1 + 0x8000) >> 16;
+		cor_x[i+1] = vo_mult(corr, sign[pos]) + (*p0++);
+		corr = (L_sum2 + 0x8000) >> 16;
+		cor_y[i+1] = vo_mult(corr, sign[pos + 1]) + (*p3++);
+		pos += STEP;
+	}
+	return;
+}
+
+/*-------------------------------------------------------------------*
+ * Function  search_ixiy()                                           *
+ * ~~~~~~~~~~~~~~~~~~~~~~~                                           *
+ * Find the best positions of 2 pulses in a subframe.                *
+ *-------------------------------------------------------------------*/
+
+void search_ixiy(
+		Word16 nb_pos_ix,                     /* (i) nb of pos for pulse 1 (1..8)       */
+		Word16 track_x,                       /* (i) track of pulse 1                   */
+		Word16 track_y,                       /* (i) track of pulse 2                   */
+		Word16 * ps,                          /* (i/o) correlation of all fixed pulses  */
+		Word16 * alp,                         /* (i/o) energy of all fixed pulses       */
+		Word16 * ix,                          /* (o) position of pulse 1                */
+		Word16 * iy,                          /* (o) position of pulse 2                */
+		Word16 dn[],                          /* (i) corr. between target and h[]       */
+		Word16 dn2[],                         /* (i) vector of selected positions       */
+		Word16 cor_x[],                       /* (i) corr. of pulse 1 with fixed pulses */
+		Word16 cor_y[],                       /* (i) corr. of pulse 2 with fixed pulses */
+		Word16 rrixiy[][MSIZE]                /* (i) corr. of pulse 1 with pulse 2   */
+		)
+{
+	Word32 x, y, pos, thres_ix;
+	Word16 ps1, ps2, sq, sqk;
+	Word16 alp_16, alpk;
+	Word16 *p0, *p1, *p2;
+	Word32 s, alp0, alp1, alp2;
+
+	p0 = cor_x;
+	p1 = cor_y;
+	p2 = rrixiy[track_x];
+
+	thres_ix = nb_pos_ix - NB_MAX;
+
+	alp0 = L_deposit_h(*alp);
+	alp0 = (alp0 + 0x00008000L);       /* for rounding */
+
+	sqk = -1;
+	alpk = 1;
+
+	for (x = track_x; x < L_SUBFR; x += STEP)
+	{
+		ps1 = *ps + dn[x];
+		alp1 = alp0 + ((*p0++)<<13);
+
+		if (dn2[x] < thres_ix)
+		{
+			pos = -1;
+			for (y = track_y; y < L_SUBFR; y += STEP)
+			{
+				ps2 = add1(ps1, dn[y]);
+
+				alp2 = alp1 + ((*p1++)<<13);
+				alp2 = alp2 + ((*p2++)<<14);
+				alp_16 = extract_h(alp2);
+				sq = vo_mult(ps2, ps2);
+				s = vo_L_mult(alpk, sq) - ((sqk * alp_16)<<1);
+
+				if (s > 0)
+				{
+					sqk = sq;
+					alpk = alp_16;
+					pos = y;
+				}
+			}
+			p1 -= NB_POS;
+
+			if (pos >= 0)
+			{
+				*ix = x;
+				*iy = pos;
+			}
+		} else
+		{
+			p2 += NB_POS;
+		}
+	}
+
+	*ps = add1(*ps, add1(dn[*ix], dn[*iy]));
+	*alp = alpk;
+
+	return;
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/convolve.c b/media/libstagefright/codecs/amrwbenc/src/convolve.c
index 66c74d6..acba532 100644
--- a/media/libstagefright/codecs/amrwbenc/src/convolve.c
+++ b/media/libstagefright/codecs/amrwbenc/src/convolve.c
@@ -1,109 +1,109 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-       File: convolve.c
-
-	   Description:Perform the convolution between two vectors x[] and h[]
-	               and write the result in the vector y[]
-
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-void Convolve (
-		Word16 x[],        /* (i)     : input vector                           */
-		Word16 h[],        /* (i)     : impulse response                       */
-		Word16 y[],        /* (o)     : output vector                          */
-		Word16 L           /* (i)     : vector size                            */
-	      )
-{
-	Word32  i, n;
-	Word16 *tmpH,*tmpX;
-	Word32 s;
-	for (n = 0; n < 64;)
-	{
-		tmpH = h+n;
-		tmpX = x;
-		i=n+1;
-		s = vo_mult32((*tmpX++), (*tmpH--));i--;
-		while(i>0)
-		{
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			i -= 4;
-		}
-		y[n] = ((s<<1) + 0x8000)>>16;   
-		n++;
-
-		tmpH = h+n;
-		tmpX = x;
-		i=n+1;
-		s =  vo_mult32((*tmpX++), (*tmpH--));i--;
-		s += vo_mult32((*tmpX++), (*tmpH--));i--;
-
-		while(i>0)
-		{
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			i -= 4;
-		}
-		y[n] = ((s<<1) + 0x8000)>>16;    
-		n++;
-
-		tmpH = h+n;
-		tmpX = x;
-		i=n+1;
-		s =  vo_mult32((*tmpX++), (*tmpH--));i--;
-		s += vo_mult32((*tmpX++), (*tmpH--));i--;
-		s += vo_mult32((*tmpX++), (*tmpH--));i--;
-
-		while(i>0)
-		{
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			i -= 4;
-		}
-		y[n] = ((s<<1) + 0x8000)>>16;   
-		n++;
-
-		s = 0;
-		tmpH = h+n;
-		tmpX = x;
-		i=n+1;
-		while(i>0)
-		{
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			s += vo_mult32((*tmpX++), (*tmpH--));
-			i -= 4;
-		}
-		y[n] = ((s<<1) + 0x8000)>>16;   
-		n++;        
-	}
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+       File: convolve.c
+
+	   Description:Perform the convolution between two vectors x[] and h[]
+	               and write the result in the vector y[]
+
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+void Convolve (
+		Word16 x[],        /* (i)     : input vector                           */
+		Word16 h[],        /* (i)     : impulse response                       */
+		Word16 y[],        /* (o)     : output vector                          */
+		Word16 L           /* (i)     : vector size                            */
+	      )
+{
+	Word32  i, n;
+	Word16 *tmpH,*tmpX;
+	Word32 s;
+	for (n = 0; n < 64;)
+	{
+		tmpH = h+n;
+		tmpX = x;
+		i=n+1;
+		s = vo_mult32((*tmpX++), (*tmpH--));i--;
+		while(i>0)
+		{
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			i -= 4;
+		}
+		y[n] = ((s<<1) + 0x8000)>>16;
+		n++;
+
+		tmpH = h+n;
+		tmpX = x;
+		i=n+1;
+		s =  vo_mult32((*tmpX++), (*tmpH--));i--;
+		s += vo_mult32((*tmpX++), (*tmpH--));i--;
+
+		while(i>0)
+		{
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			i -= 4;
+		}
+		y[n] = ((s<<1) + 0x8000)>>16;
+		n++;
+
+		tmpH = h+n;
+		tmpX = x;
+		i=n+1;
+		s =  vo_mult32((*tmpX++), (*tmpH--));i--;
+		s += vo_mult32((*tmpX++), (*tmpH--));i--;
+		s += vo_mult32((*tmpX++), (*tmpH--));i--;
+
+		while(i>0)
+		{
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			i -= 4;
+		}
+		y[n] = ((s<<1) + 0x8000)>>16;
+		n++;
+
+		s = 0;
+		tmpH = h+n;
+		tmpX = x;
+		i=n+1;
+		while(i>0)
+		{
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			s += vo_mult32((*tmpX++), (*tmpH--));
+			i -= 4;
+		}
+		y[n] = ((s<<1) + 0x8000)>>16;
+		n++;
+	}
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/cor_h_x.c b/media/libstagefright/codecs/amrwbenc/src/cor_h_x.c
index 3c2e9d5..d9245ed 100644
--- a/media/libstagefright/codecs/amrwbenc/src/cor_h_x.c
+++ b/media/libstagefright/codecs/amrwbenc/src/cor_h_x.c
@@ -1,127 +1,127 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: cor_h_x.c                                                *
-*                                                                      *
-*	   Description:Compute correlation between target "x[]" and "h[]"  *
-*	               Designed for codebook search (24 pulses, 4 tracks,  * 
-*				   4 pulses per track, 16 positions in each track) to  *
-*				   avoid saturation.                                   *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-
-#define L_SUBFR   64
-#define NB_TRACK  4
-#define STEP      4
-
-void cor_h_x(
-		Word16 h[],                           /* (i) Q12 : impulse response of weighted synthesis filter */
-		Word16 x[],                           /* (i) Q0  : target vector                                 */
-		Word16 dn[]                           /* (o) <12bit : correlation between target and h[]         */
-	    )
-{
-	Word32 i, j;
-	Word32 L_tmp, y32[L_SUBFR], L_tot;
-	Word16 *p1, *p2;
-	Word32 *p3;
-	Word32 L_max, L_max1, L_max2, L_max3;
-	/* first keep the result on 32 bits and find absolute maximum */
-	L_tot  = 1;                            
-	L_max  = 0; 
-	L_max1 = 0;
-	L_max2 = 0;
-	L_max3 = 0;
-	for (i = 0; i < L_SUBFR; i += STEP)
-	{
-		L_tmp = 1;                                    /* 1 -> to avoid null dn[] */
-		p1 = &x[i];
-		p2 = &h[0];
-		for (j = i; j < L_SUBFR; j++)
-			L_tmp += vo_L_mult(*p1++, *p2++);
-
-		y32[i] = L_tmp;               
-		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
-		if(L_tmp > L_max)
-		{
-			L_max = L_tmp;             
-		}
-
-		L_tmp = 1L;
-		p1 = &x[i+1];
-		p2 = &h[0];
-		for (j = i+1; j < L_SUBFR; j++)
-			L_tmp += vo_L_mult(*p1++, *p2++);
-
-		y32[i+1] = L_tmp;               
-		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
-		if(L_tmp > L_max1)
-		{
-			L_max1 = L_tmp;             
-		}
-
-		L_tmp = 1;
-		p1 = &x[i+2];
-		p2 = &h[0];
-		for (j = i+2; j < L_SUBFR; j++)
-			L_tmp += vo_L_mult(*p1++, *p2++);
-
-		y32[i+2] = L_tmp;               
-		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
-		if(L_tmp > L_max2)
-		{
-			L_max2 = L_tmp;             
-		}
-
-		L_tmp = 1;
-		p1 = &x[i+3];
-		p2 = &h[0];
-		for (j = i+3; j < L_SUBFR; j++)
-			L_tmp += vo_L_mult(*p1++, *p2++);
-
-		y32[i+3] = L_tmp;               
-		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
-		if(L_tmp > L_max3)
-		{
-			L_max3 = L_tmp;             
-		}
-	}
-	/* tot += 3*max / 8 */
-	L_max = ((L_max + L_max1 + L_max2 + L_max3) >> 2);
-	L_tot = vo_L_add(L_tot, L_max);       /* +max/4 */
-	L_tot = vo_L_add(L_tot, (L_max >> 1));  /* +max/8 */
-
-	/* Find the number of right shifts to do on y32[] so that    */
-	/* 6.0 x sumation of max of dn[] in each track not saturate. */
-	j = norm_l(L_tot) - 4;             /* 4 -> 16 x tot */
-	p1 = dn;
-	p3 = y32;
-	for (i = 0; i < L_SUBFR; i+=4)
-	{
-		*p1++ = vo_round(L_shl(*p3++, j));
-		*p1++ = vo_round(L_shl(*p3++, j));
-		*p1++ = vo_round(L_shl(*p3++, j));
-		*p1++ = vo_round(L_shl(*p3++, j));
-	}
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: cor_h_x.c                                                *
+*                                                                      *
+*	   Description:Compute correlation between target "x[]" and "h[]"  *
+*	               Designed for codebook search (24 pulses, 4 tracks,  *
+*				   4 pulses per track, 16 positions in each track) to  *
+*				   avoid saturation.                                   *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+
+#define L_SUBFR   64
+#define NB_TRACK  4
+#define STEP      4
+
+void cor_h_x(
+		Word16 h[],                           /* (i) Q12 : impulse response of weighted synthesis filter */
+		Word16 x[],                           /* (i) Q0  : target vector                                 */
+		Word16 dn[]                           /* (o) <12bit : correlation between target and h[]         */
+	    )
+{
+	Word32 i, j;
+	Word32 L_tmp, y32[L_SUBFR], L_tot;
+	Word16 *p1, *p2;
+	Word32 *p3;
+	Word32 L_max, L_max1, L_max2, L_max3;
+	/* first keep the result on 32 bits and find absolute maximum */
+	L_tot  = 1;
+	L_max  = 0;
+	L_max1 = 0;
+	L_max2 = 0;
+	L_max3 = 0;
+	for (i = 0; i < L_SUBFR; i += STEP)
+	{
+		L_tmp = 1;                                    /* 1 -> to avoid null dn[] */
+		p1 = &x[i];
+		p2 = &h[0];
+		for (j = i; j < L_SUBFR; j++)
+			L_tmp += vo_L_mult(*p1++, *p2++);
+
+		y32[i] = L_tmp;
+		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
+		if(L_tmp > L_max)
+		{
+			L_max = L_tmp;
+		}
+
+		L_tmp = 1L;
+		p1 = &x[i+1];
+		p2 = &h[0];
+		for (j = i+1; j < L_SUBFR; j++)
+			L_tmp += vo_L_mult(*p1++, *p2++);
+
+		y32[i+1] = L_tmp;
+		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
+		if(L_tmp > L_max1)
+		{
+			L_max1 = L_tmp;
+		}
+
+		L_tmp = 1;
+		p1 = &x[i+2];
+		p2 = &h[0];
+		for (j = i+2; j < L_SUBFR; j++)
+			L_tmp += vo_L_mult(*p1++, *p2++);
+
+		y32[i+2] = L_tmp;
+		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
+		if(L_tmp > L_max2)
+		{
+			L_max2 = L_tmp;
+		}
+
+		L_tmp = 1;
+		p1 = &x[i+3];
+		p2 = &h[0];
+		for (j = i+3; j < L_SUBFR; j++)
+			L_tmp += vo_L_mult(*p1++, *p2++);
+
+		y32[i+3] = L_tmp;
+		L_tmp = (L_tmp > 0)? L_tmp:-L_tmp;
+		if(L_tmp > L_max3)
+		{
+			L_max3 = L_tmp;
+		}
+	}
+	/* tot += 3*max / 8 */
+	L_max = ((L_max + L_max1 + L_max2 + L_max3) >> 2);
+	L_tot = vo_L_add(L_tot, L_max);       /* +max/4 */
+	L_tot = vo_L_add(L_tot, (L_max >> 1));  /* +max/8 */
+
+	/* Find the number of right shifts to do on y32[] so that    */
+	/* 6.0 x sumation of max of dn[] in each track not saturate. */
+	j = norm_l(L_tot) - 4;             /* 4 -> 16 x tot */
+	p1 = dn;
+	p3 = y32;
+	for (i = 0; i < L_SUBFR; i+=4)
+	{
+		*p1++ = vo_round(L_shl(*p3++, j));
+		*p1++ = vo_round(L_shl(*p3++, j));
+		*p1++ = vo_round(L_shl(*p3++, j));
+		*p1++ = vo_round(L_shl(*p3++, j));
+	}
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/decim54.c b/media/libstagefright/codecs/amrwbenc/src/decim54.c
index 429a7d6..3b88514 100644
--- a/media/libstagefright/codecs/amrwbenc/src/decim54.c
+++ b/media/libstagefright/codecs/amrwbenc/src/decim54.c
@@ -1,146 +1,146 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: decim54.c                                                 *
-*                                                                      *
-*	   Description:Decimation of 16kHz signal to 12.8kHz           *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "acelp.h"
-#include "cnst.h"
-
-#define FAC5   5
-#define DOWN_FAC  26215                    /* 4/5 in Q15 */
-
-#define NB_COEF_DOWN  15
-
-/* Local functions */
-static void Down_samp(
-		Word16 * sig,                         /* input:  signal to downsampling  */
-		Word16 * sig_d,                       /* output: downsampled signal      */
-		Word16 L_frame_d                      /* input:  length of output        */
-		);
-
-/* 1/5 resolution interpolation filter  (in Q14)  */
-/* -1.5dB @ 6kHz, -6dB @ 6.4kHz, -10dB @ 6.6kHz, -20dB @ 6.9kHz, -25dB @ 7kHz, -55dB @ 8kHz */
-
-static Word16 fir_down1[4][30] =
-{
-	{-5, 24, -50, 54, 0, -128, 294, -408, 344, 0, -647, 1505, -2379, 3034, 13107, 3034, -2379, 1505, -647, 0, 344, -408,
-	294, -128, 0, 54, -50, 24, -5, 0},
-
-	{-6, 19, -26, 0, 77, -188, 270, -233, 0, 434, -964, 1366, -1293, 0, 12254, 6575, -2746, 1030, 0, -507, 601, -441,
-	198, 0, -95, 99, -58, 18, 0, -1},
-
-	{-3, 9, 0, -41, 111, -170, 153, 0, -295, 649, -888, 770, 0, -1997, 9894, 9894, -1997, 0, 770, -888, 649, -295, 0,
-	153, -170, 111, -41, 0, 9, -3},
-
-	{-1, 0, 18, -58, 99, -95, 0, 198, -441, 601, -507, 0, 1030, -2746, 6575, 12254, 0, -1293, 1366, -964, 434, 0,
-	-233, 270, -188, 77, 0, -26, 19, -6}
-};
-
-void Init_Decim_12k8(
-		Word16 mem[]                          /* output: memory (2*NB_COEF_DOWN) set to zeros */
-		)
-{
-	Set_zero(mem, 2 * NB_COEF_DOWN);
-	return;
-}
-
-void Decim_12k8(
-		Word16 sig16k[],                      /* input:  signal to downsampling  */
-		Word16 lg,                            /* input:  length of input         */
-		Word16 sig12k8[],                     /* output: decimated signal        */
-		Word16 mem[]                          /* in/out: memory (2*NB_COEF_DOWN) */
-	       )
-{
-	Word16 lg_down;
-	Word16 signal[L_FRAME16k + (2 * NB_COEF_DOWN)];
-
-	Copy(mem, signal, 2 * NB_COEF_DOWN);
-
-	Copy(sig16k, signal + (2 * NB_COEF_DOWN), lg);
-
-	lg_down = (lg * DOWN_FAC)>>15;
-
-	Down_samp(signal + NB_COEF_DOWN, sig12k8, lg_down);
-
-	Copy(signal + lg, mem, 2 * NB_COEF_DOWN);
-
-	return;
-}
-
-static void Down_samp(
-		Word16 * sig,                         /* input:  signal to downsampling  */
-		Word16 * sig_d,                       /* output: downsampled signal      */
-		Word16 L_frame_d                      /* input:  length of output        */
-		)
-{
-	Word32 i, j, frac, pos;
-	Word16 *x, *y;
-	Word32 L_sum;
-
-	pos = 0;                                 /* position is in Q2 -> 1/4 resolution  */
-	for (j = 0; j < L_frame_d; j++)
-	{
-		i = (pos >> 2);                   /* integer part     */
-		frac = pos & 3;                   /* fractional part */
-		x = sig + i - NB_COEF_DOWN + 1;
-		y = (Word16 *)(fir_down1 + frac);
-
-		L_sum = vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x++),(*y++));
-		L_sum += vo_mult32((*x),(*y));
-
-		L_sum = L_shl2(L_sum, 2);              
-		sig_d[j] = extract_h(L_add(L_sum, 0x8000)); 
-		pos += FAC5;              /* pos + 5/4 */
-	}
-	return;
-}
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: decim54.c                                                 *
+*                                                                      *
+*	   Description:Decimation of 16kHz signal to 12.8kHz           *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "acelp.h"
+#include "cnst.h"
+
+#define FAC5   5
+#define DOWN_FAC  26215                    /* 4/5 in Q15 */
+
+#define NB_COEF_DOWN  15
+
+/* Local functions */
+static void Down_samp(
+		Word16 * sig,                         /* input:  signal to downsampling  */
+		Word16 * sig_d,                       /* output: downsampled signal      */
+		Word16 L_frame_d                      /* input:  length of output        */
+		);
+
+/* 1/5 resolution interpolation filter  (in Q14)  */
+/* -1.5dB @ 6kHz, -6dB @ 6.4kHz, -10dB @ 6.6kHz, -20dB @ 6.9kHz, -25dB @ 7kHz, -55dB @ 8kHz */
+
+static Word16 fir_down1[4][30] =
+{
+	{-5, 24, -50, 54, 0, -128, 294, -408, 344, 0, -647, 1505, -2379, 3034, 13107, 3034, -2379, 1505, -647, 0, 344, -408,
+	294, -128, 0, 54, -50, 24, -5, 0},
+
+	{-6, 19, -26, 0, 77, -188, 270, -233, 0, 434, -964, 1366, -1293, 0, 12254, 6575, -2746, 1030, 0, -507, 601, -441,
+	198, 0, -95, 99, -58, 18, 0, -1},
+
+	{-3, 9, 0, -41, 111, -170, 153, 0, -295, 649, -888, 770, 0, -1997, 9894, 9894, -1997, 0, 770, -888, 649, -295, 0,
+	153, -170, 111, -41, 0, 9, -3},
+
+	{-1, 0, 18, -58, 99, -95, 0, 198, -441, 601, -507, 0, 1030, -2746, 6575, 12254, 0, -1293, 1366, -964, 434, 0,
+	-233, 270, -188, 77, 0, -26, 19, -6}
+};
+
+void Init_Decim_12k8(
+		Word16 mem[]                          /* output: memory (2*NB_COEF_DOWN) set to zeros */
+		)
+{
+	Set_zero(mem, 2 * NB_COEF_DOWN);
+	return;
+}
+
+void Decim_12k8(
+		Word16 sig16k[],                      /* input:  signal to downsampling  */
+		Word16 lg,                            /* input:  length of input         */
+		Word16 sig12k8[],                     /* output: decimated signal        */
+		Word16 mem[]                          /* in/out: memory (2*NB_COEF_DOWN) */
+	       )
+{
+	Word16 lg_down;
+	Word16 signal[L_FRAME16k + (2 * NB_COEF_DOWN)];
+
+	Copy(mem, signal, 2 * NB_COEF_DOWN);
+
+	Copy(sig16k, signal + (2 * NB_COEF_DOWN), lg);
+
+	lg_down = (lg * DOWN_FAC)>>15;
+
+	Down_samp(signal + NB_COEF_DOWN, sig12k8, lg_down);
+
+	Copy(signal + lg, mem, 2 * NB_COEF_DOWN);
+
+	return;
+}
+
+static void Down_samp(
+		Word16 * sig,                         /* input:  signal to downsampling  */
+		Word16 * sig_d,                       /* output: downsampled signal      */
+		Word16 L_frame_d                      /* input:  length of output        */
+		)
+{
+	Word32 i, j, frac, pos;
+	Word16 *x, *y;
+	Word32 L_sum;
+
+	pos = 0;                                 /* position is in Q2 -> 1/4 resolution  */
+	for (j = 0; j < L_frame_d; j++)
+	{
+		i = (pos >> 2);                   /* integer part     */
+		frac = pos & 3;                   /* fractional part */
+		x = sig + i - NB_COEF_DOWN + 1;
+		y = (Word16 *)(fir_down1 + frac);
+
+		L_sum = vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x++),(*y++));
+		L_sum += vo_mult32((*x),(*y));
+
+		L_sum = L_shl2(L_sum, 2);
+		sig_d[j] = extract_h(L_add(L_sum, 0x8000));
+		pos += FAC5;              /* pos + 5/4 */
+	}
+	return;
+}
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/deemph.c b/media/libstagefright/codecs/amrwbenc/src/deemph.c
index 6ad528d..0c49d6b 100644
--- a/media/libstagefright/codecs/amrwbenc/src/deemph.c
+++ b/media/libstagefright/codecs/amrwbenc/src/deemph.c
@@ -1,117 +1,117 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: deemph.c                                                 *
-*                                                                      *
-*	   Description:filtering through 1/(1-mu z^ -1)                    *
-*	               Deemph2 --> signal is divided by 2                  *
-*				   Deemph_32 --> for 32 bits signal.                   *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-
-void Deemph(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
-		Word16 L,                             /* (i)     : vector size                            */
-		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
-	   )
-{
-	Word32 i;
-	Word32 L_tmp;
-
-	L_tmp = L_deposit_h(x[0]);
-	L_tmp = L_mac(L_tmp, *mem, mu);
-	x[0] = vo_round(L_tmp);                   
-
-	for (i = 1; i < L; i++)
-	{
-		L_tmp = L_deposit_h(x[i]);
-		L_tmp = L_mac(L_tmp, x[i - 1], mu);
-		x[i] = voround(L_tmp);               
-	}
-
-	*mem = x[L - 1];                       
-
-	return;
-}
-
-
-void Deemph2(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
-		Word16 L,                             /* (i)     : vector size                            */
-		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
-	    )
-{
-	Word32 i;
-	Word32 L_tmp;
-	L_tmp = x[0] << 15;
-	L_tmp += ((*mem) * mu)<<1;
-	x[0] = (L_tmp + 0x8000)>>16;                   
-	for (i = 1; i < L; i++)
-	{
-		L_tmp = x[i] << 15;
-		L_tmp += (x[i - 1] * mu)<<1;
-		x[i] = (L_tmp + 0x8000)>>16;               
-	}
-	*mem = x[L - 1];                       
-	return;
-}
-
-
-void Deemph_32(
-		Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
-		Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
-		Word16 y[],                           /* (o)     : output signal (x16)      */
-		Word16 mu,                            /* (i) Q15 : deemphasis factor        */
-		Word16 L,                             /* (i)     : vector size              */
-		Word16 * mem                          /* (i/o)   : memory (y[-1])           */
-	      )
-{
-	Word16 fac;
-	Word32 i, L_tmp;
-
-	fac = mu >> 1;                                /* Q15 --> Q14 */
-
-	L_tmp = L_deposit_h(x_hi[0]);
-	L_tmp += (x_lo[0] * 8)<<1;
-	L_tmp = (L_tmp << 3);
-	L_tmp += ((*mem) * fac)<<1;
-	L_tmp = (L_tmp << 1);               
-	y[0] = (L_tmp + 0x8000)>>16;                  
-
-	for (i = 1; i < L; i++)
-	{
-		L_tmp = L_deposit_h(x_hi[i]);
-		L_tmp += (x_lo[i] * 8)<<1;
-		L_tmp = (L_tmp << 3);
-		L_tmp += (y[i - 1] * fac)<<1;
-		L_tmp = (L_tmp << 1);           
-		y[i] = (L_tmp + 0x8000)>>16;               
-	}
-
-	*mem = y[L - 1];                       
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: deemph.c                                                 *
+*                                                                      *
+*	   Description:filtering through 1/(1-mu z^ -1)                    *
+*	               Deemph2 --> signal is divided by 2                  *
+*				   Deemph_32 --> for 32 bits signal.                   *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+
+void Deemph(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
+		Word16 L,                             /* (i)     : vector size                            */
+		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
+	   )
+{
+	Word32 i;
+	Word32 L_tmp;
+
+	L_tmp = L_deposit_h(x[0]);
+	L_tmp = L_mac(L_tmp, *mem, mu);
+	x[0] = vo_round(L_tmp);
+
+	for (i = 1; i < L; i++)
+	{
+		L_tmp = L_deposit_h(x[i]);
+		L_tmp = L_mac(L_tmp, x[i - 1], mu);
+		x[i] = voround(L_tmp);
+	}
+
+	*mem = x[L - 1];
+
+	return;
+}
+
+
+void Deemph2(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : deemphasis factor                      */
+		Word16 L,                             /* (i)     : vector size                            */
+		Word16 * mem                          /* (i/o)   : memory (y[-1])                         */
+	    )
+{
+	Word32 i;
+	Word32 L_tmp;
+	L_tmp = x[0] << 15;
+	L_tmp += ((*mem) * mu)<<1;
+	x[0] = (L_tmp + 0x8000)>>16;
+	for (i = 1; i < L; i++)
+	{
+		L_tmp = x[i] << 15;
+		L_tmp += (x[i - 1] * mu)<<1;
+		x[i] = (L_tmp + 0x8000)>>16;
+	}
+	*mem = x[L - 1];
+	return;
+}
+
+
+void Deemph_32(
+		Word16 x_hi[],                        /* (i)     : input signal (bit31..16) */
+		Word16 x_lo[],                        /* (i)     : input signal (bit15..4)  */
+		Word16 y[],                           /* (o)     : output signal (x16)      */
+		Word16 mu,                            /* (i) Q15 : deemphasis factor        */
+		Word16 L,                             /* (i)     : vector size              */
+		Word16 * mem                          /* (i/o)   : memory (y[-1])           */
+	      )
+{
+	Word16 fac;
+	Word32 i, L_tmp;
+
+	fac = mu >> 1;                                /* Q15 --> Q14 */
+
+	L_tmp = L_deposit_h(x_hi[0]);
+	L_tmp += (x_lo[0] * 8)<<1;
+	L_tmp = (L_tmp << 3);
+	L_tmp += ((*mem) * fac)<<1;
+	L_tmp = (L_tmp << 1);
+	y[0] = (L_tmp + 0x8000)>>16;
+
+	for (i = 1; i < L; i++)
+	{
+		L_tmp = L_deposit_h(x_hi[i]);
+		L_tmp += (x_lo[i] * 8)<<1;
+		L_tmp = (L_tmp << 3);
+		L_tmp += (y[i - 1] * fac)<<1;
+		L_tmp = (L_tmp << 1);
+		y[i] = (L_tmp + 0x8000)>>16;
+	}
+
+	*mem = y[L - 1];
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/dtx.c b/media/libstagefright/codecs/amrwbenc/src/dtx.c
index 02921eb..2cfaced 100644
--- a/media/libstagefright/codecs/amrwbenc/src/dtx.c
+++ b/media/libstagefright/codecs/amrwbenc/src/dtx.c
@@ -1,605 +1,605 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: dtx.c                                                    *
-*                                                                      *
-*	    Description:DTX functions                                  *
-*                                                                      *
-************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "math_op.h"
-#include "cnst.h"
-#include "acelp.h"                         /* prototype of functions    */
-#include "bits.h"
-#include "dtx.h"
-#include "log2.h"
-#include "mem_align.h"
-
-static void aver_isf_history(
-		Word16 isf_old[],
-		Word16 indices[],
-		Word32 isf_aver[]
-		);
-
-static void find_frame_indices(
-		Word16 isf_old_tx[],
-		Word16 indices[],
-		dtx_encState * st
-		);
-
-static Word16 dithering_control(
-		dtx_encState * st
-		);
-
-/* excitation energy adjustment depending on speech coder mode used, Q7 */
-static Word16 en_adjust[9] =
-{
-	230,                                   /* mode0 = 7k  :  -5.4dB  */
-	179,                                   /* mode1 = 9k  :  -4.2dB  */
-	141,                                   /* mode2 = 12k :  -3.3dB  */
-	128,                                   /* mode3 = 14k :  -3.0dB  */
-	122,                                   /* mode4 = 16k :  -2.85dB */
-	115,                                   /* mode5 = 18k :  -2.7dB  */
-	115,                                   /* mode6 = 20k :  -2.7dB  */
-	115,                                   /* mode7 = 23k :  -2.7dB  */
-	115                                    /* mode8 = 24k :  -2.7dB  */
-};
-
-/**************************************************************************
-*
-* Function    : dtx_enc_init
-*
-**************************************************************************/
-Word16 dtx_enc_init(dtx_encState ** st, Word16 isf_init[], VO_MEM_OPERATOR *pMemOP)
-{
-	dtx_encState *s;
-
-	if (st == (dtx_encState **) NULL)
-	{
-		fprintf(stderr, "dtx_enc_init: invalid parameter\n");
-		return -1;
-	}
-	*st = NULL;
-
-	/* allocate memory */
-	if ((s = (dtx_encState *)mem_malloc(pMemOP, sizeof(dtx_encState), 32, VO_INDEX_ENC_AMRWB)) == NULL)
-	{
-		fprintf(stderr, "dtx_enc_init: can not malloc state structure\n");
-		return -1;
-	}
-	dtx_enc_reset(s, isf_init);
-	*st = s;
-	return 0;
-}
-
-/**************************************************************************
-*
-* Function    : dtx_enc_reset
-*
-**************************************************************************/
-Word16 dtx_enc_reset(dtx_encState * st, Word16 isf_init[])
-{
-	Word32 i;
-
-	if (st == (dtx_encState *) NULL)
-	{
-		fprintf(stderr, "dtx_enc_reset: invalid parameter\n");
-		return -1;
-	}
-	st->hist_ptr = 0;                      
-	st->log_en_index = 0;                  
-
-	/* Init isf_hist[] */
-	for (i = 0; i < DTX_HIST_SIZE; i++)
-	{
-		Copy(isf_init, &st->isf_hist[i * M], M);
-	}
-	st->cng_seed = RANDOM_INITSEED;       
-
-	/* Reset energy history */
-	Set_zero(st->log_en_hist, DTX_HIST_SIZE);
-
-	st->dtxHangoverCount = DTX_HANG_CONST; 
-	st->decAnaElapsedCount = 32767;        
-
-	for (i = 0; i < 28; i++)
-	{
-		st->D[i] = 0;                      
-	}
-
-	for (i = 0; i < DTX_HIST_SIZE - 1; i++)
-	{
-		st->sumD[i] = 0;                   
-	}
-
-	return 1;
-}
-
-/**************************************************************************
-*
-* Function    : dtx_enc_exit
-*
-**************************************************************************/
-void dtx_enc_exit(dtx_encState ** st, VO_MEM_OPERATOR *pMemOP)
-{
-	if (st == NULL || *st == NULL)
-		return;
-	/* deallocate memory */
-	mem_free(pMemOP, *st, VO_INDEX_ENC_AMRWB);
-	*st = NULL;
-	return;
-}
-
-
-/**************************************************************************
-*
-* Function    : dtx_enc
-*
-**************************************************************************/
-Word16 dtx_enc(
-		dtx_encState * st,                    /* i/o : State struct                                         */
-		Word16 isf[M],                        /* o   : CN ISF vector                                        */
-		Word16 * exc2,                        /* o   : CN excitation                                        */
-		Word16 ** prms
-	      )
-{
-	Word32 i, j;
-	Word16 indice[7];
-	Word16 log_en, gain, level, exp, exp0, tmp;
-	Word16 log_en_int_e, log_en_int_m;
-	Word32 L_isf[M], ener32, level32;
-	Word16 isf_order[3];
-	Word16 CN_dith;
-
-	/* VOX mode computation of SID parameters */
-	log_en = 0;
-	for (i = 0; i < M; i++)
-	{
-		L_isf[i] = 0;
-	}
-	/* average energy and isf */
-	for (i = 0; i < DTX_HIST_SIZE; i++)
-	{
-		/* Division by DTX_HIST_SIZE = 8 has been done in dtx_buffer. log_en is in Q10 */
-		log_en = add(log_en, st->log_en_hist[i]);
-
-	}
-	find_frame_indices(st->isf_hist, isf_order, st);
-	aver_isf_history(st->isf_hist, isf_order, L_isf);
-
-	for (j = 0; j < M; j++)
-	{
-		isf[j] = (Word16)(L_isf[j] >> 3);  /* divide by 8 */
-	}
-
-	/* quantize logarithmic energy to 6 bits (-6 : 66 dB) which corresponds to -2:22 in log2(E).  */
-	/* st->log_en_index = (short)( (log_en + 2.0) * 2.625 ); */
-
-	/* increase dynamics to 7 bits (Q8) */
-	log_en = (log_en >> 2);
-
-	/* Add 2 in Q8 = 512 to get log2(E) between 0:24 */
-	log_en = add(log_en, 512);
-
-	/* Multiply by 2.625 to get full 6 bit range. 2.625 = 21504 in Q13. The result is in Q6 */
-	log_en = mult(log_en, 21504);
-
-	/* Quantize Energy */
-	st->log_en_index = shr(log_en, 6);
-
-	if(st->log_en_index > 63)
-	{
-		st->log_en_index = 63;
-	}
-	if (st->log_en_index < 0)
-	{
-		st->log_en_index = 0;
-	}
-	/* Quantize ISFs */
-	Qisf_ns(isf, isf, indice);
-
-
-	Parm_serial(indice[0], 6, prms);
-	Parm_serial(indice[1], 6, prms);
-	Parm_serial(indice[2], 6, prms);
-	Parm_serial(indice[3], 5, prms);
-	Parm_serial(indice[4], 5, prms);
-
-	Parm_serial((st->log_en_index), 6, prms);
-
-	CN_dith = dithering_control(st);
-	Parm_serial(CN_dith, 1, prms);
-
-	/* level = (float)( pow( 2.0f, (float)st->log_en_index / 2.625 - 2.0 ) );    */
-	/* log2(E) in Q9 (log2(E) lies in between -2:22) */
-	log_en = shl(st->log_en_index, 15 - 6);
-
-	/* Divide by 2.625; log_en will be between 0:24  */
-	log_en = mult(log_en, 12483);
-	/* the result corresponds to log2(gain) in Q10 */
-
-	/* Find integer part  */
-	log_en_int_e = (log_en >> 10);
-
-	/* Find fractional part */
-	log_en_int_m = (Word16) (log_en & 0x3ff);
-	log_en_int_m = shl(log_en_int_m, 5);
-
-	/* Subtract 2 from log_en in Q9, i.e divide the gain by 2 (energy by 4) */
-	/* Add 16 in order to have the result of pow2 in Q16 */
-	log_en_int_e = add(log_en_int_e, 16 - 1);
-
-	level32 = Pow2(log_en_int_e, log_en_int_m); /* Q16 */
-	exp0 = norm_l(level32);
-	level32 = (level32 << exp0);        /* level in Q31 */
-	exp0 = (15 - exp0);
-	level = extract_h(level32);            /* level in Q15 */
-
-	/* generate white noise vector */
-	for (i = 0; i < L_FRAME; i++)
-	{
-		exc2[i] = (Random(&(st->cng_seed)) >> 4);
-	}
-
-	/* gain = level / sqrt(ener) * sqrt(L_FRAME) */
-
-	/* energy of generated excitation */
-	ener32 = Dot_product12(exc2, exc2, L_FRAME, &exp);
-
-	Isqrt_n(&ener32, &exp);
-
-	gain = extract_h(ener32);
-
-	gain = mult(level, gain);              /* gain in Q15 */
-
-	exp = add(exp0, exp);
-
-	/* Multiply by sqrt(L_FRAME)=16, i.e. shift left by 4 */
-	exp += 4;
-
-	for (i = 0; i < L_FRAME; i++)
-	{
-		tmp = mult(exc2[i], gain);         /* Q0 * Q15 */
-		exc2[i] = shl(tmp, exp); 
-	}
-
-	return 0;
-}
-
-/**************************************************************************
-*
-* Function    : dtx_buffer Purpose     : handles the DTX buffer
-*
-**************************************************************************/
-Word16 dtx_buffer(
-		dtx_encState * st,                    /* i/o : State struct                    */
-		Word16 isf_new[],                     /* i   : isf vector                      */
-		Word32 enr,                           /* i   : residual energy (in L_FRAME)    */
-		Word16 codec_mode
-		)
-{
-	Word16 log_en;
-
-	Word16 log_en_e;
-	Word16 log_en_m;
-	st->hist_ptr = add(st->hist_ptr, 1); 
-	if(st->hist_ptr == DTX_HIST_SIZE)
-	{
-		st->hist_ptr = 0;
-	}
-	/* copy lsp vector into buffer */
-	Copy(isf_new, &st->isf_hist[st->hist_ptr * M], M);
-
-	/* log_en = (float)log10(enr*0.0059322)/(float)log10(2.0f);  */
-	Log2(enr, &log_en_e, &log_en_m);
-
-	/* convert exponent and mantissa to Word16 Q7. Q7 is used to simplify averaging in dtx_enc */
-	log_en = shl(log_en_e, 7);             /* Q7 */
-	log_en = add(log_en, shr(log_en_m, 15 - 7));
-
-	/* Find energy per sample by multiplying with 0.0059322, i.e subtract log2(1/0.0059322) = 7.39722 The
-	 * constant 0.0059322 takes into account windowings and analysis length from autocorrelation
-	 * computations; 7.39722 in Q7 = 947  */
-	/* Subtract 3 dB = 0.99658 in log2(E) = 127 in Q7. */
-	/* log_en = sub( log_en, 947 + en_adjust[codec_mode] ); */
-
-	/* Find energy per sample (divide by L_FRAME=256), i.e subtract log2(256) = 8.0  (1024 in Q7) */
-	/* Subtract 3 dB = 0.99658 in log2(E) = 127 in Q7. */
-
-	log_en = sub(log_en, add(1024, en_adjust[codec_mode]));
-
-	/* Insert into the buffer */
-	st->log_en_hist[st->hist_ptr] = log_en;
-	return 0;
-}
-
-/**************************************************************************
-*
-* Function    : tx_dtx_handler Purpose     : adds extra speech hangover
-*                                            to analyze speech on
-*                                            the decoding side.
-**************************************************************************/
-void tx_dtx_handler(dtx_encState * st,     /* i/o : State struct           */
-		Word16 vad_flag,                      /* i   : vad decision           */
-		Word16 * usedMode                     /* i/o : mode changed or not    */
-		)
-{
-
-	/* this state machine is in synch with the GSMEFR txDtx machine      */
-	st->decAnaElapsedCount = add(st->decAnaElapsedCount, 1); 
-
-	if (vad_flag != 0)
-	{
-		st->dtxHangoverCount = DTX_HANG_CONST;
-	} else
-	{                                      /* non-speech */
-		if (st->dtxHangoverCount == 0)
-		{                                  /* out of decoder analysis hangover  */
-			st->decAnaElapsedCount = 0;    
-			*usedMode = MRDTX;            
-		} else
-		{                                  /* in possible analysis hangover */
-			st->dtxHangoverCount = sub(st->dtxHangoverCount, 1);
-
-			/* decAnaElapsedCount + dtxHangoverCount < DTX_ELAPSED_FRAMES_THRESH */
-			if (sub(add(st->decAnaElapsedCount, st->dtxHangoverCount),
-						DTX_ELAPSED_FRAMES_THRESH) < 0)
-			{
-				*usedMode = MRDTX;
-				/* if short time since decoder update, do not add extra HO */
-			}
-			/* else override VAD and stay in speech mode *usedMode and add extra hangover */
-		}
-	}
-
-	return;
-}
-
-
-
-static void aver_isf_history(
-		Word16 isf_old[],
-		Word16 indices[],
-		Word32 isf_aver[]
-		)
-{
-	Word32 i, j, k;
-	Word16 isf_tmp[2 * M];
-	Word32 L_tmp;
-
-	/* Memorize in isf_tmp[][] the ISF vectors to be replaced by */
-	/* the median ISF vector prior to the averaging               */
-	for (k = 0; k < 2; k++)
-	{
-		if ((indices[k] + 1) != 0)
-		{
-			for (i = 0; i < M; i++)
-			{
-				isf_tmp[k * M + i] = isf_old[indices[k] * M + i];      
-				isf_old[indices[k] * M + i] = isf_old[indices[2] * M + i];    
-			}
-		}
-	}
-
-	/* Perform the ISF averaging */
-	for (j = 0; j < M; j++)
-	{
-		L_tmp = 0;                      
-
-		for (i = 0; i < DTX_HIST_SIZE; i++)
-		{
-			L_tmp = L_add(L_tmp, L_deposit_l(isf_old[i * M + j]));
-		}
-		isf_aver[j] = L_tmp;              
-	}
-
-	/* Retrieve from isf_tmp[][] the ISF vectors saved prior to averaging */
-	for (k = 0; k < 2; k++)
-	{
-		if ((indices[k] + 1) != 0)
-		{
-			for (i = 0; i < M; i++)
-			{
-				isf_old[indices[k] * M + i] = isf_tmp[k * M + i];
-			}
-		}
-	}
-
-	return;
-}
-
-static void find_frame_indices(
-		Word16 isf_old_tx[],
-		Word16 indices[],
-		dtx_encState * st
-		)
-{
-	Word32 L_tmp, summin, summax, summax2nd;
-	Word16 i, j, tmp;
-	Word16 ptr;
-
-	/* Remove the effect of the oldest frame from the column */
-	/* sum sumD[0..DTX_HIST_SIZE-1]. sumD[DTX_HIST_SIZE] is    */
-	/* not updated since it will be removed later.           */
-
-	tmp = DTX_HIST_SIZE_MIN_ONE;           
-	j = -1;                                
-	for (i = 0; i < DTX_HIST_SIZE_MIN_ONE; i++)
-	{
-		j = add(j, tmp);
-		st->sumD[i] = L_sub(st->sumD[i], st->D[j]);     
-		tmp = sub(tmp, 1);
-	}
-
-	/* Shift the column sum sumD. The element sumD[DTX_HIST_SIZE-1]    */
-	/* corresponding to the oldest frame is removed. The sum of     */
-	/* the distances between the latest isf and other isfs, */
-	/* i.e. the element sumD[0], will be computed during this call. */
-	/* Hence this element is initialized to zero.                   */
-
-	for (i = DTX_HIST_SIZE_MIN_ONE; i > 0; i--)
-	{
-		st->sumD[i] = st->sumD[i - 1];     
-	}
-	st->sumD[0] = 0;                       
-
-	/* Remove the oldest frame from the distance matrix.           */
-	/* Note that the distance matrix is replaced by a one-         */
-	/* dimensional array to save static memory.                    */
-
-	tmp = 0;                               
-	for (i = 27; i >= 12; i = (Word16) (i - tmp))
-	{
-		tmp = add(tmp, 1);
-		for (j = tmp; j > 0; j--)
-		{
-			st->D[i - j + 1] = st->D[i - j - tmp];   
-		}
-	}
-
-	/* Compute the first column of the distance matrix D            */
-	/* (squared Euclidean distances from isf1[] to isf_old_tx[][]). */
-
-	ptr = st->hist_ptr;                 
-	for (i = 1; i < DTX_HIST_SIZE; i++)
-	{
-		/* Compute the distance between the latest isf and the other isfs. */
-		ptr = sub(ptr, 1);
-		if (ptr < 0)
-		{
-			ptr = DTX_HIST_SIZE_MIN_ONE;   
-		}
-		L_tmp = 0;                         
-		for (j = 0; j < M; j++)
-		{
-			tmp = sub(isf_old_tx[st->hist_ptr * M + j], isf_old_tx[ptr * M + j]);
-			L_tmp = L_mac(L_tmp, tmp, tmp);
-		}
-		st->D[i - 1] = L_tmp;           
-
-		/* Update also the column sums. */
-		st->sumD[0] = L_add(st->sumD[0], st->D[i - 1]); 
-		st->sumD[i] = L_add(st->sumD[i], st->D[i - 1]); 
-	}
-
-	/* Find the minimum and maximum distances */
-	summax = st->sumD[0];                  
-	summin = st->sumD[0];                  
-	indices[0] = 0;                        
-	indices[2] = 0;                        
-	for (i = 1; i < DTX_HIST_SIZE; i++)
-	{
-		if (L_sub(st->sumD[i], summax) > 0)
-		{
-			indices[0] = i;                
-			summax = st->sumD[i];          
-		}
-		if (L_sub(st->sumD[i], summin) < 0)
-		{
-			indices[2] = i;                
-			summin = st->sumD[i];          
-		}
-	}
-
-	/* Find the second largest distance */
-	summax2nd = -2147483647L;              
-	indices[1] = -1;                       
-	for (i = 0; i < DTX_HIST_SIZE; i++)
-	{
-		if ((L_sub(st->sumD[i], summax2nd) > 0) && (sub(i, indices[0]) != 0))
-		{
-			indices[1] = i;                
-			summax2nd = st->sumD[i];       
-		}
-	}
-
-	for (i = 0; i < 3; i++)
-	{
-		indices[i] = sub(st->hist_ptr, indices[i]);     
-		if (indices[i] < 0)
-		{
-			indices[i] = add(indices[i], DTX_HIST_SIZE);       
-		}
-	}
-
-	/* If maximum distance/MED_THRESH is smaller than minimum distance */
-	/* then the median ISF vector replacement is not performed         */
-	tmp = norm_l(summax);
-	summax = (summax << tmp);
-	summin = (summin << tmp);
-	L_tmp = L_mult(voround(summax), INV_MED_THRESH);
-	if(L_tmp <= summin)
-	{
-		indices[0] = -1; 
-	}
-	/* If second largest distance/MED_THRESH is smaller than     */
-	/* minimum distance then the median ISF vector replacement is    */
-	/* not performed                                                 */
-	summax2nd = L_shl(summax2nd, tmp);
-	L_tmp = L_mult(voround(summax2nd), INV_MED_THRESH);
-	if(L_tmp <= summin)
-	{
-		indices[1] = -1;                 
-	}
-	return;
-}
-
-static Word16 dithering_control(
-		dtx_encState * st
-		)
-{
-	Word16 tmp, mean, CN_dith, gain_diff;
-	Word32 i, ISF_diff;
-
-	/* determine how stationary the spectrum of background noise is */
-	ISF_diff = 0;
-	for (i = 0; i < 8; i++)
-	{
-		ISF_diff = L_add(ISF_diff, st->sumD[i]);
-	}
-	if ((ISF_diff >> 26) > 0)
-	{
-		CN_dith = 1;
-	} else
-	{
-		CN_dith = 0;
-	}
-
-	/* determine how stationary the energy of background noise is */
-	mean = 0;
-	for (i = 0; i < DTX_HIST_SIZE; i++)
-	{
-		mean = add(mean, st->log_en_hist[i]);
-	}
-	mean = (mean >> 3);
-	gain_diff = 0;
-	for (i = 0; i < DTX_HIST_SIZE; i++)
-	{
-		tmp = abs_s(sub(st->log_en_hist[i], mean));
-		gain_diff = add(gain_diff, tmp);
-	}
-	if (gain_diff > GAIN_THR)
-	{
-		CN_dith = 1;
-	}
-	return CN_dith;
-}
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: dtx.c                                                    *
+*                                                                      *
+*	    Description:DTX functions                                  *
+*                                                                      *
+************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "math_op.h"
+#include "cnst.h"
+#include "acelp.h"                         /* prototype of functions    */
+#include "bits.h"
+#include "dtx.h"
+#include "log2.h"
+#include "mem_align.h"
+
+static void aver_isf_history(
+		Word16 isf_old[],
+		Word16 indices[],
+		Word32 isf_aver[]
+		);
+
+static void find_frame_indices(
+		Word16 isf_old_tx[],
+		Word16 indices[],
+		dtx_encState * st
+		);
+
+static Word16 dithering_control(
+		dtx_encState * st
+		);
+
+/* excitation energy adjustment depending on speech coder mode used, Q7 */
+static Word16 en_adjust[9] =
+{
+	230,                                   /* mode0 = 7k  :  -5.4dB  */
+	179,                                   /* mode1 = 9k  :  -4.2dB  */
+	141,                                   /* mode2 = 12k :  -3.3dB  */
+	128,                                   /* mode3 = 14k :  -3.0dB  */
+	122,                                   /* mode4 = 16k :  -2.85dB */
+	115,                                   /* mode5 = 18k :  -2.7dB  */
+	115,                                   /* mode6 = 20k :  -2.7dB  */
+	115,                                   /* mode7 = 23k :  -2.7dB  */
+	115                                    /* mode8 = 24k :  -2.7dB  */
+};
+
+/**************************************************************************
+*
+* Function    : dtx_enc_init
+*
+**************************************************************************/
+Word16 dtx_enc_init(dtx_encState ** st, Word16 isf_init[], VO_MEM_OPERATOR *pMemOP)
+{
+	dtx_encState *s;
+
+	if (st == (dtx_encState **) NULL)
+	{
+		fprintf(stderr, "dtx_enc_init: invalid parameter\n");
+		return -1;
+	}
+	*st = NULL;
+
+	/* allocate memory */
+	if ((s = (dtx_encState *)mem_malloc(pMemOP, sizeof(dtx_encState), 32, VO_INDEX_ENC_AMRWB)) == NULL)
+	{
+		fprintf(stderr, "dtx_enc_init: can not malloc state structure\n");
+		return -1;
+	}
+	dtx_enc_reset(s, isf_init);
+	*st = s;
+	return 0;
+}
+
+/**************************************************************************
+*
+* Function    : dtx_enc_reset
+*
+**************************************************************************/
+Word16 dtx_enc_reset(dtx_encState * st, Word16 isf_init[])
+{
+	Word32 i;
+
+	if (st == (dtx_encState *) NULL)
+	{
+		fprintf(stderr, "dtx_enc_reset: invalid parameter\n");
+		return -1;
+	}
+	st->hist_ptr = 0;
+	st->log_en_index = 0;
+
+	/* Init isf_hist[] */
+	for (i = 0; i < DTX_HIST_SIZE; i++)
+	{
+		Copy(isf_init, &st->isf_hist[i * M], M);
+	}
+	st->cng_seed = RANDOM_INITSEED;
+
+	/* Reset energy history */
+	Set_zero(st->log_en_hist, DTX_HIST_SIZE);
+
+	st->dtxHangoverCount = DTX_HANG_CONST;
+	st->decAnaElapsedCount = 32767;
+
+	for (i = 0; i < 28; i++)
+	{
+		st->D[i] = 0;
+	}
+
+	for (i = 0; i < DTX_HIST_SIZE - 1; i++)
+	{
+		st->sumD[i] = 0;
+	}
+
+	return 1;
+}
+
+/**************************************************************************
+*
+* Function    : dtx_enc_exit
+*
+**************************************************************************/
+void dtx_enc_exit(dtx_encState ** st, VO_MEM_OPERATOR *pMemOP)
+{
+	if (st == NULL || *st == NULL)
+		return;
+	/* deallocate memory */
+	mem_free(pMemOP, *st, VO_INDEX_ENC_AMRWB);
+	*st = NULL;
+	return;
+}
+
+
+/**************************************************************************
+*
+* Function    : dtx_enc
+*
+**************************************************************************/
+Word16 dtx_enc(
+		dtx_encState * st,                    /* i/o : State struct                                         */
+		Word16 isf[M],                        /* o   : CN ISF vector                                        */
+		Word16 * exc2,                        /* o   : CN excitation                                        */
+		Word16 ** prms
+	      )
+{
+	Word32 i, j;
+	Word16 indice[7];
+	Word16 log_en, gain, level, exp, exp0, tmp;
+	Word16 log_en_int_e, log_en_int_m;
+	Word32 L_isf[M], ener32, level32;
+	Word16 isf_order[3];
+	Word16 CN_dith;
+
+	/* VOX mode computation of SID parameters */
+	log_en = 0;
+	for (i = 0; i < M; i++)
+	{
+		L_isf[i] = 0;
+	}
+	/* average energy and isf */
+	for (i = 0; i < DTX_HIST_SIZE; i++)
+	{
+		/* Division by DTX_HIST_SIZE = 8 has been done in dtx_buffer. log_en is in Q10 */
+		log_en = add(log_en, st->log_en_hist[i]);
+
+	}
+	find_frame_indices(st->isf_hist, isf_order, st);
+	aver_isf_history(st->isf_hist, isf_order, L_isf);
+
+	for (j = 0; j < M; j++)
+	{
+		isf[j] = (Word16)(L_isf[j] >> 3);  /* divide by 8 */
+	}
+
+	/* quantize logarithmic energy to 6 bits (-6 : 66 dB) which corresponds to -2:22 in log2(E).  */
+	/* st->log_en_index = (short)( (log_en + 2.0) * 2.625 ); */
+
+	/* increase dynamics to 7 bits (Q8) */
+	log_en = (log_en >> 2);
+
+	/* Add 2 in Q8 = 512 to get log2(E) between 0:24 */
+	log_en = add(log_en, 512);
+
+	/* Multiply by 2.625 to get full 6 bit range. 2.625 = 21504 in Q13. The result is in Q6 */
+	log_en = mult(log_en, 21504);
+
+	/* Quantize Energy */
+	st->log_en_index = shr(log_en, 6);
+
+	if(st->log_en_index > 63)
+	{
+		st->log_en_index = 63;
+	}
+	if (st->log_en_index < 0)
+	{
+		st->log_en_index = 0;
+	}
+	/* Quantize ISFs */
+	Qisf_ns(isf, isf, indice);
+
+
+	Parm_serial(indice[0], 6, prms);
+	Parm_serial(indice[1], 6, prms);
+	Parm_serial(indice[2], 6, prms);
+	Parm_serial(indice[3], 5, prms);
+	Parm_serial(indice[4], 5, prms);
+
+	Parm_serial((st->log_en_index), 6, prms);
+
+	CN_dith = dithering_control(st);
+	Parm_serial(CN_dith, 1, prms);
+
+	/* level = (float)( pow( 2.0f, (float)st->log_en_index / 2.625 - 2.0 ) );    */
+	/* log2(E) in Q9 (log2(E) lies in between -2:22) */
+	log_en = shl(st->log_en_index, 15 - 6);
+
+	/* Divide by 2.625; log_en will be between 0:24  */
+	log_en = mult(log_en, 12483);
+	/* the result corresponds to log2(gain) in Q10 */
+
+	/* Find integer part  */
+	log_en_int_e = (log_en >> 10);
+
+	/* Find fractional part */
+	log_en_int_m = (Word16) (log_en & 0x3ff);
+	log_en_int_m = shl(log_en_int_m, 5);
+
+	/* Subtract 2 from log_en in Q9, i.e divide the gain by 2 (energy by 4) */
+	/* Add 16 in order to have the result of pow2 in Q16 */
+	log_en_int_e = add(log_en_int_e, 16 - 1);
+
+	level32 = Pow2(log_en_int_e, log_en_int_m); /* Q16 */
+	exp0 = norm_l(level32);
+	level32 = (level32 << exp0);        /* level in Q31 */
+	exp0 = (15 - exp0);
+	level = extract_h(level32);            /* level in Q15 */
+
+	/* generate white noise vector */
+	for (i = 0; i < L_FRAME; i++)
+	{
+		exc2[i] = (Random(&(st->cng_seed)) >> 4);
+	}
+
+	/* gain = level / sqrt(ener) * sqrt(L_FRAME) */
+
+	/* energy of generated excitation */
+	ener32 = Dot_product12(exc2, exc2, L_FRAME, &exp);
+
+	Isqrt_n(&ener32, &exp);
+
+	gain = extract_h(ener32);
+
+	gain = mult(level, gain);              /* gain in Q15 */
+
+	exp = add(exp0, exp);
+
+	/* Multiply by sqrt(L_FRAME)=16, i.e. shift left by 4 */
+	exp += 4;
+
+	for (i = 0; i < L_FRAME; i++)
+	{
+		tmp = mult(exc2[i], gain);         /* Q0 * Q15 */
+		exc2[i] = shl(tmp, exp);
+	}
+
+	return 0;
+}
+
+/**************************************************************************
+*
+* Function    : dtx_buffer Purpose     : handles the DTX buffer
+*
+**************************************************************************/
+Word16 dtx_buffer(
+		dtx_encState * st,                    /* i/o : State struct                    */
+		Word16 isf_new[],                     /* i   : isf vector                      */
+		Word32 enr,                           /* i   : residual energy (in L_FRAME)    */
+		Word16 codec_mode
+		)
+{
+	Word16 log_en;
+
+	Word16 log_en_e;
+	Word16 log_en_m;
+	st->hist_ptr = add(st->hist_ptr, 1);
+	if(st->hist_ptr == DTX_HIST_SIZE)
+	{
+		st->hist_ptr = 0;
+	}
+	/* copy lsp vector into buffer */
+	Copy(isf_new, &st->isf_hist[st->hist_ptr * M], M);
+
+	/* log_en = (float)log10(enr*0.0059322)/(float)log10(2.0f);  */
+	Log2(enr, &log_en_e, &log_en_m);
+
+	/* convert exponent and mantissa to Word16 Q7. Q7 is used to simplify averaging in dtx_enc */
+	log_en = shl(log_en_e, 7);             /* Q7 */
+	log_en = add(log_en, shr(log_en_m, 15 - 7));
+
+	/* Find energy per sample by multiplying with 0.0059322, i.e subtract log2(1/0.0059322) = 7.39722 The
+	 * constant 0.0059322 takes into account windowings and analysis length from autocorrelation
+	 * computations; 7.39722 in Q7 = 947  */
+	/* Subtract 3 dB = 0.99658 in log2(E) = 127 in Q7. */
+	/* log_en = sub( log_en, 947 + en_adjust[codec_mode] ); */
+
+	/* Find energy per sample (divide by L_FRAME=256), i.e subtract log2(256) = 8.0  (1024 in Q7) */
+	/* Subtract 3 dB = 0.99658 in log2(E) = 127 in Q7. */
+
+	log_en = sub(log_en, add(1024, en_adjust[codec_mode]));
+
+	/* Insert into the buffer */
+	st->log_en_hist[st->hist_ptr] = log_en;
+	return 0;
+}
+
+/**************************************************************************
+*
+* Function    : tx_dtx_handler Purpose     : adds extra speech hangover
+*                                            to analyze speech on
+*                                            the decoding side.
+**************************************************************************/
+void tx_dtx_handler(dtx_encState * st,     /* i/o : State struct           */
+		Word16 vad_flag,                      /* i   : vad decision           */
+		Word16 * usedMode                     /* i/o : mode changed or not    */
+		)
+{
+
+	/* this state machine is in synch with the GSMEFR txDtx machine      */
+	st->decAnaElapsedCount = add(st->decAnaElapsedCount, 1);
+
+	if (vad_flag != 0)
+	{
+		st->dtxHangoverCount = DTX_HANG_CONST;
+	} else
+	{                                      /* non-speech */
+		if (st->dtxHangoverCount == 0)
+		{                                  /* out of decoder analysis hangover  */
+			st->decAnaElapsedCount = 0;
+			*usedMode = MRDTX;
+		} else
+		{                                  /* in possible analysis hangover */
+			st->dtxHangoverCount = sub(st->dtxHangoverCount, 1);
+
+			/* decAnaElapsedCount + dtxHangoverCount < DTX_ELAPSED_FRAMES_THRESH */
+			if (sub(add(st->decAnaElapsedCount, st->dtxHangoverCount),
+						DTX_ELAPSED_FRAMES_THRESH) < 0)
+			{
+				*usedMode = MRDTX;
+				/* if short time since decoder update, do not add extra HO */
+			}
+			/* else override VAD and stay in speech mode *usedMode and add extra hangover */
+		}
+	}
+
+	return;
+}
+
+
+
+static void aver_isf_history(
+		Word16 isf_old[],
+		Word16 indices[],
+		Word32 isf_aver[]
+		)
+{
+	Word32 i, j, k;
+	Word16 isf_tmp[2 * M];
+	Word32 L_tmp;
+
+	/* Memorize in isf_tmp[][] the ISF vectors to be replaced by */
+	/* the median ISF vector prior to the averaging               */
+	for (k = 0; k < 2; k++)
+	{
+		if ((indices[k] + 1) != 0)
+		{
+			for (i = 0; i < M; i++)
+			{
+				isf_tmp[k * M + i] = isf_old[indices[k] * M + i];
+				isf_old[indices[k] * M + i] = isf_old[indices[2] * M + i];
+			}
+		}
+	}
+
+	/* Perform the ISF averaging */
+	for (j = 0; j < M; j++)
+	{
+		L_tmp = 0;
+
+		for (i = 0; i < DTX_HIST_SIZE; i++)
+		{
+			L_tmp = L_add(L_tmp, L_deposit_l(isf_old[i * M + j]));
+		}
+		isf_aver[j] = L_tmp;
+	}
+
+	/* Retrieve from isf_tmp[][] the ISF vectors saved prior to averaging */
+	for (k = 0; k < 2; k++)
+	{
+		if ((indices[k] + 1) != 0)
+		{
+			for (i = 0; i < M; i++)
+			{
+				isf_old[indices[k] * M + i] = isf_tmp[k * M + i];
+			}
+		}
+	}
+
+	return;
+}
+
+static void find_frame_indices(
+		Word16 isf_old_tx[],
+		Word16 indices[],
+		dtx_encState * st
+		)
+{
+	Word32 L_tmp, summin, summax, summax2nd;
+	Word16 i, j, tmp;
+	Word16 ptr;
+
+	/* Remove the effect of the oldest frame from the column */
+	/* sum sumD[0..DTX_HIST_SIZE-1]. sumD[DTX_HIST_SIZE] is    */
+	/* not updated since it will be removed later.           */
+
+	tmp = DTX_HIST_SIZE_MIN_ONE;
+	j = -1;
+	for (i = 0; i < DTX_HIST_SIZE_MIN_ONE; i++)
+	{
+		j = add(j, tmp);
+		st->sumD[i] = L_sub(st->sumD[i], st->D[j]);
+		tmp = sub(tmp, 1);
+	}
+
+	/* Shift the column sum sumD. The element sumD[DTX_HIST_SIZE-1]    */
+	/* corresponding to the oldest frame is removed. The sum of     */
+	/* the distances between the latest isf and other isfs, */
+	/* i.e. the element sumD[0], will be computed during this call. */
+	/* Hence this element is initialized to zero.                   */
+
+	for (i = DTX_HIST_SIZE_MIN_ONE; i > 0; i--)
+	{
+		st->sumD[i] = st->sumD[i - 1];
+	}
+	st->sumD[0] = 0;
+
+	/* Remove the oldest frame from the distance matrix.           */
+	/* Note that the distance matrix is replaced by a one-         */
+	/* dimensional array to save static memory.                    */
+
+	tmp = 0;
+	for (i = 27; i >= 12; i = (Word16) (i - tmp))
+	{
+		tmp = add(tmp, 1);
+		for (j = tmp; j > 0; j--)
+		{
+			st->D[i - j + 1] = st->D[i - j - tmp];
+		}
+	}
+
+	/* Compute the first column of the distance matrix D            */
+	/* (squared Euclidean distances from isf1[] to isf_old_tx[][]). */
+
+	ptr = st->hist_ptr;
+	for (i = 1; i < DTX_HIST_SIZE; i++)
+	{
+		/* Compute the distance between the latest isf and the other isfs. */
+		ptr = sub(ptr, 1);
+		if (ptr < 0)
+		{
+			ptr = DTX_HIST_SIZE_MIN_ONE;
+		}
+		L_tmp = 0;
+		for (j = 0; j < M; j++)
+		{
+			tmp = sub(isf_old_tx[st->hist_ptr * M + j], isf_old_tx[ptr * M + j]);
+			L_tmp = L_mac(L_tmp, tmp, tmp);
+		}
+		st->D[i - 1] = L_tmp;
+
+		/* Update also the column sums. */
+		st->sumD[0] = L_add(st->sumD[0], st->D[i - 1]);
+		st->sumD[i] = L_add(st->sumD[i], st->D[i - 1]);
+	}
+
+	/* Find the minimum and maximum distances */
+	summax = st->sumD[0];
+	summin = st->sumD[0];
+	indices[0] = 0;
+	indices[2] = 0;
+	for (i = 1; i < DTX_HIST_SIZE; i++)
+	{
+		if (L_sub(st->sumD[i], summax) > 0)
+		{
+			indices[0] = i;
+			summax = st->sumD[i];
+		}
+		if (L_sub(st->sumD[i], summin) < 0)
+		{
+			indices[2] = i;
+			summin = st->sumD[i];
+		}
+	}
+
+	/* Find the second largest distance */
+	summax2nd = -2147483647L;
+	indices[1] = -1;
+	for (i = 0; i < DTX_HIST_SIZE; i++)
+	{
+		if ((L_sub(st->sumD[i], summax2nd) > 0) && (sub(i, indices[0]) != 0))
+		{
+			indices[1] = i;
+			summax2nd = st->sumD[i];
+		}
+	}
+
+	for (i = 0; i < 3; i++)
+	{
+		indices[i] = sub(st->hist_ptr, indices[i]);
+		if (indices[i] < 0)
+		{
+			indices[i] = add(indices[i], DTX_HIST_SIZE);
+		}
+	}
+
+	/* If maximum distance/MED_THRESH is smaller than minimum distance */
+	/* then the median ISF vector replacement is not performed         */
+	tmp = norm_l(summax);
+	summax = (summax << tmp);
+	summin = (summin << tmp);
+	L_tmp = L_mult(voround(summax), INV_MED_THRESH);
+	if(L_tmp <= summin)
+	{
+		indices[0] = -1;
+	}
+	/* If second largest distance/MED_THRESH is smaller than     */
+	/* minimum distance then the median ISF vector replacement is    */
+	/* not performed                                                 */
+	summax2nd = L_shl(summax2nd, tmp);
+	L_tmp = L_mult(voround(summax2nd), INV_MED_THRESH);
+	if(L_tmp <= summin)
+	{
+		indices[1] = -1;
+	}
+	return;
+}
+
+static Word16 dithering_control(
+		dtx_encState * st
+		)
+{
+	Word16 tmp, mean, CN_dith, gain_diff;
+	Word32 i, ISF_diff;
+
+	/* determine how stationary the spectrum of background noise is */
+	ISF_diff = 0;
+	for (i = 0; i < 8; i++)
+	{
+		ISF_diff = L_add(ISF_diff, st->sumD[i]);
+	}
+	if ((ISF_diff >> 26) > 0)
+	{
+		CN_dith = 1;
+	} else
+	{
+		CN_dith = 0;
+	}
+
+	/* determine how stationary the energy of background noise is */
+	mean = 0;
+	for (i = 0; i < DTX_HIST_SIZE; i++)
+	{
+		mean = add(mean, st->log_en_hist[i]);
+	}
+	mean = (mean >> 3);
+	gain_diff = 0;
+	for (i = 0; i < DTX_HIST_SIZE; i++)
+	{
+		tmp = abs_s(sub(st->log_en_hist[i], mean));
+		gain_diff = add(gain_diff, tmp);
+	}
+	if (gain_diff > GAIN_THR)
+	{
+		CN_dith = 1;
+	}
+	return CN_dith;
+}
diff --git a/media/libstagefright/codecs/amrwbenc/src/g_pitch.c b/media/libstagefright/codecs/amrwbenc/src/g_pitch.c
index 570138e..d681f2e 100644
--- a/media/libstagefright/codecs/amrwbenc/src/g_pitch.c
+++ b/media/libstagefright/codecs/amrwbenc/src/g_pitch.c
@@ -1,79 +1,79 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: g_pitch.c                                                 *
-*                                                                      *
-*	   Description:Compute the gain of pitch. Result in Q12        *
-*	               if(gain < 0) gain = 0                           *
-*				   if(gain > 1.2) gain = 1.2           *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-
-Word16 G_pitch(                            /* (o) Q14 : Gain of pitch lag saturated to 1.2   */
-		Word16 xn[],                          /* (i)     : Pitch target.                        */
-		Word16 y1[],                          /* (i)     : filtered adaptive codebook.          */
-		Word16 g_coeff[],                     /* : Correlations need for gain quantization.     */
-		Word16 L_subfr                        /* : Length of subframe.                          */
-	      )
-{
-	Word32 i;
-	Word16 xy, yy, exp_xy, exp_yy, gain;
-	/* Compute scalar product <y1[],y1[]> */
-#ifdef ASM_OPT                  /* asm optimization branch */
-	/* Compute scalar product <xn[],y1[]> */
-	xy = extract_h(Dot_product12_asm(xn, y1, L_subfr, &exp_xy));
-	yy = extract_h(Dot_product12_asm(y1, y1, L_subfr, &exp_yy));
-
-#else
-	/* Compute scalar product <xn[],y1[]> */
-	xy = extract_h(Dot_product12(xn, y1, L_subfr, &exp_xy));
-	yy = extract_h(Dot_product12(y1, y1, L_subfr, &exp_yy));
-
-#endif
-
-	g_coeff[0] = yy;                       
-	g_coeff[1] = exp_yy;                   
-	g_coeff[2] = xy;                       
-	g_coeff[3] = exp_xy;                   
-
-	/* If (xy < 0) gain = 0 */
-	if (xy < 0)
-		return ((Word16) 0);
-
-	/* compute gain = xy/yy */
-
-	xy >>= 1;                       /* Be sure xy < yy */
-	gain = div_s(xy, yy);
-
-	i = exp_xy;
-	i -= exp_yy;
-
-	gain = shl(gain, i);                   
-
-	/* if (gain > 1.2) gain = 1.2  in Q14 */
-	if(gain > 19661)
-	{
-		gain = 19661;                      
-	}
-	return (gain);
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: g_pitch.c                                                 *
+*                                                                      *
+*	   Description:Compute the gain of pitch. Result in Q12        *
+*	               if(gain < 0) gain = 0                           *
+*				   if(gain > 1.2) gain = 1.2           *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+
+Word16 G_pitch(                            /* (o) Q14 : Gain of pitch lag saturated to 1.2   */
+		Word16 xn[],                          /* (i)     : Pitch target.                        */
+		Word16 y1[],                          /* (i)     : filtered adaptive codebook.          */
+		Word16 g_coeff[],                     /* : Correlations need for gain quantization.     */
+		Word16 L_subfr                        /* : Length of subframe.                          */
+	      )
+{
+	Word32 i;
+	Word16 xy, yy, exp_xy, exp_yy, gain;
+	/* Compute scalar product <y1[],y1[]> */
+#ifdef ASM_OPT                  /* asm optimization branch */
+	/* Compute scalar product <xn[],y1[]> */
+	xy = extract_h(Dot_product12_asm(xn, y1, L_subfr, &exp_xy));
+	yy = extract_h(Dot_product12_asm(y1, y1, L_subfr, &exp_yy));
+
+#else
+	/* Compute scalar product <xn[],y1[]> */
+	xy = extract_h(Dot_product12(xn, y1, L_subfr, &exp_xy));
+	yy = extract_h(Dot_product12(y1, y1, L_subfr, &exp_yy));
+
+#endif
+
+	g_coeff[0] = yy;
+	g_coeff[1] = exp_yy;
+	g_coeff[2] = xy;
+	g_coeff[3] = exp_xy;
+
+	/* If (xy < 0) gain = 0 */
+	if (xy < 0)
+		return ((Word16) 0);
+
+	/* compute gain = xy/yy */
+
+	xy >>= 1;                       /* Be sure xy < yy */
+	gain = div_s(xy, yy);
+
+	i = exp_xy;
+	i -= exp_yy;
+
+	gain = shl(gain, i);
+
+	/* if (gain > 1.2) gain = 1.2  in Q14 */
+	if(gain > 19661)
+	{
+		gain = 19661;
+	}
+	return (gain);
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/gpclip.c b/media/libstagefright/codecs/amrwbenc/src/gpclip.c
index e23f2f4..800b3f9 100644
--- a/media/libstagefright/codecs/amrwbenc/src/gpclip.c
+++ b/media/libstagefright/codecs/amrwbenc/src/gpclip.c
@@ -1,110 +1,110 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/**************************************************************************
-*      File: gpclip.c                                                     *
-*                                                                         *
-*      Description:To avoid unstable synthesis on frame erasure, the gain *
-*      need to be limited(gain pitch < 1.0) when the following            *
-*      case occurs                                                        *
-*      a resonance on LPC filter(lp_disp < 60Hz)                          *
-*      a good pitch prediction (lp_gp > 0.95)                             *
-*                                                                         *   
-***************************************************************************/
-#include "typedef.h"
-#include "basic_op.h"
-
-#define DIST_ISF_MAX    307                /* 120 Hz (6400Hz=16384) */
-#define DIST_ISF_THRES  154                /* 60     (6400Hz=16384) */
-#define GAIN_PIT_THRES  14746              /* 0.9 in Q14 */
-#define GAIN_PIT_MIN    9830               /* 0.6 in Q14 */
-#define M               16
-
-
-void Init_gp_clip(
-		Word16 mem[]                          /* (o) : memory of gain of pitch clipping algorithm */
-		)
-{
-	mem[0] = DIST_ISF_MAX;                 
-	mem[1] = GAIN_PIT_MIN;                 
-}
-
-
-Word16 Gp_clip(
-		Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
-	      )
-{
-	Word16 clip = 0;
-	if ((mem[0] < DIST_ISF_THRES) && (mem[1] > GAIN_PIT_THRES))
-		clip = 1;                          
-
-	return (clip);
-}
-
-
-void Gp_clip_test_isf(
-		Word16 isf[],                         /* (i)   : isf values (in frequency domain)           */
-		Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
-		)
-{
-	Word16 dist, dist_min;
-	Word32 i;
-
-	dist_min = vo_sub(isf[1], isf[0]);
-
-	for (i = 2; i < M - 1; i++)
-	{
-		dist = vo_sub(isf[i], isf[i - 1]);
-		if(dist < dist_min)
-		{
-			dist_min = dist;               
-		}
-	}
-
-	dist = extract_h(L_mac(vo_L_mult(26214, mem[0]), 6554, dist_min));
-
-	if (dist > DIST_ISF_MAX)
-	{
-		dist = DIST_ISF_MAX;               
-	}
-	mem[0] = dist;                        
-
-	return;
-}
-
-
-void Gp_clip_test_gain_pit(
-		Word16 gain_pit,                      /* (i) Q14 : gain of quantized pitch                    */
-		Word16 mem[]                          /* (i/o)   : memory of gain of pitch clipping algorithm */
-		)
-{
-	Word16 gain;
-	Word32 L_tmp;
-	L_tmp = (29491 * mem[1])<<1;
-	L_tmp += (3277 * gain_pit)<<1;
-
-	gain = extract_h(L_tmp);
-
-	if(gain < GAIN_PIT_MIN)
-	{
-		gain = GAIN_PIT_MIN;              
-	}
-	mem[1] = gain;                         
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/**************************************************************************
+*      File: gpclip.c                                                     *
+*                                                                         *
+*      Description:To avoid unstable synthesis on frame erasure, the gain *
+*      need to be limited(gain pitch < 1.0) when the following            *
+*      case occurs                                                        *
+*      a resonance on LPC filter(lp_disp < 60Hz)                          *
+*      a good pitch prediction (lp_gp > 0.95)                             *
+*                                                                         *
+***************************************************************************/
+#include "typedef.h"
+#include "basic_op.h"
+
+#define DIST_ISF_MAX    307                /* 120 Hz (6400Hz=16384) */
+#define DIST_ISF_THRES  154                /* 60     (6400Hz=16384) */
+#define GAIN_PIT_THRES  14746              /* 0.9 in Q14 */
+#define GAIN_PIT_MIN    9830               /* 0.6 in Q14 */
+#define M               16
+
+
+void Init_gp_clip(
+		Word16 mem[]                          /* (o) : memory of gain of pitch clipping algorithm */
+		)
+{
+	mem[0] = DIST_ISF_MAX;
+	mem[1] = GAIN_PIT_MIN;
+}
+
+
+Word16 Gp_clip(
+		Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
+	      )
+{
+	Word16 clip = 0;
+	if ((mem[0] < DIST_ISF_THRES) && (mem[1] > GAIN_PIT_THRES))
+		clip = 1;
+
+	return (clip);
+}
+
+
+void Gp_clip_test_isf(
+		Word16 isf[],                         /* (i)   : isf values (in frequency domain)           */
+		Word16 mem[]                          /* (i/o) : memory of gain of pitch clipping algorithm */
+		)
+{
+	Word16 dist, dist_min;
+	Word32 i;
+
+	dist_min = vo_sub(isf[1], isf[0]);
+
+	for (i = 2; i < M - 1; i++)
+	{
+		dist = vo_sub(isf[i], isf[i - 1]);
+		if(dist < dist_min)
+		{
+			dist_min = dist;
+		}
+	}
+
+	dist = extract_h(L_mac(vo_L_mult(26214, mem[0]), 6554, dist_min));
+
+	if (dist > DIST_ISF_MAX)
+	{
+		dist = DIST_ISF_MAX;
+	}
+	mem[0] = dist;
+
+	return;
+}
+
+
+void Gp_clip_test_gain_pit(
+		Word16 gain_pit,                      /* (i) Q14 : gain of quantized pitch                    */
+		Word16 mem[]                          /* (i/o)   : memory of gain of pitch clipping algorithm */
+		)
+{
+	Word16 gain;
+	Word32 L_tmp;
+	L_tmp = (29491 * mem[1])<<1;
+	L_tmp += (3277 * gain_pit)<<1;
+
+	gain = extract_h(L_tmp);
+
+	if(gain < GAIN_PIT_MIN)
+	{
+		gain = GAIN_PIT_MIN;
+	}
+	mem[1] = gain;
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/homing.c b/media/libstagefright/codecs/amrwbenc/src/homing.c
index 015633f..565040f 100644
--- a/media/libstagefright/codecs/amrwbenc/src/homing.c
+++ b/media/libstagefright/codecs/amrwbenc/src/homing.c
@@ -1,46 +1,46 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: homing.c                                                 *
-*                                                                      *
-*       Description:Performs the homing routines                       *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "cnst.h"
-#include "basic_op.h"
-#include "bits.h"
-#include "homing.tab"
-
-Word16 encoder_homing_frame_test(Word16 input_frame[])
-{
-	Word32 i;
-	Word16 j = 0;
-
-	/* check 320 input samples for matching EHF_MASK: defined in e_homing.h */
-	for (i = 0; i < L_FRAME16k; i++)
-	{
-		j = (Word16) (input_frame[i] ^ EHF_MASK);
-
-		if (j)
-			break;
-	}
-
-	return (Word16) (!j);
-}
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: homing.c                                                 *
+*                                                                      *
+*       Description:Performs the homing routines                       *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "cnst.h"
+#include "basic_op.h"
+#include "bits.h"
+#include "homing.tab"
+
+Word16 encoder_homing_frame_test(Word16 input_frame[])
+{
+	Word32 i;
+	Word16 j = 0;
+
+	/* check 320 input samples for matching EHF_MASK: defined in e_homing.h */
+	for (i = 0; i < L_FRAME16k; i++)
+	{
+		j = (Word16) (input_frame[i] ^ EHF_MASK);
+
+		if (j)
+			break;
+	}
+
+	return (Word16) (!j);
+}
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/hp400.c b/media/libstagefright/codecs/amrwbenc/src/hp400.c
index 463a53a..a6f9701 100644
--- a/media/libstagefright/codecs/amrwbenc/src/hp400.c
+++ b/media/libstagefright/codecs/amrwbenc/src/hp400.c
@@ -1,106 +1,106 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: hp400.c                                                    *
-*                                                                       *
-*      Description:                                                     *
-* 2nd order high pass filter with cut off frequency at 400 Hz.          *
-* Designed with cheby2 function in MATLAB.                              *
-* Optimized for fixed-point to get the following frequency response:    *
-*                                                                       *
-*  frequency:     0Hz   100Hz  200Hz  300Hz  400Hz  630Hz  1.5kHz  3kHz *
-*  dB loss:     -infdB  -30dB  -20dB  -10dB  -3dB   +6dB    +1dB    0dB *
-*                                                                       *
-* Algorithm:                                                            *
-*                                                                       *
-*  y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2]                         *
-*                   + a[1]*y[i-1] + a[2]*y[i-2];                        *
-*                                                                       *
-*  Word16 b[3] = {3660, -7320,  3660};       in Q12                     *
-*  Word16 a[3] = {4096,  7320, -3540};       in Q12                     *
-*                                                                       *
-*  float -->   b[3] = {0.893554687, -1.787109375,  0.893554687};        *
-*              a[3] = {1.000000000,  1.787109375, -0.864257812};        *
-*                                                                       *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "acelp.h"
-
-/* filter coefficients  */
-static Word16 b[3] = {915, -1830, 915};         /* Q12 (/4) */
-static Word16 a[3] = {16384, 29280, -14160};    /* Q12 (x4) */
-/* Initialization of static values */
-
-void Init_HP400_12k8(Word16 mem[])
-{
-	Set_zero(mem, 6);
-}
-
-
-void HP400_12k8(
-		Word16 signal[],                      /* input signal / output is divided by 16 */
-		Word16 lg,                            /* lenght of signal    */
-		Word16 mem[]                          /* filter memory [6]   */
-	       )
-{
-	Word16  x2;
-	Word16 y2_hi, y2_lo, y1_hi, y1_lo, x0, x1;
-	Word32 L_tmp;
-	Word32 num;
-	y2_hi = *mem++;
-	y2_lo = *mem++;
-	y1_hi = *mem++;
-	y1_lo = *mem++;
-	x0 = *mem++;   
-	x1 = *mem;   
-	num = (Word32)lg;
-	do
-	{
-		x2 = x1;
-		x1 = x0;
-		x0 = *signal;
-		/* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2]  */
-		/* + a[1]*y[i-1] + a[2] * y[i-2];  */
-		L_tmp = 8192L;                    /* rounding to maximise precision */
-		L_tmp += y1_lo * a[1];
-		L_tmp += y2_lo * a[2];
-		L_tmp = L_tmp >> 14;
-		L_tmp += (y1_hi * a[1] + y2_hi * a[2] + (x0 + x2)* b[0] + x1 * b[1]) << 1;
-		L_tmp <<= 1;           /* coeff Q12 --> Q13 */
-		y2_hi = y1_hi;
-		y2_lo = y1_lo;
-		y1_hi = (Word16)(L_tmp>>16);
-		y1_lo = (Word16)((L_tmp & 0xffff)>>1);
-
-		/* signal is divided by 16 to avoid overflow in energy computation */
-		*signal++ = (L_tmp + 0x8000) >> 16;
-	}while(--num !=0);
-
-	*mem-- = x1;
-	*mem-- = x0;
-	*mem-- = y1_lo;
-	*mem-- = y1_hi;
-	*mem-- = y2_lo;
-	*mem   = y2_hi;  
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: hp400.c                                                    *
+*                                                                       *
+*      Description:                                                     *
+* 2nd order high pass filter with cut off frequency at 400 Hz.          *
+* Designed with cheby2 function in MATLAB.                              *
+* Optimized for fixed-point to get the following frequency response:    *
+*                                                                       *
+*  frequency:     0Hz   100Hz  200Hz  300Hz  400Hz  630Hz  1.5kHz  3kHz *
+*  dB loss:     -infdB  -30dB  -20dB  -10dB  -3dB   +6dB    +1dB    0dB *
+*                                                                       *
+* Algorithm:                                                            *
+*                                                                       *
+*  y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2]                         *
+*                   + a[1]*y[i-1] + a[2]*y[i-2];                        *
+*                                                                       *
+*  Word16 b[3] = {3660, -7320,  3660};       in Q12                     *
+*  Word16 a[3] = {4096,  7320, -3540};       in Q12                     *
+*                                                                       *
+*  float -->   b[3] = {0.893554687, -1.787109375,  0.893554687};        *
+*              a[3] = {1.000000000,  1.787109375, -0.864257812};        *
+*                                                                       *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "acelp.h"
+
+/* filter coefficients  */
+static Word16 b[3] = {915, -1830, 915};         /* Q12 (/4) */
+static Word16 a[3] = {16384, 29280, -14160};    /* Q12 (x4) */
+/* Initialization of static values */
+
+void Init_HP400_12k8(Word16 mem[])
+{
+	Set_zero(mem, 6);
+}
+
+
+void HP400_12k8(
+		Word16 signal[],                      /* input signal / output is divided by 16 */
+		Word16 lg,                            /* lenght of signal    */
+		Word16 mem[]                          /* filter memory [6]   */
+	       )
+{
+	Word16  x2;
+	Word16 y2_hi, y2_lo, y1_hi, y1_lo, x0, x1;
+	Word32 L_tmp;
+	Word32 num;
+	y2_hi = *mem++;
+	y2_lo = *mem++;
+	y1_hi = *mem++;
+	y1_lo = *mem++;
+	x0 = *mem++;
+	x1 = *mem;
+	num = (Word32)lg;
+	do
+	{
+		x2 = x1;
+		x1 = x0;
+		x0 = *signal;
+		/* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2]  */
+		/* + a[1]*y[i-1] + a[2] * y[i-2];  */
+		L_tmp = 8192L;                    /* rounding to maximise precision */
+		L_tmp += y1_lo * a[1];
+		L_tmp += y2_lo * a[2];
+		L_tmp = L_tmp >> 14;
+		L_tmp += (y1_hi * a[1] + y2_hi * a[2] + (x0 + x2)* b[0] + x1 * b[1]) << 1;
+		L_tmp <<= 1;           /* coeff Q12 --> Q13 */
+		y2_hi = y1_hi;
+		y2_lo = y1_lo;
+		y1_hi = (Word16)(L_tmp>>16);
+		y1_lo = (Word16)((L_tmp & 0xffff)>>1);
+
+		/* signal is divided by 16 to avoid overflow in energy computation */
+		*signal++ = (L_tmp + 0x8000) >> 16;
+	}while(--num !=0);
+
+	*mem-- = x1;
+	*mem-- = x0;
+	*mem-- = y1_lo;
+	*mem-- = y1_hi;
+	*mem-- = y2_lo;
+	*mem   = y2_hi;
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/hp50.c b/media/libstagefright/codecs/amrwbenc/src/hp50.c
index 53e3d7b..c1c7b83 100644
--- a/media/libstagefright/codecs/amrwbenc/src/hp50.c
+++ b/media/libstagefright/codecs/amrwbenc/src/hp50.c
@@ -1,106 +1,106 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: hp50.c                                                     *
-*                                                                       *
-*	   Description:                                                 *
-* 2nd order high pass filter with cut off frequency at 31 Hz.           *
-* Designed with cheby2 function in MATLAB.                              *
-* Optimized for fixed-point to get the following frequency response:    *
-*                                                                       *
-*  frequency:     0Hz    14Hz  24Hz   31Hz   37Hz   41Hz   47Hz         *
-*  dB loss:     -infdB  -15dB  -6dB   -3dB  -1.5dB  -1dB  -0.5dB        *
-*                                                                       *
-* Algorithm:                                                            *
-*                                                                       *
-*  y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2]                         *
-*                   + a[1]*y[i-1] + a[2]*y[i-2];                        *
-*                                                                       *
-*  Word16 b[3] = {4053, -8106, 4053};       in Q12                      *
-*  Word16 a[3] = {8192, 16211, -8021};       in Q12                     *
-*                                                                       *
-*  float -->   b[3] = {0.989501953, -1.979003906,  0.989501953};        *
-*              a[3] = {1.000000000,  1.978881836, -0.979125977};        *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "cnst.h"
-#include "acelp.h"
-
-/* filter coefficients  */
-static Word16 b[3] = {4053, -8106, 4053};  /* Q12 */
-static Word16 a[3] = {8192, 16211, -8021}; /* Q12 (x2) */
-
-/* Initialization of static values */
-
-void Init_HP50_12k8(Word16 mem[])
-{
-	Set_zero(mem, 6);
-}
-
-
-void HP50_12k8(
-		Word16 signal[],                      /* input/output signal */
-		Word16 lg,                            /* lenght of signal    */
-		Word16 mem[]                          /* filter memory [6]   */
-	      )
-{
-	Word16 x2;
-	Word16 y2_hi, y2_lo, y1_hi, y1_lo, x0, x1;
-	Word32 L_tmp;
-	Word32 num;
-
-	y2_hi = *mem++;
-	y2_lo = *mem++;
-	y1_hi = *mem++;
-	y1_lo = *mem++;
-	x0 = *mem++;   
-	x1 = *mem;
-	num = (Word32)lg;
-	do
-	{
-		x2 = x1;
-		x1 = x0;
-		x0 = *signal;
-		/* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2]  */
-		/* + a[1]*y[i-1] + a[2] * y[i-2];  */
-		L_tmp = 8192 ;                    /* rounding to maximise precision */
-		L_tmp += y1_lo * a[1];
-		L_tmp += y2_lo * a[2];
-		L_tmp = L_tmp >> 14;
-		L_tmp += (y1_hi * a[1] + y2_hi * a[2] + (x0 + x2) * b[0] + x1 * b[1]) << 1;
-		L_tmp <<= 2;           /* coeff Q12 --> Q13 */
-		y2_hi = y1_hi;
-		y2_lo = y1_lo;
-		y1_hi = (Word16)(L_tmp>>16);
-		y1_lo = (Word16)((L_tmp & 0xffff)>>1);
-		*signal++ = extract_h((L_add((L_tmp<<1), 0x8000)));
-	}while(--num !=0);
-
-	*mem-- = x1;
-	*mem-- = x0;
-	*mem-- = y1_lo;
-	*mem-- = y1_hi;
-	*mem-- = y2_lo;
-	*mem-- = y2_hi;  
-
-	return;
-}
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: hp50.c                                                     *
+*                                                                       *
+*	   Description:                                                 *
+* 2nd order high pass filter with cut off frequency at 31 Hz.           *
+* Designed with cheby2 function in MATLAB.                              *
+* Optimized for fixed-point to get the following frequency response:    *
+*                                                                       *
+*  frequency:     0Hz    14Hz  24Hz   31Hz   37Hz   41Hz   47Hz         *
+*  dB loss:     -infdB  -15dB  -6dB   -3dB  -1.5dB  -1dB  -0.5dB        *
+*                                                                       *
+* Algorithm:                                                            *
+*                                                                       *
+*  y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2]                         *
+*                   + a[1]*y[i-1] + a[2]*y[i-2];                        *
+*                                                                       *
+*  Word16 b[3] = {4053, -8106, 4053};       in Q12                      *
+*  Word16 a[3] = {8192, 16211, -8021};       in Q12                     *
+*                                                                       *
+*  float -->   b[3] = {0.989501953, -1.979003906,  0.989501953};        *
+*              a[3] = {1.000000000,  1.978881836, -0.979125977};        *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "cnst.h"
+#include "acelp.h"
+
+/* filter coefficients  */
+static Word16 b[3] = {4053, -8106, 4053};  /* Q12 */
+static Word16 a[3] = {8192, 16211, -8021}; /* Q12 (x2) */
+
+/* Initialization of static values */
+
+void Init_HP50_12k8(Word16 mem[])
+{
+	Set_zero(mem, 6);
+}
+
+
+void HP50_12k8(
+		Word16 signal[],                      /* input/output signal */
+		Word16 lg,                            /* lenght of signal    */
+		Word16 mem[]                          /* filter memory [6]   */
+	      )
+{
+	Word16 x2;
+	Word16 y2_hi, y2_lo, y1_hi, y1_lo, x0, x1;
+	Word32 L_tmp;
+	Word32 num;
+
+	y2_hi = *mem++;
+	y2_lo = *mem++;
+	y1_hi = *mem++;
+	y1_lo = *mem++;
+	x0 = *mem++;
+	x1 = *mem;
+	num = (Word32)lg;
+	do
+	{
+		x2 = x1;
+		x1 = x0;
+		x0 = *signal;
+		/* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2]  */
+		/* + a[1]*y[i-1] + a[2] * y[i-2];  */
+		L_tmp = 8192 ;                    /* rounding to maximise precision */
+		L_tmp += y1_lo * a[1];
+		L_tmp += y2_lo * a[2];
+		L_tmp = L_tmp >> 14;
+		L_tmp += (y1_hi * a[1] + y2_hi * a[2] + (x0 + x2) * b[0] + x1 * b[1]) << 1;
+		L_tmp <<= 2;           /* coeff Q12 --> Q13 */
+		y2_hi = y1_hi;
+		y2_lo = y1_lo;
+		y1_hi = (Word16)(L_tmp>>16);
+		y1_lo = (Word16)((L_tmp & 0xffff)>>1);
+		*signal++ = extract_h((L_add((L_tmp<<1), 0x8000)));
+	}while(--num !=0);
+
+	*mem-- = x1;
+	*mem-- = x0;
+	*mem-- = y1_lo;
+	*mem-- = y1_hi;
+	*mem-- = y2_lo;
+	*mem-- = y2_hi;
+
+	return;
+}
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/hp6k.c b/media/libstagefright/codecs/amrwbenc/src/hp6k.c
index 5ee5b20..8e66eb0 100644
--- a/media/libstagefright/codecs/amrwbenc/src/hp6k.c
+++ b/media/libstagefright/codecs/amrwbenc/src/hp6k.c
@@ -1,93 +1,93 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: hp6k.c                                                    *
-*                                                                       *
-*	Description:15th order band pass 6kHz to 7kHz FIR filter        *
-*       frequency: 4kHz   5kHz  5.5kHz  6kHz  6.5kHz  7kHz 7.5kHz 8kHz  *
-*	dB loss:  -60dB  -45dB  -13dB   -3dB   0dB    -3dB -13dB  -45dB *
-*	                                                                *                                                                 
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "acelp.h"
-#include "cnst.h"
-
-#define L_FIR 31
-
-/* filter coefficients (gain=4.0) */
-
-Word16 fir_6k_7k[L_FIR] =
-{
-	-32, 47, 32, -27, -369,
-	1122, -1421, 0, 3798, -8880,
-	12349, -10984, 3548, 7766, -18001,
-	22118, -18001, 7766, 3548, -10984,
-	12349, -8880, 3798, 0, -1421,
-	1122, -369, -27, 32, 47,
-	-32
-};
-
-
-void Init_Filt_6k_7k(Word16 mem[])         /* mem[30] */
-{
-	Set_zero(mem, L_FIR - 1);
-	return;
-}
-
-void Filt_6k_7k(
-		Word16 signal[],                      /* input:  signal                  */
-		Word16 lg,                            /* input:  length of input         */
-		Word16 mem[]                          /* in/out: memory (size=30)        */
-	       )
-{
-	Word16 x[L_SUBFR16k + (L_FIR - 1)];
-	Word32 i, L_tmp;
-
-	Copy(mem, x, L_FIR - 1);
-	for (i = lg - 1; i >= 0; i--)
-	{
-		x[i + L_FIR - 1] = signal[i] >> 2;                         /* gain of filter = 4 */
-	}	
-	for (i = 0; i < lg; i++)
-	{
-		L_tmp =  (x[i] + x[i+ 30]) * fir_6k_7k[0];
-		L_tmp += (x[i+1] + x[i + 29]) * fir_6k_7k[1];
-		L_tmp += (x[i+2] + x[i + 28]) * fir_6k_7k[2];
-		L_tmp += (x[i+3] + x[i + 27]) * fir_6k_7k[3];
-		L_tmp += (x[i+4] + x[i + 26]) * fir_6k_7k[4];
-		L_tmp += (x[i+5] + x[i + 25]) * fir_6k_7k[5];
-		L_tmp += (x[i+6] + x[i + 24]) * fir_6k_7k[6];
-		L_tmp += (x[i+7] + x[i + 23]) * fir_6k_7k[7];
-		L_tmp += (x[i+8] + x[i + 22]) * fir_6k_7k[8];
-		L_tmp += (x[i+9] + x[i + 21]) * fir_6k_7k[9];
-		L_tmp += (x[i+10] + x[i + 20]) * fir_6k_7k[10];
-		L_tmp += (x[i+11] + x[i + 19]) * fir_6k_7k[11];
-		L_tmp += (x[i+12] + x[i + 18]) * fir_6k_7k[12];
-		L_tmp += (x[i+13] + x[i + 17]) * fir_6k_7k[13];
-		L_tmp += (x[i+14] + x[i + 16]) * fir_6k_7k[14];
-		L_tmp += (x[i+15]) * fir_6k_7k[15];
-		signal[i] = (L_tmp + 0x4000) >> 15;
-	}
-
-	Copy(x + lg, mem, L_FIR - 1);
-
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: hp6k.c                                                    *
+*                                                                       *
+*	Description:15th order band pass 6kHz to 7kHz FIR filter        *
+*       frequency: 4kHz   5kHz  5.5kHz  6kHz  6.5kHz  7kHz 7.5kHz 8kHz  *
+*	dB loss:  -60dB  -45dB  -13dB   -3dB   0dB    -3dB -13dB  -45dB *
+*	                                                                *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "acelp.h"
+#include "cnst.h"
+
+#define L_FIR 31
+
+/* filter coefficients (gain=4.0) */
+
+Word16 fir_6k_7k[L_FIR] =
+{
+	-32, 47, 32, -27, -369,
+	1122, -1421, 0, 3798, -8880,
+	12349, -10984, 3548, 7766, -18001,
+	22118, -18001, 7766, 3548, -10984,
+	12349, -8880, 3798, 0, -1421,
+	1122, -369, -27, 32, 47,
+	-32
+};
+
+
+void Init_Filt_6k_7k(Word16 mem[])         /* mem[30] */
+{
+	Set_zero(mem, L_FIR - 1);
+	return;
+}
+
+void Filt_6k_7k(
+		Word16 signal[],                      /* input:  signal                  */
+		Word16 lg,                            /* input:  length of input         */
+		Word16 mem[]                          /* in/out: memory (size=30)        */
+	       )
+{
+	Word16 x[L_SUBFR16k + (L_FIR - 1)];
+	Word32 i, L_tmp;
+
+	Copy(mem, x, L_FIR - 1);
+	for (i = lg - 1; i >= 0; i--)
+	{
+		x[i + L_FIR - 1] = signal[i] >> 2;                         /* gain of filter = 4 */
+	}
+	for (i = 0; i < lg; i++)
+	{
+		L_tmp =  (x[i] + x[i+ 30]) * fir_6k_7k[0];
+		L_tmp += (x[i+1] + x[i + 29]) * fir_6k_7k[1];
+		L_tmp += (x[i+2] + x[i + 28]) * fir_6k_7k[2];
+		L_tmp += (x[i+3] + x[i + 27]) * fir_6k_7k[3];
+		L_tmp += (x[i+4] + x[i + 26]) * fir_6k_7k[4];
+		L_tmp += (x[i+5] + x[i + 25]) * fir_6k_7k[5];
+		L_tmp += (x[i+6] + x[i + 24]) * fir_6k_7k[6];
+		L_tmp += (x[i+7] + x[i + 23]) * fir_6k_7k[7];
+		L_tmp += (x[i+8] + x[i + 22]) * fir_6k_7k[8];
+		L_tmp += (x[i+9] + x[i + 21]) * fir_6k_7k[9];
+		L_tmp += (x[i+10] + x[i + 20]) * fir_6k_7k[10];
+		L_tmp += (x[i+11] + x[i + 19]) * fir_6k_7k[11];
+		L_tmp += (x[i+12] + x[i + 18]) * fir_6k_7k[12];
+		L_tmp += (x[i+13] + x[i + 17]) * fir_6k_7k[13];
+		L_tmp += (x[i+14] + x[i + 16]) * fir_6k_7k[14];
+		L_tmp += (x[i+15]) * fir_6k_7k[15];
+		signal[i] = (L_tmp + 0x4000) >> 15;
+	}
+
+	Copy(x + lg, mem, L_FIR - 1);
+
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/hp_wsp.c b/media/libstagefright/codecs/amrwbenc/src/hp_wsp.c
index 7fb62a4..bc1ec49 100644
--- a/media/libstagefright/codecs/amrwbenc/src/hp_wsp.c
+++ b/media/libstagefright/codecs/amrwbenc/src/hp_wsp.c
@@ -1,148 +1,148 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: hp_wsp.c                                                  *
-*       Description:                                                    *
-*       3nd order high pass filter with cut off frequency at 180Hz      *
-* Algorithm:                                                            *
-*                                                                       *
-*  y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2] + b[3]*x[i-3]           *
-*                   + a[1]*y[i-1] + a[2]*y[i-2] + a[3]*y[i-3];          *
-*                                                                       *
-* float a_coef[HP_ORDER]= {                                             *
-*    -2.64436711600664f,                                                *
-*    2.35087386625360f,                                                 *
-*   -0.70001156927424f};                                                *
-*                                                                       *
-* float b_coef[HP_ORDER+1]= {                                           *
-*     -0.83787057505665f,                                               *
-*    2.50975570071058f,                                                 *
-*   -2.50975570071058f,                                                 *
-*    0.83787057505665f};                                                *
-*                                                                       *
-*************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "acelp.h"
-
-/* filter coefficients in Q12 */
-static Word16 a[4] = {8192, 21663, -19258, 5734};
-static Word16 b[4] = {-3432, +10280, -10280, +3432};
-
-/* Initialization of static values */
-void Init_Hp_wsp(Word16 mem[])
-{
-	Set_zero(mem, 9);
-
-	return;
-}
-
-void scale_mem_Hp_wsp(Word16 mem[], Word16 exp)
-{
-	Word32 i;
-	Word32 L_tmp;
-
-	for (i = 0; i < 6; i += 2)
-	{
-		L_tmp = ((mem[i] << 16) + (mem[i + 1]<<1));
-		L_tmp = L_shl(L_tmp, exp);
-		mem[i] = L_tmp >> 16;
-		mem[i + 1] = (L_tmp & 0xffff)>>1;
-	}
-
-	for (i = 6; i < 9; i++)
-	{
-		L_tmp = L_deposit_h(mem[i]);       /* x[i] */
-		L_tmp = L_shl(L_tmp, exp);
-		mem[i] = vo_round(L_tmp);
-	}
-
-	return;
-}
-
-
-void Hp_wsp(
-		Word16 wsp[],                         /* i   : wsp[]  signal       */
-		Word16 hp_wsp[],                      /* o   : hypass wsp[]        */
-		Word16 lg,                            /* i   : lenght of signal    */
-		Word16 mem[]                          /* i/o : filter memory [9]   */
-	   )
-{
-	Word16 x0, x1, x2, x3;
-	Word16 y3_hi, y3_lo, y2_hi, y2_lo, y1_hi, y1_lo;
-	Word32 i, L_tmp;
-
-	y3_hi = mem[0];                        
-	y3_lo = mem[1];                        
-	y2_hi = mem[2];                        
-	y2_lo = mem[3];                        
-	y1_hi = mem[4];                        
-	y1_lo = mem[5];                        
-	x0 = mem[6];                           
-	x1 = mem[7];                           
-	x2 = mem[8];                           
-
-	for (i = 0; i < lg; i++)
-	{
-		x3 = x2;                           
-		x2 = x1;                           
-		x1 = x0;                           
-		x0 = wsp[i];                       
-		/* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2] + b[3]*x[i-3]  */
-		/* + a[1]*y[i-1] + a[2] * y[i-2]  + a[3]*y[i-3]  */
-
-		L_tmp = 16384L;                    /* rounding to maximise precision */
-		L_tmp += (y1_lo * a[1])<<1;
-		L_tmp += (y2_lo * a[2])<<1;
-		L_tmp += (y3_lo * a[3])<<1;
-		L_tmp = L_tmp >> 15;
-		L_tmp += (y1_hi * a[1])<<1;
-		L_tmp += (y2_hi * a[2])<<1;
-		L_tmp += (y3_hi * a[3])<<1;
-		L_tmp += (x0 * b[0])<<1;
-		L_tmp += (x1 * b[1])<<1;
-		L_tmp += (x2 * b[2])<<1;
-		L_tmp += (x3 * b[3])<<1;
-
-		L_tmp = L_tmp << 2;
-
-		y3_hi = y2_hi;                     
-		y3_lo = y2_lo;                     
-		y2_hi = y1_hi;                     
-		y2_lo = y1_lo; 
-		y1_hi = L_tmp >> 16;
-		y1_lo = (L_tmp & 0xffff) >>1;
-
-		hp_wsp[i] = (L_tmp + 0x4000)>>15;          
-	}
-
-	mem[0] = y3_hi;                        
-	mem[1] = y3_lo;                        
-	mem[2] = y2_hi;                        
-	mem[3] = y2_lo;                        
-	mem[4] = y1_hi;                        
-	mem[5] = y1_lo;                        
-	mem[6] = x0;                           
-	mem[7] = x1;                           
-	mem[8] = x2;                           
-
-	return;
-}
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: hp_wsp.c                                                  *
+*       Description:                                                    *
+*       3nd order high pass filter with cut off frequency at 180Hz      *
+* Algorithm:                                                            *
+*                                                                       *
+*  y[i] = b[0]*x[i] + b[1]*x[i-1] + b[2]*x[i-2] + b[3]*x[i-3]           *
+*                   + a[1]*y[i-1] + a[2]*y[i-2] + a[3]*y[i-3];          *
+*                                                                       *
+* float a_coef[HP_ORDER]= {                                             *
+*    -2.64436711600664f,                                                *
+*    2.35087386625360f,                                                 *
+*   -0.70001156927424f};                                                *
+*                                                                       *
+* float b_coef[HP_ORDER+1]= {                                           *
+*     -0.83787057505665f,                                               *
+*    2.50975570071058f,                                                 *
+*   -2.50975570071058f,                                                 *
+*    0.83787057505665f};                                                *
+*                                                                       *
+*************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "acelp.h"
+
+/* filter coefficients in Q12 */
+static Word16 a[4] = {8192, 21663, -19258, 5734};
+static Word16 b[4] = {-3432, +10280, -10280, +3432};
+
+/* Initialization of static values */
+void Init_Hp_wsp(Word16 mem[])
+{
+	Set_zero(mem, 9);
+
+	return;
+}
+
+void scale_mem_Hp_wsp(Word16 mem[], Word16 exp)
+{
+	Word32 i;
+	Word32 L_tmp;
+
+	for (i = 0; i < 6; i += 2)
+	{
+		L_tmp = ((mem[i] << 16) + (mem[i + 1]<<1));
+		L_tmp = L_shl(L_tmp, exp);
+		mem[i] = L_tmp >> 16;
+		mem[i + 1] = (L_tmp & 0xffff)>>1;
+	}
+
+	for (i = 6; i < 9; i++)
+	{
+		L_tmp = L_deposit_h(mem[i]);       /* x[i] */
+		L_tmp = L_shl(L_tmp, exp);
+		mem[i] = vo_round(L_tmp);
+	}
+
+	return;
+}
+
+
+void Hp_wsp(
+		Word16 wsp[],                         /* i   : wsp[]  signal       */
+		Word16 hp_wsp[],                      /* o   : hypass wsp[]        */
+		Word16 lg,                            /* i   : lenght of signal    */
+		Word16 mem[]                          /* i/o : filter memory [9]   */
+	   )
+{
+	Word16 x0, x1, x2, x3;
+	Word16 y3_hi, y3_lo, y2_hi, y2_lo, y1_hi, y1_lo;
+	Word32 i, L_tmp;
+
+	y3_hi = mem[0];
+	y3_lo = mem[1];
+	y2_hi = mem[2];
+	y2_lo = mem[3];
+	y1_hi = mem[4];
+	y1_lo = mem[5];
+	x0 = mem[6];
+	x1 = mem[7];
+	x2 = mem[8];
+
+	for (i = 0; i < lg; i++)
+	{
+		x3 = x2;
+		x2 = x1;
+		x1 = x0;
+		x0 = wsp[i];
+		/* y[i] = b[0]*x[i] + b[1]*x[i-1] + b140[2]*x[i-2] + b[3]*x[i-3]  */
+		/* + a[1]*y[i-1] + a[2] * y[i-2]  + a[3]*y[i-3]  */
+
+		L_tmp = 16384L;                    /* rounding to maximise precision */
+		L_tmp += (y1_lo * a[1])<<1;
+		L_tmp += (y2_lo * a[2])<<1;
+		L_tmp += (y3_lo * a[3])<<1;
+		L_tmp = L_tmp >> 15;
+		L_tmp += (y1_hi * a[1])<<1;
+		L_tmp += (y2_hi * a[2])<<1;
+		L_tmp += (y3_hi * a[3])<<1;
+		L_tmp += (x0 * b[0])<<1;
+		L_tmp += (x1 * b[1])<<1;
+		L_tmp += (x2 * b[2])<<1;
+		L_tmp += (x3 * b[3])<<1;
+
+		L_tmp = L_tmp << 2;
+
+		y3_hi = y2_hi;
+		y3_lo = y2_lo;
+		y2_hi = y1_hi;
+		y2_lo = y1_lo;
+		y1_hi = L_tmp >> 16;
+		y1_lo = (L_tmp & 0xffff) >>1;
+
+		hp_wsp[i] = (L_tmp + 0x4000)>>15;
+	}
+
+	mem[0] = y3_hi;
+	mem[1] = y3_lo;
+	mem[2] = y2_hi;
+	mem[3] = y2_lo;
+	mem[4] = y1_hi;
+	mem[5] = y1_lo;
+	mem[6] = x0;
+	mem[7] = x1;
+	mem[8] = x2;
+
+	return;
+}
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/int_lpc.c b/media/libstagefright/codecs/amrwbenc/src/int_lpc.c
index be1fd0b..1119bc7 100644
--- a/media/libstagefright/codecs/amrwbenc/src/int_lpc.c
+++ b/media/libstagefright/codecs/amrwbenc/src/int_lpc.c
@@ -1,66 +1,66 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: int_lpc.c                                                 *
-*                                                                      *
-*      Description:Interpolation of the LP parameters in 4 subframes.  *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "cnst.h"
-#include "acelp.h"
-
-#define MP1 (M+1)
-
-
-void Int_isp(
-		Word16 isp_old[],                     /* input : isps from past frame              */
-		Word16 isp_new[],                     /* input : isps from present frame           */
-		Word16 frac[],                        /* input : fraction for 3 first subfr (Q15)  */
-		Word16 Az[]                           /* output: LP coefficients in 4 subframes    */
-	    )
-{
-	Word32 i, k; 
-	Word16 fac_old, fac_new;
-	Word16 isp[M];
-	Word32 L_tmp;
-
-	for (k = 0; k < 3; k++)
-	{
-		fac_new = frac[k];                
-		fac_old = (32767 - fac_new) + 1;  /* 1.0 - fac_new */
-
-		for (i = 0; i < M; i++)
-		{
-			L_tmp = (isp_old[i] * fac_old)<<1;
-			L_tmp += (isp_new[i] * fac_new)<<1;
-			isp[i] = (L_tmp + 0x8000)>>16;        
-		}
-		Isp_Az(isp, Az, M, 0);
-		Az += MP1;
-	}
-
-	/* 4th subframe: isp_new (frac=1.0) */
-	Isp_Az(isp_new, Az, M, 0);
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: int_lpc.c                                                 *
+*                                                                      *
+*      Description:Interpolation of the LP parameters in 4 subframes.  *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "cnst.h"
+#include "acelp.h"
+
+#define MP1 (M+1)
+
+
+void Int_isp(
+		Word16 isp_old[],                     /* input : isps from past frame              */
+		Word16 isp_new[],                     /* input : isps from present frame           */
+		Word16 frac[],                        /* input : fraction for 3 first subfr (Q15)  */
+		Word16 Az[]                           /* output: LP coefficients in 4 subframes    */
+	    )
+{
+	Word32 i, k;
+	Word16 fac_old, fac_new;
+	Word16 isp[M];
+	Word32 L_tmp;
+
+	for (k = 0; k < 3; k++)
+	{
+		fac_new = frac[k];
+		fac_old = (32767 - fac_new) + 1;  /* 1.0 - fac_new */
+
+		for (i = 0; i < M; i++)
+		{
+			L_tmp = (isp_old[i] * fac_old)<<1;
+			L_tmp += (isp_new[i] * fac_new)<<1;
+			isp[i] = (L_tmp + 0x8000)>>16;
+		}
+		Isp_Az(isp, Az, M, 0);
+		Az += MP1;
+	}
+
+	/* 4th subframe: isp_new (frac=1.0) */
+	Isp_Az(isp_new, Az, M, 0);
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/isp_az.c b/media/libstagefright/codecs/amrwbenc/src/isp_az.c
index 7b44d12..30a8bbd 100644
--- a/media/libstagefright/codecs/amrwbenc/src/isp_az.c
+++ b/media/libstagefright/codecs/amrwbenc/src/isp_az.c
@@ -1,247 +1,247 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: isp_az.c                                                  *
-*                                                                      *
-*      Description:Compute the LPC coefficients from isp (order=M)     *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "cnst.h"
-
-#define NC (M/2)
-#define NC16k (M16k/2)
-
-/* local function */
-
-static void Get_isp_pol(Word16 * isp, Word32 * f, Word16 n);
-static void Get_isp_pol_16kHz(Word16 * isp, Word32 * f, Word16 n);
-
-void Isp_Az(
-		Word16 isp[],                         /* (i) Q15 : Immittance spectral pairs            */
-		Word16 a[],                           /* (o) Q12 : predictor coefficients (order = M)   */
-		Word16 m,
-		Word16 adaptive_scaling               /* (i) 0   : adaptive scaling disabled */
-		                                      /*     1   : adaptive scaling enabled  */
-	   )
-{
-	Word32 i, j; 
-	Word16 hi, lo;
-	Word32 f1[NC16k + 1], f2[NC16k];
-	Word16 nc;
-	Word32 t0;
-	Word16 q, q_sug;
-	Word32 tmax;
-
-	nc = (m >> 1);
-	if(nc > 8)
-	{
-		Get_isp_pol_16kHz(&isp[0], f1, nc);
-		for (i = 0; i <= nc; i++)
-		{
-			f1[i] = f1[i] << 2;
-		}
-	} else
-		Get_isp_pol(&isp[0], f1, nc);
-
-	if (nc > 8)
-	{
-		Get_isp_pol_16kHz(&isp[1], f2, (nc - 1));
-		for (i = 0; i <= nc - 1; i++)
-		{
-			f2[i] = f2[i] << 2;
-		}
-	} else
-		Get_isp_pol(&isp[1], f2, (nc - 1));
-
-	/*-----------------------------------------------------*
-	 *  Multiply F2(z) by (1 - z^-2)                       *
-	 *-----------------------------------------------------*/
-
-	for (i = (nc - 1); i > 1; i--)
-	{
-		f2[i] = vo_L_sub(f2[i], f2[i - 2]);          /* f2[i] -= f2[i-2]; */
-	}
-
-	/*----------------------------------------------------------*
-	 *  Scale F1(z) by (1+isp[m-1])  and  F2(z) by (1-isp[m-1]) *
-	 *----------------------------------------------------------*/
-
-	for (i = 0; i < nc; i++)
-	{
-		/* f1[i] *= (1.0 + isp[M-1]); */
-
-		hi = f1[i] >> 16;
-		lo = (f1[i] & 0xffff)>>1;
-
-		t0 = Mpy_32_16(hi, lo, isp[m - 1]);
-		f1[i] = vo_L_add(f1[i], t0); 
-
-		/* f2[i] *= (1.0 - isp[M-1]); */
-
-		hi = f2[i] >> 16;
-		lo = (f2[i] & 0xffff)>>1;
-		t0 = Mpy_32_16(hi, lo, isp[m - 1]);
-		f2[i] = vo_L_sub(f2[i], t0); 
-	}
-
-	/*-----------------------------------------------------*
-	 *  A(z) = (F1(z)+F2(z))/2                             *
-	 *  F1(z) is symmetric and F2(z) is antisymmetric      *
-	 *-----------------------------------------------------*/
-
-	/* a[0] = 1.0; */
-	a[0] = 4096;  
-	tmax = 1;                            
-	for (i = 1, j = m - 1; i < nc; i++, j--)
-	{
-		/* a[i] = 0.5*(f1[i] + f2[i]); */
-
-		t0 = vo_L_add(f1[i], f2[i]);          /* f1[i] + f2[i]             */
-		tmax |= L_abs(t0);                 
-		a[i] = (Word16)(vo_L_shr_r(t0, 12)); /* from Q23 to Q12 and * 0.5 */
-
-		/* a[j] = 0.5*(f1[i] - f2[i]); */
-
-		t0 = vo_L_sub(f1[i], f2[i]);          /* f1[i] - f2[i]             */
-		tmax |= L_abs(t0);                
-		a[j] = (Word16)(vo_L_shr_r(t0, 12)); /* from Q23 to Q12 and * 0.5 */
-	}
-
-	/* rescale data if overflow has occured and reprocess the loop */
-	if(adaptive_scaling == 1)
-		q = 4 - norm_l(tmax);        /* adaptive scaling enabled */
-	else
-		q = 0;                           /* adaptive scaling disabled */
-
-	if (q > 0)
-	{
-		q_sug = (12 + q);
-		for (i = 1, j = m - 1; i < nc; i++, j--)
-		{
-			/* a[i] = 0.5*(f1[i] + f2[i]); */
-			t0 = vo_L_add(f1[i], f2[i]);          /* f1[i] + f2[i]             */
-			a[i] = (Word16)(vo_L_shr_r(t0, q_sug)); /* from Q23 to Q12 and * 0.5 */
-
-			/* a[j] = 0.5*(f1[i] - f2[i]); */
-			t0 = vo_L_sub(f1[i], f2[i]);          /* f1[i] - f2[i]             */
-			a[j] = (Word16)(vo_L_shr_r(t0, q_sug)); /* from Q23 to Q12 and * 0.5 */
-		}
-		a[0] = shr(a[0], q); 
-	}
-	else
-	{
-		q_sug = 12; 
-		q     = 0; 
-	}
-	/* a[NC] = 0.5*f1[NC]*(1.0 + isp[M-1]); */
-	hi = f1[nc] >> 16;
-	lo = (f1[nc] & 0xffff)>>1;
-	t0 = Mpy_32_16(hi, lo, isp[m - 1]);
-	t0 = vo_L_add(f1[nc], t0);
-	a[nc] = (Word16)(L_shr_r(t0, q_sug));    /* from Q23 to Q12 and * 0.5 */
-	/* a[m] = isp[m-1]; */
-
-	a[m] = vo_shr_r(isp[m - 1], (3 + q));           /* from Q15 to Q12          */
-	return;
-}
-
-/*-----------------------------------------------------------*
-* procedure Get_isp_pol:                                    *
-*           ~~~~~~~~~~~                                     *
-*   Find the polynomial F1(z) or F2(z) from the ISPs.       *
-* This is performed by expanding the product polynomials:   *
-*                                                           *
-* F1(z) =   product   ( 1 - 2 isp_i z^-1 + z^-2 )           *
-*         i=0,2,4,6,8                                       *
-* F2(z) =   product   ( 1 - 2 isp_i z^-1 + z^-2 )           *
-*         i=1,3,5,7                                         *
-*                                                           *
-* where isp_i are the ISPs in the cosine domain.            *
-*-----------------------------------------------------------*
-*                                                           *
-* Parameters:                                               *
-*  isp[]   : isp vector (cosine domaine)         in Q15     *
-*  f[]     : the coefficients of F1 or F2        in Q23     *
-*  n       : == NC for F1(z); == NC-1 for F2(z)             *
-*-----------------------------------------------------------*/
-
-static void Get_isp_pol(Word16 * isp, Word32 * f, Word16 n)
-{
-	Word16 hi, lo;
-	Word32 i, j, t0;
-	/* All computation in Q23 */
-
-	f[0] = vo_L_mult(4096, 1024);               /* f[0] = 1.0;        in Q23  */
-	f[1] = vo_L_mult(isp[0], -256);             /* f[1] = -2.0*isp[0] in Q23  */
-
-	f += 2;                                  /* Advance f pointer          */
-	isp += 2;                                /* Advance isp pointer        */
-	for (i = 2; i <= n; i++)
-	{
-		*f = f[-2];                        
-		for (j = 1; j < i; j++, f--)
-		{
-			hi = f[-1]>>16;
-			lo = (f[-1] & 0xffff)>>1;
-
-			t0 = Mpy_32_16(hi, lo, *isp);  /* t0 = f[-1] * isp    */
-			t0 = t0 << 1;
-			*f = vo_L_sub(*f, t0);              /* *f -= t0            */
-			*f = vo_L_add(*f, f[-2]);           /* *f += f[-2]         */
-		}
-		*f -= (*isp << 9);           /* *f -= isp<<8        */
-		f += i;                            /* Advance f pointer   */
-		isp += 2;                          /* Advance isp pointer */
-	}
-	return;
-}
-
-static void Get_isp_pol_16kHz(Word16 * isp, Word32 * f, Word16 n)
-{
-	Word16 hi, lo;
-	Word32 i, j, t0;
-
-	/* All computation in Q23 */
-	f[0] = L_mult(4096, 256);                /* f[0] = 1.0;        in Q23  */
-	f[1] = L_mult(isp[0], -64);              /* f[1] = -2.0*isp[0] in Q23  */
-
-	f += 2;                                  /* Advance f pointer          */
-	isp += 2;                                /* Advance isp pointer        */
-
-	for (i = 2; i <= n; i++)
-	{
-		*f = f[-2];                        
-		for (j = 1; j < i; j++, f--)
-		{
-			VO_L_Extract(f[-1], &hi, &lo);
-			t0 = Mpy_32_16(hi, lo, *isp);  /* t0 = f[-1] * isp    */
-			t0 = L_shl2(t0, 1);
-			*f = L_sub(*f, t0);              /* *f -= t0            */
-			*f = L_add(*f, f[-2]);           /* *f += f[-2]         */
-		}
-		*f = L_msu(*f, *isp, 64);            /* *f -= isp<<8        */
-		f += i;                            /* Advance f pointer   */
-		isp += 2;                          /* Advance isp pointer */
-	}
-	return;
-}
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: isp_az.c                                                  *
+*                                                                      *
+*      Description:Compute the LPC coefficients from isp (order=M)     *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "cnst.h"
+
+#define NC (M/2)
+#define NC16k (M16k/2)
+
+/* local function */
+
+static void Get_isp_pol(Word16 * isp, Word32 * f, Word16 n);
+static void Get_isp_pol_16kHz(Word16 * isp, Word32 * f, Word16 n);
+
+void Isp_Az(
+		Word16 isp[],                         /* (i) Q15 : Immittance spectral pairs            */
+		Word16 a[],                           /* (o) Q12 : predictor coefficients (order = M)   */
+		Word16 m,
+		Word16 adaptive_scaling               /* (i) 0   : adaptive scaling disabled */
+		                                      /*     1   : adaptive scaling enabled  */
+	   )
+{
+	Word32 i, j;
+	Word16 hi, lo;
+	Word32 f1[NC16k + 1], f2[NC16k];
+	Word16 nc;
+	Word32 t0;
+	Word16 q, q_sug;
+	Word32 tmax;
+
+	nc = (m >> 1);
+	if(nc > 8)
+	{
+		Get_isp_pol_16kHz(&isp[0], f1, nc);
+		for (i = 0; i <= nc; i++)
+		{
+			f1[i] = f1[i] << 2;
+		}
+	} else
+		Get_isp_pol(&isp[0], f1, nc);
+
+	if (nc > 8)
+	{
+		Get_isp_pol_16kHz(&isp[1], f2, (nc - 1));
+		for (i = 0; i <= nc - 1; i++)
+		{
+			f2[i] = f2[i] << 2;
+		}
+	} else
+		Get_isp_pol(&isp[1], f2, (nc - 1));
+
+	/*-----------------------------------------------------*
+	 *  Multiply F2(z) by (1 - z^-2)                       *
+	 *-----------------------------------------------------*/
+
+	for (i = (nc - 1); i > 1; i--)
+	{
+		f2[i] = vo_L_sub(f2[i], f2[i - 2]);          /* f2[i] -= f2[i-2]; */
+	}
+
+	/*----------------------------------------------------------*
+	 *  Scale F1(z) by (1+isp[m-1])  and  F2(z) by (1-isp[m-1]) *
+	 *----------------------------------------------------------*/
+
+	for (i = 0; i < nc; i++)
+	{
+		/* f1[i] *= (1.0 + isp[M-1]); */
+
+		hi = f1[i] >> 16;
+		lo = (f1[i] & 0xffff)>>1;
+
+		t0 = Mpy_32_16(hi, lo, isp[m - 1]);
+		f1[i] = vo_L_add(f1[i], t0);
+
+		/* f2[i] *= (1.0 - isp[M-1]); */
+
+		hi = f2[i] >> 16;
+		lo = (f2[i] & 0xffff)>>1;
+		t0 = Mpy_32_16(hi, lo, isp[m - 1]);
+		f2[i] = vo_L_sub(f2[i], t0);
+	}
+
+	/*-----------------------------------------------------*
+	 *  A(z) = (F1(z)+F2(z))/2                             *
+	 *  F1(z) is symmetric and F2(z) is antisymmetric      *
+	 *-----------------------------------------------------*/
+
+	/* a[0] = 1.0; */
+	a[0] = 4096;
+	tmax = 1;
+	for (i = 1, j = m - 1; i < nc; i++, j--)
+	{
+		/* a[i] = 0.5*(f1[i] + f2[i]); */
+
+		t0 = vo_L_add(f1[i], f2[i]);          /* f1[i] + f2[i]             */
+		tmax |= L_abs(t0);
+		a[i] = (Word16)(vo_L_shr_r(t0, 12)); /* from Q23 to Q12 and * 0.5 */
+
+		/* a[j] = 0.5*(f1[i] - f2[i]); */
+
+		t0 = vo_L_sub(f1[i], f2[i]);          /* f1[i] - f2[i]             */
+		tmax |= L_abs(t0);
+		a[j] = (Word16)(vo_L_shr_r(t0, 12)); /* from Q23 to Q12 and * 0.5 */
+	}
+
+	/* rescale data if overflow has occured and reprocess the loop */
+	if(adaptive_scaling == 1)
+		q = 4 - norm_l(tmax);        /* adaptive scaling enabled */
+	else
+		q = 0;                           /* adaptive scaling disabled */
+
+	if (q > 0)
+	{
+		q_sug = (12 + q);
+		for (i = 1, j = m - 1; i < nc; i++, j--)
+		{
+			/* a[i] = 0.5*(f1[i] + f2[i]); */
+			t0 = vo_L_add(f1[i], f2[i]);          /* f1[i] + f2[i]             */
+			a[i] = (Word16)(vo_L_shr_r(t0, q_sug)); /* from Q23 to Q12 and * 0.5 */
+
+			/* a[j] = 0.5*(f1[i] - f2[i]); */
+			t0 = vo_L_sub(f1[i], f2[i]);          /* f1[i] - f2[i]             */
+			a[j] = (Word16)(vo_L_shr_r(t0, q_sug)); /* from Q23 to Q12 and * 0.5 */
+		}
+		a[0] = shr(a[0], q);
+	}
+	else
+	{
+		q_sug = 12;
+		q     = 0;
+	}
+	/* a[NC] = 0.5*f1[NC]*(1.0 + isp[M-1]); */
+	hi = f1[nc] >> 16;
+	lo = (f1[nc] & 0xffff)>>1;
+	t0 = Mpy_32_16(hi, lo, isp[m - 1]);
+	t0 = vo_L_add(f1[nc], t0);
+	a[nc] = (Word16)(L_shr_r(t0, q_sug));    /* from Q23 to Q12 and * 0.5 */
+	/* a[m] = isp[m-1]; */
+
+	a[m] = vo_shr_r(isp[m - 1], (3 + q));           /* from Q15 to Q12          */
+	return;
+}
+
+/*-----------------------------------------------------------*
+* procedure Get_isp_pol:                                    *
+*           ~~~~~~~~~~~                                     *
+*   Find the polynomial F1(z) or F2(z) from the ISPs.       *
+* This is performed by expanding the product polynomials:   *
+*                                                           *
+* F1(z) =   product   ( 1 - 2 isp_i z^-1 + z^-2 )           *
+*         i=0,2,4,6,8                                       *
+* F2(z) =   product   ( 1 - 2 isp_i z^-1 + z^-2 )           *
+*         i=1,3,5,7                                         *
+*                                                           *
+* where isp_i are the ISPs in the cosine domain.            *
+*-----------------------------------------------------------*
+*                                                           *
+* Parameters:                                               *
+*  isp[]   : isp vector (cosine domaine)         in Q15     *
+*  f[]     : the coefficients of F1 or F2        in Q23     *
+*  n       : == NC for F1(z); == NC-1 for F2(z)             *
+*-----------------------------------------------------------*/
+
+static void Get_isp_pol(Word16 * isp, Word32 * f, Word16 n)
+{
+	Word16 hi, lo;
+	Word32 i, j, t0;
+	/* All computation in Q23 */
+
+	f[0] = vo_L_mult(4096, 1024);               /* f[0] = 1.0;        in Q23  */
+	f[1] = vo_L_mult(isp[0], -256);             /* f[1] = -2.0*isp[0] in Q23  */
+
+	f += 2;                                  /* Advance f pointer          */
+	isp += 2;                                /* Advance isp pointer        */
+	for (i = 2; i <= n; i++)
+	{
+		*f = f[-2];
+		for (j = 1; j < i; j++, f--)
+		{
+			hi = f[-1]>>16;
+			lo = (f[-1] & 0xffff)>>1;
+
+			t0 = Mpy_32_16(hi, lo, *isp);  /* t0 = f[-1] * isp    */
+			t0 = t0 << 1;
+			*f = vo_L_sub(*f, t0);              /* *f -= t0            */
+			*f = vo_L_add(*f, f[-2]);           /* *f += f[-2]         */
+		}
+		*f -= (*isp << 9);           /* *f -= isp<<8        */
+		f += i;                            /* Advance f pointer   */
+		isp += 2;                          /* Advance isp pointer */
+	}
+	return;
+}
+
+static void Get_isp_pol_16kHz(Word16 * isp, Word32 * f, Word16 n)
+{
+	Word16 hi, lo;
+	Word32 i, j, t0;
+
+	/* All computation in Q23 */
+	f[0] = L_mult(4096, 256);                /* f[0] = 1.0;        in Q23  */
+	f[1] = L_mult(isp[0], -64);              /* f[1] = -2.0*isp[0] in Q23  */
+
+	f += 2;                                  /* Advance f pointer          */
+	isp += 2;                                /* Advance isp pointer        */
+
+	for (i = 2; i <= n; i++)
+	{
+		*f = f[-2];
+		for (j = 1; j < i; j++, f--)
+		{
+			VO_L_Extract(f[-1], &hi, &lo);
+			t0 = Mpy_32_16(hi, lo, *isp);  /* t0 = f[-1] * isp    */
+			t0 = L_shl2(t0, 1);
+			*f = L_sub(*f, t0);              /* *f -= t0            */
+			*f = L_add(*f, f[-2]);           /* *f += f[-2]         */
+		}
+		*f = L_msu(*f, *isp, 64);            /* *f -= isp<<8        */
+		f += i;                            /* Advance f pointer   */
+		isp += 2;                          /* Advance isp pointer */
+	}
+	return;
+}
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/isp_isf.c b/media/libstagefright/codecs/amrwbenc/src/isp_isf.c
index 6c6e389..b4ba408 100644
--- a/media/libstagefright/codecs/amrwbenc/src/isp_isf.c
+++ b/media/libstagefright/codecs/amrwbenc/src/isp_isf.c
@@ -1,91 +1,91 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: isp_isf.c                                                *
-*                                                                      *
-*       Description:                                                   *
-*	Isp_isf   Transformation isp to isf                            *
-*	Isf_isp   Transformation isf to isp                            *
-*                                                                      *
-*	The transformation from isp[i] to isf[i] and isf[i] to isp[i]  *
-*	are approximated by a look-up table and interpolation          *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "isp_isf.tab"                     /* Look-up table for transformations */
-
-void Isp_isf(
-		Word16 isp[],                         /* (i) Q15 : isp[m] (range: -1<=val<1)                */
-		Word16 isf[],                         /* (o) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
-		Word16 m                              /* (i)     : LPC order                                */
-	    )
-{
-	Word32 i, ind;
-	Word32 L_tmp;
-	ind = 127;                               /* beging at end of table -1 */
-	for (i = (m - 1); i >= 0; i--)
-	{
-		if (i >= (m - 2))
-		{                                  /* m-2 is a constant */
-			ind = 127;                       /* beging at end of table -1 */
-		}
-		/* find value in table that is just greater than isp[i] */
-		while (table[ind] < isp[i])
-			ind--;
-		/* acos(isp[i])= ind*128 + ( ( isp[i]-table[ind] ) * slope[ind] )/2048 */
-		L_tmp = vo_L_mult(vo_sub(isp[i], table[ind]), slope[ind]);
-		isf[i] = vo_round((L_tmp << 4));   /* (isp[i]-table[ind])*slope[ind])>>11 */
-		isf[i] = add1(isf[i], (ind << 7)); 
-	}
-	isf[m - 1] = (isf[m - 1] >> 1);      
-	return;
-}
-
-
-void Isf_isp(
-		Word16 isf[],                         /* (i) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
-		Word16 isp[],                         /* (o) Q15 : isp[m] (range: -1<=val<1)                */
-		Word16 m                              /* (i)     : LPC order                                */
-	    )
-{
-	Word16 offset;
-	Word32 i, ind, L_tmp;
-
-	for (i = 0; i < m - 1; i++)
-	{
-		isp[i] = isf[i];                  
-	}
-	isp[m - 1] = (isf[m - 1] << 1);
-
-	for (i = 0; i < m; i++)
-	{
-		ind = (isp[i] >> 7);                      /* ind    = b7-b15 of isf[i] */
-		offset = (Word16) (isp[i] & 0x007f);      /* offset = b0-b6  of isf[i] */
-
-		/* isp[i] = table[ind]+ ((table[ind+1]-table[ind])*offset) / 128 */
-		L_tmp = vo_L_mult(vo_sub(table[ind + 1], table[ind]), offset);
-		isp[i] = add1(table[ind], (Word16)((L_tmp >> 8)));   
-	}
-
-	return;
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: isp_isf.c                                                *
+*                                                                      *
+*       Description:                                                   *
+*	Isp_isf   Transformation isp to isf                            *
+*	Isf_isp   Transformation isf to isp                            *
+*                                                                      *
+*	The transformation from isp[i] to isf[i] and isf[i] to isp[i]  *
+*	are approximated by a look-up table and interpolation          *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "isp_isf.tab"                     /* Look-up table for transformations */
+
+void Isp_isf(
+		Word16 isp[],                         /* (i) Q15 : isp[m] (range: -1<=val<1)                */
+		Word16 isf[],                         /* (o) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
+		Word16 m                              /* (i)     : LPC order                                */
+	    )
+{
+	Word32 i, ind;
+	Word32 L_tmp;
+	ind = 127;                               /* beging at end of table -1 */
+	for (i = (m - 1); i >= 0; i--)
+	{
+		if (i >= (m - 2))
+		{                                  /* m-2 is a constant */
+			ind = 127;                       /* beging at end of table -1 */
+		}
+		/* find value in table that is just greater than isp[i] */
+		while (table[ind] < isp[i])
+			ind--;
+		/* acos(isp[i])= ind*128 + ( ( isp[i]-table[ind] ) * slope[ind] )/2048 */
+		L_tmp = vo_L_mult(vo_sub(isp[i], table[ind]), slope[ind]);
+		isf[i] = vo_round((L_tmp << 4));   /* (isp[i]-table[ind])*slope[ind])>>11 */
+		isf[i] = add1(isf[i], (ind << 7));
+	}
+	isf[m - 1] = (isf[m - 1] >> 1);
+	return;
+}
+
+
+void Isf_isp(
+		Word16 isf[],                         /* (i) Q15 : isf[m] normalized (range: 0.0<=val<=0.5) */
+		Word16 isp[],                         /* (o) Q15 : isp[m] (range: -1<=val<1)                */
+		Word16 m                              /* (i)     : LPC order                                */
+	    )
+{
+	Word16 offset;
+	Word32 i, ind, L_tmp;
+
+	for (i = 0; i < m - 1; i++)
+	{
+		isp[i] = isf[i];
+	}
+	isp[m - 1] = (isf[m - 1] << 1);
+
+	for (i = 0; i < m; i++)
+	{
+		ind = (isp[i] >> 7);                      /* ind    = b7-b15 of isf[i] */
+		offset = (Word16) (isp[i] & 0x007f);      /* offset = b0-b6  of isf[i] */
+
+		/* isp[i] = table[ind]+ ((table[ind+1]-table[ind])*offset) / 128 */
+		L_tmp = vo_L_mult(vo_sub(table[ind + 1], table[ind]), offset);
+		isp[i] = add1(table[ind], (Word16)((L_tmp >> 8)));
+	}
+
+	return;
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/lag_wind.c b/media/libstagefright/codecs/amrwbenc/src/lag_wind.c
index 0397704..49c622c 100644
--- a/media/libstagefright/codecs/amrwbenc/src/lag_wind.c
+++ b/media/libstagefright/codecs/amrwbenc/src/lag_wind.c
@@ -1,49 +1,49 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: lag_wind.c                                                *
-*                                                                      *
-*	   Description: Lag_windows on autocorrelations                *
-*	                r[i] *= lag_wind[i]                            *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "lag_wind.tab"
-
-
-void Lag_window(
-		Word16 r_h[],                         /* (i/o)   : Autocorrelations  (msb)          */
-		Word16 r_l[]                          /* (i/o)   : Autocorrelations  (lsb)          */
-	       )
-{
-	Word32 i;
-	Word32 x;
-
-	for (i = 1; i <= M; i++)
-	{
-		x = Mpy_32(r_h[i], r_l[i], volag_h[i - 1], volag_l[i - 1]);
-		r_h[i] = x >> 16;
-		r_l[i] = (x & 0xffff)>>1;
-	}
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: lag_wind.c                                                *
+*                                                                      *
+*	   Description: Lag_windows on autocorrelations                *
+*	                r[i] *= lag_wind[i]                            *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "lag_wind.tab"
+
+
+void Lag_window(
+		Word16 r_h[],                         /* (i/o)   : Autocorrelations  (msb)          */
+		Word16 r_l[]                          /* (i/o)   : Autocorrelations  (lsb)          */
+	       )
+{
+	Word32 i;
+	Word32 x;
+
+	for (i = 1; i <= M; i++)
+	{
+		x = Mpy_32(r_h[i], r_l[i], volag_h[i - 1], volag_l[i - 1]);
+		r_h[i] = x >> 16;
+		r_l[i] = (x & 0xffff)>>1;
+	}
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/levinson.c b/media/libstagefright/codecs/amrwbenc/src/levinson.c
index 8bc6f62..4b2f8ed 100644
--- a/media/libstagefright/codecs/amrwbenc/src/levinson.c
+++ b/media/libstagefright/codecs/amrwbenc/src/levinson.c
@@ -1,250 +1,250 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: levinson.c                                                *
-*                                                                      *
-*      Description:LEVINSON-DURBIN algorithm in double precision       *
-*                                                                      *
-************************************************************************/
-/*---------------------------------------------------------------------------*
- *                         LEVINSON.C					     *
- *---------------------------------------------------------------------------*
- *                                                                           *
- *      LEVINSON-DURBIN algorithm in double precision                        *
- *                                                                           *
- *                                                                           *
- * Algorithm                                                                 *
- *                                                                           *
- *       R[i]    autocorrelations.                                           *
- *       A[i]    filter coefficients.                                        *
- *       K       reflection coefficients.                                    *
- *       Alpha   prediction gain.                                            *
- *                                                                           *
- *       Initialization:                                                     *
- *               A[0] = 1                                                    *
- *               K    = -R[1]/R[0]                                           *
- *               A[1] = K                                                    *
- *               Alpha = R[0] * (1-K**2]                                     *
- *                                                                           *
- *       Do for  i = 2 to M                                                  *
- *                                                                           *
- *            S =  SUM ( R[j]*A[i-j] ,j=1,i-1 ) +  R[i]                      *
- *                                                                           *
- *            K = -S / Alpha                                                 *
- *                                                                           *
- *            An[j] = A[j] + K*A[i-j]   for j=1 to i-1                       *
- *                                      where   An[i] = new A[i]             *
- *            An[i]=K                                                        *
- *                                                                           *
- *            Alpha=Alpha * (1-K**2)                                         *
- *                                                                           *
- *       END                                                                 *
- *                                                                           *
- * Remarks on the dynamics of the calculations.                              *
- *                                                                           *
- *       The numbers used are in double precision in the following format :  *
- *       A = AH <<16 + AL<<1.  AH and AL are 16 bit signed integers.         *
- *       Since the LSB's also contain a sign bit, this format does not       *
- *       correspond to standard 32 bit integers.  We use this format since   *
- *       it allows fast execution of multiplications and divisions.          *
- *                                                                           *
- *       "DPF" will refer to this special format in the following text.      *
- *       See oper_32b.c                                                      *
- *                                                                           *
- *       The R[i] were normalized in routine AUTO (hence, R[i] < 1.0).       *
- *       The K[i] and Alpha are theoretically < 1.0.                         *
- *       The A[i], for a sampling frequency of 8 kHz, are in practice        *
- *       always inferior to 16.0.                                            *
- *                                                                           *
- *       These characteristics allow straigthforward fixed-point             *
- *       implementation.  We choose to represent the parameters as           *
- *       follows :                                                           *
- *                                                                           *
- *               R[i]    Q31   +- .99..                                      *
- *               K[i]    Q31   +- .99..                                      *
- *               Alpha   Normalized -> mantissa in Q31 plus exponent         *
- *               A[i]    Q27   +- 15.999..                                   *
- *                                                                           *
- *       The additions are performed in 32 bit.  For the summation used      *
- *       to calculate the K[i], we multiply numbers in Q31 by numbers        *
- *       in Q27, with the result of the multiplications in Q27,              *
- *       resulting in a dynamic of +- 16.  This is sufficient to avoid       *
- *       overflow, since the final result of the summation is                *
- *       necessarily < 1.0 as both the K[i] and Alpha are                    *
- *       theoretically < 1.0.                                                *
- *___________________________________________________________________________*/
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "acelp.h"
-
-#define M   16
-#define NC  (M/2)
-
-void Init_Levinson(
-		Word16 * mem                          /* output  :static memory (18 words) */
-		)
-{
-	Set_zero(mem, 18);                     /* old_A[0..M-1] = 0, old_rc[0..1] = 0 */
-	return;
-}
-
-
-void Levinson(
-		Word16 Rh[],                          /* (i)     : Rh[M+1] Vector of autocorrelations (msb) */
-		Word16 Rl[],                          /* (i)     : Rl[M+1] Vector of autocorrelations (lsb) */
-		Word16 A[],                           /* (o) Q12 : A[M]    LPC coefficients  (m = 16)       */
-		Word16 rc[],                          /* (o) Q15 : rc[M]   Reflection coefficients.         */
-		Word16 * mem                          /* (i/o)   :static memory (18 words)                  */
-	     )
-{
-	Word32 i, j;
-	Word16 hi, lo;
-	Word16 Kh, Kl;                         /* reflection coefficient; hi and lo           */
-	Word16 alp_h, alp_l, alp_exp;          /* Prediction gain; hi lo and exponent         */
-	Word16 Ah[M + 1], Al[M + 1];           /* LPC coef. in double prec.                   */
-	Word16 Anh[M + 1], Anl[M + 1];         /* LPC coef.for next iteration in double prec. */
-	Word32 t0, t1, t2;                     /* temporary variable                          */
-	Word16 *old_A, *old_rc;
-
-	/* Last A(z) for case of unstable filter */
-	old_A = mem;                           
-	old_rc = mem + M;                      
-
-	/* K = A[1] = -R[1] / R[0] */
-
-	t1 = ((Rh[1] << 16) + (Rl[1] << 1));   /* R[1] in Q31 */
-	t2 = L_abs(t1);                        /* abs R[1]         */
-	t0 = Div_32(t2, Rh[0], Rl[0]);         /* R[1]/R[0] in Q31 */
-	if (t1 > 0)
-		t0 = -t0;                          /* -R[1]/R[0]       */
-
-	Kh = t0 >> 16;
-	Kl = (t0 & 0xffff)>>1;
-	rc[0] = Kh;                            
-	t0 = (t0 >> 4);                        /* A[1] in Q27      */
-
-	Ah[1] = t0 >> 16;
-	Al[1] = (t0 & 0xffff)>>1;
-
-	/* Alpha = R[0] * (1-K**2) */
-	t0 = Mpy_32(Kh, Kl, Kh, Kl);           /* K*K      in Q31 */
-	t0 = L_abs(t0);                        /* Some case <0 !! */
-	t0 = vo_L_sub((Word32) 0x7fffffffL, t0);  /* 1 - K*K  in Q31 */
-
-	hi = t0 >> 16;
-	lo = (t0 & 0xffff)>>1;
-
-	t0 = Mpy_32(Rh[0], Rl[0], hi, lo);     /* Alpha in Q31    */
-
-	/* Normalize Alpha */
-	alp_exp = norm_l(t0);
-	t0 = (t0 << alp_exp);
-
-	alp_h = t0 >> 16;
-	alp_l = (t0 & 0xffff)>>1;
-	/*--------------------------------------*
-	 * ITERATIONS  I=2 to M                 *
-	 *--------------------------------------*/
-	for (i = 2; i <= M; i++)
-	{
-		/* t0 = SUM ( R[j]*A[i-j] ,j=1,i-1 ) +  R[i] */
-		t0 = 0;                           
-		for (j = 1; j < i; j++)
-			t0 = vo_L_add(t0, Mpy_32(Rh[j], Rl[j], Ah[i - j], Al[i - j]));
-
-		t0 = t0 << 4;                 /* result in Q27 -> convert to Q31 */
-		/* No overflow possible            */
-		t1 = ((Rh[i] << 16) + (Rl[i] << 1));
-		t0 = vo_L_add(t0, t1);                /* add R[i] in Q31                 */
-
-		/* K = -t0 / Alpha */
-		t1 = L_abs(t0);
-		t2 = Div_32(t1, alp_h, alp_l);     /* abs(t0)/Alpha                   */
-		if (t0 > 0)
-			t2 = -t2;                   /* K =-t0/Alpha                    */
-		t2 = (t2 << alp_exp);           /* denormalize; compare to Alpha   */
-
-		Kh = t2 >> 16;
-		Kl = (t2 & 0xffff)>>1;
-
-		rc[i - 1] = Kh;                   
-		/* Test for unstable filter. If unstable keep old A(z) */
-		if (abs_s(Kh) > 32750)
-		{
-			A[0] = 4096;                    /* Ai[0] not stored (always 1.0) */
-			for (j = 0; j < M; j++)
-			{
-				A[j + 1] = old_A[j];       
-			}
-			rc[0] = old_rc[0];             /* only two rc coefficients are needed */
-			rc[1] = old_rc[1];
-			return;
-		}
-		/*------------------------------------------*
-		 *  Compute new LPC coeff. -> An[i]         *
-		 *  An[j]= A[j] + K*A[i-j]     , j=1 to i-1 *
-		 *  An[i]= K                                *
-		 *------------------------------------------*/
-		for (j = 1; j < i; j++)
-		{
-			t0 = Mpy_32(Kh, Kl, Ah[i - j], Al[i - j]);
-			t0 = vo_L_add(t0, ((Ah[j] << 16) + (Al[j] << 1)));
-			Anh[j] = t0 >> 16;
-			Anl[j] = (t0 & 0xffff)>>1;
-		}
-		t2 = (t2 >> 4);                 /* t2 = K in Q31 ->convert to Q27  */
-
-		VO_L_Extract(t2, &Anh[i], &Anl[i]);   /* An[i] in Q27                    */
-
-		/* Alpha = Alpha * (1-K**2) */
-		t0 = Mpy_32(Kh, Kl, Kh, Kl);               /* K*K      in Q31 */
-		t0 = L_abs(t0);                            /* Some case <0 !! */
-		t0 = vo_L_sub((Word32) 0x7fffffffL, t0);   /* 1 - K*K  in Q31 */
-		hi = t0 >> 16;
-		lo = (t0 & 0xffff)>>1;
-		t0 = Mpy_32(alp_h, alp_l, hi, lo); /* Alpha in Q31    */
-
-		/* Normalize Alpha */
-		j = norm_l(t0);
-		t0 = (t0 << j);
-		alp_h = t0 >> 16;
-		alp_l = (t0 & 0xffff)>>1;
-		alp_exp += j;         /* Add normalization to alp_exp */
-
-		/* A[j] = An[j] */
-		for (j = 1; j <= i; j++)
-		{
-			Ah[j] = Anh[j];               
-			Al[j] = Anl[j];                
-		}
-	}
-	/* Truncate A[i] in Q27 to Q12 with rounding */
-	A[0] = 4096;                          
-	for (i = 1; i <= M; i++)
-	{
-		t0 = (Ah[i] << 16) + (Al[i] << 1);
-		old_A[i - 1] = A[i] = vo_round((t0 << 1));      
-	}
-	old_rc[0] = rc[0];                    
-	old_rc[1] = rc[1];                    
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: levinson.c                                                *
+*                                                                      *
+*      Description:LEVINSON-DURBIN algorithm in double precision       *
+*                                                                      *
+************************************************************************/
+/*---------------------------------------------------------------------------*
+ *                         LEVINSON.C					     *
+ *---------------------------------------------------------------------------*
+ *                                                                           *
+ *      LEVINSON-DURBIN algorithm in double precision                        *
+ *                                                                           *
+ *                                                                           *
+ * Algorithm                                                                 *
+ *                                                                           *
+ *       R[i]    autocorrelations.                                           *
+ *       A[i]    filter coefficients.                                        *
+ *       K       reflection coefficients.                                    *
+ *       Alpha   prediction gain.                                            *
+ *                                                                           *
+ *       Initialization:                                                     *
+ *               A[0] = 1                                                    *
+ *               K    = -R[1]/R[0]                                           *
+ *               A[1] = K                                                    *
+ *               Alpha = R[0] * (1-K**2]                                     *
+ *                                                                           *
+ *       Do for  i = 2 to M                                                  *
+ *                                                                           *
+ *            S =  SUM ( R[j]*A[i-j] ,j=1,i-1 ) +  R[i]                      *
+ *                                                                           *
+ *            K = -S / Alpha                                                 *
+ *                                                                           *
+ *            An[j] = A[j] + K*A[i-j]   for j=1 to i-1                       *
+ *                                      where   An[i] = new A[i]             *
+ *            An[i]=K                                                        *
+ *                                                                           *
+ *            Alpha=Alpha * (1-K**2)                                         *
+ *                                                                           *
+ *       END                                                                 *
+ *                                                                           *
+ * Remarks on the dynamics of the calculations.                              *
+ *                                                                           *
+ *       The numbers used are in double precision in the following format :  *
+ *       A = AH <<16 + AL<<1.  AH and AL are 16 bit signed integers.         *
+ *       Since the LSB's also contain a sign bit, this format does not       *
+ *       correspond to standard 32 bit integers.  We use this format since   *
+ *       it allows fast execution of multiplications and divisions.          *
+ *                                                                           *
+ *       "DPF" will refer to this special format in the following text.      *
+ *       See oper_32b.c                                                      *
+ *                                                                           *
+ *       The R[i] were normalized in routine AUTO (hence, R[i] < 1.0).       *
+ *       The K[i] and Alpha are theoretically < 1.0.                         *
+ *       The A[i], for a sampling frequency of 8 kHz, are in practice        *
+ *       always inferior to 16.0.                                            *
+ *                                                                           *
+ *       These characteristics allow straigthforward fixed-point             *
+ *       implementation.  We choose to represent the parameters as           *
+ *       follows :                                                           *
+ *                                                                           *
+ *               R[i]    Q31   +- .99..                                      *
+ *               K[i]    Q31   +- .99..                                      *
+ *               Alpha   Normalized -> mantissa in Q31 plus exponent         *
+ *               A[i]    Q27   +- 15.999..                                   *
+ *                                                                           *
+ *       The additions are performed in 32 bit.  For the summation used      *
+ *       to calculate the K[i], we multiply numbers in Q31 by numbers        *
+ *       in Q27, with the result of the multiplications in Q27,              *
+ *       resulting in a dynamic of +- 16.  This is sufficient to avoid       *
+ *       overflow, since the final result of the summation is                *
+ *       necessarily < 1.0 as both the K[i] and Alpha are                    *
+ *       theoretically < 1.0.                                                *
+ *___________________________________________________________________________*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "acelp.h"
+
+#define M   16
+#define NC  (M/2)
+
+void Init_Levinson(
+		Word16 * mem                          /* output  :static memory (18 words) */
+		)
+{
+	Set_zero(mem, 18);                     /* old_A[0..M-1] = 0, old_rc[0..1] = 0 */
+	return;
+}
+
+
+void Levinson(
+		Word16 Rh[],                          /* (i)     : Rh[M+1] Vector of autocorrelations (msb) */
+		Word16 Rl[],                          /* (i)     : Rl[M+1] Vector of autocorrelations (lsb) */
+		Word16 A[],                           /* (o) Q12 : A[M]    LPC coefficients  (m = 16)       */
+		Word16 rc[],                          /* (o) Q15 : rc[M]   Reflection coefficients.         */
+		Word16 * mem                          /* (i/o)   :static memory (18 words)                  */
+	     )
+{
+	Word32 i, j;
+	Word16 hi, lo;
+	Word16 Kh, Kl;                         /* reflection coefficient; hi and lo           */
+	Word16 alp_h, alp_l, alp_exp;          /* Prediction gain; hi lo and exponent         */
+	Word16 Ah[M + 1], Al[M + 1];           /* LPC coef. in double prec.                   */
+	Word16 Anh[M + 1], Anl[M + 1];         /* LPC coef.for next iteration in double prec. */
+	Word32 t0, t1, t2;                     /* temporary variable                          */
+	Word16 *old_A, *old_rc;
+
+	/* Last A(z) for case of unstable filter */
+	old_A = mem;
+	old_rc = mem + M;
+
+	/* K = A[1] = -R[1] / R[0] */
+
+	t1 = ((Rh[1] << 16) + (Rl[1] << 1));   /* R[1] in Q31 */
+	t2 = L_abs(t1);                        /* abs R[1]         */
+	t0 = Div_32(t2, Rh[0], Rl[0]);         /* R[1]/R[0] in Q31 */
+	if (t1 > 0)
+		t0 = -t0;                          /* -R[1]/R[0]       */
+
+	Kh = t0 >> 16;
+	Kl = (t0 & 0xffff)>>1;
+	rc[0] = Kh;
+	t0 = (t0 >> 4);                        /* A[1] in Q27      */
+
+	Ah[1] = t0 >> 16;
+	Al[1] = (t0 & 0xffff)>>1;
+
+	/* Alpha = R[0] * (1-K**2) */
+	t0 = Mpy_32(Kh, Kl, Kh, Kl);           /* K*K      in Q31 */
+	t0 = L_abs(t0);                        /* Some case <0 !! */
+	t0 = vo_L_sub((Word32) 0x7fffffffL, t0);  /* 1 - K*K  in Q31 */
+
+	hi = t0 >> 16;
+	lo = (t0 & 0xffff)>>1;
+
+	t0 = Mpy_32(Rh[0], Rl[0], hi, lo);     /* Alpha in Q31    */
+
+	/* Normalize Alpha */
+	alp_exp = norm_l(t0);
+	t0 = (t0 << alp_exp);
+
+	alp_h = t0 >> 16;
+	alp_l = (t0 & 0xffff)>>1;
+	/*--------------------------------------*
+	 * ITERATIONS  I=2 to M                 *
+	 *--------------------------------------*/
+	for (i = 2; i <= M; i++)
+	{
+		/* t0 = SUM ( R[j]*A[i-j] ,j=1,i-1 ) +  R[i] */
+		t0 = 0;
+		for (j = 1; j < i; j++)
+			t0 = vo_L_add(t0, Mpy_32(Rh[j], Rl[j], Ah[i - j], Al[i - j]));
+
+		t0 = t0 << 4;                 /* result in Q27 -> convert to Q31 */
+		/* No overflow possible            */
+		t1 = ((Rh[i] << 16) + (Rl[i] << 1));
+		t0 = vo_L_add(t0, t1);                /* add R[i] in Q31                 */
+
+		/* K = -t0 / Alpha */
+		t1 = L_abs(t0);
+		t2 = Div_32(t1, alp_h, alp_l);     /* abs(t0)/Alpha                   */
+		if (t0 > 0)
+			t2 = -t2;                   /* K =-t0/Alpha                    */
+		t2 = (t2 << alp_exp);           /* denormalize; compare to Alpha   */
+
+		Kh = t2 >> 16;
+		Kl = (t2 & 0xffff)>>1;
+
+		rc[i - 1] = Kh;
+		/* Test for unstable filter. If unstable keep old A(z) */
+		if (abs_s(Kh) > 32750)
+		{
+			A[0] = 4096;                    /* Ai[0] not stored (always 1.0) */
+			for (j = 0; j < M; j++)
+			{
+				A[j + 1] = old_A[j];
+			}
+			rc[0] = old_rc[0];             /* only two rc coefficients are needed */
+			rc[1] = old_rc[1];
+			return;
+		}
+		/*------------------------------------------*
+		 *  Compute new LPC coeff. -> An[i]         *
+		 *  An[j]= A[j] + K*A[i-j]     , j=1 to i-1 *
+		 *  An[i]= K                                *
+		 *------------------------------------------*/
+		for (j = 1; j < i; j++)
+		{
+			t0 = Mpy_32(Kh, Kl, Ah[i - j], Al[i - j]);
+			t0 = vo_L_add(t0, ((Ah[j] << 16) + (Al[j] << 1)));
+			Anh[j] = t0 >> 16;
+			Anl[j] = (t0 & 0xffff)>>1;
+		}
+		t2 = (t2 >> 4);                 /* t2 = K in Q31 ->convert to Q27  */
+
+		VO_L_Extract(t2, &Anh[i], &Anl[i]);   /* An[i] in Q27                    */
+
+		/* Alpha = Alpha * (1-K**2) */
+		t0 = Mpy_32(Kh, Kl, Kh, Kl);               /* K*K      in Q31 */
+		t0 = L_abs(t0);                            /* Some case <0 !! */
+		t0 = vo_L_sub((Word32) 0x7fffffffL, t0);   /* 1 - K*K  in Q31 */
+		hi = t0 >> 16;
+		lo = (t0 & 0xffff)>>1;
+		t0 = Mpy_32(alp_h, alp_l, hi, lo); /* Alpha in Q31    */
+
+		/* Normalize Alpha */
+		j = norm_l(t0);
+		t0 = (t0 << j);
+		alp_h = t0 >> 16;
+		alp_l = (t0 & 0xffff)>>1;
+		alp_exp += j;         /* Add normalization to alp_exp */
+
+		/* A[j] = An[j] */
+		for (j = 1; j <= i; j++)
+		{
+			Ah[j] = Anh[j];
+			Al[j] = Anl[j];
+		}
+	}
+	/* Truncate A[i] in Q27 to Q12 with rounding */
+	A[0] = 4096;
+	for (i = 1; i <= M; i++)
+	{
+		t0 = (Ah[i] << 16) + (Al[i] << 1);
+		old_A[i - 1] = A[i] = vo_round((t0 << 1));
+	}
+	old_rc[0] = rc[0];
+	old_rc[1] = rc[1];
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/log2.c b/media/libstagefright/codecs/amrwbenc/src/log2.c
index cd3d815..0f65541 100644
--- a/media/libstagefright/codecs/amrwbenc/src/log2.c
+++ b/media/libstagefright/codecs/amrwbenc/src/log2.c
@@ -1,111 +1,111 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*                                                                      *
-*      File             : log2.c                                       *
-*      Purpose          : Computes log2(L_x)                           *
-*                                                                      *
-************************************************************************/
-
-#include "log2.h"
-/********************************************************************************
-*                         INCLUDE FILES
-*********************************************************************************/
-#include "typedef.h"
-#include "basic_op.h"
-
-/*********************************************************************************
-*                         LOCAL VARIABLES AND TABLES
-**********************************************************************************/
-#include "log2_tab.h"     /* Table for Log2() */
-
-/*************************************************************************
-*
-*   FUNCTION:   Log2_norm()
-*
-*   PURPOSE:   Computes log2(L_x, exp),  where   L_x is positive and
-*              normalized, and exp is the normalisation exponent
-*              If L_x is negative or zero, the result is 0.
-*
-*   DESCRIPTION:
-*        The function Log2(L_x) is approximated by a table and linear
-*        interpolation. The following steps are used to compute Log2(L_x)
-*
-*           1- exponent = 30-norm_exponent
-*           2- i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
-*           3- a = bit10-b24
-*           4- i -=32
-*           5- fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
-*
-*************************************************************************/
-
-void Log2_norm (
-		Word32 L_x,         /* (i) : input value (normalized)                    */
-		Word16 exp,         /* (i) : norm_l (L_x)                                */
-		Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
-		Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1)  */
-	       )
-{
-	Word16 i, a, tmp;
-	Word32 L_y;
-	if (L_x <= (Word32) 0)
-	{
-		*exponent = 0; 
-		*fraction = 0; 
-		return;
-	}
-	*exponent = (30 - exp); 
-	L_x = (L_x >> 9);
-	i = extract_h (L_x);                /* Extract b25-b31 */
-	L_x = (L_x >> 1);
-	a = (Word16)(L_x);                /* Extract b10-b24 of fraction */
-	a = (Word16)(a & (Word16)0x7fff);
-	i -= 32;
-	L_y = L_deposit_h (table[i]);       /* table[i] << 16        */
-	tmp = vo_sub(table[i], table[i + 1]); /* table[i] - table[i+1] */
-	L_y = vo_L_msu (L_y, tmp, a);          /* L_y -= tmp*a*2        */
-	*fraction = extract_h (L_y); 
-
-	return;
-}
-
-/*************************************************************************
-*
-*   FUNCTION:   Log2()
-*
-*   PURPOSE:   Computes log2(L_x),  where   L_x is positive.
-*              If L_x is negative or zero, the result is 0.
-*
-*   DESCRIPTION:
-*        normalizes L_x and then calls Log2_norm().
-*
-*************************************************************************/
-
-void Log2 (
-		Word32 L_x,         /* (i) : input value                                 */
-		Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
-		Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1) */
-	  )
-{
-	Word16 exp;
-
-	exp = norm_l(L_x);
-	Log2_norm ((L_x << exp), exp, exponent, fraction);
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*                                                                      *
+*      File             : log2.c                                       *
+*      Purpose          : Computes log2(L_x)                           *
+*                                                                      *
+************************************************************************/
+
+#include "log2.h"
+/********************************************************************************
+*                         INCLUDE FILES
+*********************************************************************************/
+#include "typedef.h"
+#include "basic_op.h"
+
+/*********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+**********************************************************************************/
+#include "log2_tab.h"     /* Table for Log2() */
+
+/*************************************************************************
+*
+*   FUNCTION:   Log2_norm()
+*
+*   PURPOSE:   Computes log2(L_x, exp),  where   L_x is positive and
+*              normalized, and exp is the normalisation exponent
+*              If L_x is negative or zero, the result is 0.
+*
+*   DESCRIPTION:
+*        The function Log2(L_x) is approximated by a table and linear
+*        interpolation. The following steps are used to compute Log2(L_x)
+*
+*           1- exponent = 30-norm_exponent
+*           2- i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
+*           3- a = bit10-b24
+*           4- i -=32
+*           5- fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+*
+*************************************************************************/
+
+void Log2_norm (
+		Word32 L_x,         /* (i) : input value (normalized)                    */
+		Word16 exp,         /* (i) : norm_l (L_x)                                */
+		Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+		Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1)  */
+	       )
+{
+	Word16 i, a, tmp;
+	Word32 L_y;
+	if (L_x <= (Word32) 0)
+	{
+		*exponent = 0;
+		*fraction = 0;
+		return;
+	}
+	*exponent = (30 - exp);
+	L_x = (L_x >> 9);
+	i = extract_h (L_x);                /* Extract b25-b31 */
+	L_x = (L_x >> 1);
+	a = (Word16)(L_x);                /* Extract b10-b24 of fraction */
+	a = (Word16)(a & (Word16)0x7fff);
+	i -= 32;
+	L_y = L_deposit_h (table[i]);       /* table[i] << 16        */
+	tmp = vo_sub(table[i], table[i + 1]); /* table[i] - table[i+1] */
+	L_y = vo_L_msu (L_y, tmp, a);          /* L_y -= tmp*a*2        */
+	*fraction = extract_h (L_y);
+
+	return;
+}
+
+/*************************************************************************
+*
+*   FUNCTION:   Log2()
+*
+*   PURPOSE:   Computes log2(L_x),  where   L_x is positive.
+*              If L_x is negative or zero, the result is 0.
+*
+*   DESCRIPTION:
+*        normalizes L_x and then calls Log2_norm().
+*
+*************************************************************************/
+
+void Log2 (
+		Word32 L_x,         /* (i) : input value                                 */
+		Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+		Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1) */
+	  )
+{
+	Word16 exp;
+
+	exp = norm_l(L_x);
+	Log2_norm ((L_x << exp), exp, exponent, fraction);
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/lp_dec2.c b/media/libstagefright/codecs/amrwbenc/src/lp_dec2.c
index 63b746b..1d5d076 100644
--- a/media/libstagefright/codecs/amrwbenc/src/lp_dec2.c
+++ b/media/libstagefright/codecs/amrwbenc/src/lp_dec2.c
@@ -1,70 +1,70 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: lp_dec2.c                                                *
-*                                                                      *
-*	Description:Decimate a vector by 2 with 2nd order fir filter   *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "cnst.h"
-
-#define L_FIR  5
-#define L_MEM  (L_FIR-2)
-
-/* static float h_fir[L_FIR] = {0.13, 0.23, 0.28, 0.23, 0.13}; */
-/* fixed-point: sum of coef = 32767 to avoid overflow on DC */
-static Word16 h_fir[L_FIR] = {4260, 7536, 9175, 7536, 4260};
-
-void LP_Decim2(
-		Word16 x[],                           /* in/out: signal to process         */
-		Word16 l,                             /* input : size of filtering         */
-		Word16 mem[]                          /* in/out: memory (size=3)           */
-	      )
-{
-	Word16 *p_x, x_buf[L_FRAME + L_MEM];
-	Word32 i, j;
-	Word32 L_tmp;
-	/* copy initial filter states into buffer */
-	p_x = x_buf;                           
-	for (i = 0; i < L_MEM; i++)
-	{
-		*p_x++ = mem[i];  
-		mem[i] = x[l - L_MEM + i];  
-	}
-	for (i = 0; i < l; i++)
-	{
-		*p_x++ = x[i];                     
-	}
-	for (i = 0, j = 0; i < l; i += 2, j++)
-	{
-		p_x = &x_buf[i];  
-		L_tmp  = ((*p_x++) * h_fir[0]);
-		L_tmp += ((*p_x++) * h_fir[1]);
-		L_tmp += ((*p_x++) * h_fir[2]);
-		L_tmp += ((*p_x++) * h_fir[3]);
-		L_tmp += ((*p_x++) * h_fir[4]);
-		x[j] = (L_tmp + 0x4000)>>15;              
-	}
-	return;
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: lp_dec2.c                                                *
+*                                                                      *
+*	Description:Decimate a vector by 2 with 2nd order fir filter   *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "cnst.h"
+
+#define L_FIR  5
+#define L_MEM  (L_FIR-2)
+
+/* static float h_fir[L_FIR] = {0.13, 0.23, 0.28, 0.23, 0.13}; */
+/* fixed-point: sum of coef = 32767 to avoid overflow on DC */
+static Word16 h_fir[L_FIR] = {4260, 7536, 9175, 7536, 4260};
+
+void LP_Decim2(
+		Word16 x[],                           /* in/out: signal to process         */
+		Word16 l,                             /* input : size of filtering         */
+		Word16 mem[]                          /* in/out: memory (size=3)           */
+	      )
+{
+	Word16 *p_x, x_buf[L_FRAME + L_MEM];
+	Word32 i, j;
+	Word32 L_tmp;
+	/* copy initial filter states into buffer */
+	p_x = x_buf;
+	for (i = 0; i < L_MEM; i++)
+	{
+		*p_x++ = mem[i];
+		mem[i] = x[l - L_MEM + i];
+	}
+	for (i = 0; i < l; i++)
+	{
+		*p_x++ = x[i];
+	}
+	for (i = 0, j = 0; i < l; i += 2, j++)
+	{
+		p_x = &x_buf[i];
+		L_tmp  = ((*p_x++) * h_fir[0]);
+		L_tmp += ((*p_x++) * h_fir[1]);
+		L_tmp += ((*p_x++) * h_fir[2]);
+		L_tmp += ((*p_x++) * h_fir[3]);
+		L_tmp += ((*p_x++) * h_fir[4]);
+		x[j] = (L_tmp + 0x4000)>>15;
+	}
+	return;
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/math_op.c b/media/libstagefright/codecs/amrwbenc/src/math_op.c
index 1c95ed0..7affbb2 100644
--- a/media/libstagefright/codecs/amrwbenc/src/math_op.c
+++ b/media/libstagefright/codecs/amrwbenc/src/math_op.c
@@ -1,219 +1,219 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/*___________________________________________________________________________
-|                                                                           |
-|  This file contains mathematic operations in fixed point.                 |
-|                                                                           |
-|  Isqrt()              : inverse square root (16 bits precision).          |
-|  Pow2()               : 2^x  (16 bits precision).                         |
-|  Log2()               : log2 (16 bits precision).                         |
-|  Dot_product()        : scalar product of <x[],y[]>                       |
-|                                                                           |
-|  These operations are not standard double precision operations.           |
-|  They are used where low complexity is important and the full 32 bits     |
-|  precision is not necessary. For example, the function Div_32() has a     |
-|  24 bits precision which is enough for our purposes.                      |
-|                                                                           |
-|  In this file, the values use theses representations:                     |
-|                                                                           |
-|  Word32 L_32     : standard signed 32 bits format                         |
-|  Word16 hi, lo   : L_32 = hi<<16 + lo<<1  (DPF - Double Precision Format) |
-|  Word32 frac, Word16 exp : L_32 = frac << exp-31  (normalised format)     |
-|  Word16 int, frac        : L_32 = int.frac        (fractional format)     |
-|___________________________________________________________________________|
-*/
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : Isqrt                                                   |
-|                                                                           |
-|       Compute 1/sqrt(L_x).                                                |
-|       if L_x is negative or zero, result is 1 (7fffffff).                 |
-|---------------------------------------------------------------------------|
-|  Algorithm:                                                               |
-|                                                                           |
-|   1- Normalization of L_x.                                                |
-|   2- call Isqrt_n(L_x, exponant)                                          |
-|   3- L_y = L_x << exponant                                                |
-|___________________________________________________________________________|
-*/
-Word32 Isqrt(                              /* (o) Q31 : output value (range: 0<=val<1)         */
-		Word32 L_x                            /* (i) Q0  : input value  (range: 0<=val<=7fffffff) */
-	    )
-{
-	Word16 exp;
-	Word32 L_y;
-	exp = norm_l(L_x);
-	L_x = (L_x << exp);                 /* L_x is normalized */
-	exp = (31 - exp);
-	Isqrt_n(&L_x, &exp);
-	L_y = (L_x << exp);                 /* denormalization   */
-	return (L_y);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : Isqrt_n                                                 |
-|                                                                           |
-|       Compute 1/sqrt(value).                                              |
-|       if value is negative or zero, result is 1 (frac=7fffffff, exp=0).   |
-|---------------------------------------------------------------------------|
-|  Algorithm:                                                               |
-|                                                                           |
-|   The function 1/sqrt(value) is approximated by a table and linear        |
-|   interpolation.                                                          |
-|                                                                           |
-|   1- If exponant is odd then shift fraction right once.                   |
-|   2- exponant = -((exponant-1)>>1)                                        |
-|   3- i = bit25-b30 of fraction, 16 <= i <= 63 ->because of normalization. |
-|   4- a = bit10-b24                                                        |
-|   5- i -=16                                                               |
-|   6- fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2            |
-|___________________________________________________________________________|
-*/
-static Word16 table_isqrt[49] =
-{
-	32767, 31790, 30894, 30070, 29309, 28602, 27945, 27330, 26755, 26214,
-	25705, 25225, 24770, 24339, 23930, 23541, 23170, 22817, 22479, 22155,
-	21845, 21548, 21263, 20988, 20724, 20470, 20225, 19988, 19760, 19539,
-	19326, 19119, 18919, 18725, 18536, 18354, 18176, 18004, 17837, 17674,
-	17515, 17361, 17211, 17064, 16921, 16782, 16646, 16514, 16384
-};
-
-void Isqrt_n(
-		Word32 * frac,                        /* (i/o) Q31: normalized value (1.0 < frac <= 0.5) */
-		Word16 * exp                          /* (i/o)    : exponent (value = frac x 2^exponent) */
-	    )
-{
-	Word16 i, a, tmp;
-
-	if (*frac <= (Word32) 0)
-	{
-		*exp = 0;                          
-		*frac = 0x7fffffffL;               
-		return;
-	}
-
-	if((*exp & 1) == 1)                       /*If exponant odd -> shift right */
-		*frac = (*frac) >> 1;
-
-	*exp = negate((*exp - 1) >> 1);   
-
-	*frac = (*frac >> 9);               
-	i = extract_h(*frac);                  /* Extract b25-b31 */
-	*frac = (*frac >> 1);              
-	a = (Word16)(*frac);                  /* Extract b10-b24 */
-	a = (Word16) (a & (Word16) 0x7fff);    
-	i -= 16;
-	*frac = L_deposit_h(table_isqrt[i]);   /* table[i] << 16         */
-	tmp = vo_sub(table_isqrt[i], table_isqrt[i + 1]);      /* table[i] - table[i+1]) */
-	*frac = vo_L_msu(*frac, tmp, a);          /* frac -=  tmp*a*2       */
-
-	return;
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : Pow2()                                                  |
-|                                                                           |
-|     L_x = pow(2.0, exponant.fraction)         (exponant = interger part)  |
-|         = pow(2.0, 0.fraction) << exponant                                |
-|---------------------------------------------------------------------------|
-|  Algorithm:                                                               |
-|                                                                           |
-|   The function Pow2(L_x) is approximated by a table and linear            |
-|   interpolation.                                                          |
-|                                                                           |
-|   1- i = bit10-b15 of fraction,   0 <= i <= 31                            |
-|   2- a = bit0-b9   of fraction                                            |
-|   3- L_x = table[i]<<16 - (table[i] - table[i+1]) * a * 2                 |
-|   4- L_x = L_x >> (30-exponant)     (with rounding)                       |
-|___________________________________________________________________________|
-*/
-static Word16 table_pow2[33] =
-{
-	16384, 16743, 17109, 17484, 17867, 18258, 18658, 19066, 19484, 19911,
-	20347, 20792, 21247, 21713, 22188, 22674, 23170, 23678, 24196, 24726,
-	25268, 25821, 26386, 26964, 27554, 28158, 28774, 29405, 30048, 30706,
-	31379, 32066, 32767
-};
-
-Word32 Pow2(                               /* (o) Q0  : result       (range: 0<=val<=0x7fffffff) */
-		Word16 exponant,                      /* (i) Q0  : Integer part.      (range: 0<=val<=30)   */
-		Word16 fraction                       /* (i) Q15 : Fractionnal part.  (range: 0.0<=val<1.0) */
-	   )
-{
-	Word16 exp, i, a, tmp;
-	Word32 L_x;
-
-	L_x = vo_L_mult(fraction, 32);            /* L_x = fraction<<6           */
-	i = extract_h(L_x);                    /* Extract b10-b16 of fraction */
-	L_x =L_x >> 1;
-	a = (Word16)(L_x);                    /* Extract b0-b9   of fraction */
-	a = (Word16) (a & (Word16) 0x7fff); 
-
-	L_x = L_deposit_h(table_pow2[i]);      /* table[i] << 16        */
-	tmp = vo_sub(table_pow2[i], table_pow2[i + 1]);        /* table[i] - table[i+1] */
-	L_x -= (tmp * a)<<1;              /* L_x -= tmp*a*2        */
-
-	exp = vo_sub(30, exponant);
-	L_x = vo_L_shr_r(L_x, exp);
-
-	return (L_x);
-}
-
-/*___________________________________________________________________________
-|                                                                           |
-|   Function Name : Dot_product12()                                         |
-|                                                                           |
-|       Compute scalar product of <x[],y[]> using accumulator.              |
-|                                                                           |
-|       The result is normalized (in Q31) with exponent (0..30).            |
-|---------------------------------------------------------------------------|
-|  Algorithm:                                                               |
-|                                                                           |
-|       dot_product = sum(x[i]*y[i])     i=0..N-1                           |
-|___________________________________________________________________________|
-*/
-
-Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
-		Word16 x[],                           /* (i) 12bits: x vector                       */
-		Word16 y[],                           /* (i) 12bits: y vector                       */
-		Word16 lg,                            /* (i)    : vector length                     */
-		Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
-		)
-{
-	Word16 sft;
-	Word32 i, L_sum;
-	L_sum = 0;
-	for (i = 0; i < lg; i++)
-	{
-		L_sum += x[i] * y[i];
-	}
-	L_sum = (L_sum << 1) + 1;
-	/* Normalize acc in Q31 */
-	sft = norm_l(L_sum);
-	L_sum = L_sum << sft;
-	*exp = 30 - sft;            /* exponent = 0..30 */
-	return (L_sum);
-
-}
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/*___________________________________________________________________________
+|                                                                           |
+|  This file contains mathematic operations in fixed point.                 |
+|                                                                           |
+|  Isqrt()              : inverse square root (16 bits precision).          |
+|  Pow2()               : 2^x  (16 bits precision).                         |
+|  Log2()               : log2 (16 bits precision).                         |
+|  Dot_product()        : scalar product of <x[],y[]>                       |
+|                                                                           |
+|  These operations are not standard double precision operations.           |
+|  They are used where low complexity is important and the full 32 bits     |
+|  precision is not necessary. For example, the function Div_32() has a     |
+|  24 bits precision which is enough for our purposes.                      |
+|                                                                           |
+|  In this file, the values use theses representations:                     |
+|                                                                           |
+|  Word32 L_32     : standard signed 32 bits format                         |
+|  Word16 hi, lo   : L_32 = hi<<16 + lo<<1  (DPF - Double Precision Format) |
+|  Word32 frac, Word16 exp : L_32 = frac << exp-31  (normalised format)     |
+|  Word16 int, frac        : L_32 = int.frac        (fractional format)     |
+|___________________________________________________________________________|
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : Isqrt                                                   |
+|                                                                           |
+|       Compute 1/sqrt(L_x).                                                |
+|       if L_x is negative or zero, result is 1 (7fffffff).                 |
+|---------------------------------------------------------------------------|
+|  Algorithm:                                                               |
+|                                                                           |
+|   1- Normalization of L_x.                                                |
+|   2- call Isqrt_n(L_x, exponant)                                          |
+|   3- L_y = L_x << exponant                                                |
+|___________________________________________________________________________|
+*/
+Word32 Isqrt(                              /* (o) Q31 : output value (range: 0<=val<1)         */
+		Word32 L_x                            /* (i) Q0  : input value  (range: 0<=val<=7fffffff) */
+	    )
+{
+	Word16 exp;
+	Word32 L_y;
+	exp = norm_l(L_x);
+	L_x = (L_x << exp);                 /* L_x is normalized */
+	exp = (31 - exp);
+	Isqrt_n(&L_x, &exp);
+	L_y = (L_x << exp);                 /* denormalization   */
+	return (L_y);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : Isqrt_n                                                 |
+|                                                                           |
+|       Compute 1/sqrt(value).                                              |
+|       if value is negative or zero, result is 1 (frac=7fffffff, exp=0).   |
+|---------------------------------------------------------------------------|
+|  Algorithm:                                                               |
+|                                                                           |
+|   The function 1/sqrt(value) is approximated by a table and linear        |
+|   interpolation.                                                          |
+|                                                                           |
+|   1- If exponant is odd then shift fraction right once.                   |
+|   2- exponant = -((exponant-1)>>1)                                        |
+|   3- i = bit25-b30 of fraction, 16 <= i <= 63 ->because of normalization. |
+|   4- a = bit10-b24                                                        |
+|   5- i -=16                                                               |
+|   6- fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2            |
+|___________________________________________________________________________|
+*/
+static Word16 table_isqrt[49] =
+{
+	32767, 31790, 30894, 30070, 29309, 28602, 27945, 27330, 26755, 26214,
+	25705, 25225, 24770, 24339, 23930, 23541, 23170, 22817, 22479, 22155,
+	21845, 21548, 21263, 20988, 20724, 20470, 20225, 19988, 19760, 19539,
+	19326, 19119, 18919, 18725, 18536, 18354, 18176, 18004, 17837, 17674,
+	17515, 17361, 17211, 17064, 16921, 16782, 16646, 16514, 16384
+};
+
+void Isqrt_n(
+		Word32 * frac,                        /* (i/o) Q31: normalized value (1.0 < frac <= 0.5) */
+		Word16 * exp                          /* (i/o)    : exponent (value = frac x 2^exponent) */
+	    )
+{
+	Word16 i, a, tmp;
+
+	if (*frac <= (Word32) 0)
+	{
+		*exp = 0;
+		*frac = 0x7fffffffL;
+		return;
+	}
+
+	if((*exp & 1) == 1)                       /*If exponant odd -> shift right */
+		*frac = (*frac) >> 1;
+
+	*exp = negate((*exp - 1) >> 1);
+
+	*frac = (*frac >> 9);
+	i = extract_h(*frac);                  /* Extract b25-b31 */
+	*frac = (*frac >> 1);
+	a = (Word16)(*frac);                  /* Extract b10-b24 */
+	a = (Word16) (a & (Word16) 0x7fff);
+	i -= 16;
+	*frac = L_deposit_h(table_isqrt[i]);   /* table[i] << 16         */
+	tmp = vo_sub(table_isqrt[i], table_isqrt[i + 1]);      /* table[i] - table[i+1]) */
+	*frac = vo_L_msu(*frac, tmp, a);          /* frac -=  tmp*a*2       */
+
+	return;
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : Pow2()                                                  |
+|                                                                           |
+|     L_x = pow(2.0, exponant.fraction)         (exponant = interger part)  |
+|         = pow(2.0, 0.fraction) << exponant                                |
+|---------------------------------------------------------------------------|
+|  Algorithm:                                                               |
+|                                                                           |
+|   The function Pow2(L_x) is approximated by a table and linear            |
+|   interpolation.                                                          |
+|                                                                           |
+|   1- i = bit10-b15 of fraction,   0 <= i <= 31                            |
+|   2- a = bit0-b9   of fraction                                            |
+|   3- L_x = table[i]<<16 - (table[i] - table[i+1]) * a * 2                 |
+|   4- L_x = L_x >> (30-exponant)     (with rounding)                       |
+|___________________________________________________________________________|
+*/
+static Word16 table_pow2[33] =
+{
+	16384, 16743, 17109, 17484, 17867, 18258, 18658, 19066, 19484, 19911,
+	20347, 20792, 21247, 21713, 22188, 22674, 23170, 23678, 24196, 24726,
+	25268, 25821, 26386, 26964, 27554, 28158, 28774, 29405, 30048, 30706,
+	31379, 32066, 32767
+};
+
+Word32 Pow2(                               /* (o) Q0  : result       (range: 0<=val<=0x7fffffff) */
+		Word16 exponant,                      /* (i) Q0  : Integer part.      (range: 0<=val<=30)   */
+		Word16 fraction                       /* (i) Q15 : Fractionnal part.  (range: 0.0<=val<1.0) */
+	   )
+{
+	Word16 exp, i, a, tmp;
+	Word32 L_x;
+
+	L_x = vo_L_mult(fraction, 32);            /* L_x = fraction<<6           */
+	i = extract_h(L_x);                    /* Extract b10-b16 of fraction */
+	L_x =L_x >> 1;
+	a = (Word16)(L_x);                    /* Extract b0-b9   of fraction */
+	a = (Word16) (a & (Word16) 0x7fff);
+
+	L_x = L_deposit_h(table_pow2[i]);      /* table[i] << 16        */
+	tmp = vo_sub(table_pow2[i], table_pow2[i + 1]);        /* table[i] - table[i+1] */
+	L_x -= (tmp * a)<<1;              /* L_x -= tmp*a*2        */
+
+	exp = vo_sub(30, exponant);
+	L_x = vo_L_shr_r(L_x, exp);
+
+	return (L_x);
+}
+
+/*___________________________________________________________________________
+|                                                                           |
+|   Function Name : Dot_product12()                                         |
+|                                                                           |
+|       Compute scalar product of <x[],y[]> using accumulator.              |
+|                                                                           |
+|       The result is normalized (in Q31) with exponent (0..30).            |
+|---------------------------------------------------------------------------|
+|  Algorithm:                                                               |
+|                                                                           |
+|       dot_product = sum(x[i]*y[i])     i=0..N-1                           |
+|___________________________________________________________________________|
+*/
+
+Word32 Dot_product12(                      /* (o) Q31: normalized result (1 < val <= -1) */
+		Word16 x[],                           /* (i) 12bits: x vector                       */
+		Word16 y[],                           /* (i) 12bits: y vector                       */
+		Word16 lg,                            /* (i)    : vector length                     */
+		Word16 * exp                          /* (o)    : exponent of result (0..+30)       */
+		)
+{
+	Word16 sft;
+	Word32 i, L_sum;
+	L_sum = 0;
+	for (i = 0; i < lg; i++)
+	{
+		L_sum += x[i] * y[i];
+	}
+	L_sum = (L_sum << 1) + 1;
+	/* Normalize acc in Q31 */
+	sft = norm_l(L_sum);
+	L_sum = L_sum << sft;
+	*exp = 30 - sft;            /* exponent = 0..30 */
+	return (L_sum);
+
+}
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/mem_align.c b/media/libstagefright/codecs/amrwbenc/src/mem_align.c
index e58915a..a29baf3 100644
--- a/media/libstagefright/codecs/amrwbenc/src/mem_align.c
+++ b/media/libstagefright/codecs/amrwbenc/src/mem_align.c
@@ -27,7 +27,7 @@
 /*****************************************************************************
 *
 * function name: mem_malloc
-* description:  malloc the alignments memory 
+* description:  malloc the alignments memory
 * returns:      the point of the memory
 *
 **********************************************************************************/
diff --git a/media/libstagefright/codecs/amrwbenc/src/oper_32b.c b/media/libstagefright/codecs/amrwbenc/src/oper_32b.c
index 5f1523e..27cad76 100644
--- a/media/libstagefright/codecs/amrwbenc/src/oper_32b.c
+++ b/media/libstagefright/codecs/amrwbenc/src/oper_32b.c
@@ -1,223 +1,223 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/*****************************************************************************
- *  This file contains operations in double precision.                       *
- *  These operations are not standard double precision operations.           *
- *  They are used where single precision is not enough but the full 32 bits  *
- *  precision is not necessary. For example, the function Div_32() has a     *
- *  24 bits precision which is enough for our purposes.                      *
- *                                                                           *
- *  The double precision numbers use a special representation:               *
- *                                                                           *
- *     L_32 = hi<<16 + lo<<1                                                 *
- *                                                                           *
- *  L_32 is a 32 bit integer.                                                *
- *  hi and lo are 16 bit signed integers.                                    *
- *  As the low part also contains the sign, this allows fast multiplication. *
- *                                                                           *
- *      0x8000 0000 <= L_32 <= 0x7fff fffe.                                  *
- *                                                                           *
- *  We will use DPF (Double Precision Format )in this file to specify        *
- *  this special format.                                                     *
- *****************************************************************************
-*/
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-
-/*****************************************************************************
- *                                                                           *
- *  Function L_Extract()                                                     *
- *                                                                           *
- *  Extract from a 32 bit integer two 16 bit DPF.                            *
- *                                                                           *
- *  Arguments:                                                               *
- *                                                                           *
- *   L_32      : 32 bit integer.                                             *
- *               0x8000 0000 <= L_32 <= 0x7fff ffff.                         *
- *   hi        : b16 to b31 of L_32                                          *
- *   lo        : (L_32 - hi<<16)>>1                                          *
- *****************************************************************************
-*/
-
-__inline void VO_L_Extract (Word32 L_32, Word16 *hi, Word16 *lo)
-{
-	*hi = (Word16)(L_32 >> 16);
-	*lo = (Word16)((L_32 & 0xffff) >> 1);
-	return;
-}
-
-/*****************************************************************************
- *                                                                           *
- *  Function L_Comp()                                                        *
- *                                                                           *
- *  Compose from two 16 bit DPF a 32 bit integer.                            *
- *                                                                           *
- *     L_32 = hi<<16 + lo<<1                                                 *
- *                                                                           *
- *  Arguments:                                                               *
- *                                                                           *
- *   hi        msb                                                           *
- *   lo        lsf (with sign)                                               *
- *                                                                           *
- *   Return Value :                                                          *
- *                                                                           *
- *             32 bit long signed integer (Word32) whose value falls in the  *
- *             range : 0x8000 0000 <= L_32 <= 0x7fff fff0.                   *
- *                                                                           *
- *****************************************************************************
-*/
-
-Word32 L_Comp (Word16 hi, Word16 lo)
-{
-	Word32 L_32;
-
-	L_32 = L_deposit_h (hi);
-
-	return (L_mac (L_32, lo, 1));       /* = hi<<16 + lo<<1 */
-}
-
-/*****************************************************************************
- * Function Mpy_32()                                                         *
- *                                                                           *
- *   Multiply two 32 bit integers (DPF). The result is divided by 2**31      *
- *                                                                           *
- *   L_32 = (hi1*hi2)<<1 + ( (hi1*lo2)>>15 + (lo1*hi2)>>15 )<<1              *
- *                                                                           *
- *   This operation can also be viewed as the multiplication of two Q31      *
- *   number and the result is also in Q31.                                   *
- *                                                                           *
- * Arguments:                                                                *
- *                                                                           *
- *  hi1         hi part of first number                                      *
- *  lo1         lo part of first number                                      *
- *  hi2         hi part of second number                                     *
- *  lo2         lo part of second number                                     *
- *                                                                           *
- *****************************************************************************
-*/
-
-__inline Word32  Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2)
-{
-	Word32 L_32;
-	L_32 = (hi1 * hi2);
-	L_32 += (hi1 * lo2) >> 15;
-	L_32 += (lo1 * hi2) >> 15;
-	L_32 <<= 1;
-
-	return (L_32);
-}
-
-/*****************************************************************************
- * Function Mpy_32_16()                                                      *
- *                                                                           *
- *   Multiply a 16 bit integer by a 32 bit (DPF). The result is divided      *
- *   by 2**15                                                                *
- *                                                                           *
- *                                                                           *
- *   L_32 = (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1                                *
- *                                                                           *
- * Arguments:                                                                *
- *                                                                           *
- *  hi          hi part of 32 bit number.                                    *
- *  lo          lo part of 32 bit number.                                    *
- *  n           16 bit number.                                               *
- *                                                                           *
- *****************************************************************************
-*/
-
-__inline Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n)
-{
-	Word32 L_32;
-
-	L_32 = (hi * n)<<1;
-	L_32 += (((lo * n)>>15)<<1);
-
-	return (L_32);
-}
-
-/*****************************************************************************
- *                                                                           *
- *   Function Name : Div_32                                                  *
- *                                                                           *
- *   Purpose :                                                               *
- *             Fractional integer division of two 32 bit numbers.            *
- *             L_num / L_denom.                                              *
- *             L_num and L_denom must be positive and L_num < L_denom.       *
- *             L_denom = denom_hi<<16 + denom_lo<<1                          *
- *             denom_hi is a normalize number.                               *
- *                                                                           *
- *   Inputs :                                                                *
- *                                                                           *
- *    L_num                                                                  *
- *             32 bit long signed integer (Word32) whose value falls in the  *
- *             range : 0x0000 0000 < L_num < L_denom                         *
- *                                                                           *
- *    L_denom = denom_hi<<16 + denom_lo<<1      (DPF)                        *
- *                                                                           *
- *       denom_hi                                                            *
- *             16 bit positive normalized integer whose value falls in the   *
- *             range : 0x4000 < hi < 0x7fff                                  *
- *       denom_lo                                                            *
- *             16 bit positive integer whose value falls in the              *
- *             range : 0 < lo < 0x7fff                                       *
- *                                                                           *
- *   Return Value :                                                          *
- *                                                                           *
- *    L_div                                                                  *
- *             32 bit long signed integer (Word32) whose value falls in the  *
- *             range : 0x0000 0000 <= L_div <= 0x7fff ffff.                  *
- *                                                                           *
- *  Algorithm:                                                               *
- *                                                                           *
- *  - find = 1/L_denom.                                                      *
- *      First approximation: approx = 1 / denom_hi                           *
- *      1/L_denom = approx * (2.0 - L_denom * approx )                       *
- *                                                                           *
- *  -  result = L_num * (1/L_denom)                                          *
- *****************************************************************************
-*/
-
-Word32 Div_32 (Word32 L_num, Word16 denom_hi, Word16 denom_lo)
-{
-	Word16 approx, hi, lo, n_hi, n_lo;
-	Word32 L_32;
-
-	/* First approximation: 1 / L_denom = 1/denom_hi */
-
-	approx = div_s ((Word16) 0x3fff, denom_hi);
-
-	/* 1/L_denom = approx * (2.0 - L_denom * approx) */
-
-	L_32 = Mpy_32_16 (denom_hi, denom_lo, approx);
-
-	L_32 = L_sub ((Word32) 0x7fffffffL, L_32);
-	hi = L_32 >> 16;
-	lo = (L_32 & 0xffff) >> 1;
-
-	L_32 = Mpy_32_16 (hi, lo, approx);
-
-	/* L_num * (1/L_denom) */
-	hi = L_32 >> 16;
-	lo = (L_32 & 0xffff) >> 1;
-	VO_L_Extract (L_num, &n_hi, &n_lo);
-	L_32 = Mpy_32 (n_hi, n_lo, hi, lo);
-	L_32 = L_shl2(L_32, 2);
-
-	return (L_32);
-}
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/*****************************************************************************
+ *  This file contains operations in double precision.                       *
+ *  These operations are not standard double precision operations.           *
+ *  They are used where single precision is not enough but the full 32 bits  *
+ *  precision is not necessary. For example, the function Div_32() has a     *
+ *  24 bits precision which is enough for our purposes.                      *
+ *                                                                           *
+ *  The double precision numbers use a special representation:               *
+ *                                                                           *
+ *     L_32 = hi<<16 + lo<<1                                                 *
+ *                                                                           *
+ *  L_32 is a 32 bit integer.                                                *
+ *  hi and lo are 16 bit signed integers.                                    *
+ *  As the low part also contains the sign, this allows fast multiplication. *
+ *                                                                           *
+ *      0x8000 0000 <= L_32 <= 0x7fff fffe.                                  *
+ *                                                                           *
+ *  We will use DPF (Double Precision Format )in this file to specify        *
+ *  this special format.                                                     *
+ *****************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+
+/*****************************************************************************
+ *                                                                           *
+ *  Function L_Extract()                                                     *
+ *                                                                           *
+ *  Extract from a 32 bit integer two 16 bit DPF.                            *
+ *                                                                           *
+ *  Arguments:                                                               *
+ *                                                                           *
+ *   L_32      : 32 bit integer.                                             *
+ *               0x8000 0000 <= L_32 <= 0x7fff ffff.                         *
+ *   hi        : b16 to b31 of L_32                                          *
+ *   lo        : (L_32 - hi<<16)>>1                                          *
+ *****************************************************************************
+*/
+
+__inline void VO_L_Extract (Word32 L_32, Word16 *hi, Word16 *lo)
+{
+	*hi = (Word16)(L_32 >> 16);
+	*lo = (Word16)((L_32 & 0xffff) >> 1);
+	return;
+}
+
+/*****************************************************************************
+ *                                                                           *
+ *  Function L_Comp()                                                        *
+ *                                                                           *
+ *  Compose from two 16 bit DPF a 32 bit integer.                            *
+ *                                                                           *
+ *     L_32 = hi<<16 + lo<<1                                                 *
+ *                                                                           *
+ *  Arguments:                                                               *
+ *                                                                           *
+ *   hi        msb                                                           *
+ *   lo        lsf (with sign)                                               *
+ *                                                                           *
+ *   Return Value :                                                          *
+ *                                                                           *
+ *             32 bit long signed integer (Word32) whose value falls in the  *
+ *             range : 0x8000 0000 <= L_32 <= 0x7fff fff0.                   *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 L_Comp (Word16 hi, Word16 lo)
+{
+	Word32 L_32;
+
+	L_32 = L_deposit_h (hi);
+
+	return (L_mac (L_32, lo, 1));       /* = hi<<16 + lo<<1 */
+}
+
+/*****************************************************************************
+ * Function Mpy_32()                                                         *
+ *                                                                           *
+ *   Multiply two 32 bit integers (DPF). The result is divided by 2**31      *
+ *                                                                           *
+ *   L_32 = (hi1*hi2)<<1 + ( (hi1*lo2)>>15 + (lo1*hi2)>>15 )<<1              *
+ *                                                                           *
+ *   This operation can also be viewed as the multiplication of two Q31      *
+ *   number and the result is also in Q31.                                   *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi1         hi part of first number                                      *
+ *  lo1         lo part of first number                                      *
+ *  hi2         hi part of second number                                     *
+ *  lo2         lo part of second number                                     *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+__inline Word32  Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2)
+{
+	Word32 L_32;
+	L_32 = (hi1 * hi2);
+	L_32 += (hi1 * lo2) >> 15;
+	L_32 += (lo1 * hi2) >> 15;
+	L_32 <<= 1;
+
+	return (L_32);
+}
+
+/*****************************************************************************
+ * Function Mpy_32_16()                                                      *
+ *                                                                           *
+ *   Multiply a 16 bit integer by a 32 bit (DPF). The result is divided      *
+ *   by 2**15                                                                *
+ *                                                                           *
+ *                                                                           *
+ *   L_32 = (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1                                *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi          hi part of 32 bit number.                                    *
+ *  lo          lo part of 32 bit number.                                    *
+ *  n           16 bit number.                                               *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+__inline Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n)
+{
+	Word32 L_32;
+
+	L_32 = (hi * n)<<1;
+	L_32 += (((lo * n)>>15)<<1);
+
+	return (L_32);
+}
+
+/*****************************************************************************
+ *                                                                           *
+ *   Function Name : Div_32                                                  *
+ *                                                                           *
+ *   Purpose :                                                               *
+ *             Fractional integer division of two 32 bit numbers.            *
+ *             L_num / L_denom.                                              *
+ *             L_num and L_denom must be positive and L_num < L_denom.       *
+ *             L_denom = denom_hi<<16 + denom_lo<<1                          *
+ *             denom_hi is a normalize number.                               *
+ *                                                                           *
+ *   Inputs :                                                                *
+ *                                                                           *
+ *    L_num                                                                  *
+ *             32 bit long signed integer (Word32) whose value falls in the  *
+ *             range : 0x0000 0000 < L_num < L_denom                         *
+ *                                                                           *
+ *    L_denom = denom_hi<<16 + denom_lo<<1      (DPF)                        *
+ *                                                                           *
+ *       denom_hi                                                            *
+ *             16 bit positive normalized integer whose value falls in the   *
+ *             range : 0x4000 < hi < 0x7fff                                  *
+ *       denom_lo                                                            *
+ *             16 bit positive integer whose value falls in the              *
+ *             range : 0 < lo < 0x7fff                                       *
+ *                                                                           *
+ *   Return Value :                                                          *
+ *                                                                           *
+ *    L_div                                                                  *
+ *             32 bit long signed integer (Word32) whose value falls in the  *
+ *             range : 0x0000 0000 <= L_div <= 0x7fff ffff.                  *
+ *                                                                           *
+ *  Algorithm:                                                               *
+ *                                                                           *
+ *  - find = 1/L_denom.                                                      *
+ *      First approximation: approx = 1 / denom_hi                           *
+ *      1/L_denom = approx * (2.0 - L_denom * approx )                       *
+ *                                                                           *
+ *  -  result = L_num * (1/L_denom)                                          *
+ *****************************************************************************
+*/
+
+Word32 Div_32 (Word32 L_num, Word16 denom_hi, Word16 denom_lo)
+{
+	Word16 approx, hi, lo, n_hi, n_lo;
+	Word32 L_32;
+
+	/* First approximation: 1 / L_denom = 1/denom_hi */
+
+	approx = div_s ((Word16) 0x3fff, denom_hi);
+
+	/* 1/L_denom = approx * (2.0 - L_denom * approx) */
+
+	L_32 = Mpy_32_16 (denom_hi, denom_lo, approx);
+
+	L_32 = L_sub ((Word32) 0x7fffffffL, L_32);
+	hi = L_32 >> 16;
+	lo = (L_32 & 0xffff) >> 1;
+
+	L_32 = Mpy_32_16 (hi, lo, approx);
+
+	/* L_num * (1/L_denom) */
+	hi = L_32 >> 16;
+	lo = (L_32 & 0xffff) >> 1;
+	VO_L_Extract (L_num, &n_hi, &n_lo);
+	L_32 = Mpy_32 (n_hi, n_lo, hi, lo);
+	L_32 = L_shl2(L_32, 2);
+
+	return (L_32);
+}
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/p_med_ol.c b/media/libstagefright/codecs/amrwbenc/src/p_med_ol.c
index 39ee966..b8174b9 100644
--- a/media/libstagefright/codecs/amrwbenc/src/p_med_ol.c
+++ b/media/libstagefright/codecs/amrwbenc/src/p_med_ol.c
@@ -1,256 +1,256 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: p_med_ol.c                                                *
-*                                                                      *
-*      Description: Compute the open loop pitch lag                    *
-*	            output: open loop pitch lag                        *                            
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "acelp.h"
-#include "oper_32b.h"
-#include "math_op.h"
-#include "p_med_ol.tab"
-
-Word16 Pitch_med_ol(
-		   Word16      wsp[],        /*   i: signal used to compute the open loop pitch*/  
-                                     /*      wsp[-pit_max] to wsp[-1] should be known */
-		   Coder_State *st,          /* i/o: codec global structure */
-		   Word16      L_frame       /*   i: length of frame to compute pitch */
-		)
-{
-	Word16 Tm;
-	Word16 hi, lo;
-	Word16 *ww, *we, *hp_wsp;
-	Word16 exp_R0, exp_R1, exp_R2;
-	Word32 i, j, max, R0, R1, R2;
-	Word16 *p1, *p2;
-	Word16 L_min = 17;                   /* minimum pitch lag: PIT_MIN / OPL_DECIM */
-	Word16 L_max = 115;                  /* maximum pitch lag: PIT_MAX / OPL_DECIM */
-	Word16 L_0 = st->old_T0_med;         /* old open-loop pitch */
-	Word16 *gain = &(st->ol_gain);       /* normalize correlation of hp_wsp for the lag */
-	Word16 *hp_wsp_mem = st->hp_wsp_mem; /* memory of the hypass filter for hp_wsp[] (lg = 9)*/
-	Word16 *old_hp_wsp = st->old_hp_wsp; /* hypass wsp[] */
-	Word16 wght_flg = st->ol_wght_flg;   /* is weighting function used */
-
-	ww = &corrweight[198];
-	we = &corrweight[98 + L_max - L_0];
-
-	max = MIN_32;                          
-	Tm = 0;                                
-	for (i = L_max; i > L_min; i--)
-	{
-		/* Compute the correlation */
-		R0 = 0;
-		p1 = wsp;
-		p2 = &wsp[-i];
-		for (j = 0; j < L_frame; j+=4)
-		{
-			R0 += vo_L_mult((*p1++), (*p2++));
-			R0 += vo_L_mult((*p1++), (*p2++));
-			R0 += vo_L_mult((*p1++), (*p2++));
-			R0 += vo_L_mult((*p1++), (*p2++));     
-		}
-		/* Weighting of the correlation function.   */
-		hi = R0>>16;
-		lo = (R0 & 0xffff)>>1;
-
-		R0 = Mpy_32_16(hi, lo, *ww);
-		ww--;
-
-		if ((L_0 > 0) && (wght_flg > 0))
-		{
-			/* Weight the neighbourhood of the old lag. */
-			hi = R0>>16;
-			lo = (R0 & 0xffff)>>1;
-			R0 = Mpy_32_16(hi, lo, *we);
-			we--;
-		}
-		if(R0 >= max)
-		{
-			max = R0;
-			Tm = i;
-		}
-	}
-
-	/* Hypass the wsp[] vector */
-	hp_wsp = old_hp_wsp + L_max;           
-	Hp_wsp(wsp, hp_wsp, L_frame, hp_wsp_mem);
-
-	/* Compute normalize correlation at delay Tm */
-	R0 = 0;                                
-	R1 = 0;                               
-	R2 = 0; 
-	p1 = hp_wsp;
-	p2 = hp_wsp - Tm;
-	for (j = 0; j < L_frame; j+=4)
-	{
-		R2 += vo_mult32(*p1, *p1);
-		R1 += vo_mult32(*p2, *p2);
-		R0 += vo_mult32(*p1++, *p2++);
-		R2 += vo_mult32(*p1, *p1);
-		R1 += vo_mult32(*p2, *p2);
-		R0 += vo_mult32(*p1++, *p2++);
-		R2 += vo_mult32(*p1, *p1);
-		R1 += vo_mult32(*p2, *p2);
-		R0 += vo_mult32(*p1++, *p2++);
-		R2 += vo_mult32(*p1, *p1);
-		R1 += vo_mult32(*p2, *p2);
-		R0 += vo_mult32(*p1++, *p2++);
-	}
-	R0 = R0 <<1;
-	R1 = (R1 <<1) + 1L;
-	R2 = (R2 <<1) + 1L;
-	/* gain = R0/ sqrt(R1*R2) */
-
-	exp_R0 = norm_l(R0);
-	R0 = (R0 << exp_R0);
-
-	exp_R1 = norm_l(R1);
-	R1 = (R1 << exp_R1);
-
-	exp_R2 = norm_l(R2);
-	R2 = (R2 << exp_R2);
-
-
-	R1 = vo_L_mult(vo_round(R1), vo_round(R2));
-
-	i = norm_l(R1);
-	R1 = (R1 << i);
-
-	exp_R1 += exp_R2;
-	exp_R1 += i;
-	exp_R1 = 62 - exp_R1;
-
-	Isqrt_n(&R1, &exp_R1);
-
-	R0 = vo_L_mult(voround(R0), voround(R1));
-	exp_R0 = 31 - exp_R0;
-	exp_R0 += exp_R1;
-
-	*gain = vo_round(L_shl(R0, exp_R0));
-
-	/* Shitf hp_wsp[] for next frame */
-
-	for (i = 0; i < L_max; i++)
-	{
-		old_hp_wsp[i] = old_hp_wsp[i + L_frame];
-	}
-
-	return (Tm);
-}
-
-/************************************************************************
-*  Function: median5                                                    *
-*                                                                       *
-*      Returns the median of the set {X[-2], X[-1],..., X[2]},          *
-*      whose elements are 16-bit integers.                              *
-*                                                                       *
-*  Input:                                                               *
-*      X[-2:2]   16-bit integers.                                       *
-*                                                                       *
-*  Return:                                                              *
-*      The median of {X[-2], X[-1],..., X[2]}.                          *
-************************************************************************/
-
-Word16 median5(Word16 x[])
-{
-	Word16 x1, x2, x3, x4, x5;
-	Word16 tmp;
-
-	x1 = x[-2];                            
-	x2 = x[-1];                            
-	x3 = x[0];                             
-	x4 = x[1];                             
-	x5 = x[2];                             
-
-	if (x2 < x1)
-	{
-		tmp = x1;
-		x1 = x2;
-		x2 = tmp;                          
-	}
-	if (x3 < x1)
-	{
-		tmp = x1;
-		x1 = x3;
-		x3 = tmp;                          
-	}
-	if (x4 < x1)
-	{
-		tmp = x1;
-		x1 = x4;
-		x4 = tmp;                          
-	}
-	if (x5 < x1)
-	{
-		x5 = x1;                           
-	}
-	if (x3 < x2)
-	{
-		tmp = x2;
-		x2 = x3;
-		x3 = tmp;                          
-	}
-	if (x4 < x2)
-	{
-		tmp = x2;
-		x2 = x4;
-		x4 = tmp;                          
-	}
-	if (x5 < x2)
-	{
-		x5 = x2;                           
-	}
-	if (x4 < x3)
-	{
-		x3 = x4;                           
-	}
-	if (x5 < x3)
-	{
-		x3 = x5;                           
-	}
-	return (x3);
-}
-
-
-Word16 Med_olag(                           /* output : median of  5 previous open-loop lags       */
-		Word16 prev_ol_lag,                /* input  : previous open-loop lag                     */
-		Word16 old_ol_lag[5]
-	       )
-{
-	Word32 i;
-
-	/* Use median of 5 previous open-loop lags as old lag */
-
-	for (i = 4; i > 0; i--)
-	{
-		old_ol_lag[i] = old_ol_lag[i - 1]; 
-	}
-
-	old_ol_lag[0] = prev_ol_lag;           
-
-	i = median5(&old_ol_lag[2]);
-
-	return i;
-
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: p_med_ol.c                                                *
+*                                                                      *
+*      Description: Compute the open loop pitch lag                    *
+*	            output: open loop pitch lag                        *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "acelp.h"
+#include "oper_32b.h"
+#include "math_op.h"
+#include "p_med_ol.tab"
+
+Word16 Pitch_med_ol(
+		   Word16      wsp[],        /*   i: signal used to compute the open loop pitch*/
+                                     /*      wsp[-pit_max] to wsp[-1] should be known */
+		   Coder_State *st,          /* i/o: codec global structure */
+		   Word16      L_frame       /*   i: length of frame to compute pitch */
+		)
+{
+	Word16 Tm;
+	Word16 hi, lo;
+	Word16 *ww, *we, *hp_wsp;
+	Word16 exp_R0, exp_R1, exp_R2;
+	Word32 i, j, max, R0, R1, R2;
+	Word16 *p1, *p2;
+	Word16 L_min = 17;                   /* minimum pitch lag: PIT_MIN / OPL_DECIM */
+	Word16 L_max = 115;                  /* maximum pitch lag: PIT_MAX / OPL_DECIM */
+	Word16 L_0 = st->old_T0_med;         /* old open-loop pitch */
+	Word16 *gain = &(st->ol_gain);       /* normalize correlation of hp_wsp for the lag */
+	Word16 *hp_wsp_mem = st->hp_wsp_mem; /* memory of the hypass filter for hp_wsp[] (lg = 9)*/
+	Word16 *old_hp_wsp = st->old_hp_wsp; /* hypass wsp[] */
+	Word16 wght_flg = st->ol_wght_flg;   /* is weighting function used */
+
+	ww = &corrweight[198];
+	we = &corrweight[98 + L_max - L_0];
+
+	max = MIN_32;
+	Tm = 0;
+	for (i = L_max; i > L_min; i--)
+	{
+		/* Compute the correlation */
+		R0 = 0;
+		p1 = wsp;
+		p2 = &wsp[-i];
+		for (j = 0; j < L_frame; j+=4)
+		{
+			R0 += vo_L_mult((*p1++), (*p2++));
+			R0 += vo_L_mult((*p1++), (*p2++));
+			R0 += vo_L_mult((*p1++), (*p2++));
+			R0 += vo_L_mult((*p1++), (*p2++));
+		}
+		/* Weighting of the correlation function.   */
+		hi = R0>>16;
+		lo = (R0 & 0xffff)>>1;
+
+		R0 = Mpy_32_16(hi, lo, *ww);
+		ww--;
+
+		if ((L_0 > 0) && (wght_flg > 0))
+		{
+			/* Weight the neighbourhood of the old lag. */
+			hi = R0>>16;
+			lo = (R0 & 0xffff)>>1;
+			R0 = Mpy_32_16(hi, lo, *we);
+			we--;
+		}
+		if(R0 >= max)
+		{
+			max = R0;
+			Tm = i;
+		}
+	}
+
+	/* Hypass the wsp[] vector */
+	hp_wsp = old_hp_wsp + L_max;
+	Hp_wsp(wsp, hp_wsp, L_frame, hp_wsp_mem);
+
+	/* Compute normalize correlation at delay Tm */
+	R0 = 0;
+	R1 = 0;
+	R2 = 0;
+	p1 = hp_wsp;
+	p2 = hp_wsp - Tm;
+	for (j = 0; j < L_frame; j+=4)
+	{
+		R2 += vo_mult32(*p1, *p1);
+		R1 += vo_mult32(*p2, *p2);
+		R0 += vo_mult32(*p1++, *p2++);
+		R2 += vo_mult32(*p1, *p1);
+		R1 += vo_mult32(*p2, *p2);
+		R0 += vo_mult32(*p1++, *p2++);
+		R2 += vo_mult32(*p1, *p1);
+		R1 += vo_mult32(*p2, *p2);
+		R0 += vo_mult32(*p1++, *p2++);
+		R2 += vo_mult32(*p1, *p1);
+		R1 += vo_mult32(*p2, *p2);
+		R0 += vo_mult32(*p1++, *p2++);
+	}
+	R0 = R0 <<1;
+	R1 = (R1 <<1) + 1L;
+	R2 = (R2 <<1) + 1L;
+	/* gain = R0/ sqrt(R1*R2) */
+
+	exp_R0 = norm_l(R0);
+	R0 = (R0 << exp_R0);
+
+	exp_R1 = norm_l(R1);
+	R1 = (R1 << exp_R1);
+
+	exp_R2 = norm_l(R2);
+	R2 = (R2 << exp_R2);
+
+
+	R1 = vo_L_mult(vo_round(R1), vo_round(R2));
+
+	i = norm_l(R1);
+	R1 = (R1 << i);
+
+	exp_R1 += exp_R2;
+	exp_R1 += i;
+	exp_R1 = 62 - exp_R1;
+
+	Isqrt_n(&R1, &exp_R1);
+
+	R0 = vo_L_mult(voround(R0), voround(R1));
+	exp_R0 = 31 - exp_R0;
+	exp_R0 += exp_R1;
+
+	*gain = vo_round(L_shl(R0, exp_R0));
+
+	/* Shitf hp_wsp[] for next frame */
+
+	for (i = 0; i < L_max; i++)
+	{
+		old_hp_wsp[i] = old_hp_wsp[i + L_frame];
+	}
+
+	return (Tm);
+}
+
+/************************************************************************
+*  Function: median5                                                    *
+*                                                                       *
+*      Returns the median of the set {X[-2], X[-1],..., X[2]},          *
+*      whose elements are 16-bit integers.                              *
+*                                                                       *
+*  Input:                                                               *
+*      X[-2:2]   16-bit integers.                                       *
+*                                                                       *
+*  Return:                                                              *
+*      The median of {X[-2], X[-1],..., X[2]}.                          *
+************************************************************************/
+
+Word16 median5(Word16 x[])
+{
+	Word16 x1, x2, x3, x4, x5;
+	Word16 tmp;
+
+	x1 = x[-2];
+	x2 = x[-1];
+	x3 = x[0];
+	x4 = x[1];
+	x5 = x[2];
+
+	if (x2 < x1)
+	{
+		tmp = x1;
+		x1 = x2;
+		x2 = tmp;
+	}
+	if (x3 < x1)
+	{
+		tmp = x1;
+		x1 = x3;
+		x3 = tmp;
+	}
+	if (x4 < x1)
+	{
+		tmp = x1;
+		x1 = x4;
+		x4 = tmp;
+	}
+	if (x5 < x1)
+	{
+		x5 = x1;
+	}
+	if (x3 < x2)
+	{
+		tmp = x2;
+		x2 = x3;
+		x3 = tmp;
+	}
+	if (x4 < x2)
+	{
+		tmp = x2;
+		x2 = x4;
+		x4 = tmp;
+	}
+	if (x5 < x2)
+	{
+		x5 = x2;
+	}
+	if (x4 < x3)
+	{
+		x3 = x4;
+	}
+	if (x5 < x3)
+	{
+		x3 = x5;
+	}
+	return (x3);
+}
+
+
+Word16 Med_olag(                           /* output : median of  5 previous open-loop lags       */
+		Word16 prev_ol_lag,                /* input  : previous open-loop lag                     */
+		Word16 old_ol_lag[5]
+	       )
+{
+	Word32 i;
+
+	/* Use median of 5 previous open-loop lags as old lag */
+
+	for (i = 4; i > 0; i--)
+	{
+		old_ol_lag[i] = old_ol_lag[i - 1];
+	}
+
+	old_ol_lag[0] = prev_ol_lag;
+
+	i = median5(&old_ol_lag[2]);
+
+	return i;
+
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/pit_shrp.c b/media/libstagefright/codecs/amrwbenc/src/pit_shrp.c
index c8a227c..6f55b8f 100644
--- a/media/libstagefright/codecs/amrwbenc/src/pit_shrp.c
+++ b/media/libstagefright/codecs/amrwbenc/src/pit_shrp.c
@@ -1,49 +1,49 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: pit_shrp.c                                                *
-*                                                                      *
-*      Description: Performs Pitch sharpening routine                  *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-void Pit_shrp(
-		Word16 * x,                           /* in/out: impulse response (or algebraic code) */
-		Word16 pit_lag,                       /* input : pitch lag                            */
-		Word16 sharp,                         /* input : pitch sharpening factor (Q15)        */
-		Word16 L_subfr                        /* input : subframe size                        */
-	     )
-{
-	Word32 i;
-	Word32 L_tmp;
-	Word16 *x_ptr = x + pit_lag;
-
-	for (i = pit_lag; i < L_subfr; i++)
-	{
-		L_tmp = (*x_ptr << 15);
-		L_tmp += *x++ * sharp;
-		*x_ptr++ = ((L_tmp + 0x4000)>>15);
-	}
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: pit_shrp.c                                                *
+*                                                                      *
+*      Description: Performs Pitch sharpening routine                  *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+void Pit_shrp(
+		Word16 * x,                           /* in/out: impulse response (or algebraic code) */
+		Word16 pit_lag,                       /* input : pitch lag                            */
+		Word16 sharp,                         /* input : pitch sharpening factor (Q15)        */
+		Word16 L_subfr                        /* input : subframe size                        */
+	     )
+{
+	Word32 i;
+	Word32 L_tmp;
+	Word16 *x_ptr = x + pit_lag;
+
+	for (i = pit_lag; i < L_subfr; i++)
+	{
+		L_tmp = (*x_ptr << 15);
+		L_tmp += *x++ * sharp;
+		*x_ptr++ = ((L_tmp + 0x4000)>>15);
+	}
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/pitch_f4.c b/media/libstagefright/codecs/amrwbenc/src/pitch_f4.c
index c115b11..0d66c31 100644
--- a/media/libstagefright/codecs/amrwbenc/src/pitch_f4.c
+++ b/media/libstagefright/codecs/amrwbenc/src/pitch_f4.c
@@ -1,324 +1,324 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: pitch_f4.c                                                *
-*                                                                      *
-*      Description: Find the closed loop pitch period with             *
-*	            1/4 subsample resolution.                          *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-#include "acelp.h"
-#include "cnst.h"
-
-#define UP_SAMP      4
-#define L_INTERPOL1  4
-
-/* Local functions */
-
-#ifdef ASM_OPT
-void Norm_corr_asm(
-		Word16 exc[],                         /* (i)     : excitation buffer                     */
-		Word16 xn[],                          /* (i)     : target vector                         */
-		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
-		Word16 L_subfr,
-		Word16 t_min,                         /* (i)     : minimum value of pitch lag.           */
-		Word16 t_max,                         /* (i)     : maximum value of pitch lag.           */
-		Word16 corr_norm[]                    /* (o) Q15 : normalized correlation                */
-		);
-#else
-static void Norm_Corr(
-		Word16 exc[],                         /* (i)     : excitation buffer                     */
-		Word16 xn[],                          /* (i)     : target vector                         */
-		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
-		Word16 L_subfr,
-		Word16 t_min,                         /* (i)     : minimum value of pitch lag.           */
-		Word16 t_max,                         /* (i)     : maximum value of pitch lag.           */
-		Word16 corr_norm[]                    /* (o) Q15 : normalized correlation                */
-		);
-#endif
-
-static Word16 Interpol_4(                  /* (o)  : interpolated value  */
-		Word16 * x,                           /* (i)  : input vector        */
-		Word32 frac                           /* (i)  : fraction (-4..+3)   */
-		);
-
-
-Word16 Pitch_fr4(                          /* (o)     : pitch period.                         */
-		Word16 exc[],                         /* (i)     : excitation buffer                     */
-		Word16 xn[],                          /* (i)     : target vector                         */
-		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
-		Word16 t0_min,                        /* (i)     : minimum value in the searched range.  */
-		Word16 t0_max,                        /* (i)     : maximum value in the searched range.  */
-		Word16 * pit_frac,                    /* (o)     : chosen fraction (0, 1, 2 or 3).       */
-		Word16 i_subfr,                       /* (i)     : indicator for first subframe.         */
-		Word16 t0_fr2,                        /* (i)     : minimum value for resolution 1/2      */
-		Word16 t0_fr1,                        /* (i)     : minimum value for resolution 1        */
-		Word16 L_subfr                        /* (i)     : Length of subframe                    */
-		)
-{
-	Word32 fraction, i;
-	Word16 t_min, t_max;
-	Word16 max, t0, step, temp;
-	Word16 *corr;
-	Word16 corr_v[40];                     /* Total length = t0_max-t0_min+1+2*L_inter */
-
-	/* Find interval to compute normalized correlation */
-
-	t_min = t0_min - L_INTERPOL1;
-	t_max = t0_max + L_INTERPOL1;
-	corr = &corr_v[-t_min];
-	/* Compute normalized correlation between target and filtered excitation */
-#ifdef ASM_OPT               /* asm optimization branch */
-    Norm_corr_asm(exc, xn, h, L_subfr, t_min, t_max, corr);
-#else
-	Norm_Corr(exc, xn, h, L_subfr, t_min, t_max, corr);
-#endif 
-
-	/* Find integer pitch */
-
-	max = corr[t0_min];
-	t0 = t0_min;
-	for (i = t0_min + 1; i <= t0_max; i++)
-	{
-		if (corr[i] >= max)
-		{
-			max = corr[i];                 
-			t0 = i;                        
-		}
-	}
-	/* If first subframe and t0 >= t0_fr1, do not search fractionnal pitch */
-	if ((i_subfr == 0) && (t0 >= t0_fr1))
-	{
-		*pit_frac = 0;
-		return (t0);
-	}
-	/*------------------------------------------------------------------*
-	 * Search fractionnal pitch with 1/4 subsample resolution.          *
-	 * Test the fractions around t0 and choose the one which maximizes  *
-	 * the interpolated normalized correlation.                         *
-	 *------------------------------------------------------------------*/
-
-	step = 1;               /* 1/4 subsample resolution */
-	fraction = -3;
-	if ((t0_fr2 == PIT_MIN)||((i_subfr == 0) && (t0 >= t0_fr2)))
-	{
-		step = 2;              /* 1/2 subsample resolution */
-		fraction = -2;
-	}
-	if(t0 == t0_min)
-	{
-		fraction = 0;
-	}
-	max = Interpol_4(&corr[t0], fraction);
-
-	for (i = fraction + step; i <= 3; i += step)
-	{
-		temp = Interpol_4(&corr[t0], i);
-		if(temp > max)
-		{
-			max = temp;
-			fraction = i;
-		}
-	}
-	/* limit the fraction value in the interval [0,1,2,3] */
-	if (fraction < 0)
-	{
-		fraction += UP_SAMP;
-		t0 -= 1;
-	}
-	*pit_frac = fraction;
-	return (t0);
-}
-
-
-/***********************************************************************************
-* Function:  Norm_Corr()                                                            *
-*                                                                                   *
-* Description: Find the normalized correlation between the target vector and the    *
-* filtered past excitation.                                                         *
-* (correlation between target and filtered excitation divided by the                *
-*  square root of energy of target and filtered excitation).                        *
-************************************************************************************/
-#ifndef ASM_OPT
-static void Norm_Corr(
-		Word16 exc[],                         /* (i)     : excitation buffer                     */
-		Word16 xn[],                          /* (i)     : target vector                         */
-		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
-		Word16 L_subfr,
-		Word16 t_min,                         /* (i)     : minimum value of pitch lag.           */
-		Word16 t_max,                         /* (i)     : maximum value of pitch lag.           */
-		Word16 corr_norm[])                   /* (o) Q15 : normalized correlation                */
-{
-	Word32 i, k, t;
-	Word32 corr, exp_corr, norm, exp, scale;
-	Word16 exp_norm, excf[L_SUBFR], tmp;
-	Word32 L_tmp, L_tmp1, L_tmp2;
-
-	/* compute the filtered excitation for the first delay t_min */
-	k = -t_min;
-
-#ifdef ASM_OPT              /* asm optimization branch */
-	Convolve_asm(&exc[k], h, excf, 64);
-#else
-	Convolve(&exc[k], h, excf, 64);
-#endif
-
-	/* Compute rounded down 1/sqrt(energy of xn[]) */
-	L_tmp = 0; 
-	for (i = 0; i < 64; i+=4)
-	{
-		L_tmp += (xn[i] * xn[i]);
-		L_tmp += (xn[i+1] * xn[i+1]);
-		L_tmp += (xn[i+2] * xn[i+2]);
-		L_tmp += (xn[i+3] * xn[i+3]);
-	}
-
-	L_tmp = (L_tmp << 1) + 1;
-	exp = norm_l(L_tmp);
-	exp = (32 - exp);
-	//exp = exp + 2;                     /* energy of xn[] x 2 + rounded up     */
-	scale = -(exp >> 1);           /* (1<<scale) < 1/sqrt(energy rounded) */
-
-	/* loop for every possible period */
-
-	for (t = t_min; t <= t_max; t++)
-	{
-		/* Compute correlation between xn[] and excf[] */
-		L_tmp  = 0;  
-		L_tmp1 = 0;
-		for (i = 0; i < 64; i+=4)
-		{
-			L_tmp  += (xn[i] * excf[i]);
-			L_tmp1 += (excf[i] * excf[i]);
-			L_tmp  += (xn[i+1] * excf[i+1]);
-			L_tmp1 += (excf[i+1] * excf[i+1]);
-			L_tmp  += (xn[i+2] * excf[i+2]);
-			L_tmp1 += (excf[i+2] * excf[i+2]);
-			L_tmp  += (xn[i+3] * excf[i+3]);
-			L_tmp1 += (excf[i+3] * excf[i+3]);
-		}
-
-		L_tmp = (L_tmp << 1) + 1;
-		L_tmp1 = (L_tmp1 << 1) + 1;
-
-		exp = norm_l(L_tmp);
-		L_tmp = (L_tmp << exp);
-		exp_corr = (30 - exp);
-		corr = extract_h(L_tmp);
-
-		exp = norm_l(L_tmp1);
-		L_tmp = (L_tmp1 << exp);
-		exp_norm = (30 - exp);
-
-		Isqrt_n(&L_tmp, &exp_norm);
-		norm = extract_h(L_tmp);
-
-		/* Normalize correlation = correlation * (1/sqrt(energy)) */
-
-		L_tmp = vo_L_mult(corr, norm);
-
-		L_tmp2 = exp_corr + exp_norm + scale;
-		if(L_tmp2 < 0)
-		{
-			L_tmp2 = -L_tmp2;
-			L_tmp = L_tmp >> L_tmp2;
-		}
-		else
-		{
-			L_tmp = L_tmp << L_tmp2;
-		}
-
-		corr_norm[t] = vo_round(L_tmp);      
-		/* modify the filtered excitation excf[] for the next iteration */
-
-		if(t != t_max)
-		{
-			k = -(t + 1);
-			tmp = exc[k];
-			for (i = 63; i > 0; i--)
-			{
-				excf[i] = add1(vo_mult(tmp, h[i]), excf[i - 1]);
-			}
-			excf[0] = vo_mult(tmp, h[0]);
-		}
-	}
-	return;
-}
-
-#endif
-/************************************************************************************
-* Function: Interpol_4()                                                             *
-*                                                                                    *
-* Description: For interpolating the normalized correlation with 1/4 resolution.     *
-**************************************************************************************/
-
-/* 1/4 resolution interpolation filter (-3 dB at 0.791*fs/2) in Q14 */
-static Word16 inter4_1[4][8] =
-{
-	{-12, 420, -1732, 5429, 13418, -1242, 73, 32},
-	{-26, 455, -2142, 9910, 9910,  -2142, 455, -26},
-	{32,  73, -1242, 13418, 5429, -1732, 420, -12},
-	{206, -766, 1376, 14746, 1376, -766, 206, 0}
-};
-
-/*** Coefficients in floating point
-static float inter4_1[UP_SAMP*L_INTERPOL1+1] = {
-0.900000,
-0.818959,  0.604850,  0.331379,  0.083958,
--0.075795, -0.130717, -0.105685, -0.046774,
-0.004467,  0.027789,  0.025642,  0.012571,
-0.001927, -0.001571, -0.000753,  0.000000};
-***/
-
-static Word16 Interpol_4(                  /* (o)  : interpolated value  */
-		Word16 * x,                           /* (i)  : input vector        */
-		Word32 frac                           /* (i)  : fraction (-4..+3)   */
-		)
-{
-	Word16 sum;
-	Word32  k, L_sum;
-	Word16 *ptr;
-
-	if (frac < 0)
-	{
-		frac += UP_SAMP;
-		x--;
-	}
-	x = x - L_INTERPOL1 + 1;
-	k = UP_SAMP - 1 - frac;
-	ptr = &(inter4_1[k][0]);
-
-	L_sum  = vo_mult32(x[0], (*ptr++));
-	L_sum += vo_mult32(x[1], (*ptr++));
-	L_sum += vo_mult32(x[2], (*ptr++));
-	L_sum += vo_mult32(x[3], (*ptr++));
-	L_sum += vo_mult32(x[4], (*ptr++));  
-	L_sum += vo_mult32(x[5], (*ptr++));
-	L_sum += vo_mult32(x[6], (*ptr++));
-	L_sum += vo_mult32(x[7], (*ptr++));   
-
-	sum = extract_h(L_add(L_shl2(L_sum, 2), 0x8000));
-	return (sum);
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: pitch_f4.c                                                *
+*                                                                      *
+*      Description: Find the closed loop pitch period with             *
+*	            1/4 subsample resolution.                          *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+#include "acelp.h"
+#include "cnst.h"
+
+#define UP_SAMP      4
+#define L_INTERPOL1  4
+
+/* Local functions */
+
+#ifdef ASM_OPT
+void Norm_corr_asm(
+		Word16 exc[],                         /* (i)     : excitation buffer                     */
+		Word16 xn[],                          /* (i)     : target vector                         */
+		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
+		Word16 L_subfr,
+		Word16 t_min,                         /* (i)     : minimum value of pitch lag.           */
+		Word16 t_max,                         /* (i)     : maximum value of pitch lag.           */
+		Word16 corr_norm[]                    /* (o) Q15 : normalized correlation                */
+		);
+#else
+static void Norm_Corr(
+		Word16 exc[],                         /* (i)     : excitation buffer                     */
+		Word16 xn[],                          /* (i)     : target vector                         */
+		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
+		Word16 L_subfr,
+		Word16 t_min,                         /* (i)     : minimum value of pitch lag.           */
+		Word16 t_max,                         /* (i)     : maximum value of pitch lag.           */
+		Word16 corr_norm[]                    /* (o) Q15 : normalized correlation                */
+		);
+#endif
+
+static Word16 Interpol_4(                  /* (o)  : interpolated value  */
+		Word16 * x,                           /* (i)  : input vector        */
+		Word32 frac                           /* (i)  : fraction (-4..+3)   */
+		);
+
+
+Word16 Pitch_fr4(                          /* (o)     : pitch period.                         */
+		Word16 exc[],                         /* (i)     : excitation buffer                     */
+		Word16 xn[],                          /* (i)     : target vector                         */
+		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
+		Word16 t0_min,                        /* (i)     : minimum value in the searched range.  */
+		Word16 t0_max,                        /* (i)     : maximum value in the searched range.  */
+		Word16 * pit_frac,                    /* (o)     : chosen fraction (0, 1, 2 or 3).       */
+		Word16 i_subfr,                       /* (i)     : indicator for first subframe.         */
+		Word16 t0_fr2,                        /* (i)     : minimum value for resolution 1/2      */
+		Word16 t0_fr1,                        /* (i)     : minimum value for resolution 1        */
+		Word16 L_subfr                        /* (i)     : Length of subframe                    */
+		)
+{
+	Word32 fraction, i;
+	Word16 t_min, t_max;
+	Word16 max, t0, step, temp;
+	Word16 *corr;
+	Word16 corr_v[40];                     /* Total length = t0_max-t0_min+1+2*L_inter */
+
+	/* Find interval to compute normalized correlation */
+
+	t_min = t0_min - L_INTERPOL1;
+	t_max = t0_max + L_INTERPOL1;
+	corr = &corr_v[-t_min];
+	/* Compute normalized correlation between target and filtered excitation */
+#ifdef ASM_OPT               /* asm optimization branch */
+    Norm_corr_asm(exc, xn, h, L_subfr, t_min, t_max, corr);
+#else
+	Norm_Corr(exc, xn, h, L_subfr, t_min, t_max, corr);
+#endif
+
+	/* Find integer pitch */
+
+	max = corr[t0_min];
+	t0 = t0_min;
+	for (i = t0_min + 1; i <= t0_max; i++)
+	{
+		if (corr[i] >= max)
+		{
+			max = corr[i];
+			t0 = i;
+		}
+	}
+	/* If first subframe and t0 >= t0_fr1, do not search fractionnal pitch */
+	if ((i_subfr == 0) && (t0 >= t0_fr1))
+	{
+		*pit_frac = 0;
+		return (t0);
+	}
+	/*------------------------------------------------------------------*
+	 * Search fractionnal pitch with 1/4 subsample resolution.          *
+	 * Test the fractions around t0 and choose the one which maximizes  *
+	 * the interpolated normalized correlation.                         *
+	 *------------------------------------------------------------------*/
+
+	step = 1;               /* 1/4 subsample resolution */
+	fraction = -3;
+	if ((t0_fr2 == PIT_MIN)||((i_subfr == 0) && (t0 >= t0_fr2)))
+	{
+		step = 2;              /* 1/2 subsample resolution */
+		fraction = -2;
+	}
+	if(t0 == t0_min)
+	{
+		fraction = 0;
+	}
+	max = Interpol_4(&corr[t0], fraction);
+
+	for (i = fraction + step; i <= 3; i += step)
+	{
+		temp = Interpol_4(&corr[t0], i);
+		if(temp > max)
+		{
+			max = temp;
+			fraction = i;
+		}
+	}
+	/* limit the fraction value in the interval [0,1,2,3] */
+	if (fraction < 0)
+	{
+		fraction += UP_SAMP;
+		t0 -= 1;
+	}
+	*pit_frac = fraction;
+	return (t0);
+}
+
+
+/***********************************************************************************
+* Function:  Norm_Corr()                                                            *
+*                                                                                   *
+* Description: Find the normalized correlation between the target vector and the    *
+* filtered past excitation.                                                         *
+* (correlation between target and filtered excitation divided by the                *
+*  square root of energy of target and filtered excitation).                        *
+************************************************************************************/
+#ifndef ASM_OPT
+static void Norm_Corr(
+		Word16 exc[],                         /* (i)     : excitation buffer                     */
+		Word16 xn[],                          /* (i)     : target vector                         */
+		Word16 h[],                           /* (i) Q15 : impulse response of synth/wgt filters */
+		Word16 L_subfr,
+		Word16 t_min,                         /* (i)     : minimum value of pitch lag.           */
+		Word16 t_max,                         /* (i)     : maximum value of pitch lag.           */
+		Word16 corr_norm[])                   /* (o) Q15 : normalized correlation                */
+{
+	Word32 i, k, t;
+	Word32 corr, exp_corr, norm, exp, scale;
+	Word16 exp_norm, excf[L_SUBFR], tmp;
+	Word32 L_tmp, L_tmp1, L_tmp2;
+
+	/* compute the filtered excitation for the first delay t_min */
+	k = -t_min;
+
+#ifdef ASM_OPT              /* asm optimization branch */
+	Convolve_asm(&exc[k], h, excf, 64);
+#else
+	Convolve(&exc[k], h, excf, 64);
+#endif
+
+	/* Compute rounded down 1/sqrt(energy of xn[]) */
+	L_tmp = 0;
+	for (i = 0; i < 64; i+=4)
+	{
+		L_tmp += (xn[i] * xn[i]);
+		L_tmp += (xn[i+1] * xn[i+1]);
+		L_tmp += (xn[i+2] * xn[i+2]);
+		L_tmp += (xn[i+3] * xn[i+3]);
+	}
+
+	L_tmp = (L_tmp << 1) + 1;
+	exp = norm_l(L_tmp);
+	exp = (32 - exp);
+	//exp = exp + 2;                     /* energy of xn[] x 2 + rounded up     */
+	scale = -(exp >> 1);           /* (1<<scale) < 1/sqrt(energy rounded) */
+
+	/* loop for every possible period */
+
+	for (t = t_min; t <= t_max; t++)
+	{
+		/* Compute correlation between xn[] and excf[] */
+		L_tmp  = 0;
+		L_tmp1 = 0;
+		for (i = 0; i < 64; i+=4)
+		{
+			L_tmp  += (xn[i] * excf[i]);
+			L_tmp1 += (excf[i] * excf[i]);
+			L_tmp  += (xn[i+1] * excf[i+1]);
+			L_tmp1 += (excf[i+1] * excf[i+1]);
+			L_tmp  += (xn[i+2] * excf[i+2]);
+			L_tmp1 += (excf[i+2] * excf[i+2]);
+			L_tmp  += (xn[i+3] * excf[i+3]);
+			L_tmp1 += (excf[i+3] * excf[i+3]);
+		}
+
+		L_tmp = (L_tmp << 1) + 1;
+		L_tmp1 = (L_tmp1 << 1) + 1;
+
+		exp = norm_l(L_tmp);
+		L_tmp = (L_tmp << exp);
+		exp_corr = (30 - exp);
+		corr = extract_h(L_tmp);
+
+		exp = norm_l(L_tmp1);
+		L_tmp = (L_tmp1 << exp);
+		exp_norm = (30 - exp);
+
+		Isqrt_n(&L_tmp, &exp_norm);
+		norm = extract_h(L_tmp);
+
+		/* Normalize correlation = correlation * (1/sqrt(energy)) */
+
+		L_tmp = vo_L_mult(corr, norm);
+
+		L_tmp2 = exp_corr + exp_norm + scale;
+		if(L_tmp2 < 0)
+		{
+			L_tmp2 = -L_tmp2;
+			L_tmp = L_tmp >> L_tmp2;
+		}
+		else
+		{
+			L_tmp = L_tmp << L_tmp2;
+		}
+
+		corr_norm[t] = vo_round(L_tmp);
+		/* modify the filtered excitation excf[] for the next iteration */
+
+		if(t != t_max)
+		{
+			k = -(t + 1);
+			tmp = exc[k];
+			for (i = 63; i > 0; i--)
+			{
+				excf[i] = add1(vo_mult(tmp, h[i]), excf[i - 1]);
+			}
+			excf[0] = vo_mult(tmp, h[0]);
+		}
+	}
+	return;
+}
+
+#endif
+/************************************************************************************
+* Function: Interpol_4()                                                             *
+*                                                                                    *
+* Description: For interpolating the normalized correlation with 1/4 resolution.     *
+**************************************************************************************/
+
+/* 1/4 resolution interpolation filter (-3 dB at 0.791*fs/2) in Q14 */
+static Word16 inter4_1[4][8] =
+{
+	{-12, 420, -1732, 5429, 13418, -1242, 73, 32},
+	{-26, 455, -2142, 9910, 9910,  -2142, 455, -26},
+	{32,  73, -1242, 13418, 5429, -1732, 420, -12},
+	{206, -766, 1376, 14746, 1376, -766, 206, 0}
+};
+
+/*** Coefficients in floating point
+static float inter4_1[UP_SAMP*L_INTERPOL1+1] = {
+0.900000,
+0.818959,  0.604850,  0.331379,  0.083958,
+-0.075795, -0.130717, -0.105685, -0.046774,
+0.004467,  0.027789,  0.025642,  0.012571,
+0.001927, -0.001571, -0.000753,  0.000000};
+***/
+
+static Word16 Interpol_4(                  /* (o)  : interpolated value  */
+		Word16 * x,                           /* (i)  : input vector        */
+		Word32 frac                           /* (i)  : fraction (-4..+3)   */
+		)
+{
+	Word16 sum;
+	Word32  k, L_sum;
+	Word16 *ptr;
+
+	if (frac < 0)
+	{
+		frac += UP_SAMP;
+		x--;
+	}
+	x = x - L_INTERPOL1 + 1;
+	k = UP_SAMP - 1 - frac;
+	ptr = &(inter4_1[k][0]);
+
+	L_sum  = vo_mult32(x[0], (*ptr++));
+	L_sum += vo_mult32(x[1], (*ptr++));
+	L_sum += vo_mult32(x[2], (*ptr++));
+	L_sum += vo_mult32(x[3], (*ptr++));
+	L_sum += vo_mult32(x[4], (*ptr++));
+	L_sum += vo_mult32(x[5], (*ptr++));
+	L_sum += vo_mult32(x[6], (*ptr++));
+	L_sum += vo_mult32(x[7], (*ptr++));
+
+	sum = extract_h(L_add(L_shl2(L_sum, 2), 0x8000));
+	return (sum);
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/pred_lt4.c b/media/libstagefright/codecs/amrwbenc/src/pred_lt4.c
index ac1ff22..8404cf9 100644
--- a/media/libstagefright/codecs/amrwbenc/src/pred_lt4.c
+++ b/media/libstagefright/codecs/amrwbenc/src/pred_lt4.c
@@ -1,120 +1,120 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: pred_lt4.c                                                *
-*                                                                      *
-*      Description: Compute the result of long term prediction with    *
-*      fractional interpolation of resolution 1/4                      *
-*      on return exc[0..L_subr-1] contains the interpolated signal     *
-*      (adaptive codebook excitation)                                  *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-#define UP_SAMP      4
-#define L_INTERPOL2  16
-
-/* 1/4 resolution interpolation filter (-3 dB at 0.856*fs/2) in Q14 */
-
-Word16 inter4_2[4][32] =
-{
-	{0,-2,4,-2,-10,38,-88,165,-275,424,-619,871,-1207,1699,-2598,5531,14031,-2147,780,-249,
-	-16,153,-213,226,-209,175,-133,91,-55,28,-10,2},
-
-	{1,-7,19,-33,47,-52,43,-9,-60,175,-355,626,-1044,1749,-3267,10359,10359,-3267,1749,-1044,
-	626,-355,175,-60,-9,43,-52,47,-33,19, -7, 1},
-
-	{2,-10,28,-55,91,-133,175,-209,226,-213,153,-16,-249,780,-2147,14031,5531,-2598,1699,-1207,
-	871,-619,424,-275,165,-88,38,-10,-2,4,-2,0},
-
-	{1,-7,22,-49,92,-153,231,-325,431,-544,656,-762,853,-923,968,15401,968,-923,853,-762,
-	656,-544,431,-325,231,-153,92,-49,22,-7, 1, 0}
-
-};
-
-void Pred_lt4(
-		Word16 exc[],                         /* in/out: excitation buffer */
-		Word16 T0,                            /* input : integer pitch lag */
-		Word16 frac,                          /* input : fraction of lag   */
-		Word16 L_subfr                        /* input : subframe size     */
-	     )
-{
-	Word16 j, k, *x;
-	Word32 L_sum;
-	Word16 *ptr, *ptr1;
-	Word16 *ptr2;
-
-	x = exc - T0;   
-	frac = -frac;
-	if (frac < 0)
-	{
-		frac += UP_SAMP;
-		x--;
-	}   
-	x -= 15;                                     /* x = L_INTERPOL2 - 1 */
-	k = 3 - frac;                                /* k = UP_SAMP - 1 - frac */
-
-	ptr2 = &(inter4_2[k][0]);
-	for (j = 0; j < L_subfr; j++)
-	{
-		ptr = ptr2;
-		ptr1 = x;
-		L_sum  = vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-		L_sum += vo_mult32((*ptr1++), (*ptr++));
-
-		L_sum = L_shl2(L_sum, 2);
-		exc[j] = extract_h(L_add(L_sum, 0x8000));
-		x++;
-	}
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: pred_lt4.c                                                *
+*                                                                      *
+*      Description: Compute the result of long term prediction with    *
+*      fractional interpolation of resolution 1/4                      *
+*      on return exc[0..L_subr-1] contains the interpolated signal     *
+*      (adaptive codebook excitation)                                  *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+#define UP_SAMP      4
+#define L_INTERPOL2  16
+
+/* 1/4 resolution interpolation filter (-3 dB at 0.856*fs/2) in Q14 */
+
+Word16 inter4_2[4][32] =
+{
+	{0,-2,4,-2,-10,38,-88,165,-275,424,-619,871,-1207,1699,-2598,5531,14031,-2147,780,-249,
+	-16,153,-213,226,-209,175,-133,91,-55,28,-10,2},
+
+	{1,-7,19,-33,47,-52,43,-9,-60,175,-355,626,-1044,1749,-3267,10359,10359,-3267,1749,-1044,
+	626,-355,175,-60,-9,43,-52,47,-33,19, -7, 1},
+
+	{2,-10,28,-55,91,-133,175,-209,226,-213,153,-16,-249,780,-2147,14031,5531,-2598,1699,-1207,
+	871,-619,424,-275,165,-88,38,-10,-2,4,-2,0},
+
+	{1,-7,22,-49,92,-153,231,-325,431,-544,656,-762,853,-923,968,15401,968,-923,853,-762,
+	656,-544,431,-325,231,-153,92,-49,22,-7, 1, 0}
+
+};
+
+void Pred_lt4(
+		Word16 exc[],                         /* in/out: excitation buffer */
+		Word16 T0,                            /* input : integer pitch lag */
+		Word16 frac,                          /* input : fraction of lag   */
+		Word16 L_subfr                        /* input : subframe size     */
+	     )
+{
+	Word16 j, k, *x;
+	Word32 L_sum;
+	Word16 *ptr, *ptr1;
+	Word16 *ptr2;
+
+	x = exc - T0;
+	frac = -frac;
+	if (frac < 0)
+	{
+		frac += UP_SAMP;
+		x--;
+	}
+	x -= 15;                                     /* x = L_INTERPOL2 - 1 */
+	k = 3 - frac;                                /* k = UP_SAMP - 1 - frac */
+
+	ptr2 = &(inter4_2[k][0]);
+	for (j = 0; j < L_subfr; j++)
+	{
+		ptr = ptr2;
+		ptr1 = x;
+		L_sum  = vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+		L_sum += vo_mult32((*ptr1++), (*ptr++));
+
+		L_sum = L_shl2(L_sum, 2);
+		exc[j] = extract_h(L_add(L_sum, 0x8000));
+		x++;
+	}
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/preemph.c b/media/libstagefright/codecs/amrwbenc/src/preemph.c
index f5bcd33..c867bf7 100644
--- a/media/libstagefright/codecs/amrwbenc/src/preemph.c
+++ b/media/libstagefright/codecs/amrwbenc/src/preemph.c
@@ -1,88 +1,88 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: preemph.c                                                *
-*                                                                     *
-*      Description: Preemphasis: filtering through 1 - g z^-1         *
-*	           Preemph2 --> signal is multiplied by 2             *
-*                                                                     *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-void Preemph(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
-		Word16 lg,                            /* (i)     : lenght of filtering                    */
-		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
-	    )
-{
-	Word16 temp;
-	Word32 i, L_tmp;
-
-	temp = x[lg - 1];                     
-
-	for (i = lg - 1; i > 0; i--)
-	{
-		L_tmp = L_deposit_h(x[i]);
-		L_tmp -= (x[i - 1] * mu)<<1;
-		x[i] = (L_tmp + 0x8000)>>16;               
-	}
-
-	L_tmp = L_deposit_h(x[0]);
-	L_tmp -= ((*mem) * mu)<<1;
-	x[0] = (L_tmp + 0x8000)>>16;                   
-
-	*mem = temp;                           
-
-	return;
-}
-
-
-void Preemph2(
-		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
-		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
-		Word16 lg,                            /* (i)     : lenght of filtering                    */
-		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
-	     )
-{
-	Word16 temp;
-	Word32 i, L_tmp;
-
-	temp = x[lg - 1];                     
-
-	for (i = (Word16) (lg - 1); i > 0; i--)
-	{
-		L_tmp = L_deposit_h(x[i]);
-		L_tmp -= (x[i - 1] * mu)<<1;
-		L_tmp = (L_tmp << 1);
-		x[i] = (L_tmp + 0x8000)>>16;               
-	}
-
-	L_tmp = L_deposit_h(x[0]);
-	L_tmp -= ((*mem) * mu)<<1;
-	L_tmp = (L_tmp << 1);
-	x[0] = (L_tmp + 0x8000)>>16;                   
-
-	*mem = temp;                           
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: preemph.c                                                *
+*                                                                     *
+*      Description: Preemphasis: filtering through 1 - g z^-1         *
+*	           Preemph2 --> signal is multiplied by 2             *
+*                                                                     *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+void Preemph(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
+		Word16 lg,                            /* (i)     : lenght of filtering                    */
+		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
+	    )
+{
+	Word16 temp;
+	Word32 i, L_tmp;
+
+	temp = x[lg - 1];
+
+	for (i = lg - 1; i > 0; i--)
+	{
+		L_tmp = L_deposit_h(x[i]);
+		L_tmp -= (x[i - 1] * mu)<<1;
+		x[i] = (L_tmp + 0x8000)>>16;
+	}
+
+	L_tmp = L_deposit_h(x[0]);
+	L_tmp -= ((*mem) * mu)<<1;
+	x[0] = (L_tmp + 0x8000)>>16;
+
+	*mem = temp;
+
+	return;
+}
+
+
+void Preemph2(
+		Word16 x[],                           /* (i/o)   : input signal overwritten by the output */
+		Word16 mu,                            /* (i) Q15 : preemphasis coefficient                */
+		Word16 lg,                            /* (i)     : lenght of filtering                    */
+		Word16 * mem                          /* (i/o)   : memory (x[-1])                         */
+	     )
+{
+	Word16 temp;
+	Word32 i, L_tmp;
+
+	temp = x[lg - 1];
+
+	for (i = (Word16) (lg - 1); i > 0; i--)
+	{
+		L_tmp = L_deposit_h(x[i]);
+		L_tmp -= (x[i - 1] * mu)<<1;
+		L_tmp = (L_tmp << 1);
+		x[i] = (L_tmp + 0x8000)>>16;
+	}
+
+	L_tmp = L_deposit_h(x[0]);
+	L_tmp -= ((*mem) * mu)<<1;
+	L_tmp = (L_tmp << 1);
+	x[0] = (L_tmp + 0x8000)>>16;
+
+	*mem = temp;
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/q_gain2.c b/media/libstagefright/codecs/amrwbenc/src/q_gain2.c
index 59eefe4..e8ca043 100644
--- a/media/libstagefright/codecs/amrwbenc/src/q_gain2.c
+++ b/media/libstagefright/codecs/amrwbenc/src/q_gain2.c
@@ -1,346 +1,346 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/**************************************************************************
-*  File: q_gain2.c                                                         *
-*                                                                          *
-*  Description:                                                            *
-* Quantization of pitch and codebook gains.                                *
-* MA prediction is performed on the innovation energy (in dB with mean     *
-* removed).                                                                *
-* An initial predicted gain, g_0, is first determined and the correction   *
-* factor     alpha = gain / g_0    is quantized.                           *
-* The pitch gain and the correction factor are vector quantized and the    *
-* mean-squared weighted error criterion is used in the quantizer search.   *
-****************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "math_op.h"
-#include "log2.h"
-#include "acelp.h"
-#include "q_gain2.tab"
-
-#define MEAN_ENER    30
-#define RANGE        64
-#define PRED_ORDER   4
-
-
-/* MA prediction coeff ={0.5, 0.4, 0.3, 0.2} in Q13 */
-static Word16 pred[PRED_ORDER] = {4096, 3277, 2458, 1638};
-
-
-void Init_Q_gain2(
-		Word16 * mem                          /* output  :static memory (2 words)      */
-		)
-{
-	Word32 i;
-
-	/* 4nd order quantizer energy predictor (init to -14.0 in Q10) */
-	for (i = 0; i < PRED_ORDER; i++)
-	{
-		mem[i] = -14336;                     /* past_qua_en[i] */
-	}
-
-	return;
-}
-
-Word16 Q_gain2(                            /* Return index of quantization.          */
-		Word16 xn[],                          /* (i) Q_xn: Target vector.               */
-		Word16 y1[],                          /* (i) Q_xn: Adaptive codebook.           */
-		Word16 Q_xn,                          /* (i)     : xn and y1 format             */
-		Word16 y2[],                          /* (i) Q9  : Filtered innovative vector.  */
-		Word16 code[],                        /* (i) Q9  : Innovative vector.           */
-		Word16 g_coeff[],                     /* (i)     : Correlations <xn y1> <y1 y1> */
-		/*           Compute in G_pitch().        */
-		Word16 L_subfr,                       /* (i)     : Subframe lenght.             */
-		Word16 nbits,                         /* (i)     : number of bits (6 or 7)      */
-		Word16 * gain_pit,                    /* (i/o)Q14: Pitch gain.                  */
-		Word32 * gain_cod,                    /* (o) Q16 : Code gain.                   */
-		Word16 gp_clip,                       /* (i)     : Gp Clipping flag             */
-		Word16 * mem                          /* (i/o)   : static memory (2 words)      */
-	      )
-{
-	Word16 index, *p, min_ind, size;
-	Word16 exp, frac, gcode0, exp_gcode0, e_max, exp_code, qua_ener;
-	Word16 g_pitch, g2_pitch, g_code, g_pit_cod, g2_code, g2_code_lo;
-	Word16 coeff[5], coeff_lo[5], exp_coeff[5];
-	Word16 exp_max[5];
-	Word32 i, j, L_tmp, dist_min;
-	Word16 *past_qua_en, *t_qua_gain;
-
-	past_qua_en = mem;                     
-
-	/*-----------------------------------------------------------------*
-	 * - Find the initial quantization pitch index                     *
-	 * - Set gains search range                                        *
-	 *-----------------------------------------------------------------*/
-	if (nbits == 6)
-	{
-		t_qua_gain = t_qua_gain6b;         
-		min_ind = 0;                       
-		size = RANGE;                      
-
-		if(gp_clip == 1)
-		{
-			size = size - 16;          /* limit gain pitch to 1.0 */
-		}
-	} else
-	{
-		t_qua_gain = t_qua_gain7b;         
-
-		p = t_qua_gain7b + RANGE;            /* pt at 1/4th of table */
-
-		j = nb_qua_gain7b - RANGE;         
-
-		if (gp_clip == 1)
-		{
-			j = j - 27;                /* limit gain pitch to 1.0 */
-		}
-		min_ind = 0;                       
-		g_pitch = *gain_pit;               
-
-		for (i = 0; i < j; i++, p += 2)
-		{
-			if (g_pitch > *p)
-			{
-				min_ind = min_ind + 1;
-			}
-		}
-		size = RANGE;                      
-	}
-
-	/*------------------------------------------------------------------*
-	 *  Compute coefficient need for the quantization.                  *
-	 *                                                                  *
-	 *  coeff[0] =    y1 y1                                             *
-	 *  coeff[1] = -2 xn y1                                             *
-	 *  coeff[2] =    y2 y2                                             *
-	 *  coeff[3] = -2 xn y2                                             *
-	 *  coeff[4] =  2 y1 y2                                             *
-	 *                                                                  *
-	 * Product <y1 y1> and <xn y1> have been compute in G_pitch() and   *
-	 * are in vector g_coeff[].                                         *
-	 *------------------------------------------------------------------*/
-
-	coeff[0] = g_coeff[0];                 
-	exp_coeff[0] = g_coeff[1];             
-	coeff[1] = negate(g_coeff[2]);                    /* coeff[1] = -2 xn y1 */
-	exp_coeff[1] = g_coeff[3] + 1;     
-
-	/* Compute scalar product <y2[],y2[]> */
-#ifdef ASM_OPT                   /* asm optimization branch */
-	coeff[2] = extract_h(Dot_product12_asm(y2, y2, L_subfr, &exp));
-#else
-	coeff[2] = extract_h(Dot_product12(y2, y2, L_subfr, &exp));
-#endif
-	exp_coeff[2] = (exp - 18) + (Q_xn << 1);     /* -18 (y2 Q9) */
-
-	/* Compute scalar product -2*<xn[],y2[]> */
-#ifdef ASM_OPT                  /* asm optimization branch */
-	coeff[3] = extract_h(L_negate(Dot_product12_asm(xn, y2, L_subfr, &exp)));
-#else
-	coeff[3] = extract_h(L_negate(Dot_product12(xn, y2, L_subfr, &exp)));
-#endif
-
-	exp_coeff[3] = (exp - 8) + Q_xn;  /* -9 (y2 Q9), +1 (2 xn y2) */
-
-	/* Compute scalar product 2*<y1[],y2[]> */
-#ifdef ASM_OPT                 /* asm optimization branch */
-	coeff[4] = extract_h(Dot_product12_asm(y1, y2, L_subfr, &exp));
-#else
-	coeff[4] = extract_h(Dot_product12(y1, y2, L_subfr, &exp));
-#endif
-	exp_coeff[4] = (exp - 8) + Q_xn;  /* -9 (y2 Q9), +1 (2 y1 y2) */
-
-	/*-----------------------------------------------------------------*
-	 *  Find energy of code and compute:                               *
-	 *                                                                 *
-	 *    L_tmp = MEAN_ENER - 10log10(energy of code/ L_subfr)         *
-	 *          = MEAN_ENER - 3.0103*log2(energy of code/ L_subfr)     *
-	 *-----------------------------------------------------------------*/
-#ifdef ASM_OPT                 /* asm optimization branch */
-	L_tmp = Dot_product12_asm(code, code, L_subfr, &exp_code);
-#else
-	L_tmp = Dot_product12(code, code, L_subfr, &exp_code);
-#endif
-	/* exp_code: -18 (code in Q9), -6 (/L_subfr), -31 (L_tmp Q31->Q0) */
-	exp_code = (exp_code - (18 + 6 + 31));
-
-	Log2(L_tmp, &exp, &frac);
-	exp += exp_code;
-	L_tmp = Mpy_32_16(exp, frac, -24660);  /* x -3.0103(Q13) -> Q14 */
-
-	L_tmp += (MEAN_ENER * 8192)<<1; /* + MEAN_ENER in Q14 */
-
-	/*-----------------------------------------------------------------*
-	 * Compute gcode0.                                                 *
-	 *  = Sum(i=0,1) pred[i]*past_qua_en[i] + mean_ener - ener_code    *
-	 *-----------------------------------------------------------------*/
-	L_tmp = (L_tmp << 10);              /* From Q14 to Q24 */
-	L_tmp += (pred[0] * past_qua_en[0])<<1;      /* Q13*Q10 -> Q24 */
-	L_tmp += (pred[1] * past_qua_en[1])<<1;      /* Q13*Q10 -> Q24 */
-	L_tmp += (pred[2] * past_qua_en[2])<<1;      /* Q13*Q10 -> Q24 */
-	L_tmp += (pred[3] * past_qua_en[3])<<1;      /* Q13*Q10 -> Q24 */
-
-	gcode0 = extract_h(L_tmp);             /* From Q24 to Q8  */
-
-	/*-----------------------------------------------------------------*
-	 * gcode0 = pow(10.0, gcode0/20)                                   *
-	 *        = pow(2, 3.321928*gcode0/20)                             *
-	 *        = pow(2, 0.166096*gcode0)                                *
-	 *-----------------------------------------------------------------*/
-
-	L_tmp = vo_L_mult(gcode0, 5443);          /* *0.166096 in Q15 -> Q24     */
-	L_tmp = L_tmp >> 8;               /* From Q24 to Q16             */
-	VO_L_Extract(L_tmp, &exp_gcode0, &frac);  /* Extract exponent of gcode0  */
-
-	gcode0 = (Word16)(Pow2(14, frac));    /* Put 14 as exponent so that  */
-	/* output of Pow2() will be:   */
-	/* 16384 < Pow2() <= 32767     */
-	exp_gcode0 -= 14;
-
-	/*-------------------------------------------------------------------------*
-	 * Find the best quantizer                                                 *
-	 * ~~~~~~~~~~~~~~~~~~~~~~~                                                 *
-	 * Before doing the computation we need to aling exponents of coeff[]      *
-	 * to be sure to have the maximum precision.                               *
-	 *                                                                         *
-	 * In the table the pitch gains are in Q14, the code gains are in Q11 and  *
-	 * are multiply by gcode0 which have been multiply by 2^exp_gcode0.        *
-	 * Also when we compute g_pitch*g_pitch, g_code*g_code and g_pitch*g_code  *
-	 * we divide by 2^15.                                                      *
-	 * Considering all the scaling above we have:                              *
-	 *                                                                         *
-	 *   exp_code = exp_gcode0-11+15 = exp_gcode0+4                            *
-	 *                                                                         *
-	 *   g_pitch*g_pitch  = -14-14+15                                          *
-	 *   g_pitch          = -14                                                *
-	 *   g_code*g_code    = (2*exp_code)+15                                    *
-	 *   g_code           = exp_code                                           *
-	 *   g_pitch*g_code   = -14 + exp_code +15                                 *
-	 *                                                                         *
-	 *   g_pitch*g_pitch * coeff[0]  ;exp_max0 = exp_coeff[0] - 13             *
-	 *   g_pitch         * coeff[1]  ;exp_max1 = exp_coeff[1] - 14             *
-	 *   g_code*g_code   * coeff[2]  ;exp_max2 = exp_coeff[2] +15+(2*exp_code) *
-	 *   g_code          * coeff[3]  ;exp_max3 = exp_coeff[3] + exp_code       *
-	 *   g_pitch*g_code  * coeff[4]  ;exp_max4 = exp_coeff[4] + 1 + exp_code   *
-	 *-------------------------------------------------------------------------*/
-
-	exp_code = (exp_gcode0 + 4);
-	exp_max[0] = (exp_coeff[0] - 13);    
-	exp_max[1] = (exp_coeff[1] - 14);    
-	exp_max[2] = (exp_coeff[2] + (15 + (exp_code << 1)));  
-	exp_max[3] = (exp_coeff[3] + exp_code);   
-	exp_max[4] = (exp_coeff[4] + (1 + exp_code));  
-
-	/* Find maximum exponant */
-
-	e_max = exp_max[0];                   
-	for (i = 1; i < 5; i++)
-	{
-		if(exp_max[i] > e_max)
-		{
-			e_max = exp_max[i];            
-		}
-	}
-
-	/* align coeff[] and save in special 32 bit double precision */
-
-	for (i = 0; i < 5; i++)
-	{
-		j = add1(vo_sub(e_max, exp_max[i]), 2);/* /4 to avoid overflow */
-		L_tmp = L_deposit_h(coeff[i]);
-		L_tmp = L_shr(L_tmp, j);
-		VO_L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);
-		coeff_lo[i] = (coeff_lo[i] >> 3);   /* lo >> 3 */
-	}
-
-	/* Codebook search */
-	dist_min = MAX_32;                     
-	p = &t_qua_gain[min_ind << 1];      
-
-	index = 0;                             
-	for (i = 0; i < size; i++)
-	{
-		g_pitch = *p++;                    
-		g_code = *p++;                     
-
-		g_code = ((g_code * gcode0) + 0x4000)>>15;
-		g2_pitch = ((g_pitch * g_pitch) + 0x4000)>>15;
-		g_pit_cod = ((g_code * g_pitch) + 0x4000)>>15;
-		L_tmp = (g_code * g_code)<<1;
-		VO_L_Extract(L_tmp, &g2_code, &g2_code_lo);
-
-		L_tmp = (coeff[2] * g2_code_lo)<<1;
-		L_tmp =  (L_tmp >> 3);
-		L_tmp += (coeff_lo[0] * g2_pitch)<<1;
-		L_tmp += (coeff_lo[1] * g_pitch)<<1;
-		L_tmp += (coeff_lo[2] * g2_code)<<1;
-		L_tmp += (coeff_lo[3] * g_code)<<1;
-		L_tmp += (coeff_lo[4] * g_pit_cod)<<1;
-		L_tmp =  (L_tmp >> 12);
-		L_tmp += (coeff[0] * g2_pitch)<<1;
-		L_tmp += (coeff[1] * g_pitch)<<1;
-		L_tmp += (coeff[2] * g2_code)<<1;
-		L_tmp += (coeff[3] * g_code)<<1;
-		L_tmp += (coeff[4] * g_pit_cod)<<1;
-
-		if(L_tmp < dist_min)
-		{
-			dist_min = L_tmp;              
-			index = i;                     
-		}
-	}
-
-	/* Read the quantized gains */
-	index = index + min_ind;
-	p = &t_qua_gain[(index + index)];    
-	*gain_pit = *p++;                       /* selected pitch gain in Q14 */
-	g_code = *p++;                          /* selected code gain in Q11  */
-
-	L_tmp = vo_L_mult(g_code, gcode0);             /* Q11*Q0 -> Q12 */
-	L_tmp = L_shl(L_tmp, (exp_gcode0 + 4));   /* Q12 -> Q16 */
-
-	*gain_cod = L_tmp;                       /* gain of code in Q16 */
-
-	/*---------------------------------------------------*
-	 * qua_ener = 20*log10(g_code)                       *
-	 *          = 6.0206*log2(g_code)                    *
-	 *          = 6.0206*(log2(g_codeQ11) - 11)          *
-	 *---------------------------------------------------*/
-
-	L_tmp = L_deposit_l(g_code);
-	Log2(L_tmp, &exp, &frac);
-	exp -= 11;
-	L_tmp = Mpy_32_16(exp, frac, 24660);   /* x 6.0206 in Q12 */
-
-	qua_ener = (Word16)(L_tmp >> 3); /* result in Q10 */
-
-	/* update table of past quantized energies */
-
-	past_qua_en[3] = past_qua_en[2];       
-	past_qua_en[2] = past_qua_en[1];       
-	past_qua_en[1] = past_qua_en[0];       
-	past_qua_en[0] = qua_ener;             
-
-	return (index);
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/**************************************************************************
+*  File: q_gain2.c                                                         *
+*                                                                          *
+*  Description:                                                            *
+* Quantization of pitch and codebook gains.                                *
+* MA prediction is performed on the innovation energy (in dB with mean     *
+* removed).                                                                *
+* An initial predicted gain, g_0, is first determined and the correction   *
+* factor     alpha = gain / g_0    is quantized.                           *
+* The pitch gain and the correction factor are vector quantized and the    *
+* mean-squared weighted error criterion is used in the quantizer search.   *
+****************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "math_op.h"
+#include "log2.h"
+#include "acelp.h"
+#include "q_gain2.tab"
+
+#define MEAN_ENER    30
+#define RANGE        64
+#define PRED_ORDER   4
+
+
+/* MA prediction coeff ={0.5, 0.4, 0.3, 0.2} in Q13 */
+static Word16 pred[PRED_ORDER] = {4096, 3277, 2458, 1638};
+
+
+void Init_Q_gain2(
+		Word16 * mem                          /* output  :static memory (2 words)      */
+		)
+{
+	Word32 i;
+
+	/* 4nd order quantizer energy predictor (init to -14.0 in Q10) */
+	for (i = 0; i < PRED_ORDER; i++)
+	{
+		mem[i] = -14336;                     /* past_qua_en[i] */
+	}
+
+	return;
+}
+
+Word16 Q_gain2(                            /* Return index of quantization.          */
+		Word16 xn[],                          /* (i) Q_xn: Target vector.               */
+		Word16 y1[],                          /* (i) Q_xn: Adaptive codebook.           */
+		Word16 Q_xn,                          /* (i)     : xn and y1 format             */
+		Word16 y2[],                          /* (i) Q9  : Filtered innovative vector.  */
+		Word16 code[],                        /* (i) Q9  : Innovative vector.           */
+		Word16 g_coeff[],                     /* (i)     : Correlations <xn y1> <y1 y1> */
+		/*           Compute in G_pitch().        */
+		Word16 L_subfr,                       /* (i)     : Subframe lenght.             */
+		Word16 nbits,                         /* (i)     : number of bits (6 or 7)      */
+		Word16 * gain_pit,                    /* (i/o)Q14: Pitch gain.                  */
+		Word32 * gain_cod,                    /* (o) Q16 : Code gain.                   */
+		Word16 gp_clip,                       /* (i)     : Gp Clipping flag             */
+		Word16 * mem                          /* (i/o)   : static memory (2 words)      */
+	      )
+{
+	Word16 index, *p, min_ind, size;
+	Word16 exp, frac, gcode0, exp_gcode0, e_max, exp_code, qua_ener;
+	Word16 g_pitch, g2_pitch, g_code, g_pit_cod, g2_code, g2_code_lo;
+	Word16 coeff[5], coeff_lo[5], exp_coeff[5];
+	Word16 exp_max[5];
+	Word32 i, j, L_tmp, dist_min;
+	Word16 *past_qua_en, *t_qua_gain;
+
+	past_qua_en = mem;
+
+	/*-----------------------------------------------------------------*
+	 * - Find the initial quantization pitch index                     *
+	 * - Set gains search range                                        *
+	 *-----------------------------------------------------------------*/
+	if (nbits == 6)
+	{
+		t_qua_gain = t_qua_gain6b;
+		min_ind = 0;
+		size = RANGE;
+
+		if(gp_clip == 1)
+		{
+			size = size - 16;          /* limit gain pitch to 1.0 */
+		}
+	} else
+	{
+		t_qua_gain = t_qua_gain7b;
+
+		p = t_qua_gain7b + RANGE;            /* pt at 1/4th of table */
+
+		j = nb_qua_gain7b - RANGE;
+
+		if (gp_clip == 1)
+		{
+			j = j - 27;                /* limit gain pitch to 1.0 */
+		}
+		min_ind = 0;
+		g_pitch = *gain_pit;
+
+		for (i = 0; i < j; i++, p += 2)
+		{
+			if (g_pitch > *p)
+			{
+				min_ind = min_ind + 1;
+			}
+		}
+		size = RANGE;
+	}
+
+	/*------------------------------------------------------------------*
+	 *  Compute coefficient need for the quantization.                  *
+	 *                                                                  *
+	 *  coeff[0] =    y1 y1                                             *
+	 *  coeff[1] = -2 xn y1                                             *
+	 *  coeff[2] =    y2 y2                                             *
+	 *  coeff[3] = -2 xn y2                                             *
+	 *  coeff[4] =  2 y1 y2                                             *
+	 *                                                                  *
+	 * Product <y1 y1> and <xn y1> have been compute in G_pitch() and   *
+	 * are in vector g_coeff[].                                         *
+	 *------------------------------------------------------------------*/
+
+	coeff[0] = g_coeff[0];
+	exp_coeff[0] = g_coeff[1];
+	coeff[1] = negate(g_coeff[2]);                    /* coeff[1] = -2 xn y1 */
+	exp_coeff[1] = g_coeff[3] + 1;
+
+	/* Compute scalar product <y2[],y2[]> */
+#ifdef ASM_OPT                   /* asm optimization branch */
+	coeff[2] = extract_h(Dot_product12_asm(y2, y2, L_subfr, &exp));
+#else
+	coeff[2] = extract_h(Dot_product12(y2, y2, L_subfr, &exp));
+#endif
+	exp_coeff[2] = (exp - 18) + (Q_xn << 1);     /* -18 (y2 Q9) */
+
+	/* Compute scalar product -2*<xn[],y2[]> */
+#ifdef ASM_OPT                  /* asm optimization branch */
+	coeff[3] = extract_h(L_negate(Dot_product12_asm(xn, y2, L_subfr, &exp)));
+#else
+	coeff[3] = extract_h(L_negate(Dot_product12(xn, y2, L_subfr, &exp)));
+#endif
+
+	exp_coeff[3] = (exp - 8) + Q_xn;  /* -9 (y2 Q9), +1 (2 xn y2) */
+
+	/* Compute scalar product 2*<y1[],y2[]> */
+#ifdef ASM_OPT                 /* asm optimization branch */
+	coeff[4] = extract_h(Dot_product12_asm(y1, y2, L_subfr, &exp));
+#else
+	coeff[4] = extract_h(Dot_product12(y1, y2, L_subfr, &exp));
+#endif
+	exp_coeff[4] = (exp - 8) + Q_xn;  /* -9 (y2 Q9), +1 (2 y1 y2) */
+
+	/*-----------------------------------------------------------------*
+	 *  Find energy of code and compute:                               *
+	 *                                                                 *
+	 *    L_tmp = MEAN_ENER - 10log10(energy of code/ L_subfr)         *
+	 *          = MEAN_ENER - 3.0103*log2(energy of code/ L_subfr)     *
+	 *-----------------------------------------------------------------*/
+#ifdef ASM_OPT                 /* asm optimization branch */
+	L_tmp = Dot_product12_asm(code, code, L_subfr, &exp_code);
+#else
+	L_tmp = Dot_product12(code, code, L_subfr, &exp_code);
+#endif
+	/* exp_code: -18 (code in Q9), -6 (/L_subfr), -31 (L_tmp Q31->Q0) */
+	exp_code = (exp_code - (18 + 6 + 31));
+
+	Log2(L_tmp, &exp, &frac);
+	exp += exp_code;
+	L_tmp = Mpy_32_16(exp, frac, -24660);  /* x -3.0103(Q13) -> Q14 */
+
+	L_tmp += (MEAN_ENER * 8192)<<1; /* + MEAN_ENER in Q14 */
+
+	/*-----------------------------------------------------------------*
+	 * Compute gcode0.                                                 *
+	 *  = Sum(i=0,1) pred[i]*past_qua_en[i] + mean_ener - ener_code    *
+	 *-----------------------------------------------------------------*/
+	L_tmp = (L_tmp << 10);              /* From Q14 to Q24 */
+	L_tmp += (pred[0] * past_qua_en[0])<<1;      /* Q13*Q10 -> Q24 */
+	L_tmp += (pred[1] * past_qua_en[1])<<1;      /* Q13*Q10 -> Q24 */
+	L_tmp += (pred[2] * past_qua_en[2])<<1;      /* Q13*Q10 -> Q24 */
+	L_tmp += (pred[3] * past_qua_en[3])<<1;      /* Q13*Q10 -> Q24 */
+
+	gcode0 = extract_h(L_tmp);             /* From Q24 to Q8  */
+
+	/*-----------------------------------------------------------------*
+	 * gcode0 = pow(10.0, gcode0/20)                                   *
+	 *        = pow(2, 3.321928*gcode0/20)                             *
+	 *        = pow(2, 0.166096*gcode0)                                *
+	 *-----------------------------------------------------------------*/
+
+	L_tmp = vo_L_mult(gcode0, 5443);          /* *0.166096 in Q15 -> Q24     */
+	L_tmp = L_tmp >> 8;               /* From Q24 to Q16             */
+	VO_L_Extract(L_tmp, &exp_gcode0, &frac);  /* Extract exponent of gcode0  */
+
+	gcode0 = (Word16)(Pow2(14, frac));    /* Put 14 as exponent so that  */
+	/* output of Pow2() will be:   */
+	/* 16384 < Pow2() <= 32767     */
+	exp_gcode0 -= 14;
+
+	/*-------------------------------------------------------------------------*
+	 * Find the best quantizer                                                 *
+	 * ~~~~~~~~~~~~~~~~~~~~~~~                                                 *
+	 * Before doing the computation we need to aling exponents of coeff[]      *
+	 * to be sure to have the maximum precision.                               *
+	 *                                                                         *
+	 * In the table the pitch gains are in Q14, the code gains are in Q11 and  *
+	 * are multiply by gcode0 which have been multiply by 2^exp_gcode0.        *
+	 * Also when we compute g_pitch*g_pitch, g_code*g_code and g_pitch*g_code  *
+	 * we divide by 2^15.                                                      *
+	 * Considering all the scaling above we have:                              *
+	 *                                                                         *
+	 *   exp_code = exp_gcode0-11+15 = exp_gcode0+4                            *
+	 *                                                                         *
+	 *   g_pitch*g_pitch  = -14-14+15                                          *
+	 *   g_pitch          = -14                                                *
+	 *   g_code*g_code    = (2*exp_code)+15                                    *
+	 *   g_code           = exp_code                                           *
+	 *   g_pitch*g_code   = -14 + exp_code +15                                 *
+	 *                                                                         *
+	 *   g_pitch*g_pitch * coeff[0]  ;exp_max0 = exp_coeff[0] - 13             *
+	 *   g_pitch         * coeff[1]  ;exp_max1 = exp_coeff[1] - 14             *
+	 *   g_code*g_code   * coeff[2]  ;exp_max2 = exp_coeff[2] +15+(2*exp_code) *
+	 *   g_code          * coeff[3]  ;exp_max3 = exp_coeff[3] + exp_code       *
+	 *   g_pitch*g_code  * coeff[4]  ;exp_max4 = exp_coeff[4] + 1 + exp_code   *
+	 *-------------------------------------------------------------------------*/
+
+	exp_code = (exp_gcode0 + 4);
+	exp_max[0] = (exp_coeff[0] - 13);
+	exp_max[1] = (exp_coeff[1] - 14);
+	exp_max[2] = (exp_coeff[2] + (15 + (exp_code << 1)));
+	exp_max[3] = (exp_coeff[3] + exp_code);
+	exp_max[4] = (exp_coeff[4] + (1 + exp_code));
+
+	/* Find maximum exponant */
+
+	e_max = exp_max[0];
+	for (i = 1; i < 5; i++)
+	{
+		if(exp_max[i] > e_max)
+		{
+			e_max = exp_max[i];
+		}
+	}
+
+	/* align coeff[] and save in special 32 bit double precision */
+
+	for (i = 0; i < 5; i++)
+	{
+		j = add1(vo_sub(e_max, exp_max[i]), 2);/* /4 to avoid overflow */
+		L_tmp = L_deposit_h(coeff[i]);
+		L_tmp = L_shr(L_tmp, j);
+		VO_L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);
+		coeff_lo[i] = (coeff_lo[i] >> 3);   /* lo >> 3 */
+	}
+
+	/* Codebook search */
+	dist_min = MAX_32;
+	p = &t_qua_gain[min_ind << 1];
+
+	index = 0;
+	for (i = 0; i < size; i++)
+	{
+		g_pitch = *p++;
+		g_code = *p++;
+
+		g_code = ((g_code * gcode0) + 0x4000)>>15;
+		g2_pitch = ((g_pitch * g_pitch) + 0x4000)>>15;
+		g_pit_cod = ((g_code * g_pitch) + 0x4000)>>15;
+		L_tmp = (g_code * g_code)<<1;
+		VO_L_Extract(L_tmp, &g2_code, &g2_code_lo);
+
+		L_tmp = (coeff[2] * g2_code_lo)<<1;
+		L_tmp =  (L_tmp >> 3);
+		L_tmp += (coeff_lo[0] * g2_pitch)<<1;
+		L_tmp += (coeff_lo[1] * g_pitch)<<1;
+		L_tmp += (coeff_lo[2] * g2_code)<<1;
+		L_tmp += (coeff_lo[3] * g_code)<<1;
+		L_tmp += (coeff_lo[4] * g_pit_cod)<<1;
+		L_tmp =  (L_tmp >> 12);
+		L_tmp += (coeff[0] * g2_pitch)<<1;
+		L_tmp += (coeff[1] * g_pitch)<<1;
+		L_tmp += (coeff[2] * g2_code)<<1;
+		L_tmp += (coeff[3] * g_code)<<1;
+		L_tmp += (coeff[4] * g_pit_cod)<<1;
+
+		if(L_tmp < dist_min)
+		{
+			dist_min = L_tmp;
+			index = i;
+		}
+	}
+
+	/* Read the quantized gains */
+	index = index + min_ind;
+	p = &t_qua_gain[(index + index)];
+	*gain_pit = *p++;                       /* selected pitch gain in Q14 */
+	g_code = *p++;                          /* selected code gain in Q11  */
+
+	L_tmp = vo_L_mult(g_code, gcode0);             /* Q11*Q0 -> Q12 */
+	L_tmp = L_shl(L_tmp, (exp_gcode0 + 4));   /* Q12 -> Q16 */
+
+	*gain_cod = L_tmp;                       /* gain of code in Q16 */
+
+	/*---------------------------------------------------*
+	 * qua_ener = 20*log10(g_code)                       *
+	 *          = 6.0206*log2(g_code)                    *
+	 *          = 6.0206*(log2(g_codeQ11) - 11)          *
+	 *---------------------------------------------------*/
+
+	L_tmp = L_deposit_l(g_code);
+	Log2(L_tmp, &exp, &frac);
+	exp -= 11;
+	L_tmp = Mpy_32_16(exp, frac, 24660);   /* x 6.0206 in Q12 */
+
+	qua_ener = (Word16)(L_tmp >> 3); /* result in Q10 */
+
+	/* update table of past quantized energies */
+
+	past_qua_en[3] = past_qua_en[2];
+	past_qua_en[2] = past_qua_en[1];
+	past_qua_en[1] = past_qua_en[0];
+	past_qua_en[0] = qua_ener;
+
+	return (index);
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/q_pulse.c b/media/libstagefright/codecs/amrwbenc/src/q_pulse.c
index a28ba40..80a0b73 100644
--- a/media/libstagefright/codecs/amrwbenc/src/q_pulse.c
+++ b/media/libstagefright/codecs/amrwbenc/src/q_pulse.c
@@ -1,400 +1,400 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: q_pulse.c                                                 *
-*                                                                      *
-*      Description: Coding and decoding of algebraic codebook          *
-*                                                                      *
-************************************************************************/
-
-#include <stdio.h>
-#include "typedef.h"
-#include "basic_op.h"
-#include "q_pulse.h"
-
-#define NB_POS 16                          /* pos in track, mask for sign bit */
-
-Word32 quant_1p_N1(                        /* (o) return N+1 bits             */
-		Word16 pos,                        /* (i) position of the pulse       */
-		Word16 N)                          /* (i) number of bits for position */
-{
-	Word16 mask;
-	Word32 index;
-
-	mask = (1 << N) - 1;              /* mask = ((1<<N)-1); */
-	/*-------------------------------------------------------*
-	 * Quantization of 1 pulse with N+1 bits:                *
-	 *-------------------------------------------------------*/
-	index = L_deposit_l((Word16) (pos & mask));
-	if ((pos & NB_POS) != 0)
-	{
-		index = vo_L_add(index, L_deposit_l(1 << N));   /* index += 1 << N; */
-	}
-	return (index);
-}
-
-
-Word32 quant_2p_2N1(                       /* (o) return (2*N)+1 bits         */
-		Word16 pos1,                          /* (i) position of the pulse 1     */
-		Word16 pos2,                          /* (i) position of the pulse 2     */
-		Word16 N)                             /* (i) number of bits for position */
-{
-	Word16 mask, tmp;
-	Word32 index;
-	mask = (1 << N) - 1;              /* mask = ((1<<N)-1); */
-	/*-------------------------------------------------------*
-	 * Quantization of 2 pulses with 2*N+1 bits:             *
-	 *-------------------------------------------------------*/
-	if (((pos2 ^ pos1) & NB_POS) == 0)
-	{
-		/* sign of 1st pulse == sign of 2th pulse */
-		if(pos1 <= pos2)          /* ((pos1 - pos2) <= 0) */
-		{
-			/* index = ((pos1 & mask) << N) + (pos2 & mask); */
-			index = L_deposit_l(add1((((Word16) (pos1 & mask)) << N), ((Word16) (pos2 & mask))));
-		} else
-		{
-			/* ((pos2 & mask) << N) + (pos1 & mask); */
-			index = L_deposit_l(add1((((Word16) (pos2 & mask)) << N), ((Word16) (pos1 & mask))));
-		}
-		if ((pos1 & NB_POS) != 0)
-		{
-			tmp = (N << 1);
-			index = vo_L_add(index, (1L << tmp));       /* index += 1 << (2*N); */
-		}
-	} else
-	{
-		/* sign of 1st pulse != sign of 2th pulse */
-		if (vo_sub((Word16) (pos1 & mask), (Word16) (pos2 & mask)) <= 0)
-		{
-			/* index = ((pos2 & mask) << N) + (pos1 & mask); */
-			index = L_deposit_l(add1((((Word16) (pos2 & mask)) << N), ((Word16) (pos1 & mask)))); 
-			if ((pos2 & NB_POS) != 0)
-			{
-				tmp = (N << 1);           /* index += 1 << (2*N); */
-				index = vo_L_add(index, (1L << tmp));
-			}
-		} else
-		{
-			/* index = ((pos1 & mask) << N) + (pos2 & mask);	 */
-			index = L_deposit_l(add1((((Word16) (pos1 & mask)) << N), ((Word16) (pos2 & mask)))); 
-			if ((pos1 & NB_POS) != 0)
-			{
-				tmp = (N << 1);
-				index = vo_L_add(index, (1 << tmp));    /* index += 1 << (2*N); */
-			}
-		}
-	}
-	return (index);
-}
-
-
-Word32 quant_3p_3N1(                       /* (o) return (3*N)+1 bits         */
-		Word16 pos1,                          /* (i) position of the pulse 1     */
-		Word16 pos2,                          /* (i) position of the pulse 2     */
-		Word16 pos3,                          /* (i) position of the pulse 3     */
-		Word16 N)                             /* (i) number of bits for position */
-{
-	Word16 nb_pos;
-	Word32 index;
-
-	nb_pos =(1 <<(N - 1));            /* nb_pos = (1<<(N-1)); */
-	/*-------------------------------------------------------*
-	 * Quantization of 3 pulses with 3*N+1 bits:             *
-	 *-------------------------------------------------------*/
-	if (((pos1 ^ pos2) & nb_pos) == 0)
-	{
-		index = quant_2p_2N1(pos1, pos2, sub(N, 1));    /* index = quant_2p_2N1(pos1, pos2, (N-1)); */
-		/* index += (pos1 & nb_pos) << N; */
-		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N));  
-		/* index += quant_1p_N1(pos3, N) << (2*N); */
-		index = vo_L_add(index, (quant_1p_N1(pos3, N)<<(N << 1)));
-
-	} else if (((pos1 ^ pos3) & nb_pos) == 0)
-	{
-		index = quant_2p_2N1(pos1, pos3, sub(N, 1));    /* index = quant_2p_2N1(pos1, pos3, (N-1)); */
-		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N)); 
-		/* index += (pos1 & nb_pos) << N; */
-		index = vo_L_add(index, (quant_1p_N1(pos2, N) << (N << 1)));
-		/* index += quant_1p_N1(pos2, N) <<
-		 * (2*N); */
-	} else
-	{
-		index = quant_2p_2N1(pos2, pos3, (N - 1));    /* index = quant_2p_2N1(pos2, pos3, (N-1)); */
-		/* index += (pos2 & nb_pos) << N;			 */
-		index = vo_L_add(index, (L_deposit_l((Word16) (pos2 & nb_pos)) << N));  
-		/* index += quant_1p_N1(pos1, N) << (2*N);	 */
-		index = vo_L_add(index, (quant_1p_N1(pos1, N) << (N << 1)));
-	}
-	return (index);
-}
-
-
-Word32 quant_4p_4N1(                       /* (o) return (4*N)+1 bits         */
-		Word16 pos1,                          /* (i) position of the pulse 1     */
-		Word16 pos2,                          /* (i) position of the pulse 2     */
-		Word16 pos3,                          /* (i) position of the pulse 3     */
-		Word16 pos4,                          /* (i) position of the pulse 4     */
-		Word16 N)                             /* (i) number of bits for position */
-{
-	Word16 nb_pos;
-	Word32 index;
-
-	nb_pos = 1 << (N - 1);            /* nb_pos = (1<<(N-1));  */
-	/*-------------------------------------------------------*
-	 * Quantization of 4 pulses with 4*N+1 bits:             *
-	 *-------------------------------------------------------*/
-	if (((pos1 ^ pos2) & nb_pos) == 0)
-	{
-		index = quant_2p_2N1(pos1, pos2, sub(N, 1));    /* index = quant_2p_2N1(pos1, pos2, (N-1)); */
-		/* index += (pos1 & nb_pos) << N;	 */
-		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N));  
-		/* index += quant_2p_2N1(pos3, pos4, N) << (2*N); */
-		index = vo_L_add(index, (quant_2p_2N1(pos3, pos4, N) << (N << 1)));
-	} else if (((pos1 ^ pos3) & nb_pos) == 0)
-	{
-		index = quant_2p_2N1(pos1, pos3, (N - 1));
-		/* index += (pos1 & nb_pos) << N; */
-		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N));  
-		/* index += quant_2p_2N1(pos2, pos4, N) << (2*N); */
-		index = vo_L_add(index, (quant_2p_2N1(pos2, pos4, N) << (N << 1)));
-	} else
-	{
-		index = quant_2p_2N1(pos2, pos3, (N - 1));
-		/* index += (pos2 & nb_pos) << N; */
-		index = vo_L_add(index, (L_deposit_l((Word16) (pos2 & nb_pos)) << N));  
-		/* index += quant_2p_2N1(pos1, pos4, N) << (2*N); */
-		index = vo_L_add(index, (quant_2p_2N1(pos1, pos4, N) << (N << 1)));
-	}
-	return (index);
-}
-
-
-Word32 quant_4p_4N(                        /* (o) return 4*N bits             */
-		Word16 pos[],                         /* (i) position of the pulse 1..4  */
-		Word16 N)                             /* (i) number of bits for position */
-{
-	Word16 nb_pos, mask, n_1, tmp;
-	Word16 posA[4], posB[4];
-	Word32 i, j, k, index;
-
-	n_1 = (Word16) (N - 1);                
-	nb_pos = (1 << n_1);                  /* nb_pos = (1<<n_1); */
-	mask = vo_sub((1 << N), 1);              /* mask = ((1<<N)-1); */
-
-	i = 0;                                 
-	j = 0;                                 
-	for (k = 0; k < 4; k++)
-	{
-		if ((pos[k] & nb_pos) == 0)
-		{
-			posA[i++] = pos[k];            
-		} else
-		{
-			posB[j++] = pos[k];            
-		}
-	}
-
-	switch (i)
-	{
-		case 0:
-			tmp = vo_sub((N << 2), 3);           /* index = 1 << ((4*N)-3); */
-			index = (1L << tmp);
-			/* index += quant_4p_4N1(posB[0], posB[1], posB[2], posB[3], n_1); */
-			index = vo_L_add(index, quant_4p_4N1(posB[0], posB[1], posB[2], posB[3], n_1));
-			break;
-		case 1:
-			/* index = quant_1p_N1(posA[0], n_1) << ((3*n_1)+1); */
-			tmp = add1((Word16)((vo_L_mult(3, n_1) >> 1)), 1);
-			index = L_shl(quant_1p_N1(posA[0], n_1), tmp);
-			/* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1); */
-			index = vo_L_add(index, quant_3p_3N1(posB[0], posB[1], posB[2], n_1));
-			break;
-		case 2:
-			tmp = ((n_1 << 1) + 1);         /* index = quant_2p_2N1(posA[0], posA[1], n_1) << ((2*n_1)+1); */
-			index = L_shl(quant_2p_2N1(posA[0], posA[1], n_1), tmp);
-			/* index += quant_2p_2N1(posB[0], posB[1], n_1); */
-			index = vo_L_add(index, quant_2p_2N1(posB[0], posB[1], n_1));
-			break;
-		case 3:
-			/* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << N; */
-			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), N);
-			index = vo_L_add(index, quant_1p_N1(posB[0], n_1));        /* index += quant_1p_N1(posB[0], n_1); */
-			break;
-		case 4:
-			index = quant_4p_4N1(posA[0], posA[1], posA[2], posA[3], n_1);
-			break;
-		default:
-			index = 0;
-			fprintf(stderr, "Error in function quant_4p_4N\n");
-	}
-	tmp = ((N << 2) - 2);               /* index += (i & 3) << ((4*N)-2); */
-	index = vo_L_add(index, L_shl((L_deposit_l(i) & (3L)), tmp));
-
-	return (index);
-}
-
-
-
-Word32 quant_5p_5N(                        /* (o) return 5*N bits             */
-		Word16 pos[],                         /* (i) position of the pulse 1..5  */
-		Word16 N)                             /* (i) number of bits for position */
-{
-	Word16 nb_pos, n_1, tmp;
-	Word16 posA[5], posB[5];
-	Word32 i, j, k, index, tmp2;
-
-	n_1 = (Word16) (N - 1);                
-	nb_pos = (1 << n_1);                  /* nb_pos = (1<<n_1); */
-
-	i = 0;                                 
-	j = 0;                                 
-	for (k = 0; k < 5; k++)
-	{
-		if ((pos[k] & nb_pos) == 0)
-		{
-			posA[i++] = pos[k];            
-		} else
-		{
-			posB[j++] = pos[k];            
-		}
-	}
-
-	switch (i)
-	{
-		case 0:
-			tmp = vo_sub((Word16)((vo_L_mult(5, N) >> 1)), 1);        /* ((5*N)-1)) */
-			index = L_shl(1L, tmp);   /* index = 1 << ((5*N)-1); */
-			tmp = add1((N << 1), 1);  /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1) << ((2*N)+1);*/
-			tmp2 = L_shl(quant_3p_3N1(posB[0], posB[1], posB[2], n_1), tmp);
-			index = vo_L_add(index, tmp2);
-			index = vo_L_add(index, quant_2p_2N1(posB[3], posB[4], N));        /* index += quant_2p_2N1(posB[3], posB[4], N); */
-			break;
-		case 1:
-			tmp = vo_sub((Word16)((vo_L_mult(5, N) >> 1)), 1);        /* index = 1 << ((5*N)-1); */
-			index = L_shl(1L, tmp);
-			tmp = add1((N << 1), 1);   /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1) <<((2*N)+1);  */
-			tmp2 = L_shl(quant_3p_3N1(posB[0], posB[1], posB[2], n_1), tmp);
-			index = vo_L_add(index, tmp2);
-			index = vo_L_add(index, quant_2p_2N1(posB[3], posA[0], N));        /* index += quant_2p_2N1(posB[3], posA[0], N); */
-			break;
-		case 2:
-			tmp = vo_sub((Word16)((vo_L_mult(5, N) >> 1)), 1);        /* ((5*N)-1)) */
-			index = L_shl(1L, tmp);            /* index = 1 << ((5*N)-1); */
-			tmp = add1((N << 1), 1);           /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1) << ((2*N)+1);  */
-			tmp2 = L_shl(quant_3p_3N1(posB[0], posB[1], posB[2], n_1), tmp);
-			index = vo_L_add(index, tmp2);
-			index = vo_L_add(index, quant_2p_2N1(posA[0], posA[1], N));        /* index += quant_2p_2N1(posA[0], posA[1], N); */
-			break;
-		case 3:
-			tmp = add1((N << 1), 1);           /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((2*N)+1);  */
-			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), tmp);
-			index = vo_L_add(index, quant_2p_2N1(posB[0], posB[1], N));        /* index += quant_2p_2N1(posB[0], posB[1], N); */
-			break;
-		case 4:
-			tmp = add1((N << 1), 1);           /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((2*N)+1);  */
-			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), tmp);
-			index = vo_L_add(index, quant_2p_2N1(posA[3], posB[0], N));        /* index += quant_2p_2N1(posA[3], posB[0], N); */
-			break;
-		case 5:
-			tmp = add1((N << 1), 1);           /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((2*N)+1);  */
-			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), tmp);
-			index = vo_L_add(index, quant_2p_2N1(posA[3], posA[4], N));        /* index += quant_2p_2N1(posA[3], posA[4], N); */
-			break;
-		default:
-			index = 0;
-			fprintf(stderr, "Error in function quant_5p_5N\n");
-	}
-
-	return (index);
-}
-
-
-Word32 quant_6p_6N_2(                      /* (o) return (6*N)-2 bits         */
-		Word16 pos[],                         /* (i) position of the pulse 1..6  */
-		Word16 N)                             /* (i) number of bits for position */
-{
-	Word16 nb_pos, n_1;
-	Word16 posA[6], posB[6];
-	Word32 i, j, k, index;
-
-	/* !!  N and n_1 are constants -> it doesn't need to be operated by Basic Operators */
-	n_1 = (Word16) (N - 1);                
-	nb_pos = (1 << n_1);                  /* nb_pos = (1<<n_1); */
-
-	i = 0;                                 
-	j = 0;                                 
-	for (k = 0; k < 6; k++)
-	{
-		if ((pos[k] & nb_pos) == 0)
-		{
-			posA[i++] = pos[k];            
-		} else
-		{
-			posB[j++] = pos[k];            
-		}
-	}
-
-	switch (i)
-	{
-		case 0:
-			index = (1 << (Word16) (6 * N - 5));        /* index = 1 << ((6*N)-5); */
-			index = vo_L_add(index, (quant_5p_5N(posB, n_1) << N)); /* index += quant_5p_5N(posB, n_1) << N; */
-			index = vo_L_add(index, quant_1p_N1(posB[5], n_1));        /* index += quant_1p_N1(posB[5], n_1); */
-			break;
-		case 1:
-			index = (1L << (Word16) (6 * N - 5));        /* index = 1 << ((6*N)-5); */
-			index = vo_L_add(index, (quant_5p_5N(posB, n_1) << N)); /* index += quant_5p_5N(posB, n_1) << N; */
-			index = vo_L_add(index, quant_1p_N1(posA[0], n_1));        /* index += quant_1p_N1(posA[0], n_1); */
-			break;
-		case 2:
-			index = (1L << (Word16) (6 * N - 5));        /* index = 1 << ((6*N)-5); */
-			/* index += quant_4p_4N(posB, n_1) << ((2*n_1)+1); */
-			index = vo_L_add(index, (quant_4p_4N(posB, n_1) << (Word16) (2 * n_1 + 1)));
-			index = vo_L_add(index, quant_2p_2N1(posA[0], posA[1], n_1));      /* index += quant_2p_2N1(posA[0], posA[1], n_1); */
-			break;
-		case 3:
-			index = (quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << (Word16) (3 * n_1 + 1));    
-			                                  /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((3*n_1)+1); */
-			index =vo_L_add(index, quant_3p_3N1(posB[0], posB[1], posB[2], n_1));     
-			                                 /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1); */
-			break;
-		case 4:
-			i = 2;                            
-			index = (quant_4p_4N(posA, n_1) << (Word16) (2 * n_1 + 1));  /* index = quant_4p_4N(posA, n_1) << ((2*n_1)+1); */
-			index = vo_L_add(index, quant_2p_2N1(posB[0], posB[1], n_1));      /* index += quant_2p_2N1(posB[0], posB[1], n_1); */
-			break;
-		case 5:
-			i = 1;                            
-			index = (quant_5p_5N(posA, n_1) << N);       /* index = quant_5p_5N(posA, n_1) << N; */
-			index = vo_L_add(index, quant_1p_N1(posB[0], n_1));        /* index += quant_1p_N1(posB[0], n_1); */
-			break;
-		case 6:
-			i = 0;                             
-			index = (quant_5p_5N(posA, n_1) << N);       /* index = quant_5p_5N(posA, n_1) << N; */
-			index = vo_L_add(index, quant_1p_N1(posA[5], n_1));        /* index += quant_1p_N1(posA[5], n_1); */
-			break;
-		default:
-			index = 0;
-			fprintf(stderr, "Error in function quant_6p_6N_2\n");
-	}
-	index = vo_L_add(index, ((L_deposit_l(i) & 3L) << (Word16) (6 * N - 4)));   /* index += (i & 3) << ((6*N)-4); */
-
-	return (index);
-}
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: q_pulse.c                                                 *
+*                                                                      *
+*      Description: Coding and decoding of algebraic codebook          *
+*                                                                      *
+************************************************************************/
+
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "q_pulse.h"
+
+#define NB_POS 16                          /* pos in track, mask for sign bit */
+
+Word32 quant_1p_N1(                        /* (o) return N+1 bits             */
+		Word16 pos,                        /* (i) position of the pulse       */
+		Word16 N)                          /* (i) number of bits for position */
+{
+	Word16 mask;
+	Word32 index;
+
+	mask = (1 << N) - 1;              /* mask = ((1<<N)-1); */
+	/*-------------------------------------------------------*
+	 * Quantization of 1 pulse with N+1 bits:                *
+	 *-------------------------------------------------------*/
+	index = L_deposit_l((Word16) (pos & mask));
+	if ((pos & NB_POS) != 0)
+	{
+		index = vo_L_add(index, L_deposit_l(1 << N));   /* index += 1 << N; */
+	}
+	return (index);
+}
+
+
+Word32 quant_2p_2N1(                       /* (o) return (2*N)+1 bits         */
+		Word16 pos1,                          /* (i) position of the pulse 1     */
+		Word16 pos2,                          /* (i) position of the pulse 2     */
+		Word16 N)                             /* (i) number of bits for position */
+{
+	Word16 mask, tmp;
+	Word32 index;
+	mask = (1 << N) - 1;              /* mask = ((1<<N)-1); */
+	/*-------------------------------------------------------*
+	 * Quantization of 2 pulses with 2*N+1 bits:             *
+	 *-------------------------------------------------------*/
+	if (((pos2 ^ pos1) & NB_POS) == 0)
+	{
+		/* sign of 1st pulse == sign of 2th pulse */
+		if(pos1 <= pos2)          /* ((pos1 - pos2) <= 0) */
+		{
+			/* index = ((pos1 & mask) << N) + (pos2 & mask); */
+			index = L_deposit_l(add1((((Word16) (pos1 & mask)) << N), ((Word16) (pos2 & mask))));
+		} else
+		{
+			/* ((pos2 & mask) << N) + (pos1 & mask); */
+			index = L_deposit_l(add1((((Word16) (pos2 & mask)) << N), ((Word16) (pos1 & mask))));
+		}
+		if ((pos1 & NB_POS) != 0)
+		{
+			tmp = (N << 1);
+			index = vo_L_add(index, (1L << tmp));       /* index += 1 << (2*N); */
+		}
+	} else
+	{
+		/* sign of 1st pulse != sign of 2th pulse */
+		if (vo_sub((Word16) (pos1 & mask), (Word16) (pos2 & mask)) <= 0)
+		{
+			/* index = ((pos2 & mask) << N) + (pos1 & mask); */
+			index = L_deposit_l(add1((((Word16) (pos2 & mask)) << N), ((Word16) (pos1 & mask))));
+			if ((pos2 & NB_POS) != 0)
+			{
+				tmp = (N << 1);           /* index += 1 << (2*N); */
+				index = vo_L_add(index, (1L << tmp));
+			}
+		} else
+		{
+			/* index = ((pos1 & mask) << N) + (pos2 & mask);	 */
+			index = L_deposit_l(add1((((Word16) (pos1 & mask)) << N), ((Word16) (pos2 & mask))));
+			if ((pos1 & NB_POS) != 0)
+			{
+				tmp = (N << 1);
+				index = vo_L_add(index, (1 << tmp));    /* index += 1 << (2*N); */
+			}
+		}
+	}
+	return (index);
+}
+
+
+Word32 quant_3p_3N1(                       /* (o) return (3*N)+1 bits         */
+		Word16 pos1,                          /* (i) position of the pulse 1     */
+		Word16 pos2,                          /* (i) position of the pulse 2     */
+		Word16 pos3,                          /* (i) position of the pulse 3     */
+		Word16 N)                             /* (i) number of bits for position */
+{
+	Word16 nb_pos;
+	Word32 index;
+
+	nb_pos =(1 <<(N - 1));            /* nb_pos = (1<<(N-1)); */
+	/*-------------------------------------------------------*
+	 * Quantization of 3 pulses with 3*N+1 bits:             *
+	 *-------------------------------------------------------*/
+	if (((pos1 ^ pos2) & nb_pos) == 0)
+	{
+		index = quant_2p_2N1(pos1, pos2, sub(N, 1));    /* index = quant_2p_2N1(pos1, pos2, (N-1)); */
+		/* index += (pos1 & nb_pos) << N; */
+		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N));
+		/* index += quant_1p_N1(pos3, N) << (2*N); */
+		index = vo_L_add(index, (quant_1p_N1(pos3, N)<<(N << 1)));
+
+	} else if (((pos1 ^ pos3) & nb_pos) == 0)
+	{
+		index = quant_2p_2N1(pos1, pos3, sub(N, 1));    /* index = quant_2p_2N1(pos1, pos3, (N-1)); */
+		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N));
+		/* index += (pos1 & nb_pos) << N; */
+		index = vo_L_add(index, (quant_1p_N1(pos2, N) << (N << 1)));
+		/* index += quant_1p_N1(pos2, N) <<
+		 * (2*N); */
+	} else
+	{
+		index = quant_2p_2N1(pos2, pos3, (N - 1));    /* index = quant_2p_2N1(pos2, pos3, (N-1)); */
+		/* index += (pos2 & nb_pos) << N;			 */
+		index = vo_L_add(index, (L_deposit_l((Word16) (pos2 & nb_pos)) << N));
+		/* index += quant_1p_N1(pos1, N) << (2*N);	 */
+		index = vo_L_add(index, (quant_1p_N1(pos1, N) << (N << 1)));
+	}
+	return (index);
+}
+
+
+Word32 quant_4p_4N1(                       /* (o) return (4*N)+1 bits         */
+		Word16 pos1,                          /* (i) position of the pulse 1     */
+		Word16 pos2,                          /* (i) position of the pulse 2     */
+		Word16 pos3,                          /* (i) position of the pulse 3     */
+		Word16 pos4,                          /* (i) position of the pulse 4     */
+		Word16 N)                             /* (i) number of bits for position */
+{
+	Word16 nb_pos;
+	Word32 index;
+
+	nb_pos = 1 << (N - 1);            /* nb_pos = (1<<(N-1));  */
+	/*-------------------------------------------------------*
+	 * Quantization of 4 pulses with 4*N+1 bits:             *
+	 *-------------------------------------------------------*/
+	if (((pos1 ^ pos2) & nb_pos) == 0)
+	{
+		index = quant_2p_2N1(pos1, pos2, sub(N, 1));    /* index = quant_2p_2N1(pos1, pos2, (N-1)); */
+		/* index += (pos1 & nb_pos) << N;	 */
+		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N));
+		/* index += quant_2p_2N1(pos3, pos4, N) << (2*N); */
+		index = vo_L_add(index, (quant_2p_2N1(pos3, pos4, N) << (N << 1)));
+	} else if (((pos1 ^ pos3) & nb_pos) == 0)
+	{
+		index = quant_2p_2N1(pos1, pos3, (N - 1));
+		/* index += (pos1 & nb_pos) << N; */
+		index = vo_L_add(index, (L_deposit_l((Word16) (pos1 & nb_pos)) << N));
+		/* index += quant_2p_2N1(pos2, pos4, N) << (2*N); */
+		index = vo_L_add(index, (quant_2p_2N1(pos2, pos4, N) << (N << 1)));
+	} else
+	{
+		index = quant_2p_2N1(pos2, pos3, (N - 1));
+		/* index += (pos2 & nb_pos) << N; */
+		index = vo_L_add(index, (L_deposit_l((Word16) (pos2 & nb_pos)) << N));
+		/* index += quant_2p_2N1(pos1, pos4, N) << (2*N); */
+		index = vo_L_add(index, (quant_2p_2N1(pos1, pos4, N) << (N << 1)));
+	}
+	return (index);
+}
+
+
+Word32 quant_4p_4N(                        /* (o) return 4*N bits             */
+		Word16 pos[],                         /* (i) position of the pulse 1..4  */
+		Word16 N)                             /* (i) number of bits for position */
+{
+	Word16 nb_pos, mask, n_1, tmp;
+	Word16 posA[4], posB[4];
+	Word32 i, j, k, index;
+
+	n_1 = (Word16) (N - 1);
+	nb_pos = (1 << n_1);                  /* nb_pos = (1<<n_1); */
+	mask = vo_sub((1 << N), 1);              /* mask = ((1<<N)-1); */
+
+	i = 0;
+	j = 0;
+	for (k = 0; k < 4; k++)
+	{
+		if ((pos[k] & nb_pos) == 0)
+		{
+			posA[i++] = pos[k];
+		} else
+		{
+			posB[j++] = pos[k];
+		}
+	}
+
+	switch (i)
+	{
+		case 0:
+			tmp = vo_sub((N << 2), 3);           /* index = 1 << ((4*N)-3); */
+			index = (1L << tmp);
+			/* index += quant_4p_4N1(posB[0], posB[1], posB[2], posB[3], n_1); */
+			index = vo_L_add(index, quant_4p_4N1(posB[0], posB[1], posB[2], posB[3], n_1));
+			break;
+		case 1:
+			/* index = quant_1p_N1(posA[0], n_1) << ((3*n_1)+1); */
+			tmp = add1((Word16)((vo_L_mult(3, n_1) >> 1)), 1);
+			index = L_shl(quant_1p_N1(posA[0], n_1), tmp);
+			/* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1); */
+			index = vo_L_add(index, quant_3p_3N1(posB[0], posB[1], posB[2], n_1));
+			break;
+		case 2:
+			tmp = ((n_1 << 1) + 1);         /* index = quant_2p_2N1(posA[0], posA[1], n_1) << ((2*n_1)+1); */
+			index = L_shl(quant_2p_2N1(posA[0], posA[1], n_1), tmp);
+			/* index += quant_2p_2N1(posB[0], posB[1], n_1); */
+			index = vo_L_add(index, quant_2p_2N1(posB[0], posB[1], n_1));
+			break;
+		case 3:
+			/* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << N; */
+			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), N);
+			index = vo_L_add(index, quant_1p_N1(posB[0], n_1));        /* index += quant_1p_N1(posB[0], n_1); */
+			break;
+		case 4:
+			index = quant_4p_4N1(posA[0], posA[1], posA[2], posA[3], n_1);
+			break;
+		default:
+			index = 0;
+			fprintf(stderr, "Error in function quant_4p_4N\n");
+	}
+	tmp = ((N << 2) - 2);               /* index += (i & 3) << ((4*N)-2); */
+	index = vo_L_add(index, L_shl((L_deposit_l(i) & (3L)), tmp));
+
+	return (index);
+}
+
+
+
+Word32 quant_5p_5N(                        /* (o) return 5*N bits             */
+		Word16 pos[],                         /* (i) position of the pulse 1..5  */
+		Word16 N)                             /* (i) number of bits for position */
+{
+	Word16 nb_pos, n_1, tmp;
+	Word16 posA[5], posB[5];
+	Word32 i, j, k, index, tmp2;
+
+	n_1 = (Word16) (N - 1);
+	nb_pos = (1 << n_1);                  /* nb_pos = (1<<n_1); */
+
+	i = 0;
+	j = 0;
+	for (k = 0; k < 5; k++)
+	{
+		if ((pos[k] & nb_pos) == 0)
+		{
+			posA[i++] = pos[k];
+		} else
+		{
+			posB[j++] = pos[k];
+		}
+	}
+
+	switch (i)
+	{
+		case 0:
+			tmp = vo_sub((Word16)((vo_L_mult(5, N) >> 1)), 1);        /* ((5*N)-1)) */
+			index = L_shl(1L, tmp);   /* index = 1 << ((5*N)-1); */
+			tmp = add1((N << 1), 1);  /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1) << ((2*N)+1);*/
+			tmp2 = L_shl(quant_3p_3N1(posB[0], posB[1], posB[2], n_1), tmp);
+			index = vo_L_add(index, tmp2);
+			index = vo_L_add(index, quant_2p_2N1(posB[3], posB[4], N));        /* index += quant_2p_2N1(posB[3], posB[4], N); */
+			break;
+		case 1:
+			tmp = vo_sub((Word16)((vo_L_mult(5, N) >> 1)), 1);        /* index = 1 << ((5*N)-1); */
+			index = L_shl(1L, tmp);
+			tmp = add1((N << 1), 1);   /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1) <<((2*N)+1);  */
+			tmp2 = L_shl(quant_3p_3N1(posB[0], posB[1], posB[2], n_1), tmp);
+			index = vo_L_add(index, tmp2);
+			index = vo_L_add(index, quant_2p_2N1(posB[3], posA[0], N));        /* index += quant_2p_2N1(posB[3], posA[0], N); */
+			break;
+		case 2:
+			tmp = vo_sub((Word16)((vo_L_mult(5, N) >> 1)), 1);        /* ((5*N)-1)) */
+			index = L_shl(1L, tmp);            /* index = 1 << ((5*N)-1); */
+			tmp = add1((N << 1), 1);           /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1) << ((2*N)+1);  */
+			tmp2 = L_shl(quant_3p_3N1(posB[0], posB[1], posB[2], n_1), tmp);
+			index = vo_L_add(index, tmp2);
+			index = vo_L_add(index, quant_2p_2N1(posA[0], posA[1], N));        /* index += quant_2p_2N1(posA[0], posA[1], N); */
+			break;
+		case 3:
+			tmp = add1((N << 1), 1);           /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((2*N)+1);  */
+			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), tmp);
+			index = vo_L_add(index, quant_2p_2N1(posB[0], posB[1], N));        /* index += quant_2p_2N1(posB[0], posB[1], N); */
+			break;
+		case 4:
+			tmp = add1((N << 1), 1);           /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((2*N)+1);  */
+			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), tmp);
+			index = vo_L_add(index, quant_2p_2N1(posA[3], posB[0], N));        /* index += quant_2p_2N1(posA[3], posB[0], N); */
+			break;
+		case 5:
+			tmp = add1((N << 1), 1);           /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((2*N)+1);  */
+			index = L_shl(quant_3p_3N1(posA[0], posA[1], posA[2], n_1), tmp);
+			index = vo_L_add(index, quant_2p_2N1(posA[3], posA[4], N));        /* index += quant_2p_2N1(posA[3], posA[4], N); */
+			break;
+		default:
+			index = 0;
+			fprintf(stderr, "Error in function quant_5p_5N\n");
+	}
+
+	return (index);
+}
+
+
+Word32 quant_6p_6N_2(                      /* (o) return (6*N)-2 bits         */
+		Word16 pos[],                         /* (i) position of the pulse 1..6  */
+		Word16 N)                             /* (i) number of bits for position */
+{
+	Word16 nb_pos, n_1;
+	Word16 posA[6], posB[6];
+	Word32 i, j, k, index;
+
+	/* !!  N and n_1 are constants -> it doesn't need to be operated by Basic Operators */
+	n_1 = (Word16) (N - 1);
+	nb_pos = (1 << n_1);                  /* nb_pos = (1<<n_1); */
+
+	i = 0;
+	j = 0;
+	for (k = 0; k < 6; k++)
+	{
+		if ((pos[k] & nb_pos) == 0)
+		{
+			posA[i++] = pos[k];
+		} else
+		{
+			posB[j++] = pos[k];
+		}
+	}
+
+	switch (i)
+	{
+		case 0:
+			index = (1 << (Word16) (6 * N - 5));        /* index = 1 << ((6*N)-5); */
+			index = vo_L_add(index, (quant_5p_5N(posB, n_1) << N)); /* index += quant_5p_5N(posB, n_1) << N; */
+			index = vo_L_add(index, quant_1p_N1(posB[5], n_1));        /* index += quant_1p_N1(posB[5], n_1); */
+			break;
+		case 1:
+			index = (1L << (Word16) (6 * N - 5));        /* index = 1 << ((6*N)-5); */
+			index = vo_L_add(index, (quant_5p_5N(posB, n_1) << N)); /* index += quant_5p_5N(posB, n_1) << N; */
+			index = vo_L_add(index, quant_1p_N1(posA[0], n_1));        /* index += quant_1p_N1(posA[0], n_1); */
+			break;
+		case 2:
+			index = (1L << (Word16) (6 * N - 5));        /* index = 1 << ((6*N)-5); */
+			/* index += quant_4p_4N(posB, n_1) << ((2*n_1)+1); */
+			index = vo_L_add(index, (quant_4p_4N(posB, n_1) << (Word16) (2 * n_1 + 1)));
+			index = vo_L_add(index, quant_2p_2N1(posA[0], posA[1], n_1));      /* index += quant_2p_2N1(posA[0], posA[1], n_1); */
+			break;
+		case 3:
+			index = (quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << (Word16) (3 * n_1 + 1));
+			                                  /* index = quant_3p_3N1(posA[0], posA[1], posA[2], n_1) << ((3*n_1)+1); */
+			index =vo_L_add(index, quant_3p_3N1(posB[0], posB[1], posB[2], n_1));
+			                                 /* index += quant_3p_3N1(posB[0], posB[1], posB[2], n_1); */
+			break;
+		case 4:
+			i = 2;
+			index = (quant_4p_4N(posA, n_1) << (Word16) (2 * n_1 + 1));  /* index = quant_4p_4N(posA, n_1) << ((2*n_1)+1); */
+			index = vo_L_add(index, quant_2p_2N1(posB[0], posB[1], n_1));      /* index += quant_2p_2N1(posB[0], posB[1], n_1); */
+			break;
+		case 5:
+			i = 1;
+			index = (quant_5p_5N(posA, n_1) << N);       /* index = quant_5p_5N(posA, n_1) << N; */
+			index = vo_L_add(index, quant_1p_N1(posB[0], n_1));        /* index += quant_1p_N1(posB[0], n_1); */
+			break;
+		case 6:
+			i = 0;
+			index = (quant_5p_5N(posA, n_1) << N);       /* index = quant_5p_5N(posA, n_1) << N; */
+			index = vo_L_add(index, quant_1p_N1(posA[5], n_1));        /* index += quant_1p_N1(posA[5], n_1); */
+			break;
+		default:
+			index = 0;
+			fprintf(stderr, "Error in function quant_6p_6N_2\n");
+	}
+	index = vo_L_add(index, ((L_deposit_l(i) & 3L) << (Word16) (6 * N - 4)));   /* index += (i & 3) << ((6*N)-4); */
+
+	return (index);
+}
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/qisf_ns.c b/media/libstagefright/codecs/amrwbenc/src/qisf_ns.c
index 00b0a53..fc2f00d 100644
--- a/media/libstagefright/codecs/amrwbenc/src/qisf_ns.c
+++ b/media/libstagefright/codecs/amrwbenc/src/qisf_ns.c
@@ -1,111 +1,111 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***************************************************************************
-*      File: qisf_ns.c                                                     *
-*                                                                          *
-*      Description: Coding/Decoding of ISF parameters for background noise.*
-*                    The ISF vector is quantized using VQ with split-by-5  *
-*                                                                          *
-****************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "acelp.h"
-#include "qisf_ns.tab"                     /* Codebooks of ISFs */
-
-/*------------------------------------------------------------------*
-* routine:   Qisf_ns()                                             *
-*            ~~~~~~~~~                                             *
-*------------------------------------------------------------------*/
-
-void Qisf_ns(
-		Word16 * isf1,                        /* input : ISF in the frequency domain (0..0.5) */
-		Word16 * isf_q,                       /* output: quantized ISF                        */
-		Word16 * indice                       /* output: quantization indices                 */
-	    )
-{
-	Word16 i;
-	Word32 tmp;
-
-	for (i = 0; i < ORDER; i++)
-	{
-		isf_q[i] = sub(isf1[i], mean_isf_noise[i]);     
-	}
-
-	indice[0] = Sub_VQ(&isf_q[0], dico1_isf_noise, 2, SIZE_BK_NOISE1, &tmp);    
-	indice[1] = Sub_VQ(&isf_q[2], dico2_isf_noise, 3, SIZE_BK_NOISE2, &tmp);    
-	indice[2] = Sub_VQ(&isf_q[5], dico3_isf_noise, 3, SIZE_BK_NOISE3, &tmp);    
-	indice[3] = Sub_VQ(&isf_q[8], dico4_isf_noise, 4, SIZE_BK_NOISE4, &tmp);    
-	indice[4] = Sub_VQ(&isf_q[12], dico5_isf_noise, 4, SIZE_BK_NOISE5, &tmp);   
-
-	/* decoding the ISFs */
-
-	Disf_ns(indice, isf_q);
-
-	return;
-}
-
-/********************************************************************
-* Function:   Disf_ns()                                             *
-*            ~~~~~~~~~                                              *
-* Decoding of ISF parameters                                        *
-*-------------------------------------------------------------------*
-*  Arguments:                                                       *
-*    indice[] : indices of the selected codebook entries            *
-*    isf[]    : quantized ISFs (in frequency domain)                *
-*********************************************************************/
-
-void Disf_ns(
-		Word16 * indice,                      /* input:  quantization indices                  */
-		Word16 * isf_q                        /* input : ISF in the frequency domain (0..0.5)  */
-	    )
-{
-	Word16 i;
-
-	for (i = 0; i < 2; i++)
-	{
-		isf_q[i] = dico1_isf_noise[indice[0] * 2 + i];  
-	}
-	for (i = 0; i < 3; i++)
-	{
-		isf_q[i + 2] = dico2_isf_noise[indice[1] * 3 + i];      
-	}
-	for (i = 0; i < 3; i++)
-	{
-		isf_q[i + 5] = dico3_isf_noise[indice[2] * 3 + i];      
-	}
-	for (i = 0; i < 4; i++)
-	{
-		isf_q[i + 8] = dico4_isf_noise[indice[3] * 4 + i];      
-	}
-	for (i = 0; i < 4; i++)
-	{
-		isf_q[i + 12] = dico5_isf_noise[indice[4] * 4 + i];     
-	}
-
-	for (i = 0; i < ORDER; i++)
-	{
-		isf_q[i] = add(isf_q[i], mean_isf_noise[i]);   
-	}
-
-	Reorder_isf(isf_q, ISF_GAP, ORDER);
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***************************************************************************
+*      File: qisf_ns.c                                                     *
+*                                                                          *
+*      Description: Coding/Decoding of ISF parameters for background noise.*
+*                    The ISF vector is quantized using VQ with split-by-5  *
+*                                                                          *
+****************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "acelp.h"
+#include "qisf_ns.tab"                     /* Codebooks of ISFs */
+
+/*------------------------------------------------------------------*
+* routine:   Qisf_ns()                                             *
+*            ~~~~~~~~~                                             *
+*------------------------------------------------------------------*/
+
+void Qisf_ns(
+		Word16 * isf1,                        /* input : ISF in the frequency domain (0..0.5) */
+		Word16 * isf_q,                       /* output: quantized ISF                        */
+		Word16 * indice                       /* output: quantization indices                 */
+	    )
+{
+	Word16 i;
+	Word32 tmp;
+
+	for (i = 0; i < ORDER; i++)
+	{
+		isf_q[i] = sub(isf1[i], mean_isf_noise[i]);
+	}
+
+	indice[0] = Sub_VQ(&isf_q[0], dico1_isf_noise, 2, SIZE_BK_NOISE1, &tmp);
+	indice[1] = Sub_VQ(&isf_q[2], dico2_isf_noise, 3, SIZE_BK_NOISE2, &tmp);
+	indice[2] = Sub_VQ(&isf_q[5], dico3_isf_noise, 3, SIZE_BK_NOISE3, &tmp);
+	indice[3] = Sub_VQ(&isf_q[8], dico4_isf_noise, 4, SIZE_BK_NOISE4, &tmp);
+	indice[4] = Sub_VQ(&isf_q[12], dico5_isf_noise, 4, SIZE_BK_NOISE5, &tmp);
+
+	/* decoding the ISFs */
+
+	Disf_ns(indice, isf_q);
+
+	return;
+}
+
+/********************************************************************
+* Function:   Disf_ns()                                             *
+*            ~~~~~~~~~                                              *
+* Decoding of ISF parameters                                        *
+*-------------------------------------------------------------------*
+*  Arguments:                                                       *
+*    indice[] : indices of the selected codebook entries            *
+*    isf[]    : quantized ISFs (in frequency domain)                *
+*********************************************************************/
+
+void Disf_ns(
+		Word16 * indice,                      /* input:  quantization indices                  */
+		Word16 * isf_q                        /* input : ISF in the frequency domain (0..0.5)  */
+	    )
+{
+	Word16 i;
+
+	for (i = 0; i < 2; i++)
+	{
+		isf_q[i] = dico1_isf_noise[indice[0] * 2 + i];
+	}
+	for (i = 0; i < 3; i++)
+	{
+		isf_q[i + 2] = dico2_isf_noise[indice[1] * 3 + i];
+	}
+	for (i = 0; i < 3; i++)
+	{
+		isf_q[i + 5] = dico3_isf_noise[indice[2] * 3 + i];
+	}
+	for (i = 0; i < 4; i++)
+	{
+		isf_q[i + 8] = dico4_isf_noise[indice[3] * 4 + i];
+	}
+	for (i = 0; i < 4; i++)
+	{
+		isf_q[i + 12] = dico5_isf_noise[indice[4] * 4 + i];
+	}
+
+	for (i = 0; i < ORDER; i++)
+	{
+		isf_q[i] = add(isf_q[i], mean_isf_noise[i]);
+	}
+
+	Reorder_isf(isf_q, ISF_GAP, ORDER);
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/qpisf_2s.c b/media/libstagefright/codecs/amrwbenc/src/qpisf_2s.c
index ccedb5c..c711cd0 100644
--- a/media/libstagefright/codecs/amrwbenc/src/qpisf_2s.c
+++ b/media/libstagefright/codecs/amrwbenc/src/qpisf_2s.c
@@ -1,542 +1,542 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: apisf_2s.c                                               *
-*                                                                      *
-*       Description: Coding/Decodeing of ISF parameters with predication
-*       The ISF vector is quantized using two-stage VQ with split-by-2 *
-*       in 1st stage and split-by-5(or 3) in the second stage          *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "cnst.h"
-#include "acelp.h"
-#include "qpisf_2s.tab"                    /* Codebooks of isfs */
-
-#define MU         10923                   /* Prediction factor   (1.0/3.0) in Q15 */
-#define N_SURV_MAX 4                       /* 4 survivors max */
-#define ALPHA      29491                   /* 0. 9 in Q15     */
-#define ONE_ALPHA (32768-ALPHA)            /* (1.0 - ALPHA) in Q15 */
-
-/* private functions */
-static void VQ_stage1(
-		Word16 * x,                           /* input : ISF residual vector           */
-		Word16 * dico,                        /* input : quantization codebook         */
-		Word16 dim,                           /* input : dimention of vector           */
-		Word16 dico_size,                     /* input : size of quantization codebook */
-		Word16 * index,                       /* output: indices of survivors          */
-		Word16 surv                           /* input : number of survivor            */
-		);
-
-/**************************************************************************
-* Function:   Qpisf_2s_46B()                                              *
-*                                                                         *
-* Description: Quantization of isf parameters with prediction. (46 bits)  *
-*                                                                         *
-* The isf vector is quantized using two-stage VQ with split-by-2 in       *
-*  1st stage and split-by-5 in the second stage.                          *
-***************************************************************************/
-
-void Qpisf_2s_46b(
-		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
-		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
-		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
-		Word16 * indice,                      /* (o)     : quantization indices                 */
-		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
-		)
-{
-	Word16 tmp_ind[5];
-	Word16 surv1[N_SURV_MAX];              /* indices of survivors from 1st stage */
-	Word32 i, k, temp, min_err, distance;
-	Word16 isf[ORDER];
-	Word16 isf_stage2[ORDER];
-
-	for (i = 0; i < ORDER; i++)
-	{
-		isf[i] = vo_sub(isf1[i], mean_isf[i]);
-		isf[i] = vo_sub(isf[i], vo_mult(MU, past_isfq[i])); 
-	}
-
-	VQ_stage1(&isf[0], dico1_isf, 9, SIZE_BK1, surv1, nb_surv);
-
-	distance = MAX_32;          
-
-	for (k = 0; k < nb_surv; k++)
-	{
-		for (i = 0; i < 9; i++)
-		{
-			isf_stage2[i] = vo_sub(isf[i], dico1_isf[i + surv1[k] * 9]); 
-		}
-		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico21_isf, 3, SIZE_BK21, &min_err); 
-		temp = min_err;
-		tmp_ind[1] = Sub_VQ(&isf_stage2[3], dico22_isf, 3, SIZE_BK22, &min_err); 
-		temp = vo_L_add(temp, min_err);
-		tmp_ind[2] = Sub_VQ(&isf_stage2[6], dico23_isf, 3, SIZE_BK23, &min_err);  
-		temp = vo_L_add(temp, min_err);
-
-		if(temp < distance)
-		{
-			distance = temp;               
-			indice[0] = surv1[k];          
-			for (i = 0; i < 3; i++)
-			{
-				indice[i + 2] = tmp_ind[i];
-			}
-		}
-	}
-
-
-	VQ_stage1(&isf[9], dico2_isf, 7, SIZE_BK2, surv1, nb_surv);
-
-	distance = MAX_32;                   
-
-	for (k = 0; k < nb_surv; k++)
-	{
-		for (i = 0; i < 7; i++)
-		{
-			isf_stage2[i] = vo_sub(isf[9 + i], dico2_isf[i + surv1[k] * 7]);       
-		}
-
-		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico24_isf, 3, SIZE_BK24, &min_err);
-		temp = min_err; 
-		tmp_ind[1] = Sub_VQ(&isf_stage2[3], dico25_isf, 4, SIZE_BK25, &min_err);
-		temp = vo_L_add(temp, min_err);
-
-		if(temp < distance)
-		{
-			distance = temp;               
-			indice[1] = surv1[k];          
-			for (i = 0; i < 2; i++)
-			{
-				indice[i + 5] = tmp_ind[i];
-			}
-		}
-	}
-
-	Dpisf_2s_46b(indice, isf_q, past_isfq, isf_q, isf_q, 0, 0);
-
-	return;
-}
-
-/*****************************************************************************
-* Function:   Qpisf_2s_36B()                                                 *
-*                                                                            *
-* Description: Quantization of isf parameters with prediction. (36 bits)     *
-*                                                                            *
-* The isf vector is quantized using two-stage VQ with split-by-2 in          *
-*  1st stage and split-by-3 in the second stage.                             *
-******************************************************************************/
-
-void Qpisf_2s_36b(
-		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
-		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
-		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
-		Word16 * indice,                      /* (o)     : quantization indices                 */
-		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
-		)
-{
-	Word16 i, k, tmp_ind[5];
-	Word16 surv1[N_SURV_MAX];              /* indices of survivors from 1st stage */
-	Word32 temp, min_err, distance;
-	Word16 isf[ORDER];
-	Word16 isf_stage2[ORDER];
-
-	for (i = 0; i < ORDER; i++)
-	{
-		isf[i] = vo_sub(isf1[i], mean_isf[i]);
-		isf[i] = vo_sub(isf[i], vo_mult(MU, past_isfq[i]));
-	}
-
-	VQ_stage1(&isf[0], dico1_isf, 9, SIZE_BK1, surv1, nb_surv);
-
-	distance = MAX_32;                  
-
-	for (k = 0; k < nb_surv; k++)
-	{
-		for (i = 0; i < 9; i++)
-		{
-			isf_stage2[i] = vo_sub(isf[i], dico1_isf[i + surv1[k] * 9]); 
-		}
-
-		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico21_isf_36b, 5, SIZE_BK21_36b, &min_err);        
-		temp = min_err;                  
-		tmp_ind[1] = Sub_VQ(&isf_stage2[5], dico22_isf_36b, 4, SIZE_BK22_36b, &min_err);        
-		temp = vo_L_add(temp, min_err);
-
-		if(temp < distance)
-		{
-			distance = temp;               
-			indice[0] = surv1[k];          
-			for (i = 0; i < 2; i++)
-			{
-				indice[i + 2] = tmp_ind[i];
-			}
-		}
-	}
-
-	VQ_stage1(&isf[9], dico2_isf, 7, SIZE_BK2, surv1, nb_surv);
-	distance = MAX_32;                    
-
-	for (k = 0; k < nb_surv; k++)
-	{
-		for (i = 0; i < 7; i++)
-		{
-			isf_stage2[i] = vo_sub(isf[9 + i], dico2_isf[i + surv1[k] * 7]);     
-		}
-
-		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico23_isf_36b, 7, SIZE_BK23_36b, &min_err);  
-		temp = min_err;                  
-
-		if(temp < distance)
-		{
-			distance = temp;               
-			indice[1] = surv1[k];          
-			indice[4] = tmp_ind[0];        
-		}
-	}
-
-	Dpisf_2s_36b(indice, isf_q, past_isfq, isf_q, isf_q, 0, 0);
-
-	return;
-}
-
-/*********************************************************************
-* Function: Dpisf_2s_46b()                                           *
-*                                                                    *
-* Description: Decoding of ISF parameters                            *
-**********************************************************************/
-
-void Dpisf_2s_46b(
-		Word16 * indice,                      /* input:  quantization indices                       */
-		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
-		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
-		Word16 * isfold,                      /* input : past quantized ISF                    */
-		Word16 * isf_buf,                     /* input : isf buffer                                                        */
-		Word16 bfi,                           /* input : Bad frame indicator                   */
-		Word16 enc_dec
-		)
-{
-	Word16 ref_isf[M], tmp;
-	Word32 i, j, L_tmp;
-
-	if (bfi == 0)                          /* Good frame */
-	{
-		for (i = 0; i < 9; i++)
-		{
-			isf_q[i] = dico1_isf[indice[0] * 9 + i];    
-		}
-		for (i = 0; i < 7; i++)
-		{
-			isf_q[i + 9] = dico2_isf[indice[1] * 7 + i];       
-		}
-
-		for (i = 0; i < 3; i++)
-		{
-			isf_q[i] = add1(isf_q[i], dico21_isf[indice[2] * 3 + i]);   
-			isf_q[i + 3] = add1(isf_q[i + 3], dico22_isf[indice[3] * 3 + i]);  
-			isf_q[i + 6] = add1(isf_q[i + 6], dico23_isf[indice[4] * 3 + i]); 
-			isf_q[i + 9] = add1(isf_q[i + 9], dico24_isf[indice[5] * 3 + i]); 
-		}
-
-		for (i = 0; i < 4; i++)
-		{
-			isf_q[i + 12] = add1(isf_q[i + 12], dico25_isf[indice[6] * 4 + i]);  
-		}
-
-		for (i = 0; i < ORDER; i++)
-		{
-			tmp = isf_q[i];               
-			isf_q[i] = add1(tmp, mean_isf[i]);  
-			isf_q[i] = add1(isf_q[i], vo_mult(MU, past_isfq[i]));
-			past_isfq[i] = tmp;  
-		}
-
-		if (enc_dec)
-		{
-			for (i = 0; i < M; i++)
-			{
-				for (j = (L_MEANBUF - 1); j > 0; j--)
-				{
-					isf_buf[j * M + i] = isf_buf[(j - 1) * M + i]; 
-				}
-				isf_buf[i] = isf_q[i]; 
-			}
-		}
-	} else
-	{                                      /* bad frame */
-		for (i = 0; i < M; i++)
-		{
-			L_tmp = mean_isf[i] << 14;
-			for (j = 0; j < L_MEANBUF; j++)
-			{
-				L_tmp += (isf_buf[j * M + i] << 14);
-			}
-			ref_isf[i] = vo_round(L_tmp);
-		}
-
-		/* use the past ISFs slightly shifted towards their mean */
-		for (i = 0; i < ORDER; i++)
-		{
-			isf_q[i] = add1(vo_mult(ALPHA, isfold[i]), vo_mult(ONE_ALPHA, ref_isf[i])); 
-		}
-
-		/* estimate past quantized residual to be used in next frame */
-		for (i = 0; i < ORDER; i++)
-		{
-			tmp = add1(ref_isf[i], vo_mult(past_isfq[i], MU));      /* predicted ISF */
-			past_isfq[i] = vo_sub(isf_q[i], tmp); 
-			past_isfq[i] = (past_isfq[i] >> 1);        /* past_isfq[i] *= 0.5 */
-		}
-	}
-
-	Reorder_isf(isf_q, ISF_GAP, ORDER);
-	return;
-}
-
-/*********************************************************************
-* Function:   Disf_2s_36b()                                          *
-*                                                                    *
-* Description: Decoding of ISF parameters                            *
-*********************************************************************/
-
-void Dpisf_2s_36b(
-		Word16 * indice,                      /* input:  quantization indices                       */
-		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
-		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
-		Word16 * isfold,                      /* input : past quantized ISF                    */
-		Word16 * isf_buf,                     /* input : isf buffer                                                        */
-		Word16 bfi,                           /* input : Bad frame indicator                   */
-		Word16 enc_dec
-		)
-{
-	Word16 ref_isf[M], tmp;
-	Word32 i, j, L_tmp;
-
-	if (bfi == 0)                          /* Good frame */
-	{
-		for (i = 0; i < 9; i++)
-		{
-			isf_q[i] = dico1_isf[indice[0] * 9 + i];    
-		}
-		for (i = 0; i < 7; i++)
-		{
-			isf_q[i + 9] = dico2_isf[indice[1] * 7 + i];       
-		}
-
-		for (i = 0; i < 5; i++)
-		{
-			isf_q[i] = add1(isf_q[i], dico21_isf_36b[indice[2] * 5 + i]);       
-		}
-		for (i = 0; i < 4; i++)
-		{
-			isf_q[i + 5] = add1(isf_q[i + 5], dico22_isf_36b[indice[3] * 4 + i]);        
-		}
-		for (i = 0; i < 7; i++)
-		{
-			isf_q[i + 9] = add1(isf_q[i + 9], dico23_isf_36b[indice[4] * 7 + i]);       
-		}
-
-		for (i = 0; i < ORDER; i++)
-		{
-			tmp = isf_q[i];
-			isf_q[i] = add1(tmp, mean_isf[i]);   
-			isf_q[i] = add1(isf_q[i], vo_mult(MU, past_isfq[i]));   
-			past_isfq[i] = tmp;           
-		}
-
-
-		if (enc_dec)
-		{
-			for (i = 0; i < M; i++)
-			{
-				for (j = (L_MEANBUF - 1); j > 0; j--)
-				{
-					isf_buf[j * M + i] = isf_buf[(j - 1) * M + i];      
-				}
-				isf_buf[i] = isf_q[i];    
-			}
-		}
-	} else
-	{                                      /* bad frame */
-		for (i = 0; i < M; i++)
-		{
-			L_tmp = (mean_isf[i] << 14);
-			for (j = 0; j < L_MEANBUF; j++)
-			{
-				L_tmp += (isf_buf[j * M + i] << 14);
-			}
-			ref_isf[i] = vo_round(L_tmp);    
-		}
-
-		/* use the past ISFs slightly shifted towards their mean */
-		for (i = 0; i < ORDER; i++)
-		{
-			isf_q[i] = add1(vo_mult(ALPHA, isfold[i]), vo_mult(ONE_ALPHA, ref_isf[i]));        
-		}
-
-		/* estimate past quantized residual to be used in next frame */
-		for (i = 0; i < ORDER; i++)
-		{
-			tmp = add1(ref_isf[i], vo_mult(past_isfq[i], MU));      /* predicted ISF */
-			past_isfq[i] = vo_sub(isf_q[i], tmp);  
-			past_isfq[i] = past_isfq[i] >> 1;         /* past_isfq[i] *= 0.5 */
-		}
-	}
-
-	Reorder_isf(isf_q, ISF_GAP, ORDER);
-
-	return;
-}
-
-
-/***************************************************************************
-* Function:  Reorder_isf()                                                 *
-*                                                                          *
-* Description: To make sure that the  isfs are properly order and to       *
-*              keep a certain minimum distance between consecutive isfs.   *
-*--------------------------------------------------------------------------*
-*    Argument         description                     in/out               *
-*                                                                          *
-*     isf[]           vector of isfs                    i/o                *
-*     min_dist        minimum required distance         i                  *
-*     n               LPC order                         i                  *
-****************************************************************************/
-
-void Reorder_isf(
-		Word16 * isf,                         /* (i/o) Q15: ISF in the frequency domain (0..0.5) */
-		Word16 min_dist,                      /* (i) Q15  : minimum distance to keep             */
-		Word16 n                              /* (i)      : number of ISF                        */
-		)
-{
-	Word32 i; 
-	Word16 isf_min;
-
-	isf_min = min_dist;                    
-	for (i = 0; i < n - 1; i++)
-	{
-		if(isf[i] < isf_min)
-		{
-			isf[i] = isf_min;              
-		}
-		isf_min = (isf[i] + min_dist);
-	}
-	return;
-}
-
-
-Word16 Sub_VQ(                             /* output: return quantization index     */
-		Word16 * x,                           /* input : ISF residual vector           */
-		Word16 * dico,                        /* input : quantization codebook         */
-		Word16 dim,                           /* input : dimention of vector           */
-		Word16 dico_size,                     /* input : size of quantization codebook */
-		Word32 * distance                     /* output: error of quantization         */
-	     )
-{
-	Word16 temp, *p_dico;
-	Word32 i, j, index;
-	Word32 dist_min, dist;
-
-	dist_min = MAX_32;                     
-	p_dico = dico;                         
-
-	index = 0;                             
-	for (i = 0; i < dico_size; i++)
-	{
-		dist = 0;  
-
-		for (j = 0; j < dim; j++)
-		{
-			temp = x[j] - (*p_dico++);
-			dist += (temp * temp)<<1;
-		}
-
-		if(dist < dist_min)
-		{
-			dist_min = dist;               
-			index = i;                     
-		}
-	}
-
-	*distance = dist_min;                  
-
-	/* Reading the selected vector */
-	p_dico = &dico[index * dim];           
-	for (j = 0; j < dim; j++)
-	{
-		x[j] = *p_dico++;                  
-	}
-
-	return index;
-}
-
-
-static void VQ_stage1(
-		Word16 * x,                           /* input : ISF residual vector           */
-		Word16 * dico,                        /* input : quantization codebook         */
-		Word16 dim,                           /* input : dimention of vector           */
-		Word16 dico_size,                     /* input : size of quantization codebook */
-		Word16 * index,                       /* output: indices of survivors          */
-		Word16 surv                           /* input : number of survivor            */
-		)
-{
-	Word16 temp, *p_dico;
-	Word32 i, j, k, l;
-	Word32 dist_min[N_SURV_MAX], dist;
-
-	dist_min[0] = MAX_32;
-	dist_min[1] = MAX_32;
-	dist_min[2] = MAX_32;
-	dist_min[3] = MAX_32;
-	index[0] = 0;
-	index[1] = 1;
-	index[2] = 2;
-	index[3] = 3;
-
-	p_dico = dico;                         
-
-	for (i = 0; i < dico_size; i++)
-	{
-		dist = 0;                          
-		for (j = 0; j < dim; j++)
-		{
-			temp = x[j] -  (*p_dico++);
-			dist += (temp * temp)<<1;
-		}
-
-		for (k = 0; k < surv; k++)
-		{
-			if(dist < dist_min[k])
-			{
-				for (l = surv - 1; l > k; l--)
-				{
-					dist_min[l] = dist_min[l - 1];      
-					index[l] = index[l - 1];    
-				}
-				dist_min[k] = dist;        
-				index[k] = i;              
-				break;
-			}
-		}
-	}
-	return;
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: apisf_2s.c                                               *
+*                                                                      *
+*       Description: Coding/Decodeing of ISF parameters with predication
+*       The ISF vector is quantized using two-stage VQ with split-by-2 *
+*       in 1st stage and split-by-5(or 3) in the second stage          *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "cnst.h"
+#include "acelp.h"
+#include "qpisf_2s.tab"                    /* Codebooks of isfs */
+
+#define MU         10923                   /* Prediction factor   (1.0/3.0) in Q15 */
+#define N_SURV_MAX 4                       /* 4 survivors max */
+#define ALPHA      29491                   /* 0. 9 in Q15     */
+#define ONE_ALPHA (32768-ALPHA)            /* (1.0 - ALPHA) in Q15 */
+
+/* private functions */
+static void VQ_stage1(
+		Word16 * x,                           /* input : ISF residual vector           */
+		Word16 * dico,                        /* input : quantization codebook         */
+		Word16 dim,                           /* input : dimention of vector           */
+		Word16 dico_size,                     /* input : size of quantization codebook */
+		Word16 * index,                       /* output: indices of survivors          */
+		Word16 surv                           /* input : number of survivor            */
+		);
+
+/**************************************************************************
+* Function:   Qpisf_2s_46B()                                              *
+*                                                                         *
+* Description: Quantization of isf parameters with prediction. (46 bits)  *
+*                                                                         *
+* The isf vector is quantized using two-stage VQ with split-by-2 in       *
+*  1st stage and split-by-5 in the second stage.                          *
+***************************************************************************/
+
+void Qpisf_2s_46b(
+		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
+		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
+		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
+		Word16 * indice,                      /* (o)     : quantization indices                 */
+		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
+		)
+{
+	Word16 tmp_ind[5];
+	Word16 surv1[N_SURV_MAX];              /* indices of survivors from 1st stage */
+	Word32 i, k, temp, min_err, distance;
+	Word16 isf[ORDER];
+	Word16 isf_stage2[ORDER];
+
+	for (i = 0; i < ORDER; i++)
+	{
+		isf[i] = vo_sub(isf1[i], mean_isf[i]);
+		isf[i] = vo_sub(isf[i], vo_mult(MU, past_isfq[i]));
+	}
+
+	VQ_stage1(&isf[0], dico1_isf, 9, SIZE_BK1, surv1, nb_surv);
+
+	distance = MAX_32;
+
+	for (k = 0; k < nb_surv; k++)
+	{
+		for (i = 0; i < 9; i++)
+		{
+			isf_stage2[i] = vo_sub(isf[i], dico1_isf[i + surv1[k] * 9]);
+		}
+		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico21_isf, 3, SIZE_BK21, &min_err);
+		temp = min_err;
+		tmp_ind[1] = Sub_VQ(&isf_stage2[3], dico22_isf, 3, SIZE_BK22, &min_err);
+		temp = vo_L_add(temp, min_err);
+		tmp_ind[2] = Sub_VQ(&isf_stage2[6], dico23_isf, 3, SIZE_BK23, &min_err);
+		temp = vo_L_add(temp, min_err);
+
+		if(temp < distance)
+		{
+			distance = temp;
+			indice[0] = surv1[k];
+			for (i = 0; i < 3; i++)
+			{
+				indice[i + 2] = tmp_ind[i];
+			}
+		}
+	}
+
+
+	VQ_stage1(&isf[9], dico2_isf, 7, SIZE_BK2, surv1, nb_surv);
+
+	distance = MAX_32;
+
+	for (k = 0; k < nb_surv; k++)
+	{
+		for (i = 0; i < 7; i++)
+		{
+			isf_stage2[i] = vo_sub(isf[9 + i], dico2_isf[i + surv1[k] * 7]);
+		}
+
+		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico24_isf, 3, SIZE_BK24, &min_err);
+		temp = min_err;
+		tmp_ind[1] = Sub_VQ(&isf_stage2[3], dico25_isf, 4, SIZE_BK25, &min_err);
+		temp = vo_L_add(temp, min_err);
+
+		if(temp < distance)
+		{
+			distance = temp;
+			indice[1] = surv1[k];
+			for (i = 0; i < 2; i++)
+			{
+				indice[i + 5] = tmp_ind[i];
+			}
+		}
+	}
+
+	Dpisf_2s_46b(indice, isf_q, past_isfq, isf_q, isf_q, 0, 0);
+
+	return;
+}
+
+/*****************************************************************************
+* Function:   Qpisf_2s_36B()                                                 *
+*                                                                            *
+* Description: Quantization of isf parameters with prediction. (36 bits)     *
+*                                                                            *
+* The isf vector is quantized using two-stage VQ with split-by-2 in          *
+*  1st stage and split-by-3 in the second stage.                             *
+******************************************************************************/
+
+void Qpisf_2s_36b(
+		Word16 * isf1,                        /* (i) Q15 : ISF in the frequency domain (0..0.5) */
+		Word16 * isf_q,                       /* (o) Q15 : quantized ISF               (0..0.5) */
+		Word16 * past_isfq,                   /* (io)Q15 : past ISF quantizer                   */
+		Word16 * indice,                      /* (o)     : quantization indices                 */
+		Word16 nb_surv                        /* (i)     : number of survivor (1, 2, 3 or 4)    */
+		)
+{
+	Word16 i, k, tmp_ind[5];
+	Word16 surv1[N_SURV_MAX];              /* indices of survivors from 1st stage */
+	Word32 temp, min_err, distance;
+	Word16 isf[ORDER];
+	Word16 isf_stage2[ORDER];
+
+	for (i = 0; i < ORDER; i++)
+	{
+		isf[i] = vo_sub(isf1[i], mean_isf[i]);
+		isf[i] = vo_sub(isf[i], vo_mult(MU, past_isfq[i]));
+	}
+
+	VQ_stage1(&isf[0], dico1_isf, 9, SIZE_BK1, surv1, nb_surv);
+
+	distance = MAX_32;
+
+	for (k = 0; k < nb_surv; k++)
+	{
+		for (i = 0; i < 9; i++)
+		{
+			isf_stage2[i] = vo_sub(isf[i], dico1_isf[i + surv1[k] * 9]);
+		}
+
+		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico21_isf_36b, 5, SIZE_BK21_36b, &min_err);
+		temp = min_err;
+		tmp_ind[1] = Sub_VQ(&isf_stage2[5], dico22_isf_36b, 4, SIZE_BK22_36b, &min_err);
+		temp = vo_L_add(temp, min_err);
+
+		if(temp < distance)
+		{
+			distance = temp;
+			indice[0] = surv1[k];
+			for (i = 0; i < 2; i++)
+			{
+				indice[i + 2] = tmp_ind[i];
+			}
+		}
+	}
+
+	VQ_stage1(&isf[9], dico2_isf, 7, SIZE_BK2, surv1, nb_surv);
+	distance = MAX_32;
+
+	for (k = 0; k < nb_surv; k++)
+	{
+		for (i = 0; i < 7; i++)
+		{
+			isf_stage2[i] = vo_sub(isf[9 + i], dico2_isf[i + surv1[k] * 7]);
+		}
+
+		tmp_ind[0] = Sub_VQ(&isf_stage2[0], dico23_isf_36b, 7, SIZE_BK23_36b, &min_err);
+		temp = min_err;
+
+		if(temp < distance)
+		{
+			distance = temp;
+			indice[1] = surv1[k];
+			indice[4] = tmp_ind[0];
+		}
+	}
+
+	Dpisf_2s_36b(indice, isf_q, past_isfq, isf_q, isf_q, 0, 0);
+
+	return;
+}
+
+/*********************************************************************
+* Function: Dpisf_2s_46b()                                           *
+*                                                                    *
+* Description: Decoding of ISF parameters                            *
+**********************************************************************/
+
+void Dpisf_2s_46b(
+		Word16 * indice,                      /* input:  quantization indices                       */
+		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
+		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
+		Word16 * isfold,                      /* input : past quantized ISF                    */
+		Word16 * isf_buf,                     /* input : isf buffer                                                        */
+		Word16 bfi,                           /* input : Bad frame indicator                   */
+		Word16 enc_dec
+		)
+{
+	Word16 ref_isf[M], tmp;
+	Word32 i, j, L_tmp;
+
+	if (bfi == 0)                          /* Good frame */
+	{
+		for (i = 0; i < 9; i++)
+		{
+			isf_q[i] = dico1_isf[indice[0] * 9 + i];
+		}
+		for (i = 0; i < 7; i++)
+		{
+			isf_q[i + 9] = dico2_isf[indice[1] * 7 + i];
+		}
+
+		for (i = 0; i < 3; i++)
+		{
+			isf_q[i] = add1(isf_q[i], dico21_isf[indice[2] * 3 + i]);
+			isf_q[i + 3] = add1(isf_q[i + 3], dico22_isf[indice[3] * 3 + i]);
+			isf_q[i + 6] = add1(isf_q[i + 6], dico23_isf[indice[4] * 3 + i]);
+			isf_q[i + 9] = add1(isf_q[i + 9], dico24_isf[indice[5] * 3 + i]);
+		}
+
+		for (i = 0; i < 4; i++)
+		{
+			isf_q[i + 12] = add1(isf_q[i + 12], dico25_isf[indice[6] * 4 + i]);
+		}
+
+		for (i = 0; i < ORDER; i++)
+		{
+			tmp = isf_q[i];
+			isf_q[i] = add1(tmp, mean_isf[i]);
+			isf_q[i] = add1(isf_q[i], vo_mult(MU, past_isfq[i]));
+			past_isfq[i] = tmp;
+		}
+
+		if (enc_dec)
+		{
+			for (i = 0; i < M; i++)
+			{
+				for (j = (L_MEANBUF - 1); j > 0; j--)
+				{
+					isf_buf[j * M + i] = isf_buf[(j - 1) * M + i];
+				}
+				isf_buf[i] = isf_q[i];
+			}
+		}
+	} else
+	{                                      /* bad frame */
+		for (i = 0; i < M; i++)
+		{
+			L_tmp = mean_isf[i] << 14;
+			for (j = 0; j < L_MEANBUF; j++)
+			{
+				L_tmp += (isf_buf[j * M + i] << 14);
+			}
+			ref_isf[i] = vo_round(L_tmp);
+		}
+
+		/* use the past ISFs slightly shifted towards their mean */
+		for (i = 0; i < ORDER; i++)
+		{
+			isf_q[i] = add1(vo_mult(ALPHA, isfold[i]), vo_mult(ONE_ALPHA, ref_isf[i]));
+		}
+
+		/* estimate past quantized residual to be used in next frame */
+		for (i = 0; i < ORDER; i++)
+		{
+			tmp = add1(ref_isf[i], vo_mult(past_isfq[i], MU));      /* predicted ISF */
+			past_isfq[i] = vo_sub(isf_q[i], tmp);
+			past_isfq[i] = (past_isfq[i] >> 1);        /* past_isfq[i] *= 0.5 */
+		}
+	}
+
+	Reorder_isf(isf_q, ISF_GAP, ORDER);
+	return;
+}
+
+/*********************************************************************
+* Function:   Disf_2s_36b()                                          *
+*                                                                    *
+* Description: Decoding of ISF parameters                            *
+*********************************************************************/
+
+void Dpisf_2s_36b(
+		Word16 * indice,                      /* input:  quantization indices                       */
+		Word16 * isf_q,                       /* output: quantized ISF in frequency domain (0..0.5) */
+		Word16 * past_isfq,                   /* i/0   : past ISF quantizer                    */
+		Word16 * isfold,                      /* input : past quantized ISF                    */
+		Word16 * isf_buf,                     /* input : isf buffer                                                        */
+		Word16 bfi,                           /* input : Bad frame indicator                   */
+		Word16 enc_dec
+		)
+{
+	Word16 ref_isf[M], tmp;
+	Word32 i, j, L_tmp;
+
+	if (bfi == 0)                          /* Good frame */
+	{
+		for (i = 0; i < 9; i++)
+		{
+			isf_q[i] = dico1_isf[indice[0] * 9 + i];
+		}
+		for (i = 0; i < 7; i++)
+		{
+			isf_q[i + 9] = dico2_isf[indice[1] * 7 + i];
+		}
+
+		for (i = 0; i < 5; i++)
+		{
+			isf_q[i] = add1(isf_q[i], dico21_isf_36b[indice[2] * 5 + i]);
+		}
+		for (i = 0; i < 4; i++)
+		{
+			isf_q[i + 5] = add1(isf_q[i + 5], dico22_isf_36b[indice[3] * 4 + i]);
+		}
+		for (i = 0; i < 7; i++)
+		{
+			isf_q[i + 9] = add1(isf_q[i + 9], dico23_isf_36b[indice[4] * 7 + i]);
+		}
+
+		for (i = 0; i < ORDER; i++)
+		{
+			tmp = isf_q[i];
+			isf_q[i] = add1(tmp, mean_isf[i]);
+			isf_q[i] = add1(isf_q[i], vo_mult(MU, past_isfq[i]));
+			past_isfq[i] = tmp;
+		}
+
+
+		if (enc_dec)
+		{
+			for (i = 0; i < M; i++)
+			{
+				for (j = (L_MEANBUF - 1); j > 0; j--)
+				{
+					isf_buf[j * M + i] = isf_buf[(j - 1) * M + i];
+				}
+				isf_buf[i] = isf_q[i];
+			}
+		}
+	} else
+	{                                      /* bad frame */
+		for (i = 0; i < M; i++)
+		{
+			L_tmp = (mean_isf[i] << 14);
+			for (j = 0; j < L_MEANBUF; j++)
+			{
+				L_tmp += (isf_buf[j * M + i] << 14);
+			}
+			ref_isf[i] = vo_round(L_tmp);
+		}
+
+		/* use the past ISFs slightly shifted towards their mean */
+		for (i = 0; i < ORDER; i++)
+		{
+			isf_q[i] = add1(vo_mult(ALPHA, isfold[i]), vo_mult(ONE_ALPHA, ref_isf[i]));
+		}
+
+		/* estimate past quantized residual to be used in next frame */
+		for (i = 0; i < ORDER; i++)
+		{
+			tmp = add1(ref_isf[i], vo_mult(past_isfq[i], MU));      /* predicted ISF */
+			past_isfq[i] = vo_sub(isf_q[i], tmp);
+			past_isfq[i] = past_isfq[i] >> 1;         /* past_isfq[i] *= 0.5 */
+		}
+	}
+
+	Reorder_isf(isf_q, ISF_GAP, ORDER);
+
+	return;
+}
+
+
+/***************************************************************************
+* Function:  Reorder_isf()                                                 *
+*                                                                          *
+* Description: To make sure that the  isfs are properly order and to       *
+*              keep a certain minimum distance between consecutive isfs.   *
+*--------------------------------------------------------------------------*
+*    Argument         description                     in/out               *
+*                                                                          *
+*     isf[]           vector of isfs                    i/o                *
+*     min_dist        minimum required distance         i                  *
+*     n               LPC order                         i                  *
+****************************************************************************/
+
+void Reorder_isf(
+		Word16 * isf,                         /* (i/o) Q15: ISF in the frequency domain (0..0.5) */
+		Word16 min_dist,                      /* (i) Q15  : minimum distance to keep             */
+		Word16 n                              /* (i)      : number of ISF                        */
+		)
+{
+	Word32 i;
+	Word16 isf_min;
+
+	isf_min = min_dist;
+	for (i = 0; i < n - 1; i++)
+	{
+		if(isf[i] < isf_min)
+		{
+			isf[i] = isf_min;
+		}
+		isf_min = (isf[i] + min_dist);
+	}
+	return;
+}
+
+
+Word16 Sub_VQ(                             /* output: return quantization index     */
+		Word16 * x,                           /* input : ISF residual vector           */
+		Word16 * dico,                        /* input : quantization codebook         */
+		Word16 dim,                           /* input : dimention of vector           */
+		Word16 dico_size,                     /* input : size of quantization codebook */
+		Word32 * distance                     /* output: error of quantization         */
+	     )
+{
+	Word16 temp, *p_dico;
+	Word32 i, j, index;
+	Word32 dist_min, dist;
+
+	dist_min = MAX_32;
+	p_dico = dico;
+
+	index = 0;
+	for (i = 0; i < dico_size; i++)
+	{
+		dist = 0;
+
+		for (j = 0; j < dim; j++)
+		{
+			temp = x[j] - (*p_dico++);
+			dist += (temp * temp)<<1;
+		}
+
+		if(dist < dist_min)
+		{
+			dist_min = dist;
+			index = i;
+		}
+	}
+
+	*distance = dist_min;
+
+	/* Reading the selected vector */
+	p_dico = &dico[index * dim];
+	for (j = 0; j < dim; j++)
+	{
+		x[j] = *p_dico++;
+	}
+
+	return index;
+}
+
+
+static void VQ_stage1(
+		Word16 * x,                           /* input : ISF residual vector           */
+		Word16 * dico,                        /* input : quantization codebook         */
+		Word16 dim,                           /* input : dimention of vector           */
+		Word16 dico_size,                     /* input : size of quantization codebook */
+		Word16 * index,                       /* output: indices of survivors          */
+		Word16 surv                           /* input : number of survivor            */
+		)
+{
+	Word16 temp, *p_dico;
+	Word32 i, j, k, l;
+	Word32 dist_min[N_SURV_MAX], dist;
+
+	dist_min[0] = MAX_32;
+	dist_min[1] = MAX_32;
+	dist_min[2] = MAX_32;
+	dist_min[3] = MAX_32;
+	index[0] = 0;
+	index[1] = 1;
+	index[2] = 2;
+	index[3] = 3;
+
+	p_dico = dico;
+
+	for (i = 0; i < dico_size; i++)
+	{
+		dist = 0;
+		for (j = 0; j < dim; j++)
+		{
+			temp = x[j] -  (*p_dico++);
+			dist += (temp * temp)<<1;
+		}
+
+		for (k = 0; k < surv; k++)
+		{
+			if(dist < dist_min[k])
+			{
+				for (l = surv - 1; l > k; l--)
+				{
+					dist_min[l] = dist_min[l - 1];
+					index[l] = index[l - 1];
+				}
+				dist_min[k] = dist;
+				index[k] = i;
+				break;
+			}
+		}
+	}
+	return;
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/random.c b/media/libstagefright/codecs/amrwbenc/src/random.c
index 8baa8bf..b896863 100644
--- a/media/libstagefright/codecs/amrwbenc/src/random.c
+++ b/media/libstagefright/codecs/amrwbenc/src/random.c
@@ -1,33 +1,33 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: random.c                                                 *
-*                                                                      *
-*       Description: Signed 16 bits random generator                   *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-Word16 Random(Word16 * seed)
-{
-	/* static Word16 seed = 21845; */
-	*seed = (Word16)(L_add((L_mult(*seed, 31821) >> 1), 13849L));
-	return (*seed);
-}
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: random.c                                                 *
+*                                                                      *
+*       Description: Signed 16 bits random generator                   *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+Word16 Random(Word16 * seed)
+{
+	/* static Word16 seed = 21845; */
+	*seed = (Word16)(L_add((L_mult(*seed, 31821) >> 1), 13849L));
+	return (*seed);
+}
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/residu.c b/media/libstagefright/codecs/amrwbenc/src/residu.c
index 6829882..b0c04b5 100644
--- a/media/libstagefright/codecs/amrwbenc/src/residu.c
+++ b/media/libstagefright/codecs/amrwbenc/src/residu.c
@@ -1,67 +1,67 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*  File: residu.c                                                      *
-*                                                                      *
-*  Description: Compute the LPC residual by filtering                  *
-*             the input speech through A(z)                            *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-void Residu(
-		Word16 a[],                           /* (i) Q12 : prediction coefficients                     */
-		Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed         */
-		Word16 y[],                           /* (o) x2  : residual signal                             */
-		Word16 lg                             /* (i)     : size of filtering                           */
-		)
-{
-	Word16 i,*p1, *p2;
-	Word32 s;
-	for (i = 0; i < lg; i++)
-	{
-		p1 = a;
-		p2 = &x[i];
-		s  = vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1++), (*p2--));
-		s += vo_mult32((*p1), (*p2));
-
-		s = L_shl2(s, 5); 
-		y[i] = extract_h(L_add(s, 0x8000));
-	}
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*  File: residu.c                                                      *
+*                                                                      *
+*  Description: Compute the LPC residual by filtering                  *
+*             the input speech through A(z)                            *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+void Residu(
+		Word16 a[],                           /* (i) Q12 : prediction coefficients                     */
+		Word16 x[],                           /* (i)     : speech (values x[-m..-1] are needed         */
+		Word16 y[],                           /* (o) x2  : residual signal                             */
+		Word16 lg                             /* (i)     : size of filtering                           */
+		)
+{
+	Word16 i,*p1, *p2;
+	Word32 s;
+	for (i = 0; i < lg; i++)
+	{
+		p1 = a;
+		p2 = &x[i];
+		s  = vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1++), (*p2--));
+		s += vo_mult32((*p1), (*p2));
+
+		s = L_shl2(s, 5);
+		y[i] = extract_h(L_add(s, 0x8000));
+	}
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/scale.c b/media/libstagefright/codecs/amrwbenc/src/scale.c
index af40121..418cc06 100644
--- a/media/libstagefright/codecs/amrwbenc/src/scale.c
+++ b/media/libstagefright/codecs/amrwbenc/src/scale.c
@@ -1,57 +1,57 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: scale.c                                                  *
-*                                                                      *
-*       Description: Scale signal to get maximum of dynamic            *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-void Scale_sig(
-		Word16 x[],                           /* (i/o) : signal to scale               */
-		Word16 lg,                            /* (i)   : size of x[]                   */
-		Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
-	      )
-{
-	Word32 i;
-	Word32 L_tmp;
-	if(exp > 0)
-	{
-		for (i = lg - 1 ; i >= 0; i--)
-		{
-			L_tmp = L_shl2(x[i], 16 + exp);  
-			x[i] = extract_h(L_add(L_tmp, 0x8000));            
-		}
-	}
-	else
-	{
-		exp = -exp;
-		for (i = lg - 1; i >= 0; i--)
-		{
-			L_tmp = x[i] << 16;
-			L_tmp >>= exp; 
-			x[i] = (L_tmp + 0x8000)>>16;            
-		}
-	}
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: scale.c                                                  *
+*                                                                      *
+*       Description: Scale signal to get maximum of dynamic            *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+void Scale_sig(
+		Word16 x[],                           /* (i/o) : signal to scale               */
+		Word16 lg,                            /* (i)   : size of x[]                   */
+		Word16 exp                            /* (i)   : exponent: x = round(x << exp) */
+	      )
+{
+	Word32 i;
+	Word32 L_tmp;
+	if(exp > 0)
+	{
+		for (i = lg - 1 ; i >= 0; i--)
+		{
+			L_tmp = L_shl2(x[i], 16 + exp);
+			x[i] = extract_h(L_add(L_tmp, 0x8000));
+		}
+	}
+	else
+	{
+		exp = -exp;
+		for (i = lg - 1; i >= 0; i--)
+		{
+			L_tmp = x[i] << 16;
+			L_tmp >>= exp;
+			x[i] = (L_tmp + 0x8000)>>16;
+		}
+	}
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/stream.c b/media/libstagefright/codecs/amrwbenc/src/stream.c
index a708235..780f009 100644
--- a/media/libstagefright/codecs/amrwbenc/src/stream.c
+++ b/media/libstagefright/codecs/amrwbenc/src/stream.c
@@ -1,58 +1,58 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: stream.c                                                 *
-*                                                                      *
-*       Description: VOME API Buffer Operator Implement Code           *
-*                                                                      *
-************************************************************************/
-
-#include "stream.h"
-
-void voAWB_InitFrameBuffer(FrameStream *stream)
-{
-	stream->set_ptr = NULL;
-	stream->frame_ptr_bk = stream->frame_ptr;
-	stream->set_len = 0;
-	stream->framebuffer_len = 0;
-	stream->frame_storelen = 0;	
-}
-
-void voAWB_UpdateFrameBuffer(
-		FrameStream *stream, 
-		VO_MEM_OPERATOR *pMemOP
-		)
-{
-	int  len;
-	len  = MIN(Frame_Maxsize - stream->frame_storelen, stream->set_len);
-	pMemOP->Copy(VO_INDEX_ENC_AMRWB, stream->frame_ptr_bk + stream->frame_storelen , stream->set_ptr, len);
-	stream->set_len -= len;
-	stream->set_ptr += len;
-	stream->framebuffer_len = stream->frame_storelen + len;
-	stream->frame_ptr = stream->frame_ptr_bk;
-	stream->used_len += len;
-}
-
-void voAWB_FlushFrameBuffer(FrameStream *stream)
-{
-	stream->set_ptr = NULL;
-	stream->frame_ptr_bk = stream->frame_ptr;
-	stream->set_len = 0;
-	stream->framebuffer_len = 0;
-	stream->frame_storelen = 0;	
-}
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: stream.c                                                 *
+*                                                                      *
+*       Description: VOME API Buffer Operator Implement Code           *
+*                                                                      *
+************************************************************************/
+
+#include "stream.h"
+
+void voAWB_InitFrameBuffer(FrameStream *stream)
+{
+	stream->set_ptr = NULL;
+	stream->frame_ptr_bk = stream->frame_ptr;
+	stream->set_len = 0;
+	stream->framebuffer_len = 0;
+	stream->frame_storelen = 0;
+}
+
+void voAWB_UpdateFrameBuffer(
+		FrameStream *stream,
+		VO_MEM_OPERATOR *pMemOP
+		)
+{
+	int  len;
+	len  = MIN(Frame_Maxsize - stream->frame_storelen, stream->set_len);
+	pMemOP->Copy(VO_INDEX_ENC_AMRWB, stream->frame_ptr_bk + stream->frame_storelen , stream->set_ptr, len);
+	stream->set_len -= len;
+	stream->set_ptr += len;
+	stream->framebuffer_len = stream->frame_storelen + len;
+	stream->frame_ptr = stream->frame_ptr_bk;
+	stream->used_len += len;
+}
+
+void voAWB_FlushFrameBuffer(FrameStream *stream)
+{
+	stream->set_ptr = NULL;
+	stream->frame_ptr_bk = stream->frame_ptr;
+	stream->set_len = 0;
+	stream->framebuffer_len = 0;
+	stream->frame_storelen = 0;
+}
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/syn_filt.c b/media/libstagefright/codecs/amrwbenc/src/syn_filt.c
index 6c1fb8e..1bda05a 100644
--- a/media/libstagefright/codecs/amrwbenc/src/syn_filt.c
+++ b/media/libstagefright/codecs/amrwbenc/src/syn_filt.c
@@ -1,160 +1,160 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: syn_filt.c                                               *
-*                                                                      *
-*       Description: Do the synthesis filtering 1/A(z)                 *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-#include "cnst.h"
-
-void Syn_filt(
-		Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
-		Word16 x[],                           /* (i)     : input signal                             */
-		Word16 y[],                           /* (o)     : output signal                            */
-		Word16 lg,                            /* (i)     : size of filtering                        */
-		Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
-		Word16 update                         /* (i)     : 0=no update, 1=update of memory.         */
-	     )
-{
-	Word32 i, a0;
-	Word16 y_buf[L_SUBFR16k + M16k];
-	Word32 L_tmp;
-	Word16 *yy, *p1, *p2;
-	yy = &y_buf[0];                        
-	/* copy initial filter states into synthesis buffer */
-	for (i = 0; i < 16; i++)
-	{
-		*yy++ = mem[i];                    
-	}
-	a0 = (a[0] >> 1);                     /* input / 2 */
-	/* Do the filtering. */
-	for (i = 0; i < lg; i++)
-	{
-		p1 = &a[1];
-		p2 = &yy[i-1];
-		L_tmp  = vo_mult32(a0, x[i]);
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1++), (*p2--));
-		L_tmp -= vo_mult32((*p1), (*p2));
-
-		L_tmp = L_shl2(L_tmp, 4);
-		y[i] = yy[i] = extract_h(L_add(L_tmp, 0x8000));  
-	}
-	/* Update memory if required */
-	if (update)
-		for (i = 0; i < 16; i++)
-		{
-			mem[i] = yy[lg - 16 + i];
-		}
-	return;
-}
-
-
-void Syn_filt_32(
-		Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
-		Word16 m,                             /* (i)     : order of LP filter             */
-		Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
-		Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
-		Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
-		Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
-		Word16 lg                             /* (i)     : size of filtering              */
-		)
-{
-	Word32 i,a0;
-	Word32 L_tmp, L_tmp1;
-	Word16 *p1, *p2, *p3;
-	a0 = a[0] >> (4 + Qnew);          /* input / 16 and >>Qnew */
-	/* Do the filtering. */
-	for (i = 0; i < lg; i++)
-	{
-		L_tmp  = 0; 
-		L_tmp1 = 0;
-		p1 = a;
-		p2 = &sig_lo[i - 1];
-		p3 = &sig_hi[i - 1];
-
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-		L_tmp  -= vo_mult32((*p2--), (*p1));
-		L_tmp1 -= vo_mult32((*p3--), (*p1++));
-
-		L_tmp = L_tmp >> 11;      
-		L_tmp += vo_L_mult(exc[i], a0);
-
-		/* sig_hi = bit16 to bit31 of synthesis */
-		L_tmp = L_tmp - (L_tmp1<<1);
-
-		L_tmp = L_tmp >> 3;           /* ai in Q12 */
-		sig_hi[i] = extract_h(L_tmp);      
-
-		/* sig_lo = bit4 to bit15 of synthesis */
-		L_tmp >>= 4;           /* 4 : sig_lo[i] >> 4 */
-		sig_lo[i] = (Word16)((L_tmp - (sig_hi[i] << 13)));  
-	}
-
-	return;
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: syn_filt.c                                               *
+*                                                                      *
+*       Description: Do the synthesis filtering 1/A(z)                 *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+#include "cnst.h"
+
+void Syn_filt(
+		Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients           */
+		Word16 x[],                           /* (i)     : input signal                             */
+		Word16 y[],                           /* (o)     : output signal                            */
+		Word16 lg,                            /* (i)     : size of filtering                        */
+		Word16 mem[],                         /* (i/o)   : memory associated with this filtering.   */
+		Word16 update                         /* (i)     : 0=no update, 1=update of memory.         */
+	     )
+{
+	Word32 i, a0;
+	Word16 y_buf[L_SUBFR16k + M16k];
+	Word32 L_tmp;
+	Word16 *yy, *p1, *p2;
+	yy = &y_buf[0];
+	/* copy initial filter states into synthesis buffer */
+	for (i = 0; i < 16; i++)
+	{
+		*yy++ = mem[i];
+	}
+	a0 = (a[0] >> 1);                     /* input / 2 */
+	/* Do the filtering. */
+	for (i = 0; i < lg; i++)
+	{
+		p1 = &a[1];
+		p2 = &yy[i-1];
+		L_tmp  = vo_mult32(a0, x[i]);
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1++), (*p2--));
+		L_tmp -= vo_mult32((*p1), (*p2));
+
+		L_tmp = L_shl2(L_tmp, 4);
+		y[i] = yy[i] = extract_h(L_add(L_tmp, 0x8000));
+	}
+	/* Update memory if required */
+	if (update)
+		for (i = 0; i < 16; i++)
+		{
+			mem[i] = yy[lg - 16 + i];
+		}
+	return;
+}
+
+
+void Syn_filt_32(
+		Word16 a[],                           /* (i) Q12 : a[m+1] prediction coefficients */
+		Word16 m,                             /* (i)     : order of LP filter             */
+		Word16 exc[],                         /* (i) Qnew: excitation (exc[i] >> Qnew)    */
+		Word16 Qnew,                          /* (i)     : exc scaling = 0(min) to 8(max) */
+		Word16 sig_hi[],                      /* (o) /16 : synthesis high                 */
+		Word16 sig_lo[],                      /* (o) /16 : synthesis low                  */
+		Word16 lg                             /* (i)     : size of filtering              */
+		)
+{
+	Word32 i,a0;
+	Word32 L_tmp, L_tmp1;
+	Word16 *p1, *p2, *p3;
+	a0 = a[0] >> (4 + Qnew);          /* input / 16 and >>Qnew */
+	/* Do the filtering. */
+	for (i = 0; i < lg; i++)
+	{
+		L_tmp  = 0;
+		L_tmp1 = 0;
+		p1 = a;
+		p2 = &sig_lo[i - 1];
+		p3 = &sig_hi[i - 1];
+
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+		L_tmp  -= vo_mult32((*p2--), (*p1));
+		L_tmp1 -= vo_mult32((*p3--), (*p1++));
+
+		L_tmp = L_tmp >> 11;
+		L_tmp += vo_L_mult(exc[i], a0);
+
+		/* sig_hi = bit16 to bit31 of synthesis */
+		L_tmp = L_tmp - (L_tmp1<<1);
+
+		L_tmp = L_tmp >> 3;           /* ai in Q12 */
+		sig_hi[i] = extract_h(L_tmp);
+
+		/* sig_lo = bit4 to bit15 of synthesis */
+		L_tmp >>= 4;           /* 4 : sig_lo[i] >> 4 */
+		sig_lo[i] = (Word16)((L_tmp - (sig_hi[i] << 13)));
+	}
+
+	return;
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/updt_tar.c b/media/libstagefright/codecs/amrwbenc/src/updt_tar.c
index f3e5650..96779fd 100644
--- a/media/libstagefright/codecs/amrwbenc/src/updt_tar.c
+++ b/media/libstagefright/codecs/amrwbenc/src/updt_tar.c
@@ -1,49 +1,49 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: updt_tar.c                                               *
-*                                                                      *
-*       Description: Update the target vector for codebook search      *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-void Updt_tar(
-		Word16 * x,                           /* (i) Q0  : old target (for pitch search)     */
-		Word16 * x2,                          /* (o) Q0  : new target (for codebook search)  */
-		Word16 * y,                           /* (i) Q0  : filtered adaptive codebook vector */
-		Word16 gain,                          /* (i) Q14 : adaptive codebook gain            */
-		Word16 L                              /* (i)     : subframe size                     */
-	     )
-{
-	Word32 i;
-	Word32 L_tmp;
-
-	for (i = 0; i < L; i++)
-	{
-		L_tmp = x[i] << 15;
-		L_tmp -= (y[i] * gain)<<1;
-		x2[i] = extract_h(L_shl2(L_tmp, 1)); 
-	}
-
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: updt_tar.c                                               *
+*                                                                      *
+*       Description: Update the target vector for codebook search      *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+void Updt_tar(
+		Word16 * x,                           /* (i) Q0  : old target (for pitch search)     */
+		Word16 * x2,                          /* (o) Q0  : new target (for codebook search)  */
+		Word16 * y,                           /* (i) Q0  : filtered adaptive codebook vector */
+		Word16 gain,                          /* (i) Q14 : adaptive codebook gain            */
+		Word16 L                              /* (i)     : subframe size                     */
+	     )
+{
+	Word32 i;
+	Word32 L_tmp;
+
+	for (i = 0; i < L; i++)
+	{
+		L_tmp = x[i] << 15;
+		L_tmp -= (y[i] * gain)<<1;
+		x2[i] = extract_h(L_shl2(L_tmp, 1));
+	}
+
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/util.c b/media/libstagefright/codecs/amrwbenc/src/util.c
index 78141dd..76ab1b1 100644
--- a/media/libstagefright/codecs/amrwbenc/src/util.c
+++ b/media/libstagefright/codecs/amrwbenc/src/util.c
@@ -1,74 +1,74 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: util.c                                                   *
-*                                                                      *
-*       Description: Reset and Copy buffer                             *
-*                                                                      *
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-/***********************************************************************
-* Function:  Set_zero()                                             *
-* Description: Set vector x[] to zero                               *
-************************************************************************/
-
-void Set_zero(
-		Word16 x[],                           /* (o)    : vector to clear     */
-		Word16 L                              /* (i)    : length of vector    */
-	     )
-{
-	Word32 num = (Word32)L;
-	do{
-		*x++ = 0;
-	}while(--num !=0);
-}
-
-
-/*********************************************************************
-* Function: Copy()                                                   *
-*                                                                    *
-* Description: Copy vector x[] to y[]                                *
-*********************************************************************/
-
-void Copy(
-		Word16 x[],                           /* (i)   : input vector   */
-		Word16 y[],                           /* (o)   : output vector  */
-		Word16 L                              /* (i)   : vector length  */
-	 )
-{
-	Word32	temp1,temp2,num;
-	if(L&1)
-	{
-		temp1 = *x++;
-		*y++ = temp1;
-	}
-	num = (Word32)(L>>1);
-	temp1 = *x++;
-	temp2 = *x++;
-	do{
-		*y++ = temp1;
-		*y++ = temp2;
-		temp1 = *x++;
-		temp2 = *x++;
-	}while(--num!=0);
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: util.c                                                   *
+*                                                                      *
+*       Description: Reset and Copy buffer                             *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+/***********************************************************************
+* Function:  Set_zero()                                             *
+* Description: Set vector x[] to zero                               *
+************************************************************************/
+
+void Set_zero(
+		Word16 x[],                           /* (o)    : vector to clear     */
+		Word16 L                              /* (i)    : length of vector    */
+	     )
+{
+	Word32 num = (Word32)L;
+	do{
+		*x++ = 0;
+	}while(--num !=0);
+}
+
+
+/*********************************************************************
+* Function: Copy()                                                   *
+*                                                                    *
+* Description: Copy vector x[] to y[]                                *
+*********************************************************************/
+
+void Copy(
+		Word16 x[],                           /* (i)   : input vector   */
+		Word16 y[],                           /* (o)   : output vector  */
+		Word16 L                              /* (i)   : vector length  */
+	 )
+{
+	Word32	temp1,temp2,num;
+	if(L&1)
+	{
+		temp1 = *x++;
+		*y++ = temp1;
+	}
+	num = (Word32)(L>>1);
+	temp1 = *x++;
+	temp2 = *x++;
+	do{
+		*y++ = temp1;
+		*y++ = temp2;
+		temp1 = *x++;
+		temp2 = *x++;
+	}while(--num!=0);
+}
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/voAMRWBEnc.c b/media/libstagefright/codecs/amrwbenc/src/voAMRWBEnc.c
index d0d99a7..0f4d689 100644
--- a/media/libstagefright/codecs/amrwbenc/src/voAMRWBEnc.c
+++ b/media/libstagefright/codecs/amrwbenc/src/voAMRWBEnc.c
@@ -1,1941 +1,1941 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: voAMRWBEnc.c                                              *
-*                                                                      *
-*      Description: Performs the main encoder routine                  *
-*                   Fixed-point C simulation of AMR WB ACELP coding    *
-*		    algorithm with 20 msspeech frames for              *
-*		    wideband speech signals.                           *
-*                                                                      *
-************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "typedef.h"
-#include "basic_op.h"
-#include "oper_32b.h"
-#include "math_op.h"
-#include "cnst.h"
-#include "acelp.h"
-#include "cod_main.h"
-#include "bits.h"
-#include "main.h"
-#include "voAMRWB.h"
-#include "mem_align.h"
-#include "cmnMemory.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* LPC interpolation coef {0.45, 0.8, 0.96, 1.0}; in Q15 */
-static Word16 interpol_frac[NB_SUBFR] = {14746, 26214, 31457, 32767};
-
-/* isp tables for initialization */
-static Word16 isp_init[M] =
-{
-	32138, 30274, 27246, 23170, 18205, 12540, 6393, 0,
-	-6393, -12540, -18205, -23170, -27246, -30274, -32138, 1475
-};
-
-static Word16 isf_init[M] =
-{
-	1024, 2048, 3072, 4096, 5120, 6144, 7168, 8192,
-	9216, 10240, 11264, 12288, 13312, 14336, 15360, 3840
-};
-
-/* High Band encoding */
-static const Word16 HP_gain[16] =
-{
-	3624, 4673, 5597, 6479, 7425, 8378, 9324, 10264,
-	11210, 12206, 13391, 14844, 16770, 19655, 24289, 32728
-};
-
-/* Private function declaration */
-static Word16 synthesis(
-			Word16 Aq[],                          /* A(z)  : quantized Az               */
-			Word16 exc[],                         /* (i)   : excitation at 12kHz        */
-			Word16 Q_new,                         /* (i)   : scaling performed on exc   */
-			Word16 synth16k[],                    /* (o)   : 16kHz synthesis signal     */
-			Coder_State * st                      /* (i/o) : State structure            */
-			);
-
-/* Codec some parameters initialization */
-void Reset_encoder(void *st, Word16 reset_all)
-{
-	Word16 i;
-	Coder_State *cod_state;
-	cod_state = (Coder_State *) st;
-	Set_zero(cod_state->old_exc, PIT_MAX + L_INTERPOL);
-	Set_zero(cod_state->mem_syn, M);
-	Set_zero(cod_state->past_isfq, M);
-	cod_state->mem_w0 = 0;                 
-	cod_state->tilt_code = 0;              
-	cod_state->first_frame = 1;            
-	Init_gp_clip(cod_state->gp_clip);
-	cod_state->L_gc_thres = 0;             
-	if (reset_all != 0)
-	{
-		/* Static vectors to zero */
-		Set_zero(cod_state->old_speech, L_TOTAL - L_FRAME);
-		Set_zero(cod_state->old_wsp, (PIT_MAX / OPL_DECIM));
-		Set_zero(cod_state->mem_decim2, 3);
-		/* routines initialization */
-		Init_Decim_12k8(cod_state->mem_decim);
-		Init_HP50_12k8(cod_state->mem_sig_in);
-		Init_Levinson(cod_state->mem_levinson);
-		Init_Q_gain2(cod_state->qua_gain);
-		Init_Hp_wsp(cod_state->hp_wsp_mem);
-		/* isp initialization */
-		Copy(isp_init, cod_state->ispold, M);
-		Copy(isp_init, cod_state->ispold_q, M);
-		/* variable initialization */
-		cod_state->mem_preemph = 0;        
-		cod_state->mem_wsp = 0;            
-		cod_state->Q_old = 15;             
-		cod_state->Q_max[0] = 15;          
-		cod_state->Q_max[1] = 15;          
-		cod_state->old_wsp_max = 0;        
-		cod_state->old_wsp_shift = 0;      
-		/* pitch ol initialization */
-		cod_state->old_T0_med = 40;        
-		cod_state->ol_gain = 0;            
-		cod_state->ada_w = 0;              
-		cod_state->ol_wght_flg = 0;        
-		for (i = 0; i < 5; i++)
-		{
-			cod_state->old_ol_lag[i] = 40; 
-		}
-		Set_zero(cod_state->old_hp_wsp, (L_FRAME / 2) / OPL_DECIM + (PIT_MAX / OPL_DECIM));
-		Set_zero(cod_state->mem_syn_hf, M);
-		Set_zero(cod_state->mem_syn_hi, M);
-		Set_zero(cod_state->mem_syn_lo, M);
-		Init_HP50_12k8(cod_state->mem_sig_out);
-		Init_Filt_6k_7k(cod_state->mem_hf);
-		Init_HP400_12k8(cod_state->mem_hp400);
-		Copy(isf_init, cod_state->isfold, M);
-		cod_state->mem_deemph = 0;         
-		cod_state->seed2 = 21845;          
-		Init_Filt_6k_7k(cod_state->mem_hf2);
-		cod_state->gain_alpha = 32767;     
-		cod_state->vad_hist = 0;
-		wb_vad_reset(cod_state->vadSt);
-		dtx_enc_reset(cod_state->dtx_encSt, isf_init);
-	}
-	return;
-}
-
-/*-----------------------------------------------------------------*
-*   Funtion  coder                                                *
-*            ~~~~~                                                *
-*   ->Main coder routine.                                         *
-*                                                                 *
-*-----------------------------------------------------------------*/
-void coder(
-		Word16 * mode,                        /* input :  used mode                             */
-		Word16 speech16k[],                   /* input :  320 new speech samples (at 16 kHz)    */
-		Word16 prms[],                        /* output:  output parameters                     */
-		Word16 * ser_size,                    /* output:  bit rate of the used mode             */
-		void *spe_state,                      /* i/o   :  State structure                       */
-		Word16 allow_dtx                      /* input :  DTX ON/OFF                            */
-	  )
-{
-	/* Coder states */
-	Coder_State *st;
-	/* Speech vector */
-	Word16 old_speech[L_TOTAL];
-	Word16 *new_speech, *speech, *p_window;
-
-	/* Weighted speech vector */
-	Word16 old_wsp[L_FRAME + (PIT_MAX / OPL_DECIM)];
-	Word16 *wsp;
-
-	/* Excitation vector */
-	Word16 old_exc[(L_FRAME + 1) + PIT_MAX + L_INTERPOL];
-	Word16 *exc;
-
-	/* LPC coefficients */
-	Word16 r_h[M + 1], r_l[M + 1];         /* Autocorrelations of windowed speech  */
-	Word16 rc[M];                          /* Reflection coefficients.             */
-	Word16 Ap[M + 1];                      /* A(z) with spectral expansion         */
-	Word16 ispnew[M];                      /* immittance spectral pairs at 4nd sfr */
-	Word16 ispnew_q[M];                    /* quantized ISPs at 4nd subframe       */
-	Word16 isf[M];                         /* ISF (frequency domain) at 4nd sfr    */
-	Word16 *p_A, *p_Aq;                    /* ptr to A(z) for the 4 subframes      */
-	Word16 A[NB_SUBFR * (M + 1)];          /* A(z) unquantized for the 4 subframes */
-	Word16 Aq[NB_SUBFR * (M + 1)];         /* A(z)   quantized for the 4 subframes */
-
-	/* Other vectors */
-	Word16 xn[L_SUBFR];                    /* Target vector for pitch search     */
-	Word16 xn2[L_SUBFR];                   /* Target vector for codebook search  */
-	Word16 dn[L_SUBFR];                    /* Correlation between xn2 and h1     */
-	Word16 cn[L_SUBFR];                    /* Target vector in residual domain   */
-	Word16 h1[L_SUBFR];                    /* Impulse response vector            */
-	Word16 h2[L_SUBFR];                    /* Impulse response vector            */
-	Word16 code[L_SUBFR];                  /* Fixed codebook excitation          */
-	Word16 y1[L_SUBFR];                    /* Filtered adaptive excitation       */
-	Word16 y2[L_SUBFR];                    /* Filtered adaptive excitation       */
-	Word16 error[M + L_SUBFR];             /* error of quantization              */
-	Word16 synth[L_SUBFR];                 /* 12.8kHz synthesis vector           */
-	Word16 exc2[L_FRAME];                  /* excitation vector                  */
-	Word16 buf[L_FRAME];                   /* VAD buffer                         */
-
-	/* Scalars */
-	Word32 i, j, i_subfr, select, pit_flag, clip_gain, vad_flag;
-	Word16 codec_mode;
-	Word16 T_op, T_op2, T0, T0_min, T0_max, T0_frac, index;
-	Word16 gain_pit, gain_code, g_coeff[4], g_coeff2[4];
-	Word16 tmp, gain1, gain2, exp, Q_new, mu, shift, max;
-	Word16 voice_fac;
-	Word16 indice[8];
-	Word32 L_tmp, L_gain_code, L_max, L_tmp1;
-	Word16 code2[L_SUBFR];                         /* Fixed codebook excitation  */
-	Word16 stab_fac, fac, gain_code_lo;
-
-	Word16 corr_gain;
-	Word16 *vo_p0, *vo_p1, *vo_p2, *vo_p3;
-
-	st = (Coder_State *) spe_state;
-
-	*ser_size = nb_of_bits[*mode];         
-	codec_mode = *mode;                    
-
-	/*--------------------------------------------------------------------------*
-	 *          Initialize pointers to speech vector.                           *
-	 *                                                                          *
-	 *                                                                          *
-	 *                    |-------|-------|-------|-------|-------|-------|     *
-	 *                     past sp   sf1     sf2     sf3     sf4    L_NEXT      *
-	 *                    <-------  Total speech buffer (L_TOTAL)   ------>     *
-	 *              old_speech                                                  *
-	 *                    <-------  LPC analysis window (L_WINDOW)  ------>     *
-	 *                    |       <-- present frame (L_FRAME) ---->             *
-	 *                   p_window |       <----- new speech (L_FRAME) ---->     *
-	 *                            |       |                                     *
-	 *                          speech    |                                     *
-	 *                                 new_speech                               *
-	 *--------------------------------------------------------------------------*/
-
-	new_speech = old_speech + L_TOTAL - L_FRAME - L_FILT;         /* New speech     */
-	speech = old_speech + L_TOTAL - L_FRAME - L_NEXT;             /* Present frame  */
-	p_window = old_speech + L_TOTAL - L_WINDOW; 
-
-	exc = old_exc + PIT_MAX + L_INTERPOL;  
-	wsp = old_wsp + (PIT_MAX / OPL_DECIM); 
-
-	/* copy coder memory state into working space */
-	Copy(st->old_speech, old_speech, L_TOTAL - L_FRAME);
-	Copy(st->old_wsp, old_wsp, PIT_MAX / OPL_DECIM);
-	Copy(st->old_exc, old_exc, PIT_MAX + L_INTERPOL);
-
-	/*---------------------------------------------------------------*
-	 * Down sampling signal from 16kHz to 12.8kHz                    *
-	 * -> The signal is extended by L_FILT samples (padded to zero)  *
-	 * to avoid additional delay (L_FILT samples) in the coder.      *
-	 * The last L_FILT samples are approximated after decimation and *
-	 * are used (and windowed) only in autocorrelations.             *
-	 *---------------------------------------------------------------*/
-
-	Decim_12k8(speech16k, L_FRAME16k, new_speech, st->mem_decim);
-
-	/* last L_FILT samples for autocorrelation window */
-	Copy(st->mem_decim, code, 2 * L_FILT16k);
-	Set_zero(error, L_FILT16k);            /* set next sample to zero */
-	Decim_12k8(error, L_FILT16k, new_speech + L_FRAME, code);
-
-	/*---------------------------------------------------------------*
-	 * Perform 50Hz HP filtering of input signal.                    *
-	 *---------------------------------------------------------------*/
-
-	HP50_12k8(new_speech, L_FRAME, st->mem_sig_in);
-
-	/* last L_FILT samples for autocorrelation window */
-	Copy(st->mem_sig_in, code, 6);
-	HP50_12k8(new_speech + L_FRAME, L_FILT, code);
-
-	/*---------------------------------------------------------------*
-	 * Perform fixed preemphasis through 1 - g z^-1                  *
-	 * Scale signal to get maximum of precision in filtering         *
-	 *---------------------------------------------------------------*/
-
-	mu = PREEMPH_FAC >> 1;              /* Q15 --> Q14 */
-
-	/* get max of new preemphased samples (L_FRAME+L_FILT) */
-	L_tmp = new_speech[0] << 15;
-	L_tmp -= (st->mem_preemph * mu)<<1;
-	L_max = L_abs(L_tmp);
-
-	for (i = 1; i < L_FRAME + L_FILT; i++)
-	{
-		L_tmp = new_speech[i] << 15;
-		L_tmp -= (new_speech[i - 1] * mu)<<1;
-		L_tmp = L_abs(L_tmp);
-		if(L_tmp > L_max)
-		{
-			L_max = L_tmp;                 
-		}
-	}
-
-	/* get scaling factor for new and previous samples */
-	/* limit scaling to Q_MAX to keep dynamic for ringing in low signal */
-	/* limit scaling to Q_MAX also to avoid a[0]<1 in syn_filt_32 */
-	tmp = extract_h(L_max);
-	if (tmp == 0)
-	{
-		shift = Q_MAX;                     
-	} else
-	{
-		shift = norm_s(tmp) - 1;
-		if (shift < 0)
-		{
-			shift = 0;                     
-		}
-		if (shift > Q_MAX)
-		{
-			shift = Q_MAX;                 
-		}
-	}
-	Q_new = shift;                         
-	if (Q_new > st->Q_max[0])
-	{
-		Q_new = st->Q_max[0];              
-	}
-	if (Q_new > st->Q_max[1])
-	{
-		Q_new = st->Q_max[1];              
-	}
-	exp = (Q_new - st->Q_old);
-	st->Q_old = Q_new;                     
-	st->Q_max[1] = st->Q_max[0];           
-	st->Q_max[0] = shift;                  
-
-	/* preemphasis with scaling (L_FRAME+L_FILT) */
-	tmp = new_speech[L_FRAME - 1];         
-
-	for (i = L_FRAME + L_FILT - 1; i > 0; i--)
-	{
-		L_tmp = new_speech[i] << 15;
-		L_tmp -= (new_speech[i - 1] * mu)<<1;
-		L_tmp = (L_tmp << Q_new);
-		new_speech[i] = vo_round(L_tmp);      
-	}
-
-	L_tmp = new_speech[0] << 15;
-	L_tmp -= (st->mem_preemph * mu)<<1;
-	L_tmp = (L_tmp << Q_new);
-	new_speech[0] = vo_round(L_tmp);          
-
-	st->mem_preemph = tmp;                 
-
-	/* scale previous samples and memory */
-
-	Scale_sig(old_speech, L_TOTAL - L_FRAME - L_FILT, exp);
-	Scale_sig(old_exc, PIT_MAX + L_INTERPOL, exp);
-	Scale_sig(st->mem_syn, M, exp);
-	Scale_sig(st->mem_decim2, 3, exp);
-	Scale_sig(&(st->mem_wsp), 1, exp);
-	Scale_sig(&(st->mem_w0), 1, exp);
-
-	/*------------------------------------------------------------------------*
-	 *  Call VAD                                                              *
-	 *  Preemphesis scale down signal in low frequency and keep dynamic in HF.*
-	 *  Vad work slightly in futur (new_speech = speech + L_NEXT - L_FILT).   *
-	 *------------------------------------------------------------------------*/
-	Copy(new_speech, buf, L_FRAME);
-
-#ifdef ASM_OPT        /* asm optimization branch */
-	Scale_sig_opt(buf, L_FRAME, 1 - Q_new);
-#else
-	Scale_sig(buf, L_FRAME, 1 - Q_new);
-#endif
-
-	vad_flag = wb_vad(st->vadSt, buf);          /* Voice Activity Detection */ 
-	if (vad_flag == 0)
-	{
-		st->vad_hist = (st->vad_hist + 1);        
-	} else
-	{
-		st->vad_hist = 0;             
-	}
-
-	/* DTX processing */
-	if (allow_dtx != 0)
-	{
-		/* Note that mode may change here */
-		tx_dtx_handler(st->dtx_encSt, vad_flag, mode);
-		*ser_size = nb_of_bits[*mode]; 
-	}
-
-	if(*mode != MRDTX)
-	{
-		Parm_serial(vad_flag, 1, &prms);
-	}
-	/*------------------------------------------------------------------------*
-	 *  Perform LPC analysis                                                  *
-	 *  ~~~~~~~~~~~~~~~~~~~~                                                  *
-	 *   - autocorrelation + lag windowing                                    *
-	 *   - Levinson-durbin algorithm to find a[]                              *
-	 *   - convert a[] to isp[]                                               *
-	 *   - convert isp[] to isf[] for quantization                            *
-	 *   - quantize and code the isf[]                                        *
-	 *   - convert isf[] to isp[] for interpolation                           *
-	 *   - find the interpolated ISPs and convert to a[] for the 4 subframes  *
-	 *------------------------------------------------------------------------*/
-
-	/* LP analysis centered at 4nd subframe */
-	Autocorr(p_window, M, r_h, r_l);                        /* Autocorrelations */
-	Lag_window(r_h, r_l);                                   /* Lag windowing    */
-	Levinson(r_h, r_l, A, rc, st->mem_levinson);            /* Levinson Durbin  */
-	Az_isp(A, ispnew, st->ispold);                          /* From A(z) to ISP */
-
-	/* Find the interpolated ISPs and convert to a[] for all subframes */
-	Int_isp(st->ispold, ispnew, interpol_frac, A);
-
-	/* update ispold[] for the next frame */
-	Copy(ispnew, st->ispold, M);
-
-	/* Convert ISPs to frequency domain 0..6400 */
-	Isp_isf(ispnew, isf, M);
-
-	/* check resonance for pitch clipping algorithm */
-	Gp_clip_test_isf(isf, st->gp_clip);
-
-	/*----------------------------------------------------------------------*
-	 *  Perform PITCH_OL analysis                                           *
-	 *  ~~~~~~~~~~~~~~~~~~~~~~~~~                                           *
-	 * - Find the residual res[] for the whole speech frame                 *
-	 * - Find the weighted input speech wsp[] for the whole speech frame    *
-	 * - scale wsp[] to avoid overflow in pitch estimation                  *
-	 * - Find open loop pitch lag for whole speech frame                    *
-	 *----------------------------------------------------------------------*/
-	p_A = A;                             
-	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
-	{
-		/* Weighting of LPC coefficients */
-		Weight_a(p_A, Ap, GAMMA1, M);
-
-#ifdef ASM_OPT                    /* asm optimization branch */
-		Residu_opt(Ap, &speech[i_subfr], &wsp[i_subfr], L_SUBFR);
-#else
-		Residu(Ap, &speech[i_subfr], &wsp[i_subfr], L_SUBFR);
-#endif
-
-		p_A += (M + 1);                    
-	}
-
-	Deemph2(wsp, TILT_FAC, L_FRAME, &(st->mem_wsp));
-
-	/* find maximum value on wsp[] for 12 bits scaling */
-	max = 0;                              
-	for (i = 0; i < L_FRAME; i++)
-	{
-		tmp = abs_s(wsp[i]);
-		if(tmp > max)
-		{
-			max = tmp;                     
-		}
-	}
-	tmp = st->old_wsp_max;                 
-	if(max > tmp)
-	{
-		tmp = max;                         /* tmp = max(wsp_max, old_wsp_max) */
-	}
-	st->old_wsp_max = max;                
-
-	shift = norm_s(tmp) - 3;
-	if (shift > 0)
-	{
-		shift = 0;                         /* shift = 0..-3 */
-	}
-	/* decimation of wsp[] to search pitch in LF and to reduce complexity */
-	LP_Decim2(wsp, L_FRAME, st->mem_decim2);
-
-	/* scale wsp[] in 12 bits to avoid overflow */
-#ifdef  ASM_OPT                  /* asm optimization branch */
-	Scale_sig_opt(wsp, L_FRAME / OPL_DECIM, shift);
-#else
-	Scale_sig(wsp, L_FRAME / OPL_DECIM, shift);
-#endif
-	/* scale old_wsp (warning: exp must be Q_new-Q_old) */
-	exp = exp + (shift - st->old_wsp_shift);
-	st->old_wsp_shift = shift;
-
-	Scale_sig(old_wsp, PIT_MAX / OPL_DECIM, exp);
-	Scale_sig(st->old_hp_wsp, PIT_MAX / OPL_DECIM, exp);
-
-	scale_mem_Hp_wsp(st->hp_wsp_mem, exp);
-
-	/* Find open loop pitch lag for whole speech frame */
-
-	if(*ser_size == NBBITS_7k)
-	{
-		/* Find open loop pitch lag for whole speech frame */
-		T_op = Pitch_med_ol(wsp, st, L_FRAME / OPL_DECIM);
-	} else
-	{
-		/* Find open loop pitch lag for first 1/2 frame */
-		T_op = Pitch_med_ol(wsp, st, (L_FRAME/2) / OPL_DECIM);
-	}
-
-	if(st->ol_gain > 19661)       /* 0.6 in Q15 */
-	{
-		st->old_T0_med = Med_olag(T_op, st->old_ol_lag);       
-		st->ada_w = 32767;                 
-	} else
-	{
-		st->ada_w = vo_mult(st->ada_w, 29491);
-	}
-
-	if(st->ada_w < 26214)
-		st->ol_wght_flg = 0;
-	else
-		st->ol_wght_flg = 1;
-
-	wb_vad_tone_detection(st->vadSt, st->ol_gain);
-	T_op *= OPL_DECIM;                     
-
-	if(*ser_size != NBBITS_7k)
-	{
-		/* Find open loop pitch lag for second 1/2 frame */
-		T_op2 = Pitch_med_ol(wsp + ((L_FRAME / 2) / OPL_DECIM), st, (L_FRAME/2) / OPL_DECIM);
-
-		if(st->ol_gain > 19661)   /* 0.6 in Q15 */
-		{
-			st->old_T0_med = Med_olag(T_op2, st->old_ol_lag);  
-			st->ada_w = 32767;             
-		} else
-		{
-			st->ada_w = mult(st->ada_w, 29491); 
-		}
-
-		if(st->ada_w < 26214)
-			st->ol_wght_flg = 0;
-		else
-			st->ol_wght_flg = 1;
-
-		wb_vad_tone_detection(st->vadSt, st->ol_gain);
-
-		T_op2 *= OPL_DECIM;                
-
-	} else
-	{
-		T_op2 = T_op;                      
-	}
-	/*----------------------------------------------------------------------*
-	 *                              DTX-CNG                                 *
-	 *----------------------------------------------------------------------*/
-	if(*mode == MRDTX)            /* CNG mode */
-	{
-		/* Buffer isf's and energy */
-#ifdef ASM_OPT                   /* asm optimization branch */
-		Residu_opt(&A[3 * (M + 1)], speech, exc, L_FRAME);
-#else
-		Residu(&A[3 * (M + 1)], speech, exc, L_FRAME);
-#endif
-
-		for (i = 0; i < L_FRAME; i++)
-		{
-			exc2[i] = shr(exc[i], Q_new);  
-		}
-
-		L_tmp = 0;                         
-		for (i = 0; i < L_FRAME; i++)
-			L_tmp += (exc2[i] * exc2[i])<<1;
-
-		L_tmp >>= 1;
-
-		dtx_buffer(st->dtx_encSt, isf, L_tmp, codec_mode);
-
-		/* Quantize and code the ISFs */
-		dtx_enc(st->dtx_encSt, isf, exc2, &prms);
-
-		/* Convert ISFs to the cosine domain */
-		Isf_isp(isf, ispnew_q, M);
-		Isp_Az(ispnew_q, Aq, M, 0);
-
-		for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
-		{
-			corr_gain = synthesis(Aq, &exc2[i_subfr], 0, &speech16k[i_subfr * 5 / 4], st);
-		}
-		Copy(isf, st->isfold, M);
-
-		/* reset speech coder memories */
-		Reset_encoder(st, 0);
-
-		/*--------------------------------------------------*
-		 * Update signal for next frame.                    *
-		 * -> save past of speech[] and wsp[].              *
-		 *--------------------------------------------------*/
-
-		Copy(&old_speech[L_FRAME], st->old_speech, L_TOTAL - L_FRAME);
-		Copy(&old_wsp[L_FRAME / OPL_DECIM], st->old_wsp, PIT_MAX / OPL_DECIM);
-
-		return;
-	}
-	/*----------------------------------------------------------------------*
-	 *                               ACELP                                  *
-	 *----------------------------------------------------------------------*/
-
-	/* Quantize and code the ISFs */
-
-	if (*ser_size <= NBBITS_7k)
-	{
-		Qpisf_2s_36b(isf, isf, st->past_isfq, indice, 4);
-
-		Parm_serial(indice[0], 8, &prms);
-		Parm_serial(indice[1], 8, &prms);
-		Parm_serial(indice[2], 7, &prms);
-		Parm_serial(indice[3], 7, &prms);
-		Parm_serial(indice[4], 6, &prms);
-	} else
-	{
-		Qpisf_2s_46b(isf, isf, st->past_isfq, indice, 4);
-
-		Parm_serial(indice[0], 8, &prms);
-		Parm_serial(indice[1], 8, &prms);
-		Parm_serial(indice[2], 6, &prms);
-		Parm_serial(indice[3], 7, &prms);
-		Parm_serial(indice[4], 7, &prms);
-		Parm_serial(indice[5], 5, &prms);
-		Parm_serial(indice[6], 5, &prms);
-	}
-
-	/* Check stability on isf : distance between old isf and current isf */
-
-	L_tmp = 0;                           
-	for (i = 0; i < M - 1; i++)
-	{
-		tmp = vo_sub(isf[i], st->isfold[i]);
-		L_tmp += (tmp * tmp)<<1;
-	}
-
-	tmp = extract_h(L_shl2(L_tmp, 8)); 
-
-	tmp = vo_mult(tmp, 26214);                /* tmp = L_tmp*0.8/256 */
-	tmp = vo_sub(20480, tmp);                 /* 1.25 - tmp (in Q14) */
-
-	stab_fac = shl(tmp, 1); 
-
-	if (stab_fac < 0)
-	{
-		stab_fac = 0;                      
-	}
-	Copy(isf, st->isfold, M);
-
-	/* Convert ISFs to the cosine domain */
-	Isf_isp(isf, ispnew_q, M);
-
-	if (st->first_frame != 0)
-	{
-		st->first_frame = 0;              
-		Copy(ispnew_q, st->ispold_q, M);
-	}
-	/* Find the interpolated ISPs and convert to a[] for all subframes */
-
-	Int_isp(st->ispold_q, ispnew_q, interpol_frac, Aq);
-
-	/* update ispold[] for the next frame */
-	Copy(ispnew_q, st->ispold_q, M);
-
-	p_Aq = Aq;
-	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
-	{
-#ifdef ASM_OPT               /* asm optimization branch */
-		Residu_opt(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
-#else
-		Residu(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
-#endif
-		p_Aq += (M + 1);                   
-	}
-
-	/* Buffer isf's and energy for dtx on non-speech frame */
-	if (vad_flag == 0)
-	{
-		for (i = 0; i < L_FRAME; i++)
-		{
-			exc2[i] = exc[i] >> Q_new;
-		}
-		L_tmp = 0;                         
-		for (i = 0; i < L_FRAME; i++)
-			L_tmp += (exc2[i] * exc2[i])<<1;
-		L_tmp >>= 1;
-
-		dtx_buffer(st->dtx_encSt, isf, L_tmp, codec_mode);
-	}
-	/* range for closed loop pitch search in 1st subframe */
-
-	T0_min = T_op - 8;
-	if (T0_min < PIT_MIN)
-	{
-		T0_min = PIT_MIN;                  
-	}
-	T0_max = (T0_min + 15);
-
-	if(T0_max > PIT_MAX)
-	{
-		T0_max = PIT_MAX;                  
-		T0_min = T0_max - 15;          
-	}
-	/*------------------------------------------------------------------------*
-	 *          Loop for every subframe in the analysis frame                 *
-	 *------------------------------------------------------------------------*
-	 *  To find the pitch and innovation parameters. The subframe size is     *
-	 *  L_SUBFR and the loop is repeated L_FRAME/L_SUBFR times.               *
-	 *     - compute the target signal for pitch search                       *
-	 *     - compute impulse response of weighted synthesis filter (h1[])     *
-	 *     - find the closed-loop pitch parameters                            *
-	 *     - encode the pitch dealy                                           *
-	 *     - find 2 lt prediction (with / without LP filter for lt pred)      *
-	 *     - find 2 pitch gains and choose the best lt prediction.            *
-	 *     - find target vector for codebook search                           *
-	 *     - update the impulse response h1[] for codebook search             *
-	 *     - correlation between target vector and impulse response           *
-	 *     - codebook search and encoding                                     *
-	 *     - VQ of pitch and codebook gains                                   *
-	 *     - find voicing factor and tilt of code for next subframe.          *
-	 *     - update states of weighting filter                                *
-	 *     - find excitation and synthesis speech                             *
-	 *------------------------------------------------------------------------*/
-	p_A = A;                               
-	p_Aq = Aq;                             
-	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
-	{
-		pit_flag = i_subfr;                
-		if ((i_subfr == 2 * L_SUBFR) && (*ser_size > NBBITS_7k))
-		{
-			pit_flag = 0;                 
-			/* range for closed loop pitch search in 3rd subframe */
-			T0_min = (T_op2 - 8);
-
-			if (T0_min < PIT_MIN)
-			{
-				T0_min = PIT_MIN;          
-			}
-			T0_max = (T0_min + 15);
-			if (T0_max > PIT_MAX)
-			{
-				T0_max = PIT_MAX;         
-				T0_min = (T0_max - 15);
-			}
-		}
-		/*-----------------------------------------------------------------------*
-		 *                                                                       *
-		 *        Find the target vector for pitch search:                       *
-		 *        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                        *
-		 *                                                                       *
-		 *             |------|  res[n]                                          *
-		 * speech[n]---| A(z) |--------                                          *
-		 *             |------|       |   |--------| error[n]  |------|          *
-		 *                   zero -- (-)--| 1/A(z) |-----------| W(z) |-- target *
-		 *                   exc          |--------|           |------|          *
-		 *                                                                       *
-		 * Instead of subtracting the zero-input response of filters from        *
-		 * the weighted input speech, the above configuration is used to         *
-		 * compute the target vector.                                            *
-		 *                                                                       *
-		 *-----------------------------------------------------------------------*/
-
-		for (i = 0; i < M; i++)
-		{
-			error[i] = vo_sub(speech[i + i_subfr - M], st->mem_syn[i]);
-		}
-
-#ifdef ASM_OPT              /* asm optimization branch */
-		Residu_opt(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
-#else
-		Residu(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
-#endif
-		Syn_filt(p_Aq, &exc[i_subfr], error + M, L_SUBFR, error, 0);
-		Weight_a(p_A, Ap, GAMMA1, M);
-
-#ifdef ASM_OPT             /* asm optimization branch */
-		Residu_opt(Ap, error + M, xn, L_SUBFR);
-#else
-		Residu(Ap, error + M, xn, L_SUBFR);
-#endif
-		Deemph2(xn, TILT_FAC, L_SUBFR, &(st->mem_w0));
-
-		/*----------------------------------------------------------------------*
-		 * Find approx. target in residual domain "cn[]" for inovation search.  *
-		 *----------------------------------------------------------------------*/
-		/* first half: xn[] --> cn[] */
-		Set_zero(code, M);
-		Copy(xn, code + M, L_SUBFR / 2);
-		tmp = 0;                          
-		Preemph2(code + M, TILT_FAC, L_SUBFR / 2, &tmp);
-		Weight_a(p_A, Ap, GAMMA1, M);
-		Syn_filt(Ap,code + M, code + M, L_SUBFR / 2, code, 0);
-
-#ifdef ASM_OPT                /* asm optimization branch */
-		Residu_opt(p_Aq,code + M, cn, L_SUBFR / 2);
-#else
-		Residu(p_Aq,code + M, cn, L_SUBFR / 2);
-#endif
-
-		/* second half: res[] --> cn[] (approximated and faster) */
-		Copy(&exc[i_subfr + (L_SUBFR / 2)], cn + (L_SUBFR / 2), L_SUBFR / 2);
-
-		/*---------------------------------------------------------------*
-		 * Compute impulse response, h1[], of weighted synthesis filter  * 
-		 *---------------------------------------------------------------*/
-
-		Set_zero(error, M + L_SUBFR);
-		Weight_a(p_A, error + M, GAMMA1, M);
-
-		vo_p0 = error+M;
-		vo_p3 = h1;
-		for (i = 0; i < L_SUBFR; i++)
-		{
-			L_tmp = *vo_p0 << 14;        /* x4 (Q12 to Q14) */
-			vo_p1 = p_Aq + 1;
-			vo_p2 = vo_p0-1;
-			for (j = 1; j <= M/4; j++)
-			{
-				L_tmp -= *vo_p1++ * *vo_p2--;
-				L_tmp -= *vo_p1++ * *vo_p2--;
-				L_tmp -= *vo_p1++ * *vo_p2--;
-				L_tmp -= *vo_p1++ * *vo_p2--;
-			}
-			*vo_p3++ = *vo_p0++ = vo_round((L_tmp <<4));
-		}
-		/* deemph without division by 2 -> Q14 to Q15 */
-		tmp = 0; 
-		Deemph2(h1, TILT_FAC, L_SUBFR, &tmp);   /* h1 in Q14 */
-
-		/* h2 in Q12 for codebook search */
-		Copy(h1, h2, L_SUBFR);
-
-		/*---------------------------------------------------------------*
-		 * scale xn[] and h1[] to avoid overflow in dot_product12()      *
-		 *---------------------------------------------------------------*/
-#ifdef  ASM_OPT                  /* asm optimization branch */
-		Scale_sig_opt(h2, L_SUBFR, -2);
-		Scale_sig_opt(xn, L_SUBFR, shift);     /* scaling of xn[] to limit dynamic at 12 bits */
-		Scale_sig_opt(h1, L_SUBFR, 1 + shift);  /* set h1[] in Q15 with scaling for convolution */
-#else
-		Scale_sig(h2, L_SUBFR, -2);
-		Scale_sig(xn, L_SUBFR, shift);     /* scaling of xn[] to limit dynamic at 12 bits */
-		Scale_sig(h1, L_SUBFR, 1 + shift);  /* set h1[] in Q15 with scaling for convolution */
-#endif
-		/*----------------------------------------------------------------------*
-		 *                 Closed-loop fractional pitch search                  *
-		 *----------------------------------------------------------------------*/
-		/* find closed loop fractional pitch  lag */
-		if(*ser_size <= NBBITS_9k)
-		{
-			T0 = Pitch_fr4(&exc[i_subfr], xn, h1, T0_min, T0_max, &T0_frac,
-					pit_flag, PIT_MIN, PIT_FR1_8b, L_SUBFR);
-
-			/* encode pitch lag */
-			if (pit_flag == 0)             /* if 1st/3rd subframe */
-			{
-				/*--------------------------------------------------------------*
-				 * The pitch range for the 1st/3rd subframe is encoded with     *
-				 * 8 bits and is divided as follows:                            *
-				 *   PIT_MIN to PIT_FR1-1  resolution 1/2 (frac = 0 or 2)       *
-				 *   PIT_FR1 to PIT_MAX    resolution 1   (frac = 0)            *
-				 *--------------------------------------------------------------*/
-				if (T0 < PIT_FR1_8b)
-				{
-					index = ((T0 << 1) + (T0_frac >> 1) - (PIT_MIN<<1));
-				} else
-				{
-					index = ((T0 - PIT_FR1_8b) + ((PIT_FR1_8b - PIT_MIN)*2));
-				}
-
-				Parm_serial(index, 8, &prms);
-
-				/* find T0_min and T0_max for subframe 2 and 4 */
-				T0_min = (T0 - 8);
-				if (T0_min < PIT_MIN)
-				{
-					T0_min = PIT_MIN;
-				}
-				T0_max = T0_min + 15;
-				if (T0_max > PIT_MAX)
-				{
-					T0_max = PIT_MAX;
-					T0_min = (T0_max - 15);
-				}
-			} else
-			{                              /* if subframe 2 or 4 */
-				/*--------------------------------------------------------------*
-				 * The pitch range for subframe 2 or 4 is encoded with 5 bits:  *
-				 *   T0_min  to T0_max     resolution 1/2 (frac = 0 or 2)       *
-				 *--------------------------------------------------------------*/
-				i = (T0 - T0_min);
-				index = (i << 1) + (T0_frac >> 1);
-
-				Parm_serial(index, 5, &prms);
-			}
-		} else
-		{
-			T0 = Pitch_fr4(&exc[i_subfr], xn, h1, T0_min, T0_max, &T0_frac,
-					pit_flag, PIT_FR2, PIT_FR1_9b, L_SUBFR);
-
-			/* encode pitch lag */
-			if (pit_flag == 0)             /* if 1st/3rd subframe */
-			{
-				/*--------------------------------------------------------------*
-				 * The pitch range for the 1st/3rd subframe is encoded with     *
-				 * 9 bits and is divided as follows:                            *
-				 *   PIT_MIN to PIT_FR2-1  resolution 1/4 (frac = 0,1,2 or 3)   *
-				 *   PIT_FR2 to PIT_FR1-1  resolution 1/2 (frac = 0 or 1)       *
-				 *   PIT_FR1 to PIT_MAX    resolution 1   (frac = 0)            *
-				 *--------------------------------------------------------------*/
-
-				if (T0 < PIT_FR2)
-				{
-					index = ((T0 << 2) + T0_frac) - (PIT_MIN << 2);
-				} else if(T0 < PIT_FR1_9b)
-				{
-					index = ((((T0 << 1) + (T0_frac >> 1)) - (PIT_FR2<<1)) + ((PIT_FR2 - PIT_MIN)<<2));
-				} else
-				{
-					index = (((T0 - PIT_FR1_9b) + ((PIT_FR2 - PIT_MIN)<<2)) + ((PIT_FR1_9b - PIT_FR2)<<1));
-				}
-
-				Parm_serial(index, 9, &prms);
-
-				/* find T0_min and T0_max for subframe 2 and 4 */
-
-				T0_min = (T0 - 8);
-				if (T0_min < PIT_MIN)
-				{
-					T0_min = PIT_MIN; 
-				}
-				T0_max = T0_min + 15;
-
-				if (T0_max > PIT_MAX)
-				{
-					T0_max = PIT_MAX;
-					T0_min = (T0_max - 15);
-				}
-			} else
-			{                              /* if subframe 2 or 4 */
-				/*--------------------------------------------------------------*
-				 * The pitch range for subframe 2 or 4 is encoded with 6 bits:  *
-				 *   T0_min  to T0_max     resolution 1/4 (frac = 0,1,2 or 3)   *
-				 *--------------------------------------------------------------*/
-				i = (T0 - T0_min);
-				index = (i << 2) + T0_frac;
-				Parm_serial(index, 6, &prms);
-			}
-		}
-
-		/*-----------------------------------------------------------------*
-		 * Gain clipping test to avoid unstable synthesis on frame erasure *
-		 *-----------------------------------------------------------------*/
-
-		clip_gain = 0;
-		if((st->gp_clip[0] < 154) && (st->gp_clip[1] > 14746))
-			clip_gain = 1;
-
-		/*-----------------------------------------------------------------*
-		 * - find unity gain pitch excitation (adaptive codebook entry)    *
-		 *   with fractional interpolation.                                *
-		 * - find filtered pitch exc. y1[]=exc[] convolved with h1[])      *
-		 * - compute pitch gain1                                           *
-		 *-----------------------------------------------------------------*/
-		/* find pitch exitation */
-#ifdef ASM_OPT                  /* asm optimization branch */
-		pred_lt4_asm(&exc[i_subfr], T0, T0_frac, L_SUBFR + 1);
-#else
-		Pred_lt4(&exc[i_subfr], T0, T0_frac, L_SUBFR + 1);
-#endif
-		if (*ser_size > NBBITS_9k)
-		{
-#ifdef ASM_OPT                   /* asm optimization branch */
-			Convolve_asm(&exc[i_subfr], h1, y1, L_SUBFR);
-#else
-			Convolve(&exc[i_subfr], h1, y1, L_SUBFR);
-#endif 
-			gain1 = G_pitch(xn, y1, g_coeff, L_SUBFR);
-			/* clip gain if necessary to avoid problem at decoder */
-			if ((clip_gain != 0) && (gain1 > GP_CLIP))
-			{
-				gain1 = GP_CLIP; 
-			}
-			/* find energy of new target xn2[] */
-			Updt_tar(xn, dn, y1, gain1, L_SUBFR);       /* dn used temporary */
-		} else
-		{
-			gain1 = 0; 
-		}
-		/*-----------------------------------------------------------------*
-		 * - find pitch excitation filtered by 1st order LP filter.        *
-		 * - find filtered pitch exc. y2[]=exc[] convolved with h1[])      *
-		 * - compute pitch gain2                                           *
-		 *-----------------------------------------------------------------*/
-		/* find pitch excitation with lp filter */
-		vo_p0 = exc + i_subfr-1;
-		vo_p1 = code;
-		/* find pitch excitation with lp filter */
-		for (i = 0; i < L_SUBFR/2; i++)
-		{
-			L_tmp = 5898 * *vo_p0++;
-			L_tmp1 = 5898 * *vo_p0;
-			L_tmp += 20972 * *vo_p0++;
-			L_tmp1 += 20972 * *vo_p0++;
-			L_tmp1 += 5898 * *vo_p0--;
-			L_tmp += 5898 * *vo_p0;
-			*vo_p1++ = (L_tmp + 0x4000)>>15;
-			*vo_p1++ = (L_tmp1 + 0x4000)>>15;
-		}
-
-#ifdef ASM_OPT                 /* asm optimization branch */
-		Convolve_asm(code, h1, y2, L_SUBFR);
-#else
-		Convolve(code, h1, y2, L_SUBFR);
-#endif 
-
-		gain2 = G_pitch(xn, y2, g_coeff2, L_SUBFR);
-
-		/* clip gain if necessary to avoid problem at decoder */
-		if ((clip_gain != 0) && (gain2 > GP_CLIP))
-		{
-			gain2 = GP_CLIP;
-		}
-		/* find energy of new target xn2[] */
-		Updt_tar(xn, xn2, y2, gain2, L_SUBFR);
-		/*-----------------------------------------------------------------*
-		 * use the best prediction (minimise quadratic error).             *
-		 *-----------------------------------------------------------------*/
-		select = 0; 
-		if(*ser_size > NBBITS_9k)
-		{
-			L_tmp = 0L;
-			vo_p0 = dn;
-			vo_p1 = xn2;
-			for (i = 0; i < L_SUBFR/2; i++)
-			{
-				L_tmp += *vo_p0 * *vo_p0;
-				vo_p0++;
-				L_tmp -= *vo_p1 * *vo_p1;
-				vo_p1++;
-				L_tmp += *vo_p0 * *vo_p0;
-				vo_p0++;
-				L_tmp -= *vo_p1 * *vo_p1;
-				vo_p1++;
-			}
-
-			if (L_tmp <= 0)
-			{
-				select = 1; 
-			}
-			Parm_serial(select, 1, &prms);
-		}
-		if (select == 0)
-		{
-			/* use the lp filter for pitch excitation prediction */
-			gain_pit = gain2;
-			Copy(code, &exc[i_subfr], L_SUBFR);
-			Copy(y2, y1, L_SUBFR);
-			Copy(g_coeff2, g_coeff, 4);
-		} else
-		{
-			/* no filter used for pitch excitation prediction */
-			gain_pit = gain1;
-			Copy(dn, xn2, L_SUBFR);        /* target vector for codebook search */
-		}
-		/*-----------------------------------------------------------------*
-		 * - update cn[] for codebook search                               *
-		 *-----------------------------------------------------------------*/
-		Updt_tar(cn, cn, &exc[i_subfr], gain_pit, L_SUBFR);
-
-#ifdef  ASM_OPT                           /* asm optimization branch */
-		Scale_sig_opt(cn, L_SUBFR, shift);     /* scaling of cn[] to limit dynamic at 12 bits */
-#else
-		Scale_sig(cn, L_SUBFR, shift);     /* scaling of cn[] to limit dynamic at 12 bits */
-#endif
-		/*-----------------------------------------------------------------*
-		 * - include fixed-gain pitch contribution into impulse resp. h1[] *
-		 *-----------------------------------------------------------------*/
-		tmp = 0;
-		Preemph(h2, st->tilt_code, L_SUBFR, &tmp);
-
-		if (T0_frac > 2)
-			T0 = (T0 + 1);
-		Pit_shrp(h2, T0, PIT_SHARP, L_SUBFR);
-		/*-----------------------------------------------------------------*
-		 * - Correlation between target xn2[] and impulse response h1[]    *
-		 * - Innovative codebook search                                    *
-		 *-----------------------------------------------------------------*/
-		cor_h_x(h2, xn2, dn);
-		if (*ser_size <= NBBITS_7k)
-		{
-			ACELP_2t64_fx(dn, cn, h2, code, y2, indice);
-
-			Parm_serial(indice[0], 12, &prms);
-		} else if(*ser_size <= NBBITS_9k)
-		{
-			ACELP_4t64_fx(dn, cn, h2, code, y2, 20, *ser_size, indice);
-
-			Parm_serial(indice[0], 5, &prms);
-			Parm_serial(indice[1], 5, &prms);
-			Parm_serial(indice[2], 5, &prms);
-			Parm_serial(indice[3], 5, &prms);
-		} else if(*ser_size <= NBBITS_12k)
-		{
-			ACELP_4t64_fx(dn, cn, h2, code, y2, 36, *ser_size, indice);
-
-			Parm_serial(indice[0], 9, &prms);
-			Parm_serial(indice[1], 9, &prms);
-			Parm_serial(indice[2], 9, &prms);
-			Parm_serial(indice[3], 9, &prms);
-		} else if(*ser_size <= NBBITS_14k)
-		{
-			ACELP_4t64_fx(dn, cn, h2, code, y2, 44, *ser_size, indice);
-
-			Parm_serial(indice[0], 13, &prms);
-			Parm_serial(indice[1], 13, &prms);
-			Parm_serial(indice[2], 9, &prms);
-			Parm_serial(indice[3], 9, &prms);
-		} else if(*ser_size <= NBBITS_16k)
-		{
-			ACELP_4t64_fx(dn, cn, h2, code, y2, 52, *ser_size, indice);
-
-			Parm_serial(indice[0], 13, &prms);
-			Parm_serial(indice[1], 13, &prms);
-			Parm_serial(indice[2], 13, &prms);
-			Parm_serial(indice[3], 13, &prms);
-		} else if(*ser_size <= NBBITS_18k)
-		{
-			ACELP_4t64_fx(dn, cn, h2, code, y2, 64, *ser_size, indice);
-
-			Parm_serial(indice[0], 2, &prms);
-			Parm_serial(indice[1], 2, &prms);
-			Parm_serial(indice[2], 2, &prms);
-			Parm_serial(indice[3], 2, &prms);
-			Parm_serial(indice[4], 14, &prms);
-			Parm_serial(indice[5], 14, &prms);
-			Parm_serial(indice[6], 14, &prms);
-			Parm_serial(indice[7], 14, &prms);
-		} else if(*ser_size <= NBBITS_20k)
-		{
-			ACELP_4t64_fx(dn, cn, h2, code, y2, 72, *ser_size, indice);
-
-			Parm_serial(indice[0], 10, &prms);
-			Parm_serial(indice[1], 10, &prms);
-			Parm_serial(indice[2], 2, &prms);
-			Parm_serial(indice[3], 2, &prms);
-			Parm_serial(indice[4], 10, &prms);
-			Parm_serial(indice[5], 10, &prms);
-			Parm_serial(indice[6], 14, &prms);
-			Parm_serial(indice[7], 14, &prms);
-		} else
-		{
-			ACELP_4t64_fx(dn, cn, h2, code, y2, 88, *ser_size, indice);
-
-			Parm_serial(indice[0], 11, &prms);
-			Parm_serial(indice[1], 11, &prms);
-			Parm_serial(indice[2], 11, &prms);
-			Parm_serial(indice[3], 11, &prms);
-			Parm_serial(indice[4], 11, &prms);
-			Parm_serial(indice[5], 11, &prms);
-			Parm_serial(indice[6], 11, &prms);
-			Parm_serial(indice[7], 11, &prms);
-		}
-		/*-------------------------------------------------------*
-		 * - Add the fixed-gain pitch contribution to code[].    *
-		 *-------------------------------------------------------*/
-		tmp = 0; 
-		Preemph(code, st->tilt_code, L_SUBFR, &tmp);
-		Pit_shrp(code, T0, PIT_SHARP, L_SUBFR);
-		/*----------------------------------------------------------*
-		 *  - Compute the fixed codebook gain                       *
-		 *  - quantize fixed codebook gain                          *
-		 *----------------------------------------------------------*/
-		if(*ser_size <= NBBITS_9k)
-		{
-			index = Q_gain2(xn, y1, Q_new + shift, y2, code, g_coeff, L_SUBFR, 6,
-					&gain_pit, &L_gain_code, clip_gain, st->qua_gain);
-			Parm_serial(index, 6, &prms);
-		} else
-		{
-			index = Q_gain2(xn, y1, Q_new + shift, y2, code, g_coeff, L_SUBFR, 7,
-					&gain_pit, &L_gain_code, clip_gain, st->qua_gain);
-			Parm_serial(index, 7, &prms);
-		}
-		/* test quantized gain of pitch for pitch clipping algorithm */
-		Gp_clip_test_gain_pit(gain_pit, st->gp_clip);
-
-		L_tmp = L_shl(L_gain_code, Q_new); 
-		gain_code = extract_h(L_add(L_tmp, 0x8000));
-
-		/*----------------------------------------------------------*
-		 * Update parameters for the next subframe.                 *
-		 * - tilt of code: 0.0 (unvoiced) to 0.5 (voiced)           *
-		 *----------------------------------------------------------*/
-		/* find voice factor in Q15 (1=voiced, -1=unvoiced) */
-		Copy(&exc[i_subfr], exc2, L_SUBFR);
-
-#ifdef ASM_OPT                           /* asm optimization branch */
-		Scale_sig_opt(exc2, L_SUBFR, shift);
-#else
-		Scale_sig(exc2, L_SUBFR, shift);
-#endif
-		voice_fac = voice_factor(exc2, shift, gain_pit, code, gain_code, L_SUBFR);
-		/* tilt of code for next subframe: 0.5=voiced, 0=unvoiced */
-		st->tilt_code = ((voice_fac >> 2) + 8192);
-		/*------------------------------------------------------*
-		 * - Update filter's memory "mem_w0" for finding the    *
-		 *   target vector in the next subframe.                *
-		 * - Find the total excitation                          *
-		 * - Find synthesis speech to update mem_syn[].         *
-		 *------------------------------------------------------*/
-
-		/* y2 in Q9, gain_pit in Q14 */
-		L_tmp = (gain_code * y2[L_SUBFR - 1])<<1;
-		L_tmp = L_shl(L_tmp, (5 + shift));
-		L_tmp = L_negate(L_tmp);
-		L_tmp += (xn[L_SUBFR - 1] * 16384)<<1;
-		L_tmp -= (y1[L_SUBFR - 1] * gain_pit)<<1;
-		L_tmp = L_shl(L_tmp, (1 - shift));
-		st->mem_w0 = extract_h(L_add(L_tmp, 0x8000));
-
-		if (*ser_size >= NBBITS_24k)
-			Copy(&exc[i_subfr], exc2, L_SUBFR);
-
-		for (i = 0; i < L_SUBFR; i++)
-		{
-			/* code in Q9, gain_pit in Q14 */
-			L_tmp = (gain_code * code[i])<<1;
-			L_tmp = (L_tmp << 5);
-			L_tmp += (exc[i + i_subfr] * gain_pit)<<1;
-			L_tmp = L_shl2(L_tmp, 1); 
-			exc[i + i_subfr] = extract_h(L_add(L_tmp, 0x8000));
-		}
-
-		Syn_filt(p_Aq,&exc[i_subfr], synth, L_SUBFR, st->mem_syn, 1);
-
-		if(*ser_size >= NBBITS_24k)
-		{
-			/*------------------------------------------------------------*
-			 * phase dispersion to enhance noise in low bit rate          *
-			 *------------------------------------------------------------*/
-			/* L_gain_code in Q16 */
-			VO_L_Extract(L_gain_code, &gain_code, &gain_code_lo);
-
-			/*------------------------------------------------------------*
-			 * noise enhancer                                             *
-			 * ~~~~~~~~~~~~~~                                             *
-			 * - Enhance excitation on noise. (modify gain of code)       *
-			 *   If signal is noisy and LPC filter is stable, move gain   *
-			 *   of code 1.5 dB toward gain of code threshold.            *
-			 *   This decrease by 3 dB noise energy variation.            *
-			 *------------------------------------------------------------*/
-			tmp = (16384 - (voice_fac >> 1));        /* 1=unvoiced, 0=voiced */
-			fac = vo_mult(stab_fac, tmp);
-			L_tmp = L_gain_code; 
-			if(L_tmp < st->L_gc_thres)
-			{
-				L_tmp = vo_L_add(L_tmp, Mpy_32_16(gain_code, gain_code_lo, 6226));
-				if(L_tmp > st->L_gc_thres)
-				{
-					L_tmp = st->L_gc_thres;
-				}
-			} else
-			{
-				L_tmp = Mpy_32_16(gain_code, gain_code_lo, 27536);
-				if(L_tmp < st->L_gc_thres)
-				{
-					L_tmp = st->L_gc_thres;
-				}
-			}
-			st->L_gc_thres = L_tmp;
-
-			L_gain_code = Mpy_32_16(gain_code, gain_code_lo, (32767 - fac));
-			VO_L_Extract(L_tmp, &gain_code, &gain_code_lo);
-			L_gain_code = vo_L_add(L_gain_code, Mpy_32_16(gain_code, gain_code_lo, fac));
-
-			/*------------------------------------------------------------*
-			 * pitch enhancer                                             *
-			 * ~~~~~~~~~~~~~~                                             *
-			 * - Enhance excitation on voice. (HP filtering of code)      *
-			 *   On voiced signal, filtering of code by a smooth fir HP   *
-			 *   filter to decrease energy of code in low frequency.      *
-			 *------------------------------------------------------------*/
-
-			tmp = ((voice_fac >> 3) + 4096); /* 0.25=voiced, 0=unvoiced */
-
-			L_tmp = L_deposit_h(code[0]);
-			L_tmp -= (code[1] * tmp)<<1;
-			code2[0] = vo_round(L_tmp); 
-
-			for (i = 1; i < L_SUBFR - 1; i++)
-			{
-				L_tmp = L_deposit_h(code[i]);
-				L_tmp -= (code[i + 1] * tmp)<<1;
-				L_tmp -= (code[i - 1] * tmp)<<1;
-				code2[i] = vo_round(L_tmp); 
-			}
-
-			L_tmp = L_deposit_h(code[L_SUBFR - 1]);
-			L_tmp -= (code[L_SUBFR - 2] * tmp)<<1;
-			code2[L_SUBFR - 1] = vo_round(L_tmp); 
-
-			/* build excitation */
-			gain_code = vo_round(L_shl(L_gain_code, Q_new));
-
-			for (i = 0; i < L_SUBFR; i++)
-			{
-				L_tmp = (code2[i] * gain_code)<<1;
-				L_tmp = (L_tmp << 5);
-				L_tmp += (exc2[i] * gain_pit)<<1;
-				L_tmp = (L_tmp << 1);
-				exc2[i] = vo_round(L_tmp);
-			}
-
-			corr_gain = synthesis(p_Aq, exc2, Q_new, &speech16k[i_subfr * 5 / 4], st);
-			Parm_serial(corr_gain, 4, &prms);
-		}
-		p_A += (M + 1);
-		p_Aq += (M + 1);
-	}                                      /* end of subframe loop */
-
-	/*--------------------------------------------------*
-	 * Update signal for next frame.                    *
-	 * -> save past of speech[], wsp[] and exc[].       *
-	 *--------------------------------------------------*/
-	Copy(&old_speech[L_FRAME], st->old_speech, L_TOTAL - L_FRAME);
-	Copy(&old_wsp[L_FRAME / OPL_DECIM], st->old_wsp, PIT_MAX / OPL_DECIM);
-	Copy(&old_exc[L_FRAME], st->old_exc, PIT_MAX + L_INTERPOL);
-	return;
-}
-
-/*-----------------------------------------------------*
-* Function synthesis()                                *
-*                                                     *
-* Synthesis of signal at 16kHz with HF extension.     *
-*                                                     *
-*-----------------------------------------------------*/
-
-static Word16 synthesis(
-		Word16 Aq[],                          /* A(z)  : quantized Az               */
-		Word16 exc[],                         /* (i)   : excitation at 12kHz        */
-		Word16 Q_new,                         /* (i)   : scaling performed on exc   */
-		Word16 synth16k[],                    /* (o)   : 16kHz synthesis signal     */
-		Coder_State * st                      /* (i/o) : State structure            */
-		)
-{
-	Word16 fac, tmp, exp;
-	Word16 ener, exp_ener;
-	Word32 L_tmp, i;
-
-	Word16 synth_hi[M + L_SUBFR], synth_lo[M + L_SUBFR];
-	Word16 synth[L_SUBFR];
-	Word16 HF[L_SUBFR16k];                 /* High Frequency vector      */
-	Word16 Ap[M + 1];
-
-	Word16 HF_SP[L_SUBFR16k];              /* High Frequency vector (from original signal) */
-
-	Word16 HP_est_gain, HP_calc_gain, HP_corr_gain;
-	Word16 dist_min, dist;
-	Word16 HP_gain_ind = 0;
-	Word16 gain1, gain2;
-	Word16 weight1, weight2;
-
-	/*------------------------------------------------------------*
-	 * speech synthesis                                           *
-	 * ~~~~~~~~~~~~~~~~                                           *
-	 * - Find synthesis speech corresponding to exc2[].           *
-	 * - Perform fixed deemphasis and hp 50hz filtering.          *
-	 * - Oversampling from 12.8kHz to 16kHz.                      *
-	 *------------------------------------------------------------*/
-	Copy(st->mem_syn_hi, synth_hi, M);
-	Copy(st->mem_syn_lo, synth_lo, M);
-
-#ifdef ASM_OPT                 /* asm optimization branch */
-	Syn_filt_32_asm(Aq, M, exc, Q_new, synth_hi + M, synth_lo + M, L_SUBFR);
-#else
-	Syn_filt_32(Aq, M, exc, Q_new, synth_hi + M, synth_lo + M, L_SUBFR);
-#endif
-
-	Copy(synth_hi + L_SUBFR, st->mem_syn_hi, M);
-	Copy(synth_lo + L_SUBFR, st->mem_syn_lo, M);
-
-#ifdef ASM_OPT                 /* asm optimization branch */
-	Deemph_32_asm(synth_hi + M, synth_lo + M, synth, &(st->mem_deemph));
-#else
-	Deemph_32(synth_hi + M, synth_lo + M, synth, PREEMPH_FAC, L_SUBFR, &(st->mem_deemph));
-#endif
-
-	HP50_12k8(synth, L_SUBFR, st->mem_sig_out);
-
-	/* Original speech signal as reference for high band gain quantisation */
-	for (i = 0; i < L_SUBFR16k; i++)
-	{
-		HF_SP[i] = synth16k[i]; 
-	}
-
-	/*------------------------------------------------------*
-	 * HF noise synthesis                                   *
-	 * ~~~~~~~~~~~~~~~~~~                                   *
-	 * - Generate HF noise between 5.5 and 7.5 kHz.         *
-	 * - Set energy of noise according to synthesis tilt.   *
-	 *     tilt > 0.8 ==> - 14 dB (voiced)                  *
-	 *     tilt   0.5 ==> - 6 dB  (voiced or noise)         *
-	 *     tilt < 0.0 ==>   0 dB  (noise)                   *
-	 *------------------------------------------------------*/
-	/* generate white noise vector */
-	for (i = 0; i < L_SUBFR16k; i++)
-	{
-		HF[i] = Random(&(st->seed2))>>3;
-	}
-	/* energy of excitation */
-#ifdef ASM_OPT                    /* asm optimization branch */
-	Scale_sig_opt(exc, L_SUBFR, -3);
-	Q_new = Q_new - 3;
-	ener = extract_h(Dot_product12_asm(exc, exc, L_SUBFR, &exp_ener));
-#else
-	Scale_sig(exc, L_SUBFR, -3);
-	Q_new = Q_new - 3;
-	ener = extract_h(Dot_product12(exc, exc, L_SUBFR, &exp_ener));
-#endif
-
-	exp_ener = exp_ener - (Q_new + Q_new);
-	/* set energy of white noise to energy of excitation */
-#ifdef ASM_OPT              /* asm optimization branch */
-	tmp = extract_h(Dot_product12_asm(HF, HF, L_SUBFR16k, &exp));
-#else
-	tmp = extract_h(Dot_product12(HF, HF, L_SUBFR16k, &exp));
-#endif
-
-	if(tmp > ener)
-	{
-		tmp = (tmp >> 1);                 /* Be sure tmp < ener */
-		exp = (exp + 1);
-	}
-	L_tmp = L_deposit_h(div_s(tmp, ener)); /* result is normalized */
-	exp = (exp - exp_ener);
-	Isqrt_n(&L_tmp, &exp);
-	L_tmp = L_shl(L_tmp, (exp + 1));       /* L_tmp x 2, L_tmp in Q31 */
-	tmp = extract_h(L_tmp);                /* tmp = 2 x sqrt(ener_exc/ener_hf) */
-
-	for (i = 0; i < L_SUBFR16k; i++)
-	{
-		HF[i] = vo_mult(HF[i], tmp);
-	}
-
-	/* find tilt of synthesis speech (tilt: 1=voiced, -1=unvoiced) */
-	HP400_12k8(synth, L_SUBFR, st->mem_hp400);
-
-	L_tmp = 1L;
-	for (i = 0; i < L_SUBFR; i++)
-		L_tmp += (synth[i] * synth[i])<<1;
-
-	exp = norm_l(L_tmp);
-	ener = extract_h(L_tmp << exp);   /* ener = r[0] */
-
-	L_tmp = 1L;
-	for (i = 1; i < L_SUBFR; i++)
-		L_tmp +=(synth[i] * synth[i - 1])<<1;
-
-	tmp = extract_h(L_tmp << exp);    /* tmp = r[1] */
-
-	if (tmp > 0)
-	{
-		fac = div_s(tmp, ener);
-	} else
-	{
-		fac = 0; 
-	}
-
-	/* modify energy of white noise according to synthesis tilt */
-	gain1 = 32767 - fac;
-	gain2 = vo_mult(gain1, 20480);
-	gain2 = shl(gain2, 1);
-
-	if (st->vad_hist > 0)
-	{
-		weight1 = 0;
-		weight2 = 32767;
-	} else
-	{
-		weight1 = 32767;
-		weight2 = 0;
-	}
-	tmp = vo_mult(weight1, gain1);
-	tmp = add1(tmp, vo_mult(weight2, gain2));
-
-	if (tmp != 0)
-	{
-		tmp = (tmp + 1);
-	}
-	HP_est_gain = tmp;
-
-	if(HP_est_gain < 3277)
-	{
-		HP_est_gain = 3277;                /* 0.1 in Q15 */
-	}
-	/* synthesis of noise: 4.8kHz..5.6kHz --> 6kHz..7kHz */
-	Weight_a(Aq, Ap, 19661, M);            /* fac=0.6 */
-
-#ifdef ASM_OPT                /* asm optimization branch */
-	Syn_filt_asm(Ap, HF, HF, st->mem_syn_hf);
-	/* noise High Pass filtering (1ms of delay) */
-	Filt_6k_7k_asm(HF, L_SUBFR16k, st->mem_hf);
-	/* filtering of the original signal */
-	Filt_6k_7k_asm(HF_SP, L_SUBFR16k, st->mem_hf2);
-
-	/* check the gain difference */
-	Scale_sig_opt(HF_SP, L_SUBFR16k, -1);
-	ener = extract_h(Dot_product12_asm(HF_SP, HF_SP, L_SUBFR16k, &exp_ener));
-	/* set energy of white noise to energy of excitation */
-	tmp = extract_h(Dot_product12_asm(HF, HF, L_SUBFR16k, &exp));
-#else
-	Syn_filt(Ap, HF, HF, L_SUBFR16k, st->mem_syn_hf, 1);
-	/* noise High Pass filtering (1ms of delay) */
-	Filt_6k_7k(HF, L_SUBFR16k, st->mem_hf);
-	/* filtering of the original signal */
-	Filt_6k_7k(HF_SP, L_SUBFR16k, st->mem_hf2);
-	/* check the gain difference */
-	Scale_sig(HF_SP, L_SUBFR16k, -1);
-	ener = extract_h(Dot_product12(HF_SP, HF_SP, L_SUBFR16k, &exp_ener));
-	/* set energy of white noise to energy of excitation */
-	tmp = extract_h(Dot_product12(HF, HF, L_SUBFR16k, &exp));
-#endif
-
-	if (tmp > ener)
-	{
-		tmp = (tmp >> 1);                 /* Be sure tmp < ener */
-		exp = (exp + 1);
-	}
-	L_tmp = L_deposit_h(div_s(tmp, ener)); /* result is normalized */
-	exp = vo_sub(exp, exp_ener);
-	Isqrt_n(&L_tmp, &exp);
-	L_tmp = L_shl(L_tmp, exp);             /* L_tmp, L_tmp in Q31 */
-	HP_calc_gain = extract_h(L_tmp);       /* tmp = sqrt(ener_input/ener_hf) */
-
-	/* st->gain_alpha *= st->dtx_encSt->dtxHangoverCount/7 */
-	L_tmp = (vo_L_mult(st->dtx_encSt->dtxHangoverCount, 4681) << 15);
-	st->gain_alpha = vo_mult(st->gain_alpha, extract_h(L_tmp));
-
-	if(st->dtx_encSt->dtxHangoverCount > 6)
-		st->gain_alpha = 32767;
-	HP_est_gain = HP_est_gain >> 1;     /* From Q15 to Q14 */
-	HP_corr_gain = add1(vo_mult(HP_calc_gain, st->gain_alpha), vo_mult((32767 - st->gain_alpha), HP_est_gain));
-
-	/* Quantise the correction gain */
-	dist_min = 32767;
-	for (i = 0; i < 16; i++)
-	{
-		dist = vo_mult((HP_corr_gain - HP_gain[i]), (HP_corr_gain - HP_gain[i]));
-		if (dist_min > dist)
-		{
-			dist_min = dist;
-			HP_gain_ind = i;
-		}
-	}
-	HP_corr_gain = HP_gain[HP_gain_ind];
-	/* return the quantised gain index when using the highest mode, otherwise zero */
-	return (HP_gain_ind);
-}
-
-/*************************************************
-*
-* Breif: Codec main function 
-*
-**************************************************/
-
-int AMR_Enc_Encode(HAMRENC hCodec)
-{
-	Word32 i;
-	Coder_State *gData = (Coder_State*)hCodec;
-	Word16 *signal;
-	Word16 packed_size = 0;
-	Word16 prms[NB_BITS_MAX];
-	Word16 coding_mode = 0, nb_bits, allow_dtx, mode, reset_flag;
-	mode = gData->mode;
-	coding_mode = gData->mode;
-	nb_bits = nb_of_bits[mode];
-	signal = (Word16 *)gData->inputStream;
-	allow_dtx = gData->allow_dtx;
-
-	/* check for homing frame */
-	reset_flag = encoder_homing_frame_test(signal);
-
-	for (i = 0; i < L_FRAME16k; i++)   /* Delete the 2 LSBs (14-bit input) */
-	{
-		*(signal + i) = (Word16) (*(signal + i) & 0xfffC);
-	}
-
-	coder(&coding_mode, signal, prms, &nb_bits, gData, allow_dtx);
-	packed_size = PackBits(prms, coding_mode, mode, gData);
-	if (reset_flag != 0)
-	{
-		Reset_encoder(gData, 1);
-	}
-	return packed_size;
-}
-
-/***************************************************************************
-*
-*Brief: Codec API function --- Initialize the codec and return a codec handle
-*
-***************************************************************************/
-
-VO_U32 VO_API voAMRWB_Init(VO_HANDLE * phCodec,                   /* o: the audio codec handle */
-						   VO_AUDIO_CODINGTYPE vType,             /* i: Codec Type ID */
-						   VO_CODEC_INIT_USERDATA * pUserData     /* i: init Parameters */
-						   )
-{
-	Coder_State *st;
-	FrameStream *stream;
-#ifdef USE_DEAULT_MEM
-	VO_MEM_OPERATOR voMemoprator;
-#endif
-	VO_MEM_OPERATOR *pMemOP;
-	int interMem = 0;
-
-	if(pUserData == NULL || pUserData->memflag != VO_IMF_USERMEMOPERATOR || pUserData->memData == NULL )
-	{
-#ifdef USE_DEAULT_MEM
-		voMemoprator.Alloc = cmnMemAlloc;
-		voMemoprator.Copy = cmnMemCopy;
-		voMemoprator.Free = cmnMemFree;
-		voMemoprator.Set = cmnMemSet;
-		voMemoprator.Check = cmnMemCheck;
-		interMem = 1;
-		pMemOP = &voMemoprator;
-#else
-		*phCodec = NULL;
-		return VO_ERR_INVALID_ARG;
-#endif
-	}
-	else
-	{
-		pMemOP = (VO_MEM_OPERATOR *)pUserData->memData;
-	} 
-	/*-------------------------------------------------------------------------*
-	 * Memory allocation for coder state.                                      *
-	 *-------------------------------------------------------------------------*/
-	if ((st = (Coder_State *)mem_malloc(pMemOP, sizeof(Coder_State), 32, VO_INDEX_ENC_AMRWB)) == NULL)
-	{
-		return VO_ERR_OUTOF_MEMORY;
-	}
-
-	st->vadSt = NULL;                      
-	st->dtx_encSt = NULL;                  
-	st->sid_update_counter = 3;
-	st->sid_handover_debt = 0;
-	st->prev_ft = TX_SPEECH;
-	st->inputStream = NULL;
-	st->inputSize = 0;
-
-	/* Default setting */
-	st->mode = VOAMRWB_MD2385;                        /* bit rate 23.85kbps */
-	st->frameType = VOAMRWB_RFC3267;                  /* frame type: RFC3267 */
-	st->allow_dtx = 0;                                /* disable DTX mode */
-
-	st->outputStream = NULL;
-	st->outputSize = 0;
-
-	st->stream = (FrameStream *)mem_malloc(pMemOP, sizeof(FrameStream), 32, VO_INDEX_ENC_AMRWB);
-	if(st->stream == NULL)
-		return VO_ERR_OUTOF_MEMORY;
-
-	st->stream->frame_ptr = (unsigned char *)mem_malloc(pMemOP, Frame_Maxsize, 32, VO_INDEX_ENC_AMRWB);
-	if(st->stream->frame_ptr == NULL)
-		return  VO_ERR_OUTOF_MEMORY;
-
-	stream = st->stream;
-	voAWB_InitFrameBuffer(stream);
-
-	wb_vad_init(&(st->vadSt), pMemOP);
-	dtx_enc_init(&(st->dtx_encSt), isf_init, pMemOP);
-
-	Reset_encoder((void *) st, 1);
-
-	if(interMem)
-	{
-		st->voMemoprator.Alloc = cmnMemAlloc;
-		st->voMemoprator.Copy = cmnMemCopy;
-		st->voMemoprator.Free = cmnMemFree;
-		st->voMemoprator.Set = cmnMemSet;
-		st->voMemoprator.Check = cmnMemCheck;
-		pMemOP = &st->voMemoprator;
-	}
-
-	st->pvoMemop = pMemOP;
-
-	*phCodec = (void *) st;
-
-	return VO_ERR_NONE;
-}
-
-/**********************************************************************************
-*
-* Brief: Codec API function: Input PCM data
-*
-***********************************************************************************/
-
-VO_U32 VO_API voAMRWB_SetInputData(
-		VO_HANDLE hCodec,                   /* i/o: The codec handle which was created by Init function */
-		VO_CODECBUFFER * pInput             /*   i: The input buffer parameter  */
-		)
-{
-	Coder_State  *gData;
-	FrameStream  *stream;
-
-	if(NULL == hCodec)
-	{
-		return VO_ERR_INVALID_ARG;
-	}
-
-	gData = (Coder_State *)hCodec;
-	stream = gData->stream;
-
-	if(NULL == pInput || NULL == pInput->Buffer || 0 > pInput->Length)
-	{
-		return VO_ERR_INVALID_ARG;
-	}
-
-	stream->set_ptr    = pInput->Buffer;
-	stream->set_len    = pInput->Length;
-	stream->frame_ptr  = stream->frame_ptr_bk;
-	stream->used_len   = 0;
-
-	return VO_ERR_NONE;
-}
-
-/**************************************************************************************
-*
-* Brief: Codec API function: Get the compression audio data frame by frame
-*
-***************************************************************************************/
-
-VO_U32 VO_API voAMRWB_GetOutputData(
-		VO_HANDLE hCodec,                    /* i: The Codec Handle which was created by Init function*/
-		VO_CODECBUFFER * pOutput,            /* o: The output audio data */
-		VO_AUDIO_OUTPUTINFO * pAudioFormat   /* o: The encoder module filled audio format and used the input size*/
-		)
-{
-	Coder_State* gData = (Coder_State*)hCodec;
-	VO_MEM_OPERATOR  *pMemOP;
-	FrameStream  *stream = (FrameStream *)gData->stream;
-	pMemOP = (VO_MEM_OPERATOR  *)gData->pvoMemop;
-
-	if(stream->framebuffer_len  < Frame_MaxByte)         /* check the work buffer len */
-	{
-		stream->frame_storelen = stream->framebuffer_len;
-		if(stream->frame_storelen)
-		{
-			pMemOP->Copy(VO_INDEX_ENC_AMRWB, stream->frame_ptr_bk , stream->frame_ptr , stream->frame_storelen);
-		}
-		if(stream->set_len > 0)
-		{
-			voAWB_UpdateFrameBuffer(stream, pMemOP);
-		}
-		if(stream->framebuffer_len < Frame_MaxByte)
-		{
-			if(pAudioFormat)
-				pAudioFormat->InputUsed = stream->used_len;
-			return VO_ERR_INPUT_BUFFER_SMALL;
-		}
-	}
-
-	gData->inputStream = stream->frame_ptr;
-	gData->outputStream = (unsigned short*)pOutput->Buffer;
-
-	gData->outputSize = AMR_Enc_Encode(gData);         /* encoder main function */
-
-	pOutput->Length = gData->outputSize;               /* get the output buffer length */
-	stream->frame_ptr += 640;                          /* update the work buffer ptr */
-	stream->framebuffer_len  -= 640;
-
-	if(pAudioFormat)                                   /* return output audio information */
-	{
-		pAudioFormat->Format.Channels = 1;
-		pAudioFormat->Format.SampleRate = 8000;
-		pAudioFormat->Format.SampleBits = 16;	
-		pAudioFormat->InputUsed = stream->used_len;
-	}
-	return VO_ERR_NONE;
-}
-
-/*************************************************************************
-*
-* Brief: Codec API function---set the data by specified parameter ID
-*
-*************************************************************************/
-
-
-VO_U32 VO_API voAMRWB_SetParam(
-		VO_HANDLE hCodec,   /* i/o: The Codec Handle which was created by Init function */
-		VO_S32 uParamID,    /*   i: The param ID */
-		VO_PTR pData        /*   i: The param value depend on the ID */
-		)
-{
-	Coder_State* gData = (Coder_State*)hCodec;
-	FrameStream *stream = (FrameStream *)(gData->stream);
-	int *lValue = (int*)pData;
-
-	switch(uParamID)
-	{
-		/* setting AMR-WB frame type*/
-		case VO_PID_AMRWB_FRAMETYPE:
-			if(*lValue < VOAMRWB_DEFAULT || *lValue > VOAMRWB_RFC3267)
-				return VO_ERR_WRONG_PARAM_ID; 
-			gData->frameType = *lValue;
-			break;
-		/* setting AMR-WB bit rate */
-		case VO_PID_AMRWB_MODE:
-			{
-				if(*lValue < VOAMRWB_MD66 || *lValue > VOAMRWB_MD2385)
-					return VO_ERR_WRONG_PARAM_ID; 
-				gData->mode = *lValue;
-			}
-			break;
-		/* enable or disable DTX mode */
-		case VO_PID_AMRWB_DTX:
-			gData->allow_dtx = (Word16)(*lValue);
-			break;
-
-		case VO_PID_COMMON_HEADDATA:
-			break;
-        /* flush the work buffer */
-		case VO_PID_COMMON_FLUSH:
-			stream->set_ptr = NULL;
-			stream->frame_storelen = 0;
-			stream->framebuffer_len = 0;
-			stream->set_len = 0;
-			break;
-
-		default:
-			return VO_ERR_WRONG_PARAM_ID;
-	}
-	return VO_ERR_NONE;
-}
-
-/**************************************************************************
-*
-*Brief: Codec API function---Get the data by specified parameter ID
-*
-***************************************************************************/
-
-VO_U32 VO_API voAMRWB_GetParam(
-		VO_HANDLE hCodec,      /* i: The Codec Handle which was created by Init function */
-		VO_S32 uParamID,       /* i: The param ID */
-		VO_PTR pData           /* o: The param value depend on the ID */
-		)
-{
-	int    temp;
-	Coder_State* gData = (Coder_State*)hCodec;
-
-	if (gData==NULL) 
-		return VO_ERR_INVALID_ARG;
-	switch(uParamID)
-	{
-		/* output audio format */
-		case VO_PID_AMRWB_FORMAT:
-			{
-				VO_AUDIO_FORMAT* fmt = (VO_AUDIO_FORMAT*)pData;
-				fmt->Channels   = 1;
-				fmt->SampleRate = 16000;
-				fmt->SampleBits = 16;
-				break;
-			}
-        /* output audio channel number */
-		case VO_PID_AMRWB_CHANNELS:
-			temp = 1;
-			pData = (void *)(&temp);
-			break;
-        /* output audio sample rate */
-		case VO_PID_AMRWB_SAMPLERATE:
-			temp = 16000;
-			pData = (void *)(&temp);
-			break;
-		/* output audio frame type */
-		case VO_PID_AMRWB_FRAMETYPE:
-			temp = gData->frameType;
-			pData = (void *)(&temp);
-			break;
-		/* output audio bit rate */
-		case VO_PID_AMRWB_MODE:
-			temp = gData->mode;
-			pData = (void *)(&temp);
-			break;
-		default:
-			return VO_ERR_WRONG_PARAM_ID;
-	}
-
-	return VO_ERR_NONE;
-}
-
-/***********************************************************************************
-*
-* Brief: Codec API function---Release the codec after all encoder operations are done
-*
-*************************************************************************************/
-
-VO_U32 VO_API voAMRWB_Uninit(VO_HANDLE hCodec           /* i/o: Codec handle pointer */
-							 )
-{
-	Coder_State* gData = (Coder_State*)hCodec;
-	VO_MEM_OPERATOR *pMemOP;
-	pMemOP = gData->pvoMemop;
-
-	if(hCodec)
-	{
-		if(gData->stream)
-		{
-			if(gData->stream->frame_ptr_bk)
-			{
-				mem_free(pMemOP, gData->stream->frame_ptr_bk, VO_INDEX_ENC_AMRWB);
-				gData->stream->frame_ptr_bk = NULL;
-			}
-			mem_free(pMemOP, gData->stream, VO_INDEX_ENC_AMRWB);
-			gData->stream = NULL;
-		}
-		wb_vad_exit(&(((Coder_State *) gData)->vadSt), pMemOP);
-		dtx_enc_exit(&(((Coder_State *) gData)->dtx_encSt), pMemOP);
-
-		mem_free(pMemOP, hCodec, VO_INDEX_ENC_AMRWB);
-		hCodec = NULL;
-	}
-
-	return VO_ERR_NONE;
-}
-
-/********************************************************************************
-*
-* Brief: voGetAMRWBEncAPI gets the API handle of the codec
-*
-********************************************************************************/
-
-VO_S32 VO_API voGetAMRWBEncAPI(
-							   VO_AUDIO_CODECAPI * pEncHandle      /* i/o: Codec handle pointer */
-							   )
-{
-	if(NULL == pEncHandle)
-		return VO_ERR_INVALID_ARG;
-	pEncHandle->Init = voAMRWB_Init;
-	pEncHandle->SetInputData = voAMRWB_SetInputData;
-	pEncHandle->GetOutputData = voAMRWB_GetOutputData;
-	pEncHandle->SetParam = voAMRWB_SetParam;
-	pEncHandle->GetParam = voAMRWB_GetParam;
-	pEncHandle->Uninit = voAMRWB_Uninit;
-
-	return VO_ERR_NONE;
-}
-
-#ifdef __cplusplus
-}
-#endif
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: voAMRWBEnc.c                                              *
+*                                                                      *
+*      Description: Performs the main encoder routine                  *
+*                   Fixed-point C simulation of AMR WB ACELP coding    *
+*		    algorithm with 20 msspeech frames for              *
+*		    wideband speech signals.                           *
+*                                                                      *
+************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "math_op.h"
+#include "cnst.h"
+#include "acelp.h"
+#include "cod_main.h"
+#include "bits.h"
+#include "main.h"
+#include "voAMRWB.h"
+#include "mem_align.h"
+#include "cmnMemory.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* LPC interpolation coef {0.45, 0.8, 0.96, 1.0}; in Q15 */
+static Word16 interpol_frac[NB_SUBFR] = {14746, 26214, 31457, 32767};
+
+/* isp tables for initialization */
+static Word16 isp_init[M] =
+{
+	32138, 30274, 27246, 23170, 18205, 12540, 6393, 0,
+	-6393, -12540, -18205, -23170, -27246, -30274, -32138, 1475
+};
+
+static Word16 isf_init[M] =
+{
+	1024, 2048, 3072, 4096, 5120, 6144, 7168, 8192,
+	9216, 10240, 11264, 12288, 13312, 14336, 15360, 3840
+};
+
+/* High Band encoding */
+static const Word16 HP_gain[16] =
+{
+	3624, 4673, 5597, 6479, 7425, 8378, 9324, 10264,
+	11210, 12206, 13391, 14844, 16770, 19655, 24289, 32728
+};
+
+/* Private function declaration */
+static Word16 synthesis(
+			Word16 Aq[],                          /* A(z)  : quantized Az               */
+			Word16 exc[],                         /* (i)   : excitation at 12kHz        */
+			Word16 Q_new,                         /* (i)   : scaling performed on exc   */
+			Word16 synth16k[],                    /* (o)   : 16kHz synthesis signal     */
+			Coder_State * st                      /* (i/o) : State structure            */
+			);
+
+/* Codec some parameters initialization */
+void Reset_encoder(void *st, Word16 reset_all)
+{
+	Word16 i;
+	Coder_State *cod_state;
+	cod_state = (Coder_State *) st;
+	Set_zero(cod_state->old_exc, PIT_MAX + L_INTERPOL);
+	Set_zero(cod_state->mem_syn, M);
+	Set_zero(cod_state->past_isfq, M);
+	cod_state->mem_w0 = 0;
+	cod_state->tilt_code = 0;
+	cod_state->first_frame = 1;
+	Init_gp_clip(cod_state->gp_clip);
+	cod_state->L_gc_thres = 0;
+	if (reset_all != 0)
+	{
+		/* Static vectors to zero */
+		Set_zero(cod_state->old_speech, L_TOTAL - L_FRAME);
+		Set_zero(cod_state->old_wsp, (PIT_MAX / OPL_DECIM));
+		Set_zero(cod_state->mem_decim2, 3);
+		/* routines initialization */
+		Init_Decim_12k8(cod_state->mem_decim);
+		Init_HP50_12k8(cod_state->mem_sig_in);
+		Init_Levinson(cod_state->mem_levinson);
+		Init_Q_gain2(cod_state->qua_gain);
+		Init_Hp_wsp(cod_state->hp_wsp_mem);
+		/* isp initialization */
+		Copy(isp_init, cod_state->ispold, M);
+		Copy(isp_init, cod_state->ispold_q, M);
+		/* variable initialization */
+		cod_state->mem_preemph = 0;
+		cod_state->mem_wsp = 0;
+		cod_state->Q_old = 15;
+		cod_state->Q_max[0] = 15;
+		cod_state->Q_max[1] = 15;
+		cod_state->old_wsp_max = 0;
+		cod_state->old_wsp_shift = 0;
+		/* pitch ol initialization */
+		cod_state->old_T0_med = 40;
+		cod_state->ol_gain = 0;
+		cod_state->ada_w = 0;
+		cod_state->ol_wght_flg = 0;
+		for (i = 0; i < 5; i++)
+		{
+			cod_state->old_ol_lag[i] = 40;
+		}
+		Set_zero(cod_state->old_hp_wsp, (L_FRAME / 2) / OPL_DECIM + (PIT_MAX / OPL_DECIM));
+		Set_zero(cod_state->mem_syn_hf, M);
+		Set_zero(cod_state->mem_syn_hi, M);
+		Set_zero(cod_state->mem_syn_lo, M);
+		Init_HP50_12k8(cod_state->mem_sig_out);
+		Init_Filt_6k_7k(cod_state->mem_hf);
+		Init_HP400_12k8(cod_state->mem_hp400);
+		Copy(isf_init, cod_state->isfold, M);
+		cod_state->mem_deemph = 0;
+		cod_state->seed2 = 21845;
+		Init_Filt_6k_7k(cod_state->mem_hf2);
+		cod_state->gain_alpha = 32767;
+		cod_state->vad_hist = 0;
+		wb_vad_reset(cod_state->vadSt);
+		dtx_enc_reset(cod_state->dtx_encSt, isf_init);
+	}
+	return;
+}
+
+/*-----------------------------------------------------------------*
+*   Funtion  coder                                                *
+*            ~~~~~                                                *
+*   ->Main coder routine.                                         *
+*                                                                 *
+*-----------------------------------------------------------------*/
+void coder(
+		Word16 * mode,                        /* input :  used mode                             */
+		Word16 speech16k[],                   /* input :  320 new speech samples (at 16 kHz)    */
+		Word16 prms[],                        /* output:  output parameters                     */
+		Word16 * ser_size,                    /* output:  bit rate of the used mode             */
+		void *spe_state,                      /* i/o   :  State structure                       */
+		Word16 allow_dtx                      /* input :  DTX ON/OFF                            */
+	  )
+{
+	/* Coder states */
+	Coder_State *st;
+	/* Speech vector */
+	Word16 old_speech[L_TOTAL];
+	Word16 *new_speech, *speech, *p_window;
+
+	/* Weighted speech vector */
+	Word16 old_wsp[L_FRAME + (PIT_MAX / OPL_DECIM)];
+	Word16 *wsp;
+
+	/* Excitation vector */
+	Word16 old_exc[(L_FRAME + 1) + PIT_MAX + L_INTERPOL];
+	Word16 *exc;
+
+	/* LPC coefficients */
+	Word16 r_h[M + 1], r_l[M + 1];         /* Autocorrelations of windowed speech  */
+	Word16 rc[M];                          /* Reflection coefficients.             */
+	Word16 Ap[M + 1];                      /* A(z) with spectral expansion         */
+	Word16 ispnew[M];                      /* immittance spectral pairs at 4nd sfr */
+	Word16 ispnew_q[M];                    /* quantized ISPs at 4nd subframe       */
+	Word16 isf[M];                         /* ISF (frequency domain) at 4nd sfr    */
+	Word16 *p_A, *p_Aq;                    /* ptr to A(z) for the 4 subframes      */
+	Word16 A[NB_SUBFR * (M + 1)];          /* A(z) unquantized for the 4 subframes */
+	Word16 Aq[NB_SUBFR * (M + 1)];         /* A(z)   quantized for the 4 subframes */
+
+	/* Other vectors */
+	Word16 xn[L_SUBFR];                    /* Target vector for pitch search     */
+	Word16 xn2[L_SUBFR];                   /* Target vector for codebook search  */
+	Word16 dn[L_SUBFR];                    /* Correlation between xn2 and h1     */
+	Word16 cn[L_SUBFR];                    /* Target vector in residual domain   */
+	Word16 h1[L_SUBFR];                    /* Impulse response vector            */
+	Word16 h2[L_SUBFR];                    /* Impulse response vector            */
+	Word16 code[L_SUBFR];                  /* Fixed codebook excitation          */
+	Word16 y1[L_SUBFR];                    /* Filtered adaptive excitation       */
+	Word16 y2[L_SUBFR];                    /* Filtered adaptive excitation       */
+	Word16 error[M + L_SUBFR];             /* error of quantization              */
+	Word16 synth[L_SUBFR];                 /* 12.8kHz synthesis vector           */
+	Word16 exc2[L_FRAME];                  /* excitation vector                  */
+	Word16 buf[L_FRAME];                   /* VAD buffer                         */
+
+	/* Scalars */
+	Word32 i, j, i_subfr, select, pit_flag, clip_gain, vad_flag;
+	Word16 codec_mode;
+	Word16 T_op, T_op2, T0, T0_min, T0_max, T0_frac, index;
+	Word16 gain_pit, gain_code, g_coeff[4], g_coeff2[4];
+	Word16 tmp, gain1, gain2, exp, Q_new, mu, shift, max;
+	Word16 voice_fac;
+	Word16 indice[8];
+	Word32 L_tmp, L_gain_code, L_max, L_tmp1;
+	Word16 code2[L_SUBFR];                         /* Fixed codebook excitation  */
+	Word16 stab_fac, fac, gain_code_lo;
+
+	Word16 corr_gain;
+	Word16 *vo_p0, *vo_p1, *vo_p2, *vo_p3;
+
+	st = (Coder_State *) spe_state;
+
+	*ser_size = nb_of_bits[*mode];
+	codec_mode = *mode;
+
+	/*--------------------------------------------------------------------------*
+	 *          Initialize pointers to speech vector.                           *
+	 *                                                                          *
+	 *                                                                          *
+	 *                    |-------|-------|-------|-------|-------|-------|     *
+	 *                     past sp   sf1     sf2     sf3     sf4    L_NEXT      *
+	 *                    <-------  Total speech buffer (L_TOTAL)   ------>     *
+	 *              old_speech                                                  *
+	 *                    <-------  LPC analysis window (L_WINDOW)  ------>     *
+	 *                    |       <-- present frame (L_FRAME) ---->             *
+	 *                   p_window |       <----- new speech (L_FRAME) ---->     *
+	 *                            |       |                                     *
+	 *                          speech    |                                     *
+	 *                                 new_speech                               *
+	 *--------------------------------------------------------------------------*/
+
+	new_speech = old_speech + L_TOTAL - L_FRAME - L_FILT;         /* New speech     */
+	speech = old_speech + L_TOTAL - L_FRAME - L_NEXT;             /* Present frame  */
+	p_window = old_speech + L_TOTAL - L_WINDOW;
+
+	exc = old_exc + PIT_MAX + L_INTERPOL;
+	wsp = old_wsp + (PIT_MAX / OPL_DECIM);
+
+	/* copy coder memory state into working space */
+	Copy(st->old_speech, old_speech, L_TOTAL - L_FRAME);
+	Copy(st->old_wsp, old_wsp, PIT_MAX / OPL_DECIM);
+	Copy(st->old_exc, old_exc, PIT_MAX + L_INTERPOL);
+
+	/*---------------------------------------------------------------*
+	 * Down sampling signal from 16kHz to 12.8kHz                    *
+	 * -> The signal is extended by L_FILT samples (padded to zero)  *
+	 * to avoid additional delay (L_FILT samples) in the coder.      *
+	 * The last L_FILT samples are approximated after decimation and *
+	 * are used (and windowed) only in autocorrelations.             *
+	 *---------------------------------------------------------------*/
+
+	Decim_12k8(speech16k, L_FRAME16k, new_speech, st->mem_decim);
+
+	/* last L_FILT samples for autocorrelation window */
+	Copy(st->mem_decim, code, 2 * L_FILT16k);
+	Set_zero(error, L_FILT16k);            /* set next sample to zero */
+	Decim_12k8(error, L_FILT16k, new_speech + L_FRAME, code);
+
+	/*---------------------------------------------------------------*
+	 * Perform 50Hz HP filtering of input signal.                    *
+	 *---------------------------------------------------------------*/
+
+	HP50_12k8(new_speech, L_FRAME, st->mem_sig_in);
+
+	/* last L_FILT samples for autocorrelation window */
+	Copy(st->mem_sig_in, code, 6);
+	HP50_12k8(new_speech + L_FRAME, L_FILT, code);
+
+	/*---------------------------------------------------------------*
+	 * Perform fixed preemphasis through 1 - g z^-1                  *
+	 * Scale signal to get maximum of precision in filtering         *
+	 *---------------------------------------------------------------*/
+
+	mu = PREEMPH_FAC >> 1;              /* Q15 --> Q14 */
+
+	/* get max of new preemphased samples (L_FRAME+L_FILT) */
+	L_tmp = new_speech[0] << 15;
+	L_tmp -= (st->mem_preemph * mu)<<1;
+	L_max = L_abs(L_tmp);
+
+	for (i = 1; i < L_FRAME + L_FILT; i++)
+	{
+		L_tmp = new_speech[i] << 15;
+		L_tmp -= (new_speech[i - 1] * mu)<<1;
+		L_tmp = L_abs(L_tmp);
+		if(L_tmp > L_max)
+		{
+			L_max = L_tmp;
+		}
+	}
+
+	/* get scaling factor for new and previous samples */
+	/* limit scaling to Q_MAX to keep dynamic for ringing in low signal */
+	/* limit scaling to Q_MAX also to avoid a[0]<1 in syn_filt_32 */
+	tmp = extract_h(L_max);
+	if (tmp == 0)
+	{
+		shift = Q_MAX;
+	} else
+	{
+		shift = norm_s(tmp) - 1;
+		if (shift < 0)
+		{
+			shift = 0;
+		}
+		if (shift > Q_MAX)
+		{
+			shift = Q_MAX;
+		}
+	}
+	Q_new = shift;
+	if (Q_new > st->Q_max[0])
+	{
+		Q_new = st->Q_max[0];
+	}
+	if (Q_new > st->Q_max[1])
+	{
+		Q_new = st->Q_max[1];
+	}
+	exp = (Q_new - st->Q_old);
+	st->Q_old = Q_new;
+	st->Q_max[1] = st->Q_max[0];
+	st->Q_max[0] = shift;
+
+	/* preemphasis with scaling (L_FRAME+L_FILT) */
+	tmp = new_speech[L_FRAME - 1];
+
+	for (i = L_FRAME + L_FILT - 1; i > 0; i--)
+	{
+		L_tmp = new_speech[i] << 15;
+		L_tmp -= (new_speech[i - 1] * mu)<<1;
+		L_tmp = (L_tmp << Q_new);
+		new_speech[i] = vo_round(L_tmp);
+	}
+
+	L_tmp = new_speech[0] << 15;
+	L_tmp -= (st->mem_preemph * mu)<<1;
+	L_tmp = (L_tmp << Q_new);
+	new_speech[0] = vo_round(L_tmp);
+
+	st->mem_preemph = tmp;
+
+	/* scale previous samples and memory */
+
+	Scale_sig(old_speech, L_TOTAL - L_FRAME - L_FILT, exp);
+	Scale_sig(old_exc, PIT_MAX + L_INTERPOL, exp);
+	Scale_sig(st->mem_syn, M, exp);
+	Scale_sig(st->mem_decim2, 3, exp);
+	Scale_sig(&(st->mem_wsp), 1, exp);
+	Scale_sig(&(st->mem_w0), 1, exp);
+
+	/*------------------------------------------------------------------------*
+	 *  Call VAD                                                              *
+	 *  Preemphesis scale down signal in low frequency and keep dynamic in HF.*
+	 *  Vad work slightly in futur (new_speech = speech + L_NEXT - L_FILT).   *
+	 *------------------------------------------------------------------------*/
+	Copy(new_speech, buf, L_FRAME);
+
+#ifdef ASM_OPT        /* asm optimization branch */
+	Scale_sig_opt(buf, L_FRAME, 1 - Q_new);
+#else
+	Scale_sig(buf, L_FRAME, 1 - Q_new);
+#endif
+
+	vad_flag = wb_vad(st->vadSt, buf);          /* Voice Activity Detection */
+	if (vad_flag == 0)
+	{
+		st->vad_hist = (st->vad_hist + 1);
+	} else
+	{
+		st->vad_hist = 0;
+	}
+
+	/* DTX processing */
+	if (allow_dtx != 0)
+	{
+		/* Note that mode may change here */
+		tx_dtx_handler(st->dtx_encSt, vad_flag, mode);
+		*ser_size = nb_of_bits[*mode];
+	}
+
+	if(*mode != MRDTX)
+	{
+		Parm_serial(vad_flag, 1, &prms);
+	}
+	/*------------------------------------------------------------------------*
+	 *  Perform LPC analysis                                                  *
+	 *  ~~~~~~~~~~~~~~~~~~~~                                                  *
+	 *   - autocorrelation + lag windowing                                    *
+	 *   - Levinson-durbin algorithm to find a[]                              *
+	 *   - convert a[] to isp[]                                               *
+	 *   - convert isp[] to isf[] for quantization                            *
+	 *   - quantize and code the isf[]                                        *
+	 *   - convert isf[] to isp[] for interpolation                           *
+	 *   - find the interpolated ISPs and convert to a[] for the 4 subframes  *
+	 *------------------------------------------------------------------------*/
+
+	/* LP analysis centered at 4nd subframe */
+	Autocorr(p_window, M, r_h, r_l);                        /* Autocorrelations */
+	Lag_window(r_h, r_l);                                   /* Lag windowing    */
+	Levinson(r_h, r_l, A, rc, st->mem_levinson);            /* Levinson Durbin  */
+	Az_isp(A, ispnew, st->ispold);                          /* From A(z) to ISP */
+
+	/* Find the interpolated ISPs and convert to a[] for all subframes */
+	Int_isp(st->ispold, ispnew, interpol_frac, A);
+
+	/* update ispold[] for the next frame */
+	Copy(ispnew, st->ispold, M);
+
+	/* Convert ISPs to frequency domain 0..6400 */
+	Isp_isf(ispnew, isf, M);
+
+	/* check resonance for pitch clipping algorithm */
+	Gp_clip_test_isf(isf, st->gp_clip);
+
+	/*----------------------------------------------------------------------*
+	 *  Perform PITCH_OL analysis                                           *
+	 *  ~~~~~~~~~~~~~~~~~~~~~~~~~                                           *
+	 * - Find the residual res[] for the whole speech frame                 *
+	 * - Find the weighted input speech wsp[] for the whole speech frame    *
+	 * - scale wsp[] to avoid overflow in pitch estimation                  *
+	 * - Find open loop pitch lag for whole speech frame                    *
+	 *----------------------------------------------------------------------*/
+	p_A = A;
+	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
+	{
+		/* Weighting of LPC coefficients */
+		Weight_a(p_A, Ap, GAMMA1, M);
+
+#ifdef ASM_OPT                    /* asm optimization branch */
+		Residu_opt(Ap, &speech[i_subfr], &wsp[i_subfr], L_SUBFR);
+#else
+		Residu(Ap, &speech[i_subfr], &wsp[i_subfr], L_SUBFR);
+#endif
+
+		p_A += (M + 1);
+	}
+
+	Deemph2(wsp, TILT_FAC, L_FRAME, &(st->mem_wsp));
+
+	/* find maximum value on wsp[] for 12 bits scaling */
+	max = 0;
+	for (i = 0; i < L_FRAME; i++)
+	{
+		tmp = abs_s(wsp[i]);
+		if(tmp > max)
+		{
+			max = tmp;
+		}
+	}
+	tmp = st->old_wsp_max;
+	if(max > tmp)
+	{
+		tmp = max;                         /* tmp = max(wsp_max, old_wsp_max) */
+	}
+	st->old_wsp_max = max;
+
+	shift = norm_s(tmp) - 3;
+	if (shift > 0)
+	{
+		shift = 0;                         /* shift = 0..-3 */
+	}
+	/* decimation of wsp[] to search pitch in LF and to reduce complexity */
+	LP_Decim2(wsp, L_FRAME, st->mem_decim2);
+
+	/* scale wsp[] in 12 bits to avoid overflow */
+#ifdef  ASM_OPT                  /* asm optimization branch */
+	Scale_sig_opt(wsp, L_FRAME / OPL_DECIM, shift);
+#else
+	Scale_sig(wsp, L_FRAME / OPL_DECIM, shift);
+#endif
+	/* scale old_wsp (warning: exp must be Q_new-Q_old) */
+	exp = exp + (shift - st->old_wsp_shift);
+	st->old_wsp_shift = shift;
+
+	Scale_sig(old_wsp, PIT_MAX / OPL_DECIM, exp);
+	Scale_sig(st->old_hp_wsp, PIT_MAX / OPL_DECIM, exp);
+
+	scale_mem_Hp_wsp(st->hp_wsp_mem, exp);
+
+	/* Find open loop pitch lag for whole speech frame */
+
+	if(*ser_size == NBBITS_7k)
+	{
+		/* Find open loop pitch lag for whole speech frame */
+		T_op = Pitch_med_ol(wsp, st, L_FRAME / OPL_DECIM);
+	} else
+	{
+		/* Find open loop pitch lag for first 1/2 frame */
+		T_op = Pitch_med_ol(wsp, st, (L_FRAME/2) / OPL_DECIM);
+	}
+
+	if(st->ol_gain > 19661)       /* 0.6 in Q15 */
+	{
+		st->old_T0_med = Med_olag(T_op, st->old_ol_lag);
+		st->ada_w = 32767;
+	} else
+	{
+		st->ada_w = vo_mult(st->ada_w, 29491);
+	}
+
+	if(st->ada_w < 26214)
+		st->ol_wght_flg = 0;
+	else
+		st->ol_wght_flg = 1;
+
+	wb_vad_tone_detection(st->vadSt, st->ol_gain);
+	T_op *= OPL_DECIM;
+
+	if(*ser_size != NBBITS_7k)
+	{
+		/* Find open loop pitch lag for second 1/2 frame */
+		T_op2 = Pitch_med_ol(wsp + ((L_FRAME / 2) / OPL_DECIM), st, (L_FRAME/2) / OPL_DECIM);
+
+		if(st->ol_gain > 19661)   /* 0.6 in Q15 */
+		{
+			st->old_T0_med = Med_olag(T_op2, st->old_ol_lag);
+			st->ada_w = 32767;
+		} else
+		{
+			st->ada_w = mult(st->ada_w, 29491);
+		}
+
+		if(st->ada_w < 26214)
+			st->ol_wght_flg = 0;
+		else
+			st->ol_wght_flg = 1;
+
+		wb_vad_tone_detection(st->vadSt, st->ol_gain);
+
+		T_op2 *= OPL_DECIM;
+
+	} else
+	{
+		T_op2 = T_op;
+	}
+	/*----------------------------------------------------------------------*
+	 *                              DTX-CNG                                 *
+	 *----------------------------------------------------------------------*/
+	if(*mode == MRDTX)            /* CNG mode */
+	{
+		/* Buffer isf's and energy */
+#ifdef ASM_OPT                   /* asm optimization branch */
+		Residu_opt(&A[3 * (M + 1)], speech, exc, L_FRAME);
+#else
+		Residu(&A[3 * (M + 1)], speech, exc, L_FRAME);
+#endif
+
+		for (i = 0; i < L_FRAME; i++)
+		{
+			exc2[i] = shr(exc[i], Q_new);
+		}
+
+		L_tmp = 0;
+		for (i = 0; i < L_FRAME; i++)
+			L_tmp += (exc2[i] * exc2[i])<<1;
+
+		L_tmp >>= 1;
+
+		dtx_buffer(st->dtx_encSt, isf, L_tmp, codec_mode);
+
+		/* Quantize and code the ISFs */
+		dtx_enc(st->dtx_encSt, isf, exc2, &prms);
+
+		/* Convert ISFs to the cosine domain */
+		Isf_isp(isf, ispnew_q, M);
+		Isp_Az(ispnew_q, Aq, M, 0);
+
+		for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
+		{
+			corr_gain = synthesis(Aq, &exc2[i_subfr], 0, &speech16k[i_subfr * 5 / 4], st);
+		}
+		Copy(isf, st->isfold, M);
+
+		/* reset speech coder memories */
+		Reset_encoder(st, 0);
+
+		/*--------------------------------------------------*
+		 * Update signal for next frame.                    *
+		 * -> save past of speech[] and wsp[].              *
+		 *--------------------------------------------------*/
+
+		Copy(&old_speech[L_FRAME], st->old_speech, L_TOTAL - L_FRAME);
+		Copy(&old_wsp[L_FRAME / OPL_DECIM], st->old_wsp, PIT_MAX / OPL_DECIM);
+
+		return;
+	}
+	/*----------------------------------------------------------------------*
+	 *                               ACELP                                  *
+	 *----------------------------------------------------------------------*/
+
+	/* Quantize and code the ISFs */
+
+	if (*ser_size <= NBBITS_7k)
+	{
+		Qpisf_2s_36b(isf, isf, st->past_isfq, indice, 4);
+
+		Parm_serial(indice[0], 8, &prms);
+		Parm_serial(indice[1], 8, &prms);
+		Parm_serial(indice[2], 7, &prms);
+		Parm_serial(indice[3], 7, &prms);
+		Parm_serial(indice[4], 6, &prms);
+	} else
+	{
+		Qpisf_2s_46b(isf, isf, st->past_isfq, indice, 4);
+
+		Parm_serial(indice[0], 8, &prms);
+		Parm_serial(indice[1], 8, &prms);
+		Parm_serial(indice[2], 6, &prms);
+		Parm_serial(indice[3], 7, &prms);
+		Parm_serial(indice[4], 7, &prms);
+		Parm_serial(indice[5], 5, &prms);
+		Parm_serial(indice[6], 5, &prms);
+	}
+
+	/* Check stability on isf : distance between old isf and current isf */
+
+	L_tmp = 0;
+	for (i = 0; i < M - 1; i++)
+	{
+		tmp = vo_sub(isf[i], st->isfold[i]);
+		L_tmp += (tmp * tmp)<<1;
+	}
+
+	tmp = extract_h(L_shl2(L_tmp, 8));
+
+	tmp = vo_mult(tmp, 26214);                /* tmp = L_tmp*0.8/256 */
+	tmp = vo_sub(20480, tmp);                 /* 1.25 - tmp (in Q14) */
+
+	stab_fac = shl(tmp, 1);
+
+	if (stab_fac < 0)
+	{
+		stab_fac = 0;
+	}
+	Copy(isf, st->isfold, M);
+
+	/* Convert ISFs to the cosine domain */
+	Isf_isp(isf, ispnew_q, M);
+
+	if (st->first_frame != 0)
+	{
+		st->first_frame = 0;
+		Copy(ispnew_q, st->ispold_q, M);
+	}
+	/* Find the interpolated ISPs and convert to a[] for all subframes */
+
+	Int_isp(st->ispold_q, ispnew_q, interpol_frac, Aq);
+
+	/* update ispold[] for the next frame */
+	Copy(ispnew_q, st->ispold_q, M);
+
+	p_Aq = Aq;
+	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
+	{
+#ifdef ASM_OPT               /* asm optimization branch */
+		Residu_opt(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
+#else
+		Residu(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
+#endif
+		p_Aq += (M + 1);
+	}
+
+	/* Buffer isf's and energy for dtx on non-speech frame */
+	if (vad_flag == 0)
+	{
+		for (i = 0; i < L_FRAME; i++)
+		{
+			exc2[i] = exc[i] >> Q_new;
+		}
+		L_tmp = 0;
+		for (i = 0; i < L_FRAME; i++)
+			L_tmp += (exc2[i] * exc2[i])<<1;
+		L_tmp >>= 1;
+
+		dtx_buffer(st->dtx_encSt, isf, L_tmp, codec_mode);
+	}
+	/* range for closed loop pitch search in 1st subframe */
+
+	T0_min = T_op - 8;
+	if (T0_min < PIT_MIN)
+	{
+		T0_min = PIT_MIN;
+	}
+	T0_max = (T0_min + 15);
+
+	if(T0_max > PIT_MAX)
+	{
+		T0_max = PIT_MAX;
+		T0_min = T0_max - 15;
+	}
+	/*------------------------------------------------------------------------*
+	 *          Loop for every subframe in the analysis frame                 *
+	 *------------------------------------------------------------------------*
+	 *  To find the pitch and innovation parameters. The subframe size is     *
+	 *  L_SUBFR and the loop is repeated L_FRAME/L_SUBFR times.               *
+	 *     - compute the target signal for pitch search                       *
+	 *     - compute impulse response of weighted synthesis filter (h1[])     *
+	 *     - find the closed-loop pitch parameters                            *
+	 *     - encode the pitch dealy                                           *
+	 *     - find 2 lt prediction (with / without LP filter for lt pred)      *
+	 *     - find 2 pitch gains and choose the best lt prediction.            *
+	 *     - find target vector for codebook search                           *
+	 *     - update the impulse response h1[] for codebook search             *
+	 *     - correlation between target vector and impulse response           *
+	 *     - codebook search and encoding                                     *
+	 *     - VQ of pitch and codebook gains                                   *
+	 *     - find voicing factor and tilt of code for next subframe.          *
+	 *     - update states of weighting filter                                *
+	 *     - find excitation and synthesis speech                             *
+	 *------------------------------------------------------------------------*/
+	p_A = A;
+	p_Aq = Aq;
+	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
+	{
+		pit_flag = i_subfr;
+		if ((i_subfr == 2 * L_SUBFR) && (*ser_size > NBBITS_7k))
+		{
+			pit_flag = 0;
+			/* range for closed loop pitch search in 3rd subframe */
+			T0_min = (T_op2 - 8);
+
+			if (T0_min < PIT_MIN)
+			{
+				T0_min = PIT_MIN;
+			}
+			T0_max = (T0_min + 15);
+			if (T0_max > PIT_MAX)
+			{
+				T0_max = PIT_MAX;
+				T0_min = (T0_max - 15);
+			}
+		}
+		/*-----------------------------------------------------------------------*
+		 *                                                                       *
+		 *        Find the target vector for pitch search:                       *
+		 *        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                        *
+		 *                                                                       *
+		 *             |------|  res[n]                                          *
+		 * speech[n]---| A(z) |--------                                          *
+		 *             |------|       |   |--------| error[n]  |------|          *
+		 *                   zero -- (-)--| 1/A(z) |-----------| W(z) |-- target *
+		 *                   exc          |--------|           |------|          *
+		 *                                                                       *
+		 * Instead of subtracting the zero-input response of filters from        *
+		 * the weighted input speech, the above configuration is used to         *
+		 * compute the target vector.                                            *
+		 *                                                                       *
+		 *-----------------------------------------------------------------------*/
+
+		for (i = 0; i < M; i++)
+		{
+			error[i] = vo_sub(speech[i + i_subfr - M], st->mem_syn[i]);
+		}
+
+#ifdef ASM_OPT              /* asm optimization branch */
+		Residu_opt(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
+#else
+		Residu(p_Aq, &speech[i_subfr], &exc[i_subfr], L_SUBFR);
+#endif
+		Syn_filt(p_Aq, &exc[i_subfr], error + M, L_SUBFR, error, 0);
+		Weight_a(p_A, Ap, GAMMA1, M);
+
+#ifdef ASM_OPT             /* asm optimization branch */
+		Residu_opt(Ap, error + M, xn, L_SUBFR);
+#else
+		Residu(Ap, error + M, xn, L_SUBFR);
+#endif
+		Deemph2(xn, TILT_FAC, L_SUBFR, &(st->mem_w0));
+
+		/*----------------------------------------------------------------------*
+		 * Find approx. target in residual domain "cn[]" for inovation search.  *
+		 *----------------------------------------------------------------------*/
+		/* first half: xn[] --> cn[] */
+		Set_zero(code, M);
+		Copy(xn, code + M, L_SUBFR / 2);
+		tmp = 0;
+		Preemph2(code + M, TILT_FAC, L_SUBFR / 2, &tmp);
+		Weight_a(p_A, Ap, GAMMA1, M);
+		Syn_filt(Ap,code + M, code + M, L_SUBFR / 2, code, 0);
+
+#ifdef ASM_OPT                /* asm optimization branch */
+		Residu_opt(p_Aq,code + M, cn, L_SUBFR / 2);
+#else
+		Residu(p_Aq,code + M, cn, L_SUBFR / 2);
+#endif
+
+		/* second half: res[] --> cn[] (approximated and faster) */
+		Copy(&exc[i_subfr + (L_SUBFR / 2)], cn + (L_SUBFR / 2), L_SUBFR / 2);
+
+		/*---------------------------------------------------------------*
+		 * Compute impulse response, h1[], of weighted synthesis filter  *
+		 *---------------------------------------------------------------*/
+
+		Set_zero(error, M + L_SUBFR);
+		Weight_a(p_A, error + M, GAMMA1, M);
+
+		vo_p0 = error+M;
+		vo_p3 = h1;
+		for (i = 0; i < L_SUBFR; i++)
+		{
+			L_tmp = *vo_p0 << 14;        /* x4 (Q12 to Q14) */
+			vo_p1 = p_Aq + 1;
+			vo_p2 = vo_p0-1;
+			for (j = 1; j <= M/4; j++)
+			{
+				L_tmp -= *vo_p1++ * *vo_p2--;
+				L_tmp -= *vo_p1++ * *vo_p2--;
+				L_tmp -= *vo_p1++ * *vo_p2--;
+				L_tmp -= *vo_p1++ * *vo_p2--;
+			}
+			*vo_p3++ = *vo_p0++ = vo_round((L_tmp <<4));
+		}
+		/* deemph without division by 2 -> Q14 to Q15 */
+		tmp = 0;
+		Deemph2(h1, TILT_FAC, L_SUBFR, &tmp);   /* h1 in Q14 */
+
+		/* h2 in Q12 for codebook search */
+		Copy(h1, h2, L_SUBFR);
+
+		/*---------------------------------------------------------------*
+		 * scale xn[] and h1[] to avoid overflow in dot_product12()      *
+		 *---------------------------------------------------------------*/
+#ifdef  ASM_OPT                  /* asm optimization branch */
+		Scale_sig_opt(h2, L_SUBFR, -2);
+		Scale_sig_opt(xn, L_SUBFR, shift);     /* scaling of xn[] to limit dynamic at 12 bits */
+		Scale_sig_opt(h1, L_SUBFR, 1 + shift);  /* set h1[] in Q15 with scaling for convolution */
+#else
+		Scale_sig(h2, L_SUBFR, -2);
+		Scale_sig(xn, L_SUBFR, shift);     /* scaling of xn[] to limit dynamic at 12 bits */
+		Scale_sig(h1, L_SUBFR, 1 + shift);  /* set h1[] in Q15 with scaling for convolution */
+#endif
+		/*----------------------------------------------------------------------*
+		 *                 Closed-loop fractional pitch search                  *
+		 *----------------------------------------------------------------------*/
+		/* find closed loop fractional pitch  lag */
+		if(*ser_size <= NBBITS_9k)
+		{
+			T0 = Pitch_fr4(&exc[i_subfr], xn, h1, T0_min, T0_max, &T0_frac,
+					pit_flag, PIT_MIN, PIT_FR1_8b, L_SUBFR);
+
+			/* encode pitch lag */
+			if (pit_flag == 0)             /* if 1st/3rd subframe */
+			{
+				/*--------------------------------------------------------------*
+				 * The pitch range for the 1st/3rd subframe is encoded with     *
+				 * 8 bits and is divided as follows:                            *
+				 *   PIT_MIN to PIT_FR1-1  resolution 1/2 (frac = 0 or 2)       *
+				 *   PIT_FR1 to PIT_MAX    resolution 1   (frac = 0)            *
+				 *--------------------------------------------------------------*/
+				if (T0 < PIT_FR1_8b)
+				{
+					index = ((T0 << 1) + (T0_frac >> 1) - (PIT_MIN<<1));
+				} else
+				{
+					index = ((T0 - PIT_FR1_8b) + ((PIT_FR1_8b - PIT_MIN)*2));
+				}
+
+				Parm_serial(index, 8, &prms);
+
+				/* find T0_min and T0_max for subframe 2 and 4 */
+				T0_min = (T0 - 8);
+				if (T0_min < PIT_MIN)
+				{
+					T0_min = PIT_MIN;
+				}
+				T0_max = T0_min + 15;
+				if (T0_max > PIT_MAX)
+				{
+					T0_max = PIT_MAX;
+					T0_min = (T0_max - 15);
+				}
+			} else
+			{                              /* if subframe 2 or 4 */
+				/*--------------------------------------------------------------*
+				 * The pitch range for subframe 2 or 4 is encoded with 5 bits:  *
+				 *   T0_min  to T0_max     resolution 1/2 (frac = 0 or 2)       *
+				 *--------------------------------------------------------------*/
+				i = (T0 - T0_min);
+				index = (i << 1) + (T0_frac >> 1);
+
+				Parm_serial(index, 5, &prms);
+			}
+		} else
+		{
+			T0 = Pitch_fr4(&exc[i_subfr], xn, h1, T0_min, T0_max, &T0_frac,
+					pit_flag, PIT_FR2, PIT_FR1_9b, L_SUBFR);
+
+			/* encode pitch lag */
+			if (pit_flag == 0)             /* if 1st/3rd subframe */
+			{
+				/*--------------------------------------------------------------*
+				 * The pitch range for the 1st/3rd subframe is encoded with     *
+				 * 9 bits and is divided as follows:                            *
+				 *   PIT_MIN to PIT_FR2-1  resolution 1/4 (frac = 0,1,2 or 3)   *
+				 *   PIT_FR2 to PIT_FR1-1  resolution 1/2 (frac = 0 or 1)       *
+				 *   PIT_FR1 to PIT_MAX    resolution 1   (frac = 0)            *
+				 *--------------------------------------------------------------*/
+
+				if (T0 < PIT_FR2)
+				{
+					index = ((T0 << 2) + T0_frac) - (PIT_MIN << 2);
+				} else if(T0 < PIT_FR1_9b)
+				{
+					index = ((((T0 << 1) + (T0_frac >> 1)) - (PIT_FR2<<1)) + ((PIT_FR2 - PIT_MIN)<<2));
+				} else
+				{
+					index = (((T0 - PIT_FR1_9b) + ((PIT_FR2 - PIT_MIN)<<2)) + ((PIT_FR1_9b - PIT_FR2)<<1));
+				}
+
+				Parm_serial(index, 9, &prms);
+
+				/* find T0_min and T0_max for subframe 2 and 4 */
+
+				T0_min = (T0 - 8);
+				if (T0_min < PIT_MIN)
+				{
+					T0_min = PIT_MIN;
+				}
+				T0_max = T0_min + 15;
+
+				if (T0_max > PIT_MAX)
+				{
+					T0_max = PIT_MAX;
+					T0_min = (T0_max - 15);
+				}
+			} else
+			{                              /* if subframe 2 or 4 */
+				/*--------------------------------------------------------------*
+				 * The pitch range for subframe 2 or 4 is encoded with 6 bits:  *
+				 *   T0_min  to T0_max     resolution 1/4 (frac = 0,1,2 or 3)   *
+				 *--------------------------------------------------------------*/
+				i = (T0 - T0_min);
+				index = (i << 2) + T0_frac;
+				Parm_serial(index, 6, &prms);
+			}
+		}
+
+		/*-----------------------------------------------------------------*
+		 * Gain clipping test to avoid unstable synthesis on frame erasure *
+		 *-----------------------------------------------------------------*/
+
+		clip_gain = 0;
+		if((st->gp_clip[0] < 154) && (st->gp_clip[1] > 14746))
+			clip_gain = 1;
+
+		/*-----------------------------------------------------------------*
+		 * - find unity gain pitch excitation (adaptive codebook entry)    *
+		 *   with fractional interpolation.                                *
+		 * - find filtered pitch exc. y1[]=exc[] convolved with h1[])      *
+		 * - compute pitch gain1                                           *
+		 *-----------------------------------------------------------------*/
+		/* find pitch exitation */
+#ifdef ASM_OPT                  /* asm optimization branch */
+		pred_lt4_asm(&exc[i_subfr], T0, T0_frac, L_SUBFR + 1);
+#else
+		Pred_lt4(&exc[i_subfr], T0, T0_frac, L_SUBFR + 1);
+#endif
+		if (*ser_size > NBBITS_9k)
+		{
+#ifdef ASM_OPT                   /* asm optimization branch */
+			Convolve_asm(&exc[i_subfr], h1, y1, L_SUBFR);
+#else
+			Convolve(&exc[i_subfr], h1, y1, L_SUBFR);
+#endif
+			gain1 = G_pitch(xn, y1, g_coeff, L_SUBFR);
+			/* clip gain if necessary to avoid problem at decoder */
+			if ((clip_gain != 0) && (gain1 > GP_CLIP))
+			{
+				gain1 = GP_CLIP;
+			}
+			/* find energy of new target xn2[] */
+			Updt_tar(xn, dn, y1, gain1, L_SUBFR);       /* dn used temporary */
+		} else
+		{
+			gain1 = 0;
+		}
+		/*-----------------------------------------------------------------*
+		 * - find pitch excitation filtered by 1st order LP filter.        *
+		 * - find filtered pitch exc. y2[]=exc[] convolved with h1[])      *
+		 * - compute pitch gain2                                           *
+		 *-----------------------------------------------------------------*/
+		/* find pitch excitation with lp filter */
+		vo_p0 = exc + i_subfr-1;
+		vo_p1 = code;
+		/* find pitch excitation with lp filter */
+		for (i = 0; i < L_SUBFR/2; i++)
+		{
+			L_tmp = 5898 * *vo_p0++;
+			L_tmp1 = 5898 * *vo_p0;
+			L_tmp += 20972 * *vo_p0++;
+			L_tmp1 += 20972 * *vo_p0++;
+			L_tmp1 += 5898 * *vo_p0--;
+			L_tmp += 5898 * *vo_p0;
+			*vo_p1++ = (L_tmp + 0x4000)>>15;
+			*vo_p1++ = (L_tmp1 + 0x4000)>>15;
+		}
+
+#ifdef ASM_OPT                 /* asm optimization branch */
+		Convolve_asm(code, h1, y2, L_SUBFR);
+#else
+		Convolve(code, h1, y2, L_SUBFR);
+#endif
+
+		gain2 = G_pitch(xn, y2, g_coeff2, L_SUBFR);
+
+		/* clip gain if necessary to avoid problem at decoder */
+		if ((clip_gain != 0) && (gain2 > GP_CLIP))
+		{
+			gain2 = GP_CLIP;
+		}
+		/* find energy of new target xn2[] */
+		Updt_tar(xn, xn2, y2, gain2, L_SUBFR);
+		/*-----------------------------------------------------------------*
+		 * use the best prediction (minimise quadratic error).             *
+		 *-----------------------------------------------------------------*/
+		select = 0;
+		if(*ser_size > NBBITS_9k)
+		{
+			L_tmp = 0L;
+			vo_p0 = dn;
+			vo_p1 = xn2;
+			for (i = 0; i < L_SUBFR/2; i++)
+			{
+				L_tmp += *vo_p0 * *vo_p0;
+				vo_p0++;
+				L_tmp -= *vo_p1 * *vo_p1;
+				vo_p1++;
+				L_tmp += *vo_p0 * *vo_p0;
+				vo_p0++;
+				L_tmp -= *vo_p1 * *vo_p1;
+				vo_p1++;
+			}
+
+			if (L_tmp <= 0)
+			{
+				select = 1;
+			}
+			Parm_serial(select, 1, &prms);
+		}
+		if (select == 0)
+		{
+			/* use the lp filter for pitch excitation prediction */
+			gain_pit = gain2;
+			Copy(code, &exc[i_subfr], L_SUBFR);
+			Copy(y2, y1, L_SUBFR);
+			Copy(g_coeff2, g_coeff, 4);
+		} else
+		{
+			/* no filter used for pitch excitation prediction */
+			gain_pit = gain1;
+			Copy(dn, xn2, L_SUBFR);        /* target vector for codebook search */
+		}
+		/*-----------------------------------------------------------------*
+		 * - update cn[] for codebook search                               *
+		 *-----------------------------------------------------------------*/
+		Updt_tar(cn, cn, &exc[i_subfr], gain_pit, L_SUBFR);
+
+#ifdef  ASM_OPT                           /* asm optimization branch */
+		Scale_sig_opt(cn, L_SUBFR, shift);     /* scaling of cn[] to limit dynamic at 12 bits */
+#else
+		Scale_sig(cn, L_SUBFR, shift);     /* scaling of cn[] to limit dynamic at 12 bits */
+#endif
+		/*-----------------------------------------------------------------*
+		 * - include fixed-gain pitch contribution into impulse resp. h1[] *
+		 *-----------------------------------------------------------------*/
+		tmp = 0;
+		Preemph(h2, st->tilt_code, L_SUBFR, &tmp);
+
+		if (T0_frac > 2)
+			T0 = (T0 + 1);
+		Pit_shrp(h2, T0, PIT_SHARP, L_SUBFR);
+		/*-----------------------------------------------------------------*
+		 * - Correlation between target xn2[] and impulse response h1[]    *
+		 * - Innovative codebook search                                    *
+		 *-----------------------------------------------------------------*/
+		cor_h_x(h2, xn2, dn);
+		if (*ser_size <= NBBITS_7k)
+		{
+			ACELP_2t64_fx(dn, cn, h2, code, y2, indice);
+
+			Parm_serial(indice[0], 12, &prms);
+		} else if(*ser_size <= NBBITS_9k)
+		{
+			ACELP_4t64_fx(dn, cn, h2, code, y2, 20, *ser_size, indice);
+
+			Parm_serial(indice[0], 5, &prms);
+			Parm_serial(indice[1], 5, &prms);
+			Parm_serial(indice[2], 5, &prms);
+			Parm_serial(indice[3], 5, &prms);
+		} else if(*ser_size <= NBBITS_12k)
+		{
+			ACELP_4t64_fx(dn, cn, h2, code, y2, 36, *ser_size, indice);
+
+			Parm_serial(indice[0], 9, &prms);
+			Parm_serial(indice[1], 9, &prms);
+			Parm_serial(indice[2], 9, &prms);
+			Parm_serial(indice[3], 9, &prms);
+		} else if(*ser_size <= NBBITS_14k)
+		{
+			ACELP_4t64_fx(dn, cn, h2, code, y2, 44, *ser_size, indice);
+
+			Parm_serial(indice[0], 13, &prms);
+			Parm_serial(indice[1], 13, &prms);
+			Parm_serial(indice[2], 9, &prms);
+			Parm_serial(indice[3], 9, &prms);
+		} else if(*ser_size <= NBBITS_16k)
+		{
+			ACELP_4t64_fx(dn, cn, h2, code, y2, 52, *ser_size, indice);
+
+			Parm_serial(indice[0], 13, &prms);
+			Parm_serial(indice[1], 13, &prms);
+			Parm_serial(indice[2], 13, &prms);
+			Parm_serial(indice[3], 13, &prms);
+		} else if(*ser_size <= NBBITS_18k)
+		{
+			ACELP_4t64_fx(dn, cn, h2, code, y2, 64, *ser_size, indice);
+
+			Parm_serial(indice[0], 2, &prms);
+			Parm_serial(indice[1], 2, &prms);
+			Parm_serial(indice[2], 2, &prms);
+			Parm_serial(indice[3], 2, &prms);
+			Parm_serial(indice[4], 14, &prms);
+			Parm_serial(indice[5], 14, &prms);
+			Parm_serial(indice[6], 14, &prms);
+			Parm_serial(indice[7], 14, &prms);
+		} else if(*ser_size <= NBBITS_20k)
+		{
+			ACELP_4t64_fx(dn, cn, h2, code, y2, 72, *ser_size, indice);
+
+			Parm_serial(indice[0], 10, &prms);
+			Parm_serial(indice[1], 10, &prms);
+			Parm_serial(indice[2], 2, &prms);
+			Parm_serial(indice[3], 2, &prms);
+			Parm_serial(indice[4], 10, &prms);
+			Parm_serial(indice[5], 10, &prms);
+			Parm_serial(indice[6], 14, &prms);
+			Parm_serial(indice[7], 14, &prms);
+		} else
+		{
+			ACELP_4t64_fx(dn, cn, h2, code, y2, 88, *ser_size, indice);
+
+			Parm_serial(indice[0], 11, &prms);
+			Parm_serial(indice[1], 11, &prms);
+			Parm_serial(indice[2], 11, &prms);
+			Parm_serial(indice[3], 11, &prms);
+			Parm_serial(indice[4], 11, &prms);
+			Parm_serial(indice[5], 11, &prms);
+			Parm_serial(indice[6], 11, &prms);
+			Parm_serial(indice[7], 11, &prms);
+		}
+		/*-------------------------------------------------------*
+		 * - Add the fixed-gain pitch contribution to code[].    *
+		 *-------------------------------------------------------*/
+		tmp = 0;
+		Preemph(code, st->tilt_code, L_SUBFR, &tmp);
+		Pit_shrp(code, T0, PIT_SHARP, L_SUBFR);
+		/*----------------------------------------------------------*
+		 *  - Compute the fixed codebook gain                       *
+		 *  - quantize fixed codebook gain                          *
+		 *----------------------------------------------------------*/
+		if(*ser_size <= NBBITS_9k)
+		{
+			index = Q_gain2(xn, y1, Q_new + shift, y2, code, g_coeff, L_SUBFR, 6,
+					&gain_pit, &L_gain_code, clip_gain, st->qua_gain);
+			Parm_serial(index, 6, &prms);
+		} else
+		{
+			index = Q_gain2(xn, y1, Q_new + shift, y2, code, g_coeff, L_SUBFR, 7,
+					&gain_pit, &L_gain_code, clip_gain, st->qua_gain);
+			Parm_serial(index, 7, &prms);
+		}
+		/* test quantized gain of pitch for pitch clipping algorithm */
+		Gp_clip_test_gain_pit(gain_pit, st->gp_clip);
+
+		L_tmp = L_shl(L_gain_code, Q_new);
+		gain_code = extract_h(L_add(L_tmp, 0x8000));
+
+		/*----------------------------------------------------------*
+		 * Update parameters for the next subframe.                 *
+		 * - tilt of code: 0.0 (unvoiced) to 0.5 (voiced)           *
+		 *----------------------------------------------------------*/
+		/* find voice factor in Q15 (1=voiced, -1=unvoiced) */
+		Copy(&exc[i_subfr], exc2, L_SUBFR);
+
+#ifdef ASM_OPT                           /* asm optimization branch */
+		Scale_sig_opt(exc2, L_SUBFR, shift);
+#else
+		Scale_sig(exc2, L_SUBFR, shift);
+#endif
+		voice_fac = voice_factor(exc2, shift, gain_pit, code, gain_code, L_SUBFR);
+		/* tilt of code for next subframe: 0.5=voiced, 0=unvoiced */
+		st->tilt_code = ((voice_fac >> 2) + 8192);
+		/*------------------------------------------------------*
+		 * - Update filter's memory "mem_w0" for finding the    *
+		 *   target vector in the next subframe.                *
+		 * - Find the total excitation                          *
+		 * - Find synthesis speech to update mem_syn[].         *
+		 *------------------------------------------------------*/
+
+		/* y2 in Q9, gain_pit in Q14 */
+		L_tmp = (gain_code * y2[L_SUBFR - 1])<<1;
+		L_tmp = L_shl(L_tmp, (5 + shift));
+		L_tmp = L_negate(L_tmp);
+		L_tmp += (xn[L_SUBFR - 1] * 16384)<<1;
+		L_tmp -= (y1[L_SUBFR - 1] * gain_pit)<<1;
+		L_tmp = L_shl(L_tmp, (1 - shift));
+		st->mem_w0 = extract_h(L_add(L_tmp, 0x8000));
+
+		if (*ser_size >= NBBITS_24k)
+			Copy(&exc[i_subfr], exc2, L_SUBFR);
+
+		for (i = 0; i < L_SUBFR; i++)
+		{
+			/* code in Q9, gain_pit in Q14 */
+			L_tmp = (gain_code * code[i])<<1;
+			L_tmp = (L_tmp << 5);
+			L_tmp += (exc[i + i_subfr] * gain_pit)<<1;
+			L_tmp = L_shl2(L_tmp, 1);
+			exc[i + i_subfr] = extract_h(L_add(L_tmp, 0x8000));
+		}
+
+		Syn_filt(p_Aq,&exc[i_subfr], synth, L_SUBFR, st->mem_syn, 1);
+
+		if(*ser_size >= NBBITS_24k)
+		{
+			/*------------------------------------------------------------*
+			 * phase dispersion to enhance noise in low bit rate          *
+			 *------------------------------------------------------------*/
+			/* L_gain_code in Q16 */
+			VO_L_Extract(L_gain_code, &gain_code, &gain_code_lo);
+
+			/*------------------------------------------------------------*
+			 * noise enhancer                                             *
+			 * ~~~~~~~~~~~~~~                                             *
+			 * - Enhance excitation on noise. (modify gain of code)       *
+			 *   If signal is noisy and LPC filter is stable, move gain   *
+			 *   of code 1.5 dB toward gain of code threshold.            *
+			 *   This decrease by 3 dB noise energy variation.            *
+			 *------------------------------------------------------------*/
+			tmp = (16384 - (voice_fac >> 1));        /* 1=unvoiced, 0=voiced */
+			fac = vo_mult(stab_fac, tmp);
+			L_tmp = L_gain_code;
+			if(L_tmp < st->L_gc_thres)
+			{
+				L_tmp = vo_L_add(L_tmp, Mpy_32_16(gain_code, gain_code_lo, 6226));
+				if(L_tmp > st->L_gc_thres)
+				{
+					L_tmp = st->L_gc_thres;
+				}
+			} else
+			{
+				L_tmp = Mpy_32_16(gain_code, gain_code_lo, 27536);
+				if(L_tmp < st->L_gc_thres)
+				{
+					L_tmp = st->L_gc_thres;
+				}
+			}
+			st->L_gc_thres = L_tmp;
+
+			L_gain_code = Mpy_32_16(gain_code, gain_code_lo, (32767 - fac));
+			VO_L_Extract(L_tmp, &gain_code, &gain_code_lo);
+			L_gain_code = vo_L_add(L_gain_code, Mpy_32_16(gain_code, gain_code_lo, fac));
+
+			/*------------------------------------------------------------*
+			 * pitch enhancer                                             *
+			 * ~~~~~~~~~~~~~~                                             *
+			 * - Enhance excitation on voice. (HP filtering of code)      *
+			 *   On voiced signal, filtering of code by a smooth fir HP   *
+			 *   filter to decrease energy of code in low frequency.      *
+			 *------------------------------------------------------------*/
+
+			tmp = ((voice_fac >> 3) + 4096); /* 0.25=voiced, 0=unvoiced */
+
+			L_tmp = L_deposit_h(code[0]);
+			L_tmp -= (code[1] * tmp)<<1;
+			code2[0] = vo_round(L_tmp);
+
+			for (i = 1; i < L_SUBFR - 1; i++)
+			{
+				L_tmp = L_deposit_h(code[i]);
+				L_tmp -= (code[i + 1] * tmp)<<1;
+				L_tmp -= (code[i - 1] * tmp)<<1;
+				code2[i] = vo_round(L_tmp);
+			}
+
+			L_tmp = L_deposit_h(code[L_SUBFR - 1]);
+			L_tmp -= (code[L_SUBFR - 2] * tmp)<<1;
+			code2[L_SUBFR - 1] = vo_round(L_tmp);
+
+			/* build excitation */
+			gain_code = vo_round(L_shl(L_gain_code, Q_new));
+
+			for (i = 0; i < L_SUBFR; i++)
+			{
+				L_tmp = (code2[i] * gain_code)<<1;
+				L_tmp = (L_tmp << 5);
+				L_tmp += (exc2[i] * gain_pit)<<1;
+				L_tmp = (L_tmp << 1);
+				exc2[i] = vo_round(L_tmp);
+			}
+
+			corr_gain = synthesis(p_Aq, exc2, Q_new, &speech16k[i_subfr * 5 / 4], st);
+			Parm_serial(corr_gain, 4, &prms);
+		}
+		p_A += (M + 1);
+		p_Aq += (M + 1);
+	}                                      /* end of subframe loop */
+
+	/*--------------------------------------------------*
+	 * Update signal for next frame.                    *
+	 * -> save past of speech[], wsp[] and exc[].       *
+	 *--------------------------------------------------*/
+	Copy(&old_speech[L_FRAME], st->old_speech, L_TOTAL - L_FRAME);
+	Copy(&old_wsp[L_FRAME / OPL_DECIM], st->old_wsp, PIT_MAX / OPL_DECIM);
+	Copy(&old_exc[L_FRAME], st->old_exc, PIT_MAX + L_INTERPOL);
+	return;
+}
+
+/*-----------------------------------------------------*
+* Function synthesis()                                *
+*                                                     *
+* Synthesis of signal at 16kHz with HF extension.     *
+*                                                     *
+*-----------------------------------------------------*/
+
+static Word16 synthesis(
+		Word16 Aq[],                          /* A(z)  : quantized Az               */
+		Word16 exc[],                         /* (i)   : excitation at 12kHz        */
+		Word16 Q_new,                         /* (i)   : scaling performed on exc   */
+		Word16 synth16k[],                    /* (o)   : 16kHz synthesis signal     */
+		Coder_State * st                      /* (i/o) : State structure            */
+		)
+{
+	Word16 fac, tmp, exp;
+	Word16 ener, exp_ener;
+	Word32 L_tmp, i;
+
+	Word16 synth_hi[M + L_SUBFR], synth_lo[M + L_SUBFR];
+	Word16 synth[L_SUBFR];
+	Word16 HF[L_SUBFR16k];                 /* High Frequency vector      */
+	Word16 Ap[M + 1];
+
+	Word16 HF_SP[L_SUBFR16k];              /* High Frequency vector (from original signal) */
+
+	Word16 HP_est_gain, HP_calc_gain, HP_corr_gain;
+	Word16 dist_min, dist;
+	Word16 HP_gain_ind = 0;
+	Word16 gain1, gain2;
+	Word16 weight1, weight2;
+
+	/*------------------------------------------------------------*
+	 * speech synthesis                                           *
+	 * ~~~~~~~~~~~~~~~~                                           *
+	 * - Find synthesis speech corresponding to exc2[].           *
+	 * - Perform fixed deemphasis and hp 50hz filtering.          *
+	 * - Oversampling from 12.8kHz to 16kHz.                      *
+	 *------------------------------------------------------------*/
+	Copy(st->mem_syn_hi, synth_hi, M);
+	Copy(st->mem_syn_lo, synth_lo, M);
+
+#ifdef ASM_OPT                 /* asm optimization branch */
+	Syn_filt_32_asm(Aq, M, exc, Q_new, synth_hi + M, synth_lo + M, L_SUBFR);
+#else
+	Syn_filt_32(Aq, M, exc, Q_new, synth_hi + M, synth_lo + M, L_SUBFR);
+#endif
+
+	Copy(synth_hi + L_SUBFR, st->mem_syn_hi, M);
+	Copy(synth_lo + L_SUBFR, st->mem_syn_lo, M);
+
+#ifdef ASM_OPT                 /* asm optimization branch */
+	Deemph_32_asm(synth_hi + M, synth_lo + M, synth, &(st->mem_deemph));
+#else
+	Deemph_32(synth_hi + M, synth_lo + M, synth, PREEMPH_FAC, L_SUBFR, &(st->mem_deemph));
+#endif
+
+	HP50_12k8(synth, L_SUBFR, st->mem_sig_out);
+
+	/* Original speech signal as reference for high band gain quantisation */
+	for (i = 0; i < L_SUBFR16k; i++)
+	{
+		HF_SP[i] = synth16k[i];
+	}
+
+	/*------------------------------------------------------*
+	 * HF noise synthesis                                   *
+	 * ~~~~~~~~~~~~~~~~~~                                   *
+	 * - Generate HF noise between 5.5 and 7.5 kHz.         *
+	 * - Set energy of noise according to synthesis tilt.   *
+	 *     tilt > 0.8 ==> - 14 dB (voiced)                  *
+	 *     tilt   0.5 ==> - 6 dB  (voiced or noise)         *
+	 *     tilt < 0.0 ==>   0 dB  (noise)                   *
+	 *------------------------------------------------------*/
+	/* generate white noise vector */
+	for (i = 0; i < L_SUBFR16k; i++)
+	{
+		HF[i] = Random(&(st->seed2))>>3;
+	}
+	/* energy of excitation */
+#ifdef ASM_OPT                    /* asm optimization branch */
+	Scale_sig_opt(exc, L_SUBFR, -3);
+	Q_new = Q_new - 3;
+	ener = extract_h(Dot_product12_asm(exc, exc, L_SUBFR, &exp_ener));
+#else
+	Scale_sig(exc, L_SUBFR, -3);
+	Q_new = Q_new - 3;
+	ener = extract_h(Dot_product12(exc, exc, L_SUBFR, &exp_ener));
+#endif
+
+	exp_ener = exp_ener - (Q_new + Q_new);
+	/* set energy of white noise to energy of excitation */
+#ifdef ASM_OPT              /* asm optimization branch */
+	tmp = extract_h(Dot_product12_asm(HF, HF, L_SUBFR16k, &exp));
+#else
+	tmp = extract_h(Dot_product12(HF, HF, L_SUBFR16k, &exp));
+#endif
+
+	if(tmp > ener)
+	{
+		tmp = (tmp >> 1);                 /* Be sure tmp < ener */
+		exp = (exp + 1);
+	}
+	L_tmp = L_deposit_h(div_s(tmp, ener)); /* result is normalized */
+	exp = (exp - exp_ener);
+	Isqrt_n(&L_tmp, &exp);
+	L_tmp = L_shl(L_tmp, (exp + 1));       /* L_tmp x 2, L_tmp in Q31 */
+	tmp = extract_h(L_tmp);                /* tmp = 2 x sqrt(ener_exc/ener_hf) */
+
+	for (i = 0; i < L_SUBFR16k; i++)
+	{
+		HF[i] = vo_mult(HF[i], tmp);
+	}
+
+	/* find tilt of synthesis speech (tilt: 1=voiced, -1=unvoiced) */
+	HP400_12k8(synth, L_SUBFR, st->mem_hp400);
+
+	L_tmp = 1L;
+	for (i = 0; i < L_SUBFR; i++)
+		L_tmp += (synth[i] * synth[i])<<1;
+
+	exp = norm_l(L_tmp);
+	ener = extract_h(L_tmp << exp);   /* ener = r[0] */
+
+	L_tmp = 1L;
+	for (i = 1; i < L_SUBFR; i++)
+		L_tmp +=(synth[i] * synth[i - 1])<<1;
+
+	tmp = extract_h(L_tmp << exp);    /* tmp = r[1] */
+
+	if (tmp > 0)
+	{
+		fac = div_s(tmp, ener);
+	} else
+	{
+		fac = 0;
+	}
+
+	/* modify energy of white noise according to synthesis tilt */
+	gain1 = 32767 - fac;
+	gain2 = vo_mult(gain1, 20480);
+	gain2 = shl(gain2, 1);
+
+	if (st->vad_hist > 0)
+	{
+		weight1 = 0;
+		weight2 = 32767;
+	} else
+	{
+		weight1 = 32767;
+		weight2 = 0;
+	}
+	tmp = vo_mult(weight1, gain1);
+	tmp = add1(tmp, vo_mult(weight2, gain2));
+
+	if (tmp != 0)
+	{
+		tmp = (tmp + 1);
+	}
+	HP_est_gain = tmp;
+
+	if(HP_est_gain < 3277)
+	{
+		HP_est_gain = 3277;                /* 0.1 in Q15 */
+	}
+	/* synthesis of noise: 4.8kHz..5.6kHz --> 6kHz..7kHz */
+	Weight_a(Aq, Ap, 19661, M);            /* fac=0.6 */
+
+#ifdef ASM_OPT                /* asm optimization branch */
+	Syn_filt_asm(Ap, HF, HF, st->mem_syn_hf);
+	/* noise High Pass filtering (1ms of delay) */
+	Filt_6k_7k_asm(HF, L_SUBFR16k, st->mem_hf);
+	/* filtering of the original signal */
+	Filt_6k_7k_asm(HF_SP, L_SUBFR16k, st->mem_hf2);
+
+	/* check the gain difference */
+	Scale_sig_opt(HF_SP, L_SUBFR16k, -1);
+	ener = extract_h(Dot_product12_asm(HF_SP, HF_SP, L_SUBFR16k, &exp_ener));
+	/* set energy of white noise to energy of excitation */
+	tmp = extract_h(Dot_product12_asm(HF, HF, L_SUBFR16k, &exp));
+#else
+	Syn_filt(Ap, HF, HF, L_SUBFR16k, st->mem_syn_hf, 1);
+	/* noise High Pass filtering (1ms of delay) */
+	Filt_6k_7k(HF, L_SUBFR16k, st->mem_hf);
+	/* filtering of the original signal */
+	Filt_6k_7k(HF_SP, L_SUBFR16k, st->mem_hf2);
+	/* check the gain difference */
+	Scale_sig(HF_SP, L_SUBFR16k, -1);
+	ener = extract_h(Dot_product12(HF_SP, HF_SP, L_SUBFR16k, &exp_ener));
+	/* set energy of white noise to energy of excitation */
+	tmp = extract_h(Dot_product12(HF, HF, L_SUBFR16k, &exp));
+#endif
+
+	if (tmp > ener)
+	{
+		tmp = (tmp >> 1);                 /* Be sure tmp < ener */
+		exp = (exp + 1);
+	}
+	L_tmp = L_deposit_h(div_s(tmp, ener)); /* result is normalized */
+	exp = vo_sub(exp, exp_ener);
+	Isqrt_n(&L_tmp, &exp);
+	L_tmp = L_shl(L_tmp, exp);             /* L_tmp, L_tmp in Q31 */
+	HP_calc_gain = extract_h(L_tmp);       /* tmp = sqrt(ener_input/ener_hf) */
+
+	/* st->gain_alpha *= st->dtx_encSt->dtxHangoverCount/7 */
+	L_tmp = (vo_L_mult(st->dtx_encSt->dtxHangoverCount, 4681) << 15);
+	st->gain_alpha = vo_mult(st->gain_alpha, extract_h(L_tmp));
+
+	if(st->dtx_encSt->dtxHangoverCount > 6)
+		st->gain_alpha = 32767;
+	HP_est_gain = HP_est_gain >> 1;     /* From Q15 to Q14 */
+	HP_corr_gain = add1(vo_mult(HP_calc_gain, st->gain_alpha), vo_mult((32767 - st->gain_alpha), HP_est_gain));
+
+	/* Quantise the correction gain */
+	dist_min = 32767;
+	for (i = 0; i < 16; i++)
+	{
+		dist = vo_mult((HP_corr_gain - HP_gain[i]), (HP_corr_gain - HP_gain[i]));
+		if (dist_min > dist)
+		{
+			dist_min = dist;
+			HP_gain_ind = i;
+		}
+	}
+	HP_corr_gain = HP_gain[HP_gain_ind];
+	/* return the quantised gain index when using the highest mode, otherwise zero */
+	return (HP_gain_ind);
+}
+
+/*************************************************
+*
+* Breif: Codec main function
+*
+**************************************************/
+
+int AMR_Enc_Encode(HAMRENC hCodec)
+{
+	Word32 i;
+	Coder_State *gData = (Coder_State*)hCodec;
+	Word16 *signal;
+	Word16 packed_size = 0;
+	Word16 prms[NB_BITS_MAX];
+	Word16 coding_mode = 0, nb_bits, allow_dtx, mode, reset_flag;
+	mode = gData->mode;
+	coding_mode = gData->mode;
+	nb_bits = nb_of_bits[mode];
+	signal = (Word16 *)gData->inputStream;
+	allow_dtx = gData->allow_dtx;
+
+	/* check for homing frame */
+	reset_flag = encoder_homing_frame_test(signal);
+
+	for (i = 0; i < L_FRAME16k; i++)   /* Delete the 2 LSBs (14-bit input) */
+	{
+		*(signal + i) = (Word16) (*(signal + i) & 0xfffC);
+	}
+
+	coder(&coding_mode, signal, prms, &nb_bits, gData, allow_dtx);
+	packed_size = PackBits(prms, coding_mode, mode, gData);
+	if (reset_flag != 0)
+	{
+		Reset_encoder(gData, 1);
+	}
+	return packed_size;
+}
+
+/***************************************************************************
+*
+*Brief: Codec API function --- Initialize the codec and return a codec handle
+*
+***************************************************************************/
+
+VO_U32 VO_API voAMRWB_Init(VO_HANDLE * phCodec,                   /* o: the audio codec handle */
+						   VO_AUDIO_CODINGTYPE vType,             /* i: Codec Type ID */
+						   VO_CODEC_INIT_USERDATA * pUserData     /* i: init Parameters */
+						   )
+{
+	Coder_State *st;
+	FrameStream *stream;
+#ifdef USE_DEAULT_MEM
+	VO_MEM_OPERATOR voMemoprator;
+#endif
+	VO_MEM_OPERATOR *pMemOP;
+	int interMem = 0;
+
+	if(pUserData == NULL || pUserData->memflag != VO_IMF_USERMEMOPERATOR || pUserData->memData == NULL )
+	{
+#ifdef USE_DEAULT_MEM
+		voMemoprator.Alloc = cmnMemAlloc;
+		voMemoprator.Copy = cmnMemCopy;
+		voMemoprator.Free = cmnMemFree;
+		voMemoprator.Set = cmnMemSet;
+		voMemoprator.Check = cmnMemCheck;
+		interMem = 1;
+		pMemOP = &voMemoprator;
+#else
+		*phCodec = NULL;
+		return VO_ERR_INVALID_ARG;
+#endif
+	}
+	else
+	{
+		pMemOP = (VO_MEM_OPERATOR *)pUserData->memData;
+	}
+	/*-------------------------------------------------------------------------*
+	 * Memory allocation for coder state.                                      *
+	 *-------------------------------------------------------------------------*/
+	if ((st = (Coder_State *)mem_malloc(pMemOP, sizeof(Coder_State), 32, VO_INDEX_ENC_AMRWB)) == NULL)
+	{
+		return VO_ERR_OUTOF_MEMORY;
+	}
+
+	st->vadSt = NULL;
+	st->dtx_encSt = NULL;
+	st->sid_update_counter = 3;
+	st->sid_handover_debt = 0;
+	st->prev_ft = TX_SPEECH;
+	st->inputStream = NULL;
+	st->inputSize = 0;
+
+	/* Default setting */
+	st->mode = VOAMRWB_MD2385;                        /* bit rate 23.85kbps */
+	st->frameType = VOAMRWB_RFC3267;                  /* frame type: RFC3267 */
+	st->allow_dtx = 0;                                /* disable DTX mode */
+
+	st->outputStream = NULL;
+	st->outputSize = 0;
+
+	st->stream = (FrameStream *)mem_malloc(pMemOP, sizeof(FrameStream), 32, VO_INDEX_ENC_AMRWB);
+	if(st->stream == NULL)
+		return VO_ERR_OUTOF_MEMORY;
+
+	st->stream->frame_ptr = (unsigned char *)mem_malloc(pMemOP, Frame_Maxsize, 32, VO_INDEX_ENC_AMRWB);
+	if(st->stream->frame_ptr == NULL)
+		return  VO_ERR_OUTOF_MEMORY;
+
+	stream = st->stream;
+	voAWB_InitFrameBuffer(stream);
+
+	wb_vad_init(&(st->vadSt), pMemOP);
+	dtx_enc_init(&(st->dtx_encSt), isf_init, pMemOP);
+
+	Reset_encoder((void *) st, 1);
+
+	if(interMem)
+	{
+		st->voMemoprator.Alloc = cmnMemAlloc;
+		st->voMemoprator.Copy = cmnMemCopy;
+		st->voMemoprator.Free = cmnMemFree;
+		st->voMemoprator.Set = cmnMemSet;
+		st->voMemoprator.Check = cmnMemCheck;
+		pMemOP = &st->voMemoprator;
+	}
+
+	st->pvoMemop = pMemOP;
+
+	*phCodec = (void *) st;
+
+	return VO_ERR_NONE;
+}
+
+/**********************************************************************************
+*
+* Brief: Codec API function: Input PCM data
+*
+***********************************************************************************/
+
+VO_U32 VO_API voAMRWB_SetInputData(
+		VO_HANDLE hCodec,                   /* i/o: The codec handle which was created by Init function */
+		VO_CODECBUFFER * pInput             /*   i: The input buffer parameter  */
+		)
+{
+	Coder_State  *gData;
+	FrameStream  *stream;
+
+	if(NULL == hCodec)
+	{
+		return VO_ERR_INVALID_ARG;
+	}
+
+	gData = (Coder_State *)hCodec;
+	stream = gData->stream;
+
+	if(NULL == pInput || NULL == pInput->Buffer || 0 > pInput->Length)
+	{
+		return VO_ERR_INVALID_ARG;
+	}
+
+	stream->set_ptr    = pInput->Buffer;
+	stream->set_len    = pInput->Length;
+	stream->frame_ptr  = stream->frame_ptr_bk;
+	stream->used_len   = 0;
+
+	return VO_ERR_NONE;
+}
+
+/**************************************************************************************
+*
+* Brief: Codec API function: Get the compression audio data frame by frame
+*
+***************************************************************************************/
+
+VO_U32 VO_API voAMRWB_GetOutputData(
+		VO_HANDLE hCodec,                    /* i: The Codec Handle which was created by Init function*/
+		VO_CODECBUFFER * pOutput,            /* o: The output audio data */
+		VO_AUDIO_OUTPUTINFO * pAudioFormat   /* o: The encoder module filled audio format and used the input size*/
+		)
+{
+	Coder_State* gData = (Coder_State*)hCodec;
+	VO_MEM_OPERATOR  *pMemOP;
+	FrameStream  *stream = (FrameStream *)gData->stream;
+	pMemOP = (VO_MEM_OPERATOR  *)gData->pvoMemop;
+
+	if(stream->framebuffer_len  < Frame_MaxByte)         /* check the work buffer len */
+	{
+		stream->frame_storelen = stream->framebuffer_len;
+		if(stream->frame_storelen)
+		{
+			pMemOP->Copy(VO_INDEX_ENC_AMRWB, stream->frame_ptr_bk , stream->frame_ptr , stream->frame_storelen);
+		}
+		if(stream->set_len > 0)
+		{
+			voAWB_UpdateFrameBuffer(stream, pMemOP);
+		}
+		if(stream->framebuffer_len < Frame_MaxByte)
+		{
+			if(pAudioFormat)
+				pAudioFormat->InputUsed = stream->used_len;
+			return VO_ERR_INPUT_BUFFER_SMALL;
+		}
+	}
+
+	gData->inputStream = stream->frame_ptr;
+	gData->outputStream = (unsigned short*)pOutput->Buffer;
+
+	gData->outputSize = AMR_Enc_Encode(gData);         /* encoder main function */
+
+	pOutput->Length = gData->outputSize;               /* get the output buffer length */
+	stream->frame_ptr += 640;                          /* update the work buffer ptr */
+	stream->framebuffer_len  -= 640;
+
+	if(pAudioFormat)                                   /* return output audio information */
+	{
+		pAudioFormat->Format.Channels = 1;
+		pAudioFormat->Format.SampleRate = 8000;
+		pAudioFormat->Format.SampleBits = 16;
+		pAudioFormat->InputUsed = stream->used_len;
+	}
+	return VO_ERR_NONE;
+}
+
+/*************************************************************************
+*
+* Brief: Codec API function---set the data by specified parameter ID
+*
+*************************************************************************/
+
+
+VO_U32 VO_API voAMRWB_SetParam(
+		VO_HANDLE hCodec,   /* i/o: The Codec Handle which was created by Init function */
+		VO_S32 uParamID,    /*   i: The param ID */
+		VO_PTR pData        /*   i: The param value depend on the ID */
+		)
+{
+	Coder_State* gData = (Coder_State*)hCodec;
+	FrameStream *stream = (FrameStream *)(gData->stream);
+	int *lValue = (int*)pData;
+
+	switch(uParamID)
+	{
+		/* setting AMR-WB frame type*/
+		case VO_PID_AMRWB_FRAMETYPE:
+			if(*lValue < VOAMRWB_DEFAULT || *lValue > VOAMRWB_RFC3267)
+				return VO_ERR_WRONG_PARAM_ID;
+			gData->frameType = *lValue;
+			break;
+		/* setting AMR-WB bit rate */
+		case VO_PID_AMRWB_MODE:
+			{
+				if(*lValue < VOAMRWB_MD66 || *lValue > VOAMRWB_MD2385)
+					return VO_ERR_WRONG_PARAM_ID;
+				gData->mode = *lValue;
+			}
+			break;
+		/* enable or disable DTX mode */
+		case VO_PID_AMRWB_DTX:
+			gData->allow_dtx = (Word16)(*lValue);
+			break;
+
+		case VO_PID_COMMON_HEADDATA:
+			break;
+        /* flush the work buffer */
+		case VO_PID_COMMON_FLUSH:
+			stream->set_ptr = NULL;
+			stream->frame_storelen = 0;
+			stream->framebuffer_len = 0;
+			stream->set_len = 0;
+			break;
+
+		default:
+			return VO_ERR_WRONG_PARAM_ID;
+	}
+	return VO_ERR_NONE;
+}
+
+/**************************************************************************
+*
+*Brief: Codec API function---Get the data by specified parameter ID
+*
+***************************************************************************/
+
+VO_U32 VO_API voAMRWB_GetParam(
+		VO_HANDLE hCodec,      /* i: The Codec Handle which was created by Init function */
+		VO_S32 uParamID,       /* i: The param ID */
+		VO_PTR pData           /* o: The param value depend on the ID */
+		)
+{
+	int    temp;
+	Coder_State* gData = (Coder_State*)hCodec;
+
+	if (gData==NULL)
+		return VO_ERR_INVALID_ARG;
+	switch(uParamID)
+	{
+		/* output audio format */
+		case VO_PID_AMRWB_FORMAT:
+			{
+				VO_AUDIO_FORMAT* fmt = (VO_AUDIO_FORMAT*)pData;
+				fmt->Channels   = 1;
+				fmt->SampleRate = 16000;
+				fmt->SampleBits = 16;
+				break;
+			}
+        /* output audio channel number */
+		case VO_PID_AMRWB_CHANNELS:
+			temp = 1;
+			pData = (void *)(&temp);
+			break;
+        /* output audio sample rate */
+		case VO_PID_AMRWB_SAMPLERATE:
+			temp = 16000;
+			pData = (void *)(&temp);
+			break;
+		/* output audio frame type */
+		case VO_PID_AMRWB_FRAMETYPE:
+			temp = gData->frameType;
+			pData = (void *)(&temp);
+			break;
+		/* output audio bit rate */
+		case VO_PID_AMRWB_MODE:
+			temp = gData->mode;
+			pData = (void *)(&temp);
+			break;
+		default:
+			return VO_ERR_WRONG_PARAM_ID;
+	}
+
+	return VO_ERR_NONE;
+}
+
+/***********************************************************************************
+*
+* Brief: Codec API function---Release the codec after all encoder operations are done
+*
+*************************************************************************************/
+
+VO_U32 VO_API voAMRWB_Uninit(VO_HANDLE hCodec           /* i/o: Codec handle pointer */
+							 )
+{
+	Coder_State* gData = (Coder_State*)hCodec;
+	VO_MEM_OPERATOR *pMemOP;
+	pMemOP = gData->pvoMemop;
+
+	if(hCodec)
+	{
+		if(gData->stream)
+		{
+			if(gData->stream->frame_ptr_bk)
+			{
+				mem_free(pMemOP, gData->stream->frame_ptr_bk, VO_INDEX_ENC_AMRWB);
+				gData->stream->frame_ptr_bk = NULL;
+			}
+			mem_free(pMemOP, gData->stream, VO_INDEX_ENC_AMRWB);
+			gData->stream = NULL;
+		}
+		wb_vad_exit(&(((Coder_State *) gData)->vadSt), pMemOP);
+		dtx_enc_exit(&(((Coder_State *) gData)->dtx_encSt), pMemOP);
+
+		mem_free(pMemOP, hCodec, VO_INDEX_ENC_AMRWB);
+		hCodec = NULL;
+	}
+
+	return VO_ERR_NONE;
+}
+
+/********************************************************************************
+*
+* Brief: voGetAMRWBEncAPI gets the API handle of the codec
+*
+********************************************************************************/
+
+VO_S32 VO_API voGetAMRWBEncAPI(
+							   VO_AUDIO_CODECAPI * pEncHandle      /* i/o: Codec handle pointer */
+							   )
+{
+	if(NULL == pEncHandle)
+		return VO_ERR_INVALID_ARG;
+	pEncHandle->Init = voAMRWB_Init;
+	pEncHandle->SetInputData = voAMRWB_SetInputData;
+	pEncHandle->GetOutputData = voAMRWB_GetOutputData;
+	pEncHandle->SetParam = voAMRWB_SetParam;
+	pEncHandle->GetParam = voAMRWB_GetParam;
+	pEncHandle->Uninit = voAMRWB_Uninit;
+
+	return VO_ERR_NONE;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/media/libstagefright/codecs/amrwbenc/src/voicefac.c b/media/libstagefright/codecs/amrwbenc/src/voicefac.c
index 187d774..d890044 100644
--- a/media/libstagefright/codecs/amrwbenc/src/voicefac.c
+++ b/media/libstagefright/codecs/amrwbenc/src/voicefac.c
@@ -1,92 +1,92 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*   File: voicefac.c                                                   *
-*                                                                      *
-*   Description: Find the voicing factors (1 = voice to -1 = unvoiced) *
-*                                                                      *                                                 
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-
-Word16 voice_factor(                                  /* (o) Q15   : factor (-1=unvoiced to 1=voiced) */
-		Word16 exc[],                         /* (i) Q_exc : pitch excitation                 */
-		Word16 Q_exc,                         /* (i)       : exc format                       */
-		Word16 gain_pit,                      /* (i) Q14   : gain of pitch                    */
-		Word16 code[],                        /* (i) Q9    : Fixed codebook excitation        */
-		Word16 gain_code,                     /* (i) Q0    : gain of code                     */
-		Word16 L_subfr                        /* (i)       : subframe length                  */
-		)
-{
-	Word16 tmp, exp, ener1, exp1, ener2, exp2;
-	Word32 i, L_tmp;
-
-#ifdef ASM_OPT               /* asm optimization branch */
-	ener1 = extract_h(Dot_product12_asm(exc, exc, L_subfr, &exp1));
-#else
-	ener1 = extract_h(Dot_product12(exc, exc, L_subfr, &exp1));
-#endif
-	exp1 = exp1 - (Q_exc + Q_exc);
-	L_tmp = vo_L_mult(gain_pit, gain_pit);
-	exp = norm_l(L_tmp);
-	tmp = extract_h(L_tmp << exp);
-	ener1 = vo_mult(ener1, tmp);
-	exp1 = exp1 - exp - 10;        /* 10 -> gain_pit Q14 to Q9 */
-
-#ifdef ASM_OPT                /* asm optimization branch */
-	ener2 = extract_h(Dot_product12_asm(code, code, L_subfr, &exp2));
-#else
-	ener2 = extract_h(Dot_product12(code, code, L_subfr, &exp2));
-#endif
-
-	exp = norm_s(gain_code);
-	tmp = gain_code << exp;
-	tmp = vo_mult(tmp, tmp);
-	ener2 = vo_mult(ener2, tmp);
-	exp2 = exp2 - (exp + exp);
-
-	i = exp1 - exp2;
-
-	if (i >= 0)
-	{
-		ener1 = ener1 >> 1;
-		ener2 = ener2 >> (i + 1);
-	} else
-	{
-		ener1 = ener1 >> (1 - i);
-		ener2 = ener2 >> 1;
-	}
-
-	tmp = vo_sub(ener1, ener2);
-	ener1 = add1(add1(ener1, ener2), 1);
-
-	if (tmp >= 0)
-	{
-		tmp = div_s(tmp, ener1);
-	} else
-	{
-		tmp = vo_negate(div_s(vo_negate(tmp), ener1));
-	}
-
-	return (tmp);
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*   File: voicefac.c                                                   *
+*                                                                      *
+*   Description: Find the voicing factors (1 = voice to -1 = unvoiced) *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+
+Word16 voice_factor(                                  /* (o) Q15   : factor (-1=unvoiced to 1=voiced) */
+		Word16 exc[],                         /* (i) Q_exc : pitch excitation                 */
+		Word16 Q_exc,                         /* (i)       : exc format                       */
+		Word16 gain_pit,                      /* (i) Q14   : gain of pitch                    */
+		Word16 code[],                        /* (i) Q9    : Fixed codebook excitation        */
+		Word16 gain_code,                     /* (i) Q0    : gain of code                     */
+		Word16 L_subfr                        /* (i)       : subframe length                  */
+		)
+{
+	Word16 tmp, exp, ener1, exp1, ener2, exp2;
+	Word32 i, L_tmp;
+
+#ifdef ASM_OPT               /* asm optimization branch */
+	ener1 = extract_h(Dot_product12_asm(exc, exc, L_subfr, &exp1));
+#else
+	ener1 = extract_h(Dot_product12(exc, exc, L_subfr, &exp1));
+#endif
+	exp1 = exp1 - (Q_exc + Q_exc);
+	L_tmp = vo_L_mult(gain_pit, gain_pit);
+	exp = norm_l(L_tmp);
+	tmp = extract_h(L_tmp << exp);
+	ener1 = vo_mult(ener1, tmp);
+	exp1 = exp1 - exp - 10;        /* 10 -> gain_pit Q14 to Q9 */
+
+#ifdef ASM_OPT                /* asm optimization branch */
+	ener2 = extract_h(Dot_product12_asm(code, code, L_subfr, &exp2));
+#else
+	ener2 = extract_h(Dot_product12(code, code, L_subfr, &exp2));
+#endif
+
+	exp = norm_s(gain_code);
+	tmp = gain_code << exp;
+	tmp = vo_mult(tmp, tmp);
+	ener2 = vo_mult(ener2, tmp);
+	exp2 = exp2 - (exp + exp);
+
+	i = exp1 - exp2;
+
+	if (i >= 0)
+	{
+		ener1 = ener1 >> 1;
+		ener2 = ener2 >> (i + 1);
+	} else
+	{
+		ener1 = ener1 >> (1 - i);
+		ener2 = ener2 >> 1;
+	}
+
+	tmp = vo_sub(ener1, ener2);
+	ener1 = add1(add1(ener1, ener2), 1);
+
+	if (tmp >= 0)
+	{
+		tmp = div_s(tmp, ener1);
+	} else
+	{
+		tmp = vo_negate(div_s(vo_negate(tmp), ener1));
+	}
+
+	return (tmp);
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/wb_vad.c b/media/libstagefright/codecs/amrwbenc/src/wb_vad.c
index 0126853..13dd2aa 100644
--- a/media/libstagefright/codecs/amrwbenc/src/wb_vad.c
+++ b/media/libstagefright/codecs/amrwbenc/src/wb_vad.c
@@ -1,808 +1,808 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*      File: wb_vad.c                                                  *
-*                                                                      *
-*      Description: Voice Activity Detection                           *
-*                                                                      *
-************************************************************************/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "cnst.h"
-#include "wb_vad.h"
-#include "typedef.h"
-#include "basic_op.h"
-#include "math_op.h"
-#include "wb_vad_c.h"
-#include "mem_align.h"
-
-/******************************************************************************
-*  Calculate Log2 and scale the signal:
-*
-*    ilog2(Word32 in) = -1024*log10(in * 2^-31)/log10(2), where in = [1, 2^31-1]
-*
-*  input   output
-*  32768   16384
-*  1       31744
-*
-* When input is in the range of [1,2^16], max error is 0.0380%.
-*********************************************************************************/
-
-static Word16 ilog2(                       /* return: output value of the log2 */
-		Word16 mant                        /* i: value to be converted */
-		)
-{
-	Word16 ex, ex2, res;
-	Word32 i, l_temp;
-
-	if (mant <= 0)
-	{
-		mant = 1;                         
-	}
-	ex = norm_s(mant);
-	mant = mant << ex;
-
-	for (i = 0; i < 3; i++)
-		mant = vo_mult(mant, mant);
-	l_temp = vo_L_mult(mant, mant);
-
-	ex2 = norm_l(l_temp);
-	mant = extract_h(l_temp << ex2);
-
-	res = (ex + 16) << 10;
-	res = add1(res, (ex2 << 6));
-	res = vo_sub(add1(res, 127), (mant >> 8));
-	return (res);
-}
-
-/******************************************************************************
-*
-*     Function     : filter5
-*     Purpose      : Fifth-order half-band lowpass/highpass filter pair with
-*                    decimation.
-*
-*******************************************************************************/
-
-static void filter5(
-		Word16 * in0,                         /* i/o : input values; output low-pass part  */
-		Word16 * in1,                         /* i/o : input values; output high-pass part */
-		Word16 data[]                         /* i/o : filter memory                       */
-		)
-{
-	Word16 temp0, temp1, temp2;
-
-	temp0 = vo_sub(*in0, vo_mult(COEFF5_1, data[0]));
-	temp1 = add1(data[0], vo_mult(COEFF5_1, temp0));
-	data[0] = temp0;                      
-
-	temp0 = vo_sub(*in1, vo_mult(COEFF5_2, data[1]));
-	temp2 = add1(data[1], vo_mult(COEFF5_2, temp0));
-	data[1] = temp0;                       
-
-	*in0 = extract_h((vo_L_add(temp1, temp2) << 15));   
-	*in1 = extract_h((vo_L_sub(temp1, temp2) << 15));  
-}
-
-/******************************************************************************
-*
-*     Function     : filter3
-*     Purpose      : Third-order half-band lowpass/highpass filter pair with
-*                    decimation.
-*
-*******************************************************************************/
-
-static void filter3(
-		Word16 * in0,                         /* i/o : input values; output low-pass part  */
-		Word16 * in1,                         /* i/o : input values; output high-pass part */
-		Word16 * data                         /* i/o : filter memory                       */
-		)
-{
-	Word16 temp1, temp2;
-
-	temp1 = vo_sub(*in1, vo_mult(COEFF3, *data));
-	temp2 = add1(*data, vo_mult(COEFF3, temp1));
-	*data = temp1;                        
-
-	*in1 = extract_h((vo_L_sub(*in0, temp2) << 15));   
-	*in0 = extract_h((vo_L_add(*in0, temp2) << 15));   
-}
-
-/******************************************************************************
-*
-*     Function   : level_calculation
-*     Purpose    : Calculate signal level in a sub-band. Level is calculated
-*                  by summing absolute values of the input data.
-*
-*                  Signal level calculated from of the end of the frame
-*                  (data[count1 - count2]) is stored to (*sub_level)
-*                  and added to the level of the next frame.
-*
-******************************************************************************/
-
-static Word16 level_calculation(                      /* return: signal level */
-		Word16 data[],                        /* i   : signal buffer                                    */
-		Word16 * sub_level,                   /* i   : level calculated at the end of the previous frame*/
-		                                      /* o   : level of signal calculated from the last         */
-		                                      /*       (count2 - count1) samples                        */
-		Word16 count1,                        /* i   : number of samples to be counted                  */
-		Word16 count2,                        /* i   : number of samples to be counted                  */
-		Word16 ind_m,                         /* i   : step size for the index of the data buffer       */
-		Word16 ind_a,                         /* i   : starting index of the data buffer                */
-		Word16 scale                          /* i   : scaling for the level calculation                */
-		)
-{
-	Word32 i, l_temp1, l_temp2;
-	Word16 level;
-
-	l_temp1 = 0L;                          
-	for (i = count1; i < count2; i++)
-	{
-		l_temp1 += (abs_s(data[ind_m * i + ind_a])<<1);
-	}
-
-	l_temp2 = vo_L_add(l_temp1, L_shl(*sub_level, 16 - scale));
-	*sub_level = extract_h(L_shl(l_temp1, scale));      
-
-	for (i = 0; i < count1; i++)
-	{
-		l_temp2 += (abs_s(data[ind_m * i + ind_a])<<1);
-	}
-	level = extract_h(L_shl2(l_temp2, scale));
-
-	return level;
-}
-
-/******************************************************************************
-*
-*     Function     : filter_bank
-*     Purpose      : Divide input signal into bands and calculate level of
-*                    the signal in each band
-*
-*******************************************************************************/
-
-static void filter_bank(
-		VadVars * st,                         /* i/o : State struct               */
-		Word16 in[],                          /* i   : input frame                */
-		Word16 level[]                        /* o   : signal levels at each band */
-		)
-{
-	Word32 i;
-	Word16 tmp_buf[FRAME_LEN];
-
-	/* shift input 1 bit down for safe scaling */
-	for (i = 0; i < FRAME_LEN; i++)
-	{
-		tmp_buf[i] = in[i] >> 1;       
-	}
-
-	/* run the filter bank */
-	for (i = 0; i < 128; i++)
-	{
-		filter5(&tmp_buf[2 * i], &tmp_buf[2 * i + 1], st->a_data5[0]);
-	}
-	for (i = 0; i < 64; i++)
-	{
-		filter5(&tmp_buf[4 * i], &tmp_buf[4 * i + 2], st->a_data5[1]);
-		filter5(&tmp_buf[4 * i + 1], &tmp_buf[4 * i + 3], st->a_data5[2]);
-	}
-	for (i = 0; i < 32; i++)
-	{
-		filter5(&tmp_buf[8 * i], &tmp_buf[8 * i + 4], st->a_data5[3]);
-		filter5(&tmp_buf[8 * i + 2], &tmp_buf[8 * i + 6], st->a_data5[4]);
-		filter3(&tmp_buf[8 * i + 3], &tmp_buf[8 * i + 7], &st->a_data3[0]);
-	}
-	for (i = 0; i < 16; i++)
-	{
-		filter3(&tmp_buf[16 * i + 0], &tmp_buf[16 * i + 8], &st->a_data3[1]);
-		filter3(&tmp_buf[16 * i + 4], &tmp_buf[16 * i + 12], &st->a_data3[2]);
-		filter3(&tmp_buf[16 * i + 6], &tmp_buf[16 * i + 14], &st->a_data3[3]);
-	}
-
-	for (i = 0; i < 8; i++)
-	{
-		filter3(&tmp_buf[32 * i + 0], &tmp_buf[32 * i + 16], &st->a_data3[4]);
-		filter3(&tmp_buf[32 * i + 8], &tmp_buf[32 * i + 24], &st->a_data3[5]);
-	}
-
-	/* calculate levels in each frequency band */
-
-	/* 4800 - 6400 Hz */
-	level[11] = level_calculation(tmp_buf, &st->sub_level[11], 16, 64, 4, 1, 14);   
-	/* 4000 - 4800 Hz */
-	level[10] = level_calculation(tmp_buf, &st->sub_level[10], 8, 32, 8, 7, 15);   
-	/* 3200 - 4000 Hz */
-	level[9] = level_calculation(tmp_buf, &st->sub_level[9],8, 32, 8, 3, 15);   
-	/* 2400 - 3200 Hz */
-	level[8] = level_calculation(tmp_buf, &st->sub_level[8],8, 32, 8, 2, 15);   
-	/* 2000 - 2400 Hz */
-	level[7] = level_calculation(tmp_buf, &st->sub_level[7],4, 16, 16, 14, 16);       
-	/* 1600 - 2000 Hz */
-	level[6] = level_calculation(tmp_buf, &st->sub_level[6],4, 16, 16, 6, 16);        
-	/* 1200 - 1600 Hz */
-	level[5] = level_calculation(tmp_buf, &st->sub_level[5],4, 16, 16, 4, 16);        
-	/* 800 - 1200 Hz */
-	level[4] = level_calculation(tmp_buf, &st->sub_level[4],4, 16, 16, 12, 16);       
-	/* 600 - 800 Hz */
-	level[3] = level_calculation(tmp_buf, &st->sub_level[3],2, 8, 32, 8, 17); 
-	/* 400 - 600 Hz */
-	level[2] = level_calculation(tmp_buf, &st->sub_level[2],2, 8, 32, 24, 17);        
-	/* 200 - 400 Hz */
-	level[1] = level_calculation(tmp_buf, &st->sub_level[1],2, 8, 32, 16, 17);        
-	/* 0 - 200 Hz */
-	level[0] = level_calculation(tmp_buf, &st->sub_level[0],2, 8, 32, 0, 17); 
-}
-
-/******************************************************************************
-*
-*     Function   : update_cntrl
-*     Purpose    : Control update of the background noise estimate.
-*
-*******************************************************************************/
-
-static void update_cntrl(
-		VadVars * st,                         /* i/o : State structure                    */
-		Word16 level[]                        /* i   : sub-band levels of the input frame */
-		)
-{
-	Word32 i;
-	Word16 num, temp, stat_rat, exp, denom;
-	Word16 alpha;
-
-	/* if a tone has been detected for a while, initialize stat_count */
-	if (sub((Word16) (st->tone_flag & 0x7c00), 0x7c00) == 0)
-	{
-		st->stat_count = STAT_COUNT;      
-	} else
-	{
-		/* if 8 last vad-decisions have been "0", reinitialize stat_count */
-		if ((st->vadreg & 0x7f80) == 0)
-		{
-			st->stat_count = STAT_COUNT;   
-		} else
-		{
-			stat_rat = 0;                  
-			for (i = 0; i < COMPLEN; i++)
-			{
-				if(level[i] > st->ave_level[i])
-				{
-					num = level[i];        
-					denom = st->ave_level[i];   
-				} else
-				{
-					num = st->ave_level[i];
-					denom = level[i];      
-				}
-				/* Limit nimimum value of num and denom to STAT_THR_LEVEL */
-				if(num < STAT_THR_LEVEL)
-				{
-					num = STAT_THR_LEVEL;  
-				}
-				if(denom < STAT_THR_LEVEL)
-				{
-					denom = STAT_THR_LEVEL;
-				}
-				exp = norm_s(denom);
-				denom = denom << exp;
-
-				/* stat_rat = num/denom * 64 */
-				temp = div_s(num >> 1, denom);
-				stat_rat = add1(stat_rat, shr(temp, (8 - exp)));
-			}
-
-			/* compare stat_rat with a threshold and update stat_count */
-			if(stat_rat > STAT_THR)
-			{
-				st->stat_count = STAT_COUNT;    
-			} else
-			{
-				if ((st->vadreg & 0x4000) != 0)
-				{
-
-					if (st->stat_count != 0)
-					{
-						st->stat_count = st->stat_count - 1;       
-					}
-				}
-			}
-		}
-	}
-
-	/* Update average amplitude estimate for stationarity estimation */
-	alpha = ALPHA4;                        
-	if(st->stat_count == STAT_COUNT)
-	{
-		alpha = 32767;                    
-	} else if ((st->vadreg & 0x4000) == 0)
-	{
-		alpha = ALPHA5;                   
-	}
-	for (i = 0; i < COMPLEN; i++)
-	{
-		st->ave_level[i] = add1(st->ave_level[i], vo_mult_r(alpha, vo_sub(level[i], st->ave_level[i])));   
-	}
-}
-
-/******************************************************************************
-*
-*     Function     : hangover_addition
-*     Purpose      : Add hangover after speech bursts
-*
-*******************************************************************************/
-
-static Word16 hangover_addition(                      /* return: VAD_flag indicating final VAD decision */
-		VadVars * st,                         /* i/o : State structure                     */
-		Word16 low_power,                     /* i   : flag power of the input frame    */
-		Word16 hang_len,                      /* i   : hangover length */
-		Word16 burst_len                      /* i   : minimum burst length for hangover addition */
-		)
-{
-	/* if the input power (pow_sum) is lower than a threshold, clear counters and set VAD_flag to "0"         */
-	if (low_power != 0)
-	{
-		st->burst_count = 0;               
-		st->hang_count = 0;                
-		return 0;
-	}
-	/* update the counters (hang_count, burst_count) */
-	if ((st->vadreg & 0x4000) != 0)
-	{
-		st->burst_count = st->burst_count + 1;    
-		if(st->burst_count >= burst_len)
-		{
-			st->hang_count = hang_len;     
-		}
-		return 1;
-	} else
-	{
-		st->burst_count = 0;               
-		if (st->hang_count > 0)
-		{
-			st->hang_count = st->hang_count - 1;    
-			return 1;
-		}
-	}
-	return 0;
-}
-
-/******************************************************************************
-*
-*     Function   : noise_estimate_update
-*     Purpose    : Update of background noise estimate
-*
-*******************************************************************************/
-
-static void noise_estimate_update(
-		VadVars * st,                         /* i/o : State structure                       */
-		Word16 level[]                        /* i   : sub-band levels of the input frame */
-		)
-{
-	Word32 i; 
-	Word16 alpha_up, alpha_down, bckr_add = 2;
-
-	/* Control update of bckr_est[] */
-	update_cntrl(st, level);
-
-	/* Choose update speed */
-	if ((0x7800 & st->vadreg) == 0)
-	{
-		alpha_up = ALPHA_UP1;              
-		alpha_down = ALPHA_DOWN1;          
-	} else
-	{
-		if ((st->stat_count == 0))
-		{
-			alpha_up = ALPHA_UP2;          
-			alpha_down = ALPHA_DOWN2;      
-		} else
-		{
-			alpha_up = 0;                  
-			alpha_down = ALPHA3;           
-			bckr_add = 0;                  
-		}
-	}
-
-	/* Update noise estimate (bckr_est) */
-	for (i = 0; i < COMPLEN; i++)
-	{
-		Word16 temp;
-		temp = (st->old_level[i] - st->bckr_est[i]);
-
-		if (temp < 0)
-		{                                  /* update downwards */
-			st->bckr_est[i] = add1(-2, add(st->bckr_est[i],vo_mult_r(alpha_down, temp))); 
-			/* limit minimum value of the noise estimate to NOISE_MIN */
-			if(st->bckr_est[i] < NOISE_MIN)
-			{
-				st->bckr_est[i] = NOISE_MIN;   
-			}
-		} else
-		{                                  /* update upwards */
-			st->bckr_est[i] = add1(bckr_add, add1(st->bckr_est[i],vo_mult_r(alpha_up, temp)));   
-
-			/* limit maximum value of the noise estimate to NOISE_MAX */
-			if(st->bckr_est[i] > NOISE_MAX)
-			{
-				st->bckr_est[i] = NOISE_MAX;    
-			}
-		}
-	}
-
-	/* Update signal levels of the previous frame (old_level) */
-	for (i = 0; i < COMPLEN; i++)
-	{
-		st->old_level[i] = level[i];      
-	}
-}
-
-/******************************************************************************
-*
-*     Function     : vad_decision
-*     Purpose      : Calculates VAD_flag
-*
-*******************************************************************************/
-
-static Word16 vad_decision(                           /* return value : VAD_flag */
-		VadVars * st,                         /* i/o : State structure                       */
-		Word16 level[COMPLEN],                /* i   : sub-band levels of the input frame */
-		Word32 pow_sum                        /* i   : power of the input frame           */
-		)
-{
-	Word32 i;
-	Word32 L_snr_sum;
-	Word32 L_temp;
-	Word16 vad_thr, temp, noise_level;
-	Word16 low_power_flag;
-	Word16 hang_len, burst_len;
-	Word16 ilog2_speech_level, ilog2_noise_level;
-	Word16 temp2;
-
-	/* Calculate squared sum of the input levels (level) divided by the background noise components
-	 * (bckr_est). */
-	L_snr_sum = 0;                        
-	for (i = 0; i < COMPLEN; i++)
-	{
-		Word16 exp;
-
-		exp = norm_s(st->bckr_est[i]);
-		temp = (st->bckr_est[i] << exp);
-		temp = div_s((level[i] >> 1), temp);
-		temp = shl(temp, (exp - (UNIRSHFT - 1)));
-		L_snr_sum = L_mac(L_snr_sum, temp, temp);
-	}
-
-	/* Calculate average level of estimated background noise */
-	L_temp = 0;                           
-	for (i = 1; i < COMPLEN; i++)          /* ignore lowest band */
-	{
-		L_temp = vo_L_add(L_temp, st->bckr_est[i]);
-	}
-
-	noise_level = extract_h((L_temp << 12));
-	/* if SNR is lower than a threshold (MIN_SPEECH_SNR), and increase speech_level */
-	temp = vo_mult(noise_level, MIN_SPEECH_SNR) << 3;
-
-	if(st->speech_level < temp)
-	{
-		st->speech_level = temp;          
-	}
-	ilog2_noise_level = ilog2(noise_level);
-
-	/* If SNR is very poor, speech_level is probably corrupted by noise level. This is correctred by
-	 * subtracting MIN_SPEECH_SNR*noise_level from speech level */
-	ilog2_speech_level = ilog2(st->speech_level - temp);
-
-	temp = add1(vo_mult(NO_SLOPE, (ilog2_noise_level - NO_P1)), THR_HIGH);
-
-	temp2 = add1(SP_CH_MIN, vo_mult(SP_SLOPE, (ilog2_speech_level - SP_P1)));
-	if (temp2 < SP_CH_MIN)
-	{
-		temp2 = SP_CH_MIN;                 
-	}
-	if (temp2 > SP_CH_MAX)
-	{
-		temp2 = SP_CH_MAX;                 
-	}
-	vad_thr = temp + temp2;
-
-	if(vad_thr < THR_MIN)
-	{
-		vad_thr = THR_MIN;                 
-	}
-	/* Shift VAD decision register */
-	st->vadreg = (st->vadreg >> 1);       
-
-	/* Make intermediate VAD decision */
-	if(L_snr_sum > vo_L_mult(vad_thr, (512 * COMPLEN)))
-	{
-		st->vadreg = (Word16) (st->vadreg | 0x4000); 
-	}
-	/* check if the input power (pow_sum) is lower than a threshold" */
-	if(pow_sum < VAD_POW_LOW)
-	{
-		low_power_flag = 1;               
-	} else
-	{
-		low_power_flag = 0;               
-	}
-	/* Update background noise estimates */
-	noise_estimate_update(st, level);
-
-	/* Calculate values for hang_len and burst_len based on vad_thr */
-	hang_len = add1(vo_mult(HANG_SLOPE, (vad_thr - HANG_P1)), HANG_HIGH);
-	if(hang_len < HANG_LOW)
-	{
-		hang_len = HANG_LOW;              
-	}
-	burst_len = add1(vo_mult(BURST_SLOPE, (vad_thr - BURST_P1)), BURST_HIGH);
-
-	return (hangover_addition(st, low_power_flag, hang_len, burst_len));
-}
-
-/******************************************************************************
-*
-*     Function : Estimate_Speech()
-*     Purpose  : Estimate speech level
-*
-* Maximum signal level is searched and stored to the variable sp_max.
-* The speech frames must locate within SP_EST_COUNT number of frames.
-* Thus, noisy frames having occasional VAD = "1" decisions will not
-* affect to the estimated speech_level.
-*
-*******************************************************************************/
-
-static void Estimate_Speech(
-		VadVars * st,                         /* i/o : State structure    */
-		Word16 in_level                       /* level of the input frame */
-		)
-{
-	Word16 alpha;
-
-	/* if the required activity count cannot be achieved, reset counters */
-	if((st->sp_est_cnt - st->sp_max_cnt) > (SP_EST_COUNT - SP_ACTIVITY_COUNT))
-	{
-		st->sp_est_cnt = 0;                
-		st->sp_max = 0;                    
-		st->sp_max_cnt = 0;                
-	}
-	st->sp_est_cnt += 1; 
-
-	if (((st->vadreg & 0x4000)||(in_level > st->speech_level)) && (in_level > MIN_SPEECH_LEVEL1))
-	{
-		/* update sp_max */
-		if(in_level > st->sp_max)
-		{
-			st->sp_max = in_level;         
-		}
-		st->sp_max_cnt += 1;        
-
-		if(st->sp_max_cnt >= SP_ACTIVITY_COUNT)
-		{
-			Word16 tmp;
-			/* update speech estimate */
-			tmp = (st->sp_max >> 1);      /* scale to get "average" speech level */
-
-			/* select update speed */
-			if(tmp > st->speech_level)
-			{
-				alpha = ALPHA_SP_UP;       
-			} else
-			{
-				alpha = ALPHA_SP_DOWN;    
-			}
-			if(tmp > MIN_SPEECH_LEVEL2)
-			{
-				st->speech_level = add1(st->speech_level, vo_mult_r(alpha, vo_sub(tmp, st->speech_level))); 
-			}
-			/* clear all counters used for speech estimation */
-			st->sp_max = 0;                
-			st->sp_max_cnt = 0;            
-			st->sp_est_cnt = 0;            
-		}
-	}
-}
-
-/******************************************************************************
-*
-*  Function:   wb_vad_init
-*  Purpose:    Allocates state memory and initializes state memory
-*
-*******************************************************************************/
-
-Word16 wb_vad_init(                        /* return: non-zero with error, zero for ok. */
-		VadVars ** state,                     /* i/o : State structure    */
-		VO_MEM_OPERATOR *pMemOP
-		)
-{
-	VadVars *s;
-
-	if (state == (VadVars **) NULL)
-	{
-		fprintf(stderr, "vad_init: invalid parameter\n");
-		return -1;
-	}
-	*state = NULL;
-
-	/* allocate memory */
-	if ((s = (VadVars *) mem_malloc(pMemOP, sizeof(VadVars), 32, VO_INDEX_ENC_AMRWB)) == NULL)
-	{
-		fprintf(stderr, "vad_init: can not malloc state structure\n");
-		return -1;
-	}
-	wb_vad_reset(s);
-
-	*state = s;
-
-	return 0;
-}
-
-/******************************************************************************
-*
-*  Function:   wb_vad_reset
-*  Purpose:    Initializes state memory
-*
-*******************************************************************************/
-
-Word16 wb_vad_reset(                       /* return: non-zero with error, zero for ok. */
-		VadVars * state                       /* i/o : State structure    */
-		)
-{
-	Word32 i, j;
-
-	if (state == (VadVars *) NULL)
-	{
-		fprintf(stderr, "vad_reset: invalid parameter\n");
-		return -1;
-	}
-	state->tone_flag = 0;
-	state->vadreg = 0;
-	state->hang_count = 0;
-	state->burst_count = 0;
-	state->hang_count = 0;
-
-	/* initialize memory used by the filter bank */
-	for (i = 0; i < F_5TH_CNT; i++)
-	{
-		for (j = 0; j < 2; j++)
-		{
-			state->a_data5[i][j] = 0;
-		}
-	}
-
-	for (i = 0; i < F_3TH_CNT; i++)
-	{
-		state->a_data3[i] = 0;
-	}
-
-	/* initialize the rest of the memory */
-	for (i = 0; i < COMPLEN; i++)
-	{
-		state->bckr_est[i] = NOISE_INIT;
-		state->old_level[i] = NOISE_INIT;
-		state->ave_level[i] = NOISE_INIT;
-		state->sub_level[i] = 0;
-	}
-
-	state->sp_est_cnt = 0;
-	state->sp_max = 0;
-	state->sp_max_cnt = 0;
-	state->speech_level = SPEECH_LEVEL_INIT;
-	state->prev_pow_sum = 0;
-	return 0;
-}
-
-/******************************************************************************
-*
-*  Function:   wb_vad_exit
-*  Purpose:    The memory used for state memory is freed
-*
-*******************************************************************************/
-
-void wb_vad_exit(
-		VadVars ** state,                      /* i/o : State structure    */
-		VO_MEM_OPERATOR *pMemOP
-		)
-{
-	if (state == NULL || *state == NULL)
-		return;
-	/* deallocate memory */
-	mem_free(pMemOP, *state, VO_INDEX_ENC_AMRWB);
-	*state = NULL;
-	return;
-}
-
-/******************************************************************************
-*
-*     Function     : wb_vad_tone_detection
-*     Purpose      : Search maximum pitch gain from a frame. Set tone flag if
-*                    pitch gain is high. This is used to detect
-*                    signaling tones and other signals with high pitch gain.
-*
-*******************************************************************************/
-
-void wb_vad_tone_detection(
-		VadVars * st,                         /* i/o : State struct            */
-		Word16 p_gain                         /* pitch gain      */
-		)
-{
-	/* update tone flag */
-	st->tone_flag = (st->tone_flag >> 1);
-
-	/* if (pitch_gain > TONE_THR) set tone flag */
-	if (p_gain > TONE_THR)
-	{
-		st->tone_flag = (Word16) (st->tone_flag | 0x4000);
-	}
-}
-
-/******************************************************************************
-*
-*     Function     : wb_vad
-*     Purpose      : Main program for Voice Activity Detection (VAD) for AMR
-*
-*******************************************************************************/
-
-Word16 wb_vad(                                /* Return value : VAD Decision, 1 = speech, 0 = noise */
-		VadVars * st,                         /* i/o : State structure                 */
-		Word16 in_buf[]                       /* i   : samples of the input frame   */
-	     )
-{
-	Word16 level[COMPLEN];
-	Word32 i;
-	Word16 VAD_flag, temp;
-	Word32 L_temp, pow_sum;
-
-	/* Calculate power of the input frame. */
-	L_temp = 0L;                           
-	for (i = 0; i < FRAME_LEN; i++)
-	{
-		L_temp = L_mac(L_temp, in_buf[i], in_buf[i]);
-	}
-
-	/* pow_sum = power of current frame and previous frame */
-	pow_sum = L_add(L_temp, st->prev_pow_sum);  
-
-	/* save power of current frame for next call */
-	st->prev_pow_sum = L_temp;             
-
-	/* If input power is very low, clear tone flag */
-	if (pow_sum < POW_TONE_THR)
-	{
-		st->tone_flag = (Word16) (st->tone_flag & 0x1fff);      
-	}
-	/* Run the filter bank and calculate signal levels at each band */
-	filter_bank(st, in_buf, level);
-
-	/* compute VAD decision */
-	VAD_flag = vad_decision(st, level, pow_sum);
-
-	/* Calculate input level */
-	L_temp = 0;                          
-	for (i = 1; i < COMPLEN; i++)          /* ignore lowest band */
-	{
-		L_temp = vo_L_add(L_temp, level[i]);
-	}
-
-	temp = extract_h(L_temp << 12);
-
-	Estimate_Speech(st, temp);             /* Estimate speech level */
-	return (VAD_flag);
-}
-
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*      File: wb_vad.c                                                  *
+*                                                                      *
+*      Description: Voice Activity Detection                           *
+*                                                                      *
+************************************************************************/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "cnst.h"
+#include "wb_vad.h"
+#include "typedef.h"
+#include "basic_op.h"
+#include "math_op.h"
+#include "wb_vad_c.h"
+#include "mem_align.h"
+
+/******************************************************************************
+*  Calculate Log2 and scale the signal:
+*
+*    ilog2(Word32 in) = -1024*log10(in * 2^-31)/log10(2), where in = [1, 2^31-1]
+*
+*  input   output
+*  32768   16384
+*  1       31744
+*
+* When input is in the range of [1,2^16], max error is 0.0380%.
+*********************************************************************************/
+
+static Word16 ilog2(                       /* return: output value of the log2 */
+		Word16 mant                        /* i: value to be converted */
+		)
+{
+	Word16 ex, ex2, res;
+	Word32 i, l_temp;
+
+	if (mant <= 0)
+	{
+		mant = 1;
+	}
+	ex = norm_s(mant);
+	mant = mant << ex;
+
+	for (i = 0; i < 3; i++)
+		mant = vo_mult(mant, mant);
+	l_temp = vo_L_mult(mant, mant);
+
+	ex2 = norm_l(l_temp);
+	mant = extract_h(l_temp << ex2);
+
+	res = (ex + 16) << 10;
+	res = add1(res, (ex2 << 6));
+	res = vo_sub(add1(res, 127), (mant >> 8));
+	return (res);
+}
+
+/******************************************************************************
+*
+*     Function     : filter5
+*     Purpose      : Fifth-order half-band lowpass/highpass filter pair with
+*                    decimation.
+*
+*******************************************************************************/
+
+static void filter5(
+		Word16 * in0,                         /* i/o : input values; output low-pass part  */
+		Word16 * in1,                         /* i/o : input values; output high-pass part */
+		Word16 data[]                         /* i/o : filter memory                       */
+		)
+{
+	Word16 temp0, temp1, temp2;
+
+	temp0 = vo_sub(*in0, vo_mult(COEFF5_1, data[0]));
+	temp1 = add1(data[0], vo_mult(COEFF5_1, temp0));
+	data[0] = temp0;
+
+	temp0 = vo_sub(*in1, vo_mult(COEFF5_2, data[1]));
+	temp2 = add1(data[1], vo_mult(COEFF5_2, temp0));
+	data[1] = temp0;
+
+	*in0 = extract_h((vo_L_add(temp1, temp2) << 15));
+	*in1 = extract_h((vo_L_sub(temp1, temp2) << 15));
+}
+
+/******************************************************************************
+*
+*     Function     : filter3
+*     Purpose      : Third-order half-band lowpass/highpass filter pair with
+*                    decimation.
+*
+*******************************************************************************/
+
+static void filter3(
+		Word16 * in0,                         /* i/o : input values; output low-pass part  */
+		Word16 * in1,                         /* i/o : input values; output high-pass part */
+		Word16 * data                         /* i/o : filter memory                       */
+		)
+{
+	Word16 temp1, temp2;
+
+	temp1 = vo_sub(*in1, vo_mult(COEFF3, *data));
+	temp2 = add1(*data, vo_mult(COEFF3, temp1));
+	*data = temp1;
+
+	*in1 = extract_h((vo_L_sub(*in0, temp2) << 15));
+	*in0 = extract_h((vo_L_add(*in0, temp2) << 15));
+}
+
+/******************************************************************************
+*
+*     Function   : level_calculation
+*     Purpose    : Calculate signal level in a sub-band. Level is calculated
+*                  by summing absolute values of the input data.
+*
+*                  Signal level calculated from of the end of the frame
+*                  (data[count1 - count2]) is stored to (*sub_level)
+*                  and added to the level of the next frame.
+*
+******************************************************************************/
+
+static Word16 level_calculation(                      /* return: signal level */
+		Word16 data[],                        /* i   : signal buffer                                    */
+		Word16 * sub_level,                   /* i   : level calculated at the end of the previous frame*/
+		                                      /* o   : level of signal calculated from the last         */
+		                                      /*       (count2 - count1) samples                        */
+		Word16 count1,                        /* i   : number of samples to be counted                  */
+		Word16 count2,                        /* i   : number of samples to be counted                  */
+		Word16 ind_m,                         /* i   : step size for the index of the data buffer       */
+		Word16 ind_a,                         /* i   : starting index of the data buffer                */
+		Word16 scale                          /* i   : scaling for the level calculation                */
+		)
+{
+	Word32 i, l_temp1, l_temp2;
+	Word16 level;
+
+	l_temp1 = 0L;
+	for (i = count1; i < count2; i++)
+	{
+		l_temp1 += (abs_s(data[ind_m * i + ind_a])<<1);
+	}
+
+	l_temp2 = vo_L_add(l_temp1, L_shl(*sub_level, 16 - scale));
+	*sub_level = extract_h(L_shl(l_temp1, scale));
+
+	for (i = 0; i < count1; i++)
+	{
+		l_temp2 += (abs_s(data[ind_m * i + ind_a])<<1);
+	}
+	level = extract_h(L_shl2(l_temp2, scale));
+
+	return level;
+}
+
+/******************************************************************************
+*
+*     Function     : filter_bank
+*     Purpose      : Divide input signal into bands and calculate level of
+*                    the signal in each band
+*
+*******************************************************************************/
+
+static void filter_bank(
+		VadVars * st,                         /* i/o : State struct               */
+		Word16 in[],                          /* i   : input frame                */
+		Word16 level[]                        /* o   : signal levels at each band */
+		)
+{
+	Word32 i;
+	Word16 tmp_buf[FRAME_LEN];
+
+	/* shift input 1 bit down for safe scaling */
+	for (i = 0; i < FRAME_LEN; i++)
+	{
+		tmp_buf[i] = in[i] >> 1;
+	}
+
+	/* run the filter bank */
+	for (i = 0; i < 128; i++)
+	{
+		filter5(&tmp_buf[2 * i], &tmp_buf[2 * i + 1], st->a_data5[0]);
+	}
+	for (i = 0; i < 64; i++)
+	{
+		filter5(&tmp_buf[4 * i], &tmp_buf[4 * i + 2], st->a_data5[1]);
+		filter5(&tmp_buf[4 * i + 1], &tmp_buf[4 * i + 3], st->a_data5[2]);
+	}
+	for (i = 0; i < 32; i++)
+	{
+		filter5(&tmp_buf[8 * i], &tmp_buf[8 * i + 4], st->a_data5[3]);
+		filter5(&tmp_buf[8 * i + 2], &tmp_buf[8 * i + 6], st->a_data5[4]);
+		filter3(&tmp_buf[8 * i + 3], &tmp_buf[8 * i + 7], &st->a_data3[0]);
+	}
+	for (i = 0; i < 16; i++)
+	{
+		filter3(&tmp_buf[16 * i + 0], &tmp_buf[16 * i + 8], &st->a_data3[1]);
+		filter3(&tmp_buf[16 * i + 4], &tmp_buf[16 * i + 12], &st->a_data3[2]);
+		filter3(&tmp_buf[16 * i + 6], &tmp_buf[16 * i + 14], &st->a_data3[3]);
+	}
+
+	for (i = 0; i < 8; i++)
+	{
+		filter3(&tmp_buf[32 * i + 0], &tmp_buf[32 * i + 16], &st->a_data3[4]);
+		filter3(&tmp_buf[32 * i + 8], &tmp_buf[32 * i + 24], &st->a_data3[5]);
+	}
+
+	/* calculate levels in each frequency band */
+
+	/* 4800 - 6400 Hz */
+	level[11] = level_calculation(tmp_buf, &st->sub_level[11], 16, 64, 4, 1, 14);
+	/* 4000 - 4800 Hz */
+	level[10] = level_calculation(tmp_buf, &st->sub_level[10], 8, 32, 8, 7, 15);
+	/* 3200 - 4000 Hz */
+	level[9] = level_calculation(tmp_buf, &st->sub_level[9],8, 32, 8, 3, 15);
+	/* 2400 - 3200 Hz */
+	level[8] = level_calculation(tmp_buf, &st->sub_level[8],8, 32, 8, 2, 15);
+	/* 2000 - 2400 Hz */
+	level[7] = level_calculation(tmp_buf, &st->sub_level[7],4, 16, 16, 14, 16);
+	/* 1600 - 2000 Hz */
+	level[6] = level_calculation(tmp_buf, &st->sub_level[6],4, 16, 16, 6, 16);
+	/* 1200 - 1600 Hz */
+	level[5] = level_calculation(tmp_buf, &st->sub_level[5],4, 16, 16, 4, 16);
+	/* 800 - 1200 Hz */
+	level[4] = level_calculation(tmp_buf, &st->sub_level[4],4, 16, 16, 12, 16);
+	/* 600 - 800 Hz */
+	level[3] = level_calculation(tmp_buf, &st->sub_level[3],2, 8, 32, 8, 17);
+	/* 400 - 600 Hz */
+	level[2] = level_calculation(tmp_buf, &st->sub_level[2],2, 8, 32, 24, 17);
+	/* 200 - 400 Hz */
+	level[1] = level_calculation(tmp_buf, &st->sub_level[1],2, 8, 32, 16, 17);
+	/* 0 - 200 Hz */
+	level[0] = level_calculation(tmp_buf, &st->sub_level[0],2, 8, 32, 0, 17);
+}
+
+/******************************************************************************
+*
+*     Function   : update_cntrl
+*     Purpose    : Control update of the background noise estimate.
+*
+*******************************************************************************/
+
+static void update_cntrl(
+		VadVars * st,                         /* i/o : State structure                    */
+		Word16 level[]                        /* i   : sub-band levels of the input frame */
+		)
+{
+	Word32 i;
+	Word16 num, temp, stat_rat, exp, denom;
+	Word16 alpha;
+
+	/* if a tone has been detected for a while, initialize stat_count */
+	if (sub((Word16) (st->tone_flag & 0x7c00), 0x7c00) == 0)
+	{
+		st->stat_count = STAT_COUNT;
+	} else
+	{
+		/* if 8 last vad-decisions have been "0", reinitialize stat_count */
+		if ((st->vadreg & 0x7f80) == 0)
+		{
+			st->stat_count = STAT_COUNT;
+		} else
+		{
+			stat_rat = 0;
+			for (i = 0; i < COMPLEN; i++)
+			{
+				if(level[i] > st->ave_level[i])
+				{
+					num = level[i];
+					denom = st->ave_level[i];
+				} else
+				{
+					num = st->ave_level[i];
+					denom = level[i];
+				}
+				/* Limit nimimum value of num and denom to STAT_THR_LEVEL */
+				if(num < STAT_THR_LEVEL)
+				{
+					num = STAT_THR_LEVEL;
+				}
+				if(denom < STAT_THR_LEVEL)
+				{
+					denom = STAT_THR_LEVEL;
+				}
+				exp = norm_s(denom);
+				denom = denom << exp;
+
+				/* stat_rat = num/denom * 64 */
+				temp = div_s(num >> 1, denom);
+				stat_rat = add1(stat_rat, shr(temp, (8 - exp)));
+			}
+
+			/* compare stat_rat with a threshold and update stat_count */
+			if(stat_rat > STAT_THR)
+			{
+				st->stat_count = STAT_COUNT;
+			} else
+			{
+				if ((st->vadreg & 0x4000) != 0)
+				{
+
+					if (st->stat_count != 0)
+					{
+						st->stat_count = st->stat_count - 1;
+					}
+				}
+			}
+		}
+	}
+
+	/* Update average amplitude estimate for stationarity estimation */
+	alpha = ALPHA4;
+	if(st->stat_count == STAT_COUNT)
+	{
+		alpha = 32767;
+	} else if ((st->vadreg & 0x4000) == 0)
+	{
+		alpha = ALPHA5;
+	}
+	for (i = 0; i < COMPLEN; i++)
+	{
+		st->ave_level[i] = add1(st->ave_level[i], vo_mult_r(alpha, vo_sub(level[i], st->ave_level[i])));
+	}
+}
+
+/******************************************************************************
+*
+*     Function     : hangover_addition
+*     Purpose      : Add hangover after speech bursts
+*
+*******************************************************************************/
+
+static Word16 hangover_addition(                      /* return: VAD_flag indicating final VAD decision */
+		VadVars * st,                         /* i/o : State structure                     */
+		Word16 low_power,                     /* i   : flag power of the input frame    */
+		Word16 hang_len,                      /* i   : hangover length */
+		Word16 burst_len                      /* i   : minimum burst length for hangover addition */
+		)
+{
+	/* if the input power (pow_sum) is lower than a threshold, clear counters and set VAD_flag to "0"         */
+	if (low_power != 0)
+	{
+		st->burst_count = 0;
+		st->hang_count = 0;
+		return 0;
+	}
+	/* update the counters (hang_count, burst_count) */
+	if ((st->vadreg & 0x4000) != 0)
+	{
+		st->burst_count = st->burst_count + 1;
+		if(st->burst_count >= burst_len)
+		{
+			st->hang_count = hang_len;
+		}
+		return 1;
+	} else
+	{
+		st->burst_count = 0;
+		if (st->hang_count > 0)
+		{
+			st->hang_count = st->hang_count - 1;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/******************************************************************************
+*
+*     Function   : noise_estimate_update
+*     Purpose    : Update of background noise estimate
+*
+*******************************************************************************/
+
+static void noise_estimate_update(
+		VadVars * st,                         /* i/o : State structure                       */
+		Word16 level[]                        /* i   : sub-band levels of the input frame */
+		)
+{
+	Word32 i;
+	Word16 alpha_up, alpha_down, bckr_add = 2;
+
+	/* Control update of bckr_est[] */
+	update_cntrl(st, level);
+
+	/* Choose update speed */
+	if ((0x7800 & st->vadreg) == 0)
+	{
+		alpha_up = ALPHA_UP1;
+		alpha_down = ALPHA_DOWN1;
+	} else
+	{
+		if ((st->stat_count == 0))
+		{
+			alpha_up = ALPHA_UP2;
+			alpha_down = ALPHA_DOWN2;
+		} else
+		{
+			alpha_up = 0;
+			alpha_down = ALPHA3;
+			bckr_add = 0;
+		}
+	}
+
+	/* Update noise estimate (bckr_est) */
+	for (i = 0; i < COMPLEN; i++)
+	{
+		Word16 temp;
+		temp = (st->old_level[i] - st->bckr_est[i]);
+
+		if (temp < 0)
+		{                                  /* update downwards */
+			st->bckr_est[i] = add1(-2, add(st->bckr_est[i],vo_mult_r(alpha_down, temp)));
+			/* limit minimum value of the noise estimate to NOISE_MIN */
+			if(st->bckr_est[i] < NOISE_MIN)
+			{
+				st->bckr_est[i] = NOISE_MIN;
+			}
+		} else
+		{                                  /* update upwards */
+			st->bckr_est[i] = add1(bckr_add, add1(st->bckr_est[i],vo_mult_r(alpha_up, temp)));
+
+			/* limit maximum value of the noise estimate to NOISE_MAX */
+			if(st->bckr_est[i] > NOISE_MAX)
+			{
+				st->bckr_est[i] = NOISE_MAX;
+			}
+		}
+	}
+
+	/* Update signal levels of the previous frame (old_level) */
+	for (i = 0; i < COMPLEN; i++)
+	{
+		st->old_level[i] = level[i];
+	}
+}
+
+/******************************************************************************
+*
+*     Function     : vad_decision
+*     Purpose      : Calculates VAD_flag
+*
+*******************************************************************************/
+
+static Word16 vad_decision(                           /* return value : VAD_flag */
+		VadVars * st,                         /* i/o : State structure                       */
+		Word16 level[COMPLEN],                /* i   : sub-band levels of the input frame */
+		Word32 pow_sum                        /* i   : power of the input frame           */
+		)
+{
+	Word32 i;
+	Word32 L_snr_sum;
+	Word32 L_temp;
+	Word16 vad_thr, temp, noise_level;
+	Word16 low_power_flag;
+	Word16 hang_len, burst_len;
+	Word16 ilog2_speech_level, ilog2_noise_level;
+	Word16 temp2;
+
+	/* Calculate squared sum of the input levels (level) divided by the background noise components
+	 * (bckr_est). */
+	L_snr_sum = 0;
+	for (i = 0; i < COMPLEN; i++)
+	{
+		Word16 exp;
+
+		exp = norm_s(st->bckr_est[i]);
+		temp = (st->bckr_est[i] << exp);
+		temp = div_s((level[i] >> 1), temp);
+		temp = shl(temp, (exp - (UNIRSHFT - 1)));
+		L_snr_sum = L_mac(L_snr_sum, temp, temp);
+	}
+
+	/* Calculate average level of estimated background noise */
+	L_temp = 0;
+	for (i = 1; i < COMPLEN; i++)          /* ignore lowest band */
+	{
+		L_temp = vo_L_add(L_temp, st->bckr_est[i]);
+	}
+
+	noise_level = extract_h((L_temp << 12));
+	/* if SNR is lower than a threshold (MIN_SPEECH_SNR), and increase speech_level */
+	temp = vo_mult(noise_level, MIN_SPEECH_SNR) << 3;
+
+	if(st->speech_level < temp)
+	{
+		st->speech_level = temp;
+	}
+	ilog2_noise_level = ilog2(noise_level);
+
+	/* If SNR is very poor, speech_level is probably corrupted by noise level. This is correctred by
+	 * subtracting MIN_SPEECH_SNR*noise_level from speech level */
+	ilog2_speech_level = ilog2(st->speech_level - temp);
+
+	temp = add1(vo_mult(NO_SLOPE, (ilog2_noise_level - NO_P1)), THR_HIGH);
+
+	temp2 = add1(SP_CH_MIN, vo_mult(SP_SLOPE, (ilog2_speech_level - SP_P1)));
+	if (temp2 < SP_CH_MIN)
+	{
+		temp2 = SP_CH_MIN;
+	}
+	if (temp2 > SP_CH_MAX)
+	{
+		temp2 = SP_CH_MAX;
+	}
+	vad_thr = temp + temp2;
+
+	if(vad_thr < THR_MIN)
+	{
+		vad_thr = THR_MIN;
+	}
+	/* Shift VAD decision register */
+	st->vadreg = (st->vadreg >> 1);
+
+	/* Make intermediate VAD decision */
+	if(L_snr_sum > vo_L_mult(vad_thr, (512 * COMPLEN)))
+	{
+		st->vadreg = (Word16) (st->vadreg | 0x4000);
+	}
+	/* check if the input power (pow_sum) is lower than a threshold" */
+	if(pow_sum < VAD_POW_LOW)
+	{
+		low_power_flag = 1;
+	} else
+	{
+		low_power_flag = 0;
+	}
+	/* Update background noise estimates */
+	noise_estimate_update(st, level);
+
+	/* Calculate values for hang_len and burst_len based on vad_thr */
+	hang_len = add1(vo_mult(HANG_SLOPE, (vad_thr - HANG_P1)), HANG_HIGH);
+	if(hang_len < HANG_LOW)
+	{
+		hang_len = HANG_LOW;
+	}
+	burst_len = add1(vo_mult(BURST_SLOPE, (vad_thr - BURST_P1)), BURST_HIGH);
+
+	return (hangover_addition(st, low_power_flag, hang_len, burst_len));
+}
+
+/******************************************************************************
+*
+*     Function : Estimate_Speech()
+*     Purpose  : Estimate speech level
+*
+* Maximum signal level is searched and stored to the variable sp_max.
+* The speech frames must locate within SP_EST_COUNT number of frames.
+* Thus, noisy frames having occasional VAD = "1" decisions will not
+* affect to the estimated speech_level.
+*
+*******************************************************************************/
+
+static void Estimate_Speech(
+		VadVars * st,                         /* i/o : State structure    */
+		Word16 in_level                       /* level of the input frame */
+		)
+{
+	Word16 alpha;
+
+	/* if the required activity count cannot be achieved, reset counters */
+	if((st->sp_est_cnt - st->sp_max_cnt) > (SP_EST_COUNT - SP_ACTIVITY_COUNT))
+	{
+		st->sp_est_cnt = 0;
+		st->sp_max = 0;
+		st->sp_max_cnt = 0;
+	}
+	st->sp_est_cnt += 1;
+
+	if (((st->vadreg & 0x4000)||(in_level > st->speech_level)) && (in_level > MIN_SPEECH_LEVEL1))
+	{
+		/* update sp_max */
+		if(in_level > st->sp_max)
+		{
+			st->sp_max = in_level;
+		}
+		st->sp_max_cnt += 1;
+
+		if(st->sp_max_cnt >= SP_ACTIVITY_COUNT)
+		{
+			Word16 tmp;
+			/* update speech estimate */
+			tmp = (st->sp_max >> 1);      /* scale to get "average" speech level */
+
+			/* select update speed */
+			if(tmp > st->speech_level)
+			{
+				alpha = ALPHA_SP_UP;
+			} else
+			{
+				alpha = ALPHA_SP_DOWN;
+			}
+			if(tmp > MIN_SPEECH_LEVEL2)
+			{
+				st->speech_level = add1(st->speech_level, vo_mult_r(alpha, vo_sub(tmp, st->speech_level)));
+			}
+			/* clear all counters used for speech estimation */
+			st->sp_max = 0;
+			st->sp_max_cnt = 0;
+			st->sp_est_cnt = 0;
+		}
+	}
+}
+
+/******************************************************************************
+*
+*  Function:   wb_vad_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+*******************************************************************************/
+
+Word16 wb_vad_init(                        /* return: non-zero with error, zero for ok. */
+		VadVars ** state,                     /* i/o : State structure    */
+		VO_MEM_OPERATOR *pMemOP
+		)
+{
+	VadVars *s;
+
+	if (state == (VadVars **) NULL)
+	{
+		fprintf(stderr, "vad_init: invalid parameter\n");
+		return -1;
+	}
+	*state = NULL;
+
+	/* allocate memory */
+	if ((s = (VadVars *) mem_malloc(pMemOP, sizeof(VadVars), 32, VO_INDEX_ENC_AMRWB)) == NULL)
+	{
+		fprintf(stderr, "vad_init: can not malloc state structure\n");
+		return -1;
+	}
+	wb_vad_reset(s);
+
+	*state = s;
+
+	return 0;
+}
+
+/******************************************************************************
+*
+*  Function:   wb_vad_reset
+*  Purpose:    Initializes state memory
+*
+*******************************************************************************/
+
+Word16 wb_vad_reset(                       /* return: non-zero with error, zero for ok. */
+		VadVars * state                       /* i/o : State structure    */
+		)
+{
+	Word32 i, j;
+
+	if (state == (VadVars *) NULL)
+	{
+		fprintf(stderr, "vad_reset: invalid parameter\n");
+		return -1;
+	}
+	state->tone_flag = 0;
+	state->vadreg = 0;
+	state->hang_count = 0;
+	state->burst_count = 0;
+	state->hang_count = 0;
+
+	/* initialize memory used by the filter bank */
+	for (i = 0; i < F_5TH_CNT; i++)
+	{
+		for (j = 0; j < 2; j++)
+		{
+			state->a_data5[i][j] = 0;
+		}
+	}
+
+	for (i = 0; i < F_3TH_CNT; i++)
+	{
+		state->a_data3[i] = 0;
+	}
+
+	/* initialize the rest of the memory */
+	for (i = 0; i < COMPLEN; i++)
+	{
+		state->bckr_est[i] = NOISE_INIT;
+		state->old_level[i] = NOISE_INIT;
+		state->ave_level[i] = NOISE_INIT;
+		state->sub_level[i] = 0;
+	}
+
+	state->sp_est_cnt = 0;
+	state->sp_max = 0;
+	state->sp_max_cnt = 0;
+	state->speech_level = SPEECH_LEVEL_INIT;
+	state->prev_pow_sum = 0;
+	return 0;
+}
+
+/******************************************************************************
+*
+*  Function:   wb_vad_exit
+*  Purpose:    The memory used for state memory is freed
+*
+*******************************************************************************/
+
+void wb_vad_exit(
+		VadVars ** state,                      /* i/o : State structure    */
+		VO_MEM_OPERATOR *pMemOP
+		)
+{
+	if (state == NULL || *state == NULL)
+		return;
+	/* deallocate memory */
+	mem_free(pMemOP, *state, VO_INDEX_ENC_AMRWB);
+	*state = NULL;
+	return;
+}
+
+/******************************************************************************
+*
+*     Function     : wb_vad_tone_detection
+*     Purpose      : Search maximum pitch gain from a frame. Set tone flag if
+*                    pitch gain is high. This is used to detect
+*                    signaling tones and other signals with high pitch gain.
+*
+*******************************************************************************/
+
+void wb_vad_tone_detection(
+		VadVars * st,                         /* i/o : State struct            */
+		Word16 p_gain                         /* pitch gain      */
+		)
+{
+	/* update tone flag */
+	st->tone_flag = (st->tone_flag >> 1);
+
+	/* if (pitch_gain > TONE_THR) set tone flag */
+	if (p_gain > TONE_THR)
+	{
+		st->tone_flag = (Word16) (st->tone_flag | 0x4000);
+	}
+}
+
+/******************************************************************************
+*
+*     Function     : wb_vad
+*     Purpose      : Main program for Voice Activity Detection (VAD) for AMR
+*
+*******************************************************************************/
+
+Word16 wb_vad(                                /* Return value : VAD Decision, 1 = speech, 0 = noise */
+		VadVars * st,                         /* i/o : State structure                 */
+		Word16 in_buf[]                       /* i   : samples of the input frame   */
+	     )
+{
+	Word16 level[COMPLEN];
+	Word32 i;
+	Word16 VAD_flag, temp;
+	Word32 L_temp, pow_sum;
+
+	/* Calculate power of the input frame. */
+	L_temp = 0L;
+	for (i = 0; i < FRAME_LEN; i++)
+	{
+		L_temp = L_mac(L_temp, in_buf[i], in_buf[i]);
+	}
+
+	/* pow_sum = power of current frame and previous frame */
+	pow_sum = L_add(L_temp, st->prev_pow_sum);
+
+	/* save power of current frame for next call */
+	st->prev_pow_sum = L_temp;
+
+	/* If input power is very low, clear tone flag */
+	if (pow_sum < POW_TONE_THR)
+	{
+		st->tone_flag = (Word16) (st->tone_flag & 0x1fff);
+	}
+	/* Run the filter bank and calculate signal levels at each band */
+	filter_bank(st, in_buf, level);
+
+	/* compute VAD decision */
+	VAD_flag = vad_decision(st, level, pow_sum);
+
+	/* Calculate input level */
+	L_temp = 0;
+	for (i = 1; i < COMPLEN; i++)          /* ignore lowest band */
+	{
+		L_temp = vo_L_add(L_temp, level[i]);
+	}
+
+	temp = extract_h(L_temp << 12);
+
+	Estimate_Speech(st, temp);             /* Estimate speech level */
+	return (VAD_flag);
+}
+
+
+
+
diff --git a/media/libstagefright/codecs/amrwbenc/src/weight_a.c b/media/libstagefright/codecs/amrwbenc/src/weight_a.c
index d47be97..a02b48d 100644
--- a/media/libstagefright/codecs/amrwbenc/src/weight_a.c
+++ b/media/libstagefright/codecs/amrwbenc/src/weight_a.c
@@ -1,48 +1,48 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-
-/***********************************************************************
-*       File: weight_a.c                                               *
-*                                                                      *
-*       Description:Weighting of LPC coefficients                      *
-*	               ap[i] = a[i] * (gamma ** i)                     *
-*                                                                      * 
-************************************************************************/
-
-#include "typedef.h"
-#include "basic_op.h"
-
-void Weight_a(
-		Word16 a[],                           /* (i) Q12 : a[m+1]  LPC coefficients             */
-		Word16 ap[],                          /* (o) Q12 : Spectral expanded LPC coefficients   */
-		Word16 gamma,                         /* (i) Q15 : Spectral expansion factor.           */
-		Word16 m                              /* (i)     : LPC order.                           */
-	     )
-{
-	Word32 num = m - 1, fac;
-	*ap++ = *a++;
-	fac = gamma;
-	do{
-		*ap++ =(Word16)(((vo_L_mult((*a++), fac)) + 0x8000) >> 16);
-		fac = (vo_L_mult(fac, gamma) + 0x8000) >> 16;
-	}while(--num != 0);
-
-	*ap++ = (Word16)(((vo_L_mult((*a++), fac)) + 0x8000) >> 16);
-	return;
-}
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+
+/***********************************************************************
+*       File: weight_a.c                                               *
+*                                                                      *
+*       Description:Weighting of LPC coefficients                      *
+*	               ap[i] = a[i] * (gamma ** i)                     *
+*                                                                      *
+************************************************************************/
+
+#include "typedef.h"
+#include "basic_op.h"
+
+void Weight_a(
+		Word16 a[],                           /* (i) Q12 : a[m+1]  LPC coefficients             */
+		Word16 ap[],                          /* (o) Q12 : Spectral expanded LPC coefficients   */
+		Word16 gamma,                         /* (i) Q15 : Spectral expansion factor.           */
+		Word16 m                              /* (i)     : LPC order.                           */
+	     )
+{
+	Word32 num = m - 1, fac;
+	*ap++ = *a++;
+	fac = gamma;
+	do{
+		*ap++ =(Word16)(((vo_L_mult((*a++), fac)) + 0x8000) >> 16);
+		fac = (vo_L_mult(fac, gamma) + 0x8000) >> 16;
+	}while(--num != 0);
+
+	*ap++ = (Word16)(((vo_L_mult((*a++), fac)) + 0x8000) >> 16);
+	return;
+}
+
+
+
diff --git a/media/libstagefright/codecs/avc/common/src/dpb.cpp b/media/libstagefright/codecs/avc/common/src/dpb.cpp
index 2c4c7da..b810345 100644
--- a/media/libstagefright/codecs/avc/common/src/dpb.cpp
+++ b/media/libstagefright/codecs/avc/common/src/dpb.cpp
@@ -132,6 +132,13 @@ OSCL_EXPORT_REF AVCStatus AVCConfigureSequence(AVCHandle *avcHandle, AVCCommonOb
         {
             num_fs = MAX_FS;
         }
+
+        CleanUpDPB(avcHandle, video);
+        if (InitDPB(avcHandle, video, FrameHeightInMbs, PicWidthInMbs, padding) != AVC_SUCCESS)
+        {
+            return AVC_FAIL;
+        }
+        num_fs = dpb->num_fs;
 #ifdef PV_MEMORY_POOL
         if (padding)
         {
@@ -143,11 +150,6 @@ OSCL_EXPORT_REF AVCStatus AVCConfigureSequence(AVCHandle *avcHandle, AVCCommonOb
             avcHandle->CBAVC_DPBAlloc(avcHandle->userData, PicSizeInMapUnits, num_fs);
         }
 #endif
-        CleanUpDPB(avcHandle, video);
-        if (InitDPB(avcHandle, video, FrameHeightInMbs, PicWidthInMbs, padding) != AVC_SUCCESS)
-        {
-            return AVC_FAIL;
-        }
         /*  Allocate video->mblock upto PicSizeInMbs and populate the structure  such as the neighboring MB pointers.   */
         framesize = (FrameHeightInMbs * PicWidthInMbs);
         if (video->mblock)
diff --git a/media/libstagefright/codecs/avc/dec/AVCDecoder.cpp b/media/libstagefright/codecs/avc/dec/AVCDecoder.cpp
index 868c514..bb77c8b 100644
--- a/media/libstagefright/codecs/avc/dec/AVCDecoder.cpp
+++ b/media/libstagefright/codecs/avc/dec/AVCDecoder.cpp
@@ -384,7 +384,10 @@ status_t AVCDecoder::read(
                 }
 
                 AVCDecObject *pDecVid = (AVCDecObject *)mHandle->AVCObject;
-
+                if(pDecVid->seqParams[0] == NULL) {
+                    LOGE("Sequence Parameter set at id 0 is invalid");
+                    break;
+                }
                 int32_t width =
                     (pDecVid->seqParams[0]->pic_width_in_mbs_minus1 + 1) * 16;
 
diff --git a/media/libstagefright/codecs/common/Config.mk b/media/libstagefright/codecs/common/Config.mk
index 27a17c1..187f25c 100644
--- a/media/libstagefright/codecs/common/Config.mk
+++ b/media/libstagefright/codecs/common/Config.mk
@@ -1,24 +1,24 @@
-# 
-# This configure file is just for Linux projects against Android
-#
-
-VOPRJ := 
-VONJ :=
-
-# WARNING:
-# Using v7 breaks generic build
-ifeq ($(TARGET_ARCH),arm)
-VOTT := v5
-else
-VOTT := pc
-endif
-
-# Do we also need to check on ARCH_ARM_HAVE_ARMV7A? - probably not
-ifeq ($(ARCH_ARM_HAVE_NEON),true)
-VOTT := v7
-endif
-
-VOTEST := 0
-
-VO_CFLAGS:=-DLINUX 
-
+#
+# This configure file is just for Linux projects against Android
+#
+
+VOPRJ :=
+VONJ :=
+
+# WARNING:
+# Using v7 breaks generic build
+ifeq ($(TARGET_ARCH),arm)
+VOTT := v5
+else
+VOTT := pc
+endif
+
+# Do we also need to check on ARCH_ARM_HAVE_ARMV7A? - probably not
+ifeq ($(ARCH_ARM_HAVE_NEON),true)
+VOTT := v7
+endif
+
+VOTEST := 0
+
+VO_CFLAGS:=-DLINUX
+
diff --git a/media/libstagefright/codecs/common/cmnMemory.c b/media/libstagefright/codecs/common/cmnMemory.c
index c17264c..aa52bd9 100644
--- a/media/libstagefright/codecs/common/cmnMemory.c
+++ b/media/libstagefright/codecs/common/cmnMemory.c
@@ -1,73 +1,71 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		cmnMemory.c
-
-	Content:	sample code for memory operator implementation
-
-*******************************************************************************/
-#include "cmnMemory.h"
-
-#include <malloc.h>
-#if defined LINUX
-#include <string.h>
-#endif
-
-//VO_MEM_OPERATOR		g_memOP;
-
-VO_U32 cmnMemAlloc (VO_S32 uID,  VO_MEM_INFO * pMemInfo)
-{
-	if (!pMemInfo)
-		return VO_ERR_INVALID_ARG;
-
-	pMemInfo->VBuffer = malloc (pMemInfo->Size);
-	return 0;
-}
-
-VO_U32 cmnMemFree (VO_S32 uID, VO_PTR pMem)
-{
-	free (pMem);
-	return 0;
-}
-
-VO_U32	cmnMemSet (VO_S32 uID, VO_PTR pBuff, VO_U8 uValue, VO_U32 uSize)
-{
-	memset (pBuff, uValue, uSize);
-	return 0;
-}
-
-VO_U32	cmnMemCopy (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize)
-{
-	memcpy (pDest, pSource, uSize);
-	return 0;
-}
-
-VO_U32	cmnMemCheck (VO_S32 uID, VO_PTR pBuffer, VO_U32 uSize)
-{
-	return 0;
-}
-
-VO_S32 cmnMemCompare (VO_S32 uID, VO_PTR pBuffer1, VO_PTR pBuffer2, VO_U32 uSize)
-{
-	return memcmp(pBuffer1, pBuffer2, uSize);
-}
-
-VO_U32	cmnMemMove (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize)
-{
-	memmove (pDest, pSource, uSize);
-	return 0;
-}
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		cmnMemory.c
+
+	Content:	sample code for memory operator implementation
+
+*******************************************************************************/
+#include "cmnMemory.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+//VO_MEM_OPERATOR		g_memOP;
+
+VO_U32 cmnMemAlloc (VO_S32 uID,  VO_MEM_INFO * pMemInfo)
+{
+	if (!pMemInfo)
+		return VO_ERR_INVALID_ARG;
+
+	pMemInfo->VBuffer = malloc (pMemInfo->Size);
+	return 0;
+}
+
+VO_U32 cmnMemFree (VO_S32 uID, VO_PTR pMem)
+{
+	free (pMem);
+	return 0;
+}
+
+VO_U32	cmnMemSet (VO_S32 uID, VO_PTR pBuff, VO_U8 uValue, VO_U32 uSize)
+{
+	memset (pBuff, uValue, uSize);
+	return 0;
+}
+
+VO_U32	cmnMemCopy (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize)
+{
+	memcpy (pDest, pSource, uSize);
+	return 0;
+}
+
+VO_U32	cmnMemCheck (VO_S32 uID, VO_PTR pBuffer, VO_U32 uSize)
+{
+	return 0;
+}
+
+VO_S32 cmnMemCompare (VO_S32 uID, VO_PTR pBuffer1, VO_PTR pBuffer2, VO_U32 uSize)
+{
+	return memcmp(pBuffer1, pBuffer2, uSize);
+}
+
+VO_U32	cmnMemMove (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize)
+{
+	memmove (pDest, pSource, uSize);
+	return 0;
+}
+
diff --git a/media/libstagefright/codecs/common/include/cmnMemory.h b/media/libstagefright/codecs/common/include/cmnMemory.h
index 9315600..0308dfa 100644
--- a/media/libstagefright/codecs/common/include/cmnMemory.h
+++ b/media/libstagefright/codecs/common/include/cmnMemory.h
@@ -1,106 +1,106 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		cmnMemory.h
-
-	Content:	memory operator implementation header file
-
-*******************************************************************************/
-
-#ifndef __cmnMemory_H__
-#define __cmnMemory_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#include <voMem.h>
-
-//extern VO_MEM_OPERATOR	g_memOP;
-
-/**
- * Allocate memory
- * \param uID [in] module ID
- * \param uSize [in] size of memory
- * \return value is the allocated memory address. NULL is failed.
- */
-VO_U32	cmnMemAlloc (VO_S32 uID,  VO_MEM_INFO * pMemInfo);
-
-/**
- * Free up memory
- * \param uID [in] module ID
- * \param pMem [in] address of memory
- * \return value 0, if succeeded.
- */
-VO_U32	cmnMemFree (VO_S32 uID, VO_PTR pBuffer);
-
-/**
- * memory set function
- * \param uID [in] module ID
- * \param pBuff [in/out] address of memory
- * \param uValue [in] the value to be set
- * \param uSize [in] the size to be set
- * \return value 0, if succeeded.
- */
-VO_U32	cmnMemSet (VO_S32 uID, VO_PTR pBuff, VO_U8 uValue, VO_U32 uSize);
-
-/**
- * memory copy function
- * \param uID [in] module ID
- * \param pDest [in/out] address of destination memory
- * \param pSource [in] address of source memory
- * \param uSize [in] the size to be copied
- * \return value 0, if succeeded.
- */
-VO_U32	cmnMemCopy (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize);
-
-/**
- * memory check function
- * \param uID [in] module ID
- * \param pBuff [in] address of buffer to be checked
- * \param uSize [in] the size to be checked
- * \return value 0, if succeeded.
- */
-VO_U32	cmnMemCheck (VO_S32 uID, VO_PTR pBuffer, VO_U32 uSize);
-
-/**
- * memory compare function
- * \param uID [in] module ID
- * \param pBuffer1 [in] address of buffer 1 to be compared
- * \param pBuffer2 [in] address of buffer 2 to be compared
- * \param uSize [in] the size to be compared
- * \return value: same as standard C run-time memcmp() function.
- */
-VO_S32	cmnMemCompare (VO_S32 uID, VO_PTR pBuffer1, VO_PTR pBuffer2, VO_U32 uSize);
-
-/**
- * memory move function
- * \param uID [in] module ID
- * \param pDest [in/out] address of destination memory
- * \param pSource [in] address of source memory
- * \param uSize [in] the size to be moved
- * \return value 0, if succeeded.
- */
-VO_U32	cmnMemMove (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize);
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif // __cmnMemory_H__
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		cmnMemory.h
+
+	Content:	memory operator implementation header file
+
+*******************************************************************************/
+
+#ifndef __cmnMemory_H__
+#define __cmnMemory_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <voMem.h>
+
+//extern VO_MEM_OPERATOR	g_memOP;
+
+/**
+ * Allocate memory
+ * \param uID [in] module ID
+ * \param uSize [in] size of memory
+ * \return value is the allocated memory address. NULL is failed.
+ */
+VO_U32	cmnMemAlloc (VO_S32 uID,  VO_MEM_INFO * pMemInfo);
+
+/**
+ * Free up memory
+ * \param uID [in] module ID
+ * \param pMem [in] address of memory
+ * \return value 0, if succeeded.
+ */
+VO_U32	cmnMemFree (VO_S32 uID, VO_PTR pBuffer);
+
+/**
+ * memory set function
+ * \param uID [in] module ID
+ * \param pBuff [in/out] address of memory
+ * \param uValue [in] the value to be set
+ * \param uSize [in] the size to be set
+ * \return value 0, if succeeded.
+ */
+VO_U32	cmnMemSet (VO_S32 uID, VO_PTR pBuff, VO_U8 uValue, VO_U32 uSize);
+
+/**
+ * memory copy function
+ * \param uID [in] module ID
+ * \param pDest [in/out] address of destination memory
+ * \param pSource [in] address of source memory
+ * \param uSize [in] the size to be copied
+ * \return value 0, if succeeded.
+ */
+VO_U32	cmnMemCopy (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize);
+
+/**
+ * memory check function
+ * \param uID [in] module ID
+ * \param pBuff [in] address of buffer to be checked
+ * \param uSize [in] the size to be checked
+ * \return value 0, if succeeded.
+ */
+VO_U32	cmnMemCheck (VO_S32 uID, VO_PTR pBuffer, VO_U32 uSize);
+
+/**
+ * memory compare function
+ * \param uID [in] module ID
+ * \param pBuffer1 [in] address of buffer 1 to be compared
+ * \param pBuffer2 [in] address of buffer 2 to be compared
+ * \param uSize [in] the size to be compared
+ * \return value: same as standard C run-time memcmp() function.
+ */
+VO_S32	cmnMemCompare (VO_S32 uID, VO_PTR pBuffer1, VO_PTR pBuffer2, VO_U32 uSize);
+
+/**
+ * memory move function
+ * \param uID [in] module ID
+ * \param pDest [in/out] address of destination memory
+ * \param pSource [in] address of source memory
+ * \param uSize [in] the size to be moved
+ * \return value 0, if succeeded.
+ */
+VO_U32	cmnMemMove (VO_S32 uID, VO_PTR pDest, VO_PTR pSource, VO_U32 uSize);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif // __cmnMemory_H__
+
+
diff --git a/media/libstagefright/codecs/common/include/voAAC.h b/media/libstagefright/codecs/common/include/voAAC.h
index d11ed83..9ecb142 100644
--- a/media/libstagefright/codecs/common/include/voAAC.h
+++ b/media/libstagefright/codecs/common/include/voAAC.h
@@ -1,74 +1,74 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		voAAC.h
-
-	Content:	AAC codec APIs & data types
-
-*******************************************************************************/
-
-#ifndef __voAAC_H__
-#define __voAAC_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#include "voAudio.h"
-
-/*!
- * the frame type that the decoder supports
- */
-typedef enum {
-	VOAAC_RAWDATA			= 0,	/*!<contains only raw aac data in a frame*/
-	VOAAC_ADTS				= 1,	/*!<contains ADTS header + raw AAC data in a frame*/
-	VOAAC_FT_MAX			= VO_MAX_ENUM_VALUE
-} VOAACFRAMETYPE;
-
-/*!
- * the structure for AAC encoder input parameter
- */
-typedef  struct {
-  int	  sampleRate;          /*! audio file sample rate */
-  int	  bitRate;             /*! encoder bit rate in bits/sec */
-  short   nChannels;		   /*! number of channels on input (1,2) */
-  short   adtsUsed;			   /*! whether write adts header */
-} AACENC_PARAM;
-
-/* AAC Param ID */
-#define VO_PID_AAC_Mdoule				0x42211000
-#define VO_PID_AAC_ENCPARAM				VO_PID_AAC_Mdoule | 0x0040  /*!< get/set AAC encoder parameter, the parameter is a pointer to AACENC_PARAM */
-
-/* AAC decoder error ID */
-#define VO_ERR_AAC_Mdoule				0x82210000
-#define VO_ERR_AAC_UNSFILEFORMAT		(VO_ERR_AAC_Mdoule | 0xF001)
-#define VO_ERR_AAC_UNSPROFILE			(VO_ERR_AAC_Mdoule | 0xF002)
-
-/**
- * Get audio encoder API interface
- * \param pEncHandle [out] Return the AAC Encoder handle.
- * \retval VO_ERR_OK Succeeded.
- */
-VO_S32 VO_API voGetAACEncAPI (VO_AUDIO_CODECAPI * pEncHandle);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif // __voAAC_H__
-
-
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		voAAC.h
+
+	Content:	AAC codec APIs & data types
+
+*******************************************************************************/
+
+#ifndef __voAAC_H__
+#define __voAAC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "voAudio.h"
+
+/*!
+ * the frame type that the decoder supports
+ */
+typedef enum {
+	VOAAC_RAWDATA			= 0,	/*!<contains only raw aac data in a frame*/
+	VOAAC_ADTS				= 1,	/*!<contains ADTS header + raw AAC data in a frame*/
+	VOAAC_FT_MAX			= VO_MAX_ENUM_VALUE
+} VOAACFRAMETYPE;
+
+/*!
+ * the structure for AAC encoder input parameter
+ */
+typedef  struct {
+  int	  sampleRate;          /*! audio file sample rate */
+  int	  bitRate;             /*! encoder bit rate in bits/sec */
+  short   nChannels;		   /*! number of channels on input (1,2) */
+  short   adtsUsed;			   /*! whether write adts header */
+} AACENC_PARAM;
+
+/* AAC Param ID */
+#define VO_PID_AAC_Mdoule				0x42211000
+#define VO_PID_AAC_ENCPARAM				VO_PID_AAC_Mdoule | 0x0040  /*!< get/set AAC encoder parameter, the parameter is a pointer to AACENC_PARAM */
+
+/* AAC decoder error ID */
+#define VO_ERR_AAC_Mdoule				0x82210000
+#define VO_ERR_AAC_UNSFILEFORMAT		(VO_ERR_AAC_Mdoule | 0xF001)
+#define VO_ERR_AAC_UNSPROFILE			(VO_ERR_AAC_Mdoule | 0xF002)
+
+/**
+ * Get audio encoder API interface
+ * \param pEncHandle [out] Return the AAC Encoder handle.
+ * \retval VO_ERR_OK Succeeded.
+ */
+VO_S32 VO_API voGetAACEncAPI (VO_AUDIO_CODECAPI * pEncHandle);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif // __voAAC_H__
+
+
+
diff --git a/media/libstagefright/codecs/common/include/voAMRWB.h b/media/libstagefright/codecs/common/include/voAMRWB.h
index 8a93eb8..d3eb537 100644
--- a/media/libstagefright/codecs/common/include/voAMRWB.h
+++ b/media/libstagefright/codecs/common/include/voAMRWB.h
@@ -1,87 +1,87 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		voAMRWB.h
-
-	Content:	AMR-WB codec APIs & data types
-
-*******************************************************************************/
-#ifndef  __VOAMRWB_H__
-#define  __VOAMRWB_H__
-
-#include  "voAudio.h"
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-#pragma pack(push, 4)
-
-/*!* the bit rate the codec supports*/
-typedef enum { 
-	VOAMRWB_MDNONE		= -1,	/*!< Invalid mode */
-	VOAMRWB_MD66		= 0,	/*!< 6.60kbps   */
-	VOAMRWB_MD885		= 1,    /*!< 8.85kbps   */       
-	VOAMRWB_MD1265		= 2,	/*!< 12.65kbps  */
-	VOAMRWB_MD1425		= 3,	/*!< 14.25kbps  */
-	VOAMRWB_MD1585		= 4,	/*!< 15.85bps   */
-	VOAMRWB_MD1825		= 5,	/*!< 18.25bps   */
-	VOAMRWB_MD1985		= 6,	/*!< 19.85kbps  */
-	VOAMRWB_MD2305		= 7,    /*!< 23.05kbps  */
-	VOAMRWB_MD2385          = 8,    /*!< 23.85kbps> */	
-	VOAMRWB_N_MODES 	= 9,	/*!< Invalid mode */
-	VOAMRWB_MODE_MAX    = VO_MAX_ENUM_VALUE
-	
-}VOAMRWBMODE;
-
-/*!* the frame format the codec supports*/
-typedef enum {
-	VOAMRWB_DEFAULT  	= 0,	/*!< the frame type is the header (defined in RFC3267) + rawdata*/
-	/*One word (2-byte) for sync word (0x6b21)*/
-	/*One word (2-byte) for frame length N.*/
-	/*N words (2-byte) containing N bits (bit 0 = 0x007f, bit 1 = 0x0081).*/
-	VOAMRWB_ITU         = 1, 
-	/*One word (2-byte) for sync word (0x6b21).*/
-	/*One word (2-byte) to indicate the frame type.*/	
-	/*One word (2-byte) to indicate the mode.*/
-	/*N words  (2-byte) containing N bits (bit 0 = 0xff81, bit 1 = 0x007f).*/
-	VOAMRWB_RFC3267		= 2,	/* see RFC 3267 */  
-    VOAMRWB_TMAX        = VO_MAX_ENUM_VALUE	
-}VOAMRWBFRAMETYPE;
-
-
-#define    VO_PID_AMRWB_Module							0x42261000 
-#define    VO_PID_AMRWB_FORMAT                          (VO_PID_AMRWB_Module | 0x0002)
-#define    VO_PID_AMRWB_CHANNELS                        (VO_PID_AMRWB_Module | 0x0003)
-#define    VO_PID_AMRWB_SAMPLERATE                      (VO_PID_AMRWB_Module | 0x0004)
-#define    VO_PID_AMRWB_FRAMETYPE                       (VO_PID_AMRWB_Module | 0x0005)
-#define    VO_PID_AMRWB_MODE                            (VO_PID_AMRWB_Module | 0x0006)
-#define    VO_PID_AMRWB_DTX                             (VO_PID_AMRWB_Module | 0x0007)
-
-/**
- * Get audio codec API interface
- * \param pEncHandle [out] Return the AMRWB Encoder handle.
- * \retval VO_ERR_OK Succeeded.
- */
-VO_S32 VO_API voGetAMRWBEncAPI(VO_AUDIO_CODECAPI *pEncHandle);
-
-
-#pragma pack(pop)
-#ifdef __cplusplus
-} /* extern "C" */
-#endif /* __cplusplus */
-
-
-#endif   //__VOAMRWB_H__
-
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		voAMRWB.h
+
+	Content:	AMR-WB codec APIs & data types
+
+*******************************************************************************/
+#ifndef  __VOAMRWB_H__
+#define  __VOAMRWB_H__
+
+#include  "voAudio.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#pragma pack(push, 4)
+
+/*!* the bit rate the codec supports*/
+typedef enum {
+	VOAMRWB_MDNONE		= -1,	/*!< Invalid mode */
+	VOAMRWB_MD66		= 0,	/*!< 6.60kbps   */
+	VOAMRWB_MD885		= 1,    /*!< 8.85kbps   */
+	VOAMRWB_MD1265		= 2,	/*!< 12.65kbps  */
+	VOAMRWB_MD1425		= 3,	/*!< 14.25kbps  */
+	VOAMRWB_MD1585		= 4,	/*!< 15.85bps   */
+	VOAMRWB_MD1825		= 5,	/*!< 18.25bps   */
+	VOAMRWB_MD1985		= 6,	/*!< 19.85kbps  */
+	VOAMRWB_MD2305		= 7,    /*!< 23.05kbps  */
+	VOAMRWB_MD2385          = 8,    /*!< 23.85kbps> */
+	VOAMRWB_N_MODES 	= 9,	/*!< Invalid mode */
+	VOAMRWB_MODE_MAX    = VO_MAX_ENUM_VALUE
+
+}VOAMRWBMODE;
+
+/*!* the frame format the codec supports*/
+typedef enum {
+	VOAMRWB_DEFAULT  	= 0,	/*!< the frame type is the header (defined in RFC3267) + rawdata*/
+	/*One word (2-byte) for sync word (0x6b21)*/
+	/*One word (2-byte) for frame length N.*/
+	/*N words (2-byte) containing N bits (bit 0 = 0x007f, bit 1 = 0x0081).*/
+	VOAMRWB_ITU         = 1,
+	/*One word (2-byte) for sync word (0x6b21).*/
+	/*One word (2-byte) to indicate the frame type.*/
+	/*One word (2-byte) to indicate the mode.*/
+	/*N words  (2-byte) containing N bits (bit 0 = 0xff81, bit 1 = 0x007f).*/
+	VOAMRWB_RFC3267		= 2,	/* see RFC 3267 */
+    VOAMRWB_TMAX        = VO_MAX_ENUM_VALUE
+}VOAMRWBFRAMETYPE;
+
+
+#define    VO_PID_AMRWB_Module							0x42261000
+#define    VO_PID_AMRWB_FORMAT                          (VO_PID_AMRWB_Module | 0x0002)
+#define    VO_PID_AMRWB_CHANNELS                        (VO_PID_AMRWB_Module | 0x0003)
+#define    VO_PID_AMRWB_SAMPLERATE                      (VO_PID_AMRWB_Module | 0x0004)
+#define    VO_PID_AMRWB_FRAMETYPE                       (VO_PID_AMRWB_Module | 0x0005)
+#define    VO_PID_AMRWB_MODE                            (VO_PID_AMRWB_Module | 0x0006)
+#define    VO_PID_AMRWB_DTX                             (VO_PID_AMRWB_Module | 0x0007)
+
+/**
+ * Get audio codec API interface
+ * \param pEncHandle [out] Return the AMRWB Encoder handle.
+ * \retval VO_ERR_OK Succeeded.
+ */
+VO_S32 VO_API voGetAMRWBEncAPI(VO_AUDIO_CODECAPI *pEncHandle);
+
+
+#pragma pack(pop)
+#ifdef __cplusplus
+} /* extern "C" */
+#endif /* __cplusplus */
+
+
+#endif   //__VOAMRWB_H__
+
diff --git a/media/libstagefright/codecs/common/include/voAudio.h b/media/libstagefright/codecs/common/include/voAudio.h
index 64c9dfb..d8628ee 100644
--- a/media/libstagefright/codecs/common/include/voAudio.h
+++ b/media/libstagefright/codecs/common/include/voAudio.h
@@ -1,173 +1,173 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		voAudio.h
-
-	Content:	Audio types and functions
-
-*******************************************************************************/
-
-#ifndef __voAudio_H__
-#define __voAudio_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#include "voIndex.h"
-#include "voMem.h"
-
-#define	VO_PID_AUDIO_BASE			 0x42000000							/*!< The base param ID for AUDIO codec */
-#define	VO_PID_AUDIO_FORMAT			(VO_PID_AUDIO_BASE | 0X0001)		/*!< The format data of audio in track */
-#define	VO_PID_AUDIO_SAMPLEREATE	(VO_PID_AUDIO_BASE | 0X0002)		/*!< The sample rate of audio  */
-#define	VO_PID_AUDIO_CHANNELS		(VO_PID_AUDIO_BASE | 0X0003)		/*!< The channel of audio */
-#define	VO_PID_AUDIO_BITRATE		(VO_PID_AUDIO_BASE | 0X0004)		/*!< The bit rate of audio */
-#define VO_PID_AUDIO_CHANNELMODE	(VO_PID_AUDIO_BASE | 0X0005)		/*!< The channel mode of audio */
-
-#define	VO_ERR_AUDIO_BASE			0x82000000
-#define VO_ERR_AUDIO_UNSCHANNEL		VO_ERR_AUDIO_BASE | 0x0001
-#define VO_ERR_AUDIO_UNSSAMPLERATE	VO_ERR_AUDIO_BASE | 0x0002
-#define VO_ERR_AUDIO_UNSFEATURE		VO_ERR_AUDIO_BASE | 0x0003
-
-
-/**
- *Enumeration used to define the possible audio coding formats.
- */
-typedef enum VO_AUDIO_CODINGTYPE {
-	VO_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
-	VO_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
-	VO_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
-	VO_AUDIO_CodingAMRNB,       /**< Any variant of AMR encoded data */
-	VO_AUDIO_CodingAMRWB,       /**< Any variant of AMR encoded data */
-	VO_AUDIO_CodingAMRWBP,      /**< Any variant of AMR encoded data */
-	VO_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
-	VO_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
-	VO_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data, 0xA106 - ISO/MPEG-4 AAC, 0xFF - AAC */
-	VO_AUDIO_CodingAC3,         /**< Any variant of AC3 encoded data */
-	VO_AUDIO_CodingFLAC,        /**< Any variant of FLAC encoded data */
-	VO_AUDIO_CodingMP1,			/**< Any variant of MP1 encoded data */
-	VO_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
-	VO_AUDIO_CodingOGG,         /**< Any variant of OGG encoded data */
-	VO_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
-	VO_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
-	VO_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
-	VO_AUDIO_CodingDRA,         /**< Any variant of dra encoded data */
-	VO_AUDIO_CodingG729,        /**< Any variant of dra encoded data */
-	VO_AUDIO_Coding_MAX		= VO_MAX_ENUM_VALUE
-} VO_AUDIO_CODINGTYPE;
-
-/*!
-* the channel type value
-*/
-typedef enum {
-	VO_CHANNEL_CENTER				= 1,	/*!<center channel*/
-	VO_CHANNEL_FRONT_LEFT			= 1<<1,	/*!<front left channel*/
-	VO_CHANNEL_FRONT_RIGHT			= 1<<2,	/*!<front right channel*/
-	VO_CHANNEL_SIDE_LEFT  			= 1<<3, /*!<side left channel*/
-	VO_CHANNEL_SIDE_RIGHT			= 1<<4, /*!<side right channel*/
-	VO_CHANNEL_BACK_LEFT			= 1<<5,	/*!<back left channel*/
-	VO_CHANNEL_BACK_RIGHT			= 1<<6,	/*!<back right channel*/
-	VO_CHANNEL_BACK_CENTER			= 1<<7,	/*!<back center channel*/
-	VO_CHANNEL_LFE_BASS				= 1<<8,	/*!<low-frequency effects bass channel*/
-	VO_CHANNEL_ALL					= 0xffff,/*!<[default] include all channels */
-	VO_CHANNEL_MAX					= VO_MAX_ENUM_VALUE
-} VO_AUDIO_CHANNELTYPE;
-
-/**
- * General audio format info
- */
-typedef struct
-{
-	VO_S32	SampleRate;  /*!< Sample rate */
-	VO_S32	Channels;    /*!< Channel count */
-	VO_S32	SampleBits;  /*!< Bits per sample */
-} VO_AUDIO_FORMAT;
-
-/**
- * General audio output info
- */
-typedef struct
-{
-	VO_AUDIO_FORMAT	Format;			/*!< Sample rate */
-	VO_U32			InputUsed;		/*!< Channel count */
-	VO_U32			Resever;		/*!< Resevered */
-} VO_AUDIO_OUTPUTINFO;
-
-/**
- * General audio codec function set
- */
-typedef struct VO_AUDIO_CODECAPI
-{
-	/**
-	 * Init the audio codec module and return codec handle
-	 * \param phCodec [OUT] Return the video codec handle
-	 * \param vType	[IN] The codec type if the module support multi codec.
-	 * \param pUserData	[IN] The init param. It is either a memory operator or an allocated memory
-	 * \retval VO_ERR_NONE Succeeded.
-	 */
-	VO_U32 (VO_API * Init) (VO_HANDLE * phCodec, VO_AUDIO_CODINGTYPE vType, VO_CODEC_INIT_USERDATA * pUserData );
-
-	/**
-	 * Set input audio data.
-	 * \param hCodec [IN]] The codec handle which was created by Init function.
-	 * \param pInput [IN] The input buffer param.
-	 * \retval VO_ERR_NONE Succeeded.
-	 */
-	VO_U32 (VO_API * SetInputData) (VO_HANDLE hCodec, VO_CODECBUFFER * pInput);
-
-	/**
-	 * Get the outut audio data
-	 * \param hCodec [IN]] The codec handle which was created by Init function.
-	 * \param pOutBuffer [OUT] The output audio data
-	 * \param pOutInfo [OUT] The codec fills audio format and the input data size used in current call.
-	 *						 pOutInfo->InputUsed is total used input data size in byte.
-	 * \retval  VO_ERR_NONE Succeeded.
-	 *			VO_ERR_INPUT_BUFFER_SMALL. The input was finished or the input data was not enought. Continue to input 
-	 *										data before next call.
-	 */
-	VO_U32 (VO_API * GetOutputData) (VO_HANDLE hCodec, VO_CODECBUFFER * pOutBuffer, VO_AUDIO_OUTPUTINFO * pOutInfo);
-
-	/**
-	 * Set the parameter for the specified param ID.
-	 * \param hCodec [IN]] The codec handle which was created by Init function.
-	 * \param uParamID [IN] The param ID.
-	 * \param pData [IN] The param value.
-	 * \retval VO_ERR_NONE Succeeded.
-	 */
-	VO_U32 (VO_API * SetParam) (VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData);
-
-	/**
-	 * Get the parameter for the specified param ID.
-	 * \param hCodec [IN]] The codec handle which was created by Init function.
-	 * \param uParamID [IN] The param ID.
-	 * \param pData [IN] The param value.
-	 * \retval VO_ERR_NONE Succeeded.
-	 */
-	VO_U32 (VO_API * GetParam) (VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData);
-
-	/**
-	 * Uninit the Codec.
-	 * \param hCodec [IN]] The codec handle which was created by Init function.
-	 * \retval VO_ERR_NONE Succeeded.
-	 */
-	VO_U32 (VO_API * Uninit) (VO_HANDLE hCodec);
-} VO_AUDIO_CODECAPI;
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif // __voAudio_H__
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		voAudio.h
+
+	Content:	Audio types and functions
+
+*******************************************************************************/
+
+#ifndef __voAudio_H__
+#define __voAudio_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "voIndex.h"
+#include "voMem.h"
+
+#define	VO_PID_AUDIO_BASE			 0x42000000							/*!< The base param ID for AUDIO codec */
+#define	VO_PID_AUDIO_FORMAT			(VO_PID_AUDIO_BASE | 0X0001)		/*!< The format data of audio in track */
+#define	VO_PID_AUDIO_SAMPLEREATE	(VO_PID_AUDIO_BASE | 0X0002)		/*!< The sample rate of audio  */
+#define	VO_PID_AUDIO_CHANNELS		(VO_PID_AUDIO_BASE | 0X0003)		/*!< The channel of audio */
+#define	VO_PID_AUDIO_BITRATE		(VO_PID_AUDIO_BASE | 0X0004)		/*!< The bit rate of audio */
+#define VO_PID_AUDIO_CHANNELMODE	(VO_PID_AUDIO_BASE | 0X0005)		/*!< The channel mode of audio */
+
+#define	VO_ERR_AUDIO_BASE			0x82000000
+#define VO_ERR_AUDIO_UNSCHANNEL		VO_ERR_AUDIO_BASE | 0x0001
+#define VO_ERR_AUDIO_UNSSAMPLERATE	VO_ERR_AUDIO_BASE | 0x0002
+#define VO_ERR_AUDIO_UNSFEATURE		VO_ERR_AUDIO_BASE | 0x0003
+
+
+/**
+ *Enumeration used to define the possible audio coding formats.
+ */
+typedef enum VO_AUDIO_CODINGTYPE {
+	VO_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
+	VO_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
+	VO_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
+	VO_AUDIO_CodingAMRNB,       /**< Any variant of AMR encoded data */
+	VO_AUDIO_CodingAMRWB,       /**< Any variant of AMR encoded data */
+	VO_AUDIO_CodingAMRWBP,      /**< Any variant of AMR encoded data */
+	VO_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
+	VO_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
+	VO_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data, 0xA106 - ISO/MPEG-4 AAC, 0xFF - AAC */
+	VO_AUDIO_CodingAC3,         /**< Any variant of AC3 encoded data */
+	VO_AUDIO_CodingFLAC,        /**< Any variant of FLAC encoded data */
+	VO_AUDIO_CodingMP1,			/**< Any variant of MP1 encoded data */
+	VO_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
+	VO_AUDIO_CodingOGG,         /**< Any variant of OGG encoded data */
+	VO_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
+	VO_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
+	VO_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
+	VO_AUDIO_CodingDRA,         /**< Any variant of dra encoded data */
+	VO_AUDIO_CodingG729,        /**< Any variant of dra encoded data */
+	VO_AUDIO_Coding_MAX		= VO_MAX_ENUM_VALUE
+} VO_AUDIO_CODINGTYPE;
+
+/*!
+* the channel type value
+*/
+typedef enum {
+	VO_CHANNEL_CENTER				= 1,	/*!<center channel*/
+	VO_CHANNEL_FRONT_LEFT			= 1<<1,	/*!<front left channel*/
+	VO_CHANNEL_FRONT_RIGHT			= 1<<2,	/*!<front right channel*/
+	VO_CHANNEL_SIDE_LEFT  			= 1<<3, /*!<side left channel*/
+	VO_CHANNEL_SIDE_RIGHT			= 1<<4, /*!<side right channel*/
+	VO_CHANNEL_BACK_LEFT			= 1<<5,	/*!<back left channel*/
+	VO_CHANNEL_BACK_RIGHT			= 1<<6,	/*!<back right channel*/
+	VO_CHANNEL_BACK_CENTER			= 1<<7,	/*!<back center channel*/
+	VO_CHANNEL_LFE_BASS				= 1<<8,	/*!<low-frequency effects bass channel*/
+	VO_CHANNEL_ALL					= 0xffff,/*!<[default] include all channels */
+	VO_CHANNEL_MAX					= VO_MAX_ENUM_VALUE
+} VO_AUDIO_CHANNELTYPE;
+
+/**
+ * General audio format info
+ */
+typedef struct
+{
+	VO_S32	SampleRate;  /*!< Sample rate */
+	VO_S32	Channels;    /*!< Channel count */
+	VO_S32	SampleBits;  /*!< Bits per sample */
+} VO_AUDIO_FORMAT;
+
+/**
+ * General audio output info
+ */
+typedef struct
+{
+	VO_AUDIO_FORMAT	Format;			/*!< Sample rate */
+	VO_U32			InputUsed;		/*!< Channel count */
+	VO_U32			Resever;		/*!< Resevered */
+} VO_AUDIO_OUTPUTINFO;
+
+/**
+ * General audio codec function set
+ */
+typedef struct VO_AUDIO_CODECAPI
+{
+	/**
+	 * Init the audio codec module and return codec handle
+	 * \param phCodec [OUT] Return the video codec handle
+	 * \param vType	[IN] The codec type if the module support multi codec.
+	 * \param pUserData	[IN] The init param. It is either a memory operator or an allocated memory
+	 * \retval VO_ERR_NONE Succeeded.
+	 */
+	VO_U32 (VO_API * Init) (VO_HANDLE * phCodec, VO_AUDIO_CODINGTYPE vType, VO_CODEC_INIT_USERDATA * pUserData );
+
+	/**
+	 * Set input audio data.
+	 * \param hCodec [IN]] The codec handle which was created by Init function.
+	 * \param pInput [IN] The input buffer param.
+	 * \retval VO_ERR_NONE Succeeded.
+	 */
+	VO_U32 (VO_API * SetInputData) (VO_HANDLE hCodec, VO_CODECBUFFER * pInput);
+
+	/**
+	 * Get the outut audio data
+	 * \param hCodec [IN]] The codec handle which was created by Init function.
+	 * \param pOutBuffer [OUT] The output audio data
+	 * \param pOutInfo [OUT] The codec fills audio format and the input data size used in current call.
+	 *						 pOutInfo->InputUsed is total used input data size in byte.
+	 * \retval  VO_ERR_NONE Succeeded.
+	 *			VO_ERR_INPUT_BUFFER_SMALL. The input was finished or the input data was not enought. Continue to input
+	 *										data before next call.
+	 */
+	VO_U32 (VO_API * GetOutputData) (VO_HANDLE hCodec, VO_CODECBUFFER * pOutBuffer, VO_AUDIO_OUTPUTINFO * pOutInfo);
+
+	/**
+	 * Set the parameter for the specified param ID.
+	 * \param hCodec [IN]] The codec handle which was created by Init function.
+	 * \param uParamID [IN] The param ID.
+	 * \param pData [IN] The param value.
+	 * \retval VO_ERR_NONE Succeeded.
+	 */
+	VO_U32 (VO_API * SetParam) (VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData);
+
+	/**
+	 * Get the parameter for the specified param ID.
+	 * \param hCodec [IN]] The codec handle which was created by Init function.
+	 * \param uParamID [IN] The param ID.
+	 * \param pData [IN] The param value.
+	 * \retval VO_ERR_NONE Succeeded.
+	 */
+	VO_U32 (VO_API * GetParam) (VO_HANDLE hCodec, VO_S32 uParamID, VO_PTR pData);
+
+	/**
+	 * Uninit the Codec.
+	 * \param hCodec [IN]] The codec handle which was created by Init function.
+	 * \retval VO_ERR_NONE Succeeded.
+	 */
+	VO_U32 (VO_API * Uninit) (VO_HANDLE hCodec);
+} VO_AUDIO_CODECAPI;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif // __voAudio_H__
diff --git a/media/libstagefright/codecs/common/include/voIndex.h b/media/libstagefright/codecs/common/include/voIndex.h
index 541a0db..320a2f8 100644
--- a/media/libstagefright/codecs/common/include/voIndex.h
+++ b/media/libstagefright/codecs/common/include/voIndex.h
@@ -1,193 +1,193 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		voIndex.h
-
-	Content:	module and ID definition
-
-*******************************************************************************/
-
-#ifndef __voIndex_H__
-#define __voIndex_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#include "voType.h"
-
-/* Define the module ID */
-#define _MAKE_SOURCE_ID(id, name) \
-VO_INDEX_SRC_##name = _VO_INDEX_SOURCE | id,
-
-#define _MAKE_CODEC_ID(id, name) \
-VO_INDEX_DEC_##name = _VO_INDEX_DEC | id, \
-VO_INDEX_ENC_##name = _VO_INDEX_ENC | id,
-
-#define _MAKE_EFFECT_ID(id, name) \
-VO_INDEX_EFT_##name = _VO_INDEX_EFFECT | id,
-
-#define _MAKE_SINK_ID(id, name) \
-VO_INDEX_SNK_##name = _VO_INDEX_SINK | id,
-
-#define _MAKE_FILTER_ID(id, name) \
-VO_INDEX_FLT_##name = _VO_INDEX_FILTER | id,
-
-#define _MAKE_OMX_ID(id, name) \
-VO_INDEX_OMX_##name = _VO_INDEX_OMX | id,
-
-#define _MAKE_MFW_ID(id, name) \
-VO_INDEX_MFW_##name = _VO_INDEX_MFW | id,
-
-enum
-{
-	_VO_INDEX_SOURCE		= 0x01000000,
-	_VO_INDEX_DEC			= 0x02000000,
-	_VO_INDEX_ENC			= 0x03000000,
-	_VO_INDEX_EFFECT		= 0x04000000,
-	_VO_INDEX_SINK			= 0x05000000,
-	_VO_INDEX_FILTER		= 0x06000000,
-	_VO_INDEX_OMX			= 0x07000000,
-	_VO_INDEX_MFW			= 0x08000000,
-
-	// define file parser modules
-	_MAKE_SOURCE_ID (0x010000, MP4)
-	_MAKE_SOURCE_ID (0x020000, AVI)
-	_MAKE_SOURCE_ID (0x030000, ASF)
-	_MAKE_SOURCE_ID (0x040000, REAL)
-	_MAKE_SOURCE_ID (0x050000, AUDIO)
-	_MAKE_SOURCE_ID (0x060000, FLASH)
-	_MAKE_SOURCE_ID (0x070000, OGG)
-	_MAKE_SOURCE_ID (0x080000, MKV)
-
-	// define network source modules
-	_MAKE_SOURCE_ID (0x110000, RTSP)
-	_MAKE_SOURCE_ID (0x120000, HTTP)
-
-	// define CMMB source modules
-	_MAKE_SOURCE_ID (0x200000, CMMB)
-	_MAKE_SOURCE_ID (0x210000, CMMB_INNO)
-	_MAKE_SOURCE_ID (0x220000, CMMB_TELE)
-	_MAKE_SOURCE_ID (0x230000, CMMB_SIANO)
-
-	// define DVBT source modules
-	_MAKE_SOURCE_ID (0x300000, DVBT)
-	_MAKE_SOURCE_ID (0x310000, DVBT_DIBCOM)
-
-	// define other source modules
-	_MAKE_SOURCE_ID (0x400000, ID3)
-
-	// define video codec modules
-	_MAKE_CODEC_ID (0x010000, H264)
-	_MAKE_CODEC_ID (0x020000, MPEG4)
-	_MAKE_CODEC_ID (0x030000, H263)
-	_MAKE_CODEC_ID (0x040000, S263)
-	_MAKE_CODEC_ID (0x050000, RV)
-	_MAKE_CODEC_ID (0x060000, WMV)
-	_MAKE_CODEC_ID (0x070000, DIVX3)
-	_MAKE_CODEC_ID (0x080000, MJPEG)
-	_MAKE_CODEC_ID (0x090000, MPEG2)
-	_MAKE_CODEC_ID (0x0A0000, VP6)
-
-	// define audio codec modules
-	_MAKE_CODEC_ID (0x210000, AAC)
-	_MAKE_CODEC_ID (0x220000, MP3)
-	_MAKE_CODEC_ID (0x230000, WMA)
-	_MAKE_CODEC_ID (0x240000, RA)
-	_MAKE_CODEC_ID (0x250000, AMRNB)
-	_MAKE_CODEC_ID (0x260000, AMRWB)
-	_MAKE_CODEC_ID (0x270000, AMRWBP)
-	_MAKE_CODEC_ID (0x280000, QCELP)
-	_MAKE_CODEC_ID (0x290000, EVRC)
-	_MAKE_CODEC_ID (0x2A0000, ADPCM)
-	_MAKE_CODEC_ID (0x2B0000, MIDI)
-	_MAKE_CODEC_ID (0x2C0000, AC3)
-	_MAKE_CODEC_ID (0x2D0000, FLAC)
-	_MAKE_CODEC_ID (0x2E0000, DRA)
-	_MAKE_CODEC_ID (0x2F0000, OGG)
-	_MAKE_CODEC_ID (0x300000, G729)
-
-	// define image codec modules
-	_MAKE_CODEC_ID (0x410000, JPEG)
-	_MAKE_CODEC_ID (0x420000, GIF)
-	_MAKE_CODEC_ID (0x430000, PNG)
-	_MAKE_CODEC_ID (0x440000, TIF)
-
-	// define effect modules
-	_MAKE_EFFECT_ID (0x010000, EQ)
-
-	// define sink modules
-	_MAKE_SINK_ID (0x010000, VIDEO)
-	_MAKE_SINK_ID (0x020000, AUDIO)
-	_MAKE_SINK_ID (0x030000, CCRRR)
-	_MAKE_SINK_ID (0x040000, CCRRV)
-
-	_MAKE_SINK_ID (0x110000, MP4)
-	_MAKE_SINK_ID (0x120000, AVI)
-	_MAKE_SINK_ID (0x130000, AFW)
-
-	// define media frame module ID
-	_MAKE_MFW_ID (0x010000, VOMMPLAY)
-	_MAKE_MFW_ID (0x020000, VOMMREC)
-	_MAKE_MFW_ID (0x030000, VOME)
-};
-
-
-/* define the error ID */
-#define VO_ERR_NONE						0x00000000
-#define VO_ERR_FINISH					0x00000001
-#define VO_ERR_BASE						0X80000000
-#define VO_ERR_FAILED					0x80000001
-#define VO_ERR_OUTOF_MEMORY				0x80000002
-#define VO_ERR_NOT_IMPLEMENT			0x80000003
-#define VO_ERR_INVALID_ARG				0x80000004
-#define VO_ERR_INPUT_BUFFER_SMALL		0x80000005
-#define VO_ERR_OUTPUT_BUFFER_SMALL		0x80000006
-#define VO_ERR_WRONG_STATUS				0x80000007
-#define VO_ERR_WRONG_PARAM_ID			0x80000008
-#define VO_ERR_LICENSE_ERROR			0x80000009
-
-/* xxx is the module ID
-#define VO_ERR_FAILED					0x8xxx0001
-#define VO_ERR_OUTOF_MEMORY				0x8xxx0002
-#define VO_ERR_NOT_IMPLEMENT			0x8xxx0003
-#define VO_ERR_INVALID_ARG				0x8xxx0004
-#define VO_ERR_INPUT_BUFFER_SMALL		0x8xxx0005
-#define VO_ERR_OUTPUT_BUFFER_SMALL		0x8xxx0006
-#define VO_ERR_WRONG_STATUS				0x8xxx0007
-#define VO_ERR_WRONG_PARAM_ID			0x8xxx0008
-#define VO_ERR_LICENSE_ERROR			0x8xxx0009
-// Module own error ID
-#define VO_ERR_Module					0x8xxx0X00
-*/
- 
-#define	VO_PID_COMMON_BASE				 0x40000000						/*!< The base of common param ID */
-#define	VO_PID_COMMON_QUERYMEM			(VO_PID_COMMON_BASE | 0X0001)	/*!< Query the memory needed; Reserved. */
-#define	VO_PID_COMMON_INPUTTYPE			(VO_PID_COMMON_BASE | 0X0002)	/*!< Set or get the input buffer type. VO_INPUT_TYPE */
-#define	VO_PID_COMMON_HASRESOURCE		(VO_PID_COMMON_BASE | 0X0003)	/*!< Query it has resource to be used. VO_U32 *, 1 have, 0 No */
-#define	VO_PID_COMMON_HEADDATA			(VO_PID_COMMON_BASE | 0X0004)	/*!< Decoder track header data. VO_CODECBUFFER * */
-#define	VO_PID_COMMON_FLUSH				(VO_PID_COMMON_BASE | 0X0005)	/*!< Flush the codec buffer. VO_U32 *, 1 Flush, 0 No * */
-
-/*
-// Module Param ID
-#define VO_ID_Mdoule					0x0xxx1000
-*/
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif // __voIndex_H__
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		voIndex.h
+
+	Content:	module and ID definition
+
+*******************************************************************************/
+
+#ifndef __voIndex_H__
+#define __voIndex_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include "voType.h"
+
+/* Define the module ID */
+#define _MAKE_SOURCE_ID(id, name) \
+VO_INDEX_SRC_##name = _VO_INDEX_SOURCE | id,
+
+#define _MAKE_CODEC_ID(id, name) \
+VO_INDEX_DEC_##name = _VO_INDEX_DEC | id, \
+VO_INDEX_ENC_##name = _VO_INDEX_ENC | id,
+
+#define _MAKE_EFFECT_ID(id, name) \
+VO_INDEX_EFT_##name = _VO_INDEX_EFFECT | id,
+
+#define _MAKE_SINK_ID(id, name) \
+VO_INDEX_SNK_##name = _VO_INDEX_SINK | id,
+
+#define _MAKE_FILTER_ID(id, name) \
+VO_INDEX_FLT_##name = _VO_INDEX_FILTER | id,
+
+#define _MAKE_OMX_ID(id, name) \
+VO_INDEX_OMX_##name = _VO_INDEX_OMX | id,
+
+#define _MAKE_MFW_ID(id, name) \
+VO_INDEX_MFW_##name = _VO_INDEX_MFW | id,
+
+enum
+{
+	_VO_INDEX_SOURCE		= 0x01000000,
+	_VO_INDEX_DEC			= 0x02000000,
+	_VO_INDEX_ENC			= 0x03000000,
+	_VO_INDEX_EFFECT		= 0x04000000,
+	_VO_INDEX_SINK			= 0x05000000,
+	_VO_INDEX_FILTER		= 0x06000000,
+	_VO_INDEX_OMX			= 0x07000000,
+	_VO_INDEX_MFW			= 0x08000000,
+
+	// define file parser modules
+	_MAKE_SOURCE_ID (0x010000, MP4)
+	_MAKE_SOURCE_ID (0x020000, AVI)
+	_MAKE_SOURCE_ID (0x030000, ASF)
+	_MAKE_SOURCE_ID (0x040000, REAL)
+	_MAKE_SOURCE_ID (0x050000, AUDIO)
+	_MAKE_SOURCE_ID (0x060000, FLASH)
+	_MAKE_SOURCE_ID (0x070000, OGG)
+	_MAKE_SOURCE_ID (0x080000, MKV)
+
+	// define network source modules
+	_MAKE_SOURCE_ID (0x110000, RTSP)
+	_MAKE_SOURCE_ID (0x120000, HTTP)
+
+	// define CMMB source modules
+	_MAKE_SOURCE_ID (0x200000, CMMB)
+	_MAKE_SOURCE_ID (0x210000, CMMB_INNO)
+	_MAKE_SOURCE_ID (0x220000, CMMB_TELE)
+	_MAKE_SOURCE_ID (0x230000, CMMB_SIANO)
+
+	// define DVBT source modules
+	_MAKE_SOURCE_ID (0x300000, DVBT)
+	_MAKE_SOURCE_ID (0x310000, DVBT_DIBCOM)
+
+	// define other source modules
+	_MAKE_SOURCE_ID (0x400000, ID3)
+
+	// define video codec modules
+	_MAKE_CODEC_ID (0x010000, H264)
+	_MAKE_CODEC_ID (0x020000, MPEG4)
+	_MAKE_CODEC_ID (0x030000, H263)
+	_MAKE_CODEC_ID (0x040000, S263)
+	_MAKE_CODEC_ID (0x050000, RV)
+	_MAKE_CODEC_ID (0x060000, WMV)
+	_MAKE_CODEC_ID (0x070000, DIVX3)
+	_MAKE_CODEC_ID (0x080000, MJPEG)
+	_MAKE_CODEC_ID (0x090000, MPEG2)
+	_MAKE_CODEC_ID (0x0A0000, VP6)
+
+	// define audio codec modules
+	_MAKE_CODEC_ID (0x210000, AAC)
+	_MAKE_CODEC_ID (0x220000, MP3)
+	_MAKE_CODEC_ID (0x230000, WMA)
+	_MAKE_CODEC_ID (0x240000, RA)
+	_MAKE_CODEC_ID (0x250000, AMRNB)
+	_MAKE_CODEC_ID (0x260000, AMRWB)
+	_MAKE_CODEC_ID (0x270000, AMRWBP)
+	_MAKE_CODEC_ID (0x280000, QCELP)
+	_MAKE_CODEC_ID (0x290000, EVRC)
+	_MAKE_CODEC_ID (0x2A0000, ADPCM)
+	_MAKE_CODEC_ID (0x2B0000, MIDI)
+	_MAKE_CODEC_ID (0x2C0000, AC3)
+	_MAKE_CODEC_ID (0x2D0000, FLAC)
+	_MAKE_CODEC_ID (0x2E0000, DRA)
+	_MAKE_CODEC_ID (0x2F0000, OGG)
+	_MAKE_CODEC_ID (0x300000, G729)
+
+	// define image codec modules
+	_MAKE_CODEC_ID (0x410000, JPEG)
+	_MAKE_CODEC_ID (0x420000, GIF)
+	_MAKE_CODEC_ID (0x430000, PNG)
+	_MAKE_CODEC_ID (0x440000, TIF)
+
+	// define effect modules
+	_MAKE_EFFECT_ID (0x010000, EQ)
+
+	// define sink modules
+	_MAKE_SINK_ID (0x010000, VIDEO)
+	_MAKE_SINK_ID (0x020000, AUDIO)
+	_MAKE_SINK_ID (0x030000, CCRRR)
+	_MAKE_SINK_ID (0x040000, CCRRV)
+
+	_MAKE_SINK_ID (0x110000, MP4)
+	_MAKE_SINK_ID (0x120000, AVI)
+	_MAKE_SINK_ID (0x130000, AFW)
+
+	// define media frame module ID
+	_MAKE_MFW_ID (0x010000, VOMMPLAY)
+	_MAKE_MFW_ID (0x020000, VOMMREC)
+	_MAKE_MFW_ID (0x030000, VOME)
+};
+
+
+/* define the error ID */
+#define VO_ERR_NONE						0x00000000
+#define VO_ERR_FINISH					0x00000001
+#define VO_ERR_BASE						0X80000000
+#define VO_ERR_FAILED					0x80000001
+#define VO_ERR_OUTOF_MEMORY				0x80000002
+#define VO_ERR_NOT_IMPLEMENT			0x80000003
+#define VO_ERR_INVALID_ARG				0x80000004
+#define VO_ERR_INPUT_BUFFER_SMALL		0x80000005
+#define VO_ERR_OUTPUT_BUFFER_SMALL		0x80000006
+#define VO_ERR_WRONG_STATUS				0x80000007
+#define VO_ERR_WRONG_PARAM_ID			0x80000008
+#define VO_ERR_LICENSE_ERROR			0x80000009
+
+/* xxx is the module ID
+#define VO_ERR_FAILED					0x8xxx0001
+#define VO_ERR_OUTOF_MEMORY				0x8xxx0002
+#define VO_ERR_NOT_IMPLEMENT			0x8xxx0003
+#define VO_ERR_INVALID_ARG				0x8xxx0004
+#define VO_ERR_INPUT_BUFFER_SMALL		0x8xxx0005
+#define VO_ERR_OUTPUT_BUFFER_SMALL		0x8xxx0006
+#define VO_ERR_WRONG_STATUS				0x8xxx0007
+#define VO_ERR_WRONG_PARAM_ID			0x8xxx0008
+#define VO_ERR_LICENSE_ERROR			0x8xxx0009
+// Module own error ID
+#define VO_ERR_Module					0x8xxx0X00
+*/
+
+#define	VO_PID_COMMON_BASE				 0x40000000						/*!< The base of common param ID */
+#define	VO_PID_COMMON_QUERYMEM			(VO_PID_COMMON_BASE | 0X0001)	/*!< Query the memory needed; Reserved. */
+#define	VO_PID_COMMON_INPUTTYPE			(VO_PID_COMMON_BASE | 0X0002)	/*!< Set or get the input buffer type. VO_INPUT_TYPE */
+#define	VO_PID_COMMON_HASRESOURCE		(VO_PID_COMMON_BASE | 0X0003)	/*!< Query it has resource to be used. VO_U32 *, 1 have, 0 No */
+#define	VO_PID_COMMON_HEADDATA			(VO_PID_COMMON_BASE | 0X0004)	/*!< Decoder track header data. VO_CODECBUFFER * */
+#define	VO_PID_COMMON_FLUSH				(VO_PID_COMMON_BASE | 0X0005)	/*!< Flush the codec buffer. VO_U32 *, 1 Flush, 0 No * */
+
+/*
+// Module Param ID
+#define VO_ID_Mdoule					0x0xxx1000
+*/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif // __voIndex_H__
diff --git a/media/libstagefright/codecs/common/include/voType.h b/media/libstagefright/codecs/common/include/voType.h
index 2669134..5f659ab 100644
--- a/media/libstagefright/codecs/common/include/voType.h
+++ b/media/libstagefright/codecs/common/include/voType.h
@@ -1,221 +1,221 @@
-/*
- ** Copyright 2003-2010, VisualOn, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **     http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License.
- */
-/*******************************************************************************
-	File:		voType.h
-
-	Content:	data type definition
-
-*******************************************************************************/
-#ifndef __voType_H__
-#define __voType_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#ifdef _WIN32
-#	define VO_API __cdecl
-#	define VO_CBI __stdcall
-#else
-#	define VO_API
-#	define VO_CBI
-#endif //_WIN32
-
-/** VO_IN is used to identify inputs to an VO function.  This designation
-    will also be used in the case of a pointer that points to a parameter
-    that is used as an output. */
-#ifndef VO_IN
-#define VO_IN
-#endif
-
-/** VO_OUT is used to identify outputs from an VO function.  This
-    designation will also be used in the case of a pointer that points
-    to a parameter that is used as an input. */
-#ifndef VO_OUT
-#define VO_OUT
-#endif
-
-/** VO_INOUT is used to identify parameters that may be either inputs or
-    outputs from an VO function at the same time.  This designation will
-    also be used in the case of a pointer that  points to a parameter that
-    is used both as an input and an output. */
-#ifndef VO_INOUT
-#define VO_INOUT
-#endif
-
-#define VO_MAX_ENUM_VALUE	0X7FFFFFFF
-
-/** VO_VOID */
-typedef void VO_VOID;
-
-/** VO_U8 is an 8 bit unsigned quantity that is byte aligned */
-typedef unsigned char VO_U8;
-
-/** VO_BYTE is an 8 bit unsigned quantity that is byte aligned */
-typedef unsigned char VO_BYTE;
-
-/** VO_S8 is an 8 bit signed quantity that is byte aligned */
-typedef signed char VO_S8;
-
-/** VO_CHAR is an 8 bit signed quantity that is byte aligned */
-typedef char VO_CHAR;
-
-/** VO_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
-typedef unsigned short VO_U16;
-
-/** VO_WCHAR is a 16 bit unsigned quantity that is 16 bit word aligned */
-#if defined _WIN32
-typedef unsigned short VO_WCHAR;
-typedef unsigned short* VO_PWCHAR;
-#elif defined LINUX
-typedef unsigned char VO_WCHAR;
-typedef unsigned char* VO_PWCHAR;
-#endif
-
-/** VO_S16 is a 16 bit signed quantity that is 16 bit word aligned */
-typedef signed short VO_S16;
-
-/** VO_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
-typedef unsigned long VO_U32;
-
-/** VO_S32 is a 32 bit signed quantity that is 32 bit word aligned */
-typedef signed long VO_S32;
-
-/* Users with compilers that cannot accept the "long long" designation should
-   define the VO_SKIP64BIT macro.  It should be noted that this may cause
-   some components to fail to compile if the component was written to require
-   64 bit integral types.  However, these components would NOT compile anyway
-   since the compiler does not support the way the component was written.
-*/
-#ifndef VO_SKIP64BIT
-#ifdef _WIN32
-/** VO_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned __int64  VO_U64;
-/** VO_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed   __int64  VO_S64;
-#else // WIN32
-/** VO_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
-typedef unsigned long long VO_U64;
-/** VO_S64 is a 64 bit signed quantity that is 64 bit word aligned */
-typedef signed long long VO_S64;
-#endif // WIN32
-#endif // VO_SKIP64BIT
-
-/** The VO_BOOL type is intended to be used to represent a true or a false
-    value when passing parameters to and from the VO core and components.  The
-    VO_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
- */
-typedef enum VO_BOOL {
-    VO_FALSE = 0,
-    VO_TRUE = !VO_FALSE,
-	VO_BOOL_MAX = VO_MAX_ENUM_VALUE
-} VO_BOOL;
-
-/** The VO_PTR type is intended to be used to pass pointers between the VO
-    applications and the VO Core and components.  This is a 32 bit pointer and
-    is aligned on a 32 bit boundary.
- */
-typedef void* VO_PTR;
-
-/** The VO_HANDLE type is intended to be used to pass pointers between the VO
-    applications and the VO Core and components.  This is a 32 bit pointer and
-    is aligned on a 32 bit boundary.
- */
-typedef void* VO_HANDLE;
-
-/** The VO_STRING type is intended to be used to pass "C" type strings between
-    the application and the core and component.  The VO_STRING type is a 32
-    bit pointer to a zero terminated string.  The  pointer is word aligned and
-    the string is byte aligned.
- */
-typedef char* VO_PCHAR;
-
-/** The VO_PBYTE type is intended to be used to pass arrays of bytes such as
-    buffers between the application and the component and core.  The VO_PBYTE
-    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
-    aligned and the string is byte aligned.
- */
-typedef unsigned char* VO_PBYTE;
-
-/** The VO_PTCHAR type is intended to be used to pass arrays of wchar such as
-    unicode char between the application and the component and core.  The VO_PTCHAR
-    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
-    aligned and the string is byte aligned.
- */
-/*
-#if !defined LINUX
-typedef unsigned short* VO_PTCHAR;
-typedef unsigned short* VO_TCHAR;
-#else
-typedef char* VO_PTCHAR;
-typedef char VO_TCHAR;
-#endif
-*/
-
-#ifndef NULL
-#ifdef __cplusplus
-#define NULL    0
-#else
-#define NULL    ((void *)0)
-#endif
-#endif
-
-/**
- * Input stream format, Frame or Stream..
- */
-typedef enum {
-    VO_INPUT_FRAME	= 1,	/*!< Input contains completely frame(s) data. */
-    VO_INPUT_STREAM,		/*!< Input is stream data. */
-	VO_INPUT_STREAM_MAX = VO_MAX_ENUM_VALUE
-} VO_INPUT_TYPE;
-
-
-/**
- * General data buffer, used as input or output.
- */
-typedef struct {
-	VO_PBYTE	Buffer;		/*!< Buffer pointer */
-	VO_U32		Length;		/*!< Buffer size in byte */
-	VO_S64		Time;		/*!< The time of the buffer */
-} VO_CODECBUFFER;
-
-
-/**
- * The init memdata flag.
- */
-typedef enum{
-	VO_IMF_USERMEMOPERATOR		=0,	/*!< memData is  the pointer of memoperator function*/
-	VO_IMF_PREALLOCATEDBUFFER	=1,	/*!< memData is  preallocated memory*/
-	VO_IMF_MAX = VO_MAX_ENUM_VALUE
-}VO_INIT_MEM_FlAG;
-
-
-/**
- * The init memory structure..
- */
-typedef struct{
-	VO_INIT_MEM_FlAG			memflag;	/*!<memory flag  */
-	VO_PTR						memData;	/*!<a pointer to VO_MEM_OPERATOR or a preallocated buffer  */
-	VO_U32						reserved1;	/*!<reserved  */
-	VO_U32						reserved2;	/*!<reserved */
-}VO_CODEC_INIT_USERDATA;
-
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif // __voType_H__
+/*
+ ** Copyright 2003-2010, VisualOn, Inc.
+ **
+ ** Licensed under the Apache License, Version 2.0 (the "License");
+ ** you may not use this file except in compliance with the License.
+ ** You may obtain a copy of the License at
+ **
+ **     http://www.apache.org/licenses/LICENSE-2.0
+ **
+ ** Unless required by applicable law or agreed to in writing, software
+ ** distributed under the License is distributed on an "AS IS" BASIS,
+ ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ ** See the License for the specific language governing permissions and
+ ** limitations under the License.
+ */
+/*******************************************************************************
+	File:		voType.h
+
+	Content:	data type definition
+
+*******************************************************************************/
+#ifndef __voType_H__
+#define __voType_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifdef _WIN32
+#	define VO_API __cdecl
+#	define VO_CBI __stdcall
+#else
+#	define VO_API
+#	define VO_CBI
+#endif //_WIN32
+
+/** VO_IN is used to identify inputs to an VO function.  This designation
+    will also be used in the case of a pointer that points to a parameter
+    that is used as an output. */
+#ifndef VO_IN
+#define VO_IN
+#endif
+
+/** VO_OUT is used to identify outputs from an VO function.  This
+    designation will also be used in the case of a pointer that points
+    to a parameter that is used as an input. */
+#ifndef VO_OUT
+#define VO_OUT
+#endif
+
+/** VO_INOUT is used to identify parameters that may be either inputs or
+    outputs from an VO function at the same time.  This designation will
+    also be used in the case of a pointer that  points to a parameter that
+    is used both as an input and an output. */
+#ifndef VO_INOUT
+#define VO_INOUT
+#endif
+
+#define VO_MAX_ENUM_VALUE	0X7FFFFFFF
+
+/** VO_VOID */
+typedef void VO_VOID;
+
+/** VO_U8 is an 8 bit unsigned quantity that is byte aligned */
+typedef unsigned char VO_U8;
+
+/** VO_BYTE is an 8 bit unsigned quantity that is byte aligned */
+typedef unsigned char VO_BYTE;
+
+/** VO_S8 is an 8 bit signed quantity that is byte aligned */
+typedef signed char VO_S8;
+
+/** VO_CHAR is an 8 bit signed quantity that is byte aligned */
+typedef char VO_CHAR;
+
+/** VO_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
+typedef unsigned short VO_U16;
+
+/** VO_WCHAR is a 16 bit unsigned quantity that is 16 bit word aligned */
+#if defined _WIN32
+typedef unsigned short VO_WCHAR;
+typedef unsigned short* VO_PWCHAR;
+#elif defined LINUX
+typedef unsigned char VO_WCHAR;
+typedef unsigned char* VO_PWCHAR;
+#endif
+
+/** VO_S16 is a 16 bit signed quantity that is 16 bit word aligned */
+typedef signed short VO_S16;
+
+/** VO_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
+typedef unsigned long VO_U32;
+
+/** VO_S32 is a 32 bit signed quantity that is 32 bit word aligned */
+typedef signed long VO_S32;
+
+/* Users with compilers that cannot accept the "long long" designation should
+   define the VO_SKIP64BIT macro.  It should be noted that this may cause
+   some components to fail to compile if the component was written to require
+   64 bit integral types.  However, these components would NOT compile anyway
+   since the compiler does not support the way the component was written.
+*/
+#ifndef VO_SKIP64BIT
+#ifdef _MSC_VER
+/** VO_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned __int64  VO_U64;
+/** VO_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed   __int64  VO_S64;
+#else // WIN32
+/** VO_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long VO_U64;
+/** VO_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long VO_S64;
+#endif // WIN32
+#endif // VO_SKIP64BIT
+
+/** The VO_BOOL type is intended to be used to represent a true or a false
+    value when passing parameters to and from the VO core and components.  The
+    VO_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
+ */
+typedef enum VO_BOOL {
+    VO_FALSE = 0,
+    VO_TRUE = !VO_FALSE,
+	VO_BOOL_MAX = VO_MAX_ENUM_VALUE
+} VO_BOOL;
+
+/** The VO_PTR type is intended to be used to pass pointers between the VO
+    applications and the VO Core and components.  This is a 32 bit pointer and
+    is aligned on a 32 bit boundary.
+ */
+typedef void* VO_PTR;
+
+/** The VO_HANDLE type is intended to be used to pass pointers between the VO
+    applications and the VO Core and components.  This is a 32 bit pointer and
+    is aligned on a 32 bit boundary.
+ */
+typedef void* VO_HANDLE;
+
+/** The VO_STRING type is intended to be used to pass "C" type strings between
+    the application and the core and component.  The VO_STRING type is a 32
+    bit pointer to a zero terminated string.  The  pointer is word aligned and
+    the string is byte aligned.
+ */
+typedef char* VO_PCHAR;
+
+/** The VO_PBYTE type is intended to be used to pass arrays of bytes such as
+    buffers between the application and the component and core.  The VO_PBYTE
+    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
+    aligned and the string is byte aligned.
+ */
+typedef unsigned char* VO_PBYTE;
+
+/** The VO_PTCHAR type is intended to be used to pass arrays of wchar such as
+    unicode char between the application and the component and core.  The VO_PTCHAR
+    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
+    aligned and the string is byte aligned.
+ */
+/*
+#if !defined LINUX
+typedef unsigned short* VO_PTCHAR;
+typedef unsigned short* VO_TCHAR;
+#else
+typedef char* VO_PTCHAR;
+typedef char VO_TCHAR;
+#endif
+*/
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL    0
+#else
+#define NULL    ((void *)0)
+#endif
+#endif
+
+/**
+ * Input stream format, Frame or Stream..
+ */
+typedef enum {
+    VO_INPUT_FRAME	= 1,	/*!< Input contains completely frame(s) data. */
+    VO_INPUT_STREAM,		/*!< Input is stream data. */
+	VO_INPUT_STREAM_MAX = VO_MAX_ENUM_VALUE
+} VO_INPUT_TYPE;
+
+
+/**
+ * General data buffer, used as input or output.
+ */
+typedef struct {
+	VO_PBYTE	Buffer;		/*!< Buffer pointer */
+	VO_U32		Length;		/*!< Buffer size in byte */
+	VO_S64		Time;		/*!< The time of the buffer */
+} VO_CODECBUFFER;
+
+
+/**
+ * The init memdata flag.
+ */
+typedef enum{
+	VO_IMF_USERMEMOPERATOR		=0,	/*!< memData is  the pointer of memoperator function*/
+	VO_IMF_PREALLOCATEDBUFFER	=1,	/*!< memData is  preallocated memory*/
+	VO_IMF_MAX = VO_MAX_ENUM_VALUE
+}VO_INIT_MEM_FlAG;
+
+
+/**
+ * The init memory structure..
+ */
+typedef struct{
+	VO_INIT_MEM_FlAG			memflag;	/*!<memory flag  */
+	VO_PTR						memData;	/*!<a pointer to VO_MEM_OPERATOR or a preallocated buffer  */
+	VO_U32						reserved1;	/*!<reserved  */
+	VO_U32						reserved2;	/*!<reserved */
+}VO_CODEC_INIT_USERDATA;
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif // __voType_H__
diff --git a/media/libstagefright/codecs/m4v_h263/dec/Android.mk b/media/libstagefright/codecs/m4v_h263/dec/Android.mk
index 2d9bcc6..a7c483b 100644
--- a/media/libstagefright/codecs/m4v_h263/dec/Android.mk
+++ b/media/libstagefright/codecs/m4v_h263/dec/Android.mk
@@ -47,4 +47,8 @@ LOCAL_C_INCLUDES := \
 
 LOCAL_CFLAGS := -DOSCL_EXPORT_REF= -DOSCL_IMPORT_REF=
 
+ifeq ($(TARGET_SF_NEEDS_REAL_DIMENSIONS),true)
+        LOCAL_CFLAGS += -DTARGET_SF_NEEDS_REAL_DIMENSIONS
+endif
+
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/codecs/m4v_h263/dec/M4vH263Decoder.cpp b/media/libstagefright/codecs/m4v_h263/dec/M4vH263Decoder.cpp
index dcf129e..2ebf80f 100644
--- a/media/libstagefright/codecs/m4v_h263/dec/M4vH263Decoder.cpp
+++ b/media/libstagefright/codecs/m4v_h263/dec/M4vH263Decoder.cpp
@@ -45,15 +45,17 @@ M4vH263Decoder::M4vH263Decoder(const sp<MediaSource> &source)
     mFormat = new MetaData;
     mFormat->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_RAW);
 
-    // CHECK(mSource->getFormat()->findInt32(kKeyWidth, &mWidth));
-    // CHECK(mSource->getFormat()->findInt32(kKeyHeight, &mHeight));
-
+#ifdef TARGET_SF_NEEDS_REAL_DIMENSIONS
+    CHECK(mSource->getFormat()->findInt32(kKeyWidth, &mWidth));
+    CHECK(mSource->getFormat()->findInt32(kKeyHeight, &mHeight));
+#else
     // We'll ignore the dimension advertised by the source, the decoder
     // appears to require us to always start with the default dimensions
     // of 352 x 288 to operate correctly and later react to changes in
     // the dimensions as needed.
     mWidth = 352;
     mHeight = 288;
+#endif
 
     mFormat->setInt32(kKeyWidth, mWidth);
     mFormat->setInt32(kKeyHeight, mHeight);
diff --git a/media/libstagefright/codecs/mp3dec/Android.mk b/media/libstagefright/codecs/mp3dec/Android.mk
index fb56a93..bd11766 100644
--- a/media/libstagefright/codecs/mp3dec/Android.mk
+++ b/media/libstagefright/codecs/mp3dec/Android.mk
@@ -48,6 +48,11 @@ LOCAL_C_INCLUDES := \
         $(LOCAL_PATH)/src \
         $(LOCAL_PATH)/include
 
+ifeq ($(OMAP_ENHANCEMENT),true)
+    LOCAL_C_INCLUDES += hardware/ti/omx/ducati/domx/system/omx_core/inc/
+endif
+
+
 LOCAL_CFLAGS := \
         -DOSCL_UNUSED_ARG=
 
diff --git a/media/libstagefright/codecs/mp3dec/MP3Decoder.cpp b/media/libstagefright/codecs/mp3dec/MP3Decoder.cpp
index 59dd740..f53ff10 100644
--- a/media/libstagefright/codecs/mp3dec/MP3Decoder.cpp
+++ b/media/libstagefright/codecs/mp3dec/MP3Decoder.cpp
@@ -22,9 +22,183 @@
 #include <media/stagefright/MediaDebug.h>
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MetaData.h>
+#include <media/stagefright/Utils.h>
 
 namespace android {
 
+// Everything must match except for
+// protection, bitrate, padding, private bits, mode extension,
+// copyright bit, original bit and emphasis.
+// Yes ... there are things that must indeed match...
+static const uint32_t kMask = 0xfffe0cc0;
+
+static bool get_mp3_frame_size(
+        uint32_t header, size_t *frame_size,
+        int *out_sampling_rate = NULL, int *out_channels = NULL,
+        int *out_bitrate = NULL) {
+    *frame_size = 0;
+
+    if (out_sampling_rate) {
+        *out_sampling_rate = 0;
+    }
+
+    if (out_channels) {
+        *out_channels = 0;
+    }
+
+    if (out_bitrate) {
+        *out_bitrate = 0;
+    }
+
+    if ((header & 0xffe00000) != 0xffe00000) {
+        return false;
+    }
+
+    unsigned version = (header >> 19) & 3;
+
+    if (version == 0x01) {
+        return false;
+    }
+
+    unsigned layer = (header >> 17) & 3;
+
+    if (layer == 0x00) {
+        return false;
+    }
+
+    unsigned protection = (header >> 16) & 1;
+
+    unsigned bitrate_index = (header >> 12) & 0x0f;
+
+    if (bitrate_index == 0 || bitrate_index == 0x0f) {
+        // Disallow "free" bitrate.
+        return false;
+    }
+
+    unsigned sampling_rate_index = (header >> 10) & 3;
+
+    if (sampling_rate_index == 3) {
+        return false;
+    }
+
+    static const int kSamplingRateV1[] = { 44100, 48000, 32000 };
+    int sampling_rate = kSamplingRateV1[sampling_rate_index];
+    if (version == 2 /* V2 */) {
+        sampling_rate /= 2;
+    } else if (version == 0 /* V2.5 */) {
+        sampling_rate /= 4;
+    }
+
+    unsigned padding = (header >> 9) & 1;
+
+    if (layer == 3) {
+        // layer I
+
+        static const int kBitrateV1[] = {
+            32, 64, 96, 128, 160, 192, 224, 256,
+            288, 320, 352, 384, 416, 448
+        };
+
+        static const int kBitrateV2[] = {
+            32, 48, 56, 64, 80, 96, 112, 128,
+            144, 160, 176, 192, 224, 256
+        };
+
+        int bitrate =
+            (version == 3 /* V1 */)
+                ? kBitrateV1[bitrate_index - 1]
+                : kBitrateV2[bitrate_index - 1];
+
+        if (out_bitrate) {
+            *out_bitrate = bitrate;
+        }
+
+        *frame_size = (12000 * bitrate / sampling_rate + padding) * 4;
+    } else {
+        // layer II or III
+
+        static const int kBitrateV1L2[] = {
+            32, 48, 56, 64, 80, 96, 112, 128,
+            160, 192, 224, 256, 320, 384
+        };
+
+        static const int kBitrateV1L3[] = {
+            32, 40, 48, 56, 64, 80, 96, 112,
+            128, 160, 192, 224, 256, 320
+        };
+
+        static const int kBitrateV2[] = {
+            8, 16, 24, 32, 40, 48, 56, 64,
+            80, 96, 112, 128, 144, 160
+        };
+
+        int bitrate;
+        if (version == 3 /* V1 */) {
+            bitrate = (layer == 2 /* L2 */)
+                ? kBitrateV1L2[bitrate_index - 1]
+                : kBitrateV1L3[bitrate_index - 1];
+        } else {
+            // V2 (or 2.5)
+
+            bitrate = kBitrateV2[bitrate_index - 1];
+        }
+
+        if (out_bitrate) {
+            *out_bitrate = bitrate;
+        }
+
+        if (version == 3 /* V1 */) {
+            *frame_size = 144000 * bitrate / sampling_rate + padding;
+        } else {
+            // V2 or V2.5
+            *frame_size = 72000 * bitrate / sampling_rate + padding;
+        }
+    }
+
+    if (out_sampling_rate) {
+        *out_sampling_rate = sampling_rate;
+    }
+
+    if (out_channels) {
+        int channel_mode = (header >> 6) & 3;
+
+        *out_channels = (channel_mode == 3) ? 1 : 2;
+    }
+
+    return true;
+}
+
+static bool resync(
+        uint8_t *data, uint32_t size, uint32_t match_header, off_t *out_pos) {
+
+    bool valid = false;
+    off_t pos = 0;
+    *out_pos = 0;
+    do {
+        if (pos + 4 > size) {
+            // Don't scan forever.
+            LOGV("no dice, no valid sequence of frames found.");
+            break;
+        }
+
+        uint32_t header = U32_AT(data + pos);
+
+        if (match_header != 0 && (header & kMask) != (match_header & kMask)) {
+            ++pos;
+            continue;
+        }
+
+        LOGV("found possible frame at %ld (header = 0x%08x)", pos, header);
+
+        // We found what looks like a valid frame,
+        valid = true;
+        *out_pos = pos;
+    } while (!valid);
+
+    return valid;
+}
+
+
 MP3Decoder::MP3Decoder(const sp<MediaSource> &source)
     : mSource(source),
       mNumChannels(0),
@@ -34,7 +208,9 @@ MP3Decoder::MP3Decoder(const sp<MediaSource> &source)
       mDecoderBuf(NULL),
       mAnchorTimeUs(0),
       mNumFramesOutput(0),
-      mInputBuffer(NULL) {
+      mInputBuffer(NULL),
+      mPartialBuffer(NULL),
+      mFixedHeader(0) {
     init();
 }
 
@@ -115,11 +291,120 @@ sp<MetaData> MP3Decoder::getFormat() {
     return mMeta;
 }
 
+status_t MP3Decoder::updatePartialFrame() {
+    status_t err = OK;
+    if (mPartialBuffer == NULL) {
+        return err;
+    }
+
+    size_t frameSize = 0;
+    uint32_t partialBufLen = mPartialBuffer->range_length();
+    uint32_t inputBufLen = mInputBuffer->range_length();
+    uint8_t frameHeader[4];
+    uint8_t *frmHdr;
+    uint32_t header;
+
+
+    // Look at the frame size and complete the partial frame
+    // Also check if a vaild header is found after the partial frame
+    if (partialBufLen < 4) { // check if partial frame has the 4 bytes header
+        if (inputBufLen < (4 - partialBufLen)) {
+            // input buffer does not have the frame header bytes
+            // bail out TODO
+            LOGE("MP3Decoder::updatePartialFrame buffer to small header not found"
+                 " partial buffer len %d, input buffer len %d",
+                 partialBufLen, inputBufLen);
+            //mPartialBuffer->release();
+            //mPartialBuffer = NULL;
+            return UNKNOWN_ERROR;
+        }
+
+        // copy the header bytes to frameHeader
+        memcpy (frameHeader, mPartialBuffer->data(), partialBufLen);
+        memcpy (frameHeader + partialBufLen, mInputBuffer->data(), (4 - partialBufLen));
+        // get the first 4 bytes of the buffer
+        header = U32_AT((uint8_t *)frameHeader);
+        frmHdr = frameHeader;
+    } else {
+        frmHdr = (uint8_t *)mPartialBuffer->data();
+    }
+
+    // check if its a good frame, and the frame size
+    // get the first 4 bytes of the buffer
+    header = U32_AT(frmHdr);
+    bool curFrame = get_mp3_frame_size(header,&frameSize);
+    if (!curFrame) {
+        LOGE("MP3Decoder::read - partial frame does not have a vaild header 0x%x",
+             header);
+        return UNKNOWN_ERROR;
+    }
+
+    // check if the following frame is good
+    uint32_t nextFrameOffset = frameSize - partialBufLen;
+    if ((nextFrameOffset + 4) <= inputBufLen) {
+        header = U32_AT((uint8_t *)mInputBuffer->data() + nextFrameOffset);
+        if ((header & 0xffe00000) != 0xffe00000) {
+            // next frame does not have a valid header,
+            // this may not be the next buffer, bail out.
+            LOGE("MP3Decoder::read - next frame does not have a vaild header 0x%x",
+                 header);
+            return UNKNOWN_ERROR;
+        }
+    } else {
+        // next frame header is out of range
+        // assume good header for now
+        LOGE("MP3Decoder::read - assuming next frame is good");
+    }
+
+    // check if the input buffer has the remaining partial frame
+    if (frameSize > (partialBufLen + inputBufLen)) {
+        // input buffer does not have the remaining partial frame,
+        // discard data here as frame split in 3 buffers not supported
+        LOGE("MP3Decoder::updatePartialFrame - input buffer does not have the complete frame."
+             " frame size %d, saved partial buffer len %d,"
+             " input buffer len %d", frameSize, partialBufLen, inputBufLen);
+        return UNKNOWN_ERROR;
+    }
+
+    // check if the mPartialBuffer can fit the remaining frame
+    if ((mPartialBuffer->size() - partialBufLen) < (frameSize - partialBufLen)) {
+        // mPartialBuffer is small to hold the reaming frame
+        //TODO
+        LOGE("MP3Decoder::updatePartialFrame - mPartialBuffer is small, size %d, required &d",
+             (mPartialBuffer->size() - partialBufLen), (frameSize - partialBufLen));
+        return UNKNOWN_ERROR;
+    }
+
+    // done with error checks
+    // copy the partial frames to from a complete frame
+    // Copy the remaining frame from input buffer
+    uint32_t bytesRemaining = frameSize - mPartialBuffer->range_length();
+    memcpy ((uint8_t *)mPartialBuffer->data() + mPartialBuffer->range_length(),
+            (uint8_t *)mInputBuffer->data() + mInputBuffer->range_offset(),
+            bytesRemaining);
+
+    // mark the bytes as consumed from input buffer
+    mInputBuffer->set_range(
+                           mInputBuffer->range_offset() + bytesRemaining,
+                           mInputBuffer->range_length() - bytesRemaining);
+
+    // set the range and length of mPartialBuffer
+    mPartialBuffer->set_range(0,
+                              mPartialBuffer->range_length() + bytesRemaining);
+
+    LOGE("MP3Decoder::updatePartialFrame - copied the partial frame %d, input buffer length %d",
+         bytesRemaining, mInputBuffer->range_length());
+
+    return err;
+}
+
 status_t MP3Decoder::read(
         MediaBuffer **out, const ReadOptions *options) {
     status_t err;
 
     *out = NULL;
+    bool usedPartialFrame = false;
+    bool seekSource = false;
 
     int64_t seekTimeUs;
     ReadOptions::SeekMode mode;
@@ -127,12 +412,18 @@ status_t MP3Decoder::read(
         CHECK(seekTimeUs >= 0);
 
         mNumFramesOutput = 0;
+        seekSource = true;
 
         if (mInputBuffer) {
             mInputBuffer->release();
             mInputBuffer = NULL;
         }
 
+        if (mPartialBuffer) {
+            mPartialBuffer->release();
+            mPartialBuffer = NULL;
+        }
+
         // Make sure that the next buffer output does not still
         // depend on fragments from the last one decoded.
         pvmp3_InitDecoder(mConfig, mDecoderBuf);
@@ -147,6 +438,26 @@ status_t MP3Decoder::read(
             return err;
         }
 
+        if ((mFixedHeader == 0) && (mInputBuffer->range_length() > 4)) {
+            //save the first 4 bytes as fixed header for the reset of the file
+            mFixedHeader = U32_AT((uint8_t *)mInputBuffer->data());
+        }
+
+        if (seekSource == true) {
+            off_t syncOffset = 0;
+            bool valid = resync((uint8_t *)mInputBuffer->data() + mInputBuffer->range_offset()
+                                ,mInputBuffer->range_length(), mFixedHeader, &syncOffset);
+            if (valid) {
+                // consume these bytes, we might find a frame header in next buffer
+                mInputBuffer->set_range(
+                    mInputBuffer->range_offset() + syncOffset,
+                    mInputBuffer->range_length() - syncOffset);
+                LOGV("mp3 decoder found a sync point after seek syncOffset %d", syncOffset);
+            } else {
+                LOGV("NO SYNC POINT found, buffer length %d",mInputBuffer->range_length());
+            }
+        }
+
         int64_t timeUs;
         if (mInputBuffer->meta_data()->findInt64(kKeyTime, &timeUs)) {
             mAnchorTimeUs = timeUs;
@@ -155,15 +466,33 @@ status_t MP3Decoder::read(
             // We must have a new timestamp after seeking.
             CHECK(seekTimeUs < 0);
         }
+        // check for partial frame
+        if (mPartialBuffer != NULL) {
+            err = updatePartialFrame();
+            if (err != OK) {
+                // updating partial frame failed, discard the previously
+                // saved partial frame and continue
+                mPartialBuffer->release();
+                mPartialBuffer = NULL;
+                err = OK;
+            }
+        }
     }
 
     MediaBuffer *buffer;
     CHECK_EQ(mBufferGroup->acquire_buffer(&buffer), OK);
 
-    mConfig->pInputBuffer =
-        (uint8_t *)mInputBuffer->data() + mInputBuffer->range_offset();
+    if (mPartialBuffer != NULL) {
+        mConfig->pInputBuffer =
+        (uint8_t *)mPartialBuffer->data() + mPartialBuffer->range_offset();
+        mConfig->inputBufferCurrentLength = mPartialBuffer->range_length();
+        usedPartialFrame = true;
+    } else {
+        mConfig->pInputBuffer =
+            (uint8_t *)mInputBuffer->data() + mInputBuffer->range_offset();
+        mConfig->inputBufferCurrentLength = mInputBuffer->range_length();
+    }
 
-    mConfig->inputBufferCurrentLength = mInputBuffer->range_length();
     mConfig->inputBufferMaxLength = 0;
     mConfig->inputBufferUsedLength = 0;
 
@@ -175,28 +504,67 @@ status_t MP3Decoder::read(
             != NO_DECODING_ERROR) {
         LOGV("mp3 decoder returned error %d", decoderErr);
 
-        if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR) {
+        if ((decoderErr != NO_ENOUGH_MAIN_DATA_ERROR) &&
+            (decoderErr != SYNCH_LOST_ERROR)) {
             buffer->release();
             buffer = NULL;
 
             mInputBuffer->release();
             mInputBuffer = NULL;
+            if (mPartialBuffer) {
+                mPartialBuffer->release();
+                mPartialBuffer = NULL;
+            }
+            LOGE("mp3 decoder returned UNKNOWN_ERROR");
 
             return UNKNOWN_ERROR;
         }
 
-        // This is recoverable, just ignore the current frame and
-        // play silence instead.
-        memset(buffer->data(), 0, mConfig->outputFrameSize * sizeof(int16_t));
-        mConfig->inputBufferUsedLength = mInputBuffer->range_length();
+        if ((mPartialBuffer == NULL) && (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR)) {
+            // Might be a partial frame, save it
+            mPartialBuffer = new MediaBuffer(mInputBuffer->size());
+            memcpy ((uint8_t *)mPartialBuffer->data(),
+                    mConfig->pInputBuffer, mConfig->inputBufferCurrentLength);
+            mPartialBuffer->set_range(0, mConfig->inputBufferCurrentLength);
+            // set output buffer to 0
+            mConfig->outputFrameSize = 0;
+            // consume the copied bytes from input
+            mConfig->inputBufferUsedLength = mConfig->inputBufferCurrentLength;
+        } else if(decoderErr == SYNCH_LOST_ERROR) {
+            // Try to find the mp3 frame header in the current buffer
+            off_t syncOffset = 0;
+            bool valid = resync(mConfig->pInputBuffer, mConfig->inputBufferCurrentLength,
+                                mFixedHeader, &syncOffset);
+            if (!valid || !syncOffset) {
+                // consume these bytes, we might find a frame header in next buffer
+                syncOffset = mConfig->inputBufferCurrentLength;
+            }
+            // set output buffer to 0
+            mConfig->outputFrameSize = 0;
+            // consume the junk bytes from input buffer
+            mConfig->inputBufferUsedLength = syncOffset;
+        } else {
+            // This is recoverable, just ignore the current frame and
+            // play silence instead.
+            memset(buffer->data(), 0, mConfig->outputFrameSize * sizeof(int16_t));
+            mConfig->inputBufferUsedLength = mInputBuffer->range_length();
+        }
     }
 
     buffer->set_range(
             0, mConfig->outputFrameSize * sizeof(int16_t));
 
-    mInputBuffer->set_range(
+    if ((mPartialBuffer != NULL) && usedPartialFrame) {
+        mPartialBuffer->set_range(
+            mPartialBuffer->range_offset() + mConfig->inputBufferUsedLength,
+            mPartialBuffer->range_length() - mConfig->inputBufferUsedLength);
+        mPartialBuffer->release();
+        mPartialBuffer = NULL;
+    } else {
+        mInputBuffer->set_range(
             mInputBuffer->range_offset() + mConfig->inputBufferUsedLength,
             mInputBuffer->range_length() - mConfig->inputBufferUsedLength);
+    }
 
     if (mInputBuffer->range_length() == 0) {
         mInputBuffer->release();
diff --git a/media/libstagefright/codecs/mp3dec/src/pvmp3_decode_header.cpp b/media/libstagefright/codecs/mp3dec/src/pvmp3_decode_header.cpp
index d443b7c..25e59bd 100644
--- a/media/libstagefright/codecs/mp3dec/src/pvmp3_decode_header.cpp
+++ b/media/libstagefright/codecs/mp3dec/src/pvmp3_decode_header.cpp
@@ -125,7 +125,7 @@ ERROR_CODE pvmp3_decode_header(tmp3Bits  *inputStream,
      * Note that SYNC_WORD_LNGTH is in unit of bits, but inputBufferCurrentLength
      * is in unit of bytes.
      */
-    if (inputStream->inputBufferCurrentLength < ((SYNC_WORD_LNGTH + 21) >> 3))
+    if (inputStream->inputBufferCurrentLength < ((SYNC_WORD_LNGTH + 25) >> 3))
     {
         return NO_ENOUGH_MAIN_DATA_ERROR;
     }
diff --git a/media/libstagefright/colorconversion/Android.mk b/media/libstagefright/colorconversion/Android.mk
index 0dcbd73..49e6a81 100644
--- a/media/libstagefright/colorconversion/Android.mk
+++ b/media/libstagefright/colorconversion/Android.mk
@@ -8,6 +8,10 @@ LOCAL_SRC_FILES:=                     \
 LOCAL_C_INCLUDES := \
         $(TOP)/frameworks/base/include/media/stagefright/openmax
 
+ifeq ($(TARGET_BOARD_PLATFORM),omap4)
+LOCAL_C_INCLUDES += hardware/ti/omx/ducati/domx/system/omx_core/inc
+endif
+
 LOCAL_SHARED_LIBRARIES :=       \
         libbinder               \
         libmedia                \
@@ -17,6 +21,10 @@ LOCAL_SHARED_LIBRARIES :=       \
         libsurfaceflinger_client\
         libcamera_client
 
+ifeq ($(TARGET_BOARD_PLATFORM),omap4)
+LOCAL_CFLAGS += -DTARGET_OMAP4 -DARM_4K_PAGE_SIZE=4096
+endif
+
 LOCAL_MODULE:= libstagefright_color_conversion
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 5b16997..9ba588a 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
+ * Copyright (c) 2010, Code Aurora Forum
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,9 +18,18 @@
 #include <media/stagefright/ColorConverter.h>
 #include <media/stagefright/MediaDebug.h>
 
+#if defined (TARGET_OMAP4) && defined (OMAP_ENHANCEMENT)
+#include <OMX_TI_IVCommon.h>
+#endif
+
 namespace android {
 
 static const int OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00;
+static const int QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03;
+static const size_t NV12TILE_BLOCK_WIDTH = 64;
+static const size_t NV12TILE_BLOCK_HEIGHT = 32;
+static const size_t NV12TILE_BLOCK_SIZE = NV12TILE_BLOCK_WIDTH* NV12TILE_BLOCK_HEIGHT;
+static const size_t NV12TILE_BLOCK_GROUP_SIZE =  NV12TILE_BLOCK_SIZE*4;
 
 ColorConverter::ColorConverter(
         OMX_COLOR_FORMATTYPE from, OMX_COLOR_FORMATTYPE to)
@@ -43,6 +53,11 @@ bool ColorConverter::isValid() const {
         case OMX_COLOR_FormatCbYCrY:
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
+        case QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka:
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar_Sequential_TopBottom:
+#endif
             return true;
 
         default:
@@ -50,10 +65,18 @@ bool ColorConverter::isValid() const {
     }
 }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+void ColorConverter::convert(
+        size_t width, size_t height,
+        const void *srcBits, size_t srcSkip,
+        void *dstBits, size_t dstSkip,
+        size_t dwidth, size_t dheight, size_t nOffset, bool interlaced) {
+#else
 void ColorConverter::convert(
         size_t width, size_t height,
         const void *srcBits, size_t srcSkip,
         void *dstBits, size_t dstSkip) {
+#endif
     CHECK_EQ(mDstFormat, OMX_COLOR_Format16bitRGB565);
 
     switch (mSrcFormat) {
@@ -77,6 +100,17 @@ void ColorConverter::convert(
                     width, height, srcBits, srcSkip, dstBits, dstSkip);
             break;
 
+        case QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka:
+            convertNV12Tile(
+                    width, height, srcBits, srcSkip, dstBits, dstSkip);
+            break;
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+        case OMX_COLOR_FormatYUV420PackedSemiPlanar:
+        case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar_Sequential_TopBottom:
+            convertYUV420PackedSemiPlanar(
+                    width, height, dwidth, dheight,nOffset,srcBits, srcSkip, dstBits, dstSkip, interlaced);
+            break;
+#endif
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
@@ -347,6 +381,93 @@ void ColorConverter::convertYUV420SemiPlanar(
     }
 }
 
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+void ColorConverter::convertYUV420PackedSemiPlanar(
+        size_t width, size_t height,
+        size_t displaywidth, size_t displayheight, size_t nOffset,
+        const void *srcBits, size_t srcSkip,
+        void *dstBits, size_t dstSkip, bool interlaced) {
+
+    CHECK((dstSkip & 3) == 0);
+
+    size_t stride = width;
+
+    if(srcSkip)
+        stride = srcSkip;
+
+    uint8_t *kAdjustedClip = initClip();
+
+    uint32_t *dst_ptr = (uint32_t *)dstBits;
+    const uint8_t *src_y = (const uint8_t *)srcBits;
+
+    uint32_t offx = nOffset  % stride;
+    uint32_t offy = nOffset / stride;
+
+
+    const uint8_t *src_u = (const uint8_t *)(src_y-nOffset) + (stride * height);
+    src_u += ( ( stride * (offy/2) ) + offx );
+
+    const uint8_t *src_v = src_u + 1;
+
+    for (size_t y = 0; y < displayheight; ++y) {
+        for (size_t x = 0; x < displaywidth; x += 2) {
+
+            signed y1 = (signed)src_y[x] - 16;    //Y pixel
+            signed y2 = (signed)src_y[x + 1] - 16; //2nd Y pixel
+
+            signed u = (signed)src_u[x & ~1] - 128;   //U component
+            signed v = (signed)src_u[(x & ~1) + 1] - 128; //V component
+
+            signed u_b = u * 517;
+            signed u_g = -u * 100;
+            signed v_g = -v * 208;
+            signed v_r = v * 409;
+
+            signed tmp1 = y1 * 298;
+            signed b1 = (tmp1 + u_b) / 256;
+            signed g1 = (tmp1 + v_g + u_g) / 256;
+            signed r1 = (tmp1 + v_r) / 256;
+
+            signed tmp2 = y2 * 298;
+            signed b2 = (tmp2 + u_b) / 256;
+            signed g2 = (tmp2 + v_g + u_g) / 256;
+            signed r2 = (tmp2 + v_r) / 256;
+
+            uint32_t rgb1 =
+                ((kAdjustedClip[r1] >> 3) << 11)
+                | ((kAdjustedClip[g1] >> 2) << 5)
+                | (kAdjustedClip[b1] >> 3);
+
+            uint32_t rgb2 =
+                ((kAdjustedClip[r2] >> 3) << 11)
+                | ((kAdjustedClip[g2] >> 2) << 5)
+                | (kAdjustedClip[b2] >> 3);
+
+            dst_ptr[x / 2] = (rgb2 << 16) | rgb1;
+        }
+
+        if(!interlaced){
+            src_y += stride; //increment Y-pixel line
+            if(y&1){
+              src_u += stride; //increment U-V line
+            }
+        }
+        else{
+            /* Interlaced stream. Will have Sequential Top Bottom content*/
+            /* Just extrapolate first half contnents from Y,UV planes */
+            if(y&1){
+                src_y += stride; //increment Y-pixel line, once for two lines
+                if((y/2)&1){
+                  src_u += stride; //increment U-V line, once for four lines
+                }
+            }
+        }
+        dst_ptr += dstSkip / 4;
+    }
+}
+#endif
+
 uint8_t *ColorConverter::initClip() {
     static const signed kClipMin = -278;
     static const signed kClipMax = 535;
@@ -362,4 +483,207 @@ uint8_t *ColorConverter::initClip() {
     return &mClip[-kClipMin];
 }
 
+// GetTiledMemBlockNum
+// Calculate the block number within tiled memory where the given frame space
+// block resides.
+//
+// Arguments:
+// bx  - Horizontal coordinate of block in frame space
+// by  - Vertical coordinate of block in frame space
+// nbx - Number of columns of blocks in frame space
+// nby - Number of rows of blocks in frame space
+size_t ColorConverter::nv12TileGetTiledMemBlockNum(
+        size_t bx, size_t by,
+        size_t nbx, size_t nby) {
+    //
+
+    // Due to the zigzag pattern we have that blocks are numbered like:
+    //
+    //         |             Column (by)
+    //         |   0    1    2    3    4    5    6    7
+    //  -------|---------------------------------------
+    //      0 |   0    1    6    7    8    9   14   15
+    //   R  1 |   2    3    4    5   10   11   12   13
+    //   o  2 |  16   17   22   23   24   25   30   31
+    //   w  3 |  18   19   20   21   26   27   28   29
+    //      4 |  32   33   38   39   40   41   46   47
+    // (bx) 5 |  34   35   36   37   42   43   44   45
+    //      6 |  48   49   50   51   52   53   54   55
+
+    // From this we can see that:
+
+    // For even rows:
+    // - The first block in a row is always mapped to memory block by*nbx.
+    // - For all even rows, except for the last one when nby is odd, from the first
+    //   block number an offset is then added to obtain the block number for
+    //   the other blocks in the row. The offset is bx plus the corresponding
+    //   number in the series [0, 0, 4, 4, 4, 4, 8, 8, 8, 8, 12, ...], which can be
+    //   expressed as ((bx+2) & ~(3)).
+    // - For the last row when nby is odd the offset is simply bx.
+    //
+    //  For odd rows:
+    // - The first block in the row is always mapped to memory block
+    //   (by & (~1))*nbx + 2.
+    // - From the first block number an offset is then added to obtain the block
+    //   number for the other blocks in the row. The offset is bx plus the
+    //   corresponding number in the series [0, 0, 0, 0, 4, 4, 4, 4, 8, 8, 8, 8, 12, ...],
+    //   which can be  expressed as (bx & ~(3)).
+
+    size_t base; // Number of memory block of the first block in row by
+    size_t offs; // Offset from base
+
+    if((by & 1)==0) {
+        base = by * nbx;
+        if((nby & 1) && (by == (nby - 1))) {
+            // Last row when nby is odd
+            offs = bx;
+        }
+        else {
+            offs = bx + ((bx + 2) & ~3);
+        }
+    }
+    else {
+        base = (by & (~1))*nbx + 2;
+        offs = bx + (bx & ~3);
+    }
+
+    return base + offs;
+}
+
+//Compute the RGB 565 values from the Y ,Cb Cr values
+void ColorConverter::nv12TileComputeRGB(
+        uint8_t **dstPtr, const uint8_t *blockUV,
+        const uint8_t *blockY, size_t blockWidth,
+        size_t dstSkip) {
+
+    uint8_t *dest_ptr = *dstPtr;
+
+    uint8_t *kAdjustedClip = initClip();
+
+    for(size_t i = 0; i < blockWidth; i++) {
+        signed y1 = (signed)blockY[i] - 16;;
+        signed u = (signed)blockUV[i & ~1] - 128;
+        signed v = (signed)blockUV[(i & ~1)+1]- 128;
+
+        signed u_b = u * 517;
+        signed u_g = -u * 100;
+        signed v_g = -v * 208;
+        signed v_r = v * 409;
+
+        signed tmp1 = y1 * 298;
+        signed b1 = (tmp1 + u_b) / 256;
+        signed g1 = (tmp1 + v_g + u_g) / 256;
+        signed r1 = (tmp1 + v_r) / 256;
+        uint32_t rgb1 =
+            ((kAdjustedClip[r1] >> 3) << 11)
+            | ((kAdjustedClip[g1] >> 2) << 5)
+            | (kAdjustedClip[b1] >> 3);
+
+        dest_ptr[i * 2] =  rgb1 & 0xFF;
+        dest_ptr[(i * 2) + 1] = (rgb1 >> 8) & 0xFF;
+    }
+
+    dest_ptr += dstSkip;
+    *dstPtr = dest_ptr;
+}
+
+//  TraverseBlock
+//  Function that iterates through the rows of Luma and Chroma blocks
+//  simultaneously, passing pointers to the rows to compute RGB565 values.
+//  Since there is twice as much data for Luma, Chroma row pointers are provided
+//  only when passing an even Luma row pointer.Since the same values apply for
+//  the next Luma (odd) row the  can save the pointer if needed.
+void ColorConverter::nv12TileTraverseBlock(
+        uint8_t **dstPtr, const uint8_t *blockY,
+        const uint8_t *blockUV, size_t blockWidth,
+        size_t blockHeight, size_t dstSkip) {
+
+    const uint8_t *block_UV = NULL;
+    for(size_t row = 0; row < blockHeight; row++) {
+        if(row & 1) {
+            // Only Luma, the converter can use the previous values if needed
+            nv12TileComputeRGB(dstPtr, block_UV, blockY, blockWidth, dstSkip);
+            blockUV += NV12TILE_BLOCK_WIDTH;
+        }
+        else {
+            block_UV = blockUV;
+            nv12TileComputeRGB(dstPtr, block_UV, blockY, blockWidth, dstSkip);
+        }
+        blockY += NV12TILE_BLOCK_WIDTH;
+    }
+}
+
+//Conversion from NV12 tiled to 16 bit RGB565
+void ColorConverter::convertNV12Tile(
+        size_t width, size_t height,
+        const void *srcBits, size_t srcSkip,
+        void *dstBits, size_t dstSkip) {
+
+    CHECK_EQ(srcSkip, 0);  // Doesn't really make sense for YUV formats.
+    CHECK(dstSkip >= width * 2);
+    CHECK((dstSkip & 3) == 0);
+
+    uint8_t *base_ptr = (uint8_t *)dstBits;
+    uint8_t *dst_ptr = NULL;
+
+    // Absolute number of columns of blocks in the Luma and Chroma spaces
+    size_t abx = (width - 1) / NV12TILE_BLOCK_WIDTH + 1;
+
+    // Number of columns of blocks in the Luma and Chroma spaces rounded to
+    // the next multiple of 2
+    size_t nbx = (abx + 1) & ~1;
+
+    // Number of rows of blocks in the Luma space
+    size_t nby_y = (height - 1) / NV12TILE_BLOCK_HEIGHT + 1;
+
+    // Number of rows of blocks in the Chroma space
+    size_t nby_uv = (height / 2 - 1) / NV12TILE_BLOCK_HEIGHT + 1;
+
+    // Calculate the size of the Luma section
+    size_t size_y = nbx * nby_y * NV12TILE_BLOCK_SIZE;
+
+    if((size_y % NV12TILE_BLOCK_GROUP_SIZE) != 0) {
+        size_y = (((size_y-1) / NV12TILE_BLOCK_GROUP_SIZE)+1)
+                 * NV12TILE_BLOCK_GROUP_SIZE;
+    }
+
+    // Pointers to the start of the Luma and Chroma spaces
+    const uint8_t *src_y   = (const uint8_t*)srcBits;
+    const uint8_t *src_uv = src_y + size_y;
+
+    // Iterate
+    for(size_t by = 0, rows_left = height; by < nby_y;
+            by++, rows_left -= NV12TILE_BLOCK_HEIGHT) {
+        for(size_t bx = 0, cols_left = width; bx < abx;
+                bx++, cols_left -= NV12TILE_BLOCK_WIDTH) {
+
+            size_t block_width = (cols_left > NV12TILE_BLOCK_WIDTH ?
+                    NV12TILE_BLOCK_WIDTH : cols_left);
+            size_t block_height = (rows_left > NV12TILE_BLOCK_HEIGHT ?
+                    NV12TILE_BLOCK_HEIGHT : rows_left);
+
+            // Address of Luma data for this block
+            size_t block_address = (nv12TileGetTiledMemBlockNum(bx, by, nbx, nby_y)
+                     * NV12TILE_BLOCK_SIZE);
+            const uint8_t *block_y = src_y + block_address;
+
+            // Address of Chroma data for this block
+            // since we have half the data for Chroma the same row number is used
+            // for two consecutive Luma rows, but we have to offset the base pointer
+            // by half a block for odd rows
+            block_address = (nv12TileGetTiledMemBlockNum(bx, by/2, nbx, nby_uv)
+                    * NV12TILE_BLOCK_SIZE);
+            const uint8_t *block_uv = src_uv + block_address + ((by & 1) ? NV12TILE_BLOCK_SIZE/2 : 0);
+
+            // We have started a new block, calculate the destination pointer
+            dst_ptr = base_ptr +
+            by * NV12TILE_BLOCK_HEIGHT*width*2 +
+            bx * NV12TILE_BLOCK_WIDTH*2;
+            nv12TileTraverseBlock(&dst_ptr, block_y,
+                    block_uv, block_width,
+                    block_height, dstSkip);
+        }
+    }
+}
+
 }  // namespace android
diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index 93ec79d..1a058ba 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -108,4 +108,12 @@ void SoftwareRenderer::render(
     mIndex = 1 - mIndex;
 }
 
+#ifdef OMAP_ENHANCEMENT
+Vector< sp<IMemory> > SoftwareRenderer::getBuffers(){
+    // Not Implemented
+    Vector< sp<IMemory> > mDummy;
+    return mDummy;
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/httplive/M3UParser.cpp b/media/libstagefright/httplive/M3UParser.cpp
index a68c641..90f3d6d 100644
--- a/media/libstagefright/httplive/M3UParser.cpp
+++ b/media/libstagefright/httplive/M3UParser.cpp
@@ -96,7 +96,7 @@ static bool MakeURL(const char *baseURL, const char *url, AString *out) {
         out->setTo(baseURL);
         out->append(url);
     } else {
-        char *slashPos = strrchr(baseURL, '/');
+        const char *slashPos = strrchr(baseURL, '/');
 
         if (slashPos > &baseURL[6]) {
             out->setTo(baseURL, slashPos - baseURL);
diff --git a/media/libstagefright/id3/Android.mk b/media/libstagefright/id3/Android.mk
index 23c8e44..6700b4c 100644
--- a/media/libstagefright/id3/Android.mk
+++ b/media/libstagefright/id3/Android.mk
@@ -4,6 +4,9 @@ include $(CLEAR_VARS)
 LOCAL_SRC_FILES := \
 	ID3.cpp
 
+LOCAL_C_INCLUDES:= \
+        $(TOP)/frameworks/base/include/media/stagefright/openmax
+
 LOCAL_MODULE := libstagefright_id3
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/media/libstagefright/include/AACEncoder.h b/media/libstagefright/include/AACEncoder.h
index ecc533f..e7289cd 100644
--- a/media/libstagefright/include/AACEncoder.h
+++ b/media/libstagefright/include/AACEncoder.h
@@ -60,7 +60,7 @@ class AACEncoder: public MediaSource {
             kNumSamplesPerFrame = 1024,
         };
 
-        int16_t           mInputFrame[kNumSamplesPerFrame];
+        int16_t           mInputFrame[kNumSamplesPerFrame * 2];
 
         uint8_t           mAudioSpecificConfigData[2]; // auido specific data
         void             *mEncoderHandle;
diff --git a/media/libstagefright/include/AMRExtractor.h b/media/libstagefright/include/AMRExtractor.h
index 1cdf36d..61acedf 100644
--- a/media/libstagefright/include/AMRExtractor.h
+++ b/media/libstagefright/include/AMRExtractor.h
@@ -19,11 +19,22 @@
 #define AMR_EXTRACTOR_H_
 
 #include <media/stagefright/MediaExtractor.h>
-
+#include <utils/List.h>
 namespace android {
 
 struct AMessage;
 class String8;
+struct AMRFrameTableEntry {
+
+   AMRFrameTableEntry(uint32_t numframes, uint32_t framesize, uint32_t framerate)
+      : mNumFrames(numframes),
+      mFrameSize(framesize),
+      mFrameRate(framerate) {}
+
+   uint64_t mNumFrames;
+   uint32_t mFrameSize;
+   uint32_t mFrameRate;
+};
 
 class AMRExtractor : public MediaExtractor {
 public:
@@ -44,7 +55,8 @@ private:
     status_t mInitCheck;
     size_t mFrameSize;
     bool mIsWide;
-
+    uint64_t mTotalFrames;
+    List<AMRFrameTableEntry> mAMRFrameTableEntries;
     AMRExtractor(const AMRExtractor &);
     AMRExtractor &operator=(const AMRExtractor &);
 };
diff --git a/media/libstagefright/include/ASFExtractor.h b/media/libstagefright/include/ASFExtractor.h
new file mode 100644
index 0000000..4ed0833
--- /dev/null
+++ b/media/libstagefright/include/ASFExtractor.h
@@ -0,0 +1,93 @@
+/*
+ *****************************************************************************
+ *
+ *                                Android
+ *                  ITTIAM SYSTEMS PVT LTD, BANGALORE
+ *                           COPYRIGHT(C) 2010-20
+ *
+ *  This program  is  proprietary to  Ittiam  Systems  Private  Limited  and
+ *  is protected under Indian  Copyright Law as an unpublished work. Its use
+ *  and  disclosure  is  limited by  the terms  and  conditions of a license
+ *  agreement. It may not be copied or otherwise  reproduced or disclosed to
+ *  persons outside the licensee's organization except in accordance with the
+ *  terms  and  conditions   of  such  an  agreement.  All  copies  and
+ *  reproductions shall be the property of Ittiam Systems Private Limited and
+ *  must bear this notice in its entirety.
+ *
+ *****************************************************************************
+ */
+/**
+ *****************************************************************************
+ *
+ *  @file     ASFExtractor.h
+ *
+ *  @brief    This file contains definition of ASFExtractor class
+ *
+ *****************************************************************************
+ */
+
+#ifndef ITTIAM_ASF_EXTRACTOR_H_
+
+#define ITTIAM_ASF_EXTRACTOR_H_
+
+#include <media/stagefright/MediaExtractor.h>
+#include <utils/Vector.h>
+
+namespace android {
+
+struct AMessage;
+class String8;
+class ASFExtractorImpl;
+
+typedef struct ASF_WRAPER
+{
+    ASFExtractorImpl* (*ASFExtractor)(
+        const sp<DataSource> &source);
+
+    void (*destructorASFExtractor)(ASFExtractorImpl *mHandle);
+
+    size_t (*countTracks)(ASFExtractorImpl *mHandle);
+
+    sp<MediaSource> (*getTrack)(
+        size_t index, ASFExtractorImpl *mHandle);
+
+    sp<MetaData> (*getTrackMetaData)(
+        size_t index,
+        uint32_t flags,
+        ASFExtractorImpl *mHandle);
+
+    sp<MetaData> (*getMetaData)(ASFExtractorImpl *mHandle);
+
+}ASF_WRAPER;
+
+class ASFExtractor : public MediaExtractor {
+public:
+    // Extractor assumes ownership of "source".
+    ASFExtractor(const sp<DataSource> &source);
+
+    virtual size_t countTracks();
+    virtual sp<MediaSource> getTrack(size_t index);
+    virtual sp<MetaData> getTrackMetaData(size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+
+protected:
+    virtual ~ASFExtractor();
+
+private:
+    ASF_WRAPER *pASFParser;
+    ASFExtractorImpl *mHandle;
+};
+
+bool SniffASF(const sp<DataSource> &source,
+              String8 *mimeType,
+              float *confidence,
+              sp<AMessage> *meta);
+
+bool isASFParserAvailable();
+void closeASFLib();
+
+}  // namespace android
+
+#endif  // ITTIAM_ASF_EXTRACTOR_H_
+
diff --git a/media/libstagefright/include/AwesomePlayer.h b/media/libstagefright/include/AwesomePlayer.h
index c059e60..844a082 100644
--- a/media/libstagefright/include/AwesomePlayer.h
+++ b/media/libstagefright/include/AwesomePlayer.h
@@ -17,6 +17,12 @@
 #ifndef AWESOME_PLAYER_H_
 
 #define AWESOME_PLAYER_H_
+#ifdef OMAP_ENHANCEMENT
+#include <utils/Vector.h>
+#if defined(TARGET_OMAP4)
+#include "TISEIMessagesParser.h"
+#endif
+#endif
 
 #include "NuHTTPDataSource.h"
 #include "TimedEventQueue.h"
@@ -46,6 +52,13 @@ struct AwesomeRenderer : public RefBase {
 
     virtual status_t initCheck() const = 0;
     virtual void render(MediaBuffer *buffer) = 0;
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers() = 0;
+    virtual bool setCallback(release_rendered_buffer_callback cb, void *cookie) {return false;}
+    virtual void set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling){};
+    virtual void resizeRenderer(void* resize_params) = 0;
+    virtual void requestRendererClone(bool enable) = 0;
+#endif
 
 private:
     AwesomeRenderer(const AwesomeRenderer &);
@@ -89,13 +102,18 @@ struct AwesomePlayer {
 
     status_t suspend();
     status_t resume();
+#ifdef OMAP_ENHANCEMENT
+    status_t requestVideoCloneMode(bool enable);
+#endif
 
     // This is a mask of MediaExtractor::Flags.
     uint32_t flags() const;
 
     void postAudioEOS();
     void postAudioSeekComplete();
-
+#ifdef OMAP_ENHANCEMENT
+    void releaseRenderedBuffer(const sp<IMemory>& mem);
+#endif
 private:
     friend struct AwesomeEvent;
 
@@ -113,6 +131,22 @@ private:
         AUTO_LOOPING        = 1024,
     };
 
+#ifdef OMAP_ENHANCEMENT
+    enum {
+        HOLD_TO_RESUME      = 2048,
+        MAX_RESOLUTION      = 414720, // 864x480(WVGA) - 720x576(D1-PAL)
+    };
+    enum {
+         VID_MODE_NORMAL = 0,
+         VID_MODE_CLONE = 1
+      };
+
+    int mVideoMode;
+#if defined(TARGET_OMAP4)
+    S3D_params mS3Dparams;
+#endif
+#endif
+
     mutable Mutex mLock;
     Mutex mMiscStateLock;
 
@@ -179,7 +213,15 @@ private:
     void postCheckAudioStatusEvent_l();
     status_t play_l();
 
+#ifdef OMAP_ENHANCEMENT
+    Vector<MediaBuffer*> mBuffersWithRenderer;
+    bool mBufferReleaseCallbackSet;
+    bool mIsFirstVideoBuffer;
+    status_t mFirstVideoBufferResult;
+    MediaBuffer *mFirstVideoBuffer;
+#else
     MediaBuffer *mLastVideoBuffer;
+#endif
     MediaBuffer *mVideoBuffer;
 
     sp<NuHTTPDataSource> mConnectingDataSource;
@@ -216,6 +258,12 @@ private:
         }
     } *mSuspensionState;
 
+#if defined(TARGET_OMAP4) && defined(OMAP_ENHANCEMENT)
+    bool configSEI2004Infos(OMX_OTHER_EXTRADATATYPE *extraData);
+    bool configSEI2010Infos(OMX_OTHER_EXTRADATATYPE *extraData);
+    void updateS3DRenderer();
+#endif
+
     status_t setDataSource_l(
             const char *uri,
             const KeyedVector<String8, String8> *headers = NULL);
@@ -263,6 +311,10 @@ private:
 
     AwesomePlayer(const AwesomePlayer &);
     AwesomePlayer &operator=(const AwesomePlayer &);
+#ifdef OMAP_ENHANCEMENT
+    const char* mExtractorType;
+    sp<MediaExtractor> mExtractor;
+#endif
 };
 
 }  // namespace android
diff --git a/media/libstagefright/include/MP3Decoder.h b/media/libstagefright/include/MP3Decoder.h
index 4086fb6..8ff570a 100644
--- a/media/libstagefright/include/MP3Decoder.h
+++ b/media/libstagefright/include/MP3Decoder.h
@@ -53,13 +53,16 @@ private:
     void *mDecoderBuf;
     int64_t mAnchorTimeUs;
     int64_t mNumFramesOutput;
+    uint32_t mFixedHeader;
 
     MediaBuffer *mInputBuffer;
+    MediaBuffer *mPartialBuffer;
 
     void init();
 
     MP3Decoder(const MP3Decoder &);
     MP3Decoder &operator=(const MP3Decoder &);
+    status_t updatePartialFrame();
 };
 
 }  // namespace android
diff --git a/media/libstagefright/include/NuCachedSource2.h b/media/libstagefright/include/NuCachedSource2.h
index a836ad7..df269d3 100644
--- a/media/libstagefright/include/NuCachedSource2.h
+++ b/media/libstagefright/include/NuCachedSource2.h
@@ -53,8 +53,13 @@ private:
 
     enum {
         kPageSize            = 65536,
+#ifndef OMAP_ENHANCEMENT
         kHighWaterThreshold  = 5 * 1024 * 1024,
         kLowWaterThreshold   = 512 * 1024,
+#else
+        kHighWaterThreshold  = 13 * 1024 * 1024,
+        kLowWaterThreshold   = 14 * 512 * 1024,
+#endif
 
         // Read data after a 15 sec timeout whether we're actively
         // fetching or not.
diff --git a/media/libstagefright/include/OMX.h b/media/libstagefright/include/OMX.h
index 72ab5aa..32ea540 100644
--- a/media/libstagefright/include/OMX.h
+++ b/media/libstagefright/include/OMX.h
@@ -26,6 +26,35 @@ namespace android {
 struct OMXMaster;
 class OMXNodeInstance;
 
+// data structures for tunneling buffers
+typedef struct PLATFORM_PRIVATE_PMEM_INFO
+{
+    /* pmem file descriptor */
+    size_t pmem_fd;
+    size_t offset;
+} PLATFORM_PRIVATE_PMEM_INFO;
+
+typedef struct PLATFORM_PRIVATE_ENTRY
+{
+    /* Entry type */
+    size_t type;
+
+    /* Pointer to platform specific entry */
+    void* entry;
+} PLATFORM_PRIVATE_ENTRY;
+
+typedef struct PLATFORM_PRIVATE_LIST
+{
+    /* Number of entries */
+    size_t nEntries;
+
+    /* Pointer to array of platform specific entries *
+     * Contiguous block of PLATFORM_PRIVATE_ENTRY elements */
+    PLATFORM_PRIVATE_ENTRY* entryList;
+} PLATFORM_PRIVATE_LIST;
+
+#define PLATFORM_PRIVATE_PMEM 1
+
 class OMX : public BnOMX,
             public IBinder::DeathRecipient {
 public:
@@ -59,6 +88,12 @@ public:
             node_id node, OMX_INDEXTYPE index,
             const void *params, size_t size);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    virtual status_t useBuffer(
+            node_id node, OMX_U32 port_index, const sp<IMemory> &params,
+            buffer_id *buffer, size_t size);
+#endif
+
     virtual status_t useBuffer(
             node_id node, OMX_U32 port_index, const sp<IMemory> &params,
             buffer_id *buffer);
@@ -94,6 +129,16 @@ public:
             size_t encodedWidth, size_t encodedHeight,
             size_t displayWidth, size_t displayHeight,
             int32_t rotationDegrees);
+#ifdef OMAP_ENHANCEMENT
+    virtual sp<IOMXRenderer> createRenderer(
+            const sp<ISurface> &surface,
+            const char *componentName,
+            OMX_COLOR_FORMATTYPE colorFormat,
+            size_t encodedWidth, size_t encodedHeight,
+            size_t displayWidth, size_t displayHeight,
+            int32_t rotationDegrees,
+            int isS3D, int numOfOpBuffers);
+#endif
 
     virtual void binderDied(const wp<IBinder> &the_late_who);
 
diff --git a/media/libstagefright/include/OMXNodeInstance.h b/media/libstagefright/include/OMXNodeInstance.h
index b5b31ac..82d8e26 100644
--- a/media/libstagefright/include/OMXNodeInstance.h
+++ b/media/libstagefright/include/OMXNodeInstance.h
@@ -49,6 +49,12 @@ struct OMXNodeInstance {
     status_t getConfig(OMX_INDEXTYPE index, void *params, size_t size);
     status_t setConfig(OMX_INDEXTYPE index, const void *params, size_t size);
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    status_t useBuffer(
+            OMX_U32 portIndex, const sp<IMemory> &params,
+            OMX::buffer_id *buffer, size_t size);
+#endif
+
     status_t useBuffer(
             OMX_U32 portIndex, const sp<IMemory> &params,
             OMX::buffer_id *buffer);
@@ -82,11 +88,14 @@ struct OMXNodeInstance {
 private:
     Mutex mLock;
 
+    bool pmem_registered_with_client;
+
     OMX *mOwner;
     OMX::node_id mNodeID;
     OMX_HANDLETYPE mHandle;
     sp<IOMXObserver> mObserver;
     bool mDying;
+    OMX_U8* mBase;
 
     struct ActiveBuffer {
         OMX_U32 mPortIndex;
diff --git a/media/libstagefright/include/SampleTable.h b/media/libstagefright/include/SampleTable.h
index f830690..8f56c82 100644
--- a/media/libstagefright/include/SampleTable.h
+++ b/media/libstagefright/include/SampleTable.h
@@ -46,6 +46,10 @@ public:
 
     status_t setTimeToSampleParams(off_t data_offset, size_t data_size);
 
+#ifdef OMAP_ENHANCEMENT
+    status_t setTimeToSampleParamsCtts(off_t data_offset, size_t data_size);
+#endif
+
     status_t setSyncSampleParams(off_t data_offset, size_t data_size);
 
     ////////////////////////////////////////////////////////////////////////////
@@ -76,7 +80,9 @@ public:
             uint32_t flags);
 
     status_t findThumbnailSample(uint32_t *sample_index);
-
+#ifdef OMAP_ENHANCEMENT
+	int32_t *mTimeToSampleCtts;
+#endif
 protected:
     ~SampleTable();
 
@@ -124,6 +130,12 @@ private:
 
     SampleTable(const SampleTable &);
     SampleTable &operator=(const SampleTable &);
+
+#ifdef OMAP_ENHANCEMENT
+    uint32_t mTimeToSampleCountCtts;
+    int32_t *mCttsSampleBuffer;
+#endif
+
 };
 
 }  // namespace android
diff --git a/media/libstagefright/include/SoftwareRenderer.h b/media/libstagefright/include/SoftwareRenderer.h
index 89d7cc4..ec2cc88 100644
--- a/media/libstagefright/include/SoftwareRenderer.h
+++ b/media/libstagefright/include/SoftwareRenderer.h
@@ -42,6 +42,11 @@ public:
 
     virtual void render(
             const void *data, size_t size, void *platformPrivate);
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers();
+    virtual void resizeRenderer(void* resize_params) {}
+    virtual void requestRendererClone(bool enable) {}
+#endif
 
 private:
     status_t mInitCheck;
diff --git a/media/libstagefright/include/TISEIMessagesParser.h b/media/libstagefright/include/TISEIMessagesParser.h
new file mode 100644
index 0000000..cd3e2fe
--- /dev/null
+++ b/media/libstagefright/include/TISEIMessagesParser.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) Texas Instruments - http://www.ti.com/
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+
+#ifndef TI_SEI_MESSAGES_PARSER_H_INCLUDED
+#define TI_SEI_MESSAGES_PARSER_H_INCLUDED
+
+#include <utils/Log.h>
+
+namespace android {
+
+/*values for possible S3D modes*/
+enum {
+    S3D_MODE_OFF = 0,
+    S3D_MODE_ON = 1,
+    S3D_MODE_ANAGLYPH = 2,
+};
+
+/*values for possible S3D format types*/
+enum {
+    S3D_FORMAT_NONE = 0,
+    S3D_FORMAT_OVERUNDER,
+    S3D_FORMAT_SIDEBYSIDE,
+    S3D_FORMAT_ROW_IL,
+    S3D_FORMAT_COL_IL,
+    S3D_FORMAT_PIX_IL,
+    S3D_FORMAT_CHECKB,
+    S3D_FORMAT_FRM_SEQ,
+};
+
+/*values for possible S3D order types*/
+enum {
+    S3D_ORDER_LF = 0,
+    S3D_ORDER_RF,
+};
+
+/*values for possible S3D subsampling modes*/
+enum {
+    S3D_SS_NONE = 0,
+    S3D_SS_HOR,
+    S3D_SS_VERT,
+};
+
+/*values for possible S3D SEI messages types*/
+enum {
+    S3D_SEI_NONE = 0,                                   /* Regular Interlaced or Progressive stream */
+    S3D_SEI_STEREO_INFO_PROGRESSIVE,    /* 2004 Progressive */
+    S3D_SEI_STEREO_INFO_INTERLACED,     /*  2004 Interlaced */
+    S3D_SEI_STEREO_FRAME_PACKING,       /*  2010 Progressive */
+};
+
+struct S3D_params
+{
+    bool active;
+    uint32_t mode;
+    uint32_t fmt;
+    uint32_t order;
+    uint32_t subsampling;
+    uint32_t metadata;
+};
+
+#define AVC_NALTYPE_SEI 6  /* Supplemental Enhancement Info */
+void set_frame_packing_arrangement_type(uint32_t frame_packing_arrangement_type, uint32_t &format, uint32_t &subsampling);
+int32_t AVCGetNALType(uint8_t *bitstream, int size, int *nal_type, int *nal_ref_idc);
+int16_t sei_rbsp(uint8_t *buffer, int32_t length, S3D_params &mS3Dparams);
+
+}
+#endif //TI_M4V_CONFIG_PARSER_H_INCLUDED
+#endif //OMAP_ENHANCEMENT
+
diff --git a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
index 1661130..529fd0e 100644
--- a/media/libstagefright/matroska/MatroskaExtractor.cpp
+++ b/media/libstagefright/matroska/MatroskaExtractor.cpp
@@ -706,6 +706,7 @@ void MatroskaExtractor::addTracks() {
 
     for (size_t index = 0; index < tracks->GetTracksCount(); ++index) {
         const mkvparser::Track *track = tracks->GetTrackByIndex(index);
+        if (!track) continue; // we can get back a NULL (it happens...)
 
         const char *const codecID = track->GetCodecId();
         LOGV("codec id = %s", codecID);
diff --git a/media/libstagefright/mpeg2ts/ESQueue.cpp b/media/libstagefright/mpeg2ts/ESQueue.cpp
index b0b9e66..47f8dc0 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.cpp
+++ b/media/libstagefright/mpeg2ts/ESQueue.cpp
@@ -146,6 +146,11 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitAAC() {
         bits.skipBits(2);
 
         unsigned aac_frame_length = bits.getBits(13);
+        size_t headerSize = protection_absent ? 7 : 9;
+
+        if (aac_frame_length < headerSize) {
+            break;
+        }
 
         bits.skipBits(11);  // adts_buffer_fullness
 
@@ -160,8 +165,6 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnitAAC() {
             break;
         }
 
-        size_t headerSize = protection_absent ? 7 : 9;
-
         frameOffsets.push(offset + headerSize);
         frameSizes.push(aac_frame_length - headerSize);
         auSize += aac_frame_length - headerSize;
diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index ead1675..8b64e7a 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -8,6 +8,14 @@ LOCAL_C_INCLUDES := $(PV_INCLUDES)
 LOCAL_CFLAGS := $(PV_CFLAGS_MINUS_VISIBILITY)
 endif
 
+ifeq ($(TARGET_BOARD_PLATFORM),omap3)
+LOCAL_CFLAGS += -DTARGET_OMAP3
+endif
+
+ifeq ($(TARGET_BOARD_PLATFORM),msm7x30)
+LOCAL_CFLAGS += -DTARGET_7X30
+endif
+
 LOCAL_C_INCLUDES += $(JNI_H_INCLUDE)
 
 LOCAL_SRC_FILES:=                     \
@@ -46,6 +54,11 @@ ifneq ($(TARGET_SIMULATOR),true)
 LOCAL_SHARED_LIBRARIES += libdl
 endif
 
+ifeq ($(BOARD_CAMERA_USE_GETBUFFERINFO),true)
+        LOCAL_CFLAGS += -DUSE_GETBUFFERINFO
+        LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= libstagefright_omx
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
index 2ba63f7..6cb09a4 100644
--- a/media/libstagefright/omx/OMX.cpp
+++ b/media/libstagefright/omx/OMX.cpp
@@ -55,6 +55,7 @@ private:
 
     OMXNodeInstance *mOwner;
     bool mDone;
+    bool mStarted;
     Condition mQueueChanged;
     List<omx_message> mQueue;
 
@@ -71,7 +72,8 @@ private:
 
 OMX::CallbackDispatcher::CallbackDispatcher(OMXNodeInstance *owner)
     : mOwner(owner),
-      mDone(false) {
+      mDone(false),
+      mStarted(false) {
     pthread_attr_t attr;
     pthread_attr_init(&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
@@ -98,6 +100,9 @@ OMX::CallbackDispatcher::~CallbackDispatcher() {
 
 void OMX::CallbackDispatcher::post(const omx_message &msg) {
     Mutex::Autolock autoLock(mLock);
+    while (!mStarted) {
+        mQueueChanged.wait(mLock);
+    }
 
     mQueue.push_back(msg);
     mQueueChanged.signal();
@@ -122,6 +127,12 @@ void OMX::CallbackDispatcher::threadEntry() {
     setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_AUDIO);
     prctl(PR_SET_NAME, (unsigned long)"OMXCallbackDisp", 0, 0, 0);
 
+    {
+        Mutex::Autolock autoLock(mLock);
+        mStarted = true;
+        mQueueChanged.signal();
+    }
+
     for (;;) {
         omx_message msg;
 
@@ -131,7 +142,7 @@ void OMX::CallbackDispatcher::threadEntry() {
                 mQueueChanged.wait(mLock);
             }
 
-            if (mDone) {
+            if (mDone && mQueue.empty()) {
                 break;
             }
 
@@ -295,6 +306,15 @@ status_t OMX::setConfig(
             index, params, size);
 }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+status_t OMX::useBuffer(
+        node_id node, OMX_U32 port_index, const sp<IMemory> &params,
+        buffer_id *buffer, size_t size) {
+    return findInstance(node)->useBuffer(
+            port_index, params, buffer, size);
+}
+#endif
+
 status_t OMX::useBuffer(
         node_id node, OMX_U32 port_index, const sp<IMemory> &params,
         buffer_id *buffer) {
@@ -381,6 +401,7 @@ OMX_ERRORTYPE OMX::OnFillBufferDone(
     LOGV("OnFillBufferDone buffer=%p", pBuffer);
 
     omx_message msg;
+    long offset = 0;
     msg.type = omx_message::FILL_BUFFER_DONE;
     msg.node = node;
     msg.u.extended_buffer_data.buffer = pBuffer;
@@ -391,8 +412,28 @@ OMX_ERRORTYPE OMX::OnFillBufferDone(
     msg.u.extended_buffer_data.platform_private = pBuffer->pPlatformPrivate;
     msg.u.extended_buffer_data.data_ptr = pBuffer->pBuffer;
 
-    findDispatcher(node)->post(msg);
+#ifdef TARGET_7X30
+    PLATFORM_PRIVATE_LIST *pPlatfromList = (PLATFORM_PRIVATE_LIST *)pBuffer->pPlatformPrivate;
+    PLATFORM_PRIVATE_ENTRY *pPlatformEntry;
+    PLATFORM_PRIVATE_PMEM_INFO *pPMEMInfo;
+
+    if(pPlatfromList) {
+      for(size_t i=0; i<pPlatfromList->nEntries; i++) {
+	if(pPlatfromList->entryList->type == PLATFORM_PRIVATE_PMEM)
+	  {
+	    pPlatformEntry = (PLATFORM_PRIVATE_ENTRY *)pPlatfromList->entryList;
+	    pPMEMInfo = (PLATFORM_PRIVATE_PMEM_INFO *)pPlatformEntry->entry;
+	    if(pPMEMInfo) {
+	      offset = pPMEMInfo->offset;
+	    }
+	    break;
+	  }
+      }
+    }
+    msg.u.extended_buffer_data.pmem_offset = offset;
+#endif
 
+    findDispatcher(node)->post(msg);
     return OMX_ErrorNone;
 }
 
@@ -452,6 +493,27 @@ struct SharedVideoRenderer : public VideoRenderer {
         return mObj->render(data, size, platformPrivate);
     }
 
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers() {
+        return mObj->getBuffers();
+    }
+
+    virtual bool setCallback(release_rendered_buffer_callback cb, void *cookie) {
+        return mObj->setCallback(cb, cookie);
+    }
+
+    virtual void set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling) {
+    mObj->set_s3d_frame_layout(s3d_mode, s3d_fmt, s3d_order, s3d_subsampling);
+     }
+
+    virtual void resizeRenderer(void* resize_params) {
+          mObj->resizeRenderer(resize_params);
+    }
+virtual void requestRendererClone(bool enable) {
+    mObj->requestRendererClone(enable);
+}
+#endif
+
 private:
     void *mLibHandle;
     VideoRenderer *mObj;
@@ -543,6 +605,86 @@ sp<IOMXRenderer> OMX::createRenderer(
     return new OMXRenderer(impl);
 }
 
+#ifdef OMAP_ENHANCEMENT
+sp<IOMXRenderer> OMX::createRenderer(
+        const sp<ISurface> &surface,
+        const char *componentName,
+        OMX_COLOR_FORMATTYPE colorFormat,
+        size_t encodedWidth, size_t encodedHeight,
+        size_t displayWidth, size_t displayHeight,
+        int32_t rotationDegrees,
+        int isS3D, int numOfOpBuffers) {
+    Mutex::Autolock autoLock(mLock);
+    VideoRenderer *impl = NULL;
+    void *libHandle = dlopen("libstagefrighthw.so", RTLD_NOW);
+
+    if (libHandle) {
+        typedef VideoRenderer *(*CreateRendererWithRotationFunc)(
+                const sp<ISurface> &surface,
+                const char *componentName,
+                OMX_COLOR_FORMATTYPE colorFormat,
+                size_t displayWidth, size_t displayHeight,
+                size_t decodedWidth, size_t decodedHeight,
+                int32_t rotationDegrees,
+                int isS3D, int numOfOpBuffers);
+
+        typedef VideoRenderer *(*CreateRendererFunc)(
+                const sp<ISurface> &surface,
+                const char *componentName,
+                OMX_COLOR_FORMATTYPE colorFormat,
+                size_t displayWidth, size_t displayHeight,
+                size_t decodedWidth, size_t decodedHeight,
+                int isS3D, int numOfOpBuffers);
+
+        CreateRendererWithRotationFunc funcWithRotation =
+            (CreateRendererWithRotationFunc)dlsym(
+                    libHandle,
+                    "_Z26createRendererWithRotationRKN7android2spINS_8"
+                    "ISurfaceEEEPKc20OMX_COLOR_FORMATTYPEjjjjiii");
+
+        if (funcWithRotation) {
+            impl = (*funcWithRotation)(
+                    surface, componentName, colorFormat,
+                    displayWidth, displayHeight, encodedWidth, encodedHeight,
+                    rotationDegrees,
+                    isS3D, numOfOpBuffers);
+        } else {
+            CreateRendererFunc func =
+                (CreateRendererFunc)dlsym(
+                        libHandle,
+                        "_Z14createRendererRKN7android2spINS_8ISurfaceEEEPKc20"
+                        "OMX_COLOR_FORMATTYPEjjjjii");
+            if (func) {
+                impl = (*func)(surface, componentName, colorFormat,
+                        displayWidth, displayHeight, encodedWidth, encodedHeight,
+                        isS3D, numOfOpBuffers);
+            }
+        }
+
+        if (impl) {
+            impl = new SharedVideoRenderer(libHandle, impl);
+            libHandle = NULL;
+        }
+
+        if (libHandle) {
+            dlclose(libHandle);
+            libHandle = NULL;
+        }
+    }
+
+    if (!impl) {
+        LOGE("Using software renderer.");
+        impl = new SoftwareRenderer(
+                colorFormat,
+                surface,
+                displayWidth, displayHeight,
+                encodedWidth, encodedHeight);
+    }
+
+    return new OMXRenderer(impl);
+}
+#endif
+
 OMXRenderer::OMXRenderer(VideoRenderer *impl)
     : mImpl(impl) {
 }
@@ -561,5 +703,28 @@ void OMXRenderer::render(IOMX::buffer_id buffer) {
             header->pPlatformPrivate);
 }
 
+#ifdef OMAP_ENHANCEMENT
+Vector< sp<IMemory> > OMXRenderer::getBuffers() {
+    return mImpl->getBuffers();
+}
+
+bool OMXRenderer::setCallback(release_rendered_buffer_callback cb, void *cookie) {
+    return mImpl->setCallback(cb, cookie);
+}
+
+void OMXRenderer::set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling) {
+    mImpl->set_s3d_frame_layout(s3d_mode, s3d_fmt, s3d_order, s3d_subsampling);
+}
+
+void OMXRenderer::resizeRenderer(void* resize_params) {
+    mImpl->resizeRenderer(resize_params);
+}
+
+void OMXRenderer::requestRendererClone(bool enable) {
+    mImpl->requestRendererClone(enable);
+}
+
+#endif
+
 }  // namespace android
 
diff --git a/media/libstagefright/omx/OMXMaster.cpp b/media/libstagefright/omx/OMXMaster.cpp
index 56b169a..80b59b0 100644
--- a/media/libstagefright/omx/OMXMaster.cpp
+++ b/media/libstagefright/omx/OMXMaster.cpp
@@ -87,7 +87,10 @@ void OMXMaster::addPlugin(OMXPluginBase *plugin) {
 
         mPluginByComponentName.add(name8, plugin);
     }
+
+#if !defined( TARGET_OMAP3)
     CHECK_EQ(err, OMX_ErrorNoMore);
+#endif
 }
 
 void OMXMaster::clearPlugins() {
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 5db516e..4c40a4e 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -22,11 +22,15 @@
 #include "OMXMaster.h"
 
 #include <OMX_Component.h>
+#ifdef USE_GETBUFFERINFO
+#include <OMX_QCOMExtns.h>
+#endif
 
 #include <binder/IMemory.h>
+#include <binder/MemoryHeapBase.h>
+#include <binder/MemoryHeapPmem.h>
 #include <media/stagefright/MediaDebug.h>
 #include <media/stagefright/MediaErrors.h>
-
 namespace android {
 
 struct BufferMeta {
@@ -64,6 +68,7 @@ private:
     sp<IMemory> mMem;
     size_t mSize;
     bool mIsBackup;
+    char *mBase;
 
     BufferMeta(const BufferMeta &);
     BufferMeta &operator=(const BufferMeta &);
@@ -80,7 +85,8 @@ OMXNodeInstance::OMXNodeInstance(
       mNodeID(NULL),
       mHandle(NULL),
       mObserver(observer),
-      mDying(false) {
+      mDying(false),
+      pmem_registered_with_client(false){
 }
 
 OMXNodeInstance::~OMXNodeInstance() {
@@ -178,6 +184,13 @@ status_t OMXNodeInstance::freeNode(OMXMaster *master) {
             break;
     }
 
+#ifdef TARGET_7X30
+    if(true == pmem_registered_with_client) {
+      mObserver->registerBuffers(NULL);
+      pmem_registered_with_client = false;
+    }
+#endif
+
     OMX_ERRORTYPE err = master->destroyComponentInstance(
             static_cast<OMX_COMPONENTTYPE *>(mHandle));
 
@@ -240,18 +253,57 @@ status_t OMXNodeInstance::setConfig(
     return StatusFromOMXError(err);
 }
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
 status_t OMXNodeInstance::useBuffer(
-        OMX_U32 portIndex, const sp<IMemory> &params,
-        OMX::buffer_id *buffer) {
+                OMX_U32 portIndex, const sp<IMemory> &params,
+                OMX::buffer_id *buffer) {
+        return useBuffer(portIndex, params, buffer, 0);
+}
+#endif
+
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+status_t OMXNodeInstance::useBuffer(
+                OMX_U32 portIndex, const sp<IMemory> &params,
+                OMX::buffer_id *buffer, size_t size) {
+#else
+status_t OMXNodeInstance::useBuffer(
+                OMX_U32 portIndex, const sp<IMemory> &params,
+                OMX::buffer_id *buffer) {
+#endif
     Mutex::Autolock autoLock(mLock);
 
     BufferMeta *buffer_meta = new BufferMeta(params);
 
     OMX_BUFFERHEADERTYPE *header;
 
+#if defined(OMAP_ENHANCEMENT) && defined(TARGET_OMAP4)
+    OMX_ERRORTYPE err;
+
+    if(params.get() != NULL) {
+        err = OMX_UseBuffer(
+                mHandle, &header, portIndex, buffer_meta,
+                params->size(), static_cast<OMX_U8 *>(params->pointer()));
+    } else {
+        err = OMX_UseBuffer(
+                mHandle, &header, portIndex, buffer_meta,
+                size, NULL);
+    }
+#elif defined(USE_GETBUFFERINFO)
+    OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO pmem_info;
+    ssize_t offset;
+    size_t size;
+    sp<IMemoryHeap> heap = params->getMemory(&offset, &size);
+    pmem_info.pmem_fd = heap->getHeapID();
+    pmem_info.offset = offset;
+
+    OMX_ERRORTYPE err = OMX_UseBuffer(
+            mHandle, &header, portIndex, &pmem_info,
+            params->size(), static_cast<OMX_U8 *>(params->pointer()));
+#else
     OMX_ERRORTYPE err = OMX_UseBuffer(
             mHandle, &header, portIndex, buffer_meta,
             params->size(), static_cast<OMX_U8 *>(params->pointer()));
+#endif
 
     if (err != OMX_ErrorNone) {
         LOGE("OMX_UseBuffer failed with error %d (0x%08x)", err, err);
@@ -264,6 +316,10 @@ status_t OMXNodeInstance::useBuffer(
         return UNKNOWN_ERROR;
     }
 
+#ifdef USE_GETBUFFERINFO
+    header->pAppPrivate = buffer_meta;
+#endif
+
     CHECK_EQ(header->pAppPrivate, buffer_meta);
 
     *buffer = header;
@@ -408,6 +464,36 @@ void OMXNodeInstance::onMessage(const omx_message &msg) {
         BufferMeta *buffer_meta =
             static_cast<BufferMeta *>(buffer->pAppPrivate);
 
+#ifdef TARGET_7X30
+        PLATFORM_PRIVATE_LIST *pPlatfromList = (PLATFORM_PRIVATE_LIST *)buffer->pPlatformPrivate;
+        PLATFORM_PRIVATE_ENTRY *pPlatformEntry;
+        PLATFORM_PRIVATE_PMEM_INFO *pPMEMInfo;
+        if(pPlatfromList && (false == pmem_registered_with_client)) {
+        sp<IMemoryHeap> mMem;
+        sp<MemoryHeapBase> master = NULL;
+            for(size_t i=0; i<pPlatfromList->nEntries; i++) {
+               if(pPlatfromList->entryList->type == PLATFORM_PRIVATE_PMEM)
+               {
+                  pPlatformEntry = (PLATFORM_PRIVATE_ENTRY *)pPlatfromList->entryList;
+                  pPMEMInfo = (PLATFORM_PRIVATE_PMEM_INFO *)pPlatformEntry->entry;
+                  if(pPMEMInfo) {
+                     master = (MemoryHeapBase *)pPMEMInfo->pmem_fd;
+                  }
+                  break;
+               }
+            }
+            if(master != NULL) {
+                master->setDevice("/dev/pmem_adsp");
+                uint32_t heap_flags = master->getFlags() & MemoryHeapBase::NO_CACHING;
+                sp<MemoryHeapPmem> heap = new MemoryHeapPmem(master, heap_flags);
+                heap->slap();
+                mMem = interface_cast<IMemoryHeap>(heap);
+                mBase = (OMX_U8 *)mMem->getBase();
+                mObserver->registerBuffers(mMem);
+                pmem_registered_with_client = true;
+            }
+        }
+#endif
         buffer_meta->CopyFromOMX(buffer);
     }
 
@@ -437,6 +523,17 @@ OMX_ERRORTYPE OMXNodeInstance::OnEvent(
     if (instance->mDying) {
         return OMX_ErrorNone;
     }
+#ifdef TARGET_7X30
+    if(eEvent == OMX_EventCmdComplete && nData1 == OMX_CommandPortDisable && nData2 == 1) {
+      /*This is needed to clear the reference on pmem fd.
+       * If this is skipped then we will see pmem leak.
+       */
+      if(true == instance->pmem_registered_with_client) {
+        instance->mObserver->registerBuffers(NULL);
+        instance->pmem_registered_with_client = false;
+      }
+    }
+#endif
     return instance->owner()->OnEvent(
             instance->nodeID(), eEvent, nData1, nData2, pEventData);
 }
diff --git a/media/libstagefright/omx/OMXRenderer.h b/media/libstagefright/omx/OMXRenderer.h
index 4d194ce..fec2fa3 100644
--- a/media/libstagefright/omx/OMXRenderer.h
+++ b/media/libstagefright/omx/OMXRenderer.h
@@ -31,6 +31,14 @@ public:
     virtual ~OMXRenderer();
 
     virtual void render(IOMX::buffer_id buffer);
+#ifdef OMAP_ENHANCEMENT
+    virtual Vector< sp<IMemory> > getBuffers();
+    virtual bool setCallback(release_rendered_buffer_callback cb, void *cookie);
+
+    virtual void set_s3d_frame_layout(uint32_t s3d_mode, uint32_t s3d_fmt, uint32_t s3d_order, uint32_t s3d_subsampling);
+    virtual void resizeRenderer(void* resize_params);
+    virtual void requestRendererClone(bool enable);
+#endif
 
 private:
     VideoRenderer *mImpl;
diff --git a/media/libstagefright/omx/tests/OMXHarness.cpp b/media/libstagefright/omx/tests/OMXHarness.cpp
index 4f28855..af8e0bc 100644
--- a/media/libstagefright/omx/tests/OMXHarness.cpp
+++ b/media/libstagefright/omx/tests/OMXHarness.cpp
@@ -73,6 +73,8 @@ void Harness::onMessage(const omx_message &msg) {
     mMessageAddedCondition.signal();
 }
 
+void Harness::registerBuffers(const sp<IMemoryHeap> &mem) {
+}
 status_t Harness::dequeueMessageForNode(
         IOMX::node_id node, omx_message *msg, int64_t timeoutUs) {
     return dequeueMessageForNodeIgnoringBuffers(
diff --git a/media/libstagefright/omx/tests/OMXHarness.h b/media/libstagefright/omx/tests/OMXHarness.h
index bb8fd0c..1572cdd 100644
--- a/media/libstagefright/omx/tests/OMXHarness.h
+++ b/media/libstagefright/omx/tests/OMXHarness.h
@@ -75,6 +75,7 @@ struct Harness : public BnOMXObserver {
     status_t testAll();
 
     virtual void onMessage(const omx_message &msg);
+    virtual void registerBuffers(const sp<IMemoryHeap> &mem);
 
 protected:
     virtual ~Harness();
diff --git a/media/libstagefright/rtsp/ASessionDescription.cpp b/media/libstagefright/rtsp/ASessionDescription.cpp
index aa2618e..f03f7a2 100644
--- a/media/libstagefright/rtsp/ASessionDescription.cpp
+++ b/media/libstagefright/rtsp/ASessionDescription.cpp
@@ -201,7 +201,7 @@ void ASessionDescription::getFormatType(
     AString format;
     getFormat(index, &format);
 
-    char *lastSpacePos = strrchr(format.c_str(), ' ');
+    const char *lastSpacePos = strrchr(format.c_str(), ' ');
     CHECK(lastSpacePos != NULL);
 
     char *end;
diff --git a/media/libstagefright/rtsp/MyHandler.h b/media/libstagefright/rtsp/MyHandler.h
index 7bf534d..891c3f6 100644
--- a/media/libstagefright/rtsp/MyHandler.h
+++ b/media/libstagefright/rtsp/MyHandler.h
@@ -40,14 +40,16 @@
 #include <sys/socket.h>
 #include <netdb.h>
 
-// If no access units are received within 3 secs, assume that the rtp
+// If no access units are received within 10 secs, assume that the rtp
 // stream has ended and signal end of stream.
-static int64_t kAccessUnitTimeoutUs = 3000000ll;
+static int64_t kAccessUnitTimeoutUs = 10000000ll;
 
 // If no access units arrive for the first 10 secs after starting the
 // stream, assume none ever will and signal EOS or switch transports.
 static int64_t kStartupTimeoutUs = 10000000ll;
 
+static int64_t kDefaultKeepAliveTimeoutUs = 60000000ll;
+
 namespace android {
 
 static void MakeUserAgentString(AString *s) {
@@ -110,7 +112,9 @@ struct MyHandler : public AHandler {
           mTryFakeRTCP(false),
           mReceivedFirstRTCPPacket(false),
           mReceivedFirstRTPPacket(false),
-          mSeekable(false) {
+          mSeekable(false),
+          mKeepAliveTimeoutUs(kDefaultKeepAliveTimeoutUs),
+          mKeepAliveGeneration(0) {
         mNetLooper->setName("rtsp net");
         mNetLooper->start(false /* runOnCallingThread */,
                           false /* canCallJava */,
@@ -371,6 +375,8 @@ struct MyHandler : public AHandler {
 
             case 'disc':
             {
+                ++mKeepAliveGeneration;
+
                 int32_t reconnect;
                 if (msg->findInt32("reconnect", &reconnect) && reconnect) {
                     sp<AMessage> reply = new AMessage('conn', id());
@@ -502,6 +508,34 @@ struct MyHandler : public AHandler {
                         CHECK_GE(i, 0);
 
                         mSessionID = response->mHeaders.valueAt(i);
+
+                        mKeepAliveTimeoutUs = kDefaultKeepAliveTimeoutUs;
+                        AString timeoutStr;
+                        if (GetAttribute(
+                                    mSessionID.c_str(), "timeout", &timeoutStr)) {
+                            char *end;
+                            unsigned long timeoutSecs =
+                                strtoul(timeoutStr.c_str(), &end, 10);
+
+                            if (end == timeoutStr.c_str() || *end != '\0') {
+                                LOGW("server specified malformed timeout '%s'",
+                                     timeoutStr.c_str());
+
+                                mKeepAliveTimeoutUs = kDefaultKeepAliveTimeoutUs;
+                            } else if (timeoutSecs < 15) {
+                                LOGW("server specified too short a timeout "
+                                     "(%lu secs), using default.",
+                                     timeoutSecs);
+
+                                mKeepAliveTimeoutUs = kDefaultKeepAliveTimeoutUs;
+                            } else {
+                                mKeepAliveTimeoutUs = timeoutSecs * 1000000ll;
+
+                                LOGI("server specified timeout of %lu secs.",
+                                     timeoutSecs);
+                            }
+                        }
+
                         i = mSessionID.find(";");
                         if (i >= 0) {
                             // Remove options, i.e. ";timeout=90"
@@ -549,6 +583,9 @@ struct MyHandler : public AHandler {
                 if (index < mSessionDesc->countTracks()) {
                     setupTrack(index);
                 } else if (mSetupTracksSuccessful) {
+                    ++mKeepAliveGeneration;
+                    postKeepAlive();
+
                     AString request = "PLAY ";
                     request.append(mSessionURL);
                     request.append(" RTSP/1.0\r\n");
@@ -600,6 +637,51 @@ struct MyHandler : public AHandler {
                 break;
             }
 
+            case 'aliv':
+            {
+                int32_t generation;
+                CHECK(msg->findInt32("generation", &generation));
+
+                if (generation != mKeepAliveGeneration) {
+                    // obsolete event.
+                    break;
+                }
+
+                AString request;
+                request.append("OPTIONS ");
+                request.append(mSessionURL);
+                request.append(" RTSP/1.0\r\n");
+                request.append("Session: ");
+                request.append(mSessionID);
+                request.append("\r\n");
+                request.append("\r\n");
+
+                sp<AMessage> reply = new AMessage('opts', id());
+                reply->setInt32("generation", mKeepAliveGeneration);
+                mConn->sendRequest(request.c_str(), reply);
+                break;
+            }
+
+            case 'opts':
+            {
+                int32_t result;
+                CHECK(msg->findInt32("result", &result));
+
+                LOGI("OPTIONS completed with result %d (%s)",
+                     result, strerror(-result));
+
+                int32_t generation;
+                CHECK(msg->findInt32("generation", &generation));
+
+                if (generation != mKeepAliveGeneration) {
+                    // obsolete event.
+                    break;
+                }
+
+                postKeepAlive();
+                break;
+            }
+
             case 'abor':
             {
                 for (size_t i = 0; i < mTracks.size(); ++i) {
@@ -962,6 +1044,12 @@ struct MyHandler : public AHandler {
         }
     }
 
+    void postKeepAlive() {
+        sp<AMessage> msg = new AMessage('aliv', id());
+        msg->setInt32("generation", mKeepAliveGeneration);
+        msg->post((mKeepAliveTimeoutUs * 9) / 10);
+    }
+
     void postAccessUnitTimeoutCheck() {
         if (mCheckPending) {
             return;
@@ -1092,6 +1180,8 @@ private:
     bool mReceivedFirstRTCPPacket;
     bool mReceivedFirstRTPPacket;
     bool mSeekable;
+    int64_t mKeepAliveTimeoutUs;
+    int32_t mKeepAliveGeneration;
 
     struct TrackInfo {
         AString mURL;
@@ -1197,7 +1287,7 @@ private:
             out->setTo(baseURL);
             out->append(url);
         } else {
-            char *slashPos = strrchr(baseURL, '/');
+            const char *slashPos = strrchr(baseURL, '/');
 
             if (slashPos > &baseURL[6]) {
                 out->setTo(baseURL, slashPos - baseURL);
diff --git a/obex/javax/obex/ClientOperation.java b/obex/javax/obex/ClientOperation.java
index 05b498c..111b1c4 100644
--- a/obex/javax/obex/ClientOperation.java
+++ b/obex/javax/obex/ClientOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2009, Motorola, Inc.
+ * Copyright (c) 2010-2011, Motorola, Inc.
  *
  * All rights reserved.
  *
@@ -37,7 +37,6 @@ import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
-import java.io.ByteArrayOutputStream;
 
 /**
  * This class implements the <code>Operation</code> interface. It will read and
@@ -72,6 +71,8 @@ public final class ClientOperation implements Operation, BaseStream {
 
     private boolean mEndOfBodySent;
 
+    private ObexByteBuffer mOutBuffer;
+
     /**
      * Creates new OperationImpl to read and write data to a server
      * @param maxSize the maximum packet size
@@ -100,6 +101,8 @@ public final class ClientOperation implements Operation, BaseStream {
 
         mRequestHeader = new HeaderSet();
 
+        mOutBuffer = new ObexByteBuffer(32);
+
         int[] headerList = header.getHeaderList();
 
         if (headerList != null) {
@@ -121,6 +124,13 @@ public final class ClientOperation implements Operation, BaseStream {
                     (header).mAuthResp.length);
 
         }
+        if ((header).mConnectionID != null) {
+            mRequestHeader.mConnectionID = new byte[4];
+            System.arraycopy((header).mConnectionID, 0, mRequestHeader.mConnectionID, 0,
+                    4);
+
+        }
+
     }
 
     /**
@@ -396,7 +406,7 @@ public final class ClientOperation implements Operation, BaseStream {
      */
     private boolean sendRequest(int opCode) throws IOException {
         boolean returnValue = false;
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
+
         int bodyLength = -1;
         byte[] headerArray = ObexHelper.createHeader(mRequestHeader, true);
         if (mPrivateOutput != null) {
@@ -437,9 +447,9 @@ public final class ClientOperation implements Operation, BaseStream {
                     throw new IOException("OBEX Packet exceeds max packet size");
                 }
 
-                byte[] sendHeader = new byte[end - start];
-                System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
-                if (!mParent.sendRequest(opCode, sendHeader, mReplyHeader, mPrivateInput)) {
+                mOutBuffer.reset();
+                mOutBuffer.write(headerArray, start, end - start);
+                if (!mParent.sendRequest(opCode, mOutBuffer, mReplyHeader, mPrivateInput)) {
                     return false;
                 }
 
@@ -456,7 +466,8 @@ public final class ClientOperation implements Operation, BaseStream {
                 return false;
             }
         } else {
-            out.write(headerArray);
+            mOutBuffer.reset();
+            mOutBuffer.write(headerArray);
         }
 
         if (bodyLength > 0) {
@@ -471,8 +482,6 @@ public final class ClientOperation implements Operation, BaseStream {
                 bodyLength = mMaxPacketSize - headerArray.length - 6;
             }
 
-            byte[] body = mPrivateOutput.readBytes(bodyLength);
-
             /*
              * Since this is a put request if the final bit is set or
              * the output stream is closed we need to send the 0x49
@@ -480,44 +489,40 @@ public final class ClientOperation implements Operation, BaseStream {
              */
             if ((mPrivateOutput.isClosed()) && (!returnValue) && (!mEndOfBodySent)
                     && ((opCode & 0x80) != 0)) {
-                out.write(0x49);
+                mOutBuffer.write((byte)0x49);
                 mEndOfBodySent = true;
             } else {
-                out.write(0x48);
+                mOutBuffer.write((byte)0x48);
             }
 
             bodyLength += 3;
-            out.write((byte)(bodyLength >> 8));
-            out.write((byte)bodyLength);
-
-            if (body != null) {
-                out.write(body);
-            }
+            mOutBuffer.write((byte)(bodyLength >> 8));
+            mOutBuffer.write((byte)bodyLength);
+            mPrivateOutput.writeTo(mOutBuffer, bodyLength - 3);
         }
 
         if (mPrivateOutputOpen && bodyLength <= 0 && !mEndOfBodySent) {
             // only 0x82 or 0x83 can send 0x49
             if ((opCode & 0x80) == 0) {
-                out.write(0x48);
+                mOutBuffer.write((byte)0x48);
             } else {
-                out.write(0x49);
+                mOutBuffer.write((byte)0x49);
                 mEndOfBodySent = true;
-
             }
 
             bodyLength = 3;
-            out.write((byte)(bodyLength >> 8));
-            out.write((byte)bodyLength);
+            mOutBuffer.write((byte)(bodyLength >> 8));
+            mOutBuffer.write((byte)bodyLength);
         }
 
-        if (out.size() == 0) {
+        if (mOutBuffer.getLength() == 0) {
             if (!mParent.sendRequest(opCode, null, mReplyHeader, mPrivateInput)) {
                 return false;
             }
             return returnValue;
         }
-        if ((out.size() > 0)
-                && (!mParent.sendRequest(opCode, out.toByteArray(), mReplyHeader, mPrivateInput))) {
+        if ((mOutBuffer.getLength() > 0)
+                && (!mParent.sendRequest(opCode, mOutBuffer, mReplyHeader, mPrivateInput))) {
             return false;
         }
 
@@ -723,4 +728,8 @@ public final class ClientOperation implements Operation, BaseStream {
             }
         }
     }
+
+    public void noEndofBody() {
+
+    }
 }
diff --git a/obex/javax/obex/ClientSession.java b/obex/javax/obex/ClientSession.java
index 0935383..597c17c 100644
--- a/obex/javax/obex/ClientSession.java
+++ b/obex/javax/obex/ClientSession.java
@@ -32,7 +32,6 @@
 
 package javax.obex;
 
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -62,11 +61,23 @@ public final class ClientSession extends ObexSession {
 
     private final OutputStream mOutput;
 
+    private ObexByteBuffer mOutBuffer;
+
+    private ObexByteBuffer mData;
+
+    private ObexByteBuffer mBodyBuffer;
+
+    private ObexByteBuffer mHeaderBuffer;
+
     public ClientSession(final ObexTransport trans) throws IOException {
         mInput = trans.openInputStream();
         mOutput = trans.openOutputStream();
         mOpen = true;
         mRequestActive = false;
+        mOutBuffer = new ObexByteBuffer(32);
+        mData = new ObexByteBuffer(32);
+        mBodyBuffer = new ObexByteBuffer(32);
+        mHeaderBuffer = new ObexByteBuffer(32);
     }
 
     public HeaderSet connect(final HeaderSet header) throws IOException {
@@ -97,19 +108,20 @@ public final class ClientSession extends ObexSession {
         * Byte 5&6: Max OBEX Packet Length (Defined in MAX_PACKET_SIZE)
         * Byte 7 to n: headers
         */
-        byte[] requestPacket = new byte[totalLength];
+        ObexByteBuffer requestPacket = new ObexByteBuffer(totalLength);
+
         // We just need to start at  byte 3 since the sendRequest() method will
         // handle the length and 0x80.
-        requestPacket[0] = (byte)0x10;
-        requestPacket[1] = (byte)0x00;
-        requestPacket[2] = (byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
-        requestPacket[3] = (byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
+        requestPacket.write((byte)0x10);
+        requestPacket.write((byte)0x00);
+        requestPacket.write((byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8));
+        requestPacket.write((byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF));
         if (head != null) {
-            System.arraycopy(head, 0, requestPacket, 4, head.length);
+            requestPacket.write(head);
         }
 
         // check with local max packet size
-        if ((requestPacket.length + 3) > ObexHelper.MAX_PACKET_SIZE_INT) {
+        if ((totalLength + 3) > ObexHelper.MAX_PACKET_SIZE_INT) {
             throw new IOException("Packet size exceeds max packet size");
         }
 
@@ -214,8 +226,14 @@ public final class ClientSession extends ObexSession {
             }
         }
 
+        ObexByteBuffer headBuffer = null;
+        if (head != null) {
+            headBuffer = new ObexByteBuffer(head.length);
+            headBuffer.write(head);
+        }
+
         HeaderSet returnHeaderSet = new HeaderSet();
-        sendRequest(ObexHelper.OBEX_OPCODE_DISCONNECT, head, returnHeaderSet, null);
+        sendRequest(ObexHelper.OBEX_OPCODE_DISCONNECT, headBuffer, returnHeaderSet, null);
 
         /*
          * An OBEX DISCONNECT reply from the server:
@@ -340,11 +358,11 @@ public final class ClientSession extends ObexSession {
          * Byte 5: constants
          * Byte 6 & up: headers
          */
-        byte[] packet = new byte[totalLength];
-        packet[0] = (byte)flags;
-        packet[1] = (byte)0x00;
+        ObexByteBuffer packet = new ObexByteBuffer(totalLength);
+        packet.write((byte)flags);
+        packet.write((byte)0x00);
         if (headset != null) {
-            System.arraycopy(head, 0, packet, 2, head.length);
+            packet.write(head);
         }
 
         HeaderSet returnHeaderSet = new HeaderSet();
@@ -405,31 +423,30 @@ public final class ClientSession extends ObexSession {
      *        <code>false</code> if an authentication response failed to pass
      * @throws IOException if an IO error occurs
      */
-    public boolean sendRequest(int opCode, byte[] head, HeaderSet header,
+    public boolean sendRequest(int opCode, ObexByteBuffer head, HeaderSet header,
             PrivateInputStream privateInput) throws IOException {
         //check header length with local max size
         if (head != null) {
-            if ((head.length + 3) > ObexHelper.MAX_PACKET_SIZE_INT) {
+            if ((head.getLength() + 3) > ObexHelper.MAX_PACKET_SIZE_INT) {
                 throw new IOException("header too large ");
             }
         }
 
-        int bytesReceived;
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        out.write((byte)opCode);
+        mOutBuffer.reset();
+        mOutBuffer.write((byte)opCode);
 
         // Determine if there are any headers to send
         if (head == null) {
-            out.write(0x00);
-            out.write(0x03);
+            mOutBuffer.write((byte)0x00);
+            mOutBuffer.write((byte)0x03);
         } else {
-            out.write((byte)((head.length + 3) >> 8));
-            out.write((byte)(head.length + 3));
-            out.write(head);
+            mOutBuffer.write((byte)((head.getLength() + 3) >> 8));
+            mOutBuffer.write((byte)(head.getLength() + 3));
+            mOutBuffer.write(head, 0);
         }
 
         // Write the request to the output stream and flush the stream
-        mOutput.write(out.toByteArray());
+        mOutBuffer.peek(mOutput, mOutBuffer.getLength());
         mOutput.flush();
 
         header.responseCode = mInput.read();
@@ -440,7 +457,7 @@ public final class ClientSession extends ObexSession {
             throw new IOException("Packet received exceeds packet size limit");
         }
         if (length > ObexHelper.BASE_PACKET_LENGTH) {
-            byte[] data = null;
+            mData.reset();
             if (opCode == ObexHelper.OBEX_OPCODE_CONNECT) {
                 @SuppressWarnings("unused")
                 int version = mInput.read();
@@ -454,31 +471,21 @@ public final class ClientSession extends ObexSession {
                 }
 
                 if (length > 7) {
-                    data = new byte[length - 7];
-
-                    bytesReceived = mInput.read(data);
-                    while (bytesReceived != (length - 7)) {
-                        bytesReceived += mInput.read(data, bytesReceived, data.length
-                                - bytesReceived);
-                    }
+                    mData.write(mInput, length - 7);
                 } else {
                     return true;
                 }
             } else {
-                data = new byte[length - 3];
-                bytesReceived = mInput.read(data);
-
-                while (bytesReceived != (length - 3)) {
-                    bytesReceived += mInput.read(data, bytesReceived, data.length - bytesReceived);
-                }
+                mData.write(mInput, length - 3);
                 if (opCode == ObexHelper.OBEX_OPCODE_ABORT) {
                     return true;
                 }
             }
 
-            byte[] body = ObexHelper.updateHeaderSet(header, data);
-            if ((privateInput != null) && (body != null)) {
-                privateInput.writeBytes(body, 1);
+            ObexHelper.updateHeaderSet(header, mData, mBodyBuffer, mHeaderBuffer);
+
+            if ((privateInput != null) && (mBodyBuffer.getLength() > 0)) {
+                privateInput.writeBytes(mBodyBuffer, 1);
             }
 
             if (header.mConnectionID != null) {
@@ -497,17 +504,23 @@ public final class ClientSession extends ObexSession {
                     && (header.mAuthChall != null)) {
 
                 if (handleAuthChall(header)) {
-                    out.write((byte)HeaderSet.AUTH_RESPONSE);
-                    out.write((byte)((header.mAuthResp.length + 3) >> 8));
-                    out.write((byte)(header.mAuthResp.length + 3));
-                    out.write(header.mAuthResp);
+
+                    // This can't be a member variable and mOutBuffer can't be used here
+                    // since this is a recursive call.
+                    // That's OK since authentication should not happen very often.
+                    ObexByteBuffer sendHeadersBuffer = new ObexByteBuffer(
+                            (mOutBuffer.getLength() - 3) + header.mAuthResp.length + 3);
+                    sendHeadersBuffer.write(mOutBuffer, 3);
+
+                    sendHeadersBuffer.write((byte)HeaderSet.AUTH_RESPONSE);
+                    sendHeadersBuffer.write((byte)((header.mAuthResp.length + 3) >> 8));
+                    sendHeadersBuffer.write((byte)(header.mAuthResp.length + 3));
+                    sendHeadersBuffer.write(header.mAuthResp);
+
                     header.mAuthChall = null;
                     header.mAuthResp = null;
 
-                    byte[] sendHeaders = new byte[out.size() - 3];
-                    System.arraycopy(out.toByteArray(), 3, sendHeaders, 0, sendHeaders.length);
-
-                    return sendRequest(opCode, sendHeaders, header, privateInput);
+                    return sendRequest(opCode, sendHeadersBuffer, header, privateInput);
                 }
             }
         }
diff --git a/obex/javax/obex/HeaderSet.java b/obex/javax/obex/HeaderSet.java
index b89b707..8cf15f5 100644
--- a/obex/javax/obex/HeaderSet.java
+++ b/obex/javax/obex/HeaderSet.java
@@ -126,7 +126,7 @@ public final class HeaderSet {
     /**
      * Represents the OBEX End of BODY header.
      * <P>
-     * The value of <code>BODY</code> is 0x49 (73).
+     * The value of <code>END_OF_BODY</code> is 0x49 (73).
      */
     public static final int END_OF_BODY = 0x49;
 
diff --git a/obex/javax/obex/ObexByteBuffer.java b/obex/javax/obex/ObexByteBuffer.java
new file mode 100644
index 0000000..18dafaf
--- /dev/null
+++ b/obex/javax/obex/ObexByteBuffer.java
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package javax.obex;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+class ObexByteBuffer {
+    private static final int REALLOC_EXTRA_SPACE = 24;
+
+    private byte[] mBuffer;
+
+    private int mIndex;
+
+    private int mLength;
+
+    public ObexByteBuffer(int initialSize) {
+        mBuffer = new byte[initialSize];
+        mIndex = 0;
+        mLength = 0;
+    }
+
+    /**
+     * Mark bytes at beginning or valid data as invalid.
+     * @param numBytes Number of bytes to consume.
+     */
+    private void consume(int numBytes) {
+        mLength -= numBytes;
+        if (mLength > 0) {
+            mIndex += numBytes;
+        } else {
+            mIndex = 0;
+        }
+    }
+
+    /**
+     * Make room in for new data (if needed).
+     * @param numBytes Number of bytes to make room for.
+     */
+    private void acquire(int numBytes) {
+        int remainingSpace = mBuffer.length - (mIndex + mLength);
+
+        // Do we need to grow or shuffle?
+        if (remainingSpace < numBytes) {
+            int availableSpace = mBuffer.length - mLength;
+            if (availableSpace < numBytes) {
+                // Need to grow. Add some extra space to avoid small growth.
+                byte[] newbuf = new byte[mLength + numBytes + REALLOC_EXTRA_SPACE];
+                System.arraycopy(mBuffer, mIndex, newbuf, 0, mLength);
+                mBuffer = newbuf;
+            } else {
+                // Need to shuffle
+                System.arraycopy(mBuffer, mIndex, mBuffer, 0, mLength);
+            }
+            mIndex = 0;
+        }
+    }
+
+    /**
+     * Get the internal byte array. Use with care.
+     * @return the internal byte array
+     */
+    public byte[] getBytes() {
+        return mBuffer;
+    }
+
+    /**
+     * Get number of written but not consumed bytes.
+     * @return number of bytes
+     */
+    public int getLength() {
+        return mLength;
+    }
+
+    /**
+     * Discard all unconsumed bytes.
+     */
+    public void reset() {
+        mIndex = 0;
+        mLength = 0;
+    }
+
+    /**
+     * Read and consume one byte.
+     * @return Next unconsumed byte.
+     */
+    public byte read() {
+        if (mLength == 0) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        mLength--;
+        return mBuffer[mIndex++];
+    }
+
+    /**
+     * Read and consume bytes, and write them into a byte array.
+     * Will read (dest.length - destOffset) bytes.
+     * @param dest Array to copy data into.
+     * @param destOffset Where to start writing in dest.
+     * @return number of read bytes.
+     */
+    public int read(byte[] dest, int destOffset) {
+        return read(dest, destOffset, mLength);
+    }
+
+    /**
+     * Read and consume bytes, and write them into a byte array.
+     * Will read (length - destOffset) bytes.
+     * @param dest Array to copy data into.
+     * @param destOffset Where to start writing in dest.
+     * @param length Number of bytes to read.
+     * @return number of read bytes.
+     */
+    public int read(byte[] dest, int destOffset, int length) {
+        peek(0, dest, destOffset, length);
+        consume(length);
+        return length;
+    }
+
+    /**
+     * Read and consume bytes, and write them into another ObexByteBuffer.
+     * @param dest ObexByteBuffer to copy data into.
+     * @param length Number of bytes to read.
+     * @return number of read bytes.
+     */
+    public int read(ObexByteBuffer dest, int length) {
+        if (length > mLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        dest.write(mBuffer, mIndex, length);
+        consume(length);
+
+        return length;
+    }
+
+    /**
+     * Read and consume all unconsumed bytes, and write them into an OutputStream.
+     * @param dest OutputStream to copy data into.
+     * @return number of read bytes.
+     */
+    public int read(OutputStream stream) throws IOException {
+        return read(stream, mLength);
+    }
+
+    /**
+     * Read and consume bytes, and write them into an OutputStream.
+     * @param dest OutputStream to copy data into.
+     * @param length Number of bytes to read.
+     * @return number of read bytes.
+     */
+    public int read(OutputStream destStream, int length) throws IOException {
+        peek(destStream, length);
+        consume(length);
+        return length;
+    }
+
+    /**
+     * Read (but don't consume) one byte.
+     * @param offset Offset into unconsumed bytes.
+     * @return Requested unconsumed byte.
+     */
+    public byte peek(int offset) {
+        if (offset > mLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        return mBuffer[mIndex + offset];
+    }
+
+    /**
+     * Read (but don't consume) bytes and write them into a byte array.
+     * Will read dest.length bytes.
+     * @param offset Offset into unconsumed bytes.
+     * @param dest Array to copy data into.
+     */
+    public void peek(int offset, byte[] dest) {
+        peek(offset, dest, 0, dest.length);
+    }
+
+    /**
+     * Read (but don't consume) bytes and write them into a byte array.
+     * Will read (length - destOffset) bytes.
+     * @param offset Offset into unconsumed bytes.
+     * @param dest Array to copy data into.
+     * @param destOffset Where to start writing in dest.
+     * @param length Number of bytes to read.
+     */
+    public void peek(int offset, byte[] dest, int destOffset, int length) {
+        if (offset > mLength || (offset + length) > mLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        System.arraycopy(mBuffer, mIndex + offset, dest, destOffset, length);
+    }
+
+    /**
+     * Read (but don't consume) bytes, and write them into an OutputStream.
+     * @param dest OutputStream to copy data into.
+     * @param length Number of bytes to read.
+     */
+    public void peek(OutputStream stream, int length) throws IOException {
+        if (length > mLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        stream.write(mBuffer, mIndex, length);
+    }
+
+    /**
+     * Write a new byte.
+     * @param src Byte to write.
+     */
+    public void write(byte src) {
+        acquire(1);
+        mBuffer[mIndex + mLength] = src;
+        mLength++;
+    }
+
+    /**
+     * Read bytes from a byte array and add to unconsumed bytes.
+     * Will read/write src.length bytes.
+     * @param src Array to read from.
+     */
+    public void write(byte[] src) {
+        write(src, 0, src.length);
+    }
+
+    /**
+     * Read bytes from a byte array and add to unconsumed bytes.
+     * Will read/write (src.length - srcOffset) bytes.
+     * @param src Array to read from.
+     * @param srcOffset Offset into source array.
+     */
+    public void write(byte[] src, int srcOffset) {
+        write(src, srcOffset, src.length - srcOffset);
+    }
+
+    /**
+     * Read bytes from a byte array and add to unconsumed bytes.
+     * Will read/write (srcLength - srcOffset) bytes.
+     * @param src Array to read from.
+     * @param srcOffset Offset into source array.
+     * @param srcLength Number of bytes to read/write.
+     */
+    public void write(byte[] src, int srcOffset, int srcLength) {
+        // Make sure we have space.
+        acquire(srcLength);
+
+        // Add the new data at the end
+        System.arraycopy(src, srcOffset, mBuffer, mIndex + mLength, srcLength);
+        mLength += srcLength;
+    }
+
+    /**
+     * Read bytes from another ObexByteBuffer and add to unconsumed bytes.
+     * Will read/write src.getLength() bytes. The bytes in src will not be consumed.
+     * @param src ObexByteBuffer to read from.
+     * @param srcOffset Offset into source array.
+     */
+    public void write(ObexByteBuffer src) {
+        write(src.mBuffer, 0, src.getLength());
+    }
+
+    /**
+     * Read bytes from another ObexByteBuffer and add to unconsumed bytes.
+     * Will read/write (src.getLength() - srcOffset) bytes. The bytes in src will not
+     * be consumed.
+     * @param src ObexByteBuffer to read from.
+     * @param srcOffset Offset into source array.
+     */
+    public void write(ObexByteBuffer src, int srcOffset) {
+        if (srcOffset > src.mLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        write(src.mBuffer, src.mIndex + srcOffset, src.mLength - src.mIndex - srcOffset);
+    }
+
+    /**
+     * Read bytes from another ObexByteBuffer and add to unconsumed bytes.
+     * Will read/write (srcLength - srcOffset) bytes. The bytes in src will not be
+     * consumed.
+     * @param src ObexByteBuffer to read from.
+     * @param srcOffset Offset into source array.
+     * @param srcLength Number of bytes to read/write.
+     */
+    public void write(ObexByteBuffer src, int srcOffset, int srcLength) {
+        if (srcOffset > src.mLength || (srcOffset + srcLength) > src.mLength) {
+            throw new ArrayIndexOutOfBoundsException();
+        }
+        write(src.mBuffer, src.mIndex + srcOffset, srcLength);
+    }
+
+    /**
+     * Read bytes from an InputStream and add to unconsumed bytes.
+     * @param src InputStream to read from
+     * @param srcLength Number of bytes to read
+     * @throws IOException
+     */
+    public void write(InputStream src, int srcLength) throws IOException {
+        // First make sure we have space.
+        acquire(srcLength);
+
+        // Read data until the requested number of bytes have been read.
+        int numBytes = 0;
+        do {
+            int readBytes = src.read(mBuffer, mIndex + mLength + numBytes, srcLength - numBytes);
+            if (readBytes == -1) {
+                throw new IOException();
+            }
+            numBytes += readBytes;
+        } while (numBytes != srcLength);
+        mLength += numBytes;
+    }
+}
diff --git a/obex/javax/obex/ObexHelper.java b/obex/javax/obex/ObexHelper.java
index 1b66662..7e02fd5 100644
--- a/obex/javax/obex/ObexHelper.java
+++ b/obex/javax/obex/ObexHelper.java
@@ -151,21 +151,22 @@ public final class ObexHelper {
      * exception to be thrown. When it is thrown, it is ignored.
      * @param header the HeaderSet to update
      * @param headerArray the byte array containing headers
-     * @return the result of the last start body or end body header provided;
-     *         the first byte in the result will specify if a body or end of
-     *         body is received
+     * @param bodyBuffer Buffer to return result in. Will be reset(). Can be null.
+     *   Will contain the result of the last start body or end body header provided;
+     *   the first byte in the result will specify if a body or end of body is received
+     * @param headerBuffer Buffer to use to avoid allocations. Will be reset().
      * @throws IOException if an invalid header was found
      */
-    public static byte[] updateHeaderSet(HeaderSet header, byte[] headerArray) throws IOException {
+    static void updateHeaderSet(HeaderSet header, ObexByteBuffer headerArray,
+            ObexByteBuffer bodyBuffer, ObexByteBuffer headerBuffer) throws IOException {
         int index = 0;
         int length = 0;
         int headerID;
         byte[] value = null;
-        byte[] body = null;
         HeaderSet headerImpl = header;
         try {
-            while (index < headerArray.length) {
-                headerID = 0xFF & headerArray[index];
+            while (index < headerArray.getLength()) {
+                headerID = 0xFF & headerArray.peek(index);
                 switch (headerID & (0xC0)) {
 
                     /*
@@ -181,14 +182,15 @@ public final class ObexHelper {
                     case 0x40:
                         boolean trimTail = true;
                         index++;
-                        length = 0xFF & headerArray[index];
+                        length = 0xFF & headerArray.peek(index);
                         length = length << 8;
                         index++;
-                        length += 0xFF & headerArray[index];
+                        length += 0xFF & headerArray.peek(index);
                         length -= 3;
                         index++;
-                        value = new byte[length];
-                        System.arraycopy(headerArray, index, value, 0, length);
+                        headerBuffer.reset();
+                        headerBuffer.write(headerArray, index, length);
+                        value = headerBuffer.getBytes();
                         if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
                             trimTail = false;
                         }
@@ -198,10 +200,10 @@ public final class ObexHelper {
                                     // Remove trailing null
                                     if (trimTail == false) {
                                         headerImpl.setHeader(headerID, new String(value, 0,
-                                                value.length, "ISO8859_1"));
+                                                length, "ISO8859_1"));
                                     } else {
                                         headerImpl.setHeader(headerID, new String(value, 0,
-                                                value.length - 1, "ISO8859_1"));
+                                                length - 1, "ISO8859_1"));
                                     }
                                 } catch (UnsupportedEncodingException e) {
                                     throw e;
@@ -210,27 +212,27 @@ public final class ObexHelper {
 
                             case HeaderSet.AUTH_CHALLENGE:
                                 headerImpl.mAuthChall = new byte[length];
-                                System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0,
-                                        length);
+                                headerArray.peek(index, headerImpl.mAuthChall);
                                 break;
 
                             case HeaderSet.AUTH_RESPONSE:
                                 headerImpl.mAuthResp = new byte[length];
-                                System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0,
-                                        length);
+                                headerArray.peek(index, headerImpl.mAuthResp);
                                 break;
 
                             case HeaderSet.BODY:
                                 /* Fall Through */
                             case HeaderSet.END_OF_BODY:
-                                body = new byte[length + 1];
-                                body[0] = (byte)headerID;
-                                System.arraycopy(headerArray, index, body, 1, length);
+                                if (bodyBuffer != null) {
+                                    bodyBuffer.reset();
+                                    bodyBuffer.write((byte)headerID);
+                                    bodyBuffer.write(headerArray, index, length);
+                                }
                                 break;
 
                             case HeaderSet.TIME_ISO_8601:
                                 try {
-                                    String dateString = new String(value, "ISO8859_1");
+                                    String dateString = new String(value, 0, length, "ISO8859_1");
                                     Calendar temp = Calendar.getInstance();
                                     if ((dateString.length() == 16)
                                             && (dateString.charAt(15) == 'Z')) {
@@ -257,9 +259,13 @@ public final class ObexHelper {
                             default:
                                 if ((headerID & 0xC0) == 0x00) {
                                     headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(
-                                            value, true));
+                                            value, length, true));
                                 } else {
-                                    headerImpl.setHeader(headerID, value);
+                                    // <value> is reused and can contain garbage after [length-1].
+                                    // Copy wanted data to temporary array.
+                                    byte[] otherValue = new byte[length];
+                                    System.arraycopy(value, 0, otherValue, 0, length);
+                                    headerImpl.setHeader(headerID, otherValue);
                                 }
                         }
 
@@ -273,7 +279,7 @@ public final class ObexHelper {
                     case 0x80:
                         index++;
                         try {
-                            headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
+                            headerImpl.setHeader(headerID, Byte.valueOf(headerArray.peek(index)));
                         } catch (Exception e) {
                             // Not a valid header so ignore
                         }
@@ -288,7 +294,7 @@ public final class ObexHelper {
                     case 0xC0:
                         index++;
                         value = new byte[4];
-                        System.arraycopy(headerArray, index, value, 0, 4);
+                        headerArray.peek(index, value);
                         try {
                             if (headerID != HeaderSet.TIME_4_BYTE) {
                                 // Determine if it is a connection ID.  These
@@ -317,8 +323,6 @@ public final class ObexHelper {
         } catch (IOException e) {
             throw new IOException("Header was not formatted properly");
         }
-
-        return body;
     }
 
     /**
@@ -874,11 +878,11 @@ public final class ObexHelper {
      * @return a Unicode string
      * @throws IllegalArgumentException if the byte array has an odd length
      */
-    public static String convertToUnicode(byte[] b, boolean includesNull) {
-        if (b == null || b.length == 0) {
+    public static String convertToUnicode(byte[] b, int len, boolean includesNull) {
+        if (b == null || len == 0) {
             return null;
         }
-        int arrayLength = b.length;
+        int arrayLength = len;
         if (!((arrayLength % 2) == 0)) {
             throw new IllegalArgumentException("Byte array not of a valid form");
         }
diff --git a/obex/javax/obex/ObexSession.java b/obex/javax/obex/ObexSession.java
index a7daeb5..6c4ba43 100644
--- a/obex/javax/obex/ObexSession.java
+++ b/obex/javax/obex/ObexSession.java
@@ -98,7 +98,7 @@ public class ObexSession {
 
                 case ObexHelper.OBEX_AUTH_REALM_CHARSET_UNICODE:
                     // UNICODE Encoding
-                    realm = ObexHelper.convertToUnicode(realmString, false);
+                    realm = ObexHelper.convertToUnicode(realmString, realmString.length, false);
                     break;
 
                 default:
diff --git a/obex/javax/obex/Operation.java b/obex/javax/obex/Operation.java
index 25656ed..05cecc5 100644
--- a/obex/javax/obex/Operation.java
+++ b/obex/javax/obex/Operation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2009, Motorola, Inc.
+ * Copyright (c) 2010-2011, Motorola, Inc.
  *
  * All rights reserved.
  *
@@ -175,6 +175,8 @@ public interface Operation {
 
     DataOutputStream openDataOutputStream() throws IOException;
 
+    void noEndofBody();
+
     void close() throws IOException;
 
     int getMaxPacketSize();
diff --git a/obex/javax/obex/PrivateInputStream.java b/obex/javax/obex/PrivateInputStream.java
index 5daee72..2bcf541 100644
--- a/obex/javax/obex/PrivateInputStream.java
+++ b/obex/javax/obex/PrivateInputStream.java
@@ -44,9 +44,7 @@ public final class PrivateInputStream extends InputStream {
 
     private BaseStream mParent;
 
-    private byte[] mData;
-
-    private int mIndex;
+    private ObexByteBuffer mBuffer;
 
     private boolean mOpen;
 
@@ -56,8 +54,7 @@ public final class PrivateInputStream extends InputStream {
      */
     public PrivateInputStream(BaseStream p) {
         mParent = p;
-        mData = new byte[0];
-        mIndex = 0;
+        mBuffer = new ObexByteBuffer(0);
         mOpen = true;
     }
 
@@ -73,7 +70,7 @@ public final class PrivateInputStream extends InputStream {
     @Override
     public synchronized int available() throws IOException {
         ensureOpen();
-        return mData.length - mIndex;
+        return mBuffer.getLength();
     }
 
     /**
@@ -89,12 +86,12 @@ public final class PrivateInputStream extends InputStream {
     @Override
     public synchronized int read() throws IOException {
         ensureOpen();
-        while (mData.length == mIndex) {
+        while (mBuffer.getLength() == 0) {
             if (!mParent.continueOperation(true, true)) {
                 return -1;
             }
         }
-        return (mData[mIndex++] & 0xFF);
+        return (mBuffer.read() & 0xFF);
     }
 
     @Override
@@ -113,26 +110,23 @@ public final class PrivateInputStream extends InputStream {
         }
         ensureOpen();
 
-        int currentDataLength = mData.length - mIndex;
         int remainReadLength = length;
         int offset1 = offset;
         int result = 0;
 
-        while (currentDataLength <= remainReadLength) {
-            System.arraycopy(mData, mIndex, b, offset1, currentDataLength);
-            mIndex += currentDataLength;
-            offset1 += currentDataLength;
-            result += currentDataLength;
-            remainReadLength -= currentDataLength;
+        while (mBuffer.getLength() <= remainReadLength) {
+            int readBytes = mBuffer.read(b, offset1);
+
+            offset1 += readBytes;
+            result += readBytes;
+            remainReadLength -= readBytes;
 
             if (!mParent.continueOperation(true, true)) {
                 return result == 0 ? -1 : result;
             }
-            currentDataLength = mData.length - mIndex;
         }
         if (remainReadLength > 0) {
-            System.arraycopy(mData, mIndex, b, offset1, remainReadLength);
-            mIndex += remainReadLength;
+            mBuffer.read(b, offset1, remainReadLength);
             result += remainReadLength;
         }
         return result;
@@ -144,16 +138,8 @@ public final class PrivateInputStream extends InputStream {
      * @param body the data to add to the stream
      * @param start the start of the body to array to copy
      */
-    public synchronized void writeBytes(byte[] body, int start) {
-
-        int length = (body.length - start) + (mData.length - mIndex);
-        byte[] temp = new byte[length];
-
-        System.arraycopy(mData, mIndex, temp, 0, mData.length - mIndex);
-        System.arraycopy(body, start, temp, mData.length - mIndex, body.length - start);
-
-        mData = temp;
-        mIndex = 0;
+    public synchronized void writeBytes(ObexByteBuffer body, int start) {
+        mBuffer.write(body, start);
         notifyAll();
     }
 
diff --git a/obex/javax/obex/PrivateOutputStream.java b/obex/javax/obex/PrivateOutputStream.java
index ca420af..06dd55e 100644
--- a/obex/javax/obex/PrivateOutputStream.java
+++ b/obex/javax/obex/PrivateOutputStream.java
@@ -34,7 +34,6 @@ package javax.obex;
 
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.ByteArrayOutputStream;
 
 /**
  * This object provides an output stream to the Operation objects used in this
@@ -45,7 +44,7 @@ public final class PrivateOutputStream extends OutputStream {
 
     private BaseStream mParent;
 
-    private ByteArrayOutputStream mArray;
+    private ObexByteBuffer mBuffer;
 
     private boolean mOpen;
 
@@ -57,7 +56,7 @@ public final class PrivateOutputStream extends OutputStream {
      */
     public PrivateOutputStream(BaseStream p, int maxSize) {
         mParent = p;
-        mArray = new ByteArrayOutputStream();
+        mBuffer = new ObexByteBuffer(32);
         mMaxPacketSize = maxSize;
         mOpen = true;
     }
@@ -67,7 +66,7 @@ public final class PrivateOutputStream extends OutputStream {
      * @return the number of bytes written to the output stream
      */
     public int size() {
-        return mArray.size();
+        return mBuffer.getLength();
     }
 
     /**
@@ -82,8 +81,8 @@ public final class PrivateOutputStream extends OutputStream {
     public synchronized void write(int b) throws IOException {
         ensureOpen();
         mParent.ensureNotDone();
-        mArray.write(b);
-        if (mArray.size() == mMaxPacketSize) {
+        mBuffer.write((byte)b);
+        if (mBuffer.getLength() == mMaxPacketSize) {
             mParent.continueOperation(true, false);
         }
     }
@@ -108,38 +107,30 @@ public final class PrivateOutputStream extends OutputStream {
         ensureOpen();
         mParent.ensureNotDone();
         if (count < mMaxPacketSize) {
-            mArray.write(buffer, offset, count);
+            mBuffer.write(buffer, offset, count);
         } else {
             while (remainLength >= mMaxPacketSize) {
-                mArray.write(buffer, offset1, mMaxPacketSize);
+                mBuffer.write(buffer, offset1, mMaxPacketSize);
                 offset1 += mMaxPacketSize;
                 remainLength = count - offset1;
                 mParent.continueOperation(true, false);
             }
             if (remainLength > 0) {
-                mArray.write(buffer, offset1, remainLength);
+                mBuffer.write(buffer, offset1, remainLength);
             }
         }
     }
 
     /**
-     * Reads the bytes that have been written to this stream.
-     * @param size the size of the array to return
-     * @return the byte array that is written
+     * Write some of the bytes that have been written to this stream to
+     * an ObexByteBuffer.
+     *
+     * @param dest the stream to write to
+     * @param start where to write in the byte array
+     * @param size the number of bytes to write to the byte array
      */
-    public synchronized byte[] readBytes(int size) {
-        if (mArray.size() > 0) {
-            byte[] temp = mArray.toByteArray();
-            mArray.reset();
-            byte[] result = new byte[size];
-            System.arraycopy(temp, 0, result, 0, size);
-            if (temp.length != size) {
-                mArray.write(temp, size, temp.length - size);
-            }
-            return result;
-        } else {
-            return null;
-        }
+    public synchronized void writeTo(ObexByteBuffer dest, int size) throws IOException {
+        mBuffer.read(dest, size);
     }
 
     /**
diff --git a/obex/javax/obex/ServerOperation.java b/obex/javax/obex/ServerOperation.java
index 07a3a53..b94a5f5 100644
--- a/obex/javax/obex/ServerOperation.java
+++ b/obex/javax/obex/ServerOperation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2009, Motorola, Inc.
+ * Copyright (c) 2010-2011, Motorola, Inc.
  *
  * All rights reserved.
  *
@@ -37,7 +37,6 @@ import java.io.InputStream;
 import java.io.DataInputStream;
 import java.io.OutputStream;
 import java.io.DataOutputStream;
-import java.io.ByteArrayOutputStream;
 
 /**
  * This class implements the Operation interface for server side connections.
@@ -88,6 +87,14 @@ public final class ServerOperation implements Operation, BaseStream {
 
     private boolean mHasBody;
 
+    private ObexByteBuffer mData;
+
+    private ObexByteBuffer mBodyBuffer;
+
+    private ObexByteBuffer mHeaderBuffer;
+
+    private boolean mEndofBody = true;
+
     /**
      * Creates new ServerOperation
      * @param p the parent that created this object
@@ -114,7 +121,10 @@ public final class ServerOperation implements Operation, BaseStream {
         mRequestFinished = false;
         mPrivateOutputOpen = false;
         mHasBody = false;
-        int bytesReceived;
+
+        mData = new ObexByteBuffer(32);
+        mBodyBuffer = new ObexByteBuffer(32);
+        mHeaderBuffer = new ObexByteBuffer(32);
 
         /*
          * Determine if this is a PUT request
@@ -165,16 +175,12 @@ public final class ServerOperation implements Operation, BaseStream {
          * Determine if any headers were sent in the initial request
          */
         if (length > 3) {
-            byte[] data = new byte[length - 3];
-            bytesReceived = in.read(data);
+            mData.reset();
+            mData.write(in, length - 3);
 
-            while (bytesReceived != data.length) {
-                bytesReceived += in.read(data, bytesReceived, data.length - bytesReceived);
-            }
-
-            byte[] body = ObexHelper.updateHeaderSet(requestHeader, data);
+            ObexHelper.updateHeaderSet(requestHeader, mData, mBodyBuffer, mHeaderBuffer);
 
-            if (body != null) {
+            if (mBodyBuffer.getLength() > 0) {
                 mHasBody = true;
             }
 
@@ -205,8 +211,8 @@ public final class ServerOperation implements Operation, BaseStream {
 
             }
 
-            if (body != null) {
-                mPrivateInput.writeBytes(body, 1);
+            if (mBodyBuffer.getLength() > 0) {
+                mPrivateInput.writeBytes(mBodyBuffer, 1);
             } else {
                 while ((!mGetOperation) && (!finalBitSet)) {
                     sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
@@ -281,8 +287,7 @@ public final class ServerOperation implements Operation, BaseStream {
      * @throws IOException if an IO error occurs
      */
     public synchronized boolean sendReply(int type) throws IOException {
-        ByteArrayOutputStream out = new ByteArrayOutputStream();
-        int bytesReceived;
+        mBodyBuffer.reset();
 
         long id = mListener.getConnectionId();
         if (id == -1) {
@@ -322,10 +327,10 @@ public final class ServerOperation implements Operation, BaseStream {
                     mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
                     throw new IOException("OBEX Packet exceeds max packet size");
                 }
-                byte[] sendHeader = new byte[end - start];
-                System.arraycopy(headerArray, start, sendHeader, 0, sendHeader.length);
+                mHeaderBuffer.reset();
+                mHeaderBuffer.write(headerArray, start, end - start);
 
-                mParent.sendResponse(type, sendHeader);
+                mParent.sendResponse(type, mHeaderBuffer);
                 start = end;
             }
 
@@ -336,7 +341,7 @@ public final class ServerOperation implements Operation, BaseStream {
             }
 
         } else {
-            out.write(headerArray);
+            mBodyBuffer.write(headerArray);
         }
 
         // For Get operation: if response code is OBEX_HTTP_OK, then this is the
@@ -356,36 +361,40 @@ public final class ServerOperation implements Operation, BaseStream {
                     bodyLength = mMaxPacketLength - headerArray.length - 6;
                 }
 
-                byte[] body = mPrivateOutput.readBytes(bodyLength);
-
                 /*
                  * Since this is a put request if the final bit is set or
                  * the output stream is closed we need to send the 0x49
                  * (End of Body) otherwise, we need to send 0x48 (Body)
                  */
                 if ((finalBitSet) || (mPrivateOutput.isClosed())) {
-                    out.write(0x49);
+                    if (mEndofBody) {
+                        mBodyBuffer.write((byte)0x49);
+                        bodyLength += 3;
+                        mBodyBuffer.write((byte)(bodyLength >> 8));
+                        mBodyBuffer.write((byte)bodyLength);
+                        mPrivateOutput.writeTo(mBodyBuffer, bodyLength - 3);
+		    }
                 } else {
-                    out.write(0x48);
+                    mBodyBuffer.write((byte)0x48);
+                    bodyLength += 3;
+                    mBodyBuffer.write((byte)(bodyLength >> 8));
+                    mBodyBuffer.write((byte)bodyLength);
+                    mPrivateOutput.writeTo(mBodyBuffer, bodyLength - 3);
                 }
-
-                bodyLength += 3;
-                out.write((byte)(bodyLength >> 8));
-                out.write((byte)bodyLength);
-                out.write(body);
             }
         }
 
         if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
-            out.write(0x49);
-            orginalBodyLength = 3;
-            out.write((byte)(orginalBodyLength >> 8));
-            out.write((byte)orginalBodyLength);
-
+            if (mEndofBody) {
+                mBodyBuffer.write((byte)0x49);
+                orginalBodyLength = 3;
+                mBodyBuffer.write((byte)(orginalBodyLength >> 8));
+                mBodyBuffer.write((byte)orginalBodyLength);
+            }
         }
 
         mResponseSize = 3;
-        mParent.sendResponse(type, out.toByteArray());
+        mParent.sendResponse(type, mBodyBuffer);
 
         if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
             int headerID = mInput.read();
@@ -397,12 +406,9 @@ public final class ServerOperation implements Operation, BaseStream {
                     && (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
 
                 if (length > 3) {
-                    byte[] temp = new byte[length];
-                    bytesReceived = mInput.read(temp);
-
-                    while (bytesReceived != length) {
-                        bytesReceived += mInput.read(temp, bytesReceived, length - bytesReceived);
-                    }
+                   mData.reset();
+                    // First three bytes already read, compensating for this
+                    mData.write(mInput, length - 3);
                 }
 
                 /*
@@ -440,17 +446,14 @@ public final class ServerOperation implements Operation, BaseStream {
                  * Determine if any headers were sent in the initial request
                  */
                 if (length > 3) {
-                    byte[] data = new byte[length - 3];
-                    bytesReceived = mInput.read(data);
+                    mData.reset();
+                    mData.write(mInput, length - 3);
 
-                    while (bytesReceived != data.length) {
-                        bytesReceived += mInput.read(data, bytesReceived, data.length
-                                - bytesReceived);
-                    }
-                    byte[] body = ObexHelper.updateHeaderSet(requestHeader, data);
-                    if (body != null) {
+                    ObexHelper.updateHeaderSet(requestHeader, mData, mBodyBuffer, mHeaderBuffer);
+                    if (mBodyBuffer.getLength() > 0) {
                         mHasBody = true;
                     }
+
                     if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
                         mListener.setConnectionId(ObexHelper
                                 .convertToLong(requestHeader.mConnectionID));
@@ -479,8 +482,8 @@ public final class ServerOperation implements Operation, BaseStream {
                         requestHeader.mAuthChall = null;
                     }
 
-                    if (body != null) {
-                        mPrivateInput.writeBytes(body, 1);
+                    if (mBodyBuffer.getLength() > 0) {
+                        mPrivateInput.writeBytes(mBodyBuffer, 1);
                     }
                 }
             }
@@ -709,4 +712,9 @@ public final class ServerOperation implements Operation, BaseStream {
     public void streamClosed(boolean inStream) throws IOException {
 
     }
+
+    public void noEndofBody() {
+        mEndofBody = false;
+    }
+
 }
diff --git a/obex/javax/obex/ServerSession.java b/obex/javax/obex/ServerSession.java
index a4b9759..694c8a9 100644
--- a/obex/javax/obex/ServerSession.java
+++ b/obex/javax/obex/ServerSession.java
@@ -60,6 +60,10 @@ public final class ServerSession extends ObexSession implements Runnable {
 
     private boolean mClosed;
 
+    private ObexByteBuffer mData;
+
+    private ObexByteBuffer mHeaderBuffer;
+
     /**
      * Creates new ServerSession.
      * @param trans the connection to the client
@@ -80,6 +84,9 @@ public final class ServerSession extends ObexSession implements Runnable {
         mClosed = false;
         mProcessThread = new Thread(this);
         mProcessThread.start();
+
+        mData = new ObexByteBuffer(32);
+        mHeaderBuffer = new ObexByteBuffer(32);
     }
 
     /**
@@ -253,24 +260,22 @@ public final class ServerSession extends ObexSession implements Runnable {
      * @param header the headers to include in the response
      * @throws IOException if an IO error occurs
      */
-    public void sendResponse(int code, byte[] header) throws IOException {
+    public void sendResponse(int code, ObexByteBuffer header) throws IOException {
         int totalLength = 3;
-        byte[] data = null;
+        mData.reset();
 
         if (header != null) {
-            totalLength += header.length;
-            data = new byte[totalLength];
-            data[0] = (byte)code;
-            data[1] = (byte)(totalLength >> 8);
-            data[2] = (byte)totalLength;
-            System.arraycopy(header, 0, data, 3, header.length);
+            totalLength += header.getLength();
+            mData.write((byte)code);
+            mData.write((byte)(totalLength >> 8));
+            mData.write((byte)totalLength);
+            mData.write(header);
         } else {
-            data = new byte[totalLength];
-            data[0] = (byte)code;
-            data[1] = (byte)0x00;
-            data[2] = (byte)totalLength;
+            mData.write((byte)code);
+            mData.write((byte)0x00);
+            mData.write((byte)totalLength);
         }
-        mOutput.write(data);
+        mData.read(mOutput);
         mOutput.flush();
     }
 
@@ -291,7 +296,6 @@ public final class ServerSession extends ObexSession implements Runnable {
         int totalLength = 3;
         byte[] head = null;
         int code = -1;
-        int bytesReceived;
         HeaderSet request = new HeaderSet();
         HeaderSet reply = new HeaderSet();
 
@@ -305,15 +309,10 @@ public final class ServerSession extends ObexSession implements Runnable {
             totalLength = 3;
         } else {
             if (length > 5) {
-                byte[] headers = new byte[length - 5];
-                bytesReceived = mInput.read(headers);
+                mData.reset();
+                mData.write(mInput, length - 5);
 
-                while (bytesReceived != headers.length) {
-                    bytesReceived += mInput.read(headers, bytesReceived, headers.length
-                            - bytesReceived);
-                }
-
-                ObexHelper.updateHeaderSet(request, headers);
+                ObexHelper.updateHeaderSet(request, mData, null, mHeaderBuffer);
 
                 if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
                     mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
@@ -386,18 +385,18 @@ public final class ServerSession extends ObexSession implements Runnable {
         }
 
         // Compute Length of OBEX SETPATH packet
-        byte[] replyData = new byte[totalLength];
-        replyData[0] = (byte)code;
-        replyData[1] = (byte)(totalLength >> 8);
-        replyData[2] = (byte)totalLength;
+        mData.reset();
+        mData.write((byte)code);
+        mData.write((byte)(totalLength >> 8));
+        mData.write((byte)totalLength);
         if (head != null) {
-            System.arraycopy(head, 0, replyData, 3, head.length);
+            mData.write(head);
         }
         /*
          * Write the OBEX SETPATH packet to the server. Byte 0: response code
          * Byte 1&2: Connect Packet Length Byte 3 to n: headers
          */
-        mOutput.write(replyData);
+        mData.read(mOutput);
         mOutput.flush();
     }
 
@@ -414,7 +413,6 @@ public final class ServerSession extends ObexSession implements Runnable {
         int code = ResponseCodes.OBEX_HTTP_OK;
         int totalLength = 3;
         byte[] head = null;
-        int bytesReceived;
         HeaderSet request = new HeaderSet();
         HeaderSet reply = new HeaderSet();
 
@@ -426,15 +424,10 @@ public final class ServerSession extends ObexSession implements Runnable {
             totalLength = 3;
         } else {
             if (length > 3) {
-                byte[] headers = new byte[length - 3];
-                bytesReceived = mInput.read(headers);
-
-                while (bytesReceived != headers.length) {
-                    bytesReceived += mInput.read(headers, bytesReceived, headers.length
-                            - bytesReceived);
-                }
+                mData.reset();
+                mData.write(mInput, length - 3);
 
-                ObexHelper.updateHeaderSet(request, headers);
+                ObexHelper.updateHeaderSet(request, mData, null, mHeaderBuffer);
             }
 
             if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
@@ -485,23 +478,18 @@ public final class ServerSession extends ObexSession implements Runnable {
         }
 
         // Compute Length of OBEX CONNECT packet
-        byte[] replyData;
-        if (head != null) {
-            replyData = new byte[3 + head.length];
-        } else {
-            replyData = new byte[3];
-        }
-        replyData[0] = (byte)code;
-        replyData[1] = (byte)(totalLength >> 8);
-        replyData[2] = (byte)totalLength;
+        mData.reset();
+        mData.write((byte)code);
+        mData.write((byte)(totalLength >> 8));
+        mData.write((byte)totalLength);
         if (head != null) {
-            System.arraycopy(head, 0, replyData, 3, head.length);
+            mData.write(head);
         }
         /*
          * Write the OBEX DISCONNECT packet to the server. Byte 0: response code
          * Byte 1&2: Connect Packet Length Byte 3 to n: headers
          */
-        mOutput.write(replyData);
+        mData.read(mOutput);
         mOutput.flush();
     }
 
@@ -525,7 +513,6 @@ public final class ServerSession extends ObexSession implements Runnable {
         int code = -1;
         HeaderSet request = new HeaderSet();
         HeaderSet reply = new HeaderSet();
-        int bytesReceived;
 
         /*
          * Read in the length of the OBEX packet, OBEX version, flags, and max
@@ -548,15 +535,10 @@ public final class ServerSession extends ObexSession implements Runnable {
             totalLength = 7;
         } else {
             if (packetLength > 7) {
-                byte[] headers = new byte[packetLength - 7];
-                bytesReceived = mInput.read(headers);
-
-                while (bytesReceived != headers.length) {
-                    bytesReceived += mInput.read(headers, bytesReceived, headers.length
-                            - bytesReceived);
-                }
+                mData.reset();
+                mData.write(mInput, packetLength - 7);
 
-                ObexHelper.updateHeaderSet(request, headers);
+                ObexHelper.updateHeaderSet(request, mData, null, mHeaderBuffer);
             }
 
             if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
diff --git a/opengl/include/EGL/eglext.h b/opengl/include/EGL/eglext.h
index 1ffcd56..b121158 100644
--- a/opengl/include/EGL/eglext.h
+++ b/opengl/include/EGL/eglext.h
@@ -229,6 +229,14 @@ struct android_native_buffer_t;
 #define EGL_NATIVE_BUFFER_ANDROID       0x3140  /* eglCreateImageKHR target */
 #endif
 
+#ifndef EGL_ANDROID_get_render_buffer
+#define EGL_ANDROID_get_render_buffer 1
+#ifdef EGL_EGLEXT_PROTOTYPES
+EGLAPI EGLClientBuffer EGLAPIENTRY eglGetRenderBufferANDROID(EGLDisplay dpy, EGLSurface draw);
+#endif
+typedef EGLClientBuffer (EGLAPIENTRYP PFNEGLGETRENDERBUFFERANDROIDPROC) (EGLDisplay dpy, EGLSurface draw);
+#endif
+
 #ifndef EGL_ANDROID_swap_rectangle
 #define EGL_ANDROID_swap_rectangle 1
 #ifdef EGL_EGLEXT_PROTOTYPES
diff --git a/opengl/java/android/opengl/GLSurfaceView.java b/opengl/java/android/opengl/GLSurfaceView.java
index 41207f7..f6d4db4 100644
--- a/opengl/java/android/opengl/GLSurfaceView.java
+++ b/opengl/java/android/opengl/GLSurfaceView.java
@@ -36,6 +36,7 @@ import android.util.AttributeSet;
 import android.util.Log;
 import android.view.SurfaceHolder;
 import android.view.SurfaceView;
+import android.view.Surface;
 
 /**
  * An implementation of SurfaceView that uses the dedicated surface for
@@ -1389,7 +1390,12 @@ public class GLSurfaceView extends SurfaceView implements SurfaceHolder.Callback
         }
 
         private boolean readyToDraw() {
-            return (!mPaused) && mHasSurface
+            boolean isSurfaceValid = false;
+            if(mHasSurface){
+                Surface sur = getHolder().getSurface();
+                if(sur.isValid())isSurfaceValid = true;
+            }
+            return (!mPaused) && isSurfaceValid
                 && (mWidth > 0) && (mHeight > 0)
                 && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY));
         }
diff --git a/opengl/libagl/Android.mk b/opengl/libagl/Android.mk
index b5c018f..04d6d31 100644
--- a/opengl/libagl/Android.mk
+++ b/opengl/libagl/Android.mk
@@ -12,7 +12,7 @@ LOCAL_SRC_FILES:= \
 	texture.cpp		            \
     Tokenizer.cpp               \
     TokenManager.cpp            \
-    TextureObjectManager.cpp    \
+    TextureObjectManager.cpp.arm    \
     BufferObjectManager.cpp     \
 	array.cpp.arm		        \
 	fp.cpp.arm		            \
@@ -45,9 +45,19 @@ ifneq ($(TARGET_SIMULATOR),true)
     ifeq ($(TARGET_ARCH)-$(ARCH_ARM_HAVE_TLS_REGISTER),arm-true)
         LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
     endif
+    ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+        LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+    endif
     LOCAL_C_INCLUDES += bionic/libc/private
 endif
 
+ifneq ($(TARGET_LIBAGL_USE_GRALLOC_COPYBITS),)
+    LOCAL_CFLAGS += -DLIBAGL_USE_GRALLOC_COPYBITS
+    LOCAL_SRC_FILES += copybit.cpp
+    LOCAL_SHARED_LIBRARIES += libui
+endif
+
+
 LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/egl
 LOCAL_MODULE:= libGLES_android
 
diff --git a/opengl/libagl/TextureObjectManager.cpp b/opengl/libagl/TextureObjectManager.cpp
index bbb82fc..255ccac 100644
--- a/opengl/libagl/TextureObjectManager.cpp
+++ b/opengl/libagl/TextureObjectManager.cpp
@@ -55,6 +55,9 @@ void EGLTextureObject::init()
     memset(crop_rect, 0, sizeof(crop_rect));
     generate_mipmap = GL_FALSE;
     direct = GL_FALSE;
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    try_copybit = false;
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
     buffer = 0;
 }
 
diff --git a/opengl/libagl/TextureObjectManager.h b/opengl/libagl/TextureObjectManager.h
index 70e3bef..279e040 100644
--- a/opengl/libagl/TextureObjectManager.h
+++ b/opengl/libagl/TextureObjectManager.h
@@ -80,6 +80,9 @@ public:
     GLint               crop_rect[4];
     GLint               generate_mipmap;
     GLint               direct;
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    bool                try_copybit;
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
     android_native_buffer_t* buffer;
 };
 
diff --git a/opengl/libagl/array.cpp b/opengl/libagl/array.cpp
index 7fbe9b5..f96dee4 100644
--- a/opengl/libagl/array.cpp
+++ b/opengl/libagl/array.cpp
@@ -26,6 +26,9 @@
 #include "primitives.h"
 #include "texture.h"
 #include "BufferObjectManager.h"
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+#include "copybit.h"
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
 
 // ----------------------------------------------------------------------------
 
@@ -704,6 +707,12 @@ void drawPrimitivesTriangleStrip(ogles_context_t* c,
 
 void drawPrimitivesTriangleFan(ogles_context_t* c,
         GLint first, GLsizei count) {
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    if (drawTriangleFanWithCopybit(c, first, count)) {
+        return;
+    }
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
+
     drawPrimitivesTriangleFanOrStrip(c, first, count, 2);
 }
 
diff --git a/opengl/libagl/copybit.cpp b/opengl/libagl/copybit.cpp
new file mode 100644
index 0000000..0c07bb3
--- /dev/null
+++ b/opengl/libagl/copybit.cpp
@@ -0,0 +1,618 @@
+/*
+**
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "context.h"
+#include "fp.h"
+#include "state.h"
+#include "matrix.h"
+#include "vertex.h"
+#include "light.h"
+#include "primitives.h"
+#include "texture.h"
+#include "BufferObjectManager.h"
+#include "TextureObjectManager.h"
+
+#include <hardware/gralloc.h>
+#include <hardware/copybit.h>
+#include <private/ui/android_natives_priv.h>
+
+#include <ui/GraphicBuffer.h>
+#include <ui/Region.h>
+#include <ui/Rect.h>
+
+
+#define DEBUG_COPYBIT false
+
+// ----------------------------------------------------------------------------
+
+namespace android {
+
+static void textureToCopyBitImage(
+        const GGLSurface* surface, int32_t opFormat, 
+        android_native_buffer_t* buffer, copybit_image_t* img)
+{
+    img->w      = surface->stride;
+    img->h      = surface->height;
+    img->format = opFormat;
+    img->base   = surface->data;
+    img->handle = (native_handle_t *)buffer->handle;
+}
+
+struct clipRectRegion : public copybit_region_t {
+    clipRectRegion(ogles_context_t* c) 
+    {
+        scissor_t const* scissor = &c->rasterizer.state.scissor;
+        r.l = scissor->left;
+        r.t = scissor->top;
+        r.r = scissor->right;
+        r.b = scissor->bottom;
+        next = iterate; 
+    }
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
+        *rect = static_cast<clipRectRegion const*>(self)->r;
+        const_cast<copybit_region_t *>(self)->next = iterate_done;
+        return 1;
+    }
+    static int iterate_done(copybit_region_t const *, copybit_rect_t*) {
+        return 0;
+    }
+public:
+    copybit_rect_t r;
+};
+
+static bool supportedCopybitsFormat(int format) {
+    switch (format) {
+    case COPYBIT_FORMAT_RGBA_8888:
+    case COPYBIT_FORMAT_RGBX_8888:
+    case COPYBIT_FORMAT_RGB_888:
+    case COPYBIT_FORMAT_RGB_565:
+    case COPYBIT_FORMAT_BGRA_8888:
+    case COPYBIT_FORMAT_RGBA_5551:
+    case COPYBIT_FORMAT_RGBA_4444:
+        return true;
+    default:
+        return false;
+    }
+}
+
+static bool hasAlpha(int format) {
+    switch (format) {
+    case COPYBIT_FORMAT_RGBA_8888:
+    case COPYBIT_FORMAT_BGRA_8888:
+    case COPYBIT_FORMAT_RGBA_5551:
+    case COPYBIT_FORMAT_RGBA_4444:
+        return true;
+    default:
+        return false;
+    }
+}
+
+static inline int fixedToByte(GGLfixed val) {
+    return (val - (val >> 8)) >> 8;
+}
+
+/**
+ * Performs a quick check of the rendering state. If this function returns
+ * false we cannot use the copybit driver.
+ */
+
+static bool checkContext(ogles_context_t* c) {
+
+	// By convention copybitQuickCheckContext() has already returned true.
+	// avoid checking the same information again.
+	
+    if (c->copybits.blitEngine == NULL) {
+        LOGD_IF(DEBUG_COPYBIT, "no copybit hal");
+        return false;
+    }
+
+    if (c->rasterizer.state.enables
+                    & (GGL_ENABLE_DEPTH_TEST|GGL_ENABLE_FOG)) {
+        LOGD_IF(DEBUG_COPYBIT, "depth test and/or fog");
+        return false;
+    }
+
+    // Note: The drawSurfaceBuffer is only set for destination
+    // surfaces types that are supported by the hardware and
+    // do not have an alpha channel. So we don't have to re-check that here.
+
+    static const int tmu = 0;
+    texture_unit_t& u(c->textures.tmu[tmu]);
+    EGLTextureObject* textureObject = u.texture;
+
+    if (!supportedCopybitsFormat(textureObject->surface.format)) {
+        LOGD_IF(DEBUG_COPYBIT, "texture format not supported");
+        return false;
+    }
+    return true;
+}
+
+
+static bool copybit(GLint x, GLint y,
+        GLint w, GLint h,
+        EGLTextureObject* textureObject,
+        const GLint* crop_rect,
+        int transform,
+        ogles_context_t* c)
+{
+    status_t err = NO_ERROR;
+
+    // We assume checkContext has already been called and has already
+    // returned true.
+
+    const GGLSurface& cbSurface = c->rasterizer.state.buffers.color.s;
+
+    y = cbSurface.height - (y + h);
+
+    const GLint Ucr = crop_rect[0];
+    const GLint Vcr = crop_rect[1];
+    const GLint Wcr = crop_rect[2];
+    const GLint Hcr = crop_rect[3];
+
+    GLint screen_w = w;
+    GLint screen_h = h;
+    int32_t dsdx = Wcr << 16;   // dsdx =  ((Wcr/screen_w)/Wt)*Wt
+    int32_t dtdy = Hcr << 16;   // dtdy = -((Hcr/screen_h)/Ht)*Ht
+    if (transform & COPYBIT_TRANSFORM_ROT_90) {
+        swap(screen_w, screen_h);
+    }
+    if (dsdx!=screen_w || dtdy!=screen_h) {
+        // in most cases the divide is not needed
+        dsdx /= screen_w;
+        dtdy /= screen_h;
+    }
+    dtdy = -dtdy; // see equation of dtdy above
+
+    // copybit doesn't say anything about filtering, so we can't
+    // discriminate. On msm7k, copybit will always filter.
+    // the code below handles min/mag filters, we keep it as a reference.
+    
+#ifdef MIN_MAG_FILTER
+    int32_t texelArea = gglMulx(dtdy, dsdx);
+    if (texelArea < FIXED_ONE && textureObject->mag_filter != GL_LINEAR) {
+        // Non-linear filtering on a texture enlargement.
+        LOGD_IF(DEBUG_COPYBIT, "mag filter is not GL_LINEAR");
+        return false;
+    }
+    if (texelArea > FIXED_ONE && textureObject->min_filter != GL_LINEAR) {
+        // Non-linear filtering on an texture shrink.
+        LOGD_IF(DEBUG_COPYBIT, "min filter is not GL_LINEAR");
+        return false;
+    }
+#endif
+    
+    const uint32_t enables = c->rasterizer.state.enables;
+    int planeAlpha = 255;
+    bool alphaPlaneWorkaround = false;
+    static const int tmu = 0;
+    texture_t& tev(c->rasterizer.state.texture[tmu]);
+    int32_t opFormat = textureObject->surface.format;
+    const bool srcTextureHasAlpha = hasAlpha(opFormat);
+    if (!srcTextureHasAlpha) {
+        planeAlpha = fixedToByte(c->currentColorClamped.a);
+    }
+
+    const bool cbHasAlpha = hasAlpha(cbSurface.format);
+    bool blending = false;
+    if ((enables & GGL_ENABLE_BLENDING)
+            && !(c->rasterizer.state.blend.src == GL_ONE
+                    && c->rasterizer.state.blend.dst == GL_ZERO)) {
+        // Blending is OK if it is
+        // the exact kind of blending that the copybits hardware supports.
+        // Note: The hardware only supports
+        // GL_SRC_ALPHA / GL_ONE_MINUS_SRC_ALPHA,
+        // But the surface flinger uses GL_ONE / GL_ONE_MINUS_SRC_ALPHA.
+        // We substitute GL_SRC_ALPHA / GL_ONE_MINUS_SRC_ALPHA in that case,
+        // because the performance is worth it, even if the results are
+        // not correct.
+        if (!((c->rasterizer.state.blend.src == GL_SRC_ALPHA
+                || c->rasterizer.state.blend.src == GL_ONE)
+                && c->rasterizer.state.blend.dst == GL_ONE_MINUS_SRC_ALPHA
+                && c->rasterizer.state.blend.alpha_separate == 0)) {
+            // Incompatible blend mode.
+            LOGD_IF(DEBUG_COPYBIT, "incompatible blend mode");
+            return false;
+        }
+        blending = true;
+    } else {
+        if (cbHasAlpha) {
+            // NOTE: the result will be slightly wrong in this case because
+            // the destination alpha channel will be set to 1.0 instead of
+            // the iterated alpha value. *shrug*.
+        }
+        // disable plane blending and src blending for supported formats
+        planeAlpha = 255;
+        if (opFormat == COPYBIT_FORMAT_RGBA_8888) {
+            opFormat = COPYBIT_FORMAT_RGBX_8888;
+        } else {
+            if (srcTextureHasAlpha) {
+                LOGD_IF(DEBUG_COPYBIT, "texture format requires blending");
+                return false;
+            }
+        }
+    }
+
+    switch (tev.env) {
+    case GGL_REPLACE:
+        break;
+    case GGL_MODULATE:
+        // only cases allowed is:
+        // RGB  source, color={1,1,1,a} -> can be done with GL_REPLACE
+        // RGBA source, color={1,1,1,1} -> can be done with GL_REPLACE
+        if (blending) {
+            if (c->currentColorClamped.r == c->currentColorClamped.a &&
+                c->currentColorClamped.g == c->currentColorClamped.a &&
+                c->currentColorClamped.b == c->currentColorClamped.a) {
+                // TODO: RGBA source, color={1,1,1,a} / regular-blending
+                // is equivalent
+                alphaPlaneWorkaround = true;
+                break;
+            }
+        }
+        LOGD_IF(DEBUG_COPYBIT, "GGL_MODULATE");
+        return false;
+    default:
+        // Incompatible texture environment.
+        LOGD_IF(DEBUG_COPYBIT, "incompatible texture environment");
+        return false;
+    }
+
+    copybit_device_t* copybit = c->copybits.blitEngine;
+    copybit_image_t src;
+    textureToCopyBitImage(&textureObject->surface, opFormat,
+            textureObject->buffer, &src);
+    copybit_rect_t srect = { Ucr, Vcr + Hcr, Ucr + Wcr, Vcr };
+
+    /*
+     *  Below we perform extra passes needed to emulate things the h/w
+     * cannot do.
+     */
+
+    const GLfixed minScaleInv = gglDivQ(0x10000, c->copybits.minScale, 16);
+    const GLfixed maxScaleInv = gglDivQ(0x10000, c->copybits.maxScale, 16);
+
+    sp<GraphicBuffer> tempBitmap;
+
+    if (dsdx < maxScaleInv || dsdx > minScaleInv ||
+        dtdy < maxScaleInv || dtdy > minScaleInv)
+    {
+        // The requested scale is out of the range the hardware
+        // can support.
+        LOGD_IF(DEBUG_COPYBIT,
+                "scale out of range dsdx=%08x (Wcr=%d / w=%d), "
+                "dtdy=%08x (Hcr=%d / h=%d), Ucr=%d, Vcr=%d",
+                dsdx, Wcr, w, dtdy, Hcr, h, Ucr, Vcr);
+
+        int32_t xscale=0x10000, yscale=0x10000;
+        if (dsdx > minScaleInv)         xscale = c->copybits.minScale;
+        else if (dsdx < maxScaleInv)    xscale = c->copybits.maxScale;
+        if (dtdy > minScaleInv)         yscale = c->copybits.minScale;
+        else if (dtdy < maxScaleInv)    yscale = c->copybits.maxScale;
+        dsdx = gglMulx(dsdx, xscale);
+        dtdy = gglMulx(dtdy, yscale);
+
+        /* we handle only one step of resizing below. Handling an arbitrary
+         * number is relatively easy (replace "if" above by "while"), but requires
+         * two intermediate buffers and so far we never had the need.
+         */
+
+        if (dsdx < maxScaleInv || dsdx > minScaleInv ||
+            dtdy < maxScaleInv || dtdy > minScaleInv) {
+            LOGD_IF(DEBUG_COPYBIT,
+                    "scale out of range dsdx=%08x (Wcr=%d / w=%d), "
+                    "dtdy=%08x (Hcr=%d / h=%d), Ucr=%d, Vcr=%d",
+                    dsdx, Wcr, w, dtdy, Hcr, h, Ucr, Vcr);
+            return false;
+        }
+
+        const int tmp_w = gglMulx(srect.r - srect.l, xscale, 16);
+        const int tmp_h = gglMulx(srect.b - srect.t, yscale, 16);
+
+        LOGD_IF(DEBUG_COPYBIT,
+                "xscale=%08x, yscale=%08x, dsdx=%08x, dtdy=%08x, tmp_w=%d, tmp_h=%d",
+                xscale, yscale, dsdx, dtdy, tmp_w, tmp_h);
+
+        tempBitmap = new GraphicBuffer(
+                    tmp_w, tmp_h, src.format,
+                    GraphicBuffer::USAGE_HW_2D);
+
+        err = tempBitmap->initCheck();
+        if (err == NO_ERROR) {
+            copybit_image_t tmp_dst;
+            copybit_rect_t tmp_rect;
+            tmp_dst.w = tmp_w;
+            tmp_dst.h = tmp_h;
+            tmp_dst.format = tempBitmap->format;
+            tmp_dst.handle = (native_handle_t*)tempBitmap->getNativeBuffer()->handle;
+            tmp_rect.l = 0;
+            tmp_rect.t = 0;
+            tmp_rect.r = tmp_dst.w;
+            tmp_rect.b = tmp_dst.h;
+            region_iterator tmp_it(Region(Rect(tmp_rect.r, tmp_rect.b)));
+            copybit->set_parameter(copybit, COPYBIT_TRANSFORM, 0);
+            copybit->set_parameter(copybit, COPYBIT_PLANE_ALPHA, 0xFF);
+            copybit->set_parameter(copybit, COPYBIT_DITHER, COPYBIT_DISABLE);
+            err = copybit->stretch(copybit,
+                    &tmp_dst, &src, &tmp_rect, &srect, &tmp_it);
+            src = tmp_dst;
+            srect = tmp_rect;
+        }
+    }
+
+    copybit_image_t dst;
+    textureToCopyBitImage(&cbSurface, cbSurface.format,
+            c->copybits.drawSurfaceBuffer, &dst);
+    copybit_rect_t drect = {x, y, x+w, y+h};
+
+
+    /* and now the alpha-plane hack. This handles the "Fade" case of a
+     * texture with an alpha channel.
+     */
+    if (alphaPlaneWorkaround) {
+        sp<GraphicBuffer> tempCb = new GraphicBuffer(
+                    w, h, COPYBIT_FORMAT_RGB_565,
+                    GraphicBuffer::USAGE_HW_2D);
+
+        err = tempCb->initCheck();
+
+        copybit_image_t tmpCbImg;
+        copybit_rect_t tmpCbRect;
+        copybit_rect_t tmpdrect = drect;
+        tmpCbImg.w = w;
+        tmpCbImg.h = h;
+        tmpCbImg.format = tempCb->format;
+        tmpCbImg.handle = (native_handle_t*)tempCb->getNativeBuffer()->handle;
+        tmpCbRect.l = 0;
+        tmpCbRect.t = 0;
+
+        if (drect.l < 0) {
+            tmpCbRect.l = -tmpdrect.l;
+            tmpdrect.l = 0;
+        }
+        if (drect.t < 0) {
+            tmpCbRect.t = -tmpdrect.t;
+            tmpdrect.t = 0;
+        }
+        if (drect.l + tmpCbImg.w > dst.w) {
+            tmpCbImg.w = dst.w - drect.l;
+            tmpdrect.r = dst.w;
+        }
+        if (drect.t + tmpCbImg.h > dst.h) {
+            tmpCbImg.h = dst.h - drect.t;
+            tmpdrect.b = dst.h;
+        }
+
+        tmpCbRect.r = tmpCbImg.w;
+        tmpCbRect.b = tmpCbImg.h;
+
+        if (!err) {
+            // first make a copy of the destination buffer
+            region_iterator tmp_it(Region(Rect(w, h)));
+            copybit->set_parameter(copybit, COPYBIT_TRANSFORM, 0);
+            copybit->set_parameter(copybit, COPYBIT_PLANE_ALPHA, 0xFF);
+            copybit->set_parameter(copybit, COPYBIT_DITHER, COPYBIT_DISABLE);
+            err = copybit->stretch(copybit,
+                    &tmpCbImg, &dst, &tmpCbRect, &tmpdrect, &tmp_it);
+        }
+        if (!err) {
+            // then proceed as usual, but without the alpha plane
+            copybit->set_parameter(copybit, COPYBIT_TRANSFORM, transform);
+            copybit->set_parameter(copybit, COPYBIT_PLANE_ALPHA, 0xFF);
+            copybit->set_parameter(copybit, COPYBIT_DITHER,
+                    (enables & GGL_ENABLE_DITHER) ?
+                            COPYBIT_ENABLE : COPYBIT_DISABLE);
+            clipRectRegion it(c);
+            err = copybit->stretch(copybit, &dst, &src, &drect, &srect, &it);
+        }
+        if (!err) {
+            // finally copy back the destination on top with 1-alphaplane
+            int invPlaneAlpha = 0xFF - fixedToByte(c->currentColorClamped.a);
+            clipRectRegion it(c);
+            copybit->set_parameter(copybit, COPYBIT_TRANSFORM, 0);
+            copybit->set_parameter(copybit, COPYBIT_PLANE_ALPHA, invPlaneAlpha);
+            copybit->set_parameter(copybit, COPYBIT_DITHER, COPYBIT_ENABLE);
+            err = copybit->stretch(copybit,
+                    &dst, &tmpCbImg, &tmpdrect, &tmpCbRect, &it);
+        }
+    } else {
+        copybit->set_parameter(copybit, COPYBIT_TRANSFORM, transform);
+        copybit->set_parameter(copybit, COPYBIT_PLANE_ALPHA, planeAlpha);
+        copybit->set_parameter(copybit, COPYBIT_DITHER,
+                (enables & GGL_ENABLE_DITHER) ?
+                        COPYBIT_ENABLE : COPYBIT_DISABLE);
+        clipRectRegion it(c);
+
+        LOGD_IF(0,
+             "dst={%d, %d, %d, %p, %p}, "
+             "src={%d, %d, %d, %p, %p}, "
+             "drect={%d,%d,%d,%d}, "
+             "srect={%d,%d,%d,%d}, "
+             "it={%d,%d,%d,%d}, " ,
+             dst.w, dst.h, dst.format, dst.base, dst.handle,
+             src.w, src.h, src.format, src.base, src.handle,
+             drect.l, drect.t, drect.r, drect.b,
+             srect.l, srect.t, srect.r, srect.b,
+             it.r.l, it.r.t, it.r.r, it.r.b
+        );
+
+        err = copybit->stretch(copybit, &dst, &src, &drect, &srect, &it);
+    }
+    if (err != NO_ERROR) {
+        c->textures.tmu[0].texture->try_copybit = false;
+    }
+    return err == NO_ERROR ? true : false;
+}
+
+/*
+ * Try to draw a triangle fan with copybit, return false if we fail.
+ */
+bool drawTriangleFanWithCopybit_impl(ogles_context_t* c, GLint first, GLsizei count)
+{
+    if (!checkContext(c)) {
+        return false;
+    }
+
+    // FIXME: we should handle culling  here
+    c->arrays.compileElements(c, c->vc.vBuffer, 0, 4);
+
+    // we detect if we're dealing with a rectangle, by comparing the
+    // rectangles {v0,v2} and {v1,v3} which should be identical.
+    
+    // NOTE: we should check that the rectangle is window aligned, however
+    // if we do that, the optimization won't be taken in a lot of cases.
+    // Since this code is intended to be used with SurfaceFlinger only,
+    // so it's okay...
+    
+    const vec4_t& v0 = c->vc.vBuffer[0].window;
+    const vec4_t& v1 = c->vc.vBuffer[1].window;
+    const vec4_t& v2 = c->vc.vBuffer[2].window;
+    const vec4_t& v3 = c->vc.vBuffer[3].window;
+    int l = min(v0.x, v2.x);
+    int b = min(v0.y, v2.y);
+    int r = max(v0.x, v2.x);
+    int t = max(v0.y, v2.y);
+    if ((l != min(v1.x, v3.x)) || (b != min(v1.y, v3.y)) ||
+        (r != max(v1.x, v3.x)) || (t != max(v1.y, v3.y))) {
+        LOGD_IF(DEBUG_COPYBIT, "geometry not a rectangle");
+        return false;
+    }
+
+    // fetch and transform texture coordinates
+    // NOTE: maybe it would be better to have a "compileElementsAll" method
+    // that would ensure all vertex data are fetched and transformed
+    const transform_t& tr = c->transforms.texture[0].transform; 
+    for (size_t i=0 ; i<4 ; i++) {
+        const GLubyte* tp = c->arrays.texture[0].element(i);
+        vertex_t* const v = &c->vc.vBuffer[i];
+        c->arrays.texture[0].fetch(c, v->texture[0].v, tp);
+        // FIXME: we should bail if q!=1
+        c->arrays.tex_transform[0](&tr, &v->texture[0], &v->texture[0]);
+    }
+    
+    const vec4_t& t0 = c->vc.vBuffer[0].texture[0];
+    const vec4_t& t1 = c->vc.vBuffer[1].texture[0];
+    const vec4_t& t2 = c->vc.vBuffer[2].texture[0];
+    const vec4_t& t3 = c->vc.vBuffer[3].texture[0];
+    int txl = min(t0.x, t2.x);
+    int txb = min(t0.y, t2.y);
+    int txr = max(t0.x, t2.x);
+    int txt = max(t0.y, t2.y);
+    if ((txl != min(t1.x, t3.x)) || (txb != min(t1.y, t3.y)) ||
+        (txr != max(t1.x, t3.x)) || (txt != max(t1.y, t3.y))) {
+        LOGD_IF(DEBUG_COPYBIT, "texcoord not a rectangle");
+        return false;
+    }
+    if ((txl != 0) || (txb != 0) ||
+        (txr != FIXED_ONE) || (txt != FIXED_ONE)) {
+        // we could probably handle this case, if we wanted to
+        LOGD_IF(DEBUG_COPYBIT, "texture is cropped: %08x,%08x,%08x,%08x",
+                txl, txb, txr, txt);
+        return false;
+    }
+
+    // at this point, we know we are dealing with a rectangle, so we 
+    // only need to consider 3 vertices for computing the jacobians
+    
+    const long long dx01 = v1.x - v0.x;
+    const long long dx02 = v2.x - v0.x;
+    const long long dy01 = v1.y - v0.y;
+    const long long dy02 = v2.y - v0.y;
+    const long long ds01 = t1.S - t0.S;
+    const long long ds02 = t2.S - t0.S;
+    const long long dt01 = t1.T - t0.T;
+    const long long dt02 = t2.T - t0.T;
+    const long long area = dx01*dy02 - dy01*dx02;
+    long long dsdx, dsdy, dtdx, dtdy;
+    if (area >= 0) {
+        dsdx = ds01*dy02 - ds02*dy01;
+        dtdx = dt01*dy02 - dt02*dy01;
+        dsdy = ds02*dx01 - ds01*dx02;
+        dtdy = dt02*dx01 - dt01*dx02;
+    } else {
+        dsdx = ds02*dy01 - ds01*dy02;
+        dtdx = dt02*dy01 - dt01*dy02;
+        dsdy = ds01*dx02 - ds02*dx01;
+        dtdy = dt01*dx02 - dt02*dx01;
+    }
+
+    // here we rely on the fact that we know the transform is
+    // a rigid-body transform AND that it can only rotate in 90 degrees
+    // increments
+
+    int transform = 0;
+    if (dsdx == 0) {
+        // 90 deg rotation case
+        // [ 0    dtdx  ]
+        // [ dsdx    0  ]
+        transform |= COPYBIT_TRANSFORM_ROT_90;
+        // FIXME: not sure if FLIP_H and FLIP_V shouldn't be inverted
+        if (dtdx > 0)
+            transform |= COPYBIT_TRANSFORM_FLIP_H;
+        if (dsdy < 0)
+            transform |= COPYBIT_TRANSFORM_FLIP_V;
+    } else {
+        // [ dsdx    0  ]
+        // [ 0     dtdy ]
+        if (dsdx < 0)
+            transform |= COPYBIT_TRANSFORM_FLIP_H;
+        if (dtdy < 0)
+            transform |= COPYBIT_TRANSFORM_FLIP_V;
+    }
+
+    //LOGD("l=%d, b=%d, w=%d, h=%d, tr=%d", x, y, w, h, transform);
+    //LOGD("A=%f\tB=%f\nC=%f\tD=%f",
+    //      dsdx/65536.0, dtdx/65536.0, dsdy/65536.0, dtdy/65536.0);
+
+    int x = l >> 4;
+    int y = b >> 4;
+    int w = (r-l) >> 4;
+    int h = (t-b) >> 4;
+    texture_unit_t& u(c->textures.tmu[0]);
+    EGLTextureObject* textureObject = u.texture;
+    GLint tWidth = textureObject->surface.width;
+    GLint tHeight = textureObject->surface.height;
+    GLint crop_rect[4] = {0, tHeight, tWidth, -tHeight};
+    const GGLSurface& cbSurface = c->rasterizer.state.buffers.color.s;
+    y = cbSurface.height - (y + h);
+    return copybit(x, y, w, h, textureObject, crop_rect, transform, c);
+}
+
+/*
+ * Try to drawTexiOESWithCopybit, return false if we fail.
+ */
+
+bool drawTexiOESWithCopybit_impl(GLint x, GLint y, GLint z,
+        GLint w, GLint h, ogles_context_t* c)
+{
+    // quickly process empty rects
+    if ((w|h) <= 0) {
+        return true;
+    }
+    if (!checkContext(c)) {
+        return false;
+    }
+    texture_unit_t& u(c->textures.tmu[0]);
+    EGLTextureObject* textureObject = u.texture;
+    return copybit(x, y, w, h, textureObject, textureObject->crop_rect, 0, c);
+}
+
+} // namespace android
+
diff --git a/opengl/libagl/copybit.h b/opengl/libagl/copybit.h
new file mode 100644
index 0000000..b8b5afd
--- /dev/null
+++ b/opengl/libagl/copybit.h
@@ -0,0 +1,75 @@
+/*
+**
+** Copyright 2009, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef ANDROID_OPENGLES_COPYBIT_H
+#define ANDROID_OPENGLES_COPYBIT_H
+
+#include <stdlib.h>
+
+#include <GLES/gl.h>
+
+#include "TextureObjectManager.h"
+namespace android {
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+
+bool drawTexiOESWithCopybit_impl(GLint x, GLint y, GLint z,
+        GLint w, GLint h, ogles_context_t* c);
+
+bool drawTriangleFanWithCopybit_impl(ogles_context_t* c, GLint first,
+        GLsizei count);
+
+inline bool copybitQuickCheckContext(ogles_context_t* c) {
+        return  c->copybits.drawSurfaceBuffer != 0
+            && c->rasterizer.state.enabled_tmu == 1
+            && c->textures.tmu[0].texture->try_copybit;
+}
+
+/*
+ * Tries to draw a drawTexiOES using copybit hardware.
+ * Returns true if successful.
+ */
+inline bool drawTexiOESWithCopybit(GLint x, GLint y, GLint z,
+        GLint w, GLint h, ogles_context_t* c) {
+    if (!copybitQuickCheckContext(c)) {
+    	return false;
+   	}
+   	
+   	return drawTexiOESWithCopybit_impl(x, y, z, w, h, c);
+}
+
+/*
+ * Tries to draw a triangle fan using copybit hardware.
+ * Returns true if successful.
+ */
+inline bool drawTriangleFanWithCopybit(ogles_context_t* c, GLint first,
+        GLsizei count) {
+    /*
+     * We are looking for the glDrawArrays call made by SurfaceFlinger.
+     */
+
+    if ((count!=4) || first || !copybitQuickCheckContext(c))
+        return false;
+    
+    return drawTriangleFanWithCopybit_impl(c, first, count);
+}
+
+
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
+
+} // namespace android
+
+#endif // ANDROID_OPENGLES_COPYBIT_H
diff --git a/opengl/libagl/egl.cpp b/opengl/libagl/egl.cpp
index 662a1fa..b83928a 100644
--- a/opengl/libagl/egl.cpp
+++ b/opengl/libagl/egl.cpp
@@ -158,6 +158,7 @@ struct egl_surface_t
     virtual     EGLint      getSwapBehavior() const;
     virtual     EGLBoolean  swapBuffers();
     virtual     EGLBoolean  setSwapRectangle(EGLint l, EGLint t, EGLint w, EGLint h);
+    virtual     EGLClientBuffer getRenderBuffer() const;
 protected:
     GGLSurface              depth;
 };
@@ -201,6 +202,9 @@ EGLBoolean egl_surface_t::setSwapRectangle(
 {
     return EGL_FALSE;
 }
+EGLClientBuffer egl_surface_t::getRenderBuffer() const {
+    return 0;
+}
 
 // ----------------------------------------------------------------------------
 
@@ -226,7 +230,8 @@ struct egl_window_surface_v2_t : public egl_surface_t
     virtual     EGLint      getRefreshRate() const;
     virtual     EGLint      getSwapBehavior() const;
     virtual     EGLBoolean  setSwapRectangle(EGLint l, EGLint t, EGLint w, EGLint h);
-    
+    virtual     EGLClientBuffer  getRenderBuffer() const;
+
 private:
     status_t lock(android_native_buffer_t* buf, int usage, void** vaddr);
     status_t unlock(android_native_buffer_t* buf);
@@ -480,13 +485,13 @@ void egl_window_surface_v2_t::copyBlt(
     copybit_device_t* const copybit = blitengine;
     if (copybit)  {
         copybit_image_t simg;
-        simg.w = src->width;
+        simg.w = src->stride;
         simg.h = src->height;
         simg.format = src->format;
         simg.handle = const_cast<native_handle_t*>(src->handle);
 
         copybit_image_t dimg;
-        dimg.w = dst->width;
+        dimg.w = dst->stride;
         dimg.h = dst->height;
         dimg.format = dst->format;
         dimg.handle = const_cast<native_handle_t*>(dst->handle);
@@ -621,6 +626,28 @@ EGLBoolean egl_window_surface_v2_t::setSwapRectangle(
     return EGL_TRUE;
 }
 
+EGLClientBuffer egl_window_surface_v2_t::getRenderBuffer() const
+{
+    return buffer;
+}
+
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+
+static bool supportedCopybitsDestinationFormat(int format) {
+    // Hardware supported
+    switch (format) {
+    case HAL_PIXEL_FORMAT_RGB_565:
+    case HAL_PIXEL_FORMAT_RGBA_8888:
+    case HAL_PIXEL_FORMAT_RGBX_8888:
+    case HAL_PIXEL_FORMAT_RGBA_4444:
+    case HAL_PIXEL_FORMAT_RGBA_5551:
+    case HAL_PIXEL_FORMAT_BGRA_8888:
+        return true;
+    }
+    return false;
+}
+#endif
+
 EGLBoolean egl_window_surface_v2_t::bindDrawSurface(ogles_context_t* gl)
 {
     GGLSurface buffer;
@@ -634,6 +661,18 @@ EGLBoolean egl_window_surface_v2_t::bindDrawSurface(ogles_context_t* gl)
     if (depth.data != gl->rasterizer.state.buffers.depth.data)
         gl->rasterizer.procs.depthBuffer(gl, &depth);
 
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    gl->copybits.drawSurfaceBuffer = 0;
+    if (gl->copybits.blitEngine != NULL) {
+        if (supportedCopybitsDestinationFormat(buffer.format)) {
+            buffer_handle_t handle = this->buffer->handle;
+            if (handle != NULL) {
+                gl->copybits.drawSurfaceBuffer = this->buffer;
+            }
+        }
+    }
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
+
     return EGL_TRUE;
 }
 EGLBoolean egl_window_surface_v2_t::bindReadSurface(ogles_context_t* gl)
@@ -850,6 +889,7 @@ static char const * const gExtensionsString =
         // "KHR_image_pixmap "
         "EGL_ANDROID_image_native_buffer "
         "EGL_ANDROID_swap_rectangle "
+        "EGL_ANDROID_get_render_buffer "
         ;
 
 // ----------------------------------------------------------------------------
@@ -902,6 +942,8 @@ static const extention_map_t gExtentionMap[] = {
             (__eglMustCastToProperFunctionPointerType)&eglDestroyImageKHR }, 
     { "eglSetSwapRectangleANDROID", 
             (__eglMustCastToProperFunctionPointerType)&eglSetSwapRectangleANDROID }, 
+    { "eglGetRenderBufferANDROID",
+            (__eglMustCastToProperFunctionPointerType)&eglGetRenderBufferANDROID },
 };
 
 /*
@@ -1980,7 +2022,11 @@ EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval)
     if (egl_display_t::is_valid(dpy) == EGL_FALSE)
         return setError(EGL_BAD_DISPLAY, EGL_FALSE);
     // TODO: eglSwapInterval()
-    return setError(EGL_BAD_PARAMETER, EGL_FALSE);
+    /* TODO: [ahatala 2009-10-09] changing this to default to succeeding,
+       as this will cause eglSwapInterval to fail even if the hw implementation
+       correctly supports it. */
+    //return setError(EGL_BAD_PARAMETER, EGL_FALSE);
+    return EGL_TRUE;
 }
 
 // ----------------------------------------------------------------------------
@@ -2127,3 +2173,18 @@ EGLBoolean eglSetSwapRectangleANDROID(EGLDisplay dpy, EGLSurface draw,
 
     return EGL_TRUE;
 }
+
+EGLClientBuffer eglGetRenderBufferANDROID(EGLDisplay dpy, EGLSurface draw)
+{
+    if (egl_display_t::is_valid(dpy) == EGL_FALSE)
+        return setError(EGL_BAD_DISPLAY, (EGLClientBuffer)0);
+
+    egl_surface_t* d = static_cast<egl_surface_t*>(draw);
+    if (!d->isValid())
+        return setError(EGL_BAD_SURFACE, (EGLClientBuffer)0);
+    if (d->dpy != dpy)
+        return setError(EGL_BAD_DISPLAY, (EGLClientBuffer)0);
+
+    // post the surface
+    return d->getRenderBuffer();
+}
diff --git a/opengl/libagl/state.cpp b/opengl/libagl/state.cpp
index 8b4136a..ccdb462 100644
--- a/opengl/libagl/state.cpp
+++ b/opengl/libagl/state.cpp
@@ -28,6 +28,10 @@
 #include "BufferObjectManager.h"
 #include "TextureObjectManager.h"
 
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+#include <hardware/copybit.h>
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
+
 namespace android {
 
 // ----------------------------------------------------------------------------
@@ -97,6 +101,35 @@ ogles_context_t *ogles_init(size_t extra)
     // OpenGL enables dithering by default
     c->rasterizer.procs.enable(c, GL_DITHER);
 
+    c->copybits.blitEngine = NULL;
+    c->copybits.minScale = 0;
+    c->copybits.maxScale = 0;
+    c->copybits.drawSurfaceBuffer = 0;
+
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    hw_module_t const* module;
+    if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
+        struct copybit_device_t* copyBits;
+        if (copybit_open(module, &copyBits) == 0) {
+            c->copybits.blitEngine = copyBits;
+            {
+                int minLim = copyBits->get(copyBits,
+                        COPYBIT_MINIFICATION_LIMIT);
+                if (minLim != -EINVAL && minLim > 0) {
+                    c->copybits.minScale = (1 << 16) / minLim;
+                }
+            }
+            {
+                int magLim = copyBits->get(copyBits,
+                        COPYBIT_MAGNIFICATION_LIMIT);
+                if (magLim != -EINVAL && magLim > 0) {
+                    c->copybits.maxScale = min(32*1024-1, magLim) << 16;
+                }
+            }
+        }
+    }
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
+
     return c;
 }
 
@@ -111,6 +144,11 @@ void ogles_uninit(ogles_context_t* c)
     c->bufferObjectManager->decStrong(c);
     ggl_uninit_context(&(c->rasterizer));
     free(c->rasterizer.base);
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    if (c->copybits.blitEngine != NULL) {
+        copybit_close((struct copybit_device_t*) c->copybits.blitEngine);
+    }
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
 }
 
 void _ogles_error(ogles_context_t* c, GLenum error)
diff --git a/opengl/libagl/texture.cpp b/opengl/libagl/texture.cpp
index eb96895..d67612e 100644
--- a/opengl/libagl/texture.cpp
+++ b/opengl/libagl/texture.cpp
@@ -26,6 +26,10 @@
 #include <private/ui/android_natives_priv.h>
 #include <ETC1/etc1.h>
 
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+#include "copybit.h"
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
+
 namespace android {
 
 // ----------------------------------------------------------------------------
@@ -759,10 +763,17 @@ static void drawTexxOESImp(GLfixed x, GLfixed y, GLfixed z, GLfixed w, GLfixed h
 static void drawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w, GLfixed h,
         ogles_context_t* c)
 {
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    if (drawTexiOESWithCopybit(gglFixedToIntRound(x),
+            gglFixedToIntRound(y), gglFixedToIntRound(z),
+            gglFixedToIntRound(w), gglFixedToIntRound(h), c)) {
+        return;
+    }
+#else
     // quickly reject empty rects
     if ((w|h) <= 0)
         return;
-
+#endif
     drawTexxOESImp(x, y, z, w, h, c);
 }
 
@@ -774,6 +785,11 @@ static void drawTexiOES(GLint x, GLint y, GLint z, GLint w, GLint h, ogles_conte
     // which is a lot faster.
 
     if (ggl_likely(c->rasterizer.state.enabled_tmu == 1)) {
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+        if (drawTexiOESWithCopybit(x, y, z, w, h, c)) {
+            return;
+        }
+#endif
         const int tmu = 0;
         texture_unit_t& u(c->textures.tmu[tmu]);
         EGLTextureObject* textureObject = u.texture;
@@ -781,7 +797,9 @@ static void drawTexiOES(GLint x, GLint y, GLint z, GLint w, GLint h, ogles_conte
         const GLint Hcr = textureObject->crop_rect[3];
 
         if ((w == Wcr) && (h == -Hcr)) {
+#ifndef LIBAGL_USE_GRALLOC_COPYBITS
             if ((w|h) <= 0) return; // quickly reject empty rects
+#endif
 
             if (u.dirty) {
                 c->rasterizer.procs.activeTexture(c, tmu);
@@ -1628,6 +1646,13 @@ void glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image)
     // bind it to the texture unit
     sp<EGLTextureObject> tex = getAndBindActiveTextureObject(c);
     tex->setImage(native_buffer);
+
+#ifdef LIBAGL_USE_GRALLOC_COPYBITS
+    tex->try_copybit = false;
+    if (c->copybits.blitEngine != NULL) {
+        tex->try_copybit = true;
+    }
+#endif // LIBAGL_USE_GRALLOC_COPYBITS
 }
 
 void glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image)
diff --git a/opengl/libs/Android.mk b/opengl/libs/Android.mk
index ae924cd..59794b0 100644
--- a/opengl/libs/Android.mk
+++ b/opengl/libs/Android.mk
@@ -13,6 +13,10 @@ LOCAL_SRC_FILES:= 	       \
 	EGL/Loader.cpp 	       \
 #
 
+ifneq ($(TARGET_USES_GL_VENDOR_EXTENSIONS),false)
+    LOCAL_CFLAGS += -DENABLE_VENDOR_EXTENSIONS
+endif
+
 LOCAL_SHARED_LIBRARIES += libcutils libutils
 LOCAL_LDLIBS := -lpthread -ldl
 LOCAL_MODULE:= libEGL
@@ -27,6 +31,9 @@ else
         LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
     endif
     # we need to access the private Bionic header <bionic_tls.h>
+    ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+        LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+    endif
     LOCAL_C_INCLUDES += bionic/libc/private
 endif
 
@@ -41,6 +48,9 @@ endif
 ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
   LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
 endif
+ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+  LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+endif
 
 include $(BUILD_SHARED_LIBRARY)
 installed_libEGL := $(LOCAL_INSTALLED_MODULE)
@@ -84,6 +94,9 @@ else
     ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
         LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
     endif
+    ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+        LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+    endif
     LOCAL_C_INCLUDES += bionic/libc/private
 endif
 
@@ -94,6 +107,9 @@ LOCAL_CFLAGS += -fvisibility=hidden
 ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
   LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
 endif
+ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+  LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+endif
 
 include $(BUILD_SHARED_LIBRARY)
 
@@ -120,6 +136,9 @@ else
     ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
         LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
     endif
+    ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+        LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+    endif
     LOCAL_C_INCLUDES += bionic/libc/private
 endif
 
@@ -130,6 +149,9 @@ LOCAL_CFLAGS += -fvisibility=hidden
 ifeq ($(ARCH_ARM_HAVE_TLS_REGISTER),true)
   LOCAL_CFLAGS += -DHAVE_ARM_TLS_REGISTER
 endif
+ifeq ($(TARGET_HAVE_TEGRA_ERRATA_657451),true)
+  LOCAL_CFLAGS += -DHAVE_TEGRA_ERRATA_657451
+endif
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/opengl/libs/EGL/Loader.cpp b/opengl/libs/EGL/Loader.cpp
index 747c829..e16efe3 100644
--- a/opengl/libs/EGL/Loader.cpp
+++ b/opengl/libs/EGL/Loader.cpp
@@ -23,6 +23,7 @@
 #include <limits.h>
 
 #include <cutils/log.h>
+#include <cutils/properties.h>
 
 #include <EGL/egl.h>
 
@@ -45,6 +46,39 @@ namespace android {
 
 ANDROID_SINGLETON_STATIC_INSTANCE( Loader )
 
+/* This function is called to check whether we run inside the emulator,
+ * and if this is the case whether GLES GPU emulation is supported.
+ *
+ * Returned values are:
+ *  -1   -> not running inside the emulator
+ *   0   -> running inside the emulator, but GPU emulation not supported
+ *   1   -> running inside the emulator, GPU emulation is supported
+ *          through the "emulation" config.
+ */
+static int
+checkGlesEmulationStatus(void)
+{
+    /* We're going to check for the following kernel parameters:
+     *
+     *    qemu=1                      -> tells us that we run inside the emulator
+     *    android.qemu.gles=<number>  -> tells us the GLES GPU emulation status
+     *
+     * Note that we will return <number> if we find it. This let us support
+     * more additionnal emulation modes in the future.
+     */
+    char  prop[PROPERTY_VALUE_MAX];
+    int   result = -1;
+
+    /* First, check for qemu=1 */
+    property_get("ro.kernel.qemu",prop,"0");
+    if (atoi(prop) != 1)
+        return -1;
+
+    /* We are in the emulator, get GPU status value */
+    property_get("ro.kernel.qemu.gles",prop,"0");
+    return atoi(prop);
+}
+
 // ----------------------------------------------------------------------------
 
 Loader::driver_t::driver_t(void* gles) 
@@ -94,6 +128,15 @@ Loader::Loader()
 {
     char line[256];
     char tag[256];
+
+    /* Special case for GLES emulation */
+    if (checkGlesEmulationStatus() == 0) {
+        LOGD("Emulator without GPU support detected. Fallback to software renderer.");
+        gConfig.add( entry_t(0, 0, "android") );
+        return;
+    }
+
+    /* Otherwise, use egl.cfg */
     FILE* cfg = fopen("/system/lib/egl/egl.cfg", "r");
     if (cfg == NULL) {
         // default config
diff --git a/opengl/libs/EGL/egl.cpp b/opengl/libs/EGL/egl.cpp
index 7e0c169..40dca24 100644
--- a/opengl/libs/EGL/egl.cpp
+++ b/opengl/libs/EGL/egl.cpp
@@ -46,6 +46,14 @@
 #include "egl_impl.h"
 #include "Loader.h"
 
+// Enable this define to allow querying vendor-specific GL extensions. This
+// currently will only work correctly for implementations which have a single
+// EGL backend; multiple EGL backends are not supported.
+// There's also an extra subtlety with the EGLimage entry points in GL, which
+// can't work properly if they're called directly (they have to go through
+// a wrapper).
+
+#define MAKE_CONFIG(_impl, _index)  ((EGLConfig)(((_impl)<<24) | (_index)))
 #define setError(_e, _r) setErrorEtc(__FUNCTION__, __LINE__, _e, _r)
 
 // ----------------------------------------------------------------------------
@@ -61,8 +69,14 @@ static char const * const gExtensionString  =
         "EGL_KHR_image "
         "EGL_KHR_image_base "
         "EGL_KHR_image_pixmap "
+#ifdef ENABLE_VENDOR_EXTENSIONS
+        "EGL_KHR_gl_texture_2D_image "
+        "EGL_KHR_gl_texture_cubemap_image "
+        "EGL_KHR_gl_renderbuffer_image "
+#endif
         "EGL_ANDROID_image_native_buffer "
         "EGL_ANDROID_swap_rectangle "
+        "EGL_ANDROID_get_render_buffer "
         ;
 
 // ----------------------------------------------------------------------------
@@ -414,6 +428,8 @@ static const extention_map_t gExtentionMap[] = {
             (__eglMustCastToProperFunctionPointerType)NULL },
     { "glEGLImageTargetRenderbufferStorageOES",
             (__eglMustCastToProperFunctionPointerType)NULL },
+    { "eglGetRenderBufferANDROID",
+            (__eglMustCastToProperFunctionPointerType)&eglGetRenderBufferANDROID },
 };
 
 extern const __eglMustCastToProperFunctionPointerType gExtensionForwarders[MAX_NUMBER_OF_GL_EXTENSIONS];
@@ -828,6 +844,7 @@ EGLBoolean eglGetConfigs(   EGLDisplay dpy,
 {
     egl_display_t const * const dp = get_display(dpy);
     if (!dp) return setError(EGL_BAD_DISPLAY, EGL_FALSE);
+    if (!num_config) return setError(EGL_BAD_PARAMETER, EGL_FALSE);
 
     GLint numConfigs = dp->numTotalConfigs;
     if (!configs) {
@@ -1390,6 +1407,31 @@ EGLint eglGetError(void)
     return result;
 }
 
+#ifdef ENABLE_VENDOR_EXTENSIONS
+// Note: Similar implementations of this function also exist in gl2.cpp and
+// gl.cpp, and are used by applications that call the exported entry points
+// directly.
+typedef void (GL_APIENTRYP PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) (GLenum target, GLeglImageOES image);
+typedef void (GL_APIENTRYP PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLeglImageOES image);
+
+static PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES_impl = NULL;
+static PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC glEGLImageTargetRenderbufferStorageOES_impl = NULL;
+
+static void glEGLImageTargetTexture2DOES_wrapper(GLenum target, GLeglImageOES image)
+{
+    GLeglImageOES implImage =
+        (GLeglImageOES)egl_get_image_for_current_context((EGLImageKHR)image);
+    glEGLImageTargetTexture2DOES_impl(target, implImage);
+}
+
+static void glEGLImageTargetRenderbufferStorageOES_wrapper(GLenum target, GLeglImageOES image)
+{
+    GLeglImageOES implImage =
+        (GLeglImageOES)egl_get_image_for_current_context((EGLImageKHR)image);
+    glEGLImageTargetRenderbufferStorageOES_impl(target, implImage);
+}
+#endif
+
 __eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
 {
     // eglGetProcAddress() could be the very first function called
@@ -1405,6 +1447,29 @@ __eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
     addr = findProcAddress(procname, gExtentionMap, NELEM(gExtentionMap));
     if (addr) return addr;
 
+#ifdef ENABLE_VENDOR_EXTENSIONS
+    addr = 0;
+    for (int i=0 ; i<IMPL_NUM_IMPLEMENTATIONS ; i++) {
+        egl_connection_t* const cnx = &gEGLImpl[i];
+        if (cnx->dso) {
+            if (cnx->egl.eglGetProcAddress) {
+                addr = cnx->egl.eglGetProcAddress(procname);
+                if (addr) {
+                    if (!strcmp(procname, "glEGLImageTargetTexture2DOES")) {
+                        glEGLImageTargetTexture2DOES_impl = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)addr;
+                        return (__eglMustCastToProperFunctionPointerType)glEGLImageTargetTexture2DOES_wrapper;
+                    }
+                    if (!strcmp(procname, "glEGLImageTargetRenderbufferStorageOES")) {
+                        glEGLImageTargetRenderbufferStorageOES_impl = (PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC)addr;
+                        return (__eglMustCastToProperFunctionPointerType)glEGLImageTargetRenderbufferStorageOES_wrapper;
+                    }
+                    return addr;
+                }
+            }
+        }
+    }
+#endif
+
     // this protects accesses to gGLExtentionMap and gGLExtentionSlot
     pthread_mutex_lock(&gInitDriverMutex);
 
@@ -1843,3 +1908,19 @@ EGLBoolean eglSetSwapRectangleANDROID(EGLDisplay dpy, EGLSurface draw,
     }
     return setError(EGL_BAD_DISPLAY, NULL);
 }
+
+EGLClientBuffer eglGetRenderBufferANDROID(EGLDisplay dpy, EGLSurface draw)
+{
+    SurfaceRef _s(draw);
+    if (!_s.get()) return setError(EGL_BAD_SURFACE, (EGLClientBuffer*)0);
+
+    if (!validate_display_surface(dpy, draw))
+        return 0;
+    egl_display_t const * const dp = get_display(dpy);
+    egl_surface_t const * const s = get_surface(draw);
+    if (s->cnx->egl.eglGetRenderBufferANDROID) {
+        return s->cnx->egl.eglGetRenderBufferANDROID(
+                dp->disp[s->impl].dpy, s->surface);
+    }
+    return setError(EGL_BAD_DISPLAY, (EGLClientBuffer*)0);
+}
diff --git a/opengl/libs/GLES2/gl2.cpp b/opengl/libs/GLES2/gl2.cpp
index 18dd483..af5734c 100644
--- a/opengl/libs/GLES2/gl2.cpp
+++ b/opengl/libs/GLES2/gl2.cpp
@@ -41,9 +41,18 @@ using namespace android;
 
 #if USE_FAST_TLS_KEY
 
+    #ifdef HAVE_TEGRA_ERRATA_657451
+        #define MUNGE_TLS(_tls) \
+            "bfi " #_tls ", " #_tls ", #20, #1 \n" \
+            "bic " #_tls ", " #_tls ", #1 \n"
+    #else
+        #define MUNGE_TLS(_tls) "\n"
+    #endif
+
     #ifdef HAVE_ARM_TLS_REGISTER
         #define GET_TLS(reg) \
-            "mrc p15, 0, " #reg ", c13, c0, 3 \n"
+            "mrc p15, 0, " #reg ", c13, c0, 3 \n" \
+            MUNGE_TLS(reg)
     #else
         #define GET_TLS(reg) \
             "mov   " #reg ", #0xFFFF0FFF      \n"  \
diff --git a/opengl/libs/GLES_CM/gl.cpp b/opengl/libs/GLES_CM/gl.cpp
index ee29f12..b62515b 100644
--- a/opengl/libs/GLES_CM/gl.cpp
+++ b/opengl/libs/GLES_CM/gl.cpp
@@ -97,9 +97,18 @@ GL_API void GL_APIENTRY glWeightPointerOESBounds(GLint size, GLenum type,
 
 #if USE_FAST_TLS_KEY && !CHECK_FOR_GL_ERRORS
 
+    #ifdef HAVE_TEGRA_ERRATA_657451
+        #define MUNGE_TLS(_tls) \
+            "bfi " #_tls ", " #_tls ", #20, #1 \n" \
+            "bic " #_tls ", " #_tls ", #1 \n"
+    #else
+        #define MUNGE_TLS(_tls) "\n"
+    #endif
+
     #ifdef HAVE_ARM_TLS_REGISTER
         #define GET_TLS(reg) \
-            "mrc p15, 0, " #reg ", c13, c0, 3 \n"
+            "mrc p15, 0, " #reg ", c13, c0, 3 \n" \
+            MUNGE_TLS(reg)
     #else
         #define GET_TLS(reg) \
             "mov   " #reg ", #0xFFFF0FFF      \n"  \
diff --git a/opengl/tests/gl_jni/jni/gl_code.cpp b/opengl/tests/gl_jni/jni/gl_code.cpp
index f031c79..ef66841 100644
--- a/opengl/tests/gl_jni/jni/gl_code.cpp
+++ b/opengl/tests/gl_jni/jni/gl_code.cpp
@@ -181,4 +181,3 @@ JNIEXPORT void JNICALL Java_com_android_gljni_GLJNILib_changeBackground(JNIEnv *
 {
     background = 1.0f - background;
 }
-
diff --git a/services/audioflinger/A2dpAudioInterface.cpp b/services/audioflinger/A2dpAudioInterface.cpp
index 995e31c..e55a94c 100644
--- a/services/audioflinger/A2dpAudioInterface.cpp
+++ b/services/audioflinger/A2dpAudioInterface.cpp
@@ -205,6 +205,13 @@ status_t A2dpAudioInterface::setVoiceVolume(float v)
     return mHardwareInterface->setVoiceVolume(v);
 }
 
+#ifdef HAVE_FM_RADIO
+status_t A2dpAudioInterface::setFmVolume(float v)
+{
+    return mHardwareInterface->setFmVolume(v);
+}
+#endif
+
 status_t A2dpAudioInterface::setMasterVolume(float v)
 {
     return mHardwareInterface->setMasterVolume(v);
diff --git a/services/audioflinger/A2dpAudioInterface.h b/services/audioflinger/A2dpAudioInterface.h
index 48154f9..65f4875 100644
--- a/services/audioflinger/A2dpAudioInterface.h
+++ b/services/audioflinger/A2dpAudioInterface.h
@@ -67,6 +67,9 @@ public:
                                 status_t *status,
                                 AudioSystem::audio_in_acoustics acoustics);
     virtual    void        closeInputStream(AudioStreamIn* in);
+#ifdef HAVE_FM_RADIO
+    virtual status_t    setFmVolume(float volume);
+#endif
 //    static AudioHardwareInterface* createA2dpInterface();
 
 protected:
diff --git a/services/audioflinger/AudioDumpInterface.h b/services/audioflinger/AudioDumpInterface.h
index 814ce5f..cdbb253 100644
--- a/services/audioflinger/AudioDumpInterface.h
+++ b/services/audioflinger/AudioDumpInterface.h
@@ -153,7 +153,10 @@ public:
     virtual    void        closeInputStream(AudioStreamIn* in);
 
     virtual status_t    dump(int fd, const Vector<String16>& args) { return mFinalInterface->dumpState(fd, args); }
-
+#ifdef HAVE_FM_RADIO
+    virtual status_t    setFmVolume(float volume)
+                            {return mFinalInterface->setFmVolume(volume);}
+#endif
             String8     fileName() const { return mFileName; }
 protected:
 
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 5935bf9..d1dcb1e 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -129,7 +129,13 @@ static bool settingsAllowed() {
 
 AudioFlinger::AudioFlinger()
     : BnAudioFlinger(),
+#ifdef OMAP_ENHANCEMENT
+        mAudioHardware(0), mFmEnabled(false), mMasterVolume(1.0f), mMasterMute(false), mNextUniqueId(1)
+#elif defined(HAVE_FM_RADIO)
+        mAudioHardware(0), mMasterVolume(1.0f), mMasterMute(false), mNextUniqueId(1),  mFmOn(false)
+#else
         mAudioHardware(0), mMasterVolume(1.0f), mMasterMute(false), mNextUniqueId(1)
+#endif
 {
     mHardwareStatus = AUDIO_HW_IDLE;
 
@@ -624,6 +630,11 @@ bool AudioFlinger::isStreamActive(int stream) const
             return true;
         }
     }
+#ifdef HAVE_FM_RADIO
+    if (mFmOn && stream == AudioSystem::MUSIC) {
+        return true;
+    }
+#endif
     return false;
 }
 
@@ -660,7 +671,30 @@ status_t AudioFlinger::setParameters(int ioHandle, const String8& keyValuePairs)
         }
     }
 #endif
+#if defined(HAVE_FM_RADIO) && !defined(HAS_LGE_STAR_FM_RADIO)
+    AudioParameter param = AudioParameter(keyValuePairs);
+    String8 key = String8(AudioParameter::keyRouting);
+    int device;
+    if (param.getInt(key, device) == NO_ERROR) {
+        if((device & AudioSystem::DEVICE_OUT_FM_ALL) && mFmOn == false){
+            mFmOn = true;
+         } else if (mFmOn == true && !(device & AudioSystem::DEVICE_OUT_FM_ALL)){
+            mFmOn = false;
+         }
+    }
 
+    String8 fmOnKey = String8(AudioParameter::keyFmOn);
+    String8 fmOffKey = String8(AudioParameter::keyFmOff);
+    if (param.getInt(fmOnKey, device) == NO_ERROR) {
+        mFmOn = true;
+        // Call hardware to switch FM on/off
+        mAudioHardware->setParameters(keyValuePairs);
+    } else if (param.getInt(fmOffKey, device) == NO_ERROR) {
+        mFmOn = false;
+        // Call hardware to switch FM on/off
+        mAudioHardware->setParameters(keyValuePairs);
+    }
+#endif
     // ioHandle == 0 means the parameters are global to the audio hardware interface
     if (ioHandle == 0) {
         AutoMutex lock(mHardwareLock);
@@ -768,6 +802,64 @@ status_t AudioFlinger::getRenderPosition(uint32_t *halFrames, uint32_t *dspFrame
     return BAD_VALUE;
 }
 
+#ifdef HAVE_FM_RADIO
+#ifdef USE_BROADCOM_FM_VOLUME_HACK
+/*
+ * NASTY HACK: Send raw HCI data to adjust the FM volume.
+ *
+ * Normally we would do this in libaudio, but this is for the case where
+ * we have a prebuilt libaudio and cannot modify it.
+ */
+static status_t set_volume_fm(uint32_t volume)
+{
+    int returnval = 0;
+    float ratio = 2.5;
+
+     char s1[100] = "hcitool cmd 0x3f 0xa 0x5 0xc0 0x41 0xf 0 0x20 0 0 0";
+     char s2[100] = "hcitool cmd 0x3f 0xa 0x5 0xe4 0x41 0xf 0 0x00 0 0 0";
+     char s3[100] = "hcitool cmd 0x3f 0xa 0x5 0xe0 0x41 0xf 0 ";
+
+     char stemp[10] = "";
+     char *pstarget = s3;
+
+     volume = (unsigned int)(volume * ratio);
+
+     sprintf(stemp, "0x%x ", volume);
+     pstarget = strcat(s3, stemp);
+     pstarget = strcat(s3, "0 0 0");
+
+     system(s1);
+     system(s2);
+     system(s3);
+
+     return returnval;
+}
+#endif
+
+status_t AudioFlinger::setFmVolume(float value)
+{
+	status_t ret;
+
+    // check calling permissions
+    if (!settingsAllowed()) {
+        return PERMISSION_DENIED;
+    }
+
+    AutoMutex lock(mHardwareLock);
+    mHardwareStatus = AUDIO_SET_FM_VOLUME;
+#ifdef USE_BROADCOM_FM_VOLUME_HACK
+    int vol = AudioSystem::logToLinear(value);
+    LOGI("setFmVolume %d", vol);
+    ret = set_volume_fm(vol);
+#else
+    ret = mAudioHardware->setFmVolume(value);
+#endif
+    mHardwareStatus = AUDIO_HW_IDLE;
+
+    return ret;
+}
+#endif
+
 void AudioFlinger::registerClient(const sp<IAudioFlingerClient>& client)
 {
 
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index 5917632..2ecbceb 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -170,6 +170,10 @@ public:
 
     virtual status_t moveEffects(int session, int srcOutput, int dstOutput);
 
+#ifdef HAVE_FM_RADIO
+    virtual status_t setFmVolume(float volume);
+#endif
+
     enum hardware_call_state {
         AUDIO_HW_IDLE = 0,
         AUDIO_HW_INIT,
@@ -187,6 +191,9 @@ public:
         AUDIO_HW_SET_MIC_MUTE,
         AUDIO_SET_VOICE_VOLUME,
         AUDIO_SET_PARAMETER,
+#ifdef HAVE_FM_RADIO
+        AUDIO_SET_FM_VOLUME
+#endif
     };
 
     // record interface
@@ -1190,6 +1197,9 @@ private:
 #endif
                 uint32_t mMode;
 
+#ifdef HAVE_FM_RADIO
+                bool                                mFmOn;
+#endif
 };
 
 // ----------------------------------------------------------------------------
diff --git a/services/audioflinger/AudioHardwareGeneric.cpp b/services/audioflinger/AudioHardwareGeneric.cpp
index d63c031..64d2bc5 100644
--- a/services/audioflinger/AudioHardwareGeneric.cpp
+++ b/services/audioflinger/AudioHardwareGeneric.cpp
@@ -142,6 +142,14 @@ status_t AudioHardwareGeneric::setVoiceVolume(float v)
     return NO_ERROR;
 }
 
+#ifdef HAVE_FM_RADIO
+status_t AudioHardwareGeneric::setFmVolume(float v)
+{
+    // Implement: set fm volume
+    return NO_ERROR;
+}
+#endif
+
 status_t AudioHardwareGeneric::setMasterVolume(float v)
 {
     // Implement: set master volume
diff --git a/services/audioflinger/AudioHardwareGeneric.h b/services/audioflinger/AudioHardwareGeneric.h
index aa4e78d..8b3e123 100644
--- a/services/audioflinger/AudioHardwareGeneric.h
+++ b/services/audioflinger/AudioHardwareGeneric.h
@@ -105,6 +105,9 @@ public:
     virtual             ~AudioHardwareGeneric();
     virtual status_t    initCheck();
     virtual status_t    setVoiceVolume(float volume);
+#ifdef HAVE_FM_RADIO
+    virtual status_t    setFmVolume(float volume);
+#endif
     virtual status_t    setMasterVolume(float volume);
 
     // mic mute
diff --git a/services/audioflinger/AudioHardwareStub.cpp b/services/audioflinger/AudioHardwareStub.cpp
index d481150..9460259 100644
--- a/services/audioflinger/AudioHardwareStub.cpp
+++ b/services/audioflinger/AudioHardwareStub.cpp
@@ -91,6 +91,13 @@ status_t AudioHardwareStub::setVoiceVolume(float volume)
     return NO_ERROR;
 }
 
+#ifdef HAVE_FM_RADIO
+status_t AudioHardwareStub::setFmVolume(float volume)
+{
+    return NO_ERROR;
+}
+#endif
+
 status_t AudioHardwareStub::setMasterVolume(float volume)
 {
     return NO_ERROR;
diff --git a/services/audioflinger/AudioHardwareStub.h b/services/audioflinger/AudioHardwareStub.h
index 06a29de..8b2503c 100644
--- a/services/audioflinger/AudioHardwareStub.h
+++ b/services/audioflinger/AudioHardwareStub.h
@@ -67,6 +67,9 @@ public:
     virtual             ~AudioHardwareStub();
     virtual status_t    initCheck();
     virtual status_t    setVoiceVolume(float volume);
+#ifdef HAVE_FM_RADIO
+    virtual status_t    setFmVolume(float volume);
+#endif
     virtual status_t    setMasterVolume(float volume);
 
     // mic mute
diff --git a/services/audioflinger/AudioPolicyManagerBase.cpp b/services/audioflinger/AudioPolicyManagerBase.cpp
index 4612af1..9c66bb6 100644
--- a/services/audioflinger/AudioPolicyManagerBase.cpp
+++ b/services/audioflinger/AudioPolicyManagerBase.cpp
@@ -83,6 +83,15 @@ status_t AudioPolicyManagerBase::setDeviceConnectionState(AudioSystem::audio_dev
                     mScoDeviceAddress = String8(device_address, MAX_DEVICE_ADDRESS_LEN);
                 }
             }
+#ifdef HAVE_FM_RADIO
+            if (AudioSystem::isFmDevice(device)) {
+                AudioOutputDescriptor *hwOutputDesc = mOutputs.valueFor(mHardwareOutput);
+                hwOutputDesc->mRefCount[AudioSystem::FM] = 1;
+                AudioParameter param = AudioParameter();
+                param.addInt(String8(AudioParameter::keyFmOn), mAvailableOutputDevices);
+                mpClientInterface->setParameters(mHardwareOutput, param.toString());
+            }
+#endif
             break;
         // handle output device disconnection
         case AudioSystem::DEVICE_STATE_UNAVAILABLE: {
@@ -111,6 +120,15 @@ status_t AudioPolicyManagerBase::setDeviceConnectionState(AudioSystem::audio_dev
                     mScoDeviceAddress = "";
                 }
             }
+#ifdef HAVE_FM_RADIO
+            if (AudioSystem::isFmDevice(device)) {
+                AudioOutputDescriptor *hwOutputDesc = mOutputs.valueFor(mHardwareOutput);
+                hwOutputDesc->mRefCount[AudioSystem::FM] = 0;
+                AudioParameter param = AudioParameter();
+                param.addInt(String8(AudioParameter::keyFmOff), mAvailableOutputDevices);
+                mpClientInterface->setParameters(mHardwareOutput, param.toString());
+            }
+#endif
             } break;
 
         default:
@@ -343,7 +361,12 @@ void AudioPolicyManagerBase::setForceUse(AudioSystem::force_use usage, AudioSyst
         break;
     case AudioSystem::FOR_MEDIA:
         if (config != AudioSystem::FORCE_HEADPHONES && config != AudioSystem::FORCE_BT_A2DP &&
+#ifdef HAVE_FM_RADIO
+            config != AudioSystem::FORCE_WIRED_ACCESSORY && config != AudioSystem::FORCE_SPEAKER &&
+            config != AudioSystem::FORCE_NONE) {
+#else
             config != AudioSystem::FORCE_WIRED_ACCESSORY && config != AudioSystem::FORCE_NONE) {
+#endif
             LOGW("setForceUse() invalid config %d for FOR_MEDIA", config);
             return;
         }
@@ -1537,6 +1560,9 @@ AudioPolicyManagerBase::routing_strategy AudioPolicyManagerBase::getStrategy(
         // while key clicks are played produces a poor result
     case AudioSystem::TTS:
     case AudioSystem::MUSIC:
+#ifdef HAVE_FM_RADIO
+    case AudioSystem::FM:
+#endif
         return STRATEGY_MEDIA;
     }
 }
@@ -1633,7 +1659,17 @@ uint32_t AudioPolicyManagerBase::getDeviceForStrategy(routing_strategy strategy,
         // FALL THROUGH
 
     case STRATEGY_MEDIA: {
+#ifdef HAVE_FM_RADIO
+        uint32_t device2 = 0;
+        if (mForceUse[AudioSystem::FOR_MEDIA] == AudioSystem::FORCE_SPEAKER) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_SPEAKER;
+        }
+        if (device2 == 0) {
+            device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_AUX_DIGITAL;
+        }
+#else
         uint32_t device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_AUX_DIGITAL;
+#endif
         if (device2 == 0) {
             device2 = mAvailableOutputDevices & AudioSystem::DEVICE_OUT_WIRED_HEADPHONE;
         }
@@ -1848,6 +1884,9 @@ status_t AudioPolicyManagerBase::checkAndSetVolume(int stream, int index, audio_
     // - the float value returned by computeVolume() changed
     // - the force flag is set
     if (volume != mOutputs.valueFor(output)->mCurVolume[stream] ||
+#ifdef HAVE_FM_RADIO
+            (stream == AudioSystem::FM) ||
+#endif
             force) {
         mOutputs.valueFor(output)->mCurVolume[stream] = volume;
         LOGV("setStreamVolume() for output %d stream %d, volume %f, delay %d", output, stream, volume, delayMs);
@@ -1857,6 +1896,15 @@ status_t AudioPolicyManagerBase::checkAndSetVolume(int stream, int index, audio_
             // offset value to reflect actual hardware volume that never reaches 0
             // 1% corresponds roughly to first step in VOICE_CALL stream volume setting (see AudioService.java)
             volume = 0.01 + 0.99 * volume;
+#ifdef HAVE_FM_RADIO
+        } else if (stream == AudioSystem::FM) {
+            float fmVolume = -1.0;
+            fmVolume = computeVolume(stream, index, output, device);
+            if (fmVolume >= 0 && output == mHardwareOutput) {
+                mpClientInterface->setFmVolume(fmVolume, delayMs);
+            }
+            return NO_ERROR;
+#endif
         }
         mpClientInterface->setStreamVolume((AudioSystem::stream_type)stream, volume, output, delayMs);
     }
diff --git a/services/audioflinger/AudioPolicyService.cpp b/services/audioflinger/AudioPolicyService.cpp
index f24e08e..eb0e7e0 100644
--- a/services/audioflinger/AudioPolicyService.cpp
+++ b/services/audioflinger/AudioPolicyService.cpp
@@ -622,6 +622,13 @@ status_t AudioPolicyService::setVoiceVolume(float volume, int delayMs)
     return mAudioCommandThread->voiceVolumeCommand(volume, delayMs);
 }
 
+#ifdef HAVE_FM_RADIO
+status_t AudioPolicyService::setFmVolume(float volume, int delayMs)
+{
+    return mAudioCommandThread->fmVolumeCommand(volume, delayMs);
+}
+#endif
+
 // -----------  AudioPolicyService::AudioCommandThread implementation ----------
 
 AudioPolicyService::AudioCommandThread::AudioCommandThread(String8 name)
@@ -722,6 +729,18 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                     }
                     delete data;
                     }break;
+#ifdef HAVE_FM_RADIO
+                case SET_FM_VOLUME: {
+                    FmVolumeData *data = (FmVolumeData *)command->mParam;
+                    LOGV("AudioCommandThread() processing set fm volume volume %f", data->mVolume);
+                    command->mStatus = AudioSystem::setFmVolume(data->mVolume);
+                    if (command->mWaitStatus) {
+                        command->mCond.signal();
+                        mWaitWorkCV.wait(mLock);
+                    }
+                    delete data;
+                    }break;
+#endif
                 default:
                     LOGW("AudioCommandThread() unknown command %d", command->mCommand);
                 }
@@ -893,6 +912,34 @@ status_t AudioPolicyService::AudioCommandThread::voiceVolumeCommand(float volume
     return status;
 }
 
+#ifdef HAVE_FM_RADIO
+status_t AudioPolicyService::AudioCommandThread::fmVolumeCommand(float volume, int delayMs)
+{
+    status_t status = NO_ERROR;
+
+    AudioCommand *command = new AudioCommand();
+    command->mCommand = SET_FM_VOLUME;
+    FmVolumeData *data = new FmVolumeData();
+    data->mVolume = volume;
+    command->mParam = data;
+    if (delayMs == 0) {
+        command->mWaitStatus = true;
+    } else {
+        command->mWaitStatus = false;
+    }
+    Mutex::Autolock _l(mLock);
+    insertCommand_l(command, delayMs);
+    LOGV("AudioCommandThread() adding set fm volume volume %f", volume);
+    mWaitWorkCV.signal();
+    if (command->mWaitStatus) {
+        command->mCond.wait(mLock);
+        status =  command->mStatus;
+        mWaitWorkCV.signal();
+    }
+    return status;
+}
+#endif
+
 // insertCommand_l() must be called with mLock held
 void AudioPolicyService::AudioCommandThread::insertCommand_l(AudioCommand *command, int delayMs)
 {
@@ -955,6 +1002,11 @@ void AudioPolicyService::AudioCommandThread::insertCommand_l(AudioCommand *comma
                     data->mIO, data->mStream);
             removedCommands.add(command2);
         } break;
+#ifdef HAVE_FM_RADIO
+        case SET_FM_VOLUME: {
+            removedCommands.add(command2);
+        } break;
+#endif
         case START_TONE:
         case STOP_TONE:
         default:
diff --git a/services/audioflinger/AudioPolicyService.h b/services/audioflinger/AudioPolicyService.h
index 558f455..94d07de 100644
--- a/services/audioflinger/AudioPolicyService.h
+++ b/services/audioflinger/AudioPolicyService.h
@@ -133,6 +133,9 @@ public:
     virtual status_t moveEffects(int session,
                                      audio_io_handle_t srcOutput,
                                      audio_io_handle_t dstOutput);
+#ifdef HAVE_FM_RADIO
+    virtual status_t setFmVolume(float volume, int delayMs = 0);
+#endif
 
 private:
                         AudioPolicyService();
@@ -156,7 +159,10 @@ private:
             STOP_TONE,
             SET_VOLUME,
             SET_PARAMETERS,
-            SET_VOICE_VOLUME
+            SET_VOICE_VOLUME,
+#ifdef HAVE_FM_RADIO
+            SET_FM_VOLUME
+#endif
         };
 
         AudioCommandThread (String8 name);
@@ -174,6 +180,9 @@ private:
                     status_t    volumeCommand(int stream, float volume, int output, int delayMs = 0);
                     status_t    parametersCommand(int ioHandle, const String8& keyValuePairs, int delayMs = 0);
                     status_t    voiceVolumeCommand(float volume, int delayMs = 0);
+#ifdef HAVE_FM_RADIO
+                    status_t    fmVolumeCommand(float volume, int delayMs = 0);
+#endif
                     void        insertCommand_l(AudioCommand *command, int delayMs = 0);
 
     private:
@@ -217,7 +226,12 @@ private:
         public:
             float mVolume;
         };
-
+#ifdef HAVE_FM_RADIO
+        class FmVolumeData {
+        public:
+            float mVolume;
+        };
+#endif
         Mutex   mLock;
         Condition mWaitWorkCV;
         Vector <AudioCommand *> mAudioCommands; // list of pending commands
diff --git a/telephony/java/android/telephony/NeighboringCellInfo.java b/telephony/java/android/telephony/NeighboringCellInfo.java
index 2f7666d..3ca8056 100644
--- a/telephony/java/android/telephony/NeighboringCellInfo.java
+++ b/telephony/java/android/telephony/NeighboringCellInfo.java
@@ -25,6 +25,7 @@ import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPAP;
 
 
 
@@ -143,6 +144,7 @@ public class NeighboringCellInfo implements Parcelable
             case NETWORK_TYPE_HSDPA:
             case NETWORK_TYPE_HSUPA:
             case NETWORK_TYPE_HSPA:
+            case NETWORK_TYPE_HSPAP:
                 mNetworkType = radioType;
                 mPsc = Integer.valueOf(location, 16);
                 break;
diff --git a/telephony/java/android/telephony/PhoneNumberUtils.java b/telephony/java/android/telephony/PhoneNumberUtils.java
index 5542c42..ef76ad0 100644
--- a/telephony/java/android/telephony/PhoneNumberUtils.java
+++ b/telephony/java/android/telephony/PhoneNumberUtils.java
@@ -55,6 +55,12 @@ public class PhoneNumberUtils
     public static final char WILD = 'N';
 
     /*
+     * Calling Line Identification Restriction (CLIR)
+     */
+    private static final String CLIR_ON = "*31#+";
+    private static final String CLIR_OFF = "#31#+";
+
+    /*
      * TOA = TON + NPI
      * See TS 24.008 section 10.5.4.7 for details.
      * These are the only really useful TOA values
@@ -179,8 +185,6 @@ public class PhoneNumberUtils
      *  Please note that the GSM wild character is allowed in the result.
      *  This must be resolved before dialing.
      *
-     *  Allows + only in the first  position in the result string.
-     *
      *  Returns null if phoneNumber == null
      */
     public static String
@@ -203,6 +207,11 @@ public class PhoneNumberUtils
             }
         }
 
+        int pos = addPlusChar(phoneNumber);
+        if (pos >= 0 && ret.length() > pos) {
+            ret.insert(pos, '+');
+        }
+
         return ret.toString();
     }
 
@@ -304,6 +313,28 @@ public class PhoneNumberUtils
         }
     }
 
+    /** GSM codes
+     *  Finds if a GSM code includes the international prefix (+).
+     *
+     * @param number the number to dial.
+     *
+     * @return the position where the + char will be inserted, -1 if the GSM code was not found.
+     */
+    private static int
+    addPlusChar(String number) {
+        int pos = -1;
+
+        if (number.startsWith(CLIR_OFF)) {
+            pos = CLIR_OFF.length() - 1;
+        }
+
+        if (number.startsWith(CLIR_ON)) {
+            pos = CLIR_ON.length() - 1;
+        }
+
+        return pos;
+    }
+
     /**
      * Extracts the post-dial sequence of DTMF control digits, pauses, and
      * waits. Strips separators. This string may be empty, but will not be null
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index 35a2c19..5aaff0d 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2010, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -91,6 +92,12 @@ public class ServiceState implements Parcelable {
     public static final int RADIO_TECHNOLOGY_HSPA = 11;
     /** @hide */
     public static final int RADIO_TECHNOLOGY_EVDO_B = 12;
+    /** @hide */
+    public static final int RADIO_TECHNOLOGY_EHRPD = 13;
+    /** @hide */
+    public static final int RADIO_TECHNOLOGY_LTE = 14;
+    /** @hide */
+    public static final int RADIO_TECHNOLOGY_HSPAP = 15;
 
     /**
      * Available registration states for GSM, UMTS and CDMA.
@@ -424,6 +431,15 @@ public class ServiceState implements Parcelable {
         case 12:
             radioTechnology = "EvDo rev. B";
             break;
+        case RADIO_TECHNOLOGY_EHRPD:
+            radioTechnology = "EHRPD";
+            break;
+        case RADIO_TECHNOLOGY_LTE:
+            radioTechnology = "LTE";
+            break;
+        case RADIO_TECHNOLOGY_HSPAP:
+            radioTechnology = "HSPA+";
+            break;
         default:
             Log.w(LOG_TAG, "mRadioTechnology variable out of range.");
         break;
diff --git a/telephony/java/android/telephony/TelephonyManager.java b/telephony/java/android/telephony/TelephonyManager.java
index 69673b1..a52e1aa 100644
--- a/telephony/java/android/telephony/TelephonyManager.java
+++ b/telephony/java/android/telephony/TelephonyManager.java
@@ -397,6 +397,8 @@ public class TelephonyManager {
     public static final int NETWORK_TYPE_LTE = 13;
     /** @hide */
     public static final int NETWORK_TYPE_EHRPD = 14;
+    /** @hide */
+    public static final int NETWORK_TYPE_HSPAP = 15;
 
     /**
      * Returns a constant indicating the radio technology (network type)
@@ -415,6 +417,9 @@ public class TelephonyManager {
      * @see #NETWORK_TYPE_EVDO_A
      * @see #NETWORK_TYPE_EVDO_B
      * @see #NETWORK_TYPE_1xRTT
+     * @see #NETWORK_TYPE_EHRPD
+     * @see #NETWORK_TYPE_LTE
+     * @see #NETWORK_TYPE_HSPAP
      */
     public int getNetworkType() {
         try{
@@ -465,6 +470,12 @@ public class TelephonyManager {
                 return "CDMA - EvDo rev. B";
             case NETWORK_TYPE_1xRTT:
                 return "CDMA - 1xRTT";
+            case NETWORK_TYPE_EHRPD:
+                return "CDMA - EHRPD";
+            case NETWORK_TYPE_LTE:
+                return "LTE";
+            case NETWORK_TYPE_HSPAP:
+                return "HSPA+";
             default:
                 return "UNKNOWN";
         }
@@ -825,6 +836,20 @@ public class TelephonyManager {
         return ITelephony.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE));
     }
 
+    /** FastDormancy get/setter */
+    private static boolean sDormancyRejected = false;
+
+    /** @hide */
+    public static boolean isDormancyRejected() {
+        return getDefault().sDormancyRejected;
+    }
+
+    /** @hide */
+    public static boolean setDormancyRejected(boolean rejected) {
+        getDefault().sDormancyRejected = rejected;
+        return true;
+    }
+
     //
     //
     // PhoneStateListener
diff --git a/telephony/java/com/android/internal/telephony/AdnRecord.java b/telephony/java/com/android/internal/telephony/AdnRecord.java
index 1bf2d3c..a01b00d 100644
--- a/telephony/java/com/android/internal/telephony/AdnRecord.java
+++ b/telephony/java/com/android/internal/telephony/AdnRecord.java
@@ -283,7 +283,7 @@ public class AdnRecord implements Parcelable {
     private void
     parseRecord(byte[] record) {
         try {
-            alphaTag = IccUtils.adnStringFieldToString(
+            alphaTag = IccUtils.adnStringFieldToStringKsc5601Support(
                             record, 0, record.length - FOOTER_SIZE_BYTES);
 
             int footerOffset = record.length - FOOTER_SIZE_BYTES;
diff --git a/telephony/java/com/android/internal/telephony/AdnRecordCache.java b/telephony/java/com/android/internal/telephony/AdnRecordCache.java
index c8c0658..a175d49 100644
--- a/telephony/java/com/android/internal/telephony/AdnRecordCache.java
+++ b/telephony/java/com/android/internal/telephony/AdnRecordCache.java
@@ -186,7 +186,12 @@ public final class AdnRecordCache extends Handler implements IccConstants {
         }
 
         ArrayList<AdnRecord>  oldAdnList;
-        oldAdnList = getRecordsIfLoaded(efid);
+
+        if (efid == EF_PBR) {
+            oldAdnList = mUsimPhoneBookManager.loadEfFilesFromUsim();
+        } else {
+            oldAdnList = getRecordsIfLoaded(efid);
+        }
 
         if (oldAdnList == null) {
             sendErrorResponse(response, "Adn list not exist for EF:" + efid);
@@ -208,6 +213,17 @@ public final class AdnRecordCache extends Handler implements IccConstants {
             return;
         }
 
+        if (efid == EF_PBR) {
+            AdnRecord foundAdn = oldAdnList.get(index-1);
+            efid = foundAdn.efid;
+            extensionEF = foundAdn.extRecord;
+            index = foundAdn.recordNumber;
+
+            newAdn.efid = efid;
+            newAdn.extRecord = extensionEF;
+            newAdn.recordNumber = index;
+        }
+
         Message pendingResponse = userWriteResponse.get(efid);
 
         if (pendingResponse != null) {
@@ -331,6 +347,7 @@ public final class AdnRecordCache extends Handler implements IccConstants {
 
                 if (ar.exception == null) {
                     adnLikeFiles.get(efid).set(index - 1, adn);
+                    mUsimPhoneBookManager.invalidateCache();
                 }
 
                 Message response = userWriteResponse.get(efid);
diff --git a/telephony/java/com/android/internal/telephony/CallManager.java b/telephony/java/com/android/internal/telephony/CallManager.java
index b89058f..a2a0039 100644
--- a/telephony/java/com/android/internal/telephony/CallManager.java
+++ b/telephony/java/com/android/internal/telephony/CallManager.java
@@ -25,6 +25,7 @@ import android.os.Handler;
 import android.os.Message;
 import android.os.RegistrantList;
 import android.os.Registrant;
+import android.os.SystemProperties;
 import android.telephony.PhoneStateListener;
 import android.telephony.ServiceState;
 import android.util.Log;
@@ -78,6 +79,7 @@ public final class CallManager {
     private static final int EVENT_SUPP_SERVICE_FAILED = 117;
     private static final int EVENT_SERVICE_STATE_CHANGED = 118;
     private static final int EVENT_POST_DIAL_CHARACTER = 119;
+    private static final int EVENT_SUPP_SERVICE_NOTIFY = 120;
 
     // Singleton instance
     private static final CallManager INSTANCE = new CallManager();
@@ -100,6 +102,7 @@ public final class CallManager {
     // default phone as the first phone registered, which is PhoneBase obj
     private Phone mDefaultPhone;
 
+    private boolean acceptingRingingCall;
     // state registrants
     protected final RegistrantList mPreciseCallStateRegistrants
     = new RegistrantList();
@@ -158,6 +161,9 @@ public final class CallManager {
     protected final RegistrantList mSuppServiceFailedRegistrants
     = new RegistrantList();
 
+    protected final RegistrantList mSuppServiceNotificationRegistrants
+    = new RegistrantList();
+
     protected final RegistrantList mServiceStateChangedRegistrants
     = new RegistrantList();
 
@@ -170,6 +176,7 @@ public final class CallManager {
         mBackgroundCalls = new ArrayList<Call>();
         mForegroundCalls = new ArrayList<Call>();
         mDefaultPhone = null;
+        acceptingRingingCall = false;
     }
 
     /**
@@ -288,6 +295,27 @@ public final class CallManager {
      * @return true if register successfully
      */
     public boolean registerPhone(Phone phone) {
+        return this.registerPhoneInternal(phone, false);
+    }
+
+    /**
+     * Register phone to CallManager and force it as the default phone
+     *
+     * @param phone to be registered
+     * @return true if register successfully
+     */
+    public boolean registerPhoneAsDefault(Phone phone) {
+        return this.registerPhoneInternal(phone, true);
+    }
+
+    /**
+     * Internal phone registration function used in two phone registering cases
+     *
+     * @param phone to be registered
+     * @param overrideDefaultPhone is there a need to set this phone to be the default one
+     * @return true if register successfully
+     */
+    private boolean registerPhoneInternal(Phone phone, boolean overrideDefaultPhone) {
         Phone basePhone = getPhoneBase(phone);
 
         if (basePhone != null && !mPhones.contains(basePhone)) {
@@ -297,7 +325,7 @@ public final class CallManager {
                         phone.getPhoneName() + " " + phone + ")");
             }
 
-            if (mPhones.isEmpty()) {
+            if (mPhones.isEmpty() || overrideDefaultPhone) {
                 mDefaultPhone = basePhone;
             }
             mPhones.add(basePhone);
@@ -376,7 +404,12 @@ public final class CallManager {
         int mode = AudioManager.MODE_NORMAL;
         switch (getState()) {
             case RINGING:
-                mode = AudioManager.MODE_RINGTONE;
+                if (acceptingRingingCall) {
+                  mode = AudioManager.MODE_IN_CALL;
+                  acceptingRingingCall = false;
+                } else {
+                  mode = AudioManager.MODE_RINGTONE;
+                }
                 break;
             case OFFHOOK:
                 Phone fgPhone = getFgPhone();
@@ -394,6 +427,20 @@ public final class CallManager {
                 }
                 break;
         }
+
+        // Some samsung devices need a special parameter "realcall" set for incall audio
+        boolean mSamsungRealCall = SystemProperties.getBoolean("ro.telephony.samsung.realcall", false);
+
+        if(mSamsungRealCall == true) {
+            if (mode == AudioManager.MODE_IN_CALL) {
+                Log.d(LOG_TAG, "setAudioMode(): realcall=on");
+                audioManager.setParameters("realcall=on");
+            } else if (mode == AudioManager.MODE_NORMAL) {
+                Log.d(LOG_TAG, "setAudioMode(): realcall=off");
+                audioManager.setParameters("realcall=off");
+            }
+        }
+
         // calling audioManager.setMode() multiple times in a short period of
         // time seems to break the audio recorder in in-call mode
         if (audioManager.getMode() != mode) audioManager.setMode(mode);
@@ -421,6 +468,9 @@ public final class CallManager {
         phone.registerForMmiComplete(mHandler, EVENT_MMI_COMPLETE, null);
         phone.registerForSuppServiceFailed(mHandler, EVENT_SUPP_SERVICE_FAILED, null);
         phone.registerForServiceStateChanged(mHandler, EVENT_SERVICE_STATE_CHANGED, null);
+        if (phone.getPhoneType() == Phone.PHONE_TYPE_GSM) {
+            phone.registerForSuppServiceNotification(mHandler, EVENT_SUPP_SERVICE_NOTIFY, null);
+        }
 
         // for events supported only by GSM and CDMA phone
         if (phone.getPhoneType() == Phone.PHONE_TYPE_GSM ||
@@ -453,6 +503,7 @@ public final class CallManager {
         phone.unregisterForMmiInitiate(mHandler);
         phone.unregisterForMmiComplete(mHandler);
         phone.unregisterForSuppServiceFailed(mHandler);
+        phone.unregisterForSuppServiceNotification(mHandler);
         phone.unregisterForServiceStateChanged(mHandler);
 
         // for events supported only by GSM and CDMA phone
@@ -510,6 +561,7 @@ public final class CallManager {
         }
 
         ringingPhone.acceptCall();
+        acceptingRingingCall = true;
 
         if (VDBG) {
             Log.d(LOG_TAG, "End acceptCall(" +ringingCall + ")");
@@ -1260,6 +1312,27 @@ public final class CallManager {
     }
 
     /**
+     * Register for supplementary service notifications.
+     * Message.obj will contain an AsyncResult.
+     *
+     * @param h Handler that receives the notification message.
+     * @param what User-defined message code.
+     * @param obj User object.
+     */
+    public void registerForSuppServiceNotification(Handler h, int what, Object obj){
+        mSuppServiceNotificationRegistrants.addUnique(h, what, obj);
+    }
+
+    /**
+     * Unregister for supplementary service notifications.
+     *
+     * @param h Handler to be removed from the registrant list.
+     */
+    public void unregisterForSuppServiceNotification(Handler h){
+        mSuppServiceNotificationRegistrants.remove(h);
+    }
+
+    /**
      * Register for notifications when a sInCall VoicePrivacy is enabled
      *
      * @param h Handler that receives the notification message.
@@ -1768,6 +1841,10 @@ public final class CallManager {
                     if (VDBG) Log.d(LOG_TAG, " handleMessage (EVENT_SUPP_SERVICE_FAILED)");
                     mSuppServiceFailedRegistrants.notifyRegistrants((AsyncResult) msg.obj);
                     break;
+                case EVENT_SUPP_SERVICE_NOTIFY:
+                    if (VDBG) Log.d(LOG_TAG, " handleMessage (EVENT_SUPP_SERVICE_NOTIFICATION)");
+                    mSuppServiceNotificationRegistrants.notifyRegistrants((AsyncResult) msg.obj);
+                    break;
                 case EVENT_SERVICE_STATE_CHANGED:
                     if (VDBG) Log.d(LOG_TAG, " handleMessage (EVENT_SERVICE_STATE_CHANGED)");
                     mServiceStateChangedRegistrants.notifyRegistrants((AsyncResult) msg.obj);
diff --git a/telephony/java/com/android/internal/telephony/DataConnection.java b/telephony/java/com/android/internal/telephony/DataConnection.java
index 6634017..1d6da32 100644
--- a/telephony/java/com/android/internal/telephony/DataConnection.java
+++ b/telephony/java/com/android/internal/telephony/DataConnection.java
@@ -395,6 +395,8 @@ public abstract class DataConnection extends HierarchicalStateMachine {
         String[] response = ((String[]) ar.result);
         ConnectionParams cp = (ConnectionParams) ar.userObj;
 
+        boolean mIsSamsungCdma = SystemProperties.getBoolean("ro.ril.samsung_cdma", false);
+
         if (ar.exception != null) {
             if (DBG) log("DataConnection Init failed " + ar.exception);
 
@@ -418,11 +420,21 @@ public abstract class DataConnection extends HierarchicalStateMachine {
 //            }
             if (response.length >= 2) {
                 cid = Integer.parseInt(response[0]);
-                interfaceName = response[1];
                 if (response.length > 2) {
-                    ipAddress = response[2];
-                    String prefix = "net." + interfaceName + ".";
-                    gatewayAddress = SystemProperties.get(prefix + "gw");
+                    // Samsung CDMA devices do not export gateway/ip to the framework correctly
+                    // if using FroYo RIL blobs, we can extract it from system properties
+                    String prefix;
+                    if (mIsSamsungCdma) {
+                        interfaceName = "ppp0";
+                        prefix = "net." + interfaceName + ".";
+                        ipAddress = SystemProperties.get(prefix + "local-ip");
+                        gatewayAddress = SystemProperties.get(prefix + "remote-ip");
+                    } else {
+                        interfaceName = response[1];
+                        prefix = "net." + interfaceName + ".";
+                        ipAddress = response[2];
+                        gatewayAddress = SystemProperties.get(prefix + "gw");
+                    }
                     dnsServers[0] = SystemProperties.get(prefix + "dns1");
                     dnsServers[1] = SystemProperties.get(prefix + "dns2");
                     if (DBG) {
@@ -443,6 +455,10 @@ public abstract class DataConnection extends HierarchicalStateMachine {
                 result = SetupResult.ERR_Other;
             }
         }
+        // Samsung CDMA devices require this property to be set
+        // so that pppd will be called to start 3G data
+        if (mIsSamsungCdma)
+            SystemProperties.set("ril.cdma.data_ready", "true");
 
         if (DBG) log("DataConnection setup result='" + result + "' on cid=" + cid);
         return result;
diff --git a/telephony/java/com/android/internal/telephony/HTCRIL.java b/telephony/java/com/android/internal/telephony/HTCRIL.java
new file mode 100644
index 0000000..8611b37
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/HTCRIL.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.os.Message;
+import android.os.Parcel;
+import android.util.Log;
+
+import com.android.internal.telephony.gsm.NetworkInfo;
+
+import java.util.ArrayList;
+
+/**
+ * HTC RIL class
+ *
+ * {@hide}
+ */
+public class HTCRIL extends RIL implements CommandsInterface {
+    public HTCRIL(Context context) {
+        super(context);
+    }
+
+    public HTCRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected Object
+    responseNetworkInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<NetworkInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<NetworkInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            ret.add (
+                new NetworkInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/IccCard.java b/telephony/java/com/android/internal/telephony/IccCard.java
index d3a34ec..e270ce9 100644
--- a/telephony/java/com/android/internal/telephony/IccCard.java
+++ b/telephony/java/com/android/internal/telephony/IccCard.java
@@ -487,6 +487,12 @@ public abstract class IccCard {
                             CommandsInterface.SERVICE_CLASS_DATA +
                             CommandsInterface.SERVICE_CLASS_FAX;
 
+            if (!mPhone.mIsTheCurrentActivePhone) {
+                Log.e(mLogTag, "Received message " + msg + "[" + msg.what
+                        + "] while being destroyed. Ignoring.");
+                return;
+            }
+
             switch (msg.what) {
                 case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
                     mState = null;
@@ -626,7 +632,13 @@ public abstract class IccCard {
                 index = mIccCardStatus.getGsmUmtsSubscriptionAppIndex();
             }
 
-            IccCardApplication app = mIccCardStatus.getApplication(index);
+            IccCardApplication app;
+            if (index >= 0 && index < IccCardStatus.CARD_MAX_APPS) {
+                app = mIccCardStatus.getApplication(index);
+            } else {
+                Log.e(mLogTag, "[IccCard] Invalid Subscription Application index:" + index);
+                return IccCard.State.ABSENT;
+            }
 
             if (app == null) {
                 Log.e(mLogTag, "[IccCard] Subscription Application in not present");
@@ -672,12 +684,11 @@ public abstract class IccCard {
      * @return true if a ICC card is present
      */
     public boolean hasIccCard() {
-        boolean isIccPresent;
-        if (mPhone.getPhoneName().equals("GSM")) {
-            return mIccCardStatus.getCardState().isCardPresent();
-        } else {
-            // TODO: Make work with a CDMA device with a RUIM card.
+        if (mIccCardStatus == null) {
             return false;
+        } else {
+            // Returns ICC card status for both GSM and CDMA mode
+            return mIccCardStatus.getCardState().isCardPresent();
         }
     }
 
diff --git a/telephony/java/com/android/internal/telephony/IccCardApplication.java b/telephony/java/com/android/internal/telephony/IccCardApplication.java
index 9f60a6c..4a04d8a 100644
--- a/telephony/java/com/android/internal/telephony/IccCardApplication.java
+++ b/telephony/java/com/android/internal/telephony/IccCardApplication.java
@@ -115,6 +115,7 @@ public class IccCardApplication {
             case 2: newType = AppType.APPTYPE_USIM;    break;
             case 3: newType = AppType.APPTYPE_RUIM;    break;
             case 4: newType = AppType.APPTYPE_CSIM;    break;
+            case 5: newType = AppType.APPTYPE_USIM;    break;
             default:
                 throw new RuntimeException(
                             "Unrecognized RIL_AppType: " +type);
diff --git a/telephony/java/com/android/internal/telephony/IccConstants.java b/telephony/java/com/android/internal/telephony/IccConstants.java
index acc9197..b12d2d4 100644
--- a/telephony/java/com/android/internal/telephony/IccConstants.java
+++ b/telephony/java/com/android/internal/telephony/IccConstants.java
@@ -52,6 +52,7 @@ public interface IccConstants {
     static final int EF_SPN_CPHS = 0x6f14;
     static final int EF_SPN_SHORT_CPHS = 0x6f18;
     static final int EF_INFO_CPHS = 0x6f16;
+    static final int EF_CSP_CPHS = 0x6f15;
 
     // CDMA RUIM file ids from 3GPP2 C.S0023-0
     static final int EF_CST = 0x6f32;
diff --git a/telephony/java/com/android/internal/telephony/IccFileHandler.java b/telephony/java/com/android/internal/telephony/IccFileHandler.java
index 92ddd2c..03bb371 100644
--- a/telephony/java/com/android/internal/telephony/IccFileHandler.java
+++ b/telephony/java/com/android/internal/telephony/IccFileHandler.java
@@ -104,7 +104,7 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
 
         LoadLinearFixedContext(int efid, int recordNum, Message onLoaded) {
             this.efid = efid;
-            this.recordNum = recordNum;
+            this.recordNum = java.lang.Math.max(recordNum, 1); // Clamp to 1 since the index is 1 based, just in case
             this.onLoaded = onLoaded;
             this.loadAll = false;
         }
@@ -283,6 +283,126 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
         response.sendToTarget();
     }
 
+    /**
+     * Fills a 3 integer array. This is necessary for many canadian carriers for which
+     * UICC contains commands in TLV format (Refer 11.1.1.3 of ETSI TS 102 221)
+     *
+     * @param data
+     * @param arrayToReturn : [0] = Record Size; [1] = File Size; [2] = Number of Records
+     */
+    private void ParseUICCTLVData(byte[] data, int[] arrayToReturn) throws IccFileTypeMismatch {
+        int curByte = 0;
+        int curTag;
+        int curSectionLen;
+        if (((short)data[curByte++] & 0xFF) == 0x62) {
+            logd("TLV format detected");
+            curSectionLen = data[curByte++];
+            int dataLenLeft = data.length-2;
+            if (curSectionLen != dataLenLeft) {
+                logd("Unexpected TLV length of " + curSectionLen + "; we have " + dataLenLeft + "bytes of data left");
+                // ... It sometimes happens, even if mandatory parts are missing and length > than the actual size. Data is truncated?
+                // throw new IccFileTypeMismatch();
+            }
+
+            // File Descriptor '0x82' (mandatory)
+            curTag = ((int)data[curByte++]) & 0xFF;
+            if (curTag != 0x82) {
+                logd("Unexpected TLV data, expecting file descriptor tag, but got " + curTag);
+                throw new IccFileTypeMismatch();
+            }
+            curSectionLen = data[curByte++];
+            if (curSectionLen != 5) {
+                // TODO : Currently, a length of 2 is not handled
+                logd("TLV File Description length of " + curSectionLen + " is not handled yet");
+                throw new IccFileTypeMismatch();
+            }
+            arrayToReturn[0] = ((data[curByte+2] & 0xff) << 8) +
+                                (data[curByte+3] & 0xff); // Length of 1 record
+            arrayToReturn[2] = data[curByte+4]; // Number of records
+
+            // File size is normally set later, but for some reason, sometimes the data
+            // is missing mandatory section. For this reason, set the information here
+            // it should match anyway... (honestly, I'm not sure)
+            arrayToReturn[1] = arrayToReturn[0] * arrayToReturn[2];
+            curByte += curSectionLen;
+
+            // File Identifier '0x83' (mandatory)
+            curTag = ((int)data[curByte++]) & 0xFF;
+            if (curTag != 0x83) {
+                logd("Unexpected TLV data, expecting file identifier tag, but got " + curTag);
+                throw new IccFileTypeMismatch();
+            }
+            curSectionLen = data[curByte++];
+            curByte += curSectionLen;
+
+            // Proprietary info '0xA5' (optional)
+            curTag = ((int)data[curByte]) & 0xFF;
+            if (curTag == 0xA5) {
+                // Not needed, just skip it...
+                curByte++;
+                curSectionLen = data[curByte++];
+                curByte += curSectionLen;
+            }
+
+            // Data is sometimes truncated!? Mandatory parts are sometimes missing and TLV length > than the actual data size.
+            // Do not throw exception, try to do our best
+            if (data.length > curByte) {
+                // Life Cycle Status Integer '0x8A' (mandatory)
+                curTag = ((int)data[curByte++]) & 0xFF;
+                if (curTag != 0x8A) {
+                    logd("Unexpected TLV data, expecting Life Cycle Status Integer tag, but got " + curTag);
+                    throw new IccFileTypeMismatch();
+                }
+                // Not needed, just skip it...
+                curSectionLen = data[curByte++];
+                curByte += curSectionLen;
+            }
+
+            // Data is sometimes truncated!? Mandatory parts are sometimes missing and TLV length > than the actual data size.
+            // Do not throw exception, try to do our best
+            if (data.length > curByte) {
+                // Security Attributes '0x8B' / '0x8C' / '0xAB'  (exactly one of them is mandatory)
+                curTag = ((int)data[curByte++]) & 0xFF;
+                if (curTag != 0x8B &&
+                    curTag != 0x8C &&
+                    curTag != 0xAB) {
+                    logd("Unexpected TLV data, expecting Security Attributes tag, but got " + curTag);
+                    throw new IccFileTypeMismatch();
+                }
+                // Not needed, just skip it...
+                curSectionLen = data[curByte++];
+                curByte += curSectionLen;
+            }
+
+            // Data is sometimes truncated!? Mandatory parts are sometimes missing and TLV length > than the actual data size.
+            // Do not throw exception, try to do our best
+            if (data.length > curByte) {
+                // File Size '0x80'  (mandatory)
+                curTag = ((int)data[curByte++]) & 0xFF;
+                if (curTag != 0x80) {
+                    logd("Unexpected TLV data, expecting File Size tag, but got " + curTag);
+                    throw new IccFileTypeMismatch();
+                }
+                curSectionLen = data[curByte++];
+                arrayToReturn[1] = 0;
+                for (int i = 0; i < curSectionLen; i++) {
+                    arrayToReturn[1] += ((data[i] & 0xff) << (8*i)); // File size
+                }
+                curByte += curSectionLen;
+            }
+
+            logd("ParseUICCTLVData result: Record Size = " + arrayToReturn[0] + "; File Size = " + arrayToReturn[1] + "; Number of Records = " + arrayToReturn[2]);
+
+            // Total File Size '0x81' (optional)
+            // Short File Identifier '0x88' (optional)
+            // --> not used...
+        }
+        else {
+            logd("Throwing exception : Expecting a TLV tag!");
+            throw new IccFileTypeMismatch();
+        }
+    }
+
     //***** Overridden from Handler
 
     public void handleMessage(Message msg) {
@@ -297,7 +417,7 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
         int size;
         int fileid;
         int recordNum;
-        int recordSize[];
+        int recordSize[] = new int[3];
 
         try {
             switch (msg.what) {
@@ -341,16 +461,21 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
 
                 data = result.payload;
 
-                if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE] ||
-                    EF_TYPE_LINEAR_FIXED != data[RESPONSE_DATA_STRUCTURE]) {
-                    throw new IccFileTypeMismatch();
+                if (data[0] == 0x62) {
+                    ParseUICCTLVData(data, recordSize);
                 }
+                else {
+                    if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE] ||
+                        EF_TYPE_LINEAR_FIXED != data[RESPONSE_DATA_STRUCTURE]) {
+                        logd("Exception in EVENT_GET_EF_LINEAR_RECORD_SIZE_DONE");
+                        throw new IccFileTypeMismatch();
+                    }
 
-                recordSize = new int[3];
-                recordSize[0] = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
-                recordSize[1] = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8)
-                       + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
-                recordSize[2] = recordSize[1] / recordSize[0];
+                    recordSize[0] = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
+                    recordSize[1] = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8)
+                                    + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
+                    recordSize[2] = recordSize[1] / recordSize[0];
+                }
 
                 sendResult(response, recordSize, null);
                 break;
@@ -376,31 +501,41 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
                 fileid = lc.efid;
                 recordNum = lc.recordNum;
 
-                if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE]) {
-                    throw new IccFileTypeMismatch();
+                if (data[0] == 0x62) {
+                    ParseUICCTLVData(data, recordSize);
+                    lc.recordSize = recordSize[0];
+                    size = recordSize[1];
+                    lc.countRecords = recordSize[2];
                 }
+                else {
+                    if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE]) {
+                        logd("Exception in EVENT_GET_RECORD_SIZE_DONE");
+                        throw new IccFileTypeMismatch();
+                    }
 
-                if (EF_TYPE_LINEAR_FIXED != data[RESPONSE_DATA_STRUCTURE]) {
-                    throw new IccFileTypeMismatch();
-                }
+                    if (EF_TYPE_LINEAR_FIXED != data[RESPONSE_DATA_STRUCTURE]) {
+                        logd("Exception in EVENT_GET_RECORD_SIZE_DONE");
+                        throw new IccFileTypeMismatch();
+                    }
 
-                lc.recordSize = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
+                    lc.recordSize = data[RESPONSE_DATA_RECORD_LENGTH] & 0xFF;
 
-                size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8)
-                       + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
+                    size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8)
+                           + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
+                    lc.countRecords = size / lc.recordSize;
+                }
 
-                lc.countRecords = size / lc.recordSize;
 
-                 if (lc.loadAll) {
-                     lc.results = new ArrayList<byte[]>(lc.countRecords);
-                 }
+                if (lc.loadAll) {
+                    lc.results = new ArrayList<byte[]>(lc.countRecords);
+                }
 
-                 phone.mCM.iccIO(COMMAND_READ_RECORD, lc.efid, getEFPath(lc.efid),
-                         lc.recordNum,
-                         READ_RECORD_MODE_ABSOLUTE,
-                         lc.recordSize, null, null,
-                         obtainMessage(EVENT_READ_RECORD_DONE, lc));
-                 break;
+                phone.mCM.iccIO(COMMAND_READ_RECORD, lc.efid, getEFPath(lc.efid),
+                                lc.recordNum,
+                                READ_RECORD_MODE_ABSOLUTE,
+                                lc.recordSize, null, null,
+                                obtainMessage(EVENT_READ_RECORD_DONE, lc));
+                break;
             case EVENT_GET_BINARY_SIZE_DONE:
                 ar = (AsyncResult)msg.obj;
                 response = (Message) ar.userObj;
@@ -422,16 +557,24 @@ public abstract class IccFileHandler extends Handler implements IccConstants {
 
                 fileid = msg.arg1;
 
-                if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE]) {
-                    throw new IccFileTypeMismatch();
+                if (data[0] == 0x62) {
+                    ParseUICCTLVData(data, recordSize);
+                    size = recordSize[1];
                 }
+                else {
+                    if (TYPE_EF != data[RESPONSE_DATA_FILE_TYPE]) {
+                        logd("Exception in EVENT_GET_BINARY_SIZE_DONE");
+                        throw new IccFileTypeMismatch();
+                    }
 
-                if (EF_TYPE_TRANSPARENT != data[RESPONSE_DATA_STRUCTURE]) {
-                    throw new IccFileTypeMismatch();
-                }
+                    if (EF_TYPE_TRANSPARENT != data[RESPONSE_DATA_STRUCTURE]) {
+                        logd("Exception in EVENT_GET_BINARY_SIZE_DONE");
+                        throw new IccFileTypeMismatch();
+                    }
 
-                size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8)
-                       + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
+                    size = ((data[RESPONSE_DATA_FILE_SIZE_1] & 0xff) << 8)
+                           + (data[RESPONSE_DATA_FILE_SIZE_2] & 0xff);
+                }
 
                 phone.mCM.iccIO(COMMAND_READ_BINARY, fileid, getEFPath(fileid),
                                 0, 0, size, null, null,
diff --git a/telephony/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java b/telephony/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
index 9f8e57f..45562ca 100644
--- a/telephony/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
+++ b/telephony/java/com/android/internal/telephony/IccPhoneBookInterfaceManager.java
@@ -24,6 +24,7 @@ import android.os.Message;
 import android.os.ServiceManager;
 
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * SimPhoneBookInterfaceManager to provide an inter-process communication to
@@ -62,15 +63,15 @@ public abstract class IccPhoneBookInterfaceManager extends IIccPhoneBook.Stub {
                             logd("GET_RECORD_SIZE Size " + recordSize[0] +
                                     " total " + recordSize[1] +
                                     " #record " + recordSize[2]);
-                            mLock.notifyAll();
                         }
+                        notifyPending(ar);
                     }
                     break;
                 case EVENT_UPDATE_DONE:
                     ar = (AsyncResult) msg.obj;
                     synchronized (mLock) {
                         success = (ar.exception == null);
-                        mLock.notifyAll();
+                        notifyPending(ar);
                     }
                     break;
                 case EVENT_LOAD_DONE:
@@ -84,11 +85,20 @@ public abstract class IccPhoneBookInterfaceManager extends IIccPhoneBook.Stub {
                                 records.clear();
                             }
                         }
-                        mLock.notifyAll();
+                        notifyPending(ar);
                     }
                     break;
             }
         }
+
+        private void notifyPending(AsyncResult ar) {
+            if (ar.userObj == null) {
+                return;
+            }
+            AtomicBoolean status = (AtomicBoolean) ar.userObj;
+            status.set(true);
+            mLock.notifyAll();
+        }
     };
 
     public IccPhoneBookInterfaceManager(PhoneBase phone) {
@@ -144,18 +154,18 @@ public abstract class IccPhoneBookInterfaceManager extends IIccPhoneBook.Stub {
         if (DBG) logd("updateAdnRecordsInEfBySearch: efid=" + efid +
                 " ("+ oldTag + "," + oldPhoneNumber + ")"+ "==>" +
                 " ("+ newTag + "," + newPhoneNumber + ")"+ " pin2=" + pin2);
+
+        efid = updateEfForIccType(efid);
+
         synchronized(mLock) {
             checkThread();
             success = false;
-            Message response = mBaseHandler.obtainMessage(EVENT_UPDATE_DONE);
+            AtomicBoolean status = new AtomicBoolean(false);
+            Message response = mBaseHandler.obtainMessage(EVENT_UPDATE_DONE, status);
             AdnRecord oldAdn = new AdnRecord(oldTag, oldPhoneNumber);
             AdnRecord newAdn = new AdnRecord(newTag, newPhoneNumber);
             adnCache.updateAdnBySearch(efid, oldAdn, newAdn, pin2, response);
-            try {
-                mLock.wait();
-            } catch (InterruptedException e) {
-                logd("interrupted while trying to update by search");
-            }
+            waitForResult(status);
         }
         return success;
     }
@@ -194,14 +204,11 @@ public abstract class IccPhoneBookInterfaceManager extends IIccPhoneBook.Stub {
         synchronized(mLock) {
             checkThread();
             success = false;
-            Message response = mBaseHandler.obtainMessage(EVENT_UPDATE_DONE);
+            AtomicBoolean status = new AtomicBoolean(false);
+            Message response = mBaseHandler.obtainMessage(EVENT_UPDATE_DONE, status);
             AdnRecord newAdn = new AdnRecord(newTag, newPhoneNumber);
             adnCache.updateAdnByIndex(efid, newAdn, index, pin2, response);
-            try {
-                mLock.wait();
-            } catch (InterruptedException e) {
-                logd("interrupted while trying to update by index");
-            }
+            waitForResult(status);
         }
         return success;
     }
@@ -240,15 +247,12 @@ public abstract class IccPhoneBookInterfaceManager extends IIccPhoneBook.Stub {
 
         synchronized(mLock) {
             checkThread();
-            Message response = mBaseHandler.obtainMessage(EVENT_LOAD_DONE);
+            AtomicBoolean status = new AtomicBoolean(false);
+            Message response = mBaseHandler.obtainMessage(EVENT_LOAD_DONE, status);
             adnCache.requestLoadAllAdnLike(efid, adnCache.extensionEfForEf(efid), response);
-            try {
-                mLock.wait();
-            } catch (InterruptedException e) {
-                logd("interrupted while trying to load from the SIM");
-            }
+            waitForResult(status);
         }
-            return records;
+        return records;
     }
 
     protected void checkThread() {
@@ -262,6 +266,16 @@ public abstract class IccPhoneBookInterfaceManager extends IIccPhoneBook.Stub {
         }
     }
 
+    protected void waitForResult(AtomicBoolean status) {
+        while (!status.get()) {
+            try {
+                mLock.wait();
+            } catch (InterruptedException e) {
+                logd("interrupted while trying to update by search");
+            }
+        }
+    }
+
     private int updateEfForIccType(int efid) {
         // Check if we are trying to read ADN records
         if (efid == IccConstants.EF_ADN) {
diff --git a/telephony/java/com/android/internal/telephony/IccUtils.java b/telephony/java/com/android/internal/telephony/IccUtils.java
index 71936f1..2244ac4 100644
--- a/telephony/java/com/android/internal/telephony/IccUtils.java
+++ b/telephony/java/com/android/internal/telephony/IccUtils.java
@@ -51,6 +51,8 @@ public class IccUtils {
             ret.append((char)('0' + v));
 
             v = (data[i] >> 4) & 0xf;
+            // Some PLMNs have 'f' as high nibble, ignore it
+            if (v == 0xf) continue;
             if (v > 9)  break;
             ret.append((char)('0' + v));
         }
@@ -148,6 +150,47 @@ public class IccUtils {
      */
     public static String
     adnStringFieldToString(byte[] data, int offset, int length) {
+        String s = adnStringFieldToStringUcs2Helper(data, offset, length);
+        if (s == null) {
+            s = adnStringFieldToStringGsm8BitHelper(data, offset, length);
+        }
+        return s;
+    }
+
+    /**
+     * Almost identical to the method {@link #adnStringFieldToString}.
+     *
+     * Exception:
+     * If the SIM is Korean (MCC equals "450"), KSC5601 encoding will be
+     * assumed (instead of GSM8Bit). This could lead to unintended consequences,
+     * if the ADN alphaTag was saved with GSM8Bit. This is considered an
+     * acceptable risk.
+     */
+    public static String
+    adnStringFieldToStringKsc5601Support(byte[] data, int offset, int length) {
+        String s = adnStringFieldToStringUcs2Helper(data, offset, length);
+
+        if (s == null) {
+            if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+                try {
+                    int len = offset;
+                    byte stop = (byte)0xFF;
+                    while (len < length && data[len] != stop) {
+                        len++;
+                    }
+                    return new String(data, offset, len, "KSC5601");
+                } catch (UnsupportedEncodingException e) {
+                    Log.e(LOG_TAG, "implausible UnsupportedEncodingException", e);
+                }
+            }
+
+            return adnStringFieldToStringGsm8BitHelper(data, offset, length);
+        }
+        return s;
+    }
+
+    private static String
+    adnStringFieldToStringUcs2Helper(byte[] data, int offset, int length) {
         if (length >= 1) {
             if (data[offset] == (byte) 0x80) {
                 int ucslen = (length - 1) / 2;
@@ -223,6 +266,11 @@ public class IccUtils {
             return ret.toString();
         }
 
+        return null;
+    }
+
+    private static String
+    adnStringFieldToStringGsm8BitHelper(byte[] data, int offset, int length) {
         return GsmAlphabet.gsm8BitUnpackedToString(data, offset, length);
     }
 
@@ -398,7 +446,6 @@ public class IccUtils {
         int colorNumber = data[valueIndex++] & 0xFF;
         int clutOffset = ((data[valueIndex++] & 0xFF) << 8)
                 | (data[valueIndex++] & 0xFF);
-        length = length - 6;
 
         int[] colorIndexArray = getCLUT(data, clutOffset, colorNumber);
         if (true == transparency) {
diff --git a/telephony/java/com/android/internal/telephony/LGEQualcommRIL.java b/telephony/java/com/android/internal/telephony/LGEQualcommRIL.java
new file mode 100644
index 0000000..89a276a
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/LGEQualcommRIL.java
@@ -0,0 +1,417 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.Message;
+import android.os.Parcel;
+import android.util.Log;
+
+import com.android.internal.telephony.DataCallState;
+import com.android.internal.telephony.gsm.NetworkInfo;
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+
+import java.util.ArrayList;
+
+/**
+ * Custom Qualcomm No SimReady RIL for LGE
+ *
+ * {@hide}
+ */
+public class LGEQualcommRIL extends QualcommNoSimReadyRIL implements CommandsInterface {
+    protected String mAid;
+
+    public LGEQualcommRIL(Context context) {
+        super(context);
+    }
+
+    public LGEQualcommRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    public void
+    supplyIccPin(String pin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
+
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPuk(String puk, String newPin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPin2(String pin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPuk2(String puk, String newPin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    changeIccPin(String oldPin, String newPin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(oldPin);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    changeIccPin2(String oldPin2, String newPin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(oldPin2);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyNetworkDepersonalization(String netpin, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(3);
+        rr.mp.writeString(netpin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+
+        rr.mp.writeString(mAid);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() +
+                              "> getIMSI:RIL_REQUEST_GET_IMSI " +
+                              RIL_REQUEST_GET_IMSI +
+                              " aid: " + mAid +
+                              " " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String ipVersion,
+            Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(7);
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString("0"); // ipVersion
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + ipVersion);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    iccIO (int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_IO, result);
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeInt(command);
+        rr.mp.writeInt(fileid);
+        rr.mp.writeString(path);
+        rr.mp.writeInt(p1);
+        rr.mp.writeInt(p2);
+        rr.mp.writeInt(p3);
+        rr.mp.writeString(data);
+        rr.mp.writeString(pin2);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccIO: "
+                    + " aid: " + mAid + " "
+                    + requestToString(rr.mRequest)
+                    + " 0x" + Integer.toHexString(command)
+                    + " 0x" + Integer.toHexString(fileid) + " "
+                    + " path: " + path + ","
+                    + p1 + "," + p2 + "," + p3);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeAutomatic(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric);
+
+        rr.mp.writeInt(2);
+        rr.mp.writeString(operatorNumeric);
+        rr.mp.writeString("NOCHANGE");
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    queryFacilityLock (String facility, String password, int serviceClass,
+                            Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " aid: " + mAid + " facility: " + facility);
+
+        // count strings
+        rr.mp.writeInt(4);
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(facility);
+        rr.mp.writeString(password);
+
+        rr.mp.writeString(Integer.toString(serviceClass));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setFacilityLock (String facility, boolean lockState, String password,
+                        int serviceClass, Message response) {
+        String lockString;
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " aid: " + mAid + " facility: " + facility
+                    + " lockstate: " + lockState);
+
+        // count strings
+        rr.mp.writeInt(5);
+
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(facility);
+        lockString = (lockState)?"1":"0";
+        rr.mp.writeString(lockString);
+        rr.mp.writeString(password);
+        rr.mp.writeString(Integer.toString(serviceClass));
+
+        send(rr);
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        int gsmUmtsSubscriptionAppCount = p.readInt();
+        for (int i = 0; i < gsmUmtsSubscriptionAppCount; i++) {
+            if (i == 0)
+                status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+            else
+                p.readInt();
+        }
+
+        int cdmaSubscriptionAppCount = p.readInt();
+        for (int i = 0; i < cdmaSubscriptionAppCount; i++) {
+            if (i == 0)
+                status.setCdmaSubscriptionAppIndex(p.readInt());
+            else
+                p.readInt();
+        }
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = p.readInt();
+            ca.pin2           = p.readInt();
+            status.addApplication(ca);
+            p.readInt();
+            p.readInt();
+            p.readInt();
+            p.readInt();
+        }
+
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        IccCardApplication application = status.getApplication(appIndex);
+        mAid = application.aid;
+
+        return status;
+    }
+
+    @Override
+    protected Object
+    responseDataCallList(Parcel p) {
+        int num;
+        ArrayList<DataCallState> response;
+
+        num = p.readInt();
+        response = new ArrayList<DataCallState>(num);
+
+        for (int i = 0; i < num; i++) {
+            DataCallState dataCall = new DataCallState();
+
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            dataCall.apn = p.readString();
+            dataCall.address = p.readString();
+            p.readInt(); // RadioTechnology
+            p.readInt(); // inactiveReason
+            response.add(dataCall);
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseNetworkInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<NetworkInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<NetworkInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            ret.add (
+                new NetworkInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/LGEStarRIL.java b/telephony/java/com/android/internal/telephony/LGEStarRIL.java
new file mode 100644
index 0000000..4b84f57
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/LGEStarRIL.java
@@ -0,0 +1,1170 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UNKNOWN;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_EDGE;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_GPRS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.os.PowerManager.WakeLock;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.util.Config;
+import android.util.Log;
+
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.DataCallState;
+import com.android.internal.telephony.gsm.NetworkInfo;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.SmsResponse;
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+
+import java.io.ByteArrayInputStream;
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+
+import android.os.SystemClock;
+
+/* NITZ stuffs */
+import java.util.Date;
+import java.text.SimpleDateFormat;
+
+import android.telephony.PhoneStateListener;
+import android.telephony.TelephonyManager;
+
+
+/**
+ * RIL implementation of the CommandsInterface.
+ * FIXME public only for testing
+ *
+ * {@hide}
+ */
+public class LGEStarRIL extends RIL implements CommandsInterface {
+    public LGEStarRIL(Context context) {
+        super(context);
+    }
+
+    protected int mCallState = TelephonyManager.CALL_STATE_IDLE;
+    public LGEStarRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+        /* The star needs to ignore SCREEN_X states, in order to keep the
+         * batt updates running. The others don't need this */
+        if (SystemProperties.get("ro.cm.device").indexOf("p99") == 0) {
+            context.unregisterReceiver(mIntentReceiver);
+            BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+                @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                            Log.d(LOG_TAG, "RIL received ACTION_SCREEN_ON Intent -> SKIP");
+                        } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                            Log.d(LOG_TAG, "RIL received ACTION_SCREEN_OFF Intent -> SKIP");
+                        } else {
+                            Log.w(LOG_TAG, "RIL received unexpected Intent: " + intent.getAction());
+                        }
+                    }
+            };
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_ON);
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+            context.registerReceiver(mIntentReceiver, filter);
+
+
+        } else {
+            BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+                @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                            Log.d(LOG_TAG, "Enabling FAST_DORMANCY");
+                            RILRequest rrSPR = RILRequest.obtain(
+                                    279, null);
+                            rrSPR.mp.writeInt(1);
+                            rrSPR.mp.writeInt(1);
+                            send(rrSPR);
+                        }
+                    }
+            };
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(Intent.ACTION_SCREEN_OFF);
+            context.registerReceiver(mIntentReceiver, filter);
+        }
+        PhoneStateListener mPhoneStateListener = new PhoneStateListener() {
+            @Override
+            public void onCallStateChanged(int state, String incomingNumber) {
+                /* Higher state wins, unless going back to idle */
+                if (state == TelephonyManager.CALL_STATE_IDLE || state > mCallState)
+                    mCallState = state;
+            }
+        };
+
+        // register for phone state notifications.
+        ((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE))
+            .listen(mPhoneStateListener,
+                    PhoneStateListener.LISTEN_CALL_STATE);
+    }
+
+    protected boolean mPrepSetupPending = true;
+    public void
+    setRadioPower(boolean on, Message result) {
+        if(mPrepSetupPending) {
+            if (SystemProperties.get("ro.cm.device").equals("p999")) {
+                /* Set radio access tech */
+                RILRequest rrSPR = RILRequest.obtain(
+                        296, null);
+                rrSPR.mp.writeInt(1);
+                rrSPR.mp.writeInt(1);
+                if (RILJ_LOGD) riljLog(rrSPR.serialString() + "> "
+                        + requestToString(rrSPR.mRequest));
+                send(rrSPR);
+                /* Set time zone reporting */
+                rrSPR = RILRequest.obtain(
+                        189, null);
+                rrSPR.mp.writeInt(1);
+                rrSPR.mp.writeInt(1);
+                if (RILJ_LOGD) riljLog(rrSPR.serialString() + "> "
+                        + requestToString(rrSPR.mRequest));
+                send(rrSPR);
+            } else {
+                /* Set GPRS class */
+                RILRequest rrCs = RILRequest.obtain(
+                        273, null);
+                rrCs.mp.writeInt(2);
+                rrCs.mp.writeInt(1);
+                rrCs.mp.writeInt(1);
+                if (RILJ_LOGD) riljLog(rrCs.serialString() + "> "
+                        + requestToString(rrCs.mRequest));
+                send(rrCs);
+            }
+            /* Get charset */
+            RILRequest rrGCS = RILRequest.obtain(
+                    152, null);
+            if (RILJ_LOGD) riljLog(rrGCS.serialString() + "> "
+                    + requestToString(rrGCS.mRequest));
+            send(rrGCS);
+        }
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
+
+        rr.mp.writeInt(3);
+        rr.mp.writeInt(on ? 1 : 0);
+        rr.mp.writeInt(0);
+        rr.mp.writeInt(0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+
+    }
+
+    protected void LGEswitchToRadioState(RadioState newState) {
+
+        if (!mPrepSetupPending && newState == RadioState.RADIO_UNAVAILABLE) {
+            /* We seem to have lost the radio, reset the setup flag */
+	    mPrepSetupPending = true;
+        }
+        if (newState.isOn() && mPrepSetupPending) {
+            RILRequest rrPnt = RILRequest.obtain(
+                    RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, null);
+
+            rrPnt.mp.writeInt(1);
+            rrPnt.mp.writeInt(mNetworkMode);
+            if (RILJ_LOGD) riljLog(rrPnt.serialString() + "> "
+                    + requestToString(rrPnt.mRequest) + " : " + mNetworkMode);
+
+            send(rrPnt);
+
+            /* Set "ready" */
+            RILRequest rrSc = RILRequest.obtain(
+                    (SystemProperties.get("ro.cm.device").equals("p999") ? 304 : 298), null);
+            rrSc.mp.writeInt(1);
+            rrSc.mp.writeInt(0);
+            if (RILJ_LOGD) riljLog(rrSc.serialString() + "> "
+                    + requestToString(rrSc.mRequest));
+            send(rrSc);
+
+            /* Use this to initialize network state trackers */
+            RILRequest rrSSt = RILRequest.obtain(
+                    RIL_REQUEST_SCREEN_STATE, null);
+            rrSSt.mp.writeInt(1);
+            rrSSt.mp.writeInt(1);
+            if (RILJ_LOGD) riljLog(rrSSt.serialString() + "> "
+                    + requestToString(rrSSt.mRequest));
+            send(rrSSt);
+
+            mPrepSetupPending = false;
+
+        }
+        switchToRadioState(newState);
+    }
+
+
+    /**
+     * Request ID overwrites
+     */
+
+    static final int RIL_REQUEST_HANG_UP_CALL = 204;
+
+    public void
+    hangupWaitingOrBackground (Message result) {
+        RILRequest rr = RILRequest.obtain(mCallState == TelephonyManager.CALL_STATE_OFFHOOK ?
+                                        RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND :
+                                        RIL_REQUEST_HANG_UP_CALL,
+                                        result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+     * long DTMF needs an additional int arg. -1 appears to act
+     * as a "backwards-compat" value.
+     */
+    public void
+    startDtmf(char c, Message result) {
+        RILRequest rr;
+        rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(Character.toString(c));
+        rr.mp.writeInt(-1);
+
+        send(rr);
+    }
+
+    /**
+     * Wrong parameter order for CALL_FORWARD
+     * Also, replace "all" (0) with the actual sum of all classes
+     */
+
+    public void
+    queryCallForwardStatus(int cfReason, int serviceClass,
+                String number, Message response) {
+        RILRequest rr
+            = RILRequest.obtain(RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, response);
+
+        rr.mp.writeInt(cfReason);
+        rr.mp.writeInt(2); // 2 is for query action, not in used anyway
+        if (serviceClass == 0)
+            serviceClass = 511;
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(PhoneNumberUtils.toaFromString(number));
+        rr.mp.writeString(number);
+        rr.mp.writeInt (0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + cfReason + " " + serviceClass);
+
+        send(rr);
+    }
+
+    private Message saveDataCall;
+
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+
+        saveDataCall = result;
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(1); // count becomes contextId
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString(protocol);
+        rr.mp.writeString("0");
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol);
+
+        send(rr);
+    }
+
+    public void
+    showPdpAddress(Message result) {
+        RILRequest rr
+                = RILRequest.obtain(161, result);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(1); // cid
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    deactivateDataCall(int cid, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_DEACTIVATE_DATA_CALL, result);
+
+        rr.mp.writeInt(2);
+        rr.mp.writeInt(cid); 
+        rr.mp.writeInt(1); //cid
+        rr.mp.writeString(Integer.toString(cid));
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " +
+                requestToString(rr.mRequest) + " " + cid);
+
+        send(rr);
+    }
+
+    /* This one needs an extra param... */
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric);
+
+        rr.mp.writeInt(0); // Not standard, but mandatory: radio tech
+        rr.mp.writeString(operatorNumeric);
+
+        send(rr);
+    }
+
+    public void
+    getNetworkSelectionMode(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+        /* ADAPTED_NETWORK_NAME */
+        rr
+                = RILRequest.obtain(143, null);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(6);
+
+        send(rr);
+    }
+
+    public void
+    getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() +
+                              "> getIMSI:RIL_REQUEST_GET_IMSI " +
+                              RIL_REQUEST_GET_IMSI +
+                              " " + requestToString(rr.mRequest));
+
+        send(rr);
+
+        /* Request service line */
+        RILRequest rrSL = RILRequest.obtain(
+                (SystemProperties.get("ro.cm.device").equals("p999") ? 294 : 286), null);
+        rrSL.mp.writeInt(0);
+        if (RILJ_LOGD) riljLog(rrSL.serialString() + "> "
+                + requestToString(rrSL.mRequest));
+        send(rrSL);
+    }
+
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANG_UP_CALL: ret =  responseVoid(p); break; /* LGE */
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GPRS_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseNetworkInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case 143: ret =  responseVoid(p); break; // ADAPTED_NETWORK_NAME
+            case 152: ret =  responseString(p); break; // RIL_REQUEST_GET_TE_CHARACTER_SET
+            case 161: ret =  responsePdpAddress(p); break; // SHOW_PDP_ADDRESS
+            case 189: ret =  responseVoid(p); break; // RIL_REQUEST_SET_TIME_ZONE_REPORTING
+            case 273: ret =  responseVoid(p); break; // SET_GMM_ATTACH_MODE
+            case 279: ret =  responseVoid(p); break; // FAST_DORMANCY
+            case 286: ret =  responseVoid(p); break; // GET_SERVICE_LINE
+            case 294: ret =  responseVoid(p); break; // GET_SERVICE_LINE
+            case 296: ret =  responseVoid(p); break; // RIL_REQUEST_SET_PRODUCT_RAT
+            case 298: ret =  responseVoid(p); break; // SEND_COMMAND
+            case 304: ret =  responseVoid(p); break; // SEND_COMMAND
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            rr.onError(error, ret);
+            rr.release();
+            return;
+        }
+
+        if (rr.mRequest == RIL_REQUEST_SETUP_DATA_CALL) {
+            String[] strings = (String[]) ret;
+            if (strings.length <=2 || strings[1].indexOf("gan") != 0) {
+                rr.release();
+                showPdpAddress(saveDataCall);
+                return;
+            }
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    protected Object
+    responseDataCallListChanged(Parcel p) {
+        int num;
+        ArrayList<DataCallState> response;
+
+        num = p.readInt();
+        response = new ArrayList<DataCallState>(num);
+
+        for (int i = 0; i < num; i++) {
+            DataCallState dataCall = new DataCallState();
+
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            dataCall.apn = p.readString();
+            String address = p.readString();
+            if (address != null) {
+                address = address.split(" ")[0];
+            }
+            dataCall.address = address;
+            if (dataCall.active != 0)
+                showPdpAddress(null);
+            response.add(dataCall);
+        }
+
+        return response;
+    }
+
+
+    protected void
+    processUnsolicited (Parcel p) {
+        int response;
+        Object ret;
+
+        response = p.readInt();
+
+        try {switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: ret =  responseInts(p); break;
+            case RIL_UNSOL_ON_USSD: ret =  responseStrings(p); break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseNitz(p); break;
+            case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: ret = responseDataCallListChanged(p);break;
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_STK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_STK_CALL_SETUP: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+            case RIL_UNSOL_SIM_REFRESH: ret =  responseInts(p); break;
+            case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:  ret =  responseCdmaSms(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseRaw(p); break;
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_CALL_WAITING: ret = responseCdmaCallWaiting(p); break;
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: ret = responseInts(p); break;
+            case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+            case RIL_UNSOL_OEM_HOOK_RAW: ret = responseRaw(p); break;
+            case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+            case RIL_UNSOL_RESEND_INCALL_MUTE: ret = responseVoid(p); break;
+
+            default:
+                throw new RuntimeException("Unrecognized unsol response: " + response);
+            //break; (implied)
+        }} catch (Throwable tr) {
+            Log.e(LOG_TAG, "Exception processing unsol response: " + response +
+                "Exception:" + tr.toString());
+            return;
+        }
+
+        switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                /* has bonus radio state int */
+                RadioState newState = getRadioStateFromInt(p.readInt());
+                if (RILJ_LOGD) unsljLogMore(response, newState.toString());
+
+                LGEswitchToRadioState(newState);
+            break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mCallStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: {
+                if (RILJ_LOGD) unsljLog(response);
+
+                // FIXME this should move up a layer
+                String a[] = new String[2];
+
+                a[1] = (String)ret;
+
+                SmsMessage sms;
+
+                sms = SmsMessage.newFromCMT(a);
+                if (mSMSRegistrant != null) {
+                    mSMSRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+            break;
+            }
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSmsStatusRegistrant != null) {
+                    mSmsStatusRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                int[] smsIndex = (int[])ret;
+
+                if(smsIndex.length == 1) {
+                    if (mSmsOnSimRegistrant != null) {
+                        mSmsOnSimRegistrant.
+                                notifyRegistrant(new AsyncResult(null, smsIndex, null));
+                    }
+                } else {
+                    if (RILJ_LOGD) riljLog(" NEW_SMS_ON_SIM ERROR with wrong length "
+                            + smsIndex.length);
+                }
+            break;
+            case RIL_UNSOL_ON_USSD:
+                String[] resp = (String[])ret;
+
+                if (resp.length < 2) {
+                    resp = new String[2];
+                    resp[0] = ((String[])ret)[0];
+                    resp[1] = null;
+                }
+                if (RILJ_LOGD) unsljLogMore(response, resp[0]);
+                if (mUSSDRegistrant != null) {
+                    mUSSDRegistrant.notifyRegistrant(
+                        new AsyncResult (null, resp, null));
+                }
+            break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // should have bonus long containing milliseconds since boot that the NITZ
+                // time was received. It doesn't, use "now"
+                long nitzReceiveTime = SystemClock.elapsedRealtime();//p.readLong();
+                //long nitzReceiveTime = p.readLong();
+
+                Object[] result = new Object[2];
+
+                result[0] = ret;
+                result[1] = Long.valueOf(nitzReceiveTime);
+
+                if (mNITZTimeRegistrant != null) {
+
+                    mNITZTimeRegistrant
+                        .notifyRegistrant(new AsyncResult (null, result, null));
+                } else {
+                    // in case NITZ time registrant isnt registered yet
+                    mLastNITZTimeInfo = result;
+                }
+            break;
+
+            case RIL_UNSOL_SIGNAL_STRENGTH:
+                // Note this is set to "verbose" because it happens
+                // frequently
+                if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+                if (mSignalStrengthRegistrant != null) {
+                    mSignalStrengthRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+            break;
+
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSsnRegistrant != null) {
+                    mSsnRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_SESSION_END:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mStkSessionEndRegistrant != null) {
+                    mStkSessionEndRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkProCmdRegistrant != null) {
+                    mStkProCmdRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_EVENT_NOTIFY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkEventRegistrant != null) {
+                    mStkEventRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_CALL_SETUP:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkCallSetUpRegistrant != null) {
+                    mStkCallSetUpRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_SIM_REFRESH:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mIccRefreshRegistrant != null) {
+                    mIccRefreshRegistrant.notifyRegistrant(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CALL_RING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mRingRegistrant != null) {
+                    mRingRegistrant.notifyRegistrant(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRestrictedStateRegistrant != null) {
+                    mRestrictedStateRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccStatusChangedRegistrants != null) {
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                SmsMessage sms = (SmsMessage) ret;
+
+                if (mSMSRegistrant != null) {
+                    mSMSRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mGsmBroadcastSmsRegistrant != null) {
+                    mGsmBroadcastSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mEmergencyCallbackModeRegistrant != null) {
+                    mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_CALL_WAITING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCallWaitingInfoRegistrants != null) {
+                    mCallWaitingInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mOtaProvisionRegistrants != null) {
+                    mOtaProvisionRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_INFO_REC:
+                ArrayList<CdmaInformationRecords> listInfoRecs;
+
+                try {
+                    listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+                } catch (ClassCastException e) {
+                    Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+                    break;
+                }
+
+                for (CdmaInformationRecords rec : listInfoRecs) {
+                    if (RILJ_LOGD) unsljLogRet(response, rec);
+                    notifyRegistrantsCdmaInfoRec(rec);
+                }
+                break;
+
+            case RIL_UNSOL_OEM_HOOK_RAW:
+                if (RILJ_LOGD) unsljLogvRet(response, IccUtils.bytesToHexString((byte[])ret));
+                if (mUnsolOemHookRawRegistrant != null) {
+                    mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RINGBACK_TONE:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                /* Sink these to get rid of phantom ringtone */
+                break;
+
+            case RIL_UNSOL_RESEND_INCALL_MUTE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mResendIncallMuteRegistrants != null) {
+                    mResendIncallMuteRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+        }
+    }
+
+    protected Object
+    responsePdpAddress(Parcel p) {
+        int num;
+        String response[];
+        String ifname;
+
+        num = p.readInt();
+
+        response = new String[3];
+
+        response[0] = p.readString();
+        response[2] = p.readString();
+        ifname = p.readString();
+        response[1] = ifname;
+
+        SystemProperties.set("net."+ifname+".ip",response[2]);
+        SystemProperties.set("net."+ifname+".dns1",p.readString());
+        SystemProperties.set("net."+ifname+".dns2",p.readString());
+        SystemProperties.set("net."+ifname+".gw",p.readString());
+        return response;
+    }
+
+    protected Object
+    responseNitz(Parcel p) {
+        int num, dst=0;
+        String parceldata, parcelextra;
+        String response;
+        SimpleDateFormat dateFormatter;
+        SimpleDateFormat dateParser;
+        boolean isIfx = !SystemProperties.get("ro.cm.device").equals("p999");
+        boolean usesLocalTime = isIfx && !SystemProperties.get("ro.cm.device").equals("p920");
+
+        num = p.readInt(); // TZ diff in quarter-hours
+
+        /* Get the actual date string */
+        parceldata = p.readString();
+
+        /* Infineon modems need some additional hax... */
+        if (isIfx) {
+            String [] parcelitem = parceldata.split(",");
+            parceldata = parcelitem[0] + "," + parcelitem[1]; // assuming there is always one comma at least
+            parcelextra = (parcelitem.length > 2 ? parcelitem[2] : "0");
+            dst = Integer.parseInt(parcelextra);
+        }
+
+        /* WTH... Date may come with 4 digits in the year, reduce to 2 */
+        try {
+            dateFormatter = new SimpleDateFormat("yy/MM/dd,HH:mm:ss");
+            dateParser = new SimpleDateFormat("yy/MM/dd,HH:mm:ss");
+
+            /* Ifx delivers localtime, convert to UTC */
+            if (usesLocalTime) {
+                /* Directly calculate UTC time using DST Offset */
+                int offset = num*15*60*1000;	// DST corrected
+                long when = dateParser.parse(parceldata).getTime() - offset;
+                Date d = new Date(when);
+                response = dateFormatter.format(d);
+            } else {
+                response = dateFormatter.format(dateParser.parse(parceldata));
+            }
+
+        } catch (java.text.ParseException tpe) {
+            Log.d(LOG_TAG, "NITZ TZ conversion failed: " + tpe);
+            response = parceldata;
+        }
+
+        /* Append the timezone */
+        response = response + ((num < 0) ? "" : "+") + num;
+        if (isIfx) {
+            /* Add DST */
+            response = response + "," + dst;
+        }
+
+        return response;
+    }
+
+    static String
+    requestToString(int request) {
+        switch(request) {
+            case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
+            case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
+            case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
+            case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
+            case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
+            case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
+            case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: return "ENTER_NETWORK_DEPERSONALIZATION";
+            case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
+            case RIL_REQUEST_DIAL: return "DIAL";
+            case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
+            case RIL_REQUEST_HANGUP: return "HANGUP";
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
+            case RIL_REQUEST_HANG_UP_CALL: return "HANG_UP_CALL"; /* LGE */
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
+            case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
+            case RIL_REQUEST_UDUB: return "UDUB";
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
+            case RIL_REQUEST_REGISTRATION_STATE: return "REGISTRATION_STATE";
+            case RIL_REQUEST_GPRS_REGISTRATION_STATE: return "GPRS_REGISTRATION_STATE";
+            case RIL_REQUEST_OPERATOR: return "OPERATOR";
+            case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
+            case RIL_REQUEST_DTMF: return "DTMF";
+            case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
+            case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
+            case RIL_REQUEST_SIM_IO: return "SIM_IO";
+            case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
+            case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
+            case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
+            case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
+            case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
+            case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
+            case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
+            case RIL_REQUEST_ANSWER: return "ANSWER";
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
+            case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_DTMF_START: return "DTMF_START";
+            case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
+            case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
+            case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
+            case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
+            case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
+            case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
+            case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
+            case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
+            case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
+            case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: return "SET_SUPP_SVC_NOTIFICATION";
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: return "DELETE_SMS_ON_SIM";
+            case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
+            case RIL_REQUEST_STK_GET_PROFILE: return "REQUEST_STK_GET_PROFILE";
+            case RIL_REQUEST_STK_SET_PROFILE: return "REQUEST_STK_SET_PROFILE";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "REQUEST_EXPLICIT_CALL_TRANSFER";
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "REQUEST_GET_NEIGHBORING_CELL_IDS";
+            case RIL_REQUEST_SET_LOCATION_UPDATES: return "REQUEST_SET_LOCATION_UPDATES";
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION: return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION";
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
+            case RIL_REQUEST_SET_TTY_MODE: return "RIL_REQUEST_SET_TTY_MODE";
+            case RIL_REQUEST_QUERY_TTY_MODE: return "RIL_REQUEST_QUERY_TTY_MODE";
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_FLASH: return "RIL_REQUEST_CDMA_FLASH";
+            case RIL_REQUEST_CDMA_BURST_DTMF: return "RIL_REQUEST_CDMA_BURST_DTMF";
+            case RIL_REQUEST_CDMA_SEND_SMS: return "RIL_REQUEST_CDMA_SEND_SMS";
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: return "RIL_REQUEST_CDMA_SUBSCRIPTION";
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
+            case RIL_REQUEST_DEVICE_IDENTITY: return "RIL_REQUEST_DEVICE_IDENTITY";
+            case RIL_REQUEST_GET_SMSC_ADDRESS: return "RIL_REQUEST_GET_SMSC_ADDRESS";
+            case RIL_REQUEST_SET_SMSC_ADDRESS: return "RIL_REQUEST_SET_SMSC_ADDRESS";
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
+            case 152: return "RIL_REQUEST_GET_TE_CHARACTER_SET";
+            case 143: return "ADAPTED_NETWORK_NAME";
+            case 161: return "SHOW_PDP_ADDRESS";
+            case 189: return "RIL_REQUEST_SET_TIME_ZONE_REPORTING";
+            case 273: return "SET_GMM_ATTACH_MODE";
+            case 286: return "GET_SERVICE_LINE"; // p990
+            case 294: return "GET_SERVICE_LINE"; // p999
+            case 296: return "RIL_REQUEST_SET_PRODUCT_RAT";
+            case 298: return "SEND_COMMAND"; // p990
+            case 304: return "SEND_COMMAND"; // p999
+            default: return "<unknown request>";
+        }
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/MccTable.java b/telephony/java/com/android/internal/telephony/MccTable.java
index 5539057..dc7e492 100644
--- a/telephony/java/com/android/internal/telephony/MccTable.java
+++ b/telephony/java/com/android/internal/telephony/MccTable.java
@@ -26,6 +26,7 @@ import android.os.SystemProperties;
 import android.provider.Settings;
 import android.text.TextUtils;
 import android.util.Log;
+import android.util.TimeUtils;
 
 import java.util.Arrays;
 
@@ -45,7 +46,8 @@ import java.util.Arrays;
  * only unresolved discrepancy being that this list has an extra entry
  * (461) for China.
  *
- * TODO: Complete the mappings for timezones and language/locale codes.
+ * TODO: Complete the mappings for language/locale codes, and
+ *       timezones which are not the countries' primary ones.
  *
  * The actual table data used in the Java code is generated from the
  * below Python code for efficiency.  The information is expected to
@@ -55,25 +57,25 @@ import java.util.Arrays;
 
 mcc_table = [
   (202, 'gr', 2, 'Greece'),
-  (204, 'nl', 2, 'Europe/Amsterdam', 'nl', 13, 'Netherlands (Kingdom of the)'),
+  (204, 'nl', 2, '', 'nl', 13, 'Netherlands (Kingdom of the)'),
   (206, 'be', 2, 'Belgium'),
-  (208, 'fr', 2, 'Europe/Paris', 'fr', 'France'),
+  (208, 'fr', 2, '', 'fr', 'France'),
   (212, 'mc', 2, 'Monaco (Principality of)'),
   (213, 'ad', 2, 'Andorra (Principality of)'),
-  (214, 'es', 2, 'Europe/Madrid', 'es', 'Spain'),
+  (214, 'es', 2, '', 'es', 'Spain'),
   (216, 'hu', 2, 'Hungary (Republic of)'),
   (218, 'ba', 2, 'Bosnia and Herzegovina'),
   (219, 'hr', 2, 'Croatia (Republic of)'),
   (220, 'rs', 2, 'Serbia and Montenegro'),
-  (222, 'it', 2, 'Europe/Rome', 'it', 'Italy'),
-  (225, 'va', 2, 'Europe/Rome', 'it', 'Vatican City State'),
+  (222, 'it', 2, '', 'it', 'Italy'),
+  (225, 'va', 2, '', 'it', 'Vatican City State'),
   (226, 'ro', 2, 'Romania'),
-  (228, 'ch', 2, 'Europe/Zurich', 'de', 'Switzerland (Confederation of)'),
-  (230, 'cz', 2, 'Europe/Prague', 'cs', 13, 'Czech Republic'),
+  (228, 'ch', 2, '', 'de', 'Switzerland (Confederation of)'),
+  (230, 'cz', 2, '', 'cs', 13, 'Czech Republic'),
   (231, 'sk', 2, 'Slovak Republic'),
-  (232, 'at', 2, 'Europe/Vienna', 'de', 13, 'Austria'),
-  (234, 'gb', 2, 'Europe/London', 'en', 13, 'United Kingdom of Great Britain and Northern Ireland'),
-  (235, 'gb', 2, 'Europe/London', 'en', 13, 'United Kingdom of Great Britain and Northern Ireland'),
+  (232, 'at', 2, '', 'de', 13, 'Austria'),
+  (234, 'gb', 2, '', 'en', 13, 'United Kingdom of Great Britain and Northern Ireland'),
+  (235, 'gb', 2, '', 'en', 13, 'United Kingdom of Great Britain and Northern Ireland'),
   (238, 'dk', 2, 'Denmark'),
   (240, 'se', 2, 'Sweden'),
   (242, 'no', 2, 'Norway'),
@@ -85,12 +87,12 @@ mcc_table = [
   (255, 'ua', 2, 'Ukraine'),
   (257, 'by', 2, 'Belarus (Republic of)'),
   (259, 'md', 2, 'Moldova (Republic of)'),
-  (260, 'pl', 2, 'Europe/Warsaw', 'Poland (Republic of)'),
-  (262, 'de', 2, 'Europe/Berlin', 'de', 13, 'Germany (Federal Republic of)'),
+  (260, 'pl', 2, 'Poland (Republic of)'),
+  (262, 'de', 2, '', 'de', 13, 'Germany (Federal Republic of)'),
   (266, 'gi', 2, 'Gibraltar'),
   (268, 'pt', 2, 'Portugal'),
   (270, 'lu', 2, 'Luxembourg'),
-  (272, 'ie', 2, 'Europe/Dublin', 'en', 'Ireland'),
+  (272, 'ie', 2, '', 'en', 'Ireland'),
   (274, 'is', 2, 'Iceland'),
   (276, 'al', 2, 'Albania (Republic of)'),
   (278, 'mt', 2, 'Malta'),
@@ -172,29 +174,29 @@ mcc_table = [
   (436, 'tj', 2, 'Tajikistan (Republic of)'),
   (437, 'kg', 2, 'Kyrgyz Republic'),
   (438, 'tm', 2, 'Turkmenistan'),
-  (440, 'jp', 2, 'Asia/Tokyo', 'ja', 14, 'Japan'),
-  (441, 'jp', 2, 'Asia/Tokyo', 'ja', 14, 'Japan'),
-  (450, 'kr', 2, 'Asia/Seoul', 'ko', 13, 'Korea (Republic of)'),
+  (440, 'jp', 2, '', 'ja', 14, 'Japan'),
+  (441, 'jp', 2, '', 'ja', 14, 'Japan'),
+  (450, 'kr', 2, '', 'ko', 13, 'Korea (Republic of)'),
   (452, 'vn', 2, 'Viet Nam (Socialist Republic of)'),
   (454, 'hk', 2, '"Hong Kong, China"'),
   (455, 'mo', 2, '"Macao, China"'),
   (456, 'kh', 2, 'Cambodia (Kingdom of)'),
   (457, 'la', 2, "Lao People's Democratic Republic"),
-  (460, 'cn', 2, "Asia/Beijing", 'zh', 13, "China (People's Republic of)"),
-  (461, 'cn', 2, "Asia/Beijing", 'zh', 13, "China (People's Republic of)"),
-  (466, 'tw', 2, "Taiwan (Republic of China)"),
+  (460, 'cn', 2, '', 'zh', 13, "China (People's Republic of)"),
+  (461, 'cn', 2, '', 'zh', 13, "China (People's Republic of)"),
+  (466, 'tw', 2, '', 'zh', "Taiwan (Republic of China)"),
   (467, 'kp', 2, "Democratic People's Republic of Korea"),
   (470, 'bd', 2, "Bangladesh (People's Republic of)"),
   (472, 'mv', 2, 'Maldives (Republic of)'),
   (502, 'my', 2, 'Malaysia'),
-  (505, 'au', 2, 'Australia/Sydney', 'en', 11, 'Australia'),
+  (505, 'au', 2, '', 'en', 11, 'Australia'),
   (510, 'id', 2, 'Indonesia (Republic of)'),
   (514, 'tl', 2, 'Democratic Republic of Timor-Leste'),
   (515, 'ph', 2, 'Philippines (Republic of the)'),
   (520, 'th', 2, 'Thailand'),
-  (525, 'sg', 2, 'Asia/Singapore', 'en', 11, 'Singapore (Republic of)'),
+  (525, 'sg', 2, '', 'en', 11, 'Singapore (Republic of)'),
   (528, 'bn', 2, 'Brunei Darussalam'),
-  (530, 'nz', 2, 'Pacific/Auckland', 'en', 'New Zealand'),
+  (530, 'nz', 2, '', 'en', 'New Zealand'),
   (534, 'mp', 2, 'Northern Mariana Islands (Commonwealth of the)'),
   (535, 'gu', 2, 'Guam'),
   (536, 'nr', 2, 'Nauru (Republic of)'),
@@ -265,7 +267,7 @@ mcc_table = [
   (652, 'bw', 2, 'Botswana (Republic of)'),
   (653, 'sz', 2, 'Swaziland (Kingdom of)'),
   (654, 'km', 2, 'Comoros (Union of the)'),
-  (655, 'za', 2, 'Africa/Johannesburg', 'en', 'South Africa (Republic of)'),
+  (655, 'za', 2, '', 'en', 'South Africa (Republic of)'),
   (657, 'er', 2, 'Eritrea'),
   (702, 'bz', 2, 'Belize'),
   (704, 'gt', 2, 'Guatemala (Republic of)'),
@@ -302,12 +304,12 @@ lang_set = sorted(x for x in set(get_lang(elt) for elt in mcc_table))
 
 def mk_ind_code(elt):
   iso = get_iso(elt)
-  iso_code = ((ord(iso[0]) << 8) | ord(iso[1])) & 0xFFFF # 16 bits
+  iso_code = ((ord(iso[0]) << 7) | ord(iso[1])) & 0x3FFF # 14 bits
   wifi = get_wifi(elt) & 0x000F                          #  4 bits
   sd = get_sd(elt) & 0x0003                              #  2 bits
   tz_ind = tz_set.index(get_tz(elt)) & 0x001F            #  5 bits
-  lang_ind = lang_set.index(get_lang(elt)) & 0x000F      #  4 bits
-  return (iso_code << 16) | (wifi << 11) | (sd << 9) | (tz_ind << 4) | lang_ind
+  lang_ind = lang_set.index(get_lang(elt)) & 0x003F      #  6 bits
+  return (iso_code << 18) | (wifi << 13) | (sd << 11) | (tz_ind << 6) | lang_ind
 
 ind_codes = ['0x%08x' % mk_ind_code(elt) for elt in mcc_table]
 
@@ -319,10 +321,10 @@ def fmt_list(title, l, batch_sz):
   return '    private static final %s = {\n' % title + ',\n'.join(sl) + '\n    };\n'
 
 def do_autogen_comment(extra_desc=[]):
-  print '    /' + '**\n    * AUTO GENERATED (by the Python code above)'
+  print '    /' + '**\n     * AUTO GENERATED (by the Python code above)'
   for line in extra_desc:
-    print '    * %s' % line
-  print '    *' + '/'
+    print '     * %s' % line
+  print '     *' + '/'
 
 do_autogen_comment()
 print fmt_list('String[] TZ_STRINGS', ['"%s"' % x for x in tz_set], 1)
@@ -333,24 +335,24 @@ do_autogen_comment(['This table is a list of MCC codes.  The index in this table
                     'that MCC in the IND_CODES table.'])
 print fmt_list('short[] MCC_CODES', mcc_codes, 10)
 do_autogen_comment(['The values in this table are broken down as follows (msb to lsb):',
-                    '    iso country code 16 bits',
+                    '    iso country code 14 bits',
                     '    (unused)          1 bit',
                     '    wifi channel      4 bits',
                     '    smalled digit     2 bits',
                     '    default timezone  5 bits',
-                    '    default language  4 bits'])
+                    '    default language  6 bits'])
 print fmt_list('int[] IND_CODES', ind_codes, 6)
 
 def parse_ind_code(ind):
   mcc = eval(mcc_codes[ind])
   code = eval(ind_codes[ind])
-  iso_lsb = int((code >> 16) & 0x00FF)
-  iso_msb = int((code >> 24) & 0x00FF)
+  iso_lsb = int((code >> 18) & 0x007F)
+  iso_msb = int((code >> 25) & 0x007F)
   iso = '%s%s' % (chr(iso_msb), chr(iso_lsb))
-  wifi = int((code >> 11) & 0x000F)
-  sd = int((code >> 9) & 0x0003)
-  tz_ind = (code >> 4) & 0x001F
-  lang_ind = (code >> 0) & 0x000F
+  wifi = int((code >> 13) & 0x000F)
+  sd = int((code >> 11) & 0x0003)
+  tz_ind = (code >> 6) & 0x001F
+  lang_ind = (code >> 0) & 0x003F
   return (mcc, iso, sd, tz_set[tz_ind], lang_set[lang_ind], wifi)
 
 fmt_str = 'mcc = %s, iso = %s, sd = %s, tz = %s, lang = %s, wifi = %s'
@@ -375,25 +377,7 @@ public final class MccTable
      * AUTO GENERATED (by the Python code above)
      */
     private static final String[] TZ_STRINGS = {
-        "",
-        "Africa/Johannesburg",
-        "Asia/Beijing",
-        "Asia/Seoul",
-        "Asia/Singapore",
-        "Asia/Tokyo",
-        "Australia/Sydney",
-        "Europe/Amsterdam",
-        "Europe/Berlin",
-        "Europe/Dublin",
-        "Europe/London",
-        "Europe/Madrid",
-        "Europe/Paris",
-        "Europe/Prague",
-        "Europe/Rome",
-        "Europe/Vienna",
-        "Europe/Warsaw",
-        "Europe/Zurich",
-        "Pacific/Auckland"
+        ""
     };
 
     /**
@@ -440,53 +424,53 @@ public final class MccTable
     /**
      * AUTO GENERATED (by the Python code above)
      * The values in this table are broken down as follows (msb to lsb):
-     *     iso country code 16 bits
+     *     iso country code 14 bits
      *     (unused)          1 bit
      *     wifi channel      4 bits
      *     smalled digit     2 bits
      *     default timezone  5 bits
-     *     default language  4 bits
+     *     default language  6 bits
      */
     private static final int[] IND_CODES = {
-        0x67720400, 0x6e6c6c79, 0x62650400, 0x667204c5, 0x6d630400, 0x61640400,
-        0x657304b4, 0x68750400, 0x62610400, 0x68720400, 0x72730400, 0x697404e6,
-        0x766104e6, 0x726f0400, 0x63680512, 0x637a6cd1, 0x736b0400, 0x61746cf2,
-        0x67626ca3, 0x67626ca3, 0x646b0400, 0x73650400, 0x6e6f0400, 0x66690400,
-        0x6c740400, 0x6c760400, 0x65650400, 0x72750400, 0x75610400, 0x62790400,
-        0x6d640400, 0x706c0500, 0x64656c82, 0x67690400, 0x70740400, 0x6c750400,
-        0x69650493, 0x69730400, 0x616c0400, 0x6d740400, 0x63790400, 0x67650400,
-        0x616d0400, 0x62670400, 0x74720400, 0x666f0400, 0x67650400, 0x676c0400,
-        0x736d0400, 0x736c0400, 0x6d6b0400, 0x6c690400, 0x6d650400, 0x63615e00,
-        0x706d0400, 0x75735e03, 0x75735e03, 0x75735e03, 0x75735e03, 0x75735e03,
-        0x75735e03, 0x75735e03, 0x70720400, 0x76690400, 0x6d780600, 0x6a6d0600,
-        0x67700400, 0x62620600, 0x61670600, 0x6b790600, 0x76670600, 0x626d0400,
-        0x67640400, 0x6d730400, 0x6b6e0400, 0x6c630400, 0x76630400, 0x6e6c0400,
-        0x61770400, 0x62730400, 0x61690600, 0x646d0400, 0x63750400, 0x646f0400,
-        0x68740400, 0x74740400, 0x74630400, 0x617a0400, 0x6b7a0400, 0x62740400,
-        0x696e0400, 0x696e0400, 0x706b0400, 0x61660400, 0x6c6b0400, 0x6d6d0400,
-        0x6c620400, 0x6a6f0400, 0x73790400, 0x69710400, 0x6b770400, 0x73610400,
-        0x79650400, 0x6f6d0400, 0x70730400, 0x61650400, 0x696c0400, 0x62680400,
-        0x71610400, 0x6d6e0400, 0x6e700400, 0x61650400, 0x61650400, 0x69720400,
-        0x757a0400, 0x746a0400, 0x6b670400, 0x746d0400, 0x6a707457, 0x6a707457,
-        0x6b726c38, 0x766e0400, 0x686b0400, 0x6d6f0400, 0x6b680400, 0x6c610400,
-        0x636e6c2a, 0x636e6c2a, 0x74770400, 0x6b700400, 0x62640400, 0x6d760400,
-        0x6d790400, 0x61755c63, 0x69640400, 0x746c0400, 0x70680400, 0x74680400,
-        0x73675c43, 0x626e0400, 0x6e7a0523, 0x6d700400, 0x67750400, 0x6e720400,
-        0x70670400, 0x746f0400, 0x73620400, 0x76750400, 0x666a0400, 0x77660400,
-        0x61730400, 0x6b690400, 0x6e630400, 0x70660400, 0x636b0400, 0x77730400,
-        0x666d0400, 0x6d680400, 0x70770400, 0x65670400, 0x647a0400, 0x6d610400,
-        0x746e0400, 0x6c790400, 0x676d0400, 0x736e0400, 0x6d720400, 0x6d6c0400,
-        0x676e0400, 0x63690400, 0x62660400, 0x6e650400, 0x74670400, 0x626a0400,
-        0x6d750400, 0x6c720400, 0x736c0400, 0x67680400, 0x6e670400, 0x74640400,
-        0x63660400, 0x636d0400, 0x63760400, 0x73740400, 0x67710400, 0x67610400,
-        0x63670400, 0x63670400, 0x616f0400, 0x67770400, 0x73630400, 0x73640400,
-        0x72770400, 0x65740400, 0x736f0400, 0x646a0400, 0x6b650400, 0x747a0400,
-        0x75670400, 0x62690400, 0x6d7a0400, 0x7a6d0400, 0x6d670400, 0x72650400,
-        0x7a770400, 0x6e610400, 0x6d770400, 0x6c730400, 0x62770400, 0x737a0400,
-        0x6b6d0400, 0x7a610413, 0x65720400, 0x627a0400, 0x67740400, 0x73760400,
-        0x686e0600, 0x6e690400, 0x63720400, 0x70610400, 0x70650400, 0x61720600,
-        0x62720400, 0x636c0400, 0x636f0600, 0x76650400, 0x626f0400, 0x67790400,
-        0x65630400, 0x67660400, 0x70790400, 0x73720400, 0x75790400, 0x666b0400
+        0xcfc81000, 0xddb1b009, 0xc5941000, 0xcdc81005, 0xdb8c1000, 0xc3901000,
+        0xcbcc1004, 0xd1d41000, 0xc5841000, 0xd1c81000, 0xe5cc1000, 0xd3d01006,
+        0xed841006, 0xe5bc1000, 0xc7a01002, 0xc7e9b001, 0xe7ac1000, 0xc3d1b002,
+        0xcf89b003, 0xcf89b003, 0xc9ac1000, 0xe7941000, 0xddbc1000, 0xcda41000,
+        0xd9d01000, 0xd9d81000, 0xcb941000, 0xe5d41000, 0xeb841000, 0xc5e41000,
+        0xdb901000, 0xe1b01000, 0xc995b002, 0xcfa41000, 0xe1d01000, 0xd9d41000,
+        0xd3941003, 0xd3cc1000, 0xc3b01000, 0xdbd01000, 0xc7e41000, 0xcf941000,
+        0xc3b41000, 0xc59c1000, 0xe9c81000, 0xcdbc1000, 0xcf941000, 0xcfb01000,
+        0xe7b41000, 0xe7b01000, 0xdbac1000, 0xd9a41000, 0xdb941000, 0xc7857800,
+        0xe1b41000, 0xebcd7803, 0xebcd7803, 0xebcd7803, 0xebcd7803, 0xebcd7803,
+        0xebcd7803, 0xebcd7803, 0xe1c81000, 0xeda41000, 0xdbe01800, 0xd5b41800,
+        0xcfc01000, 0xc5881800, 0xc39c1800, 0xd7e41800, 0xed9c1800, 0xc5b41000,
+        0xcf901000, 0xdbcc1000, 0xd7b81000, 0xd98c1000, 0xed8c1000, 0xddb01000,
+        0xc3dc1000, 0xc5cc1000, 0xc3a41800, 0xc9b41000, 0xc7d41000, 0xc9bc1000,
+        0xd1d01000, 0xe9d01000, 0xe98c1000, 0xc3e81000, 0xd7e81000, 0xc5d01000,
+        0xd3b81000, 0xd3b81000, 0xe1ac1000, 0xc3981000, 0xd9ac1000, 0xdbb41000,
+        0xd9881000, 0xd5bc1000, 0xe7e41000, 0xd3c41000, 0xd7dc1000, 0xe7841000,
+        0xf3941000, 0xdfb41000, 0xe1cc1000, 0xc3941000, 0xd3b01000, 0xc5a01000,
+        0xe3841000, 0xdbb81000, 0xddc01000, 0xc3941000, 0xc3941000, 0xd3c81000,
+        0xebe81000, 0xe9a81000, 0xd79c1000, 0xe9b41000, 0xd5c1d007, 0xd5c1d007,
+        0xd7c9b008, 0xedb81000, 0xd1ac1000, 0xdbbc1000, 0xd7a01000, 0xd9841000,
+        0xc7b9b00a, 0xc7b9b00a, 0xe9dc100a, 0xd7c01000, 0xc5901000, 0xdbd81000,
+        0xdbe41000, 0xc3d57003, 0xd3901000, 0xe9b01000, 0xe1a01000, 0xe9a01000,
+        0xe79d7003, 0xc5b81000, 0xdde81003, 0xdbc01000, 0xcfd41000, 0xddc81000,
+        0xe19c1000, 0xe9bc1000, 0xe7881000, 0xedd41000, 0xcda81000, 0xef981000,
+        0xc3cc1000, 0xd7a41000, 0xdd8c1000, 0xe1981000, 0xc7ac1000, 0xefcc1000,
+        0xcdb41000, 0xdba01000, 0xe1dc1000, 0xcb9c1000, 0xc9e81000, 0xdb841000,
+        0xe9b81000, 0xd9e41000, 0xcfb41000, 0xe7b81000, 0xdbc81000, 0xdbb01000,
+        0xcfb81000, 0xc7a41000, 0xc5981000, 0xdd941000, 0xe99c1000, 0xc5a81000,
+        0xdbd41000, 0xd9c81000, 0xe7b01000, 0xcfa01000, 0xdd9c1000, 0xe9901000,
+        0xc7981000, 0xc7b41000, 0xc7d81000, 0xe7d01000, 0xcfc41000, 0xcf841000,
+        0xc79c1000, 0xc79c1000, 0xc3bc1000, 0xcfdc1000, 0xe78c1000, 0xe7901000,
+        0xe5dc1000, 0xcbd01000, 0xe7bc1000, 0xc9a81000, 0xd7941000, 0xe9e81000,
+        0xeb9c1000, 0xc5a41000, 0xdbe81000, 0xf5b41000, 0xdb9c1000, 0xe5941000,
+        0xf5dc1000, 0xdd841000, 0xdbdc1000, 0xd9cc1000, 0xc5dc1000, 0xe7e81000,
+        0xd7b41000, 0xf5841003, 0xcbc81000, 0xc5e81000, 0xcfd01000, 0xe7d81000,
+        0xd1b81800, 0xdda41000, 0xc7c81000, 0xe1841000, 0xe1941000, 0xc3c81800,
+        0xc5c81000, 0xc7b01000, 0xc7bc1800, 0xed941000, 0xc5bc1000, 0xcfe41000,
+        0xcb8c1000, 0xcf981000, 0xe1e41000, 0xe7c81000, 0xebe41000, 0xcdac1000
     };
 
     static final String LOG_TAG = "MccTable";
@@ -504,7 +488,7 @@ public final class MccTable
         int tzInd = (indCode >>> 4) & 0x001F;
         String tz = TZ_STRINGS[tzInd];
         if (tz == "") {
-            return null;
+            return TimeUtils.getPrimaryTimeZoneID(countryCodeForMcc(mcc));
         }
         return tz;
     }
@@ -519,7 +503,7 @@ public final class MccTable
             return "";
         }
         int indCode = IND_CODES[index];
-        byte[] iso = {(byte)((indCode >>> 24) & 0x00FF), (byte)((indCode >>> 16) & 0x00FF)};
+        byte[] iso = {(byte)((indCode >>> 25) & 0x007F), (byte)((indCode >>> 18) & 0x007F)};
         return new String(iso);
     }
 
@@ -533,7 +517,7 @@ public final class MccTable
             return null;
         }
         int indCode = IND_CODES[index];
-        int langInd = indCode & 0x000F;
+        int langInd = indCode & 0x003F;
         String lang = LANG_STRINGS[langInd];
         if (lang == "") {
             return null;
@@ -551,7 +535,7 @@ public final class MccTable
             return 2;
         }
         int indCode = IND_CODES[index];
-        int smDig = (indCode >>> 9) & 0x0003;
+        int smDig = (indCode >>> 11) & 0x0003;
         return smDig;
     }
 
@@ -565,7 +549,7 @@ public final class MccTable
             return 0;
         }
         int indCode = IND_CODES[index];
-        int wifi = (indCode >>> 11) & 0x000F;
+        int wifi = (indCode >>> 13) & 0x000F;
         return wifi;
     }
 
diff --git a/telephony/java/com/android/internal/telephony/MotoTegraRIL.java b/telephony/java/com/android/internal/telephony/MotoTegraRIL.java
new file mode 100644
index 0000000..a3910e1
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/MotoTegraRIL.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Message;
+import android.os.Parcel;
+import android.util.Log;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import com.android.internal.telephony.gsm.NetworkInfo;
+
+import java.util.ArrayList;
+
+/**
+ * Motorola Tegra2 RIL class
+ *
+ * {@hide}
+ */
+public class MotoTegraRIL extends RIL implements CommandsInterface {
+    public MotoTegraRIL(Context context) {
+        super(context);
+    }
+
+    public MotoTegraRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        status.setGsmUmtsSubscriptionAppIndex(p.readInt());
+        status.setCdmaSubscriptionAppIndex(p.readInt());
+
+        /**
+         *  Motorola Atrix RIL has an extra field in here
+         *  If not discarded, the application count will be
+         *  incorrect and break things
+         */
+        p.readInt();
+
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = p.readInt();
+            ca.pin2           = p.readInt();
+            status.addApplication(ca);
+        }
+        return status;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/MotoTegraWorldRIL.java b/telephony/java/com/android/internal/telephony/MotoTegraWorldRIL.java
new file mode 100644
index 0000000..60a391b
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/MotoTegraWorldRIL.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Message;
+import android.os.Parcel;
+import android.util.Log;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import com.android.internal.telephony.gsm.NetworkInfo;
+
+import java.util.ArrayList;
+
+/**
+ * Motorola Tegra2 World RIL class
+ *
+ * {@hide}
+ */
+public class MotoTegraWorldRIL extends MotoTegraRIL {
+
+    public MotoTegraWorldRIL(Context context, int networkMode, int cdmaSubscription) {
+        // for testing purposes, we're forcing Global. Will be reverted in due time.
+        super(context, RILConstants.NETWORK_MODE_GLOBAL, cdmaSubscription);
+
+        Log.i("TegraWorld", "Network mode is this at creation of object: "
+              + networkMode + ", but has been forced to Global");
+
+        // BUG: On CDMA Only, networkmode still is 0. That forces GSM_Phone,
+        // since it's WCDMA-Preferred... by default.
+    }
+
+}
diff --git a/telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java b/telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java
new file mode 100644
index 0000000..695770b
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/MotoWrigley3GRIL.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.util.Log;
+
+import com.android.internal.telephony.DataCallState;
+import static com.android.internal.telephony.RILConstants.RIL_REQUEST_SETUP_DATA_CALL;
+import com.android.internal.telephony.gsm.NetworkInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+
+import java.util.ArrayList;
+
+/**
+ * RIL class for Motorola Wrigley 3G RILs which need
+ * supplementary service notification post-processing
+ *
+ * {@hide}
+ */
+public class MotoWrigley3GRIL extends RIL {
+    private static final String TAG = "MotoWrigley3GRIL";
+
+    private int mDataConnectionCount = -1;
+    private RILRequest mSetupDataCallRequest;
+
+    public MotoWrigley3GRIL(Context context) {
+        super(context);
+    }
+
+    public MotoWrigley3GRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+        mSender = new RILSender(mSenderThread.getLooper());
+    }
+
+    @Override
+    protected RILRequest
+    findAndRemoveRequestFromList(int serial) {
+        RILRequest rr = super.findAndRemoveRequestFromList(serial);
+        if (rr == mSetupDataCallRequest) {
+            /*
+             * either response arrived, or there was an error that was already handled -
+             * either way, the upper layers were notified already
+             */
+            Log.d(TAG, "Got SETUP_DATA_CALL response");
+            mSetupDataCallRequest = null;
+        }
+        return rr;
+    }
+
+    @Override
+    protected Object
+    responseSuppServiceNotification(Parcel p) {
+        SuppServiceNotification notification =
+                (SuppServiceNotification) super.responseSuppServiceNotification(p);
+
+        /**
+         * Moto's RIL seems to confuse code2 0 ('forwarded call') and
+         * 10 ('additional incoming call forwarded') and sends 10 when an
+         * incoming call is forwarded and _no_ call is currently active.
+         * It never sends 10 where it would be appropriate, so it's safe
+         * to just convert every occurence of 10 to 0.
+         */
+        if (notification.notificationType == SuppServiceNotification.NOTIFICATION_TYPE_MT) {
+            if (notification.code == SuppServiceNotification.MT_CODE_ADDITIONAL_CALL_FORWARDED) {
+                notification.code = SuppServiceNotification.MT_CODE_FORWARDED_CALL;
+            }
+        }
+
+        return notification;
+    }
+
+    @Override
+    protected Object
+    responseDataCallList(Parcel p) {
+        ArrayList<DataCallState> response =
+                (ArrayList<DataCallState>) super.responseDataCallList(p);
+        mDataConnectionCount = response.size();
+        Log.d(TAG, "Got data call list message, now has " + mDataConnectionCount + " connections");
+
+        return response;
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(7);
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString(protocol);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol);
+
+        mSetupDataCallRequest = rr;
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    deactivateDataCall(int cid, Message result) {
+        if (mDataConnectionCount == 0) {
+            Log.w(TAG, "Received deactivateDataCall RIL call without an active data call, dropping");
+            AsyncResult.forMessage(result, null, null);
+            result.sendToTarget();
+        } else {
+            super.deactivateDataCall(cid, result);
+        }
+    }
+
+    class RILSender extends RIL.RILSender {
+        public RILSender(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void
+        handleMessage(Message msg) {
+            super.handleMessage(msg);
+
+            if (msg.what == EVENT_WAKE_LOCK_TIMEOUT && mSetupDataCallRequest != null) {
+                MotoWrigley3GRIL.super.findAndRemoveRequestFromList(mSetupDataCallRequest.mSerial);
+                if (mSetupDataCallRequest.mResult != null) {
+                    Log.e(TAG, "Got stale SETUP_DATA_CALL request, pretending radio not available");
+                    CommandException ex = new CommandException(CommandException.Error.RADIO_NOT_AVAILABLE);
+                    AsyncResult.forMessage(mSetupDataCallRequest.mResult, null, ex);
+                    mSetupDataCallRequest.mResult.sendToTarget();
+                }
+                mSetupDataCallRequest.release();
+                mSetupDataCallRequest = null;
+            }
+        }
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/Phone.java b/telephony/java/com/android/internal/telephony/Phone.java
index c7d4ead..2638057 100644
--- a/telephony/java/com/android/internal/telephony/Phone.java
+++ b/telephony/java/com/android/internal/telephony/Phone.java
@@ -1717,4 +1717,15 @@ public interface Phone {
     void unsetOnEcbModeExitResponse(Handler h);
 
 
+    /**
+     * TODO: Adding a function for each property is not good.
+     * A fucntion of type getPhoneProp(propType) where propType is an
+     * enum of GSM+CDMA+LTE props would be a better approach.
+     *
+     * Get "Restriction of menu options for manual PLMN selection" bit
+     * status from EF_CSP data, this belongs to "Value Added Services Group".
+     * @return true if this bit is set or EF_CSP data is unavailable,
+     * false otherwise
+     */
+    boolean isCspPlmnEnabled();
 }
diff --git a/telephony/java/com/android/internal/telephony/PhoneBase.java b/telephony/java/com/android/internal/telephony/PhoneBase.java
index 9c6b432..3b22c31 100644
--- a/telephony/java/com/android/internal/telephony/PhoneBase.java
+++ b/telephony/java/com/android/internal/telephony/PhoneBase.java
@@ -992,6 +992,11 @@ public abstract class PhoneBase extends Handler implements Phone {
      */
     protected void notifyNewRingingConnectionP(Connection cn) {
         AsyncResult ar = new AsyncResult(null, cn, null);
+        if (SystemProperties.getBoolean(
+                "ro.telephony.call_ring.absent", false)) {
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, mCallRingContinueToken, 0), mCallRingDelay);
+        }
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
 
@@ -1020,6 +1025,13 @@ public abstract class PhoneBase extends Handler implements Phone {
         }
     }
 
+    public boolean isCspPlmnEnabled() {
+        // This function should be overridden by the class GSMPhone.
+        // Not implemented in CDMAPhone.
+        logUnexpectedGsmMethodCall("isCspPlmnEnabled");
+        return false;
+    }
+
     /**
      * Common error logger method for unexpected calls to CDMA-only methods.
      */
@@ -1028,4 +1040,12 @@ public abstract class PhoneBase extends Handler implements Phone {
         Log.e(LOG_TAG, "Error! " + name + "() in PhoneBase should not be " +
                 "called, CDMAPhone inactive.");
     }
+
+    /**
+     * Common error logger method for unexpected calls to GSM/WCDMA-only methods.
+     */
+    private void logUnexpectedGsmMethodCall(String name) {
+        Log.e(LOG_TAG, "Error! " + name + "() in PhoneBase should not be " +
+                "called, GSMPhone inactive.");
+    }
 }
diff --git a/telephony/java/com/android/internal/telephony/PhoneFactory.java b/telephony/java/com/android/internal/telephony/PhoneFactory.java
index 2e391cb..7f1ab78 100644
--- a/telephony/java/com/android/internal/telephony/PhoneFactory.java
+++ b/telephony/java/com/android/internal/telephony/PhoneFactory.java
@@ -21,6 +21,7 @@ import android.net.LocalServerSocket;
 import android.os.Looper;
 import android.provider.Settings;
 import android.util.Log;
+import android.os.SystemProperties;
 
 import com.android.internal.telephony.cdma.CDMAPhone;
 import com.android.internal.telephony.gsm.GSMPhone;
@@ -107,7 +108,38 @@ public class PhoneFactory {
                 Log.i(LOG_TAG, "Cdma Subscription set to " + Integer.toString(cdmaSubscription));
 
                 //reads the system properties and makes commandsinterface
-                sCommandsInterface = new RIL(context, networkMode, cdmaSubscription);
+
+                String sRILClassname = SystemProperties.get("ro.telephony.ril_class");
+                Log.i(LOG_TAG, "RILClassname is " + sRILClassname);
+
+                if("samsung".equals(sRILClassname))
+                {
+                    Log.i(LOG_TAG, "Using Samsung RIL");
+                    sCommandsInterface = new SamsungRIL(context, networkMode, cdmaSubscription);
+                } else if ("htc".equals(sRILClassname)) {
+                    Log.i(LOG_TAG, "Using HTC RIL");
+                    sCommandsInterface = new HTCRIL(context, networkMode, cdmaSubscription);
+                } else if("lgestar".equals(sRILClassname)) {
+                    Log.i(LOG_TAG, "Using LGE Star RIL");
+                    sCommandsInterface = new LGEStarRIL(context, networkMode, cdmaSubscription);
+                } else if ("semc".equals(sRILClassname)) {
+                    Log.i(LOG_TAG, "Using Semc RIL");
+                    sCommandsInterface = new SemcRIL(context, networkMode, cdmaSubscription);
+                } else if ("lgeqcom".equals(sRILClassname)) {
+                    Log.i(LOG_TAG, "Using LGE Qualcomm RIL");
+                    sCommandsInterface = new LGEQualcommRIL(context, networkMode, cdmaSubscription);
+                } else if ("mototegra".equals(sRILClassname)) {
+                    Log.i(LOG_TAG, "Using Motorola Tegra2 RIL");
+                    sCommandsInterface = new MotoTegraRIL(context, networkMode, cdmaSubscription);
+                } else if ("mototegraworld".equals(sRILClassname)) {
+                    Log.i(LOG_TAG, "Using Motorola Tegra2 World Edition RIL");
+                    sCommandsInterface = new MotoTegraWorldRIL(context, networkMode, cdmaSubscription);
+                } else if ("motow3g".equals(sRILClassname)) {
+                    Log.i(LOG_TAG, "Using Motorola Wrigley 3G RIL");
+                    sCommandsInterface = new MotoWrigley3GRIL(context, networkMode, cdmaSubscription);
+                } else {
+                    sCommandsInterface = new RIL(context, networkMode, cdmaSubscription);
+                }
 
                 int phoneType = getPhoneType(networkMode);
                 if (phoneType == Phone.PHONE_TYPE_GSM) {
diff --git a/telephony/java/com/android/internal/telephony/PhoneProxy.java b/telephony/java/com/android/internal/telephony/PhoneProxy.java
index 6f08868..ca4f7ba 100644
--- a/telephony/java/com/android/internal/telephony/PhoneProxy.java
+++ b/telephony/java/com/android/internal/telephony/PhoneProxy.java
@@ -89,6 +89,8 @@ public class PhoneProxy extends Handler implements Phone {
             if(mOutgoingPhone.equals("GSM")) {
                 logd("Make a new CDMAPhone and destroy the old GSMPhone.");
 
+                // Since we already know we're disposing of this
+                CallManager.getInstance().unregisterPhone(mActivePhone);
                 ((GSMPhone)mActivePhone).dispose();
                 Phone oldPhone = mActivePhone;
 
@@ -100,10 +102,16 @@ public class PhoneProxy extends Handler implements Phone {
 
                 mActivePhone = PhoneFactory.getCdmaPhone();
                 ((GSMPhone)oldPhone).removeReferences();
+
+                // out with the old...
                 oldPhone = null;
+
+                // ...and in with the new!
+                CallManager.getInstance().registerPhoneAsDefault(mActivePhone);
             } else {
                 logd("Make a new GSMPhone and destroy the old CDMAPhone.");
 
+                CallManager.getInstance().unregisterPhone(mActivePhone);
                 ((CDMAPhone)mActivePhone).dispose();
                 //mActivePhone = null;
                 Phone oldPhone = mActivePhone;
@@ -116,7 +124,9 @@ public class PhoneProxy extends Handler implements Phone {
 
                 mActivePhone = PhoneFactory.getGsmPhone();
                 ((CDMAPhone)oldPhone).removeReferences();
+
                 oldPhone = null;
+                CallManager.getInstance().registerPhoneAsDefault(mActivePhone);
             }
 
             if (mResetModemOnRadioTechnologyChange) {
@@ -843,4 +853,8 @@ public class PhoneProxy extends Handler implements Phone {
     public void unsetOnEcbModeExitResponse(Handler h){
         mActivePhone.unsetOnEcbModeExitResponse(h);
     }
+
+    public boolean isCspPlmnEnabled() {
+        return mActivePhone.isCspPlmnEnabled();
+    }
 }
diff --git a/telephony/java/com/android/internal/telephony/QualcommNoSimReadyRIL.java b/telephony/java/com/android/internal/telephony/QualcommNoSimReadyRIL.java
new file mode 100644
index 0000000..bdc5ba4
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/QualcommNoSimReadyRIL.java
@@ -0,0 +1,767 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.telephony.SmsMessage;
+import android.util.Log;
+
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+
+import java.util.ArrayList;
+
+/**
+ * Qualcomm RIL class for basebands that do not send the SIM status
+ * piggybacked in RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED. Instead,
+ * these radios will send radio state and we have to query for SIM
+ * status separately.
+ *
+ * {@hide}
+ */
+public class QualcommNoSimReadyRIL extends RIL implements CommandsInterface {
+    protected HandlerThread mIccThread;
+    protected IccHandler mIccHandler;
+
+    private final int RIL_INT_RADIO_OFF = 0;
+    private final int RIL_INT_RADIO_UNAVALIABLE = 1;
+    private final int RIL_INT_RADIO_ON = 2;
+
+    public QualcommNoSimReadyRIL(Context context) {
+        super(context);
+    }
+
+    public QualcommNoSimReadyRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+ cat libs/telephony/ril_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GPRS_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseNetworkInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            case 104: ret = responseInts(p); break; // RIL_REQUEST_VOICE_RADIO_TECH
+            case 105: ret = responseInts(p); break; // RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE
+            case 106: ret = responseStrings(p); break; // RIL_REQUEST_CDMA_PRL_VERSION
+            case 107: ret = responseInts(p);  break; // RIL_REQUEST_IMS_REGISTRATION_STATE
+            case 108: ret = responseSMS(p);  break; // RIL_REQUEST_IMS_SEND_SMS
+
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            rr.onError(error, ret);
+            rr.release();
+            return;
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    @Override
+    protected void
+    processUnsolicited (Parcel p) {
+        int response;
+        Object ret;
+
+        response = p.readInt();
+
+        try {switch(response) {
+/*
+ cat libs/telephony/ril_unsol_commands.h \
+ | egrep "^ *{RIL_" \
+ | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: \2(rr, p); break;/'
+*/
+
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED: ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: ret =  responseInts(p); break;
+            case RIL_UNSOL_ON_USSD: ret =  responseStrings(p); break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseString(p); break;
+            case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: ret = responseDataCallList(p);break;
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+            case RIL_UNSOL_STK_EVENT_NOTIFY: ret = responseString(p); break;
+            case RIL_UNSOL_STK_CALL_SETUP: ret = responseInts(p); break;
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+            case RIL_UNSOL_SIM_REFRESH: ret =  responseInts(p); break;
+            case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: ret = responseInts(p); break;
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:  ret =  responseCdmaSms(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseRaw(p); break;
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:  ret =  responseVoid(p); break;
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_UNSOL_CDMA_CALL_WAITING: ret = responseCdmaCallWaiting(p); break;
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: ret = responseInts(p); break;
+            case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+            case RIL_UNSOL_OEM_HOOK_RAW: ret = responseRaw(p); break;
+            case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+            case RIL_UNSOL_RESEND_INCALL_MUTE: ret = responseVoid(p); break;
+            case 1031: ret = responseVoid(p); break; // RIL_UNSOL_VOICE_RADIO_TECH_CHANGED
+            case 1032: ret = responseInts(p); break; // RIL_UNSOL_TETHERED_MODE_STATE_CHANGED
+            case 1033: ret = responseVoid(p); break; // RIL_UNSOL_RESPONSE_DATA_NETWORK_STATE_CHANGED
+            case 1034: ret = responseVoid(p); break; // RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED
+            case 1035: ret = responseVoid(p); break; // RIL_UNSOL_CDMA_PRL_CHANGED
+            case 1036: ret = responseVoid(p); break; // RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED
+            case 1037: ret = responseVoid(p); break; // RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE
+
+            default:
+                throw new RuntimeException("Unrecognized unsol response: " + response);
+            //break; (implied)
+        }} catch (Throwable tr) {
+            Log.e(LOG_TAG, "Exception processing unsol response: " + response +
+                "Exception:" + tr.toString());
+            return;
+        }
+
+        switch(response) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                int state = p.readInt();
+                setRadioStateFromRILInt(state);
+            break;
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mCallStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                mNetworkStateRegistrants
+                    .notifyRegistrants(new AsyncResult(null, null, null));
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS: {
+                if (RILJ_LOGD) unsljLog(response);
+
+                // FIXME this should move up a layer
+                String a[] = new String[2];
+
+                a[1] = (String)ret;
+
+                SmsMessage sms;
+
+                sms = SmsMessage.newFromCMT(a);
+                if (mSMSRegistrant != null) {
+                    mSMSRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+            break;
+            }
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSmsStatusRegistrant != null) {
+                    mSmsStatusRegistrant.notifyRegistrant(
+                            new AsyncResult(null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                int[] smsIndex = (int[])ret;
+
+                if(smsIndex.length == 1) {
+                    if (mSmsOnSimRegistrant != null) {
+                        mSmsOnSimRegistrant.
+                                notifyRegistrant(new AsyncResult(null, smsIndex, null));
+                    }
+                } else {
+                    if (RILJ_LOGD) riljLog(" NEW_SMS_ON_SIM ERROR with wrong length "
+                            + smsIndex.length);
+                }
+            break;
+            case RIL_UNSOL_ON_USSD:
+                String[] resp = (String[])ret;
+
+                if (resp.length < 2) {
+                    resp = new String[2];
+                    resp[0] = ((String[])ret)[0];
+                    resp[1] = null;
+                }
+                if (RILJ_LOGD) unsljLogMore(response, resp[0]);
+                if (mUSSDRegistrant != null) {
+                    mUSSDRegistrant.notifyRegistrant(
+                        new AsyncResult (null, resp, null));
+                }
+            break;
+            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                // has bonus long containing milliseconds since boot that the NITZ
+                // time was received
+                long nitzReceiveTime = p.readLong();
+
+                Object[] result = new Object[2];
+
+                result[0] = ret;
+                result[1] = Long.valueOf(nitzReceiveTime);
+
+                if (mNITZTimeRegistrant != null) {
+
+                    mNITZTimeRegistrant
+                        .notifyRegistrant(new AsyncResult (null, result, null));
+                } else {
+                    // in case NITZ time registrant isnt registered yet
+                    mLastNITZTimeInfo = result;
+                }
+            break;
+
+            case RIL_UNSOL_SIGNAL_STRENGTH:
+                // Note this is set to "verbose" because it happens
+                // frequently
+                if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+                if (mSignalStrengthRegistrant != null) {
+                    mSignalStrengthRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+            break;
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+            break;
+
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mSsnRegistrant != null) {
+                    mSsnRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_SESSION_END:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mStkSessionEndRegistrant != null) {
+                    mStkSessionEndRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkProCmdRegistrant != null) {
+                    mStkProCmdRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_EVENT_NOTIFY:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkEventRegistrant != null) {
+                    mStkEventRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_STK_CALL_SETUP:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mStkCallSetUpRegistrant != null) {
+                    mStkCallSetUpRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_SIM_REFRESH:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mIccRefreshRegistrant != null) {
+                    mIccRefreshRegistrant.notifyRegistrant(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CALL_RING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mRingRegistrant != null) {
+                    mRingRegistrant.notifyRegistrant(
+                            new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRestrictedStateRegistrant != null) {
+                    mRestrictedStateRegistrant.notifyRegistrant(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccStatusChangedRegistrants != null) {
+                    mIccStatusChangedRegistrants.notifyRegistrants();
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                SmsMessage sms = (SmsMessage) ret;
+
+                if (mSMSRegistrant != null) {
+                    mSMSRegistrant
+                        .notifyRegistrant(new AsyncResult(null, sms, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mGsmBroadcastSmsRegistrant != null) {
+                    mGsmBroadcastSmsRegistrant
+                        .notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mIccSmsFullRegistrant != null) {
+                    mIccSmsFullRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+                if (RILJ_LOGD) unsljLog(response);
+
+                if (mEmergencyCallbackModeRegistrant != null) {
+                    mEmergencyCallbackModeRegistrant.notifyRegistrant();
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_CALL_WAITING:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mCallWaitingInfoRegistrants != null) {
+                    mCallWaitingInfoRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mOtaProvisionRegistrants != null) {
+                    mOtaProvisionRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_CDMA_INFO_REC:
+                ArrayList<CdmaInformationRecords> listInfoRecs;
+
+                try {
+                    listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+                } catch (ClassCastException e) {
+                    Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+                    break;
+                }
+
+                for (CdmaInformationRecords rec : listInfoRecs) {
+                    if (RILJ_LOGD) unsljLogRet(response, rec);
+                    notifyRegistrantsCdmaInfoRec(rec);
+                }
+                break;
+
+            case RIL_UNSOL_OEM_HOOK_RAW:
+                if (RILJ_LOGD) unsljLogvRet(response, IccUtils.bytesToHexString((byte[])ret));
+                if (mUnsolOemHookRawRegistrant != null) {
+                    mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                }
+                break;
+
+            case RIL_UNSOL_RINGBACK_TONE:
+                if (RILJ_LOGD) unsljLogvRet(response, ret);
+                if (mRingbackToneRegistrants != null) {
+                    boolean playtone = (((int[])ret)[0] == 1);
+                    mRingbackToneRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, playtone, null));
+                }
+                break;
+
+            case RIL_UNSOL_RESEND_INCALL_MUTE:
+                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+                if (mResendIncallMuteRegistrants != null) {
+                    mResendIncallMuteRegistrants.notifyRegistrants(
+                                        new AsyncResult (null, ret, null));
+                }
+                break;
+
+            case 1031:
+                break;
+            case 1032:
+                break;
+            case 1033:
+                break;
+            case 1034:
+                break;
+            case 1035:
+                break;
+            case 1036:
+                break;
+            case 1037:
+                break;
+
+        }
+    }
+
+    private void setRadioStateFromRILInt (int stateCode) {
+        CommandsInterface.RadioState radioState;
+        HandlerThread handlerThread;
+        Looper looper;
+        IccHandler iccHandler;
+
+        switch (stateCode) {
+            case RIL_INT_RADIO_OFF:
+                radioState = CommandsInterface.RadioState.RADIO_OFF;
+                break;
+            case RIL_INT_RADIO_UNAVALIABLE:
+                radioState = CommandsInterface.RadioState.RADIO_UNAVAILABLE;
+                break;
+            case RIL_INT_RADIO_ON:
+                if (mIccHandler == null) {
+                    handlerThread = new HandlerThread("IccHandler");
+                    mIccThread = handlerThread;
+
+                    mIccThread.start();
+
+                    looper = mIccThread.getLooper();
+                    mIccHandler = new IccHandler(this,looper);
+                    mIccHandler.run();
+                }
+                if (mPhoneType == RILConstants.CDMA_PHONE) {
+                    radioState = CommandsInterface.RadioState.RUIM_NOT_READY;
+                } else {
+                    radioState = CommandsInterface.RadioState.SIM_NOT_READY;
+                }
+                setRadioState(radioState);
+                break;
+            default:
+                throw new RuntimeException("Unrecognized RIL_RadioState: " + stateCode);
+        }
+
+        if (mInitialRadioStateChange) {
+            if (radioState.isOn()) {
+                Log.d(LOG_TAG, "Radio ON @ init; reset to OFF");
+                setRadioPower(false, null);
+            }
+            else {
+                setRadioState (radioState);
+            }
+            mInitialRadioStateChange = false;
+        }
+        else {
+            setRadioState (radioState);
+        }
+    }
+    class IccHandler extends Handler implements Runnable {
+        private static final int EVENT_RADIO_ON = 1;
+        private static final int EVENT_ICC_STATUS_CHANGED = 2;
+        private static final int EVENT_GET_ICC_STATUS_DONE = 3;
+        private static final int EVENT_RADIO_OFF_OR_UNAVAILABLE = 4;
+
+        private RIL mRil;
+        private boolean mRadioOn = false;
+
+        public IccHandler (RIL ril, Looper looper) {
+            super (looper);
+            mRil = ril;
+        }
+
+        public void handleMessage (Message paramMessage) {
+            switch (paramMessage.what) {
+                case EVENT_RADIO_ON:
+                    mRadioOn = true;
+                    Log.d(LOG_TAG, "Radio on -> Forcing sim status update");
+                    sendMessage(obtainMessage(EVENT_ICC_STATUS_CHANGED));
+                    break;
+                case EVENT_GET_ICC_STATUS_DONE:
+                    AsyncResult asyncResult = (AsyncResult) paramMessage.obj;
+                    if (asyncResult.exception != null) {
+                        Log.e (LOG_TAG, "IccCardStatusDone shouldn't return exceptions!", asyncResult.exception);
+                        break;
+                    }
+                    IccCardStatus status = (IccCardStatus) asyncResult.result;
+                    if (status.getNumApplications() == 0) {
+                        if (!mRil.getRadioState().isOn()) {
+                            break;
+                        }
+
+                        if (mPhoneType == RILConstants.CDMA_PHONE) {
+                            mRil.setRadioState(CommandsInterface.RadioState.RUIM_LOCKED_OR_ABSENT);
+                        } else {
+                            mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                        }
+                    } else {
+                        int appIndex = -1;
+                        if (mPhoneType == RILConstants.CDMA_PHONE) {
+                            appIndex = status.getCdmaSubscriptionAppIndex();
+                            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+                        } else {
+                            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+                            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+                        }
+
+                        IccCardApplication application = status.getApplication(appIndex);
+                        IccCardApplication.AppState app_state = application.app_state;
+                        IccCardApplication.AppType app_type = application.app_type;
+
+                        switch (app_state) {
+                            case APPSTATE_PIN:
+                            case APPSTATE_PUK:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_LOCKED_OR_ABSENT);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            case APPSTATE_READY:
+                                switch (app_type) {
+                                    case APPTYPE_SIM:
+                                    case APPTYPE_USIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.SIM_READY);
+                                        break;
+                                    case APPTYPE_RUIM:
+                                        mRil.setRadioState(CommandsInterface.RadioState.RUIM_READY);
+                                        break;
+                                    default:
+                                        Log.e(LOG_TAG, "Currently we don't handle SIMs of type: " + app_type);
+                                        return;
+                                }
+                                break;
+                            default:
+                                return;
+                        }
+                    }
+                    break;
+                case EVENT_ICC_STATUS_CHANGED:
+                    if (mRadioOn) {
+                        Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED, calling getIccCardStatus");
+                         mRil.getIccCardStatus(obtainMessage(EVENT_GET_ICC_STATUS_DONE, paramMessage.obj));
+                    } else {
+                         Log.d(LOG_TAG, "Received EVENT_ICC_STATUS_CHANGED while radio is not ON. Ignoring");
+                    }
+                    break;
+                case EVENT_RADIO_OFF_OR_UNAVAILABLE:
+                    mRadioOn = false;
+                    // disposeCards(); // to be verified;
+                default:
+                    Log.e(LOG_TAG, " Unknown Event " + paramMessage.what);
+                    break;
+            }
+        }
+
+        public void run () {
+            mRil.registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, null);
+            Message msg = obtainMessage(EVENT_RADIO_ON);
+            mRil.getIccCardStatus(msg);
+        }
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/RIL.java b/telephony/java/com/android/internal/telephony/RIL.java
index 09a4506..86534d7 100644
--- a/telephony/java/com/android/internal/telephony/RIL.java
+++ b/telephony/java/com/android/internal/telephony/RIL.java
@@ -24,6 +24,7 @@ import static android.telephony.TelephonyManager.NETWORK_TYPE_UMTS;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSDPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSUPA;
 import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPA;
+import static android.telephony.TelephonyManager.NETWORK_TYPE_HSPAP;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -141,6 +142,7 @@ class RILRequest {
                 this.mNext = sPool;
                 sPool = this;
                 sPoolSize++;
+                mResult = null;
             }
         }
     }
@@ -203,11 +205,12 @@ class RILRequest {
  *
  * {@hide}
  */
-public final class RIL extends BaseCommands implements CommandsInterface {
-    static final String LOG_TAG = "RILJ";
+public class RIL extends BaseCommands implements CommandsInterface {
+    protected static final String LOG_TAG = "RILJ";
     private static final boolean DBG = false;
     static final boolean RILJ_LOGD = Config.LOGD;
     static final boolean RILJ_LOGV = DBG ? Config.LOGD : Config.LOGV;
+    private boolean rilNeedsNullPath = false;
 
     /**
      * Wake lock timeout should be longer than the longest timeout in
@@ -215,6 +218,8 @@ public final class RIL extends BaseCommands implements CommandsInterface {
      */
     private static final int DEFAULT_WAKE_LOCK_TIMEOUT = 30000;
 
+    private boolean mNTmodeGlobal = SystemProperties.getBoolean("ro.ril.ntmodeglobal", false);
+
     //***** Instance Variables
 
     LocalSocket mSocket;
@@ -222,7 +227,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     RILSender mSender;
     Thread mReceiverThread;
     RILReceiver mReceiver;
-    private Context mContext;
+    protected Context mContext;
     WakeLock mWakeLock;
     int mWakeLockTimeout;
     // The number of requests pending to be sent out, it increases before calling
@@ -236,7 +241,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     int mRequestMessagesWaiting;
 
     // Is this the first radio state change?
-    private boolean mInitialRadioStateChange = true;
+    protected boolean mInitialRadioStateChange = true;
 
     //I'd rather this be LinkedList or something
     ArrayList<RILRequest> mRequestsList = new ArrayList<RILRequest>();
@@ -370,6 +375,11 @@ public final class RIL extends BaseCommands implements CommandsInterface {
                             rr.onError(GENERIC_FAILURE, null);
                             rr.release();
                         }
+                    } finally {
+                        // Note: We are "Done" only if there are no outstanding
+                        // requests or replies. Thus this code path will only release
+                        // the wake lock on errors.
+                        releaseWakeLockIfDone();
                     }
 
                     if (!alreadySubtracted && mRequestMessagesPending > 0) {
@@ -615,6 +625,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         super(context);
         mCdmaSubscription  = cdmaSubscription;
         mNetworkMode = networkMode;
+        rilNeedsNullPath = context.getResources().getBoolean(com.android.internal.R.bool.config_rilNeedsNullPath);
         //At startup mPhoneType is first set from networkMode
         switch(networkMode) {
             case RILConstants.NETWORK_MODE_WCDMA_PREF:
@@ -1453,6 +1464,11 @@ public final class RIL extends BaseCommands implements CommandsInterface {
 
         rr.mp.writeInt(command);
         rr.mp.writeInt(fileid);
+        // MB501 (zeppelin) and other phones (motus, morrison, etc) require this
+        // to get data working
+        if (rilNeedsNullPath) {
+            path = null;
+        }
         rr.mp.writeString(path);
         rr.mp.writeInt(p1);
         rr.mp.writeInt(p2);
@@ -1989,26 +2005,30 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         sendScreenState(true);
    }
 
-    private void setRadioStateFromRILInt(int state) {
-        RadioState newState;
+    protected RadioState getRadioStateFromInt(int stateInt) {
+        RadioState state;
 
         /* RIL_RadioState ril.h */
-        switch(state) {
-            case 0: newState = RadioState.RADIO_OFF; break;
-            case 1: newState = RadioState.RADIO_UNAVAILABLE; break;
-            case 2: newState = RadioState.SIM_NOT_READY; break;
-            case 3: newState = RadioState.SIM_LOCKED_OR_ABSENT; break;
-            case 4: newState = RadioState.SIM_READY; break;
-            case 5: newState = RadioState.RUIM_NOT_READY; break;
-            case 6: newState = RadioState.RUIM_READY; break;
-            case 7: newState = RadioState.RUIM_LOCKED_OR_ABSENT; break;
-            case 8: newState = RadioState.NV_NOT_READY; break;
-            case 9: newState = RadioState.NV_READY; break;
+        switch(stateInt) {
+            case 0: state = RadioState.RADIO_OFF; break;
+            case 1: state = RadioState.RADIO_UNAVAILABLE; break;
+            case 2: state = RadioState.SIM_NOT_READY; break;
+            case 3: state = RadioState.SIM_LOCKED_OR_ABSENT; break;
+            case 4: state = RadioState.SIM_READY; break;
+            case 5: state = RadioState.RUIM_NOT_READY; break;
+            case 6: state = RadioState.RUIM_READY; break;
+            case 7: state = RadioState.RUIM_LOCKED_OR_ABSENT; break;
+            case 8: state = RadioState.NV_NOT_READY; break;
+            case 9: state = RadioState.NV_READY; break;
 
             default:
                 throw new RuntimeException(
-                            "Unrecognized RIL_RadioState: " +state);
+                            "Unrecognized RIL_RadioState: " + stateInt);
         }
+        return state;
+    }
+
+    protected void switchToRadioState(RadioState newState) {
 
         if (mInitialRadioStateChange) {
             if (newState.isOn()) {
@@ -2063,10 +2083,16 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void
+    protected void
     send(RILRequest rr) {
         Message msg;
 
+        if (mSocket == null) {
+            rr.onError(RADIO_NOT_AVAILABLE, null);
+            rr.release();
+            return;
+        }
+
         msg = mSender.obtainMessage(EVENT_SEND, rr);
 
         acquireWakeLock();
@@ -2118,7 +2144,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private RILRequest findAndRemoveRequestFromList(int serial) {
+    protected RILRequest findAndRemoveRequestFromList(int serial) {
         synchronized (mRequestsList) {
             for (int i = 0, s = mRequestsList.size() ; i < s ; i++) {
                 RILRequest rr = mRequestsList.get(i);
@@ -2135,7 +2161,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return null;
     }
 
-    private void
+    protected void
     processSolicited (Parcel p) {
         int serial, error;
         boolean found = false;
@@ -2236,7 +2262,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
             case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
             case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
-            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseNetworkType(p); break;
             case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
             case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
             case RIL_REQUEST_CDMA_SET_SUBSCRIPTION: ret =  responseVoid(p); break;
@@ -2302,7 +2328,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         rr.release();
     }
 
-    private String
+    protected String
     retToString(int req, Object ret) {
         if (ret == null) return "";
         switch (req) {
@@ -2363,7 +2389,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return s;
     }
 
-    private void
+    protected void
     processUnsolicited (Parcel p) {
         int response;
         Object ret;
@@ -2398,7 +2424,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
             case RIL_UNSOL_RESTRICTED_STATE_CHANGED: ret = responseInts(p); break;
             case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:  ret =  responseVoid(p); break;
             case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:  ret =  responseCdmaSms(p); break;
-            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseString(p); break;
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseRaw(p); break;
             case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:  ret =  responseVoid(p); break;
             case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
             case RIL_UNSOL_CDMA_CALL_WAITING: ret = responseCdmaCallWaiting(p); break;
@@ -2420,9 +2446,10 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         switch(response) {
             case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
                 /* has bonus radio state int */
-                setRadioStateFromRILInt(p.readInt());
+                RadioState newState = getRadioStateFromInt(p.readInt());
+                if (RILJ_LOGD) unsljLogMore(response, newState.toString());
 
-                if (RILJ_LOGD) unsljLogMore(response, mState.toString());
+                switchToRadioState(newState);
             break;
             case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
                 if (RILJ_LOGD) unsljLog(response);
@@ -2686,7 +2713,12 @@ public final class RIL extends BaseCommands implements CommandsInterface {
                 break;
 
             case RIL_UNSOL_OEM_HOOK_RAW:
-                if (RILJ_LOGD) unsljLogvRet(response, IccUtils.bytesToHexString((byte[])ret));
+                String hexstr = IccUtils.bytesToHexString((byte[])ret);
+                if (RILJ_LOGD) unsljLogvRet(response, hexstr);
+                if (hexstr.equals("72656a656374")) {
+                    if (RILJ_LOGD) Log.i(LOG_TAG, "RIL got ~+FDORM=reject, let's use TelephonyManager to disable FastDormancy.");
+                    android.telephony.TelephonyManager.setDormancyRejected(true);
+                }
                 if (mUnsolOemHookRawRegistrant != null) {
                     mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
                 }
@@ -2711,7 +2743,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private Object
+    protected Object
     responseInts(Parcel p) {
         int numInts;
         int response[];
@@ -2728,12 +2760,12 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     }
 
 
-    private Object
+    protected Object
     responseVoid(Parcel p) {
         return null;
     }
 
-    private Object
+    protected Object
     responseCallForward(Parcel p) {
         int numInfos;
         CallForwardInfo infos[];
@@ -2756,7 +2788,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return infos;
     }
 
-    private Object
+    protected Object
     responseSuppServiceNotification(Parcel p) {
         SuppServiceNotification notification = new SuppServiceNotification();
 
@@ -2769,7 +2801,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return notification;
     }
 
-    private Object
+    protected Object
     responseCdmaSms(Parcel p) {
         SmsMessage sms;
         sms = SmsMessage.newFromParcel(p);
@@ -2777,7 +2809,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return sms;
     }
 
-    private Object
+    protected Object
     responseString(Parcel p) {
         String response;
 
@@ -2786,7 +2818,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseStrings(Parcel p) {
         int num;
         String response[];
@@ -2805,7 +2837,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseRaw(Parcel p) {
         int num;
         byte response[];
@@ -2815,7 +2847,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSMS(Parcel p) {
         int messageRef, errorCode;
         String ackPDU;
@@ -2830,7 +2862,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
     }
 
 
-    private Object
+    protected Object
      responseICC_IO(Parcel p) {
         int sw1, sw2;
         byte data[] = null;
@@ -2849,7 +2881,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return new IccIoResult(sw1, sw2, s);
     }
 
-    private Object
+    protected Object
     responseIccCardStatus(Parcel p) {
         IccCardApplication ca;
 
@@ -2881,7 +2913,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return status;
     }
 
-    private Object
+    protected Object
     responseCallList(Parcel p) {
         int num;
         int voiceSettings;
@@ -2946,7 +2978,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseDataCallList(Parcel p) {
         int num;
         ArrayList<DataCallState> response;
@@ -2973,7 +3005,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseNetworkInfos(Parcel p) {
         String strings[] = (String [])responseStrings(p);
         ArrayList<NetworkInfo> ret;
@@ -2998,7 +3030,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return ret;
     }
 
-   private Object
+   protected Object
    responseCellList(Parcel p) {
        int num, rssi;
        String location;
@@ -3024,6 +3056,8 @@ public final class RIL extends BaseCommands implements CommandsInterface {
            radioType = NETWORK_TYPE_HSUPA;
        } else if (radioString.equals("HSPA")) {
            radioType = NETWORK_TYPE_HSPA;
+       } else if (radioString.equals("HSPA+")) {
+           radioType = NETWORK_TYPE_HSPAP;
        } else {
            radioType = NETWORK_TYPE_UNKNOWN;
        }
@@ -3040,7 +3074,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
        return response;
     }
 
-    private Object responseGmsBroadcastConfig(Parcel p) {
+    protected Object responseGmsBroadcastConfig(Parcel p) {
         int num;
         ArrayList<SmsBroadcastConfigInfo> response;
         SmsBroadcastConfigInfo info;
@@ -3062,7 +3096,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseCdmaBroadcastConfig(Parcel p) {
         int numServiceCategories;
         int response[];
@@ -3101,7 +3135,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseSignalStrength(Parcel p) {
         int numInts = 7;
         int response[];
@@ -3115,7 +3149,24 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private ArrayList<CdmaInformationRecords>
+    // When toggle from 3G to 2G in some devices you have enter infinite
+    // loop here with try to change mode 7. In that case we force
+    // the output to the loop and set 3G again. We cannot change
+    // this in samsungRIL since crespo is not using it.
+    protected Object
+    responseNetworkType(Parcel p) {
+        int response[] = (int[]) responseInts(p);
+
+        // When the modem responds Phone.NT_MODE_GLOBAL, it means Phone.NT_MODE_WCDMA_PREF
+        if (mNTmodeGlobal && response[0] == Phone.NT_MODE_GLOBAL) {
+            Log.d(LOG_TAG, "Overriding network type response from global to WCDMA preferred");
+            response[0] = Phone.NT_MODE_WCDMA_PREF;
+        }
+
+        return response;
+    }
+
+    protected ArrayList<CdmaInformationRecords>
     responseCdmaInformationRecord(Parcel p) {
         int numberOfInfoRecs;
         ArrayList<CdmaInformationRecords> response;
@@ -3135,7 +3186,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private Object
+    protected Object
     responseCdmaCallWaiting(Parcel p) {
         CdmaCallWaitingNotification notification = new CdmaCallWaitingNotification();
 
@@ -3151,7 +3202,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return notification;
     }
 
-    private Object
+    protected Object
     responseCallRing(Parcel p){
         char response[] = new char[4];
 
@@ -3163,7 +3214,7 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private void
+    protected void
     notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
         int response = RIL_UNSOL_CDMA_INFO_REC;
         if (infoRec.record instanceof CdmaInformationRecords.CdmaDisplayInfoRec) {
@@ -3370,27 +3421,27 @@ public final class RIL extends BaseCommands implements CommandsInterface {
         }
     }
 
-    private void riljLog(String msg) {
+    protected void riljLog(String msg) {
         Log.d(LOG_TAG, msg);
     }
 
-    private void riljLogv(String msg) {
+    protected void riljLogv(String msg) {
         Log.v(LOG_TAG, msg);
     }
 
-    private void unsljLog(int response) {
+    protected void unsljLog(int response) {
         riljLog("[UNSL]< " + responseToString(response));
     }
 
-    private void unsljLogMore(int response, String more) {
+    protected void unsljLogMore(int response, String more) {
         riljLog("[UNSL]< " + responseToString(response) + " " + more);
     }
 
-    private void unsljLogRet(int response, Object ret) {
+    protected void unsljLogRet(int response, Object ret) {
         riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
-    private void unsljLogvRet(int response, Object ret) {
+    protected void unsljLogvRet(int response, Object ret) {
         riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
     }
 
diff --git a/telephony/java/com/android/internal/telephony/SamsungRIL.java b/telephony/java/com/android/internal/telephony/SamsungRIL.java
new file mode 100644
index 0000000..9374374
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SamsungRIL.java
@@ -0,0 +1,1058 @@
+package com.android.internal.telephony;
+
+import java.util.ArrayList;
+import java.util.Collections;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.AsyncResult;
+import android.os.Parcel;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.SmsManager;
+import android.telephony.SmsMessage;
+import android.telephony.TelephonyManager;
+import static com.android.internal.telephony.RILConstants.*;
+
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.DataCallState;
+import com.android.internal.telephony.gsm.NetworkInfo;
+import com.android.internal.telephony.gsm.SmsBroadcastConfigInfo;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+import com.android.internal.telephony.IccUtils;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.SmsResponse;
+import com.android.internal.telephony.cdma.CdmaCallWaitingNotification;
+import com.android.internal.telephony.cdma.CdmaInformationRecords;
+import com.android.internal.telephony.cdma.CdmaInformationRecords.CdmaSignalInfoRec;
+import com.android.internal.telephony.cdma.SignalToneUtil;
+
+import android.util.Log;
+
+public class SamsungRIL extends RIL implements CommandsInterface {
+
+	private boolean mSignalbarCount = SystemProperties.getInt("ro.telephony.sends_barcount", 0) == 1 ? true : false;
+
+	private boolean mIsSamsungCdma = SystemProperties.getBoolean("ro.ril.samsung_cdma", false);
+
+public SamsungRIL(Context context) {
+		super(context);
+	}
+
+public SamsungRIL(Context context, int networkMode, int cdmaSubscription) {
+	super(context, networkMode, cdmaSubscription);
+}
+
+//SAMSUNG SGS STATES
+    static final int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002;
+    static final int RIL_UNSOL_O2_HOME_ZONE_INFO = 11007;
+    static final int RIL_UNSOL_DEVICE_READY_NOTI = 11008;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_2 = 11011;
+    static final int RIL_UNSOL_HSDPA_STATE_CHANGED = 11016;
+    static final int RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST = 11012;
+    static final int RIL_REQUEST_DIAL_EMERGENCY = 10016;
+    static final int RIL_UNSOL_GPS_NOTI = 11009;
+
+@Override
+ public void
+    setRadioPower(boolean on, Message result) {
+        //if radio is OFF set preferred NW type and cmda subscription
+        if(mInitialRadioStateChange) {
+            synchronized (mStateMonitor) {
+                if (!mState.isOn()) {
+                    RILRequest rrPnt = RILRequest.obtain(
+                                   RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, null);
+
+                    rrPnt.mp.writeInt(1);
+                    rrPnt.mp.writeInt(mNetworkMode);
+                    if (RILJ_LOGD) riljLog(rrPnt.serialString() + "> "
+                        + requestToString(rrPnt.mRequest) + " : " + mNetworkMode);
+
+                    send(rrPnt);
+
+                    RILRequest rrCs = RILRequest.obtain(
+                                   RIL_REQUEST_CDMA_SET_SUBSCRIPTION, null);
+                    rrCs.mp.writeInt(1);
+                    rrCs.mp.writeInt(mCdmaSubscription);
+                    if (RILJ_LOGD) riljLog(rrCs.serialString() + "> "
+                    + requestToString(rrCs.mRequest) + " : " + mCdmaSubscription);
+                    send(rrCs);
+                }
+            }
+        }
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_RADIO_POWER, result);
+
+        //samsung crap for airplane mode
+		if (on)
+		{
+			rr.mp.writeInt(1);
+			rr.mp.writeInt(1);
+		} else {
+			rr.mp.writeInt(2);
+			rr.mp.writeInt(0);
+			rr.mp.writeInt(0);
+		}
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+	@Override
+    protected void
+    processSolicited (Parcel p) {
+        int serial, error;
+        boolean found = false;
+
+        serial = p.readInt();
+        error = p.readInt();
+
+	      Log.d(LOG_TAG,"Serial: "+ serial);
+        Log.d(LOG_TAG,"Error: "+ error);
+
+        RILRequest rr;
+
+        rr = findAndRemoveRequestFromList(serial);
+
+        if (rr == null) {
+            Log.w(LOG_TAG, "Unexpected solicited response! sn: "
+                            + serial + " error: " + error);
+            return;
+        }
+
+        Object ret = null;
+
+        if (error == 0 || p.dataAvail() > 0) {
+            // either command succeeds or command fails but with data payload
+            try {switch (rr.mRequest) {
+            /*
+            cat libs/telephony/ril_commands.h \
+            | egrep "^ *{RIL_" \
+            | sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: ret = \2(p); break;/'
+             */
+            case RIL_REQUEST_GET_SIM_STATUS: ret =  responseIccCardStatus(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_SIM_PUK2: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_SIM_PIN2: ret =  responseInts(p); break;
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: ret =  responseInts(p); break;
+            case RIL_REQUEST_GET_CURRENT_CALLS: ret =  responseCallList(p); break;
+            case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+            case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseLastCallFailCause(p); break;
+            case RIL_REQUEST_SIGNAL_STRENGTH: ret =  responseSignalStrength(p); break;
+            case RIL_REQUEST_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GPRS_REGISTRATION_STATE: ret =  responseStrings(p); break;
+            case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+            case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: ret =  responseSMS(p); break;
+            case RIL_REQUEST_SETUP_DATA_CALL: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SIM_IO: ret =  responseICC_IO(p); break;
+            case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: ret =  responseCallForward(p); break;
+            case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+            case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+            case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : ret =  responseNetworkInfos(p); break;
+            case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+            case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+            case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+            case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+            case RIL_REQUEST_DATA_CALL_LIST: ret =  responseDataCallList(p); break;
+            case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+            case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+            case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+            case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_BAND_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_STK_GET_PROFILE: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SET_PROFILE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: ret =  responseString(p); break;
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: ret =  responseNetworkType(p); break;
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: ret = responseCellList(p); break;
+            case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE: ret =  responseInts(p); break;
+            case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_FLASH: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BURST_DTMF: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SEND_SMS: ret =  responseSMS(p); break;
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG: ret =  responseGmsBroadcastConfig(p); break;
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG: ret =  responseCdmaBroadcastConfig(p); break;
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: ret =  responseVoid(p); break;
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: ret =  responseStrings(p); break;
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: ret =  responseInts(p); break;
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: ret =  responseVoid(p); break;
+            case RIL_REQUEST_DEVICE_IDENTITY: ret =  responseStrings(p); break;
+            case RIL_REQUEST_GET_SMSC_ADDRESS: ret = responseString(p); break;
+            case RIL_REQUEST_SET_SMSC_ADDRESS: ret = responseVoid(p); break;
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: ret = responseVoid(p); break;
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
+            default:
+                throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+            //break;
+            }} catch (Throwable tr) {
+                // Exceptions here usually mean invalid RIL responses
+
+                Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, possible invalid RIL response", tr);
+
+                if (rr.mResult != null) {
+                    AsyncResult.forMessage(rr.mResult, null, tr);
+                    rr.mResult.sendToTarget();
+                }
+                rr.release();
+                return;
+            }
+        }
+
+        if (error != 0) {
+            //ugly fix for Samsung messing up SMS_SEND request fail in binary RIL
+	         if(!(error == -1 && rr.mRequest == RIL_REQUEST_SEND_SMS))
+	         {
+                rr.onError(error, ret);
+                rr.release();
+                return;
+	         } else {
+		        try
+                {
+                    ret =  responseSMS(p);
+                } catch (Throwable tr) {
+                        Log.w(LOG_TAG, rr.serialString() + "< "
+                        + requestToString(rr.mRequest)
+                        + " exception, Processing Samsung SMS fix ", tr);
+                        rr.onError(error, ret);
+                        rr.release();
+                        return;
+                }
+	         }
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+            + " " + retToString(rr.mRequest, ret));
+
+        if (rr.mResult != null) {
+            AsyncResult.forMessage(rr.mResult, ret, null);
+            rr.mResult.sendToTarget();
+        }
+
+        rr.release();
+    }
+
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        if (TelephonyManager.getDefault().getPhoneType() != TelephonyManager.PHONE_TYPE_GSM) {
+            super.dial(address, clirMode, uusInfo, result);
+            return;
+        }
+
+        RILRequest rr;
+        if (PhoneNumberUtils.isEmergencyNumber(address)) {
+            Log.v(LOG_TAG, "Emergency dial: " + address);
+            rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
+            rr.mp.writeString(address + "/");
+        }
+        else {
+            rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+            rr.mp.writeString(address);
+        }
+
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mp.writeInt(0); // UUS information is absent
+        } else {
+            rr.mp.writeInt(1); // UUS information is present
+            rr.mp.writeInt(uusInfo.getType());
+            rr.mp.writeInt(uusInfo.getDcs());
+            rr.mp.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+	@Override
+	 protected void
+	    processUnsolicited (Parcel p) {
+	        int response;
+	        Object ret;
+
+	        response = p.readInt();
+
+	        try {switch(response) {
+				/*
+				cat libs/telephony/ril_unsol_commands.h \
+				| egrep "^ *{RIL_" \
+				| sed -re 's/\{([^,]+),[^,]+,([^}]+).+/case \1: \2(rr, p); break;/'
+				*/
+
+	            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+	            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+	            case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED: ret =  responseVoid(p); break;
+	            case RIL_UNSOL_RESPONSE_NEW_SMS: ret =  responseString(p); break;
+	            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: ret =  responseString(p); break;
+	            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: ret =  responseInts(p); break;
+	            case RIL_UNSOL_ON_USSD: ret =  responseStrings(p); break;
+	            case RIL_UNSOL_NITZ_TIME_RECEIVED: ret =  responseString(p); break;
+	            case RIL_UNSOL_SIGNAL_STRENGTH: ret = responseSignalStrength(p); break;
+	            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: ret = responseDataCallList(p);break;
+	            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+	            case RIL_UNSOL_STK_SESSION_END: ret = responseVoid(p); break;
+	            case RIL_UNSOL_STK_PROACTIVE_COMMAND: ret = responseString(p); break;
+	            case RIL_UNSOL_STK_EVENT_NOTIFY: ret = responseString(p); break;
+	            case RIL_UNSOL_STK_CALL_SETUP: ret = responseInts(p); break;
+	            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: ret =  responseVoid(p); break;
+	            case RIL_UNSOL_SIM_REFRESH: ret =  responseInts(p); break;
+	            case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+	            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: ret = responseInts(p); break;
+	            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:  ret =  responseVoid(p); break;
+	            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:  ret =  responseCdmaSms(p); break;
+	            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:  ret =  responseString(p); break;
+	            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:  ret =  responseVoid(p); break;
+	            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+	            case RIL_UNSOL_CDMA_CALL_WAITING: ret = responseCdmaCallWaiting(p); break;
+	            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: ret = responseInts(p); break;
+	            case RIL_UNSOL_CDMA_INFO_REC: ret = responseCdmaInformationRecord(p); break;
+	            case RIL_UNSOL_OEM_HOOK_RAW: ret = responseRaw(p); break;
+	            case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+	            case RIL_UNSOL_RESEND_INCALL_MUTE: ret = responseVoid(p); break;
+	            case RIL_UNSOL_HSDPA_STATE_CHANGED: ret = responseVoid(p); break;
+
+	            //fixing anoying Exceptions caused by the new Samsung states
+	            //FIXME figure out what the states mean an what data is in the parcel
+
+	            case RIL_UNSOL_O2_HOME_ZONE_INFO: ret = responseVoid(p); break;
+	            case RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST: ret = responseVoid(p); break;
+	            case RIL_UNSOL_STK_SEND_SMS_RESULT: ret = responseVoid(p); break;
+	            case RIL_UNSOL_DEVICE_READY_NOTI: ret = responseVoid(p); break;
+	            case RIL_UNSOL_GPS_NOTI: ret = responseVoid(p); break; // Ignored in TW RIL.
+	            case RIL_UNSOL_SAMSUNG_UNKNOWN_MAGIC_REQUEST_2: ret = responseVoid(p); break;
+
+	            default:
+	                throw new RuntimeException("Unrecognized unsol response: " + response);
+	            //break; (implied)
+	        }} catch (Throwable tr) {
+	            Log.e(LOG_TAG, "Exception processing unsol response: " + response +
+	                "Exception:" + tr.toString());
+	            return;
+	        }
+
+	        switch(response) {
+	            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+	                /* has bonus radio state int */
+			RadioState newState = getRadioStateFromInt(p.readInt());
+			if (RILJ_LOGD) unsljLogMore(response, newState.toString());
+
+			switchToRadioState(newState);
+	            break;
+	            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                mCallStateRegistrants
+	                    .notifyRegistrants(new AsyncResult(null, null, null));
+	            break;
+	            case RIL_UNSOL_HSDPA_STATE_CHANGED:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                mNetworkStateRegistrants
+	                    .notifyRegistrants(new AsyncResult(null, null, null));
+	            break;
+
+	            case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                mNetworkStateRegistrants
+	                    .notifyRegistrants(new AsyncResult(null, null, null));
+	            break;
+	            case RIL_UNSOL_RESPONSE_NEW_SMS: {
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                // FIXME this should move up a layer
+	                String a[] = new String[2];
+
+	                a[1] = (String)ret;
+
+	                SmsMessage sms;
+
+	                sms = SmsMessage.newFromCMT(a);
+	                if (mSMSRegistrant != null) {
+	                    mSMSRegistrant
+	                        .notifyRegistrant(new AsyncResult(null, sms, null));
+	                }
+	            break;
+	            }
+	            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mSmsStatusRegistrant != null) {
+	                    mSmsStatusRegistrant.notifyRegistrant(
+	                            new AsyncResult(null, ret, null));
+	                }
+	            break;
+	            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                int[] smsIndex = (int[])ret;
+
+	                if(smsIndex.length == 1) {
+	                    if (mSmsOnSimRegistrant != null) {
+	                        mSmsOnSimRegistrant.
+	                                notifyRegistrant(new AsyncResult(null, smsIndex, null));
+	                    }
+	                } else {
+	                    if (RILJ_LOGD) riljLog(" NEW_SMS_ON_SIM ERROR with wrong length "
+	                            + smsIndex.length);
+	                }
+	            break;
+	            case RIL_UNSOL_ON_USSD:
+	                String[] resp = (String[])ret;
+
+	                if (resp.length < 2) {
+	                    resp = new String[2];
+	                    resp[0] = ((String[])ret)[0];
+	                    resp[1] = null;
+	                }
+	                if (RILJ_LOGD) unsljLogMore(response, resp[0]);
+	                if (mUSSDRegistrant != null) {
+	                    mUSSDRegistrant.notifyRegistrant(
+	                        new AsyncResult (null, resp, null));
+	                }
+	            break;
+	            case RIL_UNSOL_NITZ_TIME_RECEIVED:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                // has bonus long containing milliseconds since boot that the NITZ
+	                // time was received
+	                long nitzReceiveTime = p.readLong();
+
+	                Object[] result = new Object[2];
+
+			String nitz = (String)ret;
+			if (RILJ_LOGD) riljLog(" RIL_UNSOL_NITZ_TIME_RECEIVED length = "
+	                            + nitz.split("[/:,+-]").length);
+			//remove the tailing information that samsung added to the string
+			//it will screw the NITZ parser
+			if(nitz.split("[/:,+-]").length >= 9)
+			    nitz = nitz.substring(0,(nitz.lastIndexOf(",")));
+			if (RILJ_LOGD) riljLog(" RIL_UNSOL_NITZ_TIME_RECEIVED striped nitz = "
+	                            + nitz);
+	                result[0] = nitz;
+	                result[1] = Long.valueOf(nitzReceiveTime);
+
+	                if (mNITZTimeRegistrant != null) {
+
+	                    mNITZTimeRegistrant
+	                        .notifyRegistrant(new AsyncResult (null, result, null));
+	                } else {
+	                    // in case NITZ time registrant isnt registered yet
+	                    mLastNITZTimeInfo = nitz;
+	                }
+	            break;
+
+	            case RIL_UNSOL_SIGNAL_STRENGTH:
+	                // Note this is set to "verbose" because it happens
+	                // frequently
+	                if (RILJ_LOGV) unsljLogvRet(response, ret);
+
+	                if (mSignalStrengthRegistrant != null) {
+	                    mSignalStrengthRegistrant.notifyRegistrant(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	            break;
+	            case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+	            break;
+
+	            case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mSsnRegistrant != null) {
+	                    mSsnRegistrant.notifyRegistrant(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_STK_SESSION_END:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                if (mStkSessionEndRegistrant != null) {
+	                    mStkSessionEndRegistrant.notifyRegistrant(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_STK_PROACTIVE_COMMAND:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mStkProCmdRegistrant != null) {
+	                    mStkProCmdRegistrant.notifyRegistrant(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_STK_EVENT_NOTIFY:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mStkEventRegistrant != null) {
+	                    mStkEventRegistrant.notifyRegistrant(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_STK_CALL_SETUP:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mStkCallSetUpRegistrant != null) {
+	                    mStkCallSetUpRegistrant.notifyRegistrant(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                if (mIccSmsFullRegistrant != null) {
+	                    mIccSmsFullRegistrant.notifyRegistrant();
+	                }
+	                break;
+
+	            case RIL_UNSOL_SIM_REFRESH:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mIccRefreshRegistrant != null) {
+	                    mIccRefreshRegistrant.notifyRegistrant(
+	                            new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_CALL_RING:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mRingRegistrant != null) {
+	                    mRingRegistrant.notifyRegistrant(
+	                            new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
+	                if (RILJ_LOGD) unsljLogvRet(response, ret);
+	                if (mRestrictedStateRegistrant != null) {
+	                    mRestrictedStateRegistrant.notifyRegistrant(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                if (mIccStatusChangedRegistrants != null) {
+	                    mIccStatusChangedRegistrants.notifyRegistrants();
+	                }
+	                break;
+
+	            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                SmsMessage sms = (SmsMessage) ret;
+
+	                if (mSMSRegistrant != null) {
+	                    mSMSRegistrant
+	                        .notifyRegistrant(new AsyncResult(null, sms, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                if (mGsmBroadcastSmsRegistrant != null) {
+	                    mGsmBroadcastSmsRegistrant
+	                        .notifyRegistrant(new AsyncResult(null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                if (mIccSmsFullRegistrant != null) {
+	                    mIccSmsFullRegistrant.notifyRegistrant();
+	                }
+	                break;
+
+	            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
+	                if (RILJ_LOGD) unsljLog(response);
+
+	                if (mEmergencyCallbackModeRegistrant != null) {
+	                    mEmergencyCallbackModeRegistrant.notifyRegistrant();
+	                }
+	                break;
+
+	            case RIL_UNSOL_CDMA_CALL_WAITING:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mCallWaitingInfoRegistrants != null) {
+	                    mCallWaitingInfoRegistrants.notifyRegistrants(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mOtaProvisionRegistrants != null) {
+	                    mOtaProvisionRegistrants.notifyRegistrants(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_CDMA_INFO_REC:
+	                ArrayList<CdmaInformationRecords> listInfoRecs;
+
+	                try {
+	                    listInfoRecs = (ArrayList<CdmaInformationRecords>)ret;
+	                } catch (ClassCastException e) {
+	                    Log.e(LOG_TAG, "Unexpected exception casting to listInfoRecs", e);
+	                    break;
+	                }
+
+	                for (CdmaInformationRecords rec : listInfoRecs) {
+	                    if (RILJ_LOGD) unsljLogRet(response, rec);
+	                    notifyRegistrantsCdmaInfoRec(rec);
+	                }
+	                break;
+
+	            case RIL_UNSOL_OEM_HOOK_RAW:
+	                if (RILJ_LOGD) unsljLogvRet(response, IccUtils.bytesToHexString((byte[])ret));
+	                if (mUnsolOemHookRawRegistrant != null) {
+	                    mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_RINGBACK_TONE:
+	                if (RILJ_LOGD) unsljLogvRet(response, ret);
+	                if (mRingbackToneRegistrants != null) {
+	                    boolean playtone = (((int[])ret)[0] == 1);
+	                    mRingbackToneRegistrants.notifyRegistrants(
+	                                        new AsyncResult (null, playtone, null));
+	                }
+	                break;
+
+	            case RIL_UNSOL_RESEND_INCALL_MUTE:
+	                if (RILJ_LOGD) unsljLogRet(response, ret);
+
+	                if (mResendIncallMuteRegistrants != null) {
+	                    mResendIncallMuteRegistrants.notifyRegistrants(
+	                                        new AsyncResult (null, ret, null));
+	                }
+	        }
+	    }
+
+	@Override
+	 protected Object
+	    responseCallList(Parcel p) {
+			int num;
+			int voiceSettings;
+			ArrayList<DriverCall> response;
+			DriverCall dc;
+			int dataAvail = p.dataAvail();
+			int pos = p.dataPosition();
+			int size = p.dataSize();
+
+			Log.d(LOG_TAG, "Parcel size = " + size);
+			Log.d(LOG_TAG, "Parcel pos = " + pos);
+			Log.d(LOG_TAG, "Parcel dataAvail = " + dataAvail);
+
+			//Samsung fucked up here
+
+            num = p.readInt();
+
+            Log.d(LOG_TAG, "num = " + num);
+            response = new ArrayList<DriverCall>(num);
+
+            for (int i = 0 ; i < num ; i++) {
+                if (mIsSamsungCdma)
+                    dc = new SamsungDriverCall();
+                else
+                    dc = new DriverCall();
+
+                dc.state = DriverCall.stateFromCLCC(p.readInt());
+                Log.d(LOG_TAG, "state = " + dc.state);
+                dc.index = p.readInt();
+                Log.d(LOG_TAG, "index = " + dc.index);
+                dc.TOA = p.readInt();
+                Log.d(LOG_TAG, "state = " + dc.TOA);
+                dc.isMpty = (0 != p.readInt());
+                Log.d(LOG_TAG, "isMpty = " + dc.isMpty);
+                dc.isMT = (0 != p.readInt());
+                Log.d(LOG_TAG, "isMT = " + dc.isMT);
+                dc.als = p.readInt();
+                Log.d(LOG_TAG, "als = " + dc.als);
+                voiceSettings = p.readInt();
+                dc.isVoice = (0 == voiceSettings) ? false : true;
+                Log.d(LOG_TAG, "isVoice = " + dc.isVoice);
+                dc.isVoicePrivacy =  (0 != p.readInt());
+                //Some Samsung magic data for Videocalls
+                voiceSettings = p.readInt();
+                //printing it to cosole for later investigation
+                Log.d(LOG_TAG, "Samsung magic = " + voiceSettings);
+                dc.number = p.readString();
+                Log.d(LOG_TAG, "number = " + dc.number);
+                int np = p.readInt();
+                Log.d(LOG_TAG, "np = " + np);
+                dc.numberPresentation = DriverCall.presentationFromCLIP(np);
+                dc.name = p.readString();
+                Log.d(LOG_TAG, "name = " + dc.name);
+                dc.namePresentation = p.readInt();
+                Log.d(LOG_TAG, "namePresentation = " + dc.namePresentation);
+                int uusInfoPresent = p.readInt();
+                Log.d(LOG_TAG, "uusInfoPresent = " + uusInfoPresent);
+
+                if (uusInfoPresent == 1) {
+	                dc.uusInfo = new UUSInfo();
+	                dc.uusInfo.setType(p.readInt());
+	                dc.uusInfo.setDcs(p.readInt());
+	                byte[] userData = p.createByteArray();
+	                dc.uusInfo.setUserData(userData);
+	                Log
+	                .v(LOG_TAG, String.format("Incoming UUS : type=%d, dcs=%d, length=%d",
+	                                dc.uusInfo.getType(), dc.uusInfo.getDcs(),
+	                                dc.uusInfo.getUserData().length));
+	                Log.v(LOG_TAG, "Incoming UUS : data (string)="
+	                        + new String(dc.uusInfo.getUserData()));
+	                Log.v(LOG_TAG, "Incoming UUS : data (hex): "
+	                        + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
+	            } else {
+	                Log.v(LOG_TAG, "Incoming UUS : NOT present!");
+	            }
+
+            // Make sure there's a leading + on addresses with a TOA of 145
+            dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
+
+            response.add(dc);
+
+            if (dc.isVoicePrivacy) {
+                mVoicePrivacyOnRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is enabled");
+            } else {
+                mVoicePrivacyOffRegistrants.notifyRegistrants();
+                Log.d(LOG_TAG, "InCall VoicePrivacy is disabled");
+            }
+        }
+
+        Collections.sort(response);
+
+        return response;
+	    }
+	
+    protected Object
+    responseLastCallFailCause(Parcel p) {
+        int response[] = (int[])responseInts(p);
+
+        if (mIsSamsungCdma && response.length > 0 &&
+            response[0] == com.android.internal.telephony.cdma.CallFailCause.ERROR_UNSPECIFIED) {
+
+            // Far-end hangup returns ERROR_UNSPECIFIED, which shows "Call Lost" dialog.
+            Log.d(LOG_TAG, "Overriding ERROR_UNSPECIFIED fail cause with NORMAL_CLEARING.");
+            response[0] = com.android.internal.telephony.cdma.CallFailCause.NORMAL_CLEARING;
+        }
+
+        return response;
+    }
+    
+	@Override
+	protected Object
+	    responseSignalStrength(Parcel p) {
+	        int numInts = 7;
+	        int response[];
+
+	        /* TODO: Add SignalStrength class to match RIL_SignalStrength */
+	        response = new int[numInts];
+	        for (int i = 0 ; i < numInts ; i++) {
+	            response[i] = p.readInt();
+	        }
+
+		/* Matching Samsung signal strength to asu.
+		   Method taken from Samsungs cdma/gsmSignalStateTracker */
+		if(mSignalbarCount)
+		{
+			//Samsung sends the count of bars that should be displayed instead of
+			//a real signal strength
+			response[0] = ((response[0] & 0xFF00) >> 8) * 3; //gsmDbm
+		} else {
+			response[0] = response[0] & 0xFF; //gsmDbm
+		}
+		response[1] = -1; //gsmEcio
+		response[2] = (response[2] < 0)?-120:-response[2]; //cdmaDbm
+		response[3] = (response[3] < 0)?-160:-response[3]; //cdmaEcio
+		response[4] = (response[4] < 0)?-120:-response[4]; //evdoRssi
+		response[5] = (response[5] < 0)?-1:-response[5]; //evdoEcio
+		if(response[6] < 0 || response[6] > 8)
+			response[6] = -1;
+
+	        return response;
+	    }
+
+    protected Object
+    responseNetworkType(Parcel p) {
+        int response[] = (int[]) responseInts(p);
+
+        // When the modem responds Phone.NT_MODE_GLOBAL, it means Phone.NT_MODE_WCDMA_PREF
+        if (!mIsSamsungCdma && response[0] == Phone.NT_MODE_GLOBAL) {
+            Log.d(LOG_TAG, "Overriding network type response from global to WCDMA preferred");
+            response[0] = Phone.NT_MODE_WCDMA_PREF;
+        }
+
+        return response;
+    }
+    
+    // Workaround for Samsung CDMA "ring of death" bug:
+    //
+    // Symptom: As soon as the phone receives notice of an incoming call, an
+    //   audible "old fashioned ring" is emitted through the earpiece and
+    //   persists through the duration of the call, or until reboot if the call
+    //   isn't answered.
+    //
+    // Background: The CDMA telephony stack implements a number of "signal info
+    //   tones" that are locally generated by ToneGenerator and mixed into the
+    //   voice call path in response to radio RIL_UNSOL_CDMA_INFO_REC requests.
+    //   One of these tones, IS95_CONST_IR_SIG_IS54B_L, is requested by the
+    //   radio just prior to notice of an incoming call when the voice call
+    //   path is muted.  CallNotifier is responsible for stopping all signal
+    //   tones (by "playing" the TONE_CDMA_SIGNAL_OFF tone) upon receipt of a
+    //   "new ringing connection", prior to unmuting the voice call path.
+    //
+    // Problem: CallNotifier's incoming call path is designed to minimize
+    //   latency to notify users of incoming calls ASAP.  Thus,
+    //   SignalInfoTonePlayer requests are handled asynchronously by spawning a
+    //   one-shot thread for each.  Unfortunately the ToneGenerator API does
+    //   not provide a mechanism to specify an ordering on requests, and thus,
+    //   unexpected thread interleaving may result in ToneGenerator processing
+    //   them in the opposite order that CallNotifier intended.  In this case,
+    //   playing the "signal off" tone first, followed by playing the "old
+    //   fashioned ring" indefinitely.
+    //
+    // Solution: An API change to ToneGenerator is required to enable
+    //   SignalInfoTonePlayer to impose an ordering on requests (i.e., drop any
+    //   request that's older than the most recent observed).  Such a change,
+    //   or another appropriate fix should be implemented in AOSP first.
+    //
+    // Workaround: Intercept RIL_UNSOL_CDMA_INFO_REC requests from the radio,
+    //   check for a signal info record matching IS95_CONST_IR_SIG_IS54B_L, and
+    //   drop it so it's never seen by CallNotifier.  If other signal tones are
+    //   observed to cause this problem, they should be dropped here as well.
+    @Override
+    protected void
+    notifyRegistrantsCdmaInfoRec(CdmaInformationRecords infoRec) {
+        final int response = RIL_UNSOL_CDMA_INFO_REC;
+
+        if (/* mIsSamsungCdma && */ infoRec.record instanceof CdmaSignalInfoRec) {
+            CdmaSignalInfoRec sir = (CdmaSignalInfoRec)infoRec.record;
+            if (sir != null && sir.isPresent &&
+                sir.signalType == SignalToneUtil.IS95_CONST_IR_SIGNAL_IS54B &&
+                sir.alertPitch == SignalToneUtil.IS95_CONST_IR_ALERT_MED    &&
+                sir.signal     == SignalToneUtil.IS95_CONST_IR_SIG_IS54B_L) {
+
+                Log.d(LOG_TAG, "Dropping \"" + responseToString(response) + " " +
+                      retToString(response, sir) + "\" to prevent \"ring of death\" bug.");
+                return;
+            }
+        }
+
+        super.notifyRegistrantsCdmaInfoRec(infoRec);
+    }
+
+    protected class SamsungDriverCall extends DriverCall {
+        @Override
+        public String
+        toString() {
+            // Samsung CDMA devices' call parcel is formatted differently
+            // fake unused data for video calls, and fix formatting
+            // so that voice calls' information can be correctly parsed
+            return "id=" + index + ","
+                    + state + ","
+                    + "toa=" + TOA + ","
+                    + (isMpty ? "conf" : "norm") + ","
+                    + (isMT ? "mt" : "mo") + ","
+                    + "als=" + als + ","
+                    + (isVoice ? "voc" : "nonvoc") + ","
+                    + "nonvid" + ","
+                    + number + ","
+                    + "cli=" + numberPresentation + ","
+                    + "name=" + name + ","
+                    + namePresentation;
+        }
+    }
+    @Override
+    public void setPreferredNetworkType(int networkType , Message response) {
+		/* Samsung modem implementation does bad things when a datacall is running
+		 * while switching the preferred networktype.
+		 */
+		ConnectivityManager cm =
+            (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+		if(cm.getMobileDataEnabled())
+		{
+			ConnectivityHandler handler = new ConnectivityHandler(mContext);
+			handler.setPreferedNetworkType(networkType, response);
+		} else {
+			sendPreferedNetworktype(networkType, response);
+		}
+    }
+
+
+	//Sends the real RIL request to the modem.
+	private void sendPreferedNetworktype(int networkType, Message response) {
+		RILRequest rr = RILRequest.obtain(
+                RILConstants.RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, response);
+
+        rr.mp.writeInt(1);
+        rr.mp.writeInt(networkType);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " : " + networkType);
+
+        send(rr);
+	}
+	/* private class that does the handling for the dataconnection
+	 * dataconnection is done async, so we send the request for disabling it,
+	 * wait for the response, set the prefered networktype and notify the
+	 * real sender with its result.
+	 */
+	private class ConnectivityHandler extends Handler{
+
+		private static final int MESSAGE_SET_PREFERRED_NETWORK_TYPE = 30;
+		private Context mContext;
+		private int mDesiredNetworkType;
+		//the original message, we need it for calling back the original caller when done
+		private Message mNetworktypeResponse;
+		private ConnectivityBroadcastReceiver mConnectivityReceiver =  new ConnectivityBroadcastReceiver();
+
+		public ConnectivityHandler(Context context)
+		{
+			mContext = context;
+		}
+
+		private void startListening() {
+	        IntentFilter filter = new IntentFilter();
+	        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
+	        mContext.registerReceiver(mConnectivityReceiver, filter);
+		}
+
+		private synchronized void stopListening() {
+	        mContext.unregisterReceiver(mConnectivityReceiver);
+		}
+
+		public void setPreferedNetworkType(int networkType, Message response)
+		{
+			Log.d(LOG_TAG, "Mobile Dataconnection is online setting it down");
+			 mDesiredNetworkType = networkType;
+			 mNetworktypeResponse = response;
+			 ConnectivityManager cm =
+                 (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+			 //start listening for the connectivity change broadcast
+			 startListening();
+			 cm.setMobileDataEnabled(false);
+		}
+
+		  @Override
+		  public void handleMessage(Message msg) {
+			  switch(msg.what) {
+			  //networktype was set, now we can enable the dataconnection again
+			  case MESSAGE_SET_PREFERRED_NETWORK_TYPE:
+					ConnectivityManager cm =
+			                   (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+					Log.d(LOG_TAG, "preferred NetworkType set upping Mobile Dataconnection");
+
+					cm.setMobileDataEnabled(true);
+					//everything done now call back that we have set the networktype
+					AsyncResult.forMessage(mNetworktypeResponse, null, null);
+					mNetworktypeResponse.sendToTarget();
+					mNetworktypeResponse = null;
+					break;
+			  default:
+			        throw new RuntimeException("unexpected event not handled");
+			  }
+		  }
+
+			private class ConnectivityBroadcastReceiver extends BroadcastReceiver {
+
+		        @Override
+		        public void onReceive(Context context, Intent intent) {
+		            String action = intent.getAction();
+		            if (!action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
+		                Log.w(LOG_TAG, "onReceived() called with " + intent);
+		                return;
+		            }
+		            boolean noConnectivity =
+		                intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);
+
+		            if (noConnectivity) {
+						//Ok dataconnection is down, now set the networktype
+						Log.w(LOG_TAG, "Mobile Dataconnection is now down setting preferred NetworkType");
+						stopListening();
+						sendPreferedNetworktype(mDesiredNetworkType, obtainMessage(MESSAGE_SET_PREFERRED_NETWORK_TYPE));
+						mDesiredNetworkType = -1;
+		            }
+		        }
+		    }
+		}
+	}
diff --git a/telephony/java/com/android/internal/telephony/SemcRIL.java b/telephony/java/com/android/internal/telephony/SemcRIL.java
new file mode 100644
index 0000000..d87853a
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SemcRIL.java
@@ -0,0 +1,453 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.os.Message;
+import android.os.Parcel;
+import android.util.Log;
+
+import com.android.internal.telephony.DataCallState;
+import com.android.internal.telephony.gsm.NetworkInfo;
+import com.android.internal.telephony.IccCardApplication;
+import com.android.internal.telephony.IccCardStatus;
+
+import java.util.ArrayList;
+
+
+/**
+ * Custom SEMC ril
+ *
+ * {@hide}
+ */
+public class SemcRIL extends QualcommNoSimReadyRIL implements CommandsInterface {
+    protected String mAid;
+
+
+    public SemcRIL(Context context) {
+        super(context);
+    }
+
+    public SemcRIL(Context context, int networkMode, int cdmaSubscription) {
+        super(context, networkMode, cdmaSubscription);
+    }
+
+    @Override
+    public void
+    supplyIccPin(String pin, Message result) {
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN, result);
+
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPuk(String puk, String newPin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPin2(String pin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(pin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyIccPuk2(String puk, String newPin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_SIM_PUK2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(puk);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    changeIccPin(String oldPin, String newPin, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(oldPin);
+        rr.mp.writeString(newPin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    changeIccPin2(String oldPin2, String newPin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_SIM_PIN2, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(oldPin2);
+        rr.mp.writeString(newPin2);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    changeBarringPassword(String facility, String oldPwd, String newPwd, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CHANGE_BARRING_PASSWORD, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(3);
+        rr.mp.writeString(facility);
+        rr.mp.writeString(oldPwd);
+        rr.mp.writeString(newPwd);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    supplyNetworkDepersonalization(String netpin, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, result);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeInt(3);
+        rr.mp.writeString(netpin);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+
+        rr.mp.writeString(address);
+        rr.mp.writeInt(clirMode);
+
+        if (uusInfo == null) {
+            rr.mp.writeInt(0); // UUS information is absent
+        } else {
+            rr.mp.writeInt(1); // UUS information is present
+            rr.mp.writeInt(uusInfo.getType());
+            rr.mp.writeInt(uusInfo.getDcs());
+            rr.mp.writeByteArray(uusInfo.getUserData());
+        }
+        rr.mp.writeInt(0xff);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    getIMSI(Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_GET_IMSI, result);
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        if (RILJ_LOGD) riljLog(rr.serialString() +
+                              "> getIMSI:RIL_REQUEST_GET_IMSI " +
+                              RIL_REQUEST_GET_IMSI +
+                              " " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setupDataCall(String radioTechnology, String profile, String apn,
+            String user, String password, String authType, String protocol,
+            Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SETUP_DATA_CALL, result);
+
+        rr.mp.writeInt(7);
+
+        rr.mp.writeString(radioTechnology);
+        rr.mp.writeString(profile);
+        rr.mp.writeString(apn);
+        rr.mp.writeString(user);
+        rr.mp.writeString(password);
+        rr.mp.writeString(authType);
+        rr.mp.writeString("0");
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> "
+                + requestToString(rr.mRequest) + " " + radioTechnology + " "
+                + profile + " " + apn + " " + user + " "
+                + password + " " + authType + " " + protocol);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    iccIO (int command, int fileid, String path, int p1, int p2, int p3,
+            String data, String pin2, Message result) {
+        //Note: This RIL request has not been renamed to ICC,
+        //       but this request is also valid for SIM and RUIM
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SIM_IO, result);
+
+        rr.mp.writeInt(0);
+        rr.mp.writeString(mAid);
+        rr.mp.writeInt(command);
+        rr.mp.writeInt(fileid);
+        rr.mp.writeString(path);
+        rr.mp.writeInt(p1);
+        rr.mp.writeInt(p2);
+        rr.mp.writeInt(p3);
+        rr.mp.writeString(data);
+        rr.mp.writeString(pin2);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> iccIO: " + requestToString(rr.mRequest)
+                + " 0x" + Integer.toHexString(command)
+                + " 0x" + Integer.toHexString(fileid) + " "
+                + " path: " + path + ","
+                + p1 + "," + p2 + "," + p3);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeAutomatic(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mp.writeString(null);
+        rr.mp.writeInt(-1);
+        send(rr);
+    }
+
+    @Override
+    public void
+    setNetworkSelectionModeManual(String operatorNumeric, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL,
+                                    response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + operatorNumeric);
+
+        rr.mp.writeString(operatorNumeric);
+        rr.mp.writeInt(-1);
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    queryFacilityLock (String facility, String password, int serviceClass,
+                            Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_QUERY_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        // count strings
+        rr.mp.writeInt(5);
+        rr.mp.writeString("0");
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(facility);
+        rr.mp.writeString(password);
+
+        rr.mp.writeString(Integer.toString(serviceClass));
+
+        send(rr);
+    }
+
+    @Override
+    public void
+    setFacilityLock (String facility, boolean lockState, String password,
+                        int serviceClass, Message response) {
+        String lockString;
+         RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_FACILITY_LOCK, response);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        // count strings
+        rr.mp.writeInt(6);
+
+        rr.mp.writeString("0");
+        rr.mp.writeString(mAid);
+        rr.mp.writeString(facility);
+        lockString = (lockState)?"1":"0";
+        rr.mp.writeString(lockString);
+        rr.mp.writeString(password);
+        rr.mp.writeString(Integer.toString(serviceClass));
+
+        send(rr);
+
+    }
+
+    @Override
+    protected Object
+    responseIccCardStatus(Parcel p) {
+        IccCardApplication ca;
+
+        IccCardStatus status = new IccCardStatus();
+        p.readInt(); // unknown first parameter
+        status.setCardState(p.readInt());
+        status.setUniversalPinState(p.readInt());
+        int gsmUmtsSubscriptionAppCount = p.readInt();
+        int n = 0;
+        for (int i = 0; i < gsmUmtsSubscriptionAppCount; i++) {
+            n = p.readInt();
+        }
+        status.setGsmUmtsSubscriptionAppIndex(n);
+
+        int cdmaSubscriptionAppCount = p.readInt();
+        for (int i = 0; i < cdmaSubscriptionAppCount; i++) {
+            n = p.readInt();
+        }
+        status.setCdmaSubscriptionAppIndex(n);
+        int numApplications = p.readInt();
+
+        // limit to maximum allowed applications
+        if (numApplications > IccCardStatus.CARD_MAX_APPS) {
+            numApplications = IccCardStatus.CARD_MAX_APPS;
+        }
+        status.setNumApplications(numApplications);
+
+        for (int i = 0 ; i < numApplications ; i++) {
+            ca = new IccCardApplication();
+            ca.app_type       = ca.AppTypeFromRILInt(p.readInt());
+            ca.app_state      = ca.AppStateFromRILInt(p.readInt());
+            ca.perso_substate = ca.PersoSubstateFromRILInt(p.readInt());
+            ca.aid            = p.readString();
+            ca.app_label      = p.readString();
+            ca.pin1_replaced  = p.readInt();
+            ca.pin1           = p.readInt();
+            ca.pin2           = p.readInt();
+            status.addApplication(ca);
+
+        }
+        int appIndex = -1;
+        if (mPhoneType == RILConstants.CDMA_PHONE) {
+            appIndex = status.getCdmaSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a CDMA PHONE " + appIndex);
+        } else {
+            appIndex = status.getGsmUmtsSubscriptionAppIndex();
+            Log.d(LOG_TAG, "This is a GSM PHONE " + appIndex);
+        }
+
+        IccCardApplication application = status.getApplication(appIndex);
+        mAid = application.aid;
+
+        return status;
+    }
+
+    @Override
+    protected Object
+    responseDataCallList(Parcel p) {
+        int num;
+        ArrayList<DataCallState> response;
+
+        num = p.readInt();
+        response = new ArrayList<DataCallState>(num);
+
+        for (int i = 0; i < num; i++) {
+            DataCallState dataCall = new DataCallState();
+
+            dataCall.cid = p.readInt();
+            dataCall.active = p.readInt();
+            dataCall.type = p.readString();
+            dataCall.apn = p.readString();
+            dataCall.address = p.readString();
+            p.readInt();
+            p.readInt();
+            response.add(dataCall);
+        }
+
+        return response;
+    }
+
+    @Override
+    protected Object
+    responseNetworkInfos(Parcel p) {
+        String strings[] = (String [])responseStrings(p);
+        ArrayList<NetworkInfo> ret;
+
+        if (strings.length % 5 != 0) {
+            throw new RuntimeException(
+                "RIL_REQUEST_QUERY_AVAILABLE_NETWORKS: invalid response. Got "
+                + strings.length + " strings, expected multible of 5");
+        }
+
+        ret = new ArrayList<NetworkInfo>(strings.length / 5);
+
+        for (int i = 0 ; i < strings.length ; i += 5) {
+            ret.add (
+                new NetworkInfo(
+                    strings[i+0],
+                    strings[i+1],
+                    strings[i+2],
+                    strings[i+3]));
+        }
+
+        return ret;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/ServiceStateTracker.java b/telephony/java/com/android/internal/telephony/ServiceStateTracker.java
index e8bbe5e..194e210 100644
--- a/telephony/java/com/android/internal/telephony/ServiceStateTracker.java
+++ b/telephony/java/com/android/internal/telephony/ServiceStateTracker.java
@@ -45,6 +45,9 @@ public abstract class ServiceStateTracker extends Handler {
     protected static final int DATA_ACCESS_HSUPA = 10;
     protected static final int DATA_ACCESS_HSPA = 11;
     protected static final int DATA_ACCESS_CDMA_EvDo_B = 12;
+    protected static final int DATA_ACCESS_EHRPD = 13;
+    protected static final int DATA_ACCESS_LTE = 14;
+    protected static final int DATA_ACCESS_HSPAP = 15;
 
     protected CommandsInterface cm;
 
diff --git a/telephony/java/com/android/internal/telephony/SimRegionCache.java b/telephony/java/com/android/internal/telephony/SimRegionCache.java
new file mode 100644
index 0000000..2cf6d25
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/SimRegionCache.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony;
+
+import android.os.SystemProperties;
+
+public class SimRegionCache {
+    public static final int MCC_UNSET  = Integer.MIN_VALUE;
+    public static final int MCC_KOREAN = 450;
+
+    private static int regionFromMcc = MCC_UNSET;
+
+    /**
+     * Returns the region as read from the MCC of the SIM card.
+     * If the property {@link TelephonyProperties#
+     * PROPERTY_ICC_OPERATOR_NUMERIC}
+     * returns null or an empty String, the value is {@link #MCC_UNSET}
+     *
+     * @return the cached region, if set.
+     */
+    public static int getRegion() {
+        if (regionFromMcc == MCC_UNSET) {
+            String plmn = SystemProperties.get(
+                    TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC,
+                    null);
+
+            if (plmn != null && plmn.length() >= 3) {
+                try {
+                    regionFromMcc = Integer.parseInt(plmn.substring(0, 3));
+                } catch(Exception e) {
+                    // Nothing that can be done here.
+                }
+            }
+        }
+        return regionFromMcc;
+    }
+}
diff --git a/telephony/java/com/android/internal/telephony/WapPushOverSms.java b/telephony/java/com/android/internal/telephony/WapPushOverSms.java
index d661640..02e5e87 100755
--- a/telephony/java/com/android/internal/telephony/WapPushOverSms.java
+++ b/telephony/java/com/android/internal/telephony/WapPushOverSms.java
@@ -129,6 +129,9 @@ public class WapPushOverSms {
                 case WspTypeDecoder.CONTENT_TYPE_B_MMS:
                     mimeType = WspTypeDecoder.CONTENT_MIME_TYPE_B_MMS;
                     break;
+                case WspTypeDecoder.CONTENT_TYPE_B_VND_WAP_EMN_WBXML:
+                    mimeType = WspTypeDecoder.CONTENT_MIME_TYPE_B_VND_WAP_EMN_WBXML;
+                    break;
                 case WspTypeDecoder.CONTENT_TYPE_B_VND_DOCOMO_PF:
                     mimeType = WspTypeDecoder.CONTENT_MIME_TYPE_B_VND_DOCOMO_PF;
                     break;
@@ -158,6 +161,8 @@ public class WapPushOverSms {
                 binaryContentType = WspTypeDecoder.CONTENT_TYPE_B_PUSH_CO;
             } else if (mimeType.equals(WspTypeDecoder.CONTENT_MIME_TYPE_B_MMS)) {
                 binaryContentType = WspTypeDecoder.CONTENT_TYPE_B_MMS;
+            } else if (mimeType.equals(WspTypeDecoder.CONTENT_MIME_TYPE_B_VND_WAP_EMN_WBXML)) {
+                binaryContentType = WspTypeDecoder.CONTENT_TYPE_B_VND_WAP_EMN_WBXML;
             } else if (mimeType.equals(WspTypeDecoder.CONTENT_MIME_TYPE_B_VND_DOCOMO_PF)) {
                 binaryContentType = WspTypeDecoder.CONTENT_TYPE_B_VND_DOCOMO_PF;
             } else if (mimeType.equals(WspTypeDecoder.CONTENT_MIME_TYPE_B_SUPL_INIT)) {
diff --git a/telephony/java/com/android/internal/telephony/WspTypeDecoder.java b/telephony/java/com/android/internal/telephony/WspTypeDecoder.java
index 01206fd..55b5f65 100755
--- a/telephony/java/com/android/internal/telephony/WspTypeDecoder.java
+++ b/telephony/java/com/android/internal/telephony/WspTypeDecoder.java
@@ -39,6 +39,7 @@ public class WspTypeDecoder {
     public static final int CONTENT_TYPE_B_PUSH_SL = 0x30;
     public static final int CONTENT_TYPE_B_PUSH_CO = 0x32;
     public static final int CONTENT_TYPE_B_MMS = 0x3e;
+    public static final int CONTENT_TYPE_B_VND_WAP_EMN_WBXML = 0x030a;
     public static final int CONTENT_TYPE_B_VND_DOCOMO_PF = 0x0310;
     public static final int CONTENT_TYPE_B_SUPL_INIT = 0x312;
     public static final int CONTENT_TYPE_B_PUSH_SYNCML_NOTI = 0x44;
@@ -51,6 +52,7 @@ public class WspTypeDecoder {
     public static final String CONTENT_MIME_TYPE_B_PUSH_SL = "application/vnd.wap.slc";
     public static final String CONTENT_MIME_TYPE_B_PUSH_CO = "application/vnd.wap.coc";
     public static final String CONTENT_MIME_TYPE_B_MMS = "application/vnd.wap.mms-message";
+    public static final String CONTENT_MIME_TYPE_B_VND_WAP_EMN_WBXML = "application/vnd.wap.emn+wbxml";
     public static final String CONTENT_MIME_TYPE_B_VND_DOCOMO_PF = "application/vnd.docomo.pf";
     public static final String CONTENT_MIME_TYPE_B_SUPL_INIT = "application/vnd.omaloc-supl-init";
     public static final String CONTENT_MIME_TYPE_B_PUSH_SYNCML_NOTI =
diff --git a/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java b/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java
index 7c4f337..9c8bd02 100755
--- a/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CDMAPhone.java
@@ -728,14 +728,20 @@ public class CDMAPhone extends PhoneBase {
 
     public String getVoiceMailNumber() {
         String number = null;
+        String cdmaNumber = SystemProperties.get("ro.cdma.voicemail.number");
         SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
-        // TODO: The default value of voicemail number should be read from a system property
-
-        // Read platform settings for dynamic voicemail number
-        if (getContext().getResources().getBoolean(com.android.internal
-                .R.bool.config_telephony_use_own_number_for_voicemail)) {
-            number = sp.getString(VM_NUMBER_CDMA, getLine1Number());
+        if (cdmaNumber.length() > 0) {
+            if (cdmaNumber.equals("mine")) {
+                // Workaround for Sprint and similar where we dial our own phone number for voicemail
+                number = sp.getString(VM_NUMBER_CDMA, getLine1Number());
+            }
+            else {
+                // Otherwise we will assign the contents of the variable to the default voicemail number
+                // TODO: Sanity checks
+                number = sp.getString(VM_NUMBER_CDMA, cdmaNumber);
+            }
         } else {
+            // Fall back to *86 if ro.cdma.voicemail.number is not defined.
             number = sp.getString(VM_NUMBER_CDMA, "*86");
         }
         return number;
@@ -1023,7 +1029,12 @@ public class CDMAPhone extends PhoneBase {
                 }
                 String[] respId = (String[])ar.result;
                 mEsn  =  respId[2];
-                mMeid =  respId[3];
+                // Samsung CDMA devices' MEID is not found in this parcel
+                // instead, extract it from system properties
+                if (SystemProperties.get("ro.ril.samsung_cdma").equals("true"))
+                    mMeid = SystemProperties.get("ro.ril.MEID");
+                else
+                    mMeid =  respId[3];
             }
             break;
 
diff --git a/telephony/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java b/telephony/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java
index fa80063..2400f90 100644
--- a/telephony/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CdmaDataConnectionTracker.java
@@ -382,6 +382,10 @@ public final class CdmaDataConnectionTracker extends DataConnectionTracker {
         }
 
         setState(State.DISCONNECTING);
+        // Samsung CDMA devices require this property to be set
+        // so that pppd will be killed to stop 3G data
+        if (SystemProperties.get("ro.ril.samsung_cdma").equals("true"))
+            SystemProperties.set("ril.cdma.data_ready", "false");
 
         boolean notificationDeferred = false;
         for (DataConnection conn : dataConnectionList) {
diff --git a/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java b/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
index e409646..737127c 100755
--- a/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CdmaSMSDispatcher.java
@@ -45,6 +45,7 @@ import com.android.internal.telephony.TelephonyProperties;
 import com.android.internal.telephony.WspTypeDecoder;
 import com.android.internal.telephony.cdma.sms.SmsEnvelope;
 import com.android.internal.telephony.cdma.sms.UserData;
+import com.android.internal.util.BitwiseInputStream;
 import com.android.internal.util.HexDump;
 
 import java.io.ByteArrayOutputStream;
@@ -206,6 +207,28 @@ final class CdmaSMSDispatcher extends SMSDispatcher {
                     // The message was sent to a port, so concoct a URI for it.
                     dispatchPortAddressedPdus(pdus, smsHeader.portAddrs.destPort);
                 }
+            }
+           /*
+            * Check to see if we have a Virgin Mobile MMS
+            * If so, do extra processsing for Virgin Mobile's non-standard format.
+            * Otherwise, dispatch normal message.
+            */
+            if (sms.getOriginatingAddress().equals("9999999999")) {
+                Log.d(TAG, "Got a suspect SMS from the Virgin MMS originator");
+                    byte virginMMSPayload[] = null;
+                    try {
+                        int[] ourMessageRef = new int[1];
+                        virginMMSPayload = getVirginMMS(sms.getUserData(), ourMessageRef);
+                        if (virginMMSPayload == null) {
+                            Log.e(TAG, "Not a virgin MMS like we were expecting");
+                            throw new Exception("Not a Virgin MMS like we were expecting");
+                        } else {
+                            Log.d(TAG, "Sending our deflowered MMS to processCdmaWapPdu");
+                            return processCdmaWapPdu(virginMMSPayload, ourMessageRef[0], "9999999999");
+                        }
+                    } catch (Exception ourException) {
+                        Log.e(TAG, "Got an exception trying to get VMUS MMS data " + ourException);
+            }
             } else {
                 // Normal short and non-port-addressed message, dispatch it.
                 dispatchPdus(pdus);
@@ -217,7 +240,54 @@ final class CdmaSMSDispatcher extends SMSDispatcher {
         }
     }
 
-    /**
+    private synchronized byte[] getVirginMMS(final byte[] someEncodedMMSData, int[] aMessageRef) throws Exception {
+        if ((aMessageRef == null) || (aMessageRef.length != 1)) {
+            throw new Exception("aMessageRef is not usable. Must be an int array with one element.");
+        }
+        BitwiseInputStream ourInputStream;
+        int i1=0;
+        int desiredBitLength;
+        Log.d(TAG, "mmsVirginGetMsgId");
+        Log.d(TAG, "EncodedMMS: " + someEncodedMMSData);
+        try {
+            ourInputStream = new BitwiseInputStream(someEncodedMMSData);
+            ourInputStream.skip(20);
+            final int j = ourInputStream.read(8) << 8;
+            final int k = ourInputStream.read(8);
+            aMessageRef[0] = j | k;
+            Log.d(TAG, "MSGREF IS : " + aMessageRef[0]);
+            ourInputStream.skip(12);
+            i1 = ourInputStream.read(8) + -2;
+            ourInputStream.skip(13);
+            byte abyte1[] = new byte[i1];
+            for (int j1 = 0; j1 < i1; j1++) {
+                abyte1[j1] = 0;
+            }
+            desiredBitLength = i1 * 8;
+            if (ourInputStream.available() < desiredBitLength) {
+                int availableBitLength = ourInputStream.available();
+                Log.e(TAG, "mmsVirginGetMsgId inStream.available() = " + availableBitLength + " wantedBits = " + desiredBitLength);
+                throw new Exception("insufficient data (wanted " + desiredBitLength + " bits, but only have " + availableBitLength + ")");
+            }
+        } catch (com.android.internal.util.BitwiseInputStream.AccessException ourException) {
+            final String ourExceptionText = "mmsVirginGetMsgId failed: " + ourException;
+            Log.e(TAG, ourExceptionText);
+            throw new Exception(ourExceptionText);
+        }
+        byte ret[] = null;
+            try {
+            ret = ourInputStream.readByteArray(desiredBitLength);
+            Log.d(TAG, "mmsVirginGetMsgId user_length = " + i1 + " msgid = " + aMessageRef[0]);
+                Log.d(TAG, "mmsVirginGetMsgId userdata = " + ret.toString());
+            } catch (com.android.internal.util.BitwiseInputStream.AccessException ourException) {
+                final String ourExceptionText = "mmsVirginGetMsgId failed: " + ourException;
+                Log.e(TAG, ourExceptionText);
+                throw new Exception(ourExceptionText);
+            }
+            return ret;
+    }
+
+   /**
      * Processes inbound messages that are in the WAP-WDP PDU format. See
      * wap-259-wdp-20010614-a section 6.5 for details on the WAP-WDP PDU format.
      * WDP segments are gathered until a datagram completes and gets dispatched.
diff --git a/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java b/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
old mode 100644
new mode 100755
index 2cad6cc..2e9a72c
--- a/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
+++ b/telephony/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java
@@ -146,6 +146,8 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
     private ContentResolver cr;
     private String currentCarrier = null;
 
+    private boolean mIsSamsungCdma = SystemProperties.getBoolean("ro.ril.samsung_cdma", false);
+
     private ContentObserver mAutoTimeObserver = new ContentObserver(new Handler()) {
         @Override
         public void onChange(boolean selfChange) {
@@ -364,14 +366,25 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
 
                 if (states.length > 9) {
                     try {
+                        // Samsung CDMA devices provide following states
+                        // in hex format as opposed to dec
                         if (states[4] != null) {
-                            baseStationId = Integer.parseInt(states[4]);
+                            if (mIsSamsungCdma)
+                                baseStationId = Integer.parseInt(states[4], 16);
+                            else
+                                baseStationId = Integer.parseInt(states[4]);
                         }
                         if (states[5] != null) {
-                            baseStationLatitude = Integer.parseInt(states[5]);
+                            if (mIsSamsungCdma)
+                                baseStationLatitude = Integer.parseInt(states[5], 16);
+                            else
+                                baseStationLatitude = Integer.parseInt(states[5]);
                         }
                         if (states[6] != null) {
-                            baseStationLongitude = Integer.parseInt(states[6]);
+                            if (mIsSamsungCdma)
+                                baseStationLongitude = Integer.parseInt(states[6], 16);
+                            else
+                                baseStationLongitude = Integer.parseInt(states[6]);
                         }
                         // Some carriers only return lat-lngs of 0,0
                         if (baseStationLatitude == 0 && baseStationLongitude == 0) {
@@ -410,7 +423,10 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
 
             if (ar.exception == null) {
                 String cdmaSubscription[] = (String[])ar.result;
-                if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
+
+                // Samsung CDMA devices have shorter cdmaSubscription parcel
+                int SUB_LENGTH = (mIsSamsungCdma) ? 4 : 5;
+                if (cdmaSubscription != null && cdmaSubscription.length >= SUB_LENGTH) {
                     mMdn = cdmaSubscription[0];
                     if (cdmaSubscription[1] != null) {
                         String[] sid = cdmaSubscription[1].split(",");
@@ -438,7 +454,14 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
                     }
                     Log.d(LOG_TAG,"GET_CDMA_SUBSCRIPTION NID=" + cdmaSubscription[2] );
                     mMin = cdmaSubscription[3];
-                    mPrlVersion = cdmaSubscription[4];
+                    // Samsung CDMA devices' prl is not found in this parcel
+                    // instead, extract it from system properties
+                    if (mIsSamsungCdma) {
+                        String[] prl = (SystemProperties.get("ril.prl_ver_1").split(":"));
+                        mPrlVersion = prl[1];
+                    } else {
+                        mPrlVersion = cdmaSubscription[4];
+                    }
                     Log.d(LOG_TAG,"GET_CDMA_SUBSCRIPTION MDN=" + mMdn);
                     //Notify apps subscription info is ready
                     if (cdmaForSubscriptionInfoReadyRegistrants != null) {
@@ -552,32 +575,53 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
     }
 
     @Override
-    protected void powerOffRadioSafely(){
-        // clean data connection
+    protected void powerOffRadioSafely() {
         DataConnectionTracker dcTracker = phone.mDataConnection;
 
         Message msg = dcTracker.obtainMessage(DataConnectionTracker.EVENT_CLEAN_UP_CONNECTION);
-        msg.arg1 = 1; // tearDown is true
         msg.obj = CDMAPhone.REASON_RADIO_TURNED_OFF;
-        dcTracker.sendMessage(msg);
 
-        synchronized(this) {
-            if (!mPendingRadioPowerOffAfterDataOff) {
-                DataConnectionTracker.State currentState = dcTracker.getState();
-                if (currentState != DataConnectionTracker.State.CONNECTED
-                        && currentState != DataConnectionTracker.State.DISCONNECTING
-                        && currentState != DataConnectionTracker.State.INITING) {
-                    if (DBG) log("Data disconnected, turn off radio right away.");
-                    hangupAndPowerOff();
-                }
-                else if (sendEmptyMessageDelayed(EVENT_SET_RADIO_POWER_OFF, 30000)) {
-                    if (DBG) {
-                        log("Wait up to 30 sec for data to disconnect, then turn off radio.");
+        synchronized (this) {
+            if (networkType == ServiceState.RADIO_TECHNOLOGY_1xRTT) {
+                /*
+                 * In 1x CDMA , during radio power off modem will disconnect the
+                 * data call and sends the power down registration message along
+                 * with the data call release message to the network
+                 */
+
+                msg.arg1 = 0; // tearDown is false since modem does it anyway for 1X
+                dcTracker.sendMessage(msg);
+
+                Log.w(LOG_TAG, "Turn off the radio right away");
+                hangupAndPowerOff();
+            } else {
+                if (!mPendingRadioPowerOffAfterDataOff) {
+                    DataConnectionTracker.State currentState = dcTracker.getState();
+                    if (currentState != DataConnectionTracker.State.CONNECTED
+                            && currentState != DataConnectionTracker.State.DISCONNECTING
+                            && currentState != DataConnectionTracker.State.INITING) {
+
+                        msg.arg1 = 0; // tearDown is false as it is not needed.
+                        dcTracker.sendMessage(msg);
+
+                        if (DBG)
+                            log("Data disconnected, turn off radio right away.");
+                        hangupAndPowerOff();
+                    } else {
+                        // clean data connection
+                        msg.arg1 = 1; // tearDown is true
+                        dcTracker.sendMessage(msg);
+
+                        if (sendEmptyMessageDelayed(EVENT_SET_RADIO_POWER_OFF, 30000)) {
+                            if (DBG) {
+                                log("Wait upto 30s for data to disconnect, then turn off radio.");
+                            }
+                            mPendingRadioPowerOffAfterDataOff = true;
+                        } else {
+                            Log.w(LOG_TAG, "Cannot send delayed Msg, turn off radio right away.");
+                            hangupAndPowerOff();
+                        }
                     }
-                    mPendingRadioPowerOffAfterDataOff = true;
-                } else {
-                    Log.w(LOG_TAG, "Cannot send delayed Msg, turn off radio right away.");
-                    hangupAndPowerOff();
                 }
             }
         }
@@ -623,6 +667,17 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
     }
 
     /**
+     * Multi-mode radio indication facilitator
+     */
+    public boolean isMultiModeRadio() {
+        // If the device you seek to make work here has a multi-mode radio, for example
+        // a "world" CDMA/GSM/UMTS radio, this function is here to facilitate alternate
+        // code paths in some events.
+        return SystemProperties.get("ro.telephony.ril_class").equalsIgnoreCase("mototegraworld");
+    }
+
+
+    /**
      * Handle the result of one of the pollState()-related requests
      */
 
@@ -679,7 +734,12 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
                 int defaultRoamingIndicator = 0;  //[12] Is default roaming indicator from PRL
                 int reasonForDenial = 0;       //[13] Denial reason if registrationState = 3
 
-                if (states.length == 14) {
+                // in some rare cases, such as a CDMA/GSM/UMTS radio, the states array will
+                // contain 15 arguments, differring from the usual 14 contained in CDMA
+                // states packets.
+                boolean multiModeRadio = isMultiModeRadio();
+
+                if (states.length == 14 || (multiModeRadio && states.length == 15 )) {
                     try {
                         if (states[0] != null) {
                             registrationState = Integer.parseInt(states[0]);
@@ -687,14 +747,25 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
                         if (states[3] != null) {
                             radioTechnology = Integer.parseInt(states[3]);
                         }
+                        // Samsung CDMA devices provide following states
+                        // in hex format as opposed to dec
                         if (states[4] != null) {
-                            baseStationId = Integer.parseInt(states[4]);
+                            if (mIsSamsungCdma)
+                                baseStationId = Integer.parseInt(states[4], 16);
+                            else
+                                baseStationId = Integer.parseInt(states[4]);
                         }
                         if (states[5] != null) {
-                            baseStationLatitude = Integer.parseInt(states[5]);
+                            if (mIsSamsungCdma)
+                                baseStationLatitude = Integer.parseInt(states[5], 16);
+                            else
+                                baseStationLatitude = Integer.parseInt(states[5]);
                         }
                         if (states[6] != null) {
-                            baseStationLongitude = Integer.parseInt(states[6]);
+                            if (mIsSamsungCdma)
+                                baseStationLongitude = Integer.parseInt(states[6], 16);
+                            else
+                                baseStationLongitude = Integer.parseInt(states[6]);
                         }
                         // Some carriers only return lat-lngs of 0,0
                         if (baseStationLatitude == 0 && baseStationLongitude == 0) {
@@ -722,13 +793,18 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
                         if (states[13] != null) {
                             reasonForDenial = Integer.parseInt(states[13]);
                         }
+                        if((states.length == 15) && (states[14] != null) && multiModeRadio) {
+                            Log.w(LOG_TAG, "Multi-Mode RIL detected - Extraneous value: "
+                                  + states[14]);
+                        }
                     } catch (NumberFormatException ex) {
                         Log.w(LOG_TAG, "error parsing RegistrationState: " + ex);
                     }
                 } else {
                     throw new RuntimeException("Warning! Wrong number of parameters returned from "
-                                         + "RIL_REQUEST_REGISTRATION_STATE: expected 14 got "
-                                         + states.length);
+                                         + "RIL_REQUEST_REGISTRATION_STATE: expected "
+                                         + (multiModeRadio ? "15" : "14")
+                                         + ", got " + states.length);
                 }
 
                 mRegistrationState = registrationState;
@@ -1149,6 +1225,17 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
     }
 
     private TimeZone findTimeZone(int offset, boolean dst, long when) {
+        /**
+         * http://wtogami.blogspot.com/2012/01/hawaii-android-automatic-time-zone-bug.html
+         * NITZ UTC-10 without DST can only be Hawaii
+         * Impossible to differentiate America/Adak from Honolulu/Pacific
+         * from NITZ alone.
+         **/
+        if (offset == -36000000 && dst == false) {
+            Log.d(LOG_TAG, "findTimeZone() Forcing Hawaii Timezone for UTC-10");
+            return TimeZone.getTimeZone("Pacific/Honolulu");
+        }
+
         int rawOffset = offset;
         if (dst) {
             rawOffset -= 3600000;
@@ -1205,7 +1292,16 @@ final class CdmaServiceStateTracker extends ServiceStateTracker {
         } else {
             int[] ints = (int[])ar.result;
             int offset = 2;
-            int cdmaDbm = (ints[offset] > 0) ? -ints[offset] : -120;
+
+            // Samsung CDMA devices only use cdmaDbm for signal strength
+            // parcel is different as well, pull cdmaDbm response correctly
+            // all other values are ignored
+            int cdmaDbm;
+            if (mIsSamsungCdma)
+                cdmaDbm = (ints[0] > 0 ) ? -ints[0] : -120;
+            else
+                cdmaDbm = (ints[offset] > 0) ? -ints[offset] : -120;
+
             int cdmaEcio = (ints[offset+1] > 0) ? -ints[offset+1] : -160;
             int evdoRssi = (ints[offset+2] > 0) ? -ints[offset+2] : -120;
             int evdoEcio = (ints[offset+3] > 0) ? -ints[offset+3] : -1;
diff --git a/telephony/java/com/android/internal/telephony/cdma/RuimPhoneBookInterfaceManager.java b/telephony/java/com/android/internal/telephony/cdma/RuimPhoneBookInterfaceManager.java
index 6e12f24..dd1efdf 100644
--- a/telephony/java/com/android/internal/telephony/cdma/RuimPhoneBookInterfaceManager.java
+++ b/telephony/java/com/android/internal/telephony/cdma/RuimPhoneBookInterfaceManager.java
@@ -16,6 +16,8 @@
 
 package com.android.internal.telephony.cdma;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import android.os.Message;
 import android.util.Log;
 
@@ -56,14 +58,11 @@ public class RuimPhoneBookInterfaceManager extends IccPhoneBookInterfaceManager
             recordSize = new int[3];
 
             //Using mBaseHandler, no difference in EVENT_GET_SIZE_DONE handling
-            Message response = mBaseHandler.obtainMessage(EVENT_GET_SIZE_DONE);
+            AtomicBoolean status = new AtomicBoolean(false);
+            Message response = mBaseHandler.obtainMessage(EVENT_GET_SIZE_DONE, status);
 
             phone.getIccFileHandler().getEFLinearRecordSize(efid, response);
-            try {
-                mLock.wait();
-            } catch (InterruptedException e) {
-                logd("interrupted while trying to load from the RUIM");
-            }
+            waitForResult(status);
         }
 
         return recordSize;
diff --git a/telephony/java/com/android/internal/telephony/cdma/RuimRecords.java b/telephony/java/com/android/internal/telephony/cdma/RuimRecords.java
old mode 100644
new mode 100755
index 87b0c60..93a8e9d
--- a/telephony/java/com/android/internal/telephony/cdma/RuimRecords.java
+++ b/telephony/java/com/android/internal/telephony/cdma/RuimRecords.java
@@ -16,10 +16,13 @@
 
 package com.android.internal.telephony.cdma;
 
+import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY;
+import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC;
 import android.os.AsyncResult;
 import android.os.Handler;
 import android.os.Message;
 import android.os.Registrant;
+import android.os.SystemProperties;
 import android.util.Log;
 
 import com.android.internal.telephony.AdnRecord;
@@ -59,6 +62,7 @@ public final class RuimRecords extends IccRecords {
 
     private static final int EVENT_RUIM_READY = 1;
     private static final int EVENT_RADIO_OFF_OR_NOT_AVAILABLE = 2;
+    private static final int EVENT_GET_IMSI_DONE = 3;
     private static final int EVENT_GET_DEVICE_IDENTITY_DONE = 4;
     private static final int EVENT_GET_ICCID_DONE = 5;
     private static final int EVENT_GET_CDMA_SUBSCRIPTION_DONE = 10;
@@ -201,6 +205,33 @@ public final class RuimRecords extends IccRecords {
             break;
 
             /* IO events */
+            case EVENT_GET_IMSI_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+                if (ar.exception != null) {
+                    Log.e(LOG_TAG, "Exception querying IMSI, Exception:" + ar.exception);
+                    break;
+                }
+
+                mImsi = (String) ar.result;
+
+                // IMSI (MCC+MNC+MSIN) is at least 6 digits, but not more
+                // than 15 (and usually 15).
+                if (mImsi != null && (mImsi.length() < 6 || mImsi.length() > 15)) {
+                    Log.e(LOG_TAG, "invalid IMSI " + mImsi);
+                    mImsi = null;
+                }
+
+                Log.d(LOG_TAG, "IMSI: " + mImsi.substring(0, 6) + "xxxxxxxxx");
+
+                String operatorNumeric = getRUIMOperatorNumeric();
+                if (operatorNumeric != null) {
+                    if(operatorNumeric.length() <= 6){
+                        MccTable.updateMccMncConfiguration(phone, operatorNumeric);
+                    }
+                }
+            break;
 
             case EVENT_GET_CDMA_SUBSCRIPTION_DONE:
                 ar = (AsyncResult)msg.obj;
@@ -291,6 +322,16 @@ public final class RuimRecords extends IccRecords {
 
         // Further records that can be inserted are Operator/OEM dependent
 
+        String operator = getRUIMOperatorNumeric();
+
+        if (operator != null) {
+            SystemProperties.set(PROPERTY_ICC_OPERATOR_NUMERIC, operator);
+        }
+
+        if (mImsi != null) {
+            SystemProperties.set(PROPERTY_ICC_OPERATOR_ISO_COUNTRY,
+                    MccTable.countryCodeForMcc(Integer.parseInt(mImsi.substring(0,3))));
+        }
         recordsLoadedRegistrants.notifyRegistrants(
             new AsyncResult(null, null, null));
         ((CDMAPhone) phone).mRuimCard.broadcastIccStateChangedIntent(
@@ -317,6 +358,9 @@ public final class RuimRecords extends IccRecords {
 
         Log.v(LOG_TAG, "RuimRecords:fetchRuimRecords " + recordsToLoad);
 
+        phone.mCM.getIMSI(obtainMessage(EVENT_GET_IMSI_DONE));
+        recordsToLoad++;
+
         phone.getIccFileHandler().loadEFTransparent(EF_ICCID,
                 obtainMessage(EVENT_GET_ICCID_DONE));
         recordsToLoad++;
diff --git a/telephony/java/com/android/internal/telephony/cdma/SmsMessage.java b/telephony/java/com/android/internal/telephony/cdma/SmsMessage.java
old mode 100755
new mode 100644
index a1f20f8..676a828
--- a/telephony/java/com/android/internal/telephony/cdma/SmsMessage.java
+++ b/telephony/java/com/android/internal/telephony/cdma/SmsMessage.java
@@ -30,8 +30,10 @@ import com.android.internal.telephony.SmsMessageBase;
 import com.android.internal.telephony.TelephonyProperties;
 import com.android.internal.telephony.cdma.sms.BearerData;
 import com.android.internal.telephony.cdma.sms.CdmaSmsAddress;
+import com.android.internal.telephony.cdma.sms.CdmaSmsSubaddress;
 import com.android.internal.telephony.cdma.sms.SmsEnvelope;
 import com.android.internal.telephony.cdma.sms.UserData;
+import com.android.internal.util.BitwiseInputStream;
 import com.android.internal.util.HexDump;
 
 import java.io.BufferedInputStream;
@@ -72,6 +74,16 @@ public class SmsMessage extends SmsMessageBase {
     static final String LOG_TAG = "CDMA";
     static private final String LOGGABLE_TAG = "CDMA:SMS";
 
+    private final static byte TELESERVICE_IDENTIFIER                    = 0x00;
+    private final static byte SERVICE_CATEGORY                          = 0x01;
+    private final static byte ORIGINATING_ADDRESS                       = 0x02;
+    private final static byte ORIGINATING_SUB_ADDRESS                   = 0x03;
+    private final static byte DESTINATION_ADDRESS                       = 0x04;
+    private final static byte DESTINATION_SUB_ADDRESS                   = 0x05;
+    private final static byte BEARER_REPLY_OPTION                       = 0x06;
+    private final static byte CAUSE_CODES                               = 0x07;
+    private final static byte BEARER_DATA                               = 0x08;
+
     /**
      *  Status of a previously submitted SMS.
      *  This field applies to SMS Delivery Acknowledge messages. 0 indicates success;
@@ -139,6 +151,7 @@ public class SmsMessage extends SmsMessageBase {
         SmsMessage msg = new SmsMessage();
         SmsEnvelope env = new SmsEnvelope();
         CdmaSmsAddress addr = new CdmaSmsAddress();
+        CdmaSmsSubaddress subaddr = new CdmaSmsSubaddress();
         byte[] data;
         byte count;
         int countInt;
@@ -181,15 +194,24 @@ public class SmsMessage extends SmsMessageBase {
 
         addr.origBytes = data;
 
-        // ignore subaddress
-        p.readInt(); //p_cur->sSubAddress.subaddressType
-        p.readInt(); //p_cur->sSubAddress.odd
-        count = p.readByte(); //p_cur->sSubAddress.number_of_digits
-        //p_cur->sSubAddress.digits[digitCount] :
-        for (int index=0; index < count; index++) {
-            p.readByte();
+        subaddr.type = p.readInt(); // p_cur->sSubAddress.subaddressType
+        subaddr.odd = p.readByte();     // p_cur->sSubAddress.odd
+        count = p.readByte();           // p_cur->sSubAddress.number_of_digits
+
+        if (count < 0) {
+            count = 0;
+        }
+
+        // p_cur->sSubAddress.digits[digitCount] :
+
+        data = new byte[count];
+
+        for (int index = 0; index < count; ++index) {
+            data[index] = p.readByte();
         }
 
+        subaddr.origBytes = data;
+
         /* currently not supported by the modem-lib:
             env.bearerReply
             env.replySeqNo
@@ -211,6 +233,7 @@ public class SmsMessage extends SmsMessageBase {
 
         // link the the filled objects to the SMS
         env.origAddress = addr;
+        env.origSubaddress = subaddr;
         msg.originatingAddress = addr;
         msg.mEnvelope = env;
 
@@ -256,6 +279,7 @@ public class SmsMessage extends SmsMessageBase {
             System.arraycopy(data, 2, pdu, 0, size);
             // the message has to be parsed before it can be displayed
             // see gsm.SmsMessage
+            msg.parsePduFromEfRecord(pdu);
             return msg;
         } catch (RuntimeException ex) {
             Log.e(LOG_TAG, "SMS PDU parsing failed: ", ex);
@@ -528,6 +552,143 @@ public class SmsMessage extends SmsMessageBase {
     }
 
     /**
+     * Decodes 3GPP2 sms stored in CSIM/RUIM cards As per 3GPP2 C.S0015-0
+     */
+    private void parsePduFromEfRecord(byte[] pdu) {
+        ByteArrayInputStream bais = new ByteArrayInputStream(pdu);
+        DataInputStream dis = new DataInputStream(bais);
+        SmsEnvelope env = new SmsEnvelope();
+        CdmaSmsAddress addr = new CdmaSmsAddress();
+        CdmaSmsSubaddress subAddr = new CdmaSmsSubaddress();
+
+        try {
+            env.messageType = dis.readByte();
+
+            while (dis.available() > 0) {
+                int parameterId = dis.readByte();
+                int parameterLen = dis.readByte();
+                byte[] parameterData = new byte[parameterLen];
+
+                switch (parameterId) {
+                    case TELESERVICE_IDENTIFIER:
+                        /*
+                         * 16 bit parameter that identifies which upper layer
+                         * service access point is sending or should receive
+                         * this message
+                         */
+                        env.teleService = dis.readUnsignedShort();
+                        Log.i(LOG_TAG, "teleservice = " + env.teleService);
+                        break;
+                    case SERVICE_CATEGORY:
+                        /*
+                         * 16 bit parameter that identifies type of service as
+                         * in 3GPP2 C.S0015-0 Table 3.4.3.2-1
+                         */
+                        env.serviceCategory = dis.readUnsignedShort();
+                        break;
+                    case ORIGINATING_ADDRESS:
+                    case DESTINATION_ADDRESS:
+                        dis.read(parameterData, 0, parameterLen);
+                        BitwiseInputStream addrBis = new BitwiseInputStream(parameterData);
+                        addr.digitMode = addrBis.read(1);
+                        addr.numberMode = addrBis.read(1);
+                        int numberType = 0;
+                        if (addr.digitMode == CdmaSmsAddress.DIGIT_MODE_8BIT_CHAR) {
+                            numberType = addrBis.read(3);
+                            addr.ton = numberType;
+
+                            if (addr.numberMode == CdmaSmsAddress.NUMBER_MODE_NOT_DATA_NETWORK)
+                                addr.numberPlan = addrBis.read(4);
+                        }
+
+                        addr.numberOfDigits = addrBis.read(8);
+
+                        byte[] data = new byte[addr.numberOfDigits];
+                        byte b = 0x00;
+
+                        if (addr.digitMode == CdmaSmsAddress.DIGIT_MODE_4BIT_DTMF) {
+                            /* As per 3GPP2 C.S0005-0 Table 2.7.1.3.2.4-4 */
+                            for (int index = 0; index < addr.numberOfDigits; index++) {
+                                b = (byte) (0xF & addrBis.read(4));
+                                // convert the value if it is 4-bit DTMF to 8
+                                // bit
+                                data[index] = convertDtmfToAscii(b);
+                            }
+                        } else if (addr.digitMode == CdmaSmsAddress.DIGIT_MODE_8BIT_CHAR) {
+                            if (addr.numberMode == CdmaSmsAddress.NUMBER_MODE_NOT_DATA_NETWORK) {
+                                for (int index = 0; index < addr.numberOfDigits; index++) {
+                                    b = (byte) (0xFF & addrBis.read(8));
+                                    data[index] = b;
+                                }
+
+                            } else if (addr.numberMode == CdmaSmsAddress.NUMBER_MODE_DATA_NETWORK) {
+                                if (numberType == 2)
+                                    Log.e(LOG_TAG, "TODO: Originating Addr is email id");
+                                else
+                                    Log.e(LOG_TAG,
+                                          "TODO: Originating Addr is data network address");
+                            } else {
+                                Log.e(LOG_TAG, "Originating Addr is of incorrect type");
+                            }
+                        } else {
+                            Log.e(LOG_TAG, "Incorrect Digit mode");
+                        }
+                        addr.origBytes = data;
+                        Log.i(LOG_TAG, "Originating Addr=" + addr.toString());
+                        break;
+                    case ORIGINATING_SUB_ADDRESS:
+                    case DESTINATION_SUB_ADDRESS:
+                        dis.read(parameterData, 0, parameterLen);
+                        BitwiseInputStream subAddrBis = new BitwiseInputStream(parameterData);
+                        subAddr.type = subAddrBis.read(3);
+                        subAddr.odd = subAddrBis.readByteArray(1)[0];
+                        int subAddrLen = subAddrBis.read(8);
+                        byte[] subdata = new byte[subAddrLen];
+                        for (int index = 0; index < subAddrLen; index++) {
+                            b = (byte) (0xFF & subAddrBis.read(4));
+                            // convert the value if it is 4-bit DTMF to 8 bit
+                            subdata[index] = convertDtmfToAscii(b);
+                        }
+                        subAddr.origBytes = subdata;
+                        break;
+                    case BEARER_REPLY_OPTION:
+                        dis.read(parameterData, 0, parameterLen);
+                        BitwiseInputStream replyOptBis = new BitwiseInputStream(parameterData);
+                        env.bearerReply = replyOptBis.read(6);
+                        break;
+                    case CAUSE_CODES:
+                        dis.read(parameterData, 0, parameterLen);
+                        BitwiseInputStream ccBis = new BitwiseInputStream(parameterData);
+                        env.replySeqNo = ccBis.readByteArray(6)[0];
+                        env.errorClass = ccBis.readByteArray(2)[0];
+                        if (env.errorClass != 0x00)
+                            env.causeCode = ccBis.readByteArray(8)[0];
+                        break;
+                    case BEARER_DATA:
+                        dis.read(parameterData, 0, parameterLen);
+                        env.bearerData = parameterData;
+                        break;
+                    default:
+                        throw new Exception("unsupported parameterId (" + parameterId + ")");
+                }
+            }
+            bais.close();
+            dis.close();
+        } catch (Exception ex) {
+            Log.e(LOG_TAG, "parsePduFromEfRecord: conversion from pdu to SmsMessage failed" + ex);
+        }
+
+        // link the filled objects to this SMS
+        originatingAddress = addr;
+        env.origAddress = addr;
+        env.origSubaddress = subAddr;
+        mEnvelope = env;
+        mPdu = pdu;
+
+        parseSms();
+    }
+
+    /**
      * Parses a SMS message from its BearerData stream. (mobile-terminated only)
      */
     protected void parseSms() {
@@ -824,6 +985,8 @@ public class SmsMessage extends SmsMessageBase {
         output.write(mEnvelope.teleService);
         output.write(mEnvelope.origAddress.origBytes, 0, mEnvelope.origAddress.origBytes.length);
         output.write(mEnvelope.bearerData, 0, mEnvelope.bearerData.length);
+        output.write(mEnvelope.origSubaddress.origBytes, 0,
+                mEnvelope.origSubaddress.origBytes.length);
 
         return output.toByteArray();
     }
diff --git a/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java b/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java
index 5b21ec1..9f55fb7b 100755
--- a/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java
+++ b/telephony/java/com/android/internal/telephony/cdma/sms/BearerData.java
@@ -20,6 +20,8 @@ import static android.telephony.SmsMessage.ENCODING_16BIT;
 import static android.telephony.SmsMessage.MAX_USER_DATA_BYTES;
 import static android.telephony.SmsMessage.MAX_USER_DATA_BYTES_WITH_HEADER;
 
+import android.os.SystemProperties;
+
 import android.util.Log;
 
 import android.telephony.SmsMessage;
@@ -585,7 +587,6 @@ public final class BearerData {
                     uData.payload = new byte[0];
                     uData.numFields = 0;
                 } else {
-                    uData.payload = uData.payload;
                     uData.numFields = uData.payload.length;
                 }
             } else {
@@ -877,10 +878,19 @@ public final class BearerData {
             paramBits -= EXPECTED_PARAM_SIZE;
             decodeSuccess = true;
             bData.messageType = inStream.read(4);
-            bData.messageId = inStream.read(8) << 8;
-            bData.messageId |= inStream.read(8);
-            bData.hasUserDataHeader = (inStream.read(1) == 1);
-            inStream.skip(3);
+            // Samsung Fascinate parses messageId differently than other devices
+            // fix it here so that incoming sms works correctly
+            if ("fascinatemtd".equals(SystemProperties.get("ro.cm.device"))) {
+                inStream.skip(4);
+                bData.messageId = inStream.read(8) << 8;
+                bData.messageId |= inStream.read(8);
+                bData.hasUserDataHeader = (inStream.read(8) == 1);
+            } else {
+                bData.messageId = inStream.read(8) << 8;
+                bData.messageId |= inStream.read(8);
+                bData.hasUserDataHeader = (inStream.read(1) == 1);
+                inStream.skip(3);
+            }
         }
         if ((! decodeSuccess) || (paramBits > 0)) {
             Log.d(LOG_TAG, "MESSAGE_IDENTIFIER decode " +
diff --git a/telephony/java/com/android/internal/telephony/cdma/sms/CdmaSmsSubaddress.java b/telephony/java/com/android/internal/telephony/cdma/sms/CdmaSmsSubaddress.java
new file mode 100644
index 0000000..f9cebf5
--- /dev/null
+++ b/telephony/java/com/android/internal/telephony/cdma/sms/CdmaSmsSubaddress.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project. All rights reserved.
+ * Copyright (C) 2010 Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.telephony.cdma.sms;
+
+public class CdmaSmsSubaddress {
+    public int type;
+
+    public byte odd;
+
+    public byte[] origBytes;
+}
+
diff --git a/telephony/java/com/android/internal/telephony/cdma/sms/SmsEnvelope.java b/telephony/java/com/android/internal/telephony/cdma/sms/SmsEnvelope.java
index 0dcacc1..4f00163 100644
--- a/telephony/java/com/android/internal/telephony/cdma/sms/SmsEnvelope.java
+++ b/telephony/java/com/android/internal/telephony/cdma/sms/SmsEnvelope.java
@@ -17,6 +17,8 @@
 package com.android.internal.telephony.cdma.sms;
 
 
+import com.android.internal.telephony.cdma.sms.CdmaSmsSubaddress;
+
 public final class SmsEnvelope{
     /**
      * Message Types
@@ -74,17 +76,23 @@ public final class SmsEnvelope{
 
     /**
      * The origination address identifies the originator of the SMS message.
-     * (See 3GPP2 C.S0015-B, v2, 3.4.3.4)
+     * (See 3GPP2 C.S0015-B, v2, 3.4.3.3)
      */
     public CdmaSmsAddress origAddress;
 
     /**
      * The destination address identifies the target of the SMS message.
-     * (See 3GPP2 C.S0015-B, v2, 3.4.3.4)
+     * (See 3GPP2 C.S0015-B, v2, 3.4.3.3)
      */
     public CdmaSmsAddress destAddress;
 
     /**
+     * The origination subaddress identifies the originator of the SMS message.
+     * (See 3GPP2 C.S0015-B, v2, 3.4.3.4)
+     */
+    public CdmaSmsSubaddress origSubaddress;
+
+    /**
      * The 6-bit bearer reply parameter is used to request the return of a
      * SMS Acknowledge Message.
      * (See 3GPP2 C.S0015-B, v2, 3.4.3.5)
diff --git a/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java b/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java
index f128f5b..d0003a6 100644
--- a/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/telephony/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -968,7 +968,9 @@ public class GSMPhone extends PhoneBase {
     }
 
     public void getCallWaiting(Message onComplete) {
-        mCM.queryCallWaiting(CommandsInterface.SERVICE_CLASS_VOICE, onComplete);
+        // As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service
+        // class parameter in call waiting interrogation to network
+        mCM.queryCallWaiting(CommandsInterface.SERVICE_CLASS_NONE, onComplete);
     }
 
     public void setCallWaiting(boolean enable, Message onComplete) {
@@ -1498,4 +1500,8 @@ public class GSMPhone extends PhoneBase {
         Log.e(LOG_TAG, "[GSMPhone] setCellBroadcastSmsConfig() is obsolete; use SmsManager");
         response.sendToTarget();
     }
+
+    public boolean isCspPlmnEnabled() {
+        return mSIMRecords.isCspPlmnEnabled();
+    }
 }
diff --git a/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java b/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
index 96005f0..bf72c38 100644
--- a/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
+++ b/telephony/java/com/android/internal/telephony/gsm/GsmDataConnectionTracker.java
@@ -446,9 +446,10 @@ public final class GsmDataConnectionTracker extends DataConnectionTracker {
         boolean desiredPowerState = mGsmPhone.mSST.getDesiredPowerState();
 
         if ((state == State.IDLE || state == State.SCANNING)
-                && (gprsState == ServiceState.STATE_IN_SERVICE || noAutoAttach)
+                && (gprsState == ServiceState.STATE_IN_SERVICE || !noAutoAttach)
                 && mGsmPhone.mSIMRecords.getRecordsLoaded()
-                && phone.getState() == Phone.State.IDLE
+                && (mGsmPhone.mSST.isConcurrentVoiceAndData() ||
+                        phone.getState() == Phone.State.IDLE )
                 && isDataAllowed()
                 && !mIsPsRestricted
                 && desiredPowerState ) {
diff --git a/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java b/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
index 6ddb312..00b8441 100644
--- a/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
+++ b/telephony/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
@@ -140,6 +140,8 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
      */
     private Notification mNotification;
 
+    private Context mUiContext;
+
     /** Wake lock used while setting time of day. */
     private PowerManager.WakeLock mWakeLock;
     private static final String WAKELOCK_TAG = "ServiceStateTracker";
@@ -176,6 +178,12 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         }
     };
 
+    private BroadcastReceiver mThemeChangeReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            mUiContext = null;
+        }
+    };
+
     private ContentObserver mAutoTimeObserver = new ContentObserver(new Handler()) {
         @Override
         public void onChange(boolean selfChange) {
@@ -226,6 +234,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_LOCALE_CHANGED);
         phone.getContext().registerReceiver(mIntentReceiver, filter);
+
     }
 
     public void dispose() {
@@ -582,9 +591,11 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
     }
 
     protected void updateSpnDisplay() {
-        int rule = phone.mSIMRecords.getDisplayRule(ss.getOperatorNumeric());
+        // getServiceProviderName() will trigger SPN locale update.
         String spn = phone.mSIMRecords.getServiceProviderName();
         String plmn = ss.getOperatorAlphaLong();
+        // getDisplayRule() should be done after getting SPN updated.
+        int rule = phone.mSIMRecords.getDisplayRule(ss.getOperatorNumeric());
 
         // For emergency calls only, pass the EmergencyCallsOnly string via EXTRA_PLMN
         if (mEmergencyOnly && cm.getRadioState().isOn()) {
@@ -593,6 +604,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         }
 
         if (rule != curSpnRule
+                || plmn == null
                 || !TextUtils.equals(spn, curSpn)
                 || !TextUtils.equals(plmn, curPlmn)) {
             boolean showSpn = !mEmergencyOnly
@@ -855,6 +867,9 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
             case DATA_ACCESS_HSPA:
                 ret = "HSPA";
                 break;
+            case DATA_ACCESS_HSPAP:
+                ret = "HSPA+";
+                break;
             default:
                 Log.e(LOG_TAG, "Wrong network type: " + Integer.toString(type));
                 break;
@@ -945,8 +960,6 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         if (hasChanged) {
             String operatorNumeric;
 
-            updateSpnDisplay();
-
             phone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_ALPHA,
                 ss.getOperatorAlphaLong());
 
@@ -1012,7 +1025,12 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
             phone.setSystemProperty(TelephonyProperties.PROPERTY_OPERATOR_ISROAMING,
                 ss.getRoaming() ? "true" : "false");
 
+            updateSpnDisplay();
+
             phone.notifyServiceStateChanged(ss);
+
+        } else if (hasDeregistered) {
+            updateSpnDisplay();
         }
 
         if (hasGprsAttached) {
@@ -1084,6 +1102,17 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
     }
 
     private TimeZone findTimeZone(int offset, boolean dst, long when) {
+        /**
+         * http://wtogami.blogspot.com/2012/01/hawaii-android-automatic-time-zone-bug.html
+         * NITZ UTC-10 without DST can only be Hawaii
+         * Impossible to differentiate America/Adak from Honolulu/Pacific
+         * from NITZ alone.
+         **/
+        if (offset == -36000000 && dst == false) {
+            Log.d(LOG_TAG, "findTimeZone() Forcing Hawaii Timezone for UTC-10");
+            return TimeZone.getTimeZone("Pacific/Honolulu");
+        }
+
         int rawOffset = offset;
         if (dst) {
             rawOffset -= 3600000;
@@ -1298,7 +1327,14 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
      * @return true for roaming state set
      */
     private boolean isRoamingBetweenOperators(boolean gsmRoaming, ServiceState s) {
-        String spn = SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA, "empty");
+
+        boolean mvnoRoaming = Settings.System.getInt(
+                phone.getContext().getContentResolver(),
+                Settings.Secure.MVNO_ROAMING, 0) == 1;
+
+        String spn;
+
+        spn = SystemProperties.get(TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA, "empty");
 
         String onsl = s.getOperatorAlphaLong();
         String onss = s.getOperatorAlphaShort();
@@ -1317,7 +1353,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         } catch (Exception e){
         }
 
-        return gsmRoaming && !(equalsMcc && (equalsOnsl || equalsOnss));
+        return gsmRoaming && !(equalsMcc && (equalsOnsl || equalsOnss || mvnoRoaming));
     }
 
     private static int twoDigitsAt(String s, int offset) {
@@ -1334,6 +1370,11 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
         return a*10 + b;
     }
 
+    private Context getUiContext() {
+        Context mainContext = phone.getContext();
+        return mUiContext != null ? mUiContext : mainContext;
+    }
+
     /**
      * @return The current GPRS state. IN_SERVICE is the same as "attached"
      * and OUT_OF_SERVICE is the same as detached.
@@ -1651,7 +1692,7 @@ final class GsmServiceStateTracker extends ServiceStateTracker {
 
         Log.d(LOG_TAG, "[DSAC DEB] " + "put notification " + title + " / " +details);
         mNotification.tickerText = title;
-        mNotification.setLatestEventInfo(context, title, details,
+        mNotification.setLatestEventInfo(getUiContext(), title, details,
                 mNotification.contentIntent);
 
         NotificationManager notificationManager = (NotificationManager)
diff --git a/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java b/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java
index 206e62f..e8d10f9 100644
--- a/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SIMFileHandler.java
@@ -81,6 +81,7 @@ public final class SIMFileHandler extends IccFileHandler implements IccConstants
         case EF_SPN_CPHS:
         case EF_SPN_SHORT_CPHS:
         case EF_INFO_CPHS:
+        case EF_CSP_CPHS:
             return MF_SIM + DF_GSM;
 
         case EF_PBR:
diff --git a/telephony/java/com/android/internal/telephony/gsm/SIMRecords.java b/telephony/java/com/android/internal/telephony/gsm/SIMRecords.java
index e214061..3243339 100755
--- a/telephony/java/com/android/internal/telephony/gsm/SIMRecords.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SIMRecords.java
@@ -19,7 +19,6 @@ package com.android.internal.telephony.gsm;
 import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_ALPHA;
 import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_ISO_COUNTRY;
 import static com.android.internal.telephony.TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC;
-import android.content.Context;
 import android.os.AsyncResult;
 import android.os.Message;
 import android.os.SystemProperties;
@@ -37,6 +36,7 @@ import com.android.internal.telephony.IccVmNotSupportedException;
 import com.android.internal.telephony.MccTable;
 
 import java.util.ArrayList;
+import java.util.Locale;
 
 
 /**
@@ -56,6 +56,8 @@ public final class SIMRecords extends IccRecords {
 
     SpnOverride mSpnOverride;
 
+    Locale mCurrentLocale = null;
+
     // ***** Cached SIM State; cleared on channel close
 
     String imsi;
@@ -73,6 +75,7 @@ public final class SIMRecords extends IccRecords {
      *  mCphsInfo[1] and mCphsInfo[2] is CPHS Service Table
      */
     private byte[] mCphsInfo = null;
+    boolean mCspPlmnEnabled = true;
 
     byte[] efMWIS = null;
     byte[] efCPHS_MWI =null;
@@ -93,6 +96,7 @@ public final class SIMRecords extends IccRecords {
     static final int SPN_RULE_SHOW_PLMN = 0x02;
 
     // From TS 51.011 EF[SPDI] section
+    static final int TAG_SPDI = 0xA3;
     static final int TAG_SPDI_PLMN_LIST = 0x80;
 
     // Full Name IEI from TS 24.008
@@ -140,6 +144,7 @@ public final class SIMRecords extends IccRecords {
     private static final int EVENT_SET_MSISDN_DONE = 30;
     private static final int EVENT_SIM_REFRESH = 31;
     private static final int EVENT_GET_CFIS_DONE = 32;
+    private static final int EVENT_GET_CSP_CPHS_DONE = 33;
 
     // Lookup table for carriers known to produce SIMs which incorrectly indicate MNC length.
 
@@ -214,6 +219,9 @@ public final class SIMRecords extends IccRecords {
 
         adnCache.reset();
 
+        spn = null;
+        mCurrentLocale = null;
+
         phone.setSystemProperty(PROPERTY_ICC_OPERATOR_NUMERIC, null);
         phone.setSystemProperty(PROPERTY_ICC_OPERATOR_ALPHA, null);
         phone.setSystemProperty(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, null);
@@ -589,6 +597,13 @@ public final class SIMRecords extends IccRecords {
                 break;
             case EVENT_GET_CPHS_MAILBOX_DONE:
             case EVENT_GET_MBDN_DONE:
+                //Resetting the voice mail number and voice mail tag to null
+                //as these should be updated from the data read from EF_MBDN.
+                //If they are not reset, incase of invalid data/exception these
+                //variables are retaining their previous values and are
+                //causing invalid voice mailbox info display to user.
+                voiceMailNum = null;
+                voiceMailTag = null;
                 isRecordLoadResponse = true;
 
                 ar = (AsyncResult)msg.obj;
@@ -1035,6 +1050,22 @@ public final class SIMRecords extends IccRecords {
                 ((GSMPhone) phone).notifyCallForwardingIndicator();
                 break;
 
+            case EVENT_GET_CSP_CPHS_DONE:
+                isRecordLoadResponse = true;
+
+                ar = (AsyncResult)msg.obj;
+
+                if (ar.exception != null) {
+                    Log.e(LOG_TAG,"Exception in fetching EF_CSP data " + ar.exception);
+                    break;
+                }
+
+                data = (byte[])ar.result;
+
+                Log.i(LOG_TAG,"EF_CSP: " + IccUtils.bytesToHexString(data));
+                handleEfCspData(data);
+                break;
+
         }}catch (RuntimeException exc) {
             // I don't want these exceptions to be fatal
             Log.w(LOG_TAG, "Exception parsing SIM record", exc);
@@ -1058,6 +1089,12 @@ public final class SIMRecords extends IccRecords {
                 new AdnRecordLoader(phone).loadFromEF(EF_MAILBOX_CPHS, EF_EXT1,
                         1, obtainMessage(EVENT_GET_CPHS_MAILBOX_DONE));
                 break;
+            case EF_CSP_CPHS:
+                recordsToLoad++;
+                Log.i(LOG_TAG, "[CSP] SIM Refresh for EF_CSP_CPHS");
+                phone.getIccFileHandler().loadEFTransparent(EF_CSP_CPHS,
+                        obtainMessage(EVENT_GET_CSP_CPHS_DONE));
+                break;
             default:
                 // For now, fetch all records if this is not a
                 // voicemail number.
@@ -1200,11 +1237,30 @@ public final class SIMRecords extends IccRecords {
                 SimCard.INTENT_VALUE_ICC_LOADED, null);
     }
 
+    public String getServiceProviderName() {
+        setSpnFromConfig(getSIMOperatorNumeric());
+        return super.getServiceProviderName();
+    }
+
     //***** Private methods
 
     private void setSpnFromConfig(String carrier) {
-        if (mSpnOverride.containsCarrier(carrier)) {
-            spn = mSpnOverride.getSpn(carrier);
+        if (carrier == null) return;
+
+        Locale locale = phone.getContext().getResources().getConfiguration().locale;
+        locale = new Locale(locale.getLanguage(), locale.getCountry());
+
+        if ((mCurrentLocale == null || !mCurrentLocale.equals(locale))) {
+            if (mSpnOverride.containsCarrier(carrier) &&
+                    (spn = mSpnOverride.getSpn(carrier, locale)) == null &&
+                    (spn = mSpnOverride.getSpn(carrier)) == null &&
+                    "".equals(spn = SystemProperties.get(PROPERTY_ICC_OPERATOR_ALPHA))) {
+                spn = null;
+            }
+            if (spn != null && "".equals(spn)) {
+                spn = null;
+            }
+            mCurrentLocale = locale;
         }
     }
 
@@ -1288,6 +1344,9 @@ public final class SIMRecords extends IccRecords {
         iccFh.loadEFTransparent(EF_INFO_CPHS, obtainMessage(EVENT_GET_INFO_CPHS_DONE));
         recordsToLoad++;
 
+        iccFh.loadEFTransparent(EF_CSP_CPHS,obtainMessage(EVENT_GET_CSP_CPHS_DONE));
+        recordsToLoad++;
+
         // XXX should seek instead of examining them all
         if (false) { // XXX
             iccFh.loadEFLinearFixedAll(EF_SMS, obtainMessage(EVENT_GET_ALL_SMS_DONE));
@@ -1317,19 +1376,25 @@ public final class SIMRecords extends IccRecords {
      */
     protected int getDisplayRule(String plmn) {
         int rule;
-        if (spn == null || spnDisplayCondition == -1) {
-            // EF_SPN was not found on the SIM, or not yet loaded.  Just show ONS.
+        if (spn == null || spnDisplayCondition == -1 || plmn == null) {
+            // EF_SPN was not found on the SIM, or not yet loaded, or
+            // currently not registered to any PLMN. Just show ONS or
+            // the "(No service)" string.
             rule = SPN_RULE_SHOW_PLMN;
         } else if (isOnMatchingPlmn(plmn)) {
+            // registered PLMN is either HPLMN or a PLMN in the EF_SPDI list.
             rule = SPN_RULE_SHOW_SPN;
             if ((spnDisplayCondition & 0x01) == 0x01) {
-                // ONS required when registered to HPLMN or PLMN in EF_SPDI
+                // b1=0: ONS is not required
+                // b1=1: ONS is required
                 rule |= SPN_RULE_SHOW_PLMN;
             }
         } else {
+            // registered PLMN is neither HPLMN nor a PLMN in the EF_SPDI list.
             rule = SPN_RULE_SHOW_PLMN;
             if ((spnDisplayCondition & 0x02) == 0x00) {
-                // SPN required if not registered to HPLMN or PLMN in EF_SPDI
+                // b2=0: SPN is required
+                // b2=1: SPN is not required
                 rule |= SPN_RULE_SHOW_SPN;
             }
         }
@@ -1389,6 +1454,7 @@ public final class SIMRecords extends IccRecords {
         switch(spnState){
             case INIT:
                 spn = null;
+                mCurrentLocale = null;
 
                 phone.getIccFileHandler().loadEFTransparent( EF_SPN,
                         obtainMessage(EVENT_GET_SPN_DONE));
@@ -1467,8 +1533,12 @@ public final class SIMRecords extends IccRecords {
 
         byte[] plmnEntries = null;
 
-        // There should only be one TAG_SPDI_PLMN_LIST
         for ( ; tlv.isValidObject() ; tlv.nextObject()) {
+            // Skip SPDI tag, if existant
+            if (tlv.getTag() == TAG_SPDI) {
+              tlv = new SimTlv(tlv.getData(), 0, tlv.getData().length);
+            }
+            // There should only be one TAG_SPDI_PLMN_LIST
             if (tlv.getTag() == TAG_SPDI_PLMN_LIST) {
                 plmnEntries = tlv.getData();
                 break;
@@ -1505,4 +1575,53 @@ public final class SIMRecords extends IccRecords {
         Log.d(LOG_TAG, "[SIMRecords] " + s);
     }
 
+    /**
+     * Return true if "Restriction of menu options for manual PLMN selection"
+     * bit is set or EF_CSP data is unavailable, return false otherwise.
+     */
+    public boolean isCspPlmnEnabled() {
+        return mCspPlmnEnabled;
+    }
+
+    /**
+     * Parse EF_CSP data and check if
+     * "Restriction of menu options for manual PLMN selection" is
+     * Enabled/Disabled
+     *
+     * @param data EF_CSP hex data.
+     */
+    private void handleEfCspData(byte[] data) {
+        // As per spec CPHS4_2.WW6, CPHS B.4.7.1, EF_CSP contains CPHS defined
+        // 18 bytes (i.e 9 service groups info) and additional data specific to
+        // operator. The valueAddedServicesGroup is not part of standard
+        // services. This is operator specific and can be programmed any where.
+        // Normally this is programmed as 10th service after the standard
+        // services.
+        int usedCspGroups = data.length / 2;
+        // This is the "Servive Group Number" of "Value Added Services Group".
+        byte valueAddedServicesGroup = (byte)0xC0;
+
+        mCspPlmnEnabled = true;
+        for (int i = 0; i < usedCspGroups; i++) {
+             if (data[2 * i] == valueAddedServicesGroup) {
+                 Log.i(LOG_TAG, "[CSP] found ValueAddedServicesGroup, value "
+                       + data[(2 * i) + 1]);
+                 if ((data[(2 * i) + 1] & 0x80) == 0x80) {
+                     // Bit 8 is for
+                     // "Restriction of menu options for manual PLMN selection".
+                     // Operator Selection menu should be enabled.
+                     mCspPlmnEnabled = true;
+                 } else {
+                     mCspPlmnEnabled = false;
+                     // Operator Selection menu should be disabled.
+                     // Operator Selection Mode should be set to Automatic.
+                     Log.i(LOG_TAG,"[CSP] Set Automatic Network Selection");
+                     phone.setNetworkSelectionModeAutomatic(null);
+                 }
+                 return;
+             }
+        }
+
+        Log.w(LOG_TAG, "[CSP] Value Added Service Group (0xC0), not found!");
+    }
 }
diff --git a/telephony/java/com/android/internal/telephony/gsm/SimPhoneBookInterfaceManager.java b/telephony/java/com/android/internal/telephony/gsm/SimPhoneBookInterfaceManager.java
index feb508a..001e1bd 100644
--- a/telephony/java/com/android/internal/telephony/gsm/SimPhoneBookInterfaceManager.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SimPhoneBookInterfaceManager.java
@@ -16,6 +16,8 @@
 
 package com.android.internal.telephony.gsm;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import android.os.Message;
 import android.util.Log;
 
@@ -56,14 +58,11 @@ public class SimPhoneBookInterfaceManager extends IccPhoneBookInterfaceManager {
             recordSize = new int[3];
 
             //Using mBaseHandler, no difference in EVENT_GET_SIZE_DONE handling
-            Message response = mBaseHandler.obtainMessage(EVENT_GET_SIZE_DONE);
+            AtomicBoolean status = new AtomicBoolean(false);
+            Message response = mBaseHandler.obtainMessage(EVENT_GET_SIZE_DONE, status);
 
             phone.getIccFileHandler().getEFLinearRecordSize(efid, response);
-            try {
-                mLock.wait();
-            } catch (InterruptedException e) {
-                logd("interrupted while trying to load from the SIM");
-            }
+            waitForResult(status);
         }
 
         return recordSize;
diff --git a/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java b/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
index d16d426..f635890 100644
--- a/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
@@ -24,6 +24,7 @@ import android.util.Log;
 import com.android.internal.telephony.IccUtils;
 import com.android.internal.telephony.EncodeException;
 import com.android.internal.telephony.GsmAlphabet;
+import com.android.internal.telephony.SimRegionCache;
 import com.android.internal.telephony.SmsHeader;
 import com.android.internal.telephony.SmsMessageBase;
 
@@ -46,6 +47,12 @@ import static android.telephony.SmsMessage.MessageClass;
 public class SmsMessage extends SmsMessageBase{
     static final String LOG_TAG = "GSM";
 
+    /**
+     * Used with the ENCODING_ constants from {@link android.telephony.SmsMessage}
+     * Not a part of the public API, therefore not in order with those constants.
+     */
+    private static final int ENCODING_KSC5601 = 4000;
+
     private MessageClass messageClass;
 
     /**
@@ -317,8 +324,8 @@ public class SmsMessage extends SmsMessageBase{
                 return null;
             }
             // TP-Data-Coding-Scheme
-            // Class 3, UCS-2 encoding, uncompressed
-            bo.write(0x0b);
+            // UCS-2 encoding, uncompressed
+            bo.write(0x08);
         }
 
         // (no TP-Validity-Period)
@@ -730,6 +737,28 @@ public class SmsMessage extends SmsMessageBase{
             return ret;
         }
 
+        /**
+         * Interprets the user data payload as KSC5601 characters, and
+         * decodes them into a String
+         *
+         * @param byteCount the number of bytes in the user data payload
+         * @return a String with the decoded characters
+         */
+        String getUserDataKSC5601(int byteCount) {
+            String ret;
+
+            try {
+                ret = new String(pdu, cur, byteCount, "KSC5601");
+            } catch (UnsupportedEncodingException ex) {
+                // Should return same as ENCODING_UNKNOWN on error.
+                ret = null;
+                Log.e(LOG_TAG, "implausible UnsupportedEncodingException", ex);
+            }
+
+            cur += byteCount;
+            return ret;
+        }
+
         boolean moreDataPresent() {
             return (pdu.length > cur);
         }
@@ -867,6 +896,8 @@ public class SmsMessage extends SmsMessageBase{
         // TP-Message-Type-Indicator
         // 9.2.3
         case 0:
+        case 3: //GSM 03.40 9.2.3.1: MTI == 3 is Reserved.
+                //This should be processed in the same way as MTI == 0 (Deliver)
             parseSmsDeliver(p, firstByte);
             break;
         case 2:
@@ -996,7 +1027,12 @@ public class SmsMessage extends SmsMessageBase{
                 case 3: // reserved
                     Log.w(LOG_TAG, "1 - Unsupported SMS data coding scheme "
                             + (dataCodingScheme & 0xff));
-                    encodingType = ENCODING_8BIT;
+                    if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+                        Log.w(LOG_TAG, "Korean SIM, using KSC5601 for decoding.");
+                        encodingType = ENCODING_KSC5601;
+                    } else {
+                        encodingType = ENCODING_8BIT;
+                    }
                     break;
                 }
             }
@@ -1045,6 +1081,10 @@ public class SmsMessage extends SmsMessageBase{
         } else {
             Log.w(LOG_TAG, "3 - Unsupported SMS data coding scheme "
                     + (dataCodingScheme & 0xff));
+            if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+                Log.w(LOG_TAG, "Korean SIM, using KSC5601 for decoding.");
+                encodingType = ENCODING_KSC5601;
+            }
         }
 
         // set both the user data and the user data header.
@@ -1068,6 +1108,10 @@ public class SmsMessage extends SmsMessageBase{
         case ENCODING_16BIT:
             messageBody = p.getUserDataUCS2(count);
             break;
+
+        case ENCODING_KSC5601:
+            messageBody = p.getUserDataKSC5601(count);
+            break;
         }
 
         if (Config.LOGV) Log.v(LOG_TAG, "SMS message body (raw): '" + messageBody + "'");
diff --git a/telephony/java/com/android/internal/telephony/gsm/SpnOverride.java b/telephony/java/com/android/internal/telephony/gsm/SpnOverride.java
index 918c2d2..eec203e 100644
--- a/telephony/java/com/android/internal/telephony/gsm/SpnOverride.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SpnOverride.java
@@ -21,6 +21,7 @@ import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.util.HashMap;
+import java.util.Locale;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
@@ -32,23 +33,37 @@ import android.util.Xml;
 import com.android.internal.util.XmlUtils;
 
 public class SpnOverride {
-    private HashMap<String, String> CarrierSpnMap;
+    private HashMap<String, HashMap<String, String>> mCarrierLocaleSpnMap;
 
 
     static final String LOG_TAG = "GSM";
     static final String PARTNER_SPN_OVERRIDE_PATH ="etc/spn-conf.xml";
 
     SpnOverride () {
-        CarrierSpnMap = new HashMap<String, String>();
+        mCarrierLocaleSpnMap = new HashMap<String, HashMap<String, String>>();
         loadSpnOverrides();
     }
 
     boolean containsCarrier(String carrier) {
-        return CarrierSpnMap.containsKey(carrier);
+        return mCarrierLocaleSpnMap.containsKey(carrier);
     }
 
     String getSpn(String carrier) {
-        return CarrierSpnMap.get(carrier);
+        return getSpn(carrier, Locale.ROOT);
+    }
+
+    String getSpn(String carrier, Locale locale) {
+        HashMap<String, String> localeSpnMap;
+        String localeKey;
+
+        if (carrier == null || locale == null || !containsCarrier(carrier) ||
+                (localeSpnMap = mCarrierLocaleSpnMap.get(carrier)) == null ||
+                !localeSpnMap.containsKey(localeKey = locale.toString()) &&
+                !localeSpnMap.containsKey(localeKey = locale.getLanguage())) {
+            return null;
+        }
+
+        return localeSpnMap.get(localeKey);
     }
 
     private void loadSpnOverrides() {
@@ -70,19 +85,42 @@ public class SpnOverride {
             parser.setInput(spnReader);
 
             XmlUtils.beginDocument(parser, "spnOverrides");
+            XmlUtils.nextElement(parser);
 
             while (true) {
-                XmlUtils.nextElement(parser);
-
                 String name = parser.getName();
                 if (!"spnOverride".equals(name)) {
                     break;
                 }
 
                 String numeric = parser.getAttributeValue(null, "numeric");
-                String data    = parser.getAttributeValue(null, "spn");
 
-                CarrierSpnMap.put(numeric, data);
+                if (numeric == null || "".equals(numeric)) {
+                    XmlUtils.nextElement(parser);
+                    while ("spn".equals(parser.getName())) {
+                        XmlUtils.nextElement(parser);
+                    }
+                } else {
+                    HashMap<String, String> localeSpnMap = new HashMap<String, String>();
+                    localeSpnMap.put("", parser.getAttributeValue(null, "spn"));
+
+                    while (true) {
+                        XmlUtils.nextElement(parser);
+
+                        if (!"spn".equals(parser.getName())) {
+                            break;
+                        }
+
+                        String locale = parser.getAttributeValue(null, "locale");
+                        String spn = parser.nextText();
+
+                        if (locale != null && !"".equals(locale)) {
+                            localeSpnMap.put(locale, spn);
+                        }
+                    }
+
+                    mCarrierLocaleSpnMap.put(numeric, localeSpnMap);
+                }
             }
         } catch (XmlPullParserException e) {
             Log.w(LOG_TAG, "Exception in spn-conf parser " + e);
diff --git a/telephony/java/com/android/internal/telephony/gsm/SuppServiceNotification.java b/telephony/java/com/android/internal/telephony/gsm/SuppServiceNotification.java
index e68655e..200f0b1 100644
--- a/telephony/java/com/android/internal/telephony/gsm/SuppServiceNotification.java
+++ b/telephony/java/com/android/internal/telephony/gsm/SuppServiceNotification.java
@@ -35,6 +35,9 @@ public class SuppServiceNotification {
     /** TS 27.007 7.17 "number" (MT only) */
     public String number;
 
+    static public final int NOTIFICATION_TYPE_MO = 0;
+    static public final int NOTIFICATION_TYPE_MT = 1;
+
     static public final int MO_CODE_UNCONDITIONAL_CF_ACTIVE     = 0;
     static public final int MO_CODE_SOME_CF_ACTIVE              = 1;
     static public final int MO_CODE_CALL_FORWARDED              = 2;
diff --git a/telephony/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java b/telephony/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
old mode 100644
new mode 100755
index 6458fda..ec3d20a
--- a/telephony/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
+++ b/telephony/java/com/android/internal/telephony/gsm/UsimPhoneBookManager.java
@@ -53,6 +53,7 @@ public class UsimPhoneBookManager extends Handler implements IccConstants {
     private ArrayList<byte[]> mIapFileRecord;
     private ArrayList<byte[]> mEmailFileRecord;
     private Map<Integer, ArrayList<String>> mEmailsForAdnRec;
+    private boolean mRefreshCache = false;
 
     private static final int EVENT_PBR_LOAD_DONE = 1;
     private static final int EVENT_USIM_ADN_LOAD_DONE = 2;
@@ -91,11 +92,19 @@ public class UsimPhoneBookManager extends Handler implements IccConstants {
         mEmailFileRecord = null;
         mPbrFile = null;
         mIsPbrPresent = true;
+        mRefreshCache = false;
     }
 
     public ArrayList<AdnRecord> loadEfFilesFromUsim() {
         synchronized (mLock) {
-            if (!mPhoneBookRecords.isEmpty()) return mPhoneBookRecords;
+            if (!mPhoneBookRecords.isEmpty()) {
+                if (mRefreshCache) {
+                    mRefreshCache = false;
+                    refreshCache();
+                }
+                return mPhoneBookRecords;
+            }
+
             if (!mIsPbrPresent) return null;
 
             // Check if the PBR file is present in the cache, if not read it
@@ -116,6 +125,20 @@ public class UsimPhoneBookManager extends Handler implements IccConstants {
         return mPhoneBookRecords;
     }
 
+    private void refreshCache() {
+        if (mPbrFile == null) return;
+        mPhoneBookRecords.clear();
+
+        int numRecs = mPbrFile.mFileIds.size();
+        for (int i = 0; i < numRecs; i++) {
+            readAdnFileAndWait(i);
+        }
+    }
+
+    public void invalidateCache() {
+        mRefreshCache = true;
+    }
+
     private void readPbrFileAndWait() {
         mPhone.getIccFileHandler().loadEFLinearFixedAll(EF_PBR, obtainMessage(EVENT_PBR_LOAD_DONE));
         try {
diff --git a/telephony/java/com/android/internal/telephony/gsm/stk/CommandDetails.java b/telephony/java/com/android/internal/telephony/gsm/stk/CommandDetails.java
index e81ff98..8c841f0 100644
--- a/telephony/java/com/android/internal/telephony/gsm/stk/CommandDetails.java
+++ b/telephony/java/com/android/internal/telephony/gsm/stk/CommandDetails.java
@@ -48,13 +48,14 @@ class CommandDetails extends ValueObject implements Parcelable {
     }
 
     public CommandDetails(Parcel in) {
-        compRequired = true;
+        compRequired = in.readInt() != 0;
         commandNumber = in.readInt();
         typeOfCommand = in.readInt();
         commandQualifier = in.readInt();
     }
 
     public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(compRequired ? 1 : 0);
         dest.writeInt(commandNumber);
         dest.writeInt(typeOfCommand);
         dest.writeInt(commandQualifier);
@@ -103,4 +104,4 @@ class ItemsIconId extends ValueObject {
     ComprehensionTlvTag getTag() {
         return ComprehensionTlvTag.ITEM_ICON_ID_LIST;
     }
-}
\ No newline at end of file
+}
diff --git a/telephony/java/com/android/internal/telephony/sip/SipPhone.java b/telephony/java/com/android/internal/telephony/sip/SipPhone.java
old mode 100755
new mode 100644
index 461e4fb..e37afda
--- a/telephony/java/com/android/internal/telephony/sip/SipPhone.java
+++ b/telephony/java/com/android/internal/telephony/sip/SipPhone.java
@@ -41,6 +41,7 @@ import com.android.internal.telephony.UUSInfo;
 
 import java.text.ParseException;
 import java.util.List;
+import java.util.regex.Pattern;
 
 /**
  * {@hide}
@@ -383,8 +384,8 @@ public class SipPhone extends SipPhoneBase {
         Connection dial(String originalNumber) throws SipException {
             String calleeSipUri = originalNumber;
             if (!calleeSipUri.contains("@")) {
-                calleeSipUri = mProfile.getUriString().replaceFirst(
-                        mProfile.getUserName() + "@",
+                String replaceStr = Pattern.quote(mProfile.getUserName() + "@");
+                calleeSipUri = mProfile.getUriString().replaceFirst(replaceStr,
                         calleeSipUri + "@");
             }
             try {
diff --git a/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java b/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java
index 8a4a285..5511c09 100644
--- a/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java
+++ b/telephony/tests/telephonytests/src/com/android/internal/telephony/AdnRecordTest.java
@@ -170,6 +170,18 @@ public class AdnRecordTest extends TestCase {
         assertEquals("Adgjm", adn.getAlphaTag());
         assertEquals("+18885551212,12345678", adn.getNumber());
         assertFalse(adn.isEmpty());
+
+        //
+        // Test that a ADN record with KSC5601 will get converted correctly
+        // This test will only be run when using a Korean SIM
+        //
+        if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+            adn = new AdnRecord(IccUtils.hexStringToBytes(
+                  "3030312C20C8AB41B1E6FFFFFFFFFFFF07811010325476F8FFFFFFFFFFFF"));
+            assertEquals("001, \uD64DA\uAE38", adn.getAlphaTag());
+            assertEquals("01012345678", adn.getNumber());
+            assertFalse(adn.isEmpty());
+        }
     }
 }
 
diff --git a/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java b/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java
index 8a66614..f578a8d 100644
--- a/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java
+++ b/telephony/tests/telephonytests/src/com/android/internal/telephony/SMSDispatcherTest.java
@@ -102,4 +102,25 @@ public class SMSDispatcherTest extends AndroidTestCase {
        sms = SmsMessage.createFromEfRecord(1, data);
        assertNotNull(sms.getMessageBody());
     }
+
+    @MediumTest
+    public void testEfRecordKorean() throws Exception {
+        if (SimRegionCache.getRegion() == SimRegionCache.MCC_KOREAN) {
+            SmsMessage sms;
+
+            String s = "01089128010099010259040ba11000000000f00095013091900563008c4142"
+                     + "434445b0a1b3aab4d9b6f3b8b631323334354142434445b0a1b3aab4d9b6f3"
+                     + "b8b631323334354142434445b0a1b3aab4d9b6f3b8b6313233343541424344"
+                     + "45b0a1b3aab4d9b6f3b8b63132333435000000000000000000000000000000"
+                     + "00000000000000000000000000000000000000000000000000000000000000"
+                     + "0000000000000000000000000000ffffffffffffff";
+
+
+           byte[] data = IccUtils.hexStringToBytes(s);
+
+           sms = SmsMessage.createFromEfRecord(1, data);
+           assertNotNull(sms.getMessageBody());
+           assertTrue(sms.getMessageBody().startsWith("ABCDE\uAC00\uB098\uB2E4\uB77C\uB9C812345ABCDE"));
+        }
+    }
 }
diff --git a/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java b/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java
index db38ede..0502636 100644
--- a/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java
+++ b/telephony/tests/telephonytests/src/com/android/internal/telephony/SimUtilsTest.java
@@ -82,6 +82,30 @@ public class SimUtilsTest extends TestCase {
         data = IccUtils.hexStringToBytes("820505302D82d32d31");
         // Example from 3GPP TS 11.11 V18.1.3.0 annex B
         assertEquals("-\u0532\u0583-1", IccUtils.adnStringFieldToString(data, 0, data.length));
+
+        /*
+         * adnStringFieldToStringKsc5601Support()
+         * Tests equal the ones above, and will only be run if the SIM is NOT korean.
+         */
+
+        if (SimRegionCache.getRegion() != SimRegionCache.MCC_KOREAN) {
+            data = IccUtils.hexStringToBytes("00566f696365204d61696c07918150367742f3ffffffffffff");
+            // Again, skip prepended 0
+            // (this is an EF[ADN] record)
+            assertEquals("Voice Mail", IccUtils.adnStringFieldToStringKsc5601Support(data, 1, data.length - 15));
+
+            data = IccUtils.hexStringToBytes("809673539A5764002F004DFFFFFFFFFF");
+            // (this is from an EF[ADN] record)
+            assertEquals("\u9673\u539A\u5764/M", IccUtils.adnStringFieldToStringKsc5601Support(data, 0, data.length));
+
+            data = IccUtils.hexStringToBytes("810A01566fec6365204de0696cFFFFFF");
+            // (this is made up to test since I don't have a real one)
+            assertEquals("Vo\u00ECce M\u00E0il", IccUtils.adnStringFieldToStringKsc5601Support(data, 0, data.length));
+
+            data = IccUtils.hexStringToBytes("820505302D82d32d31");
+            // Example from 3GPP TS 11.11 V18.1.3.0 annex B
+            assertEquals("-\u0532\u0583-1", IccUtils.adnStringFieldToStringKsc5601Support(data, 0, data.length));
+        }
     }
 
 }
diff --git a/tools/aapt/Android.mk b/tools/aapt/Android.mk
index 094b7db..d885883 100644
--- a/tools/aapt/Android.mk
+++ b/tools/aapt/Android.mk
@@ -25,7 +25,7 @@ LOCAL_SRC_FILES := \
     ZipFile.cpp
 
 
-LOCAL_CFLAGS += -Wno-format-y2k
+LOCAL_CFLAGS += -Wno-format-y2k -fpermissive
 
 LOCAL_C_INCLUDES += external/expat/lib
 LOCAL_C_INCLUDES += external/libpng
-- 
1.8.3.2

